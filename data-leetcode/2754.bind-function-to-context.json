[
    {
        "title": "Row With Maximum Ones",
        "question_content": "Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.\n&nbsp;\nExample 1:\n\nInput: mat = [[0,1],[1,0]]\nOutput: [0,1]\nExplanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1]. \n\nExample 2:\n\nInput: mat = [[0,0,0],[0,1,1]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].\n\nExample 3:\n\nInput: mat = [[0,0],[1,1],[0,0]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].\n\n&nbsp;\nConstraints:\n\n\tm == mat.length&nbsp;\n\tn == mat[i].length&nbsp;\n\t1 <= m, n <= 100&nbsp;\n\tmat[i][j] is either 0 or 1.",
        "solutions": [
            {
                "id": 3421712,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int val=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    val++;\\n                }\\n            }\\n            if(val>max)\\n            {\\n                index=i;\\n                max=val;\\n            }\\n        }\\n        return new int[]{index,max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int val=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    val++;\\n                }\\n            }\\n            if(val>max)\\n            {\\n                index=i;\\n                max=val;\\n            }\\n        }\\n        return new int[]{index,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421887,
                "title": "easy-solution-with-explaination",
                "content": "# Intuition\\nThe basic idea is to iterate over all rows of the matrix, and count the number of ones in each row. We keep track of the row with the maximum count of ones seen so far, and update it whenever we find a row with a larger count.\\n\\n# Approach\\nTo count the number of ones in a row, we simply iterate over all elements of the row and add up the ones.\\n\\nFinally, we return the index of the row with the maximum count of ones, along with the count itself, as a vector of two integers. If there are multiple rows with the maximum count, we return the one with the smallest row number, which is the first one encountered in the loop.\\n\\n# Complexity\\n- Time complexity:\\nThe solution has a time complexity of O(mn), which is the size of the matrix, since we need to iterate over all its elements. This is optimal, since we need to examine all rows and elements to determine the maximum count of ones.\\n\\n- Space complexity:\\nSpace complexity is O(1), since we aren\\'t using any extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int maxCount = 0;\\n        int maxRow = 0;\\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                count += mat[i][j];\\n            }\\n            if (count > maxCount) {\\n                maxCount = count;\\n                maxRow = i;\\n            }\\n        }\\n        return {maxRow, maxCount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int maxCount = 0;\\n        int maxRow = 0;\\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                count += mat[i][j];\\n            }\\n            if (count > maxCount) {\\n                maxCount = count;\\n                maxRow = i;\\n            }\\n        }\\n        return {maxRow, maxCount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421854,
                "title": "easiest-solution-python3",
                "content": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:    \\n        ones = 0 \\n        index = 0\\n        for it, row in enumerate(mat):\\n            c = row.count(1)\\n            if ones < c:\\n                ones = c\\n                index = it\\n        \\n        return [index,ones]\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:    \\n        ones = 0 \\n        index = 0\\n        for it, row in enumerate(mat):\\n            c = row.count(1)\\n            if ones < c:\\n                ones = c\\n                index = it\\n        \\n        return [index,ones]\\n",
                "codeTag": "Java"
            },
            {
                "id": 3421700,
                "title": "c-bruteforce",
                "content": "**Count Ones in each row and update the answer**\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        //         {index,frequency}\\n        vector<int> res{-1, -1};\\n        for(int i = 0; i < mat.size(); ++i){\\n            int one = count(mat[i].begin(), mat[i].end(), 1);\\n            if(one > res[1])\\n                res = {i, one};\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        //         {index,frequency}\\n        vector<int> res{-1, -1};\\n        for(int i = 0; i < mat.size(); ++i){\\n            int one = count(mat[i].begin(), mat[i].end(), 1);\\n            if(one > res[1])\\n                res = {i, one};\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422458,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2);\\n        int ones = 0;\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                if(mat[i][j] == 1) ones++;\\n            }\\n            if(ones > ans[1]) {\\n                ans[0] = i;\\n                ans[1] = ones;\\n            }\\n            ones = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2);\\n        int ones = 0;\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                if(mat[i][j] == 1) ones++;\\n            }\\n            if(ones > ans[1]) {\\n                ans[0] = i;\\n                ans[1] = ones;\\n            }\\n            ones = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421881,
                "title": "simple-java-easy-explanation",
                "content": "# Intuition\\n\\nA straightforward method is to iterate through each row of the array and count the number of ones in each row. We can then keep track of the maximum number of ones seen so far and the index of the row with the maximum number of ones. At the end, we can return the index of the row with the maximum number of ones.\\n\\nTo implement this, we use two nested loops and one variable:\\n\\n\\u2022 \\'rowCount\\' to track the count of 1\\'s in each row.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n\\n# Complexity\\n- Time complexity:  O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i=0; i<mat.length; i++){\\n            int rowCount = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    rowCount++;\\n                }\\n            }\\n            if(rowCount > arr[1]){\\n                arr[1] = rowCount;\\n                arr[0] = i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i=0; i<mat.length; i++){\\n            int rowCount = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    rowCount++;\\n                }\\n            }\\n            if(rowCount > arr[1]){\\n                arr[1] = rowCount;\\n                arr[0] = i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421837,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxVal=0,ind=-1,c=0;\\n        \\n        for(int i=0;i<mat.size();i++){\\n            c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]){\\n                    c++;\\n                }\\n            }\\n            if(c > maxVal){\\n                maxVal = c;\\n                ind=i;\\n            }\\n        }\\n        if(ind==-1){\\n            return vector<int> {0,0};\\n        }\\n        return vector<int> {ind,maxVal};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxVal=0,ind=-1,c=0;\\n        \\n        for(int i=0;i<mat.size();i++){\\n            c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]){\\n                    c++;\\n                }\\n            }\\n            if(c > maxVal){\\n                maxVal = c;\\n                ind=i;\\n            }\\n        }\\n        if(ind==-1){\\n            return vector<int> {0,0};\\n        }\\n        return vector<int> {ind,maxVal};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421675,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[]=new int[2];\\n        int max=0;\\n        int ind=0;\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ind=i;\\n            }\\n        }\\n        ans[0]=ind;\\n        ans[1]=max;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[]=new int[2];\\n        int max=0;\\n        int ind=0;\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ind=i;\\n            }\\n        }\\n        ans[0]=ind;\\n        ans[1]=max;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510886,
                "title": "python-go-easy-solution",
                "content": "# Python\\u2705\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        output = [0,0]\\n        for index, item in enumerate(mat):\\n            one_count = item.count(1)\\n            if one_count > output[1]:\\n                output[0] = index\\n                output[1] = one_count\\n        return output\\n\\n```\\n# Go\\u2705\\n```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    output := []int{0,0}\\n    for index, item := range mat {\\n        oneCount := 0\\n        for _, v := range item {\\n            if v == 1{\\n                oneCount++\\n            }\\n        }\\n        if oneCount > output[1] {\\n            output[0] = index\\n            output[1] = oneCount\\n        }\\n    }\\n    return output\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        output = [0,0]\\n        for index, item in enumerate(mat):\\n            one_count = item.count(1)\\n            if one_count > output[1]:\\n                output[0] = index\\n                output[1] = one_count\\n        return output\\n\\n```\n```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    output := []int{0,0}\\n    for index, item := range mat {\\n        oneCount := 0\\n        for _, v := range item {\\n            if v == 1{\\n                oneCount++\\n            }\\n        }\\n        if oneCount > output[1] {\\n            output[0] = index\\n            output[1] = oneCount\\n        }\\n    }\\n    return output\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503602,
                "title": "simple-sort-solution",
                "content": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        list1=[]\\n        for ind,row in enumerate(mat):\\n            list1.append([ind,row.count(1)])\\n        list1.sort(key=lambda x:[-x[1],x[0]])\\n        return list1[0]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        list1=[]\\n        for ind,row in enumerate(mat):\\n            list1.append([ind,row.count(1)])\\n        list1.sort(key=lambda x:[-x[1],x[0]])\\n        return list1[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459775,
                "title": "java-easy-soln-o-row-col",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat){\\n        int ans[]=new int [2];\\n        int maxSum=0;\\n        int row=0;\\n        for(int i=0;i<mat.length;i++){\\n            int sum=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]!=0) sum+=1;\\n                }\\n                if(sum>maxSum){\\n                maxSum=sum;\\n                row=i;\\n            }\\n            }\\n        ans[0]=row;\\n        ans[1]=maxSum;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat){\\n        int ans[]=new int [2];\\n        int maxSum=0;\\n        int row=0;\\n        for(int i=0;i<mat.length;i++){\\n            int sum=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]!=0) sum+=1;\\n                }\\n                if(sum>maxSum){\\n                maxSum=sum;\\n                row=i;\\n            }\\n            }\\n        ans[0]=row;\\n        ans[1]=maxSum;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423453,
                "title": "java-6ms-beats-85-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int index=0;\\n        int maxOne=0;\\n        \\n        for(int i=0; i<mat.length; i++){\\n            int rowOnes=0;\\n//to count the number of ones in each row\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1) rowOnes++;\\n            }\\n            if(rowOnes>maxOne){\\n//checking whether the number of ones if maximum till now and updatng its value\\n                index=i;\\n                maxOne=rowOnes;\\n            }\\n        }\\n        \\n//creating a new array and returning it with the row number and number of ones in it\\n        return new int[]{index,maxOne};\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int index=0;\\n        int maxOne=0;\\n        \\n        for(int i=0; i<mat.length; i++){\\n            int rowOnes=0;\\n//to count the number of ones in each row\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1) rowOnes++;\\n            }\\n            if(rowOnes>maxOne){\\n//checking whether the number of ones if maximum till now and updatng its value\\n                index=i;\\n                maxOne=rowOnes;\\n            }\\n        }\\n        \\n//creating a new array and returning it with the row number and number of ones in it\\n        return new int[]{index,maxOne};\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421932,
                "title": "easy-solution-go-c",
                "content": "Initialize variables c and m to 0. c represents the index of the row with the maximum count of ones, and m represents the number of ones in that row.\\n\\nIterate over each row i in the matrix using a for loop. For each row i, initialize a temporary variable temp to 0, which will count the number of ones in the row.\\n\\nIterate over each column j in the current row i using another for loop. For each cell in the row, if the value is 1, increment the value of temp by 1.\\n\\nCompare the value of temp with the current maximum count of ones m. If temp is greater than m, update the values of c and m to the current row i and the number of ones in the row temp, respectively.\\n\\nOnce all rows have been iterated, return an array containing the index of the row with the maximum count of ones c and the number of ones in that row m.\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nGo\\n```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    var c, m int\\n\\n    for i := 0; i < len(mat); i++ {\\n        temp := 0\\n        for j := 0; j < len(mat[i]); j++ {\\n            if mat[i][j] == 1 {\\n                temp++\\n            }\\n        }\\n\\n        if temp > m {\\n            m = temp\\n            c = i\\n        }\\n    }\\n\\n    return []int{c, m}\\n}\\n\\n```\\nC#\\n```\\npublic class Solution {\\n    public int[] RowAndMaximumOnes(int[][] mat) {\\n        var c = 0;\\n        var m = 0;\\n\\n        for (var i = 0; i < mat.Length; i++)\\n        {\\n            var temp = 0;\\n            for (var j = 0; j < mat[i].Length; j++)\\n            {\\n                if (mat[i][j] == 1)\\n                {\\n                    temp++;\\n                }\\n            }\\n\\n            if (temp > m)\\n            {\\n                m = temp;\\n                c = i;\\n            }\\n        }\\n\\n        return new[] {c, m};\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go"
                ],
                "code": "```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    var c, m int\\n\\n    for i := 0; i < len(mat); i++ {\\n        temp := 0\\n        for j := 0; j < len(mat[i]); j++ {\\n            if mat[i][j] == 1 {\\n                temp++\\n            }\\n        }\\n\\n        if temp > m {\\n            m = temp\\n            c = i\\n        }\\n    }\\n\\n    return []int{c, m}\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int[] RowAndMaximumOnes(int[][] mat) {\\n        var c = 0;\\n        var m = 0;\\n\\n        for (var i = 0; i < mat.Length; i++)\\n        {\\n            var temp = 0;\\n            for (var j = 0; j < mat[i].Length; j++)\\n            {\\n                if (mat[i][j] == 1)\\n                {\\n                    temp++;\\n                }\\n            }\\n\\n            if (temp > m)\\n            {\\n                m = temp;\\n                c = i;\\n            }\\n        }\\n\\n        return new[] {c, m};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421897,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans = {0,0};\\n        int i,j,m=mat.size(),n=mat[0].size(),x;\\n        for(i = 0; i < m; i++){\\n            x = 0;\\n            for(j = 0; j < n; j++){\\n                x += mat[i][j];\\n            }\\n            if(x>ans[1]){\\n                ans = {i,x};\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans = {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3421891,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    countone++;\\n                }\\n        }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n             }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    countone++;\\n                }\\n        }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n             }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421778,
                "title": "clean-easy-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row=0, maxOnes=0;\\n        for(int i=0; i<mat.length; i++){\\n            int ones = 0;\\n            for(int j=0; j<mat[0].length; j++)\\n                if(mat[i][j] == 1) ones++;\\n            if(maxOnes < ones){\\n                row = i;\\n                maxOnes = ones;\\n            }\\n        }\\n        return new int[]{row,maxOnes};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row=0, maxOnes=0;\\n        for(int i=0; i<mat.length; i++){\\n            int ones = 0;\\n            for(int j=0; j<mat[0].length; j++)\\n                if(mat[i][j] == 1) ones++;\\n            if(maxOnes < ones){\\n                row = i;\\n                maxOnes = ones;\\n            }\\n        }\\n        return new int[]{row,maxOnes};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044301,
                "title": "beats-100-beginner-friendly-approach-using-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int count, ansY=0, ansX=0;\\n        for(int i=0; i<mat.size();i++){\\n            count = 0;\\n            for(int j=0; j<mat[0].size();j++){\\n              count+=mat[i][j];\\n            }\\n            if(count>ansY){\\n                ansY=count;\\n                ansX=i;\\n            }\\n        }\\n\\n        return {ansX,ansY};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int count, ansY=0, ansX=0;\\n        for(int i=0; i<mat.size();i++){\\n            count = 0;\\n            for(int j=0; j<mat[0].size();j++){\\n              count+=mat[i][j];\\n            }\\n            if(count>ansY){\\n                ansY=count;\\n                ansX=i;\\n            }\\n        }\\n\\n        return {ansX,ansY};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596424,
                "title": "simple-brute-force-approach-tc-o-m-n-sc-o-1",
                "content": "\\n\\n# Approach\\nUse Nested loops & traverse on the complete matrix & just check the conditions & maitain the maxi variable\\n\\n# Complexity\\n- Time complexity: O( m*n )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n        int m = matrix.size(); // no. of rows\\n        int n = matrix[0].size(); //no. of column\\n        int maxi = 0 , cnt =0;\\n        int index = 0; // if no row found still retrun 0\\n        for(int i =0 ; i<m ;i++){\\n               cnt = 0;\\n            for(int j =0 ;j<n; j++){\\n                if(matrix[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > maxi ){\\n                index = i;\\n            }\\n            maxi = max(maxi, cnt);\\n          \\n        }\\n    \\n    return {index , maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n        int m = matrix.size(); // no. of rows\\n        int n = matrix[0].size(); //no. of column\\n        int maxi = 0 , cnt =0;\\n        int index = 0; // if no row found still retrun 0\\n        for(int i =0 ; i<m ;i++){\\n               cnt = 0;\\n            for(int j =0 ;j<n; j++){\\n                if(matrix[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > maxi ){\\n                index = i;\\n            }\\n            maxi = max(maxi, cnt);\\n          \\n        }\\n    \\n    return {index , maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478298,
                "title": "easy-beginner-friendly-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int res = 0, mx = 0;\\n        for(int i = 0 ; i < mat.size() ; i++) {\\n            int one = 0;\\n            for(int j = 0 ; j < mat[0].size() ; j++) one += (mat[i][j] == 1);\\n            if(one > mx) {\\n                mx = one;\\n                res = i;\\n            }\\n        }\\n        return {res, mx};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int res = 0, mx = 0;\\n        for(int i = 0 ; i < mat.size() ; i++) {\\n            int one = 0;\\n            for(int j = 0 ; j < mat[0].size() ; j++) one += (mat[i][j] == 1);\\n            if(one > mx) {\\n                mx = one;\\n                res = i;\\n            }\\n        }\\n        return {res, mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431777,
                "title": "dfs-solution-different-approach-full-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe dfs function is a helper function that performs a depth-first search (DFS) traversal on the input matrix mat starting from the cell at index (i, j). It uses recursion to explore neighboring cells in the matrix and counts the number of 1s encountered. It also marks the visited cells by setting their value to -1. This function updates the count parameter by reference, which keeps track of the number of 1s encountered during the traversal.\\n\\nThe rowAndMaximumOnes function is the main function that solves the problem. It takes a 2D vector mat as input, representing the matrix of 0s and 1s. The goal is to find the row in the matrix that contains the maximum number of 1s, and return that row index along with the count of 1s in that row.\\n\\nThe function iterates through the cells of the matrix using nested for-loops. For each cell that contains a 1, it calls the dfs function to count the number of 1s in the connected component of that 1. It keeps track of the maximum count of 1s encountered and the corresponding row index. It also uses some additional variables, such as prevCount and prevRow, to optimize the DFS traversal by reusing the count from the previous row if the current row is the same as the previous row. Finally, the function returns the row index and the maximum count of 1s as a vector of two integers.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& mat,int i,int j,int &count){\\n\\n        if(i>=mat.size() || i<0 || j>=mat[0].size() || j<0){\\n            return;\\n        }\\n        if(mat[i][j]==1){\\n\\n            mat[i][j]=-1;\\n            count++;\\n            dfs(mat,i,j+1,count);\\n            dfs(mat,i,j-1,count);\\n        }\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCountRow,maxCount=0;\\n        int prevCount=0;\\n        int prevRow=-1;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    int count=0;\\n                    if(i==prevRow){\\n                        count = prevCount;\\n                    }\\n                    \\n                    dfs(mat,i,j,count);\\n                    if(count>maxCount){ maxCount=count; maxCountRow=i;}\\n                    prevCount=count;\\n                    prevRow = i;\\n                }\\n            }\\n        }\\n\\n        return {maxCountRow,maxCount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& mat,int i,int j,int &count){\\n\\n        if(i>=mat.size() || i<0 || j>=mat[0].size() || j<0){\\n            return;\\n        }\\n        if(mat[i][j]==1){\\n\\n            mat[i][j]=-1;\\n            count++;\\n            dfs(mat,i,j+1,count);\\n            dfs(mat,i,j-1,count);\\n        }\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCountRow,maxCount=0;\\n        int prevCount=0;\\n        int prevRow=-1;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    int count=0;\\n                    if(i==prevRow){\\n                        count = prevCount;\\n                    }\\n                    \\n                    dfs(mat,i,j,count);\\n                    if(count>maxCount){ maxCount=count; maxCountRow=i;}\\n                    prevCount=count;\\n                    prevRow = i;\\n                }\\n            }\\n        }\\n\\n        return {maxCountRow,maxCount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427083,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row=0\\n        value=0\\n        for i,j in enumerate(mat):\\n            one=j.count(1)\\n            if one>value:\\n                value=one\\n                row=i\\n        return [row, value]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row=0\\n        value=0\\n        for i,j in enumerate(mat):\\n            one=j.count(1)\\n            if one>value:\\n                value=one\\n                row=i\\n        return [row, value]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423064,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.into_iter().enumerate() {\\n            let ones = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if ones > res[1] {\\n                res[0] = i as i32;\\n                res[1] = ones;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.into_iter().enumerate() {\\n            let ones = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if ones > res[1] {\\n                res[0] = i as i32;\\n                res[1] = ones;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422647,
                "title": "python3-solutions-with-explanation-enumeration-numpy",
                "content": "\\u0421ount ones within rows and update index if number of ones exceeds current maximum\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row_idx, max_ones = 0, 0\\n    \\n        for idx, row in enumerate(mat):\\n            cur_ones = sum(row)\\n\\n            if cur_ones > max_ones:\\n                row_idx, max_ones = idx, cur_ones\\n\\n        return [row_idx, max_ones]\\n```\\nI would say it is a slower version, but at least something different:\\n1) Find indices of elements within rows that contain ones\\n2) Count occurrences of these elements along the rows\\n3) If there are ones, we output the index of the row containing the maximum number of ones, otherwise we return zeros as index and maximum count ones\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        ones = np.where(np.array(mat) == 1)[0]\\n        counts = np.bincount(ones)\\n        \\n        return [np.argmax(counts), counts[np.argmax(counts)]] if sum(counts) else [0, 0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row_idx, max_ones = 0, 0\\n    \\n        for idx, row in enumerate(mat):\\n            cur_ones = sum(row)\\n\\n            if cur_ones > max_ones:\\n                row_idx, max_ones = idx, cur_ones\\n\\n        return [row_idx, max_ones]\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        ones = np.where(np.array(mat) == 1)[0]\\n        counts = np.bincount(ones)\\n        \\n        return [np.argmax(counts), counts[np.argmax(counts)]] if sum(counts) else [0, 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421883,
                "title": "c-easy-peasy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_count = 0;\\n        int max_row_index = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            if (count > max_count) {\\n                max_count = count;\\n                max_row_index = i;\\n            }\\n        }\\n        \\n        if (max_row_index == -1) {\\n            return {0, 0};\\n        }\\n        \\n        vector<int> result = {max_row_index, max_count};\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_count = 0;\\n        int max_row_index = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            if (count > max_count) {\\n                max_count = count;\\n                max_row_index = i;\\n            }\\n        }\\n        \\n        if (max_row_index == -1) {\\n            return {0, 0};\\n        }\\n        \\n        vector<int> result = {max_row_index, max_count};\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421864,
                "title": "c-linear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n*m)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        vector<int> ans(2,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n            if(mat[i][m-1]>ans[1]){\\n                ans[0]=i;\\n                ans[1]=mat[i][m-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        vector<int> ans(2,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n            if(mat[i][m-1]>ans[1]){\\n                ans[0]=i;\\n                ans[1]=mat[i][m-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421800,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            int countOne = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    countOne++;\\n                }\\n            }\\n            \\n            if(countOne > maxCount) {\\n                maxCount = countOne;\\n                index = i;\\n            }\\n        }\\n        return new int[] {index, maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            int countOne = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    countOne++;\\n                }\\n            }\\n            \\n            if(countOne > maxCount) {\\n                maxCount = countOne;\\n                index = i;\\n            }\\n        }\\n        return new int[] {index, maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037301,
                "title": "easy-solution-in-c-2beats-86-31-of-users-with-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n//initilize a vector to store answer to return mac row with max ones\\n        vector<int>ans;\\n//it store row with max ones\\n        int maxrow=-1;\\n//it store max number of ones in a row\\n        int maxones=-1;\\n        int row=mat.size();\\n        for(int i=0;i<row;i++){\\n//count max ones in a row\\n            int countones=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    countones++;\\n                }\\n            }\\n//compare the maxones with countones and update \\n            if(maxones<countones){\\n                maxones=countones;\\n                maxrow=i;\\n            }\\n        }\\n//push in a vector to return answer\\n        ans.push_back(maxrow);\\n        ans.push_back(maxones);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n//initilize a vector to store answer to return mac row with max ones\\n        vector<int>ans;\\n//it store row with max ones\\n        int maxrow=-1;\\n//it store max number of ones in a row\\n        int maxones=-1;\\n        int row=mat.size();\\n        for(int i=0;i<row;i++){\\n//count max ones in a row\\n            int countones=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    countones++;\\n                }\\n            }\\n//compare the maxones with countones and update \\n            if(maxones<countones){\\n                maxones=countones;\\n                maxrow=i;\\n            }\\n        }\\n//push in a vector to return answer\\n        ans.push_back(maxrow);\\n        ans.push_back(maxones);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927224,
                "title": "easy-solution-for-begginer-fast-than-90-18-best-memory-than-99-14",
                "content": "![Screenshot_307.png](https://assets.leetcode.com/users/images/13fcd1a5-36fc-46f8-9070-42c6b3c3ae79_1692366483.620762.png)\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxValue = 0\\n        index = 0\\n        for m in range(len(mat)):\\n            sumN = 0\\n            sumN = sum(mat[m])\\n            if sumN > maxValue:\\n                index =  m\\n            maxValue=max(maxValue,sumN)\\n        return [index,maxValue]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxValue = 0\\n        index = 0\\n        for m in range(len(mat)):\\n            sumN = 0\\n            sumN = sum(mat[m])\\n            if sumN > maxValue:\\n                index =  m\\n            maxValue=max(maxValue,sumN)\\n        return [index,maxValue]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806426,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        Map<Integer,Integer>hash=new HashMap<>();\\n          int [] arr=new int[2];\\n\\n       for(int i=0;i<mat.length;i++){\\n           int max=0;\\n           for(int j=0;j<mat[i].length;j++){\\n                max+=mat[i][j];\\n           }\\n           hash.put(i,max);\\n       }\\n       int ind=0;\\n       int val=Integer.MIN_VALUE;;\\n        for(int i=0;i<hash.size();i++){\\n            if(val<hash.get(i)){\\n                val=hash.get(i);\\n                ind=i;\\n            }\\n        }\\narr[0]=ind;\\narr[1]=val;\\n               return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        Map<Integer,Integer>hash=new HashMap<>();\\n          int [] arr=new int[2];\\n\\n       for(int i=0;i<mat.length;i++){\\n           int max=0;\\n           for(int j=0;j<mat[i].length;j++){\\n                max+=mat[i][j];\\n           }\\n           hash.put(i,max);\\n       }\\n       int ind=0;\\n       int val=Integer.MIN_VALUE;;\\n        for(int i=0;i<hash.size();i++){\\n            if(val<hash.get(i)){\\n                val=hash.get(i);\\n                ind=i;\\n            }\\n        }\\narr[0]=ind;\\narr[1]=val;\\n               return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802330,
                "title": "binary-search-method",
                "content": "# Intuition\\n**Binary Search**\\n\\n# Approach\\n- traverse through matrix \\n- count the no. of 1s present in it using binary search\\n- for Binary search I have used function , which first sorts the row and the searches for the 1st One [ 0 0 0 **1** 1 1 1] \\n- when the while loop ends , our low will be pointing to the 1st One index\\n- total number of 1s present. = (n-1)-low+1 ( same as length of the sliding window j-i+1)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n O(N * NlogN) // here this could be optimised if we use linear search ,    because in that we don\\'t requie to sort the row, which could save our **nlogn** time\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint noOfOnes(vector<int>&row,int n){\\n    if(n==1)return row[0]==1;\\n    int low =0;\\n    int high = n-1;\\n    sort(row.begin(),row.end());\\n\\n    while(low<=high){\\n        int mid = low+(high-low)/2;\\n\\n        if(row[mid]==1){\\n            high = mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return (n-1)-low+1;\\n}\\nvector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n   int max1=0;\\n   int indexOfMaxRow=0;\\n   int n= matrix.size();\\n       int m = matrix[0].size();\\n   for(int i=0;i<n;i++){\\n       int OneINThisRow = noOfOnes(matrix[i],m);\\n       if(OneINThisRow>max1){\\n           max1=OneINThisRow;\\n           indexOfMaxRow = i;\\n       }\\n   }\\n   return {indexOfMaxRow,max1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint noOfOnes(vector<int>&row,int n){\\n    if(n==1)return row[0]==1;\\n    int low =0;\\n    int high = n-1;\\n    sort(row.begin(),row.end());\\n\\n    while(low<=high){\\n        int mid = low+(high-low)/2;\\n\\n        if(row[mid]==1){\\n            high = mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return (n-1)-low+1;\\n}\\nvector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n   int max1=0;\\n   int indexOfMaxRow=0;\\n   int n= matrix.size();\\n       int m = matrix[0].size();\\n   for(int i=0;i<n;i++){\\n       int OneINThisRow = noOfOnes(matrix[i],m);\\n       if(OneINThisRow>max1){\\n           max1=OneINThisRow;\\n           indexOfMaxRow = i;\\n       }\\n   }\\n   return {indexOfMaxRow,max1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700572,
                "title": "row-with-maximum-ones-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum = 0;\\n        int index = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<mat.length; i++){\\n            count = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > sum){\\n                sum = count;\\n                index = i;\\n            }\\n        }\\n        int[] arr ={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum = 0;\\n        int index = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<mat.length; i++){\\n            count = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > sum){\\n                sum = count;\\n                index = i;\\n            }\\n        }\\n        int[] arr ={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692917,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1)\\n                    countone++;\\n                }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n                }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```\\n![leetcode upvote.jpg](https://assets.leetcode.com/users/images/4e3da845-1bff-4b18-b600-051d45d0cc61_1687953880.5652628.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1)\\n                    countone++;\\n                }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n                }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541374,
                "title": "simple-java-solution-for-beginners-2ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count;\\n        int maxCount = 0;\\n        int maxCountRow = 0;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                count += mat[i][j];\\n            }\\n            if(count > maxCount) {\\n                maxCount = count;\\n                maxCountRow = i;\\n            }\\n        }\\n        return new int[]{maxCountRow, maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count;\\n        int maxCount = 0;\\n        int maxCountRow = 0;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                count += mat[i][j];\\n            }\\n            if(count > maxCount) {\\n                maxCount = count;\\n                maxCountRow = i;\\n            }\\n        }\\n        return new int[]{maxCountRow, maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541346,
                "title": "simple-java-solution-for-beginners-5ms-beats-84-48",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int arr[] = new int[2];\\n        int count;\\n        int maxCount = Integer.MIN_VALUE;\\n        int maxCountIndex = -1;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            maxCountIndex = count > maxCount ? i : maxCountIndex;\\n            maxCount = Integer.max(count, maxCount);\\n        }\\n        arr[0] = maxCountIndex;\\n        arr[1] = maxCount;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int arr[] = new int[2];\\n        int count;\\n        int maxCount = Integer.MIN_VALUE;\\n        int maxCountIndex = -1;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            maxCountIndex = count > maxCount ? i : maxCountIndex;\\n            maxCount = Integer.max(count, maxCount);\\n        }\\n        arr[0] = maxCountIndex;\\n        arr[1] = maxCount;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519424,
                "title": "beginners-friendly-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    keep track of count of 1 for every row and \\n    update the row and max when we encounter greater count of 1 than \\n    previous\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0;\\n        int row=0;\\n        \\n\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) count++;\\n            }\\n            if(count>max){\\n                max= count;\\n                row=i;\\n            }\\n            \\n        }\\n\\n        return new int[] {row,max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0;\\n        int row=0;\\n        \\n\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) count++;\\n            }\\n            if(count>max){\\n                max= count;\\n                row=i;\\n            }\\n            \\n        }\\n\\n        return new int[] {row,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484456,
                "title": "python-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted([(ind,val.count(1)) for ind,val in enumerate(mat)],key=lambda x:[-x[1],x[0]])[0]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted([(ind,val.count(1)) for ind,val in enumerate(mat)],key=lambda x:[-x[1],x[0]])[0]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455090,
                "title": "easy-solution-with-javascript-just-checkout-how-much-it-s-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n**2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let ans=[-1,-1];\\n    let row=mat.length;\\n    let col=mat[0].length;\\n\\n    for(let i=0; i<row; i++){\\n        let zero=0;\\n        let ones=0;\\n        for(let j=0; j<col; j++){\\n            if(mat[i][j]==0){\\n                zero++;\\n            }else{\\n                ones++;\\n            }\\n        }\\n        let max=Math.max(ones, ans[1]);\\n        if(max>ans[1]){\\n            ans[0]=i;\\n            ans[1]=max;\\n        }\\n        \\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let ans=[-1,-1];\\n    let row=mat.length;\\n    let col=mat[0].length;\\n\\n    for(let i=0; i<row; i++){\\n        let zero=0;\\n        let ones=0;\\n        for(let j=0; j<col; j++){\\n            if(mat[i][j]==0){\\n                zero++;\\n            }else{\\n                ones++;\\n            }\\n        }\\n        let max=Math.max(ones, ans[1]);\\n        if(max>ans[1]){\\n            ans[0]=i;\\n            ans[1]=max;\\n        }\\n        \\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434594,
                "title": "rust-sum-approach",
                "content": "Sum all the values to count number of 1s as it is just 1s and 0s. No need to filter.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut ans: Vec<i32> = vec![0,0];\\n        for (i, row) in mat.iter().enumerate(){\\n            let mut count: i32 = row.iter().sum();\\n            if count > ans[1]{\\n                ans[1] = count;\\n                ans[0] = i as i32;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut ans: Vec<i32> = vec![0,0];\\n        for (i, row) in mat.iter().enumerate(){\\n            let mut count: i32 = row.iter().sum();\\n            if count > ans[1]{\\n                ans[1] = count;\\n                ans[0] = i as i32;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432302,
                "title": "easy-iteration-and-updation-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.For the counting the numbers of ones we have iterate in the matrix of rach row \\n2.then we have find the maximum value so we check by the comparision  if count of the one greater than max value then update\\n3.if it is equal then we have to we have to choose the min index value\\n \\nThis three points we have take in the mind\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple by iterating in the matrix finding count of ones and calculate the maximum count and we have to fing min value if its index if the count is same.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n^2)\\n\\n<b> Easy question of Leetcode give me self satisfaction\\uD83D\\uDE02\\uD83D\\uDE02\\n![Bom dia ,Boa tarde ,Boa noite.png](https://assets.leetcode.com/users/images/dad35698-7331-414e-8f1c-acd427e371a7_1681842257.8646004.png)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        count=0\\n        max1=0\\n        ind=0\\n        for i in range (len(mat)):\\n            for j in range (len(mat[0])):\\n                if mat[i][j]==1:\\n                    count+=1\\n            if count>max1:\\n                max1=count\\n                ind=i\\n            elif max1==count:\\n                ind=min(ind,i)\\n            count=0\\n                \\n        return [ind,max1]\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        count=0\\n        max1=0\\n        ind=0\\n        for i in range (len(mat)):\\n            for j in range (len(mat[0])):\\n                if mat[i][j]==1:\\n                    count+=1\\n            if count>max1:\\n                max1=count\\n                ind=i\\n            elif max1==count:\\n                ind=min(ind,i)\\n            count=0\\n                \\n        return [ind,max1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425963,
                "title": "counting-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& v) \\n    {\\n        int onecount = 0;\\n        int rowidx = 0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                if(v[i][j] == 1) count++;\\n            }\\n            if(onecount < count)\\n            {\\n                onecount = count;\\n                rowidx = i;\\n            }\\n        }\\n        return {rowidx ,onecount};    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& v) \\n    {\\n        int onecount = 0;\\n        int rowidx = 0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                if(v[i][j] == 1) count++;\\n            }\\n            if(onecount < count)\\n            {\\n                onecount = count;\\n                rowidx = i;\\n            }\\n        }\\n        return {rowidx ,onecount};    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424763,
                "title": "c-easy-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int cnt=0, pos=0;\\n        for (int i=0; i<mat.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<mat[0].size(); j++){\\n                if (mat[i][j]==1)curr++;\\n            }\\n            if (curr>cnt){\\n                cnt= curr;\\n                pos= i;\\n            }\\n        }\\n        return {pos,cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int cnt=0, pos=0;\\n        for (int i=0; i<mat.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<mat[0].size(); j++){\\n                if (mat[i][j]==1)curr++;\\n            }\\n            if (curr>cnt){\\n                cnt= curr;\\n                pos= i;\\n            }\\n        }\\n        return {pos,cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424612,
                "title": "no-explanation-required",
                "content": "\\n# Solution:\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0, row = 0;\\n        for (int i = 0; i < mat.length; i++) {\\n            int ct = 0;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                ct += mat[i][j];\\n            }\\n            if (ct > max) {\\n                max = ct;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, max};\\n    }\\n}\\n```\\n### Time complexity: $$O(nm)$$",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0, row = 0;\\n        for (int i = 0; i < mat.length; i++) {\\n            int ct = 0;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                ct += mat[i][j];\\n            }\\n            if (ct > max) {\\n                max = ct;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424231,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        indicies = []\\n        for r in range(len(mat)):\\n            indicies.append(r)\\n        counts = []\\n        for row in mat:\\n            counts.append(row.count(1))\\n        for i in indicies:\\n            if counts[i] == max(counts):\\n                return [i, counts[i]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        indicies = []\\n        for r in range(len(mat)):\\n            indicies.append(r)\\n        counts = []\\n        for row in mat:\\n            counts.append(row.count(1))\\n        for i in indicies:\\n            if counts[i] == max(counts):\\n                return [i, counts[i]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422669,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        n=len(mat)\\n        m=len(mat[0])\\n        row,count_one=0,0\\n        for i in range(n):\\n            one=0\\n            for j in range(m):\\n                if mat[i][j]==1:\\n                    one+=1\\n\\n            if one>count_one:\\n                count_one=one\\n\\n                row=i\\n\\n        return [row,count_one]                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        n=len(mat)\\n        m=len(mat[0])\\n        row,count_one=0,0\\n        for i in range(n):\\n            one=0\\n            for j in range(m):\\n                if mat[i][j]==1:\\n                    one+=1\\n\\n            if one>count_one:\\n                count_one=one\\n\\n                row=i\\n\\n        return [row,count_one]                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422559,
                "title": "simple-and-easy-solution-easy-to-understand",
                "content": "# Intuition\\n**Just thought to update maxim whenever count exceedes maxim.**\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxim=INT_MIN;\\n        bool falg=true;\\n        int z;\\n        int count;\\n        vector<int>arr;\\n        vector<pair<int,int>>v_p;\\n        for(int i=0; i<n; i++)\\n        {\\n            count=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    count++;\\n                }\\n                \\n            }\\n           \\n            if(count>maxim)\\n            {\\n                z=i;\\n               maxim=max(maxim,count);\\n            }\\n            \\n            \\n        }\\n      arr.push_back(z);\\n      arr.push_back(maxim);\\n        return arr;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxim=INT_MIN;\\n        bool falg=true;\\n        int z;\\n        int count;\\n        vector<int>arr;\\n        vector<pair<int,int>>v_p;\\n        for(int i=0; i<n; i++)\\n        {\\n            count=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    count++;\\n                }\\n                \\n            }\\n           \\n            if(count>maxim)\\n            {\\n                z=i;\\n               maxim=max(maxim,count);\\n            }\\n            \\n            \\n        }\\n      arr.push_back(z);\\n      arr.push_back(maxim);\\n        return arr;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422292,
                "title": "very-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[]=new int[2];\\n        \\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            int countOnes=0;\\n            \\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                    countOnes++;\\n                }\\n            }\\n            if(countOnes>max){\\n                max=countOnes;\\n                ans[0]=i;\\n                ans[1]=max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[]=new int[2];\\n        \\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            int countOnes=0;\\n            \\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                    countOnes++;\\n                }\\n            }\\n            if(countOnes>max){\\n                max=countOnes;\\n                ans[0]=i;\\n                ans[1]=max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422251,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.iter().enumerate() {\\n            let one = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if one > res[1] {\\n                res = vec![i as i32, one];\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.iter().enumerate() {\\n            let one = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if one > res[1] {\\n                res = vec![i as i32, one];\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422112,
                "title": "easyapproach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We initialize maxCount and maxRowIndex to 0. Then we loop through all the rows of the matrix mat.\\n\\n 2. For each row, we count the number of ones in it by looping through all its elements. \\n\\n3. If this count is greater than the current maximum count, we update maxCount and maxRowIndex.\\n\\n 4. Finally, we return an array containing maxRowIndex and maxCount.\\n\\n5. To ensure that the row with the smallest row number is selected in case of multiple rows with the maximum count of ones, we can modify the code to check for the smallest row number while updating the maxRowIndex.\\n\\n6. In addition to checking if count > maxCount, we also check if count == maxCount and the current row index i is less than maxRowIndex.\\n\\n 7. If these conditions are true, we update maxRowIndex to the current row index i.\\n\\n - 8. This ensures that we always select the row with the smallest row number among the rows with the maximum count of ones.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nxn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int maxCount = 0;\\n    int maxRowIndex = 0;\\n\\n    for (int i = 0; i < mat.length; i++) {\\n        int count = 0;\\n        for (int j = 0; j < mat[i].length; j++) {\\n            if (mat[i][j] == 1) {\\n                count++;\\n            }\\n        }\\n\\n        if (count > maxCount || (count == maxCount && i < maxRowIndex)) {\\n            maxCount = count;\\n            maxRowIndex = i;\\n        }\\n    }\\n\\n    return new int[] { maxRowIndex, maxCount };\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int maxCount = 0;\\n    int maxRowIndex = 0;\\n\\n    for (int i = 0; i < mat.length; i++) {\\n        int count = 0;\\n        for (int j = 0; j < mat[i].length; j++) {\\n            if (mat[i][j] == 1) {\\n                count++;\\n            }\\n        }\\n\\n        if (count > maxCount || (count == maxCount && i < maxRowIndex)) {\\n            maxCount = count;\\n            maxRowIndex = i;\\n        }\\n    }\\n\\n    return new int[] { maxRowIndex, maxCount };\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422079,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nIn this problem, we will simply iterate through the 2D array and keep track of count of 1 in that row.\\n\\nwe will store the max count in index 1 of ans array and row with max count at index 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        // {index, maxCount}\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            // number of 1 in ith row\\n            int count=0;\\n\\n            // getting count of 1s\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n\\n            // checking for maximum count\\n            if(count>ans[1]){\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        // {index, maxCount}\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            // number of 1 in ith row\\n            int count=0;\\n\\n            // getting count of 1s\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n\\n            // checking for maximum count\\n            if(count>ans[1]){\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422002,
                "title": "best-c-well-explained-linear-time",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust traverse every row and count  the number of one. and compare it with the maximum oneCnt\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(row * column)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int r=0, maxi=0;\\n        for(int i=0; i<mat.size(); i++) {\\n            int cnt = 0;\\n            for(int j=0; j<mat[0].size(); j++)  if(mat[i][j] == 1)  cnt++;\\n            if(cnt > maxi)  {\\n                maxi = cnt;\\n                r = i;\\n            }\\n        }\\n        return {r, maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int r=0, maxi=0;\\n        for(int i=0; i<mat.size(); i++) {\\n            int cnt = 0;\\n            for(int j=0; j<mat[0].size(); j++)  if(mat[i][j] == 1)  cnt++;\\n            if(cnt > maxi)  {\\n                maxi = cnt;\\n                r = i;\\n            }\\n        }\\n        return {r, maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421908,
                "title": "javascript-simple-one-line-109ms",
                "content": "```\\nconst rowAndMaximumOnes = (g) => g.map((a, i) => [i, a.filter(x => x == 1).length]).sort((x, y) => y[1] - x[1] || x[0] - y[0])[0];\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort",
                    "Matrix"
                ],
                "code": "```\\nconst rowAndMaximumOnes = (g) => g.map((a, i) => [i, a.filter(x => x == 1).length]).sort((x, y) => y[1] - x[1] || x[0] - y[0])[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421856,
                "title": "ez-brute-force",
                "content": "# Intuition\\nJust count the number of ones in each row and find out the maximum out of it.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat)\\n    {\\n        vector<int> res(2,0);\\n        int n = mat.size();\\n        int maxi = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int cnt = 0;\\n            for(auto x : mat[i])\\n            {\\n                cnt+=x;\\n            }\\n            if(cnt > maxi)\\n            {\\n                res[0]=i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] res = new int[2];\\n        int n = mat.length;\\n        int maxi = 0;\\n        for(int i=0; i<n; i++) {\\n            int cnt = 0;\\n            for(int x : mat[i]) {\\n                cnt += x;\\n            }\\n            if(cnt > maxi) {\\n                res[0] = i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        n = len(mat)\\n        maxi = 0\\n        for i in range(n):\\n            cnt = sum(mat[i])\\n            if cnt > maxi:\\n                res[0] = i\\n                res[1] = cnt\\n                maxi = cnt\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat)\\n    {\\n        vector<int> res(2,0);\\n        int n = mat.size();\\n        int maxi = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int cnt = 0;\\n            for(auto x : mat[i])\\n            {\\n                cnt+=x;\\n            }\\n            if(cnt > maxi)\\n            {\\n                res[0]=i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] res = new int[2];\\n        int n = mat.length;\\n        int maxi = 0;\\n        for(int i=0; i<n; i++) {\\n            int cnt = 0;\\n            for(int x : mat[i]) {\\n                cnt += x;\\n            }\\n            if(cnt > maxi) {\\n                res[0] = i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        n = len(mat)\\n        maxi = 0\\n        for i in range(n):\\n            cnt = sum(mat[i])\\n            if cnt > maxi:\\n                res[0] = i\\n                res[1] = cnt\\n                maxi = cnt\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421828,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n     int[] ans = new int[2];\\n    \\n        int max=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int len=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n               if(mat[i][j]==1)\\n               {\\n                   len++;\\n                   \\n               }\\n            }\\n           if(max<len)\\n           {\\n               max=len;\\n               ans[0]=i;\\n           }\\n        }\\n        ans[1]=max;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n     int[] ans = new int[2];\\n    \\n        int max=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int len=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n               if(mat[i][j]==1)\\n               {\\n                   len++;\\n                   \\n               }\\n            }\\n           if(max<len)\\n           {\\n               max=len;\\n               ans[0]=i;\\n           }\\n        }\\n        ans[1]=max;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421822,
                "title": "easy-java-self-explanatory-o-mn",
                "content": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, max = -1, curr = 0, ans[] = new int[2];\\n        for(int row=0;row<m;row++){\\n           curr = 0;\\n           for(int col=0;col<n;col++){\\n             if(mat[row][col] == 1) curr++;  \\n           }\\n            if(curr > max){\\n                ans[0] = row;\\n                ans[1] = curr;\\n                max = curr;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, max = -1, curr = 0, ans[] = new int[2];\\n        for(int row=0;row<m;row++){\\n           curr = 0;\\n           for(int col=0;col<n;col++){\\n             if(mat[row][col] == 1) curr++;  \\n           }\\n            if(curr > max){\\n                ans[0] = row;\\n                ans[1] = curr;\\n                max = curr;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421767,
                "title": "c-brute-force-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < mat[0].size(); j++)\\n            {\\n                if(mat[i][j] == 1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(maxi < count)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n        }\\n        return {max_idx,maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < mat[0].size(); j++)\\n            {\\n                if(mat[i][j] == 1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(maxi < count)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n        }\\n        return {max_idx,maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421733,
                "title": "c-count-one-in-each-row",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421732,
                "title": "c-easy-to-understand-for-begineer",
                "content": "```\\nclass Solution {\\npublic:\\n    //Priyanshu\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     vector<int> ans;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        // int one=0;\\n        vector<pair<int,int>>vec;\\n       for(int i=0;i<n;i++){\\n           int one=0;\\n           for(int j=0;j<m;j++){\\n               if(mat[i][j]==1)one++;\\n           }\\n           vec.push_back({one,i});\\n       }\\n        int x=vec.size();\\n        sort(vec.begin(),vec.end());\\n        int maxi=vec[x-1].first;\\n        for(auto it: vec){\\n            cout<<it.first<<\" \"<<it.second<<endl;\\n        }\\n        for(auto it: vec){\\n            if(it.first==maxi){\\n                ans.push_back(it.second);\\n                ans.push_back(it.first);\\n                break;\\n            }\\n        }\\n        return ans;}};\\n\\t\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Priyanshu\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     vector<int> ans;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        // int one=0;\\n        vector<pair<int,int>>vec;\\n       for(int i=0;i<n;i++){\\n           int one=0;\\n           for(int j=0;j<m;j++){\\n               if(mat[i][j]==1)one++;\\n           }\\n           vec.push_back({one,i});\\n       }\\n        int x=vec.size();\\n        sort(vec.begin(),vec.end());\\n        int maxi=vec[x-1].first;\\n        for(auto it: vec){\\n            cout<<it.first<<\" \"<<it.second<<endl;\\n        }\\n        for(auto it: vec){\\n            if(it.first==maxi){\\n                ans.push_back(it.second);\\n                ans.push_back(it.first);\\n                break;\\n            }\\n        }\\n        return ans;}};\\n\\t\\t```",
                "codeTag": "C++"
            },
            {
                "id": 3421689,
                "title": "simplest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int> ans;\\n        int maxcount=0;\\n        int row=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1)\\n                count++;\\n              }\\n                if(count>maxcount){\\n                    maxcount=count;\\n                    row=i;\\n            }\\n        }\\n        ans.push_back(row);\\n        ans.push_back(maxcount);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int> ans;\\n        int maxcount=0;\\n        int row=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1)\\n                count++;\\n              }\\n                if(count>maxcount){\\n                    maxcount=count;\\n                    row=i;\\n            }\\n        }\\n        ans.push_back(row);\\n        ans.push_back(maxcount);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421677,
                "title": "simple-approach-brute-force-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i =0 ;i < mat.length;i++){\\n            int cnt =0;\\n            for(int j =0 ;j<mat[i].length;j++){\\n                if(mat[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > arr[1]){\\n                arr[1] = cnt;\\n                arr[0] = i;\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i =0 ;i < mat.length;i++){\\n            int cnt =0;\\n            for(int j =0 ;j<mat[i].length;j++){\\n                if(mat[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > arr[1]){\\n                arr[1] = cnt;\\n                arr[0] = i;\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101358,
                "title": "easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int res=0;\\n        int k=0;\\n        for(int i=0;i<m;i++){\\n             int count=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n         if(count>res){\\n             res=count;\\n             k=i;\\n         }\\n        }\\n        ans.push_back(k);\\n        ans.push_back(res);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int res=0;\\n        int k=0;\\n        for(int i=0;i<m;i++){\\n             int count=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n         if(count>res){\\n             res=count;\\n             k=i;\\n         }\\n        }\\n        ans.push_back(k);\\n        ans.push_back(res);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101082,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        int result[] = new int[2];\\n        for(int i=0; i<mat.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++) {\\n                if(mat[i][j]==1) {\\n                    count++;\\n                }\\n            }\\n            if(count > max) {\\n                max = count;\\n                index = i;\\n            }\\n        }\\n        result[0] = index;\\n        result[1] = max;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        int result[] = new int[2];\\n        for(int i=0; i<mat.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++) {\\n                if(mat[i][j]==1) {\\n                    count++;\\n                }\\n            }\\n            if(count > max) {\\n                max = count;\\n                index = i;\\n            }\\n        }\\n        result[0] = index;\\n        result[1] = max;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101064,
                "title": "solved-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int count=0,max=0,i,j,row;\\n        for(i=0;i<mat.size();i++)\\n        {\\n            for(j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max = count;\\n                row = i;\\n\\n            }\\n            count=0;\\n        }\\n        ans.push_back(row);\\n        ans.push_back(max);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int count=0,max=0,i,j,row;\\n        for(i=0;i<mat.size();i++)\\n        {\\n            for(j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max = count;\\n                row = i;\\n\\n            }\\n            count=0;\\n        }\\n        ans.push_back(row);\\n        ans.push_back(max);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101032,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) \\n    {\\n        int ans[]=new int [2];\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(ans[1]<count)\\n            {\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) \\n    {\\n        int ans[]=new int [2];\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(ans[1]<count)\\n            {\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100296,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int onecount = INT_MIN;\\n        int row = -1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int cnt = 0;\\n            for(int j=0; j<mat[i].size(); ++j){\\n                if(mat[i][j] == 1) cnt++;\\n            }\\n\\n            if(cnt > onecount){\\n                onecount = cnt;\\n                row = i;\\n            }\\n\\n        }\\n\\n        ans.push_back(row);\\n        ans.push_back(onecount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int onecount = INT_MIN;\\n        int row = -1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int cnt = 0;\\n            for(int j=0; j<mat[i].size(); ++j){\\n                if(mat[i][j] == 1) cnt++;\\n            }\\n\\n            if(cnt > onecount){\\n                onecount = cnt;\\n                row = i;\\n            }\\n\\n        }\\n\\n        ans.push_back(row);\\n        ans.push_back(onecount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091988,
                "title": "bs-best-solution-o-n-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortrow(vector<int> &row){\\n        sort(row.begin(),row.end());\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& a) {\\n         int count=0,index=0;\\n         int n=a.size(),m=a[0].size();\\n        for(int i=0;i<n;i++){\\n            sortrow(a[i]);\\n            int low=0,high=m-1;\\n            int ind=m;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(a[i][mid]==1){\\n                    ind=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                low=mid+1;\\n            }\\n            int count_ones=m-ind;\\n            if(count_ones>count){\\n                count=count_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,count};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortrow(vector<int> &row){\\n        sort(row.begin(),row.end());\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& a) {\\n         int count=0,index=0;\\n         int n=a.size(),m=a[0].size();\\n        for(int i=0;i<n;i++){\\n            sortrow(a[i]);\\n            int low=0,high=m-1;\\n            int ind=m;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(a[i][mid]==1){\\n                    ind=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                low=mid+1;\\n            }\\n            int count_ones=m-ind;\\n            if(count_ones>count){\\n                count=count_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,count};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088570,
                "title": "easy-solution-in-python-specially-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l = []\\n        m=0\\n        k=0\\n        x=0\\n        for i in mat:\\n            p = i.count(1)\\n            if m<p:\\n                m = p\\n                x = k\\n            k+=1\\n        l.append(x)\\n        l.append(m)\\n        return l\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l = []\\n        m=0\\n        k=0\\n        x=0\\n        for i in mat:\\n            p = i.count(1)\\n            if m<p:\\n                m = p\\n                x = k\\n            k+=1\\n        l.append(x)\\n        l.append(m)\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085878,
                "title": "best-question-for-beginners-and-the-easiest-code-given-below",
                "content": "## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count=0;\\n        int max=0;\\n        int index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n               \\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                index=i;\\n            }\\n           \\n        }\\n         \\n        return new int[] {index,max};\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count=0;\\n        int max=0;\\n        int index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n               \\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                index=i;\\n            }\\n           \\n        }\\n         \\n        return new int[] {index,max};\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085187,
                "title": "95-beats-in-c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count = 0;\\n        int min_index = -1;\\n\\n        for(int i = 0; i < mat.size(); i++){\\n            int count2 = 0;\\n            for(int j = 0; j < mat[i].size(); j++){\\n                if(mat[i][j] == 1){\\n                    count2++;\\n                }\\n            }\\n            if(count2 > count){\\n                count = count2;\\n                min_index = i;\\n            }\\n        }\\n\\n        if(count == 0){\\n            return {0,0};\\n        }\\n        return {min_index,count};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count = 0;\\n        int min_index = -1;\\n\\n        for(int i = 0; i < mat.size(); i++){\\n            int count2 = 0;\\n            for(int j = 0; j < mat[i].size(); j++){\\n                if(mat[i][j] == 1){\\n                    count2++;\\n                }\\n            }\\n            if(count2 > count){\\n                count = count2;\\n                min_index = i;\\n            }\\n        }\\n\\n        if(count == 0){\\n            return {0,0};\\n        }\\n        return {min_index,count};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081899,
                "title": "striver-approach-lower-bound-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint lowerBound(vector<int> &arr, int x){\\n    int n=arr.size();\\n    int low=0;\\n    int high = n-1;\\n    sort(arr.begin(),arr.end());\\n    int ans=n;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        if(arr[mid] >= x){\\n            ans=mid;\\n            high=mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return ans;\\n}\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int maxCount=0;\\n        int index=0;\\n        vector<int> ans;\\n        for(int i=0; i<m; i++){\\n            int onesCount = n-lowerBound(mat[i], 1);\\n            if(onesCount > maxCount){\\n                maxCount = onesCount;\\n                index=i;\\n            }\\n        }\\n        return {index, maxCount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint lowerBound(vector<int> &arr, int x){\\n    int n=arr.size();\\n    int low=0;\\n    int high = n-1;\\n    sort(arr.begin(),arr.end());\\n    int ans=n;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        if(arr[mid] >= x){\\n            ans=mid;\\n            high=mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return ans;\\n}\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int maxCount=0;\\n        int index=0;\\n        vector<int> ans;\\n        for(int i=0; i<m; i++){\\n            int onesCount = n-lowerBound(mat[i], 1);\\n            if(onesCount > maxCount){\\n                maxCount = onesCount;\\n                index=i;\\n            }\\n        }\\n        return {index, maxCount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080350,
                "title": "beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxOne=-9999\\n        index =-1\\n        for i in range(len(mat)):\\n            if maxOne < mat[i].count(1):\\n                maxOne = mat[i].count(1)\\n                index= i\\n        return [index,maxOne]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxOne=-9999\\n        index =-1\\n        for i in range(len(mat)):\\n            if maxOne < mat[i].count(1):\\n                maxOne = mat[i].count(1)\\n                index= i\\n        return [index,maxOne]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079830,
                "title": "simple-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let index = 0;\\n    let maxCount = 0;\\n    for(let i=0; i< mat.length; i++){\\n        let count = 0\\n        for(let j=0; j< mat[i].length; j++){\\n            if(mat[i][j] === 1){\\n                count++\\n            }\\n        }\\n        if(count > maxCount){\\n         maxCount = count;\\n         index = i;\\n        }\\n    }  \\n    return [index,  maxCount]  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let index = 0;\\n    let maxCount = 0;\\n    for(let i=0; i< mat.length; i++){\\n        let count = 0\\n        for(let j=0; j< mat[i].length; j++){\\n            if(mat[i][j] === 1){\\n                count++\\n            }\\n        }\\n        if(count > maxCount){\\n         maxCount = count;\\n         index = i;\\n        }\\n    }  \\n    return [index,  maxCount]  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079790,
                "title": "row-with-maximum-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n      vector<int>ans;\\n      int n=mat.size();\\n      int oneCount = INT_MIN;\\n      int rowNo;\\n\\n      for(int i=0;i<n;i++){\\n        int count=0;\\n        for(int j=0;j<mat[i].size();j++){\\n          if(mat[i][j]==1){\\n            count++;\\n          }\\n        }\\n        if(count>oneCount){\\n          oneCount=count;\\n          rowNo=i;\\n        }\\n      }\\n      ans.push_back(rowNo);\\n      ans.push_back(oneCount);\\n      return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n      vector<int>ans;\\n      int n=mat.size();\\n      int oneCount = INT_MIN;\\n      int rowNo;\\n\\n      for(int i=0;i<n;i++){\\n        int count=0;\\n        for(int j=0;j<mat[i].size();j++){\\n          if(mat[i][j]==1){\\n            count++;\\n          }\\n        }\\n        if(count>oneCount){\\n          oneCount=count;\\n          rowNo=i;\\n        }\\n      }\\n      ans.push_back(rowNo);\\n      ans.push_back(oneCount);\\n      return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074711,
                "title": "easy-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        arr=[]\\n        res=[]\\n        for i in mat:\\n            count=0\\n            for j in i:\\n                if j==1:\\n                    print(j)\\n                    count+=1\\n                if j==0:\\n                    continue\\n            arr.append(count)\\n        print(arr)\\n        if arr:\\n            for l in range(len(arr)):\\n                if arr[l]==max(arr):\\n                    res.append(l)\\n                    res.append(max(arr))\\n                    break\\n        else:\\n            res.append(0)\\n            res.append(0)\\n        return res\\n        \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        arr=[]\\n        res=[]\\n        for i in mat:\\n            count=0\\n            for j in i:\\n                if j==1:\\n                    print(j)\\n                    count+=1\\n                if j==0:\\n                    continue\\n            arr.append(count)\\n        print(arr)\\n        if arr:\\n            for l in range(len(arr)):\\n                if arr[l]==max(arr):\\n                    res.append(l)\\n                    res.append(max(arr))\\n                    break\\n        else:\\n            res.append(0)\\n            res.append(0)\\n        return res\\n        \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072903,
                "title": "o-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int a=0,c=0,b=0;\\n        for(int i=0;i<mat.length;i++){\\n            c=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    c++;\\n                }\\n                if(c>a){\\n                    b = i;\\n                }\\n                a = Math.max(a,c);\\n            }\\n        }\\n        int[] ans = {b,a};\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int a=0,c=0,b=0;\\n        for(int i=0;i<mat.length;i++){\\n            c=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    c++;\\n                }\\n                if(c>a){\\n                    b = i;\\n                }\\n                a = Math.max(a,c);\\n            }\\n        }\\n        int[] ans = {b,a};\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070947,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n =mat.length;\\n        int m = mat[0].length;\\n\\n        int index =0;\\n        int max =0;\\n\\n        for(int i =0;i<n; i++){\\n          int sum =0;\\n          for(int j =0;j<m;j++){\\n            sum = sum + mat[i][j];\\n            \\n          }\\n         if(sum > max){\\n           index =i;\\n           max =sum;\\n         }\\n        \\n        }\\n        return new int[] {index,max};\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n =mat.length;\\n        int m = mat[0].length;\\n\\n        int index =0;\\n        int max =0;\\n\\n        for(int i =0;i<n; i++){\\n          int sum =0;\\n          for(int j =0;j<m;j++){\\n            sum = sum + mat[i][j];\\n            \\n          }\\n         if(sum > max){\\n           index =i;\\n           max =sum;\\n         }\\n        \\n        }\\n        return new int[] {index,max};\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070818,
                "title": "use-c-stl",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(c)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2,0);\\n        for(int i=0; i<mat.size(); ++i)\\n        {\\n            int sum = accumulate(mat[i].begin(), mat[i].end(),0);\\n            if(sum > ans[1])\\n            {\\n                ans[1] = sum;\\n                ans[0] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2,0);\\n        for(int i=0; i<mat.size(); ++i)\\n        {\\n            int sum = accumulate(mat[i].begin(), mat[i].end(),0);\\n            if(sum > ans[1])\\n            {\\n                ans[1] = sum;\\n                ans[0] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068780,
                "title": "python-simple-with-explanation",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #INITIALISE ANS WITH 0\\n        ans=0\\n        res=[]\\n        #COUNT THE MAX NUMBER OF 1\\'S IN EACH LIST\\n        for i in mat:\\n            ans=max(ans,i.count(1))\\n        #SEARCH FOR THAT LIST AND RETURN ITS INDEX\\n        for i in range(len(mat)):\\n            if mat[i].count(1)==ans:\\n                res.append(i)\\n                res.append(ans)\\n                return res\\n                break\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #INITIALISE ANS WITH 0\\n        ans=0\\n        res=[]\\n        #COUNT THE MAX NUMBER OF 1\\'S IN EACH LIST\\n        for i in mat:\\n            ans=max(ans,i.count(1))\\n        #SEARCH FOR THAT LIST AND RETURN ITS INDEX\\n        for i in range(len(mat)):\\n            if mat[i].count(1)==ans:\\n                res.append(i)\\n                res.append(ans)\\n                return res\\n                break\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066516,
                "title": "python-solution-easy-to-understand-for-beginners",
                "content": "\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        temp=[]\\n        count1=0\\n        for i in range(len(mat)):\\n            new=mat[i].count(1)\\n            if new>count1:\\n                count1=new\\n                temp=[i,count1]\\n        if temp==[]:\\n            return [0,0]\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        temp=[]\\n        count1=0\\n        for i in range(len(mat)):\\n            new=mat[i].count(1)\\n            if new>count1:\\n                count1=new\\n                temp=[i,count1]\\n        if temp==[]:\\n            return [0,0]\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064962,
                "title": "a-bit-lenthy-solution-but-easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[100];\\n        int count = 0;\\n        int k = 0;\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j] == 1){\\n                    count ++;\\n                }\\n                \\n            }\\n            arr[k++] = count;\\n                count = 0;\\n        }\\n        int max = arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            if(arr[i] > max){\\n                max = arr[i];\\n            }\\n        }\\n        int ans = position(arr,max);\\n        int[] nums = {ans,max};\\n        return nums;\\n    }\\n        public int position(int[] arr,int target){\\n            for(int i=0;i<arr.length;i++){\\n                if(arr[i] == target){\\n                    return i;\\n                    \\n                }\\n            }\\n            return -1;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[100];\\n        int count = 0;\\n        int k = 0;\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j] == 1){\\n                    count ++;\\n                }\\n                \\n            }\\n            arr[k++] = count;\\n                count = 0;\\n        }\\n        int max = arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            if(arr[i] > max){\\n                max = arr[i];\\n            }\\n        }\\n        int ans = position(arr,max);\\n        int[] nums = {ans,max};\\n        return nums;\\n    }\\n        public int position(int[] arr,int target){\\n            for(int i=0;i<arr.length;i++){\\n                if(arr[i] == target){\\n                    return i;\\n                    \\n                }\\n            }\\n            return -1;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063673,
                "title": "easy-and-clean-code-c-solution-clean-code-easy-to-understand-o-n-2-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        vector<int>anss;\\n        int max=INT_MIN;\\n        for(int i=0;i<mat.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    cnt+=1;\\n                }\\n            }\\n           ans.push_back(i);\\n           anss.push_back(cnt);\\n            \\n        }\\n        int  index;\\n        for(int i=0;i<anss.size();i++){\\n            if(anss[i]>max){\\n                max=anss[i];\\n                index=i;\\n            }\\n        }\\n    \\n        return {index,max};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        vector<int>anss;\\n        int max=INT_MIN;\\n        for(int i=0;i<mat.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    cnt+=1;\\n                }\\n            }\\n           ans.push_back(i);\\n           anss.push_back(cnt);\\n            \\n        }\\n        int  index;\\n        for(int i=0;i<anss.size();i++){\\n            if(anss[i]>max){\\n                max=anss[i];\\n                index=i;\\n            }\\n        }\\n    \\n        return {index,max};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063205,
                "title": "h",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int row_size=mat.size();\\n        int oneCount=INT_MIN;\\n        int rowNo=0;\\n        for(int i=0;i<row_size;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>oneCount)\\n            {\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int row_size=mat.size();\\n        int oneCount=INT_MIN;\\n        int rowNo=0;\\n        for(int i=0;i<row_size;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>oneCount)\\n            {\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062082,
                "title": "simple-fast-and-100-accepted-c-c-bruteforce-approach-beats-maximum-users-check-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-> Assume ansr, Row number = 0\\n-> Assume ans, Maximum no. of 1\\'s =0\\n-> Count the no. of 1\\'s in each row.\\n-> Then, Store it in ansr, ans variable.\\n\\nReturn the ans, ansr.\\nans = maximum no. of 1s\\nansr = minimum row which contain maximum 1\\'s. \\n\\n# Approach\\nBruteForce Approach\\n\\n# Complexity\\n- Time complexity:\\nO(m x n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int ansr=0,ans=0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>ans)\\n            {\\n                ans = count;\\n                ansr = i; \\n            }\\n        }\\n        return {ansr,ans};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int ansr=0,ans=0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>ans)\\n            {\\n                ans = count;\\n                ansr = i; \\n            }\\n        }\\n        return {ansr,ans};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060971,
                "title": "easy-java-approach",
                "content": "## ****Bold****# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,maxrow=0;\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                 c++;\\n            }\\n            if(c>max)\\n            {\\n            max=c;\\n            maxrow=i;\\n            }\\n        }\\n        int[] arr = new int[2];\\n        arr[1]=max;\\n        arr[0]=maxrow;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,maxrow=0;\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                 c++;\\n            }\\n            if(c>max)\\n            {\\n            max=c;\\n            maxrow=i;\\n            }\\n        }\\n        int[] arr = new int[2];\\n        arr[1]=max;\\n        arr[0]=maxrow;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060192,
                "title": "simple-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>ans;\\n        \\n        int index=0;\\n        int OnesCount=0;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                 count++;\\n                }\\n            }\\n\\n           if(count>OnesCount) {\\n            OnesCount=count;\\n             index=i;\\n             }\\n        }\\n\\n        ans.push_back(index);\\n        ans.push_back(OnesCount);\\n        return ans;\\n          \\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>ans;\\n        \\n        int index=0;\\n        int OnesCount=0;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                 count++;\\n                }\\n            }\\n\\n           if(count>OnesCount) {\\n            OnesCount=count;\\n             index=i;\\n             }\\n        }\\n\\n        ans.push_back(index);\\n        ans.push_back(OnesCount);\\n        return ans;\\n          \\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058731,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n**O(m*n)**\\n\\nThe countOnes function iterates through a row of length \\'n\\' once and counts the number of ones. So, its time complexity is O(n).\\n\\nIn the rowAndMaximumOnes function, there is a loop that iterates through all \\'m\\' rows of the matrix. Inside the loop, it calls the countOnes function, which has a time complexity of O(n). Therefore, the time complexity of the loop is O(m * n).\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int countOnes(vector<int>& row) {\\n        int count = 0;\\n        for (int num : row) {\\n            if (num == 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCount = 0;\\n        int rowIndex = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        for (int i = 0; i < m; i++) {\\n            int onesCount = countOnes(mat[i]);\\n            if (onesCount > maxCount) {\\n                maxCount = onesCount;\\n                rowIndex = i;\\n            }\\n        }\\n        if (rowIndex == -1) {\\n            return {0, 0};  // No ones found in any row\\n        }\\n        vector<int> result = {rowIndex, maxCount};\\n        return result;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int countOnes(vector<int>& row) {\\n        int count = 0;\\n        for (int num : row) {\\n            if (num == 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCount = 0;\\n        int rowIndex = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        for (int i = 0; i < m; i++) {\\n            int onesCount = countOnes(mat[i]);\\n            if (onesCount > maxCount) {\\n                maxCount = onesCount;\\n                rowIndex = i;\\n            }\\n        }\\n        if (rowIndex == -1) {\\n            return {0, 0};  // No ones found in any row\\n        }\\n        vector<int> result = {rowIndex, maxCount};\\n        return result;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055258,
                "title": "fast-and-easy-code-by-using-python3",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> first we are taking each row and finding number of 1\\'s in it by using count meathod ad appedning it into num_1 list\\n-> next we are finding index of the row by finding index of the max element in the num_1 list because its index match with the row index \\n-> finally we are taking index i and no. of times 1 repeated into a final list and returning it \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        num_1 = []\\n        for i in mat:\\n            # finding nuo. of times 1 repeated in each row \\n            num_1.append(i.count(1))\\n        # finding index of max element in num_1\\n        i = num_1.index(max(num_1))\\n        final = [i,max(num_1)]\\n        return final\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        num_1 = []\\n        for i in mat:\\n            # finding nuo. of times 1 repeated in each row \\n            num_1.append(i.count(1))\\n        # finding index of max element in num_1\\n        i = num_1.index(max(num_1))\\n        final = [i,max(num_1)]\\n        return final\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054975,
                "title": "beat-90-in-memory-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l=[0,0]\\n        for i in range(len(mat)):\\n            if sum(mat[i])>l[1]:\\n                l[1]=sum(mat[i])\\n                l[0]=i\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l=[0,0]\\n        for i in range(len(mat)):\\n            if sum(mat[i])>l[1]:\\n                l[1]=sum(mat[i])\\n                l[0]=i\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054524,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row = 0;\\n        int count = 0;\\n        int maxCount = 0;\\n        for(int i = 0 ;  i< mat.length; i++){\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > maxCount){\\n                maxCount = count;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row = 0;\\n        int count = 0;\\n        int maxCount = 0;\\n        for(int i = 0 ;  i< mat.length; i++){\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > maxCount){\\n                maxCount = count;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053693,
                "title": "using-count-p",
                "content": "# Intuition\\nOn a first thought, i used 2 for\\'s, but that\\'s not necessary\\n# Approach\\nbc python gives us \"count\" wich you call with the array and, as a parameter, you put the element.. Of course it probably cycles the list so it\\'s still a O(n^2) but the guy who made count is way better than me so my code si 50ms faster :P I just check if the counter of 1\\'s in a array is bigger than the actual, i just keep the big one and the index, which probally isn\\'t necesary as variable, but i\\'m not a py programmer D:\\n\\n# Complexity\\n- Time complexity:\\nO(n^2).. but i\\'m having doubts with that if, maybe hurts more than what it helps\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nnot really sure about space, i mean i use 2 variables and un array length==2 D:\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        counter = 0\\n        i = 0\\n        salida = [0,0]\\n        for array in mat:\\n            if(1 in array):\\n                counter = array.count(1)\\n                if(counter > salida[1]):\\n                    salida = [i, counter]\\n            i += 1\\n            counter = 0\\n        return salida\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        counter = 0\\n        i = 0\\n        salida = [0,0]\\n        for array in mat:\\n            if(1 in array):\\n                counter = array.count(1)\\n                if(counter > salida[1]):\\n                    salida = [i, counter]\\n            i += 1\\n            counter = 0\\n        return salida\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048826,
                "title": "cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        vector<int> answer(2 , 0);\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                count += mat[i][j];\\n            }\\n            if(answer[1] < count)\\n            {\\n                answer[0] = i;\\n                answer[1] = count;\\n            }\\n        }    \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        vector<int> answer(2 , 0);\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                count += mat[i][j];\\n            }\\n            if(answer[1] < count)\\n            {\\n                answer[0] = i;\\n                answer[1] = count;\\n            }\\n        }    \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047801,
                "title": "easy-c-solution-without-taking-extra-variable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> result(2);\\n       //  have created one vector with size 2 because we have to return a vector, IN the fist index  result[0] we will be storing index of the max row and second position  result[1] we will be storing max 1 count;\\n\\n        for(int i=0 ;i<mat.size() ; i++){  // for row\\n            int oneCount = 0;    // to count 1 each row\\n            for(int j=0 ; j<mat[0].size() ; j++){  // for column\\n                if(mat[i][j] == 1){\\n                    oneCount++;  // if 1 fount in the row then we will count\\n                }\\n            }\\n            if( oneCount > result[1]){    //if max row found with respect to the previous row then we will update vector\\n                result[0] = i;\\n                result[1] = oneCount;\\n\\n            }\\n        }\\n        return result; // return the vector\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> result(2);\\n       //  have created one vector with size 2 because we have to return a vector, IN the fist index  result[0] we will be storing index of the max row and second position  result[1] we will be storing max 1 count;\\n\\n        for(int i=0 ;i<mat.size() ; i++){  // for row\\n            int oneCount = 0;    // to count 1 each row\\n            for(int j=0 ; j<mat[0].size() ; j++){  // for column\\n                if(mat[i][j] == 1){\\n                    oneCount++;  // if 1 fount in the row then we will count\\n                }\\n            }\\n            if( oneCount > result[1]){    //if max row found with respect to the previous row then we will update vector\\n                result[0] = i;\\n                result[1] = oneCount;\\n\\n            }\\n        }\\n        return result; // return the vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047187,
                "title": "74ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let result = [];\\n    let tmpCount = -1;\\n    mat.forEach((item, i) => {\\n        let count = item.reduce((n, sum) => (n + sum), 0);\\n        if (count > tmpCount) {\\n            result[0] = i;\\n            result[1] = count\\n            tmpCount = count;\\n        }\\n        \\n    });\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let result = [];\\n    let tmpCount = -1;\\n    mat.forEach((item, i) => {\\n        let count = item.reduce((n, sum) => (n + sum), 0);\\n        if (count > tmpCount) {\\n            result[0] = i;\\n            result[1] = count\\n            tmpCount = count;\\n        }\\n        \\n    });\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045304,
                "title": "brute-force-and-simple-to-understand-100",
                "content": "# Intuition\\n![cat_image.jpeg](https://assets.leetcode.com/users/images/84b86bbb-442c-414d-9e18-6b1057407c45_1694716995.6876135.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcont=0;\\n        int cont=0;\\n        int ind;\\n\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            cont=0;\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                   cont++;\\n                }\\n            }\\n\\n            if(cont>maxcont)\\n            {\\n                maxcont=cont;\\n                ind=i;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(ind);\\n        ans.push_back(maxcont);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcont=0;\\n        int cont=0;\\n        int ind;\\n\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            cont=0;\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                   cont++;\\n                }\\n            }\\n\\n            if(cont>maxcont)\\n            {\\n                maxcont=cont;\\n                ind=i;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(ind);\\n        ans.push_back(maxcont);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045214,
                "title": "easy-and-simple-c-solution-row-with-maximum-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row. ---->**Idea :-** We\\'ll count one\\'s value in each row by traversing the matrix , then store the ans and return the value of rowNo and max oneCount. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all , initialize a vector array of int type as \"ans\" `vector<int> ans;`to store the index of the row, and the number of ones in it. \\nInitializes two variables \\n-> `oneCount=INT_MIN` (that have the maximum count of ones)\\n->`rowNo = -1` (the row with the smallest row number having max no. of 1\\'s)\\n1) Using nested loop to check whether `mat[i][j]==1` or not, if mat[i][j]==1, then increment `count++`. \\n2) Check `if(count > onecount)` then  oneCount=count , rowNo= i\\n3) push_back rowNo and oneCount in \"ans\" vector array , then return ans `ans.push_back(rowNo);`\\n `ans.push_back(oneCount);`\\n `return ans;`\\n\\n# Complexity\\n- Time complexity: O( m*n ) `traversal of matrix`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount-> will store max number of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowNo-> will store index of max no. of 1\\'s wali row\\n        int rowNo=-1;\\n\\n        for(int i=0;i<n;i++){\\n            //har row start hone se phele intialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row completion , compare count with oneCount\\n            if(count> oneCount){\\n                oneCount=count;\\n                rowNo= i;\\n            }\\n        }\\n       \\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```\\n![canUpleaseUpvote.jpeg](https://assets.leetcode.com/users/images/8d39986a-7aae-4ac6-8605-00bda5df2579_1694715765.6027052.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount-> will store max number of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowNo-> will store index of max no. of 1\\'s wali row\\n        int rowNo=-1;\\n\\n        for(int i=0;i<n;i++){\\n            //har row start hone se phele intialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row completion , compare count with oneCount\\n            if(count> oneCount){\\n                oneCount=count;\\n                rowNo= i;\\n            }\\n        }\\n       \\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043733,
                "title": "row-wise-counting",
                "content": "# Intuition\\nstep 1: Traversing row wise and count 1 and compare max and count if count > max then max = count. Then count -> 0\\nstep 2: storing row idx\\nstep 3: return row idx and maximum count of 1\\n\\n# Approach\\nRow-wise Counting\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector <int> ans;\\n        int Max = INT_MIN, row_Idx;\\n        for(int i = 0 ; i<mat.size(); i++){\\n            int count = 0;\\n        for(int j = 0 ; j<mat[0].size(); j++){\\n            if(mat[i][j] == 1){\\n                count++;\\n            }\\n        }\\n        if(Max < count){\\n            Max = count;\\n            row_Idx = i;\\n        }\\n        }\\n        ans.push_back(row_Idx);\\n        ans.push_back(Max);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector <int> ans;\\n        int Max = INT_MIN, row_Idx;\\n        for(int i = 0 ; i<mat.size(); i++){\\n            int count = 0;\\n        for(int j = 0 ; j<mat[0].size(); j++){\\n            if(mat[i][j] == 1){\\n                count++;\\n            }\\n        }\\n        if(Max < count){\\n            Max = count;\\n            row_Idx = i;\\n        }\\n        }\\n        ans.push_back(row_Idx);\\n        ans.push_back(Max);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042974,
                "title": "row-with-maximum-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int onecount =INT_MIN;\\n        int n=mat.size();\\n        vector<int>ans;\\n        int rowno = -1;\\n        for(int i=0 ;i<n ;i++){\\n            int count =0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count >  onecount){\\n                onecount =count;\\n                rowno =i;\\n            }\\n        }\\n        ans.push_back(rowno);\\n        ans.push_back(onecount);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int onecount =INT_MIN;\\n        int n=mat.size();\\n        vector<int>ans;\\n        int rowno = -1;\\n        for(int i=0 ;i<n ;i++){\\n            int count =0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count >  onecount){\\n                onecount =count;\\n                rowno =i;\\n            }\\n        }\\n        ans.push_back(rowno);\\n        ans.push_back(onecount);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041660,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        vector<int>ans;\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        // for max count of one\\n        int oneCount = INT_MIN;\\n        // for which row has max one count\\n        int rowNo = 0;\\n\\n        for(int i=0 ; i<row ; i++){\\n            int count = 0;\\n            for(int j=0 ; j<col ; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > oneCount){\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        vector<int>ans;\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        // for max count of one\\n        int oneCount = INT_MIN;\\n        // for which row has max one count\\n        int rowNo = 0;\\n\\n        for(int i=0 ; i<row ; i++){\\n            int count = 0;\\n            for(int j=0 ; j<col ; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > oneCount){\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041598,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int oneCount = 0;\\n        int rowNo ;\\n        vector<int> ans;\\n\\n        for(int i=0 ; i<n ;i++){\\n            int count=0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n\\n                if(count>oneCount){\\n                    oneCount = count;\\n\\n                    rowNo = i;\\n                }\\n            }\\n        }\\n            ans.push_back(rowNo);\\n            ans.push_back(oneCount);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int oneCount = 0;\\n        int rowNo ;\\n        vector<int> ans;\\n\\n        for(int i=0 ; i<n ;i++){\\n            int count=0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n\\n                if(count>oneCount){\\n                    oneCount = count;\\n\\n                    rowNo = i;\\n                }\\n            }\\n        }\\n            ans.push_back(rowNo);\\n            ans.push_back(oneCount);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040180,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> v;\\n        int max1 = 0;\\n        int maxi = 0;\\n\\n        for (int i = 0; i < mat.size(); i++) {\\n            int count = 0;\\n\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count > max1) {\\n                max1 = count;\\n                maxi = i;\\n            }\\n        }\\n\\n        v.push_back(maxi);\\n        v.push_back(max1);\\n\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> v;\\n        int max1 = 0;\\n        int maxi = 0;\\n\\n        for (int i = 0; i < mat.size(); i++) {\\n            int count = 0;\\n\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count > max1) {\\n                max1 = count;\\n                maxi = i;\\n            }\\n        }\\n\\n        v.push_back(maxi);\\n        v.push_back(max1);\\n\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039370,
                "title": "beats-98-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount ->will store max no of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowno-->  will store index of max no of 1/s wali row\\n        int rowNo=-101;\\n\\n        for(int i=0;i<n;i++){\\n            //hr row start hone se phle initialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                //if one found then increment one\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row comple compare with one count\\n            if(count>oneCount){\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount ->will store max no of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowno-->  will store index of max no of 1/s wali row\\n        int rowNo=-101;\\n\\n        for(int i=0;i<n;i++){\\n            //hr row start hone se phle initialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                //if one found then increment one\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row comple compare with one count\\n            if(count>oneCount){\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037894,
                "title": "easy-c-solution-of-this-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int >ans;\\n        int n = mat.size();\\n        int onecount = INT_MIN;\\n        int rowno = -1;\\n\\n        for(int i = 0; i<n; i++ ){\\n            int count = 0; \\n            for(int  j = 0; j<mat[i].size(); j++ )\\n            {\\n                if(mat[i][j]  == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > onecount )\\n            {\\n                onecount = count;\\n                rowno = i;\\n            }\\n        }\\n        ans.push_back(rowno); \\n        ans.push_back(onecount);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int >ans;\\n        int n = mat.size();\\n        int onecount = INT_MIN;\\n        int rowno = -1;\\n\\n        for(int i = 0; i<n; i++ ){\\n            int count = 0; \\n            for(int  j = 0; j<mat[i].size(); j++ )\\n            {\\n                if(mat[i][j]  == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > onecount )\\n            {\\n                onecount = count;\\n                rowno = i;\\n            }\\n        }\\n        ans.push_back(rowno); \\n        ans.push_back(onecount);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036575,
                "title": "row-with-maximum-ones",
                "content": "# Intuition\\nWe are given a binary matrix where each row represents a set of elements with values 0 or 1. We need to find the row with the maximum number of 1s.\\n\\n# Approach\\n1. Initialize oneCount to a very small integer (e.g., INT_MIN) to keep track of the maximum number of 1s in a row.\\n2. Initialize rowNo to -1 to keep track of the row number with the maximum 1s.\\n3. Iterate through each row of the matrix.\\n->Initialize count to 0 for each row to count the number of 1s.\\n->Iterate through each element in the row.\\n->If an element is 1, increment count.\\n4. After counting the 1s in a row, compare count with oneCount.\\n->If count is greater than oneCount, update oneCount with count and rowNo with the current row number.\\n5. Finally, return a vector containing rowNo and oneCount, which represents the row with the maximum 1s and the count of maximum 1s in that row.\\n# Complexity\\n- Time complexity:\\nWe iterate through each row of the matrix once, and for each row, we iterate through all of its elements once. Therefore, the time complexity is O(n * m), where n is the number of rows and m is the number of columns in the matrix.\\n\\n- Space complexity:\\nWe use a constant amount of extra space for variables (oneCount, rowNo, and count) regardless of the input size. Therefore, the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n = mat.size();\\n        // Will store the max number of 1s in a row\\n        int oneCount = INT_MIN;\\n        // Will store max row number with max 1s\\n        int rowNo = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Initialize count with 0 for each row\\n            int count = 0;\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            // After row completion, compare count with oneCount\\n            if (count > oneCount) {\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n = mat.size();\\n        // Will store the max number of 1s in a row\\n        int oneCount = INT_MIN;\\n        // Will store max row number with max 1s\\n        int rowNo = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Initialize count with 0 for each row\\n            int count = 0;\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            // After row completion, compare count with oneCount\\n            if (count > oneCount) {\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035519,
                "title": "easy-java-sol-using-iterative-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=Integer.MIN_VALUE;\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            int ones=0;\\n\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) ones++;\\n            }\\n            if(ones>max){\\n                max=ones;\\n                ans[0]=i;\\n                ans[1]=ones;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=Integer.MIN_VALUE;\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            int ones=0;\\n\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) ones++;\\n            }\\n            if(ones>max){\\n                max=ones;\\n                ans[0]=i;\\n                ans[1]=ones;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028371,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n\\n        int count=0, index=0;\\n        int arr[] = new int[2];\\n\\n        for(int i=0; i<mat.length; i++){\\n            count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n          \\n            if(count>arr[1]){\\n                arr[1]=count;\\n                arr[0]=i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n\\n        int count=0, index=0;\\n        int arr[] = new int[2];\\n\\n        for(int i=0; i<mat.length; i++){\\n            count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n          \\n            if(count>arr[1]){\\n                arr[1]=count;\\n                arr[0]=i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022806,
                "title": "n-x-log2-m",
                "content": "# Intuition\\njust finding the no. of 1\\'s using lower bound and checking the condition that if maxcnt is larger than the instant cnt.\\n\\n# Approach\\nfirstly we know that the matrix is sorted at the column level .so, we cannot optimize row traversal the only thing we can optimize is that the way of computing no. of 1\\'s.\\nrun a for lopp for each row and find the no. of 1,s at each row by\\ncntones = m - lowerBound(matrix[i],m,1) .\\nand then check the condition.\\n\\n# Complexity\\n- Time complexity:O(N X log2(M))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int lowerBound(vector<int>& arr,int n,int x){\\n    \\n    int low = 0, high = n-1;\\n    \\n    while(low <= high){\\n        int mid = (low+high)/2;\\n        \\n        if(arr[mid] >= x){\\n            high=mid-1;\\n        }\\n        \\n        else{\\n            low=mid+1;\\n        }\\n    }\\n    return low;\\n}\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        }\\n            int index = -1;\\n    int max_cnt = -1;//don\\'t put max_cnt = -1; \\n    \\n    // n X log2 m\\n\\n    for(int i=0;i<n;i++){\\n        int cnt_ones = m-lowerBound(mat[i],m,1);\\n\\n        if(cnt_ones > max_cnt){\\n            max_cnt=cnt_ones;\\n            index=i;\\n        }\\n    }\\n    return {index,max_cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int lowerBound(vector<int>& arr,int n,int x){\\n    \\n    int low = 0, high = n-1;\\n    \\n    while(low <= high){\\n        int mid = (low+high)/2;\\n        \\n        if(arr[mid] >= x){\\n            high=mid-1;\\n        }\\n        \\n        else{\\n            low=mid+1;\\n        }\\n    }\\n    return low;\\n}\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        }\\n            int index = -1;\\n    int max_cnt = -1;//don\\'t put max_cnt = -1; \\n    \\n    // n X log2 m\\n\\n    for(int i=0;i<n;i++){\\n        int cnt_ones = m-lowerBound(mat[i],m,1);\\n\\n        if(cnt_ones > max_cnt){\\n            max_cnt=cnt_ones;\\n            index=i;\\n        }\\n    }\\n    return {index,max_cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021509,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016559,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015231,
                "title": "short-and-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse `sum` to find the number of ones in each row, then `max`.\\n\\n# Complexity\\n- Time complexity: $$ O(m*n) $$ - summing each row takes $$ O(n) $$ and we do this $$ m $$ times.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$ - no additional memory is allocated.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        # Use the negative index here since we want the \"smallest row number\"\\n        count, index = max((sum(row), -i) for i, row in enumerate(mat))\\n        # Turn index back to positive\\n        return [-index, count]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        # Use the negative index here since we want the \"smallest row number\"\\n        count, index = max((sum(row), -i) for i, row in enumerate(mat))\\n        # Turn index back to positive\\n        return [-index, count]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015006,
                "title": "javascript-max",
                "content": "# Code\\n```\\n// T: O(m*n) | S: O(1)\\nvar rowAndMaximumOnes = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    let max = 0;\\n    let ind = 0;\\n    for (let i = 0; i < m; i++) {\\n        let val = 0;\\n        for (let j = 0; j < n; j++) {\\n            val += mat[i][j];\\n        }\\n        if (val > max) {\\n            max = val;\\n            ind = i;\\n        }\\n    }\\n    return [ind, max];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// T: O(m*n) | S: O(1)\\nvar rowAndMaximumOnes = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    let max = 0;\\n    let ind = 0;\\n    for (let i = 0; i < m; i++) {\\n        let val = 0;\\n        for (let j = 0; j < n; j++) {\\n            val += mat[i][j];\\n        }\\n        if (val > max) {\\n            max = val;\\n            ind = i;\\n        }\\n    }\\n    return [ind, max];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012313,
                "title": "elixir-simple-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.reduce([0, 0], fn {row, i}, [r, ct] ->\\n      ones = Enum.count(row, &(&1 == 1))\\n\\n      if ones > ct do\\n        [i, ones]\\n      else\\n        [r, ct]\\n      end\\n    end)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.reduce([0, 0], fn {row, i}, [r, ct] ->\\n      ones = Enum.count(row, &(&1 == 1))\\n\\n      if ones > ct do\\n        [i, ones]\\n      else\\n        [r, ct]\\n      end\\n    end)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4002799,
                "title": "93-beats-java-o-n-m",
                "content": "# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] temp = new int[mat.length];\\n        int idx = -1,value = -1;\\n\\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                temp[i]+=mat[i][j];\\n            }\\n            if(value<temp[i]){\\n                    idx = i;\\n                    value = temp[i];\\n                }\\n        }\\n\\n        return new int[]{idx,value};\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] temp = new int[mat.length];\\n        int idx = -1,value = -1;\\n\\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                temp[i]+=mat[i][j];\\n            }\\n            if(value<temp[i]){\\n                    idx = i;\\n                    value = temp[i];\\n                }\\n        }\\n\\n        return new int[]{idx,value};\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990845,
                "title": "java-soltuion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[] = new int[2];\\n        int count=0,index=0,sum=0;\\n        int n=mat.length;int m=mat[0].length;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count =0;\\n            for(int j=0;j <mat[i].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n            sum=count;\\n            index=i;\\n            }\\n        }\\n        ans[0]=index;\\n        ans[1]=sum;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[] = new int[2];\\n        int count=0,index=0,sum=0;\\n        int n=mat.length;int m=mat[0].length;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count =0;\\n            for(int j=0;j <mat[i].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n            sum=count;\\n            index=i;\\n            }\\n        }\\n        ans[0]=index;\\n        ans[1]=sum;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982528,
                "title": "click-drama-drama-alert-idiot-here-at-your-service-wow-big-big",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary meaning only zeroes and ones. If all rows are of same length then the maximum of the sums of each row should be the answer. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse list comprehension and the sum() function. max() to find the highest and find the index of the highest and index() returns the first occurrence if there are multiple.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        sums = [sum(i) for i in mat]\\n        high = max(sums)\\n        ind = sums.index(high)\\n        return [ind, high]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        sums = [sum(i) for i in mat]\\n        high = max(sums)\\n        ind = sums.index(high)\\n        return [ind, high]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979126,
                "title": "sort-elixir",
                "content": "# Code\\n```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.map(fn {row, index} -> [index, count_ones(row)] end)\\n    |> sort_by()\\n    |> hd()\\n  end\\n\\n  defp count_ones(row) do\\n    Enum.count(row, fn x -> x == 1 end)\\n  end\\n\\n  defp sort_by(arr) do\\n    Enum.sort(arr, fn [a_idx, a_cnt], [b_idx, b_cnt] ->\\n      case a_cnt == b_cnt do\\n        true -> a_idx < b_idx\\n        false -> a_cnt > b_cnt\\n      end\\n    end)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.map(fn {row, index} -> [index, count_ones(row)] end)\\n    |> sort_by()\\n    |> hd()\\n  end\\n\\n  defp count_ones(row) do\\n    Enum.count(row, fn x -> x == 1 end)\\n  end\\n\\n  defp sort_by(arr) do\\n    Enum.sort(arr, fn [a_idx, a_cnt], [b_idx, b_cnt] ->\\n      case a_cnt == b_cnt do\\n        true -> a_idx < b_idx\\n        false -> a_cnt > b_cnt\\n      end\\n    end)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3978594,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        \\n        int index = -1;\\n        int max_count = -1;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            int row_count = 0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                row_count = row_count + mat[i][j];\\n            }\\n            if(row_count > max_count)\\n            {\\n                max_count = row_count;\\n                index = i;\\n            }\\n        }\\n        return {index, max_count};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        \\n        int index = -1;\\n        int max_count = -1;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            int row_count = 0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                row_count = row_count + mat[i][j];\\n            }\\n            if(row_count > max_count)\\n            {\\n                max_count = row_count;\\n                index = i;\\n            }\\n        }\\n        return {index, max_count};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3975885,
                "title": "python-94-efficient-solution-space-using-lambda-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        result = []\\n        #Traversing row\\n        for i in range(len(mat)):\\n            counter = 0\\n            #Traversing elements of the row\\n            for j in mat[i]:\\n                if j == 1:\\n                    #Count the number of 1\\'s in the row\\n                    counter += 1\\n            result.append([i,counter])\\n        result.sort(reverse=True)\\n        #Sort the result along with the number of 1 present in that row\\n        result.sort(key=lambda x:x[1])\\n        return result[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        result = []\\n        #Traversing row\\n        for i in range(len(mat)):\\n            counter = 0\\n            #Traversing elements of the row\\n            for j in mat[i]:\\n                if j == 1:\\n                    #Count the number of 1\\'s in the row\\n                    counter += 1\\n            result.append([i,counter])\\n        result.sort(reverse=True)\\n        #Sort the result along with the number of 1 present in that row\\n        result.sort(key=lambda x:x[1])\\n        return result[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966398,
                "title": "java-direct-to-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force approach\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        \\n       int ans[] = new int[2];\\n\\n       int count = 0;\\n\\n       for(int i=0; i<mat.length; i++ ){\\n\\n           int temp = 0;\\n\\n           for( int j=0; j<mat[0].length; j++){\\n\\n               if( mat[i][j] == 1 ){\\n                   temp++;\\n               }\\n           }\\n\\n           if( temp > count ){\\n\\n               count = temp;\\n               \\n               ans[0] = i;\\n               ans[1] = count;\\n\\n           }\\n       }\\n\\n       return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        \\n       int ans[] = new int[2];\\n\\n       int count = 0;\\n\\n       for(int i=0; i<mat.length; i++ ){\\n\\n           int temp = 0;\\n\\n           for( int j=0; j<mat[0].length; j++){\\n\\n               if( mat[i][j] == 1 ){\\n                   temp++;\\n               }\\n           }\\n\\n           if( temp > count ){\\n\\n               count = temp;\\n               \\n               ans[0] = i;\\n               ans[1] = count;\\n\\n           }\\n       }\\n\\n       return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965735,
                "title": "oneline-fast",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted((mat[i].count(1), -i, i, mat[i].count(1)) for i in range(len(mat)))[-1][2:]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted((mat[i].count(1), -i, i, mat[i].count(1)) for i in range(len(mat)))[-1][2:]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963997,
                "title": "c-simple-solution-runtime-106-ms-beats-93-20-memory-60-5-mb-beats-59-69",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int row_size = mat.size(), col_size = mat[0].size();\\n        vector<int> ans(2);\\n        int mx_count = INT_MIN;\\n        for(int i = 0; i < row_size; ++i){\\n            int count = 0;\\n            for(int j = 0; j < col_size; ++j){\\n                if(mat[i][j] == 1) count++;\\n            }\\n            if(mx_count < count) {\\n                ans[0] = i;\\n                ans[1] = count;\\n                mx_count = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int row_size = mat.size(), col_size = mat[0].size();\\n        vector<int> ans(2);\\n        int mx_count = INT_MIN;\\n        for(int i = 0; i < row_size; ++i){\\n            int count = 0;\\n            for(int j = 0; j < col_size; ++j){\\n                if(mat[i][j] == 1) count++;\\n            }\\n            if(mx_count < count) {\\n                ans[0] = i;\\n                ans[1] = count;\\n                mx_count = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961693,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i = 0; i < mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(arr[1] < count){\\n                arr[0] = i;\\n                arr[1] = count;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i = 0; i < mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(arr[1] < count){\\n                arr[0] = i;\\n                arr[1] = count;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959143,
                "title": "easiest-solution-possible-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] ar = new int[2];\\n        int maxi = 0;\\n       \\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n\\n            }\\n            if(!map.containsKey(count)){\\n                map.put(count,i);\\n            }\\n        }\\n       \\n        for(int i : map.keySet()){\\n            maxi = Math.max(maxi,i);\\n\\n\\n\\n        }\\n        ar[0] = map.get(maxi);\\n        ar[1] = maxi;\\n\\n    return ar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] ar = new int[2];\\n        int maxi = 0;\\n       \\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n\\n            }\\n            if(!map.containsKey(count)){\\n                map.put(count,i);\\n            }\\n        }\\n       \\n        for(int i : map.keySet()){\\n            maxi = Math.max(maxi,i);\\n\\n\\n\\n        }\\n        ar[0] = map.get(maxi);\\n        ar[1] = maxi;\\n\\n    return ar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957817,
                "title": "optimal-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955950,
                "title": "too-easy-easiest-java-solution-beats-100-o-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m * n) \\n    Where m is the number of rows and n is the number of columns in the input matrix mat.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr=new int [2];\\n        int min=Integer.MIN_VALUE;\\n        for (int i=0;i<mat.length;i++){\\n            int count=0;\\n            for (int j=0;j<mat[i].length;j++){\\n                if (mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            \\n            if (min<count){\\n                min=count;\\n                arr[0]=i;\\n            }\\n            \\n        }\\n        arr[1]=min;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr=new int [2];\\n        int min=Integer.MIN_VALUE;\\n        for (int i=0;i<mat.length;i++){\\n            int count=0;\\n            for (int j=0;j<mat[i].length;j++){\\n                if (mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            \\n            if (min<count){\\n                min=count;\\n                arr[0]=i;\\n            }\\n            \\n        }\\n        arr[1]=min;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954501,
                "title": "binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rowWithone(int[] arr,int st,int end){\\n           Arrays.sort(arr);\\n            int firstOccurence=-1;\\n\\t\\t\\twhile(st<=end){\\n\\t\\t\\t\\tint mid=(st+end)/2;\\n\\t\\t\\t\\tif(arr[mid]==1){           \\n\\t\\t\\t\\t\\tfirstOccurence=mid;\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arr[mid]<1){\\n\\t\\t\\t\\t\\tst=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t    return firstOccurence;\\n    }\\n    public int[] rowAndMaximumOnes(int[][] arr) {\\n        int n=arr.length;\\n        int m=arr[0].length;\\n        int maxValue=0;     //varible store the max count of one\\'s;\\n\\t\\tint maxValueidx=-1;  //variable store the idx of max count of one\\'s;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\tint firstOccuridx=rowWithone(arr[i],0,m-1 );    //calling function which return the first occurence index of the 1 in that row;\\n\\t\\t\\tif(firstOccuridx!=-1 && m-firstOccuridx>maxValue ){   //if the firstOuccrenc is -1 which means no one is fount on that row \\n\\t\\t\\t\\tmaxValue=m-firstOccuridx;                         //else if it is not -1 then we have to count the no of one\\'s on that row \\n\\t\\t\\t\\tmaxValueidx=i;                                    // no of one\\'s on that row are the no of ele - first occure indx;\\n\\t\\t\\t\\t                                                  //if the max count of one is more then the previous count then update it and update the max value idx;else continue \\n\\t\\t\\t}\\n\\t\\t}\\t\\n        int[] res=new int[2];\\n        if(maxValueidx==-1) res[0]=0;\\n        else res[0]=maxValueidx;\\n        res[1]=maxValue;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int rowWithone(int[] arr,int st,int end){\\n           Arrays.sort(arr);\\n            int firstOccurence=-1;\\n\\t\\t\\twhile(st<=end){\\n\\t\\t\\t\\tint mid=(st+end)/2;\\n\\t\\t\\t\\tif(arr[mid]==1){           \\n\\t\\t\\t\\t\\tfirstOccurence=mid;\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arr[mid]<1){\\n\\t\\t\\t\\t\\tst=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t    return firstOccurence;\\n    }\\n    public int[] rowAndMaximumOnes(int[][] arr) {\\n        int n=arr.length;\\n        int m=arr[0].length;\\n        int maxValue=0;     //varible store the max count of one\\'s;\\n\\t\\tint maxValueidx=-1;  //variable store the idx of max count of one\\'s;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\tint firstOccuridx=rowWithone(arr[i],0,m-1 );    //calling function which return the first occurence index of the 1 in that row;\\n\\t\\t\\tif(firstOccuridx!=-1 && m-firstOccuridx>maxValue ){   //if the firstOuccrenc is -1 which means no one is fount on that row \\n\\t\\t\\t\\tmaxValue=m-firstOccuridx;                         //else if it is not -1 then we have to count the no of one\\'s on that row \\n\\t\\t\\t\\tmaxValueidx=i;                                    // no of one\\'s on that row are the no of ele - first occure indx;\\n\\t\\t\\t\\t                                                  //if the max count of one is more then the previous count then update it and update the max value idx;else continue \\n\\t\\t\\t}\\n\\t\\t}\\t\\n        int[] res=new int[2];\\n        if(maxValueidx==-1) res[0]=0;\\n        else res[0]=maxValueidx;\\n        res[1]=maxValue;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949019,
                "title": "beats-100-ruby-easy-to-understand-2643-row-with-maximum-ones",
                "content": "# Code\\n```\\n# @param {Integer[][]} mat\\n# @return {Integer[]}\\ndef row_and_maximum_ones(matrix)\\n    max = 0\\n    index = 0\\n    matrix.each_with_index do |mat, indx|\\n        tamp_max = 0\\n        mat.each do |mt|\\n            tamp_max += 1 if mt == 1\\n        end\\n        if tamp_max > max\\n            max = tamp_max\\n            index = indx\\n        end\\n    end\\n    return [index, max]\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n# @param {Integer[][]} mat\\n# @return {Integer[]}\\ndef row_and_maximum_ones(matrix)\\n    max = 0\\n    index = 0\\n    matrix.each_with_index do |mat, indx|\\n        tamp_max = 0\\n        mat.each do |mt|\\n            tamp_max += 1 if mt == 1\\n        end\\n        if tamp_max > max\\n            max = tamp_max\\n            index = indx\\n        end\\n    end\\n    return [index, max]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3945308,
                "title": "count-and-maximum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr = new int[mat.length];\\n        for(int i=0; i<mat.length; i++){\\n            int count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            arr[i]=count;\\n        }\\n\\n        int max=0;\\n        int ind=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                ind=i;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr = new int[mat.length];\\n        for(int i=0; i<mat.length; i++){\\n            int count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            arr[i]=count;\\n        }\\n\\n        int max=0;\\n        int ind=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                ind=i;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942937,
                "title": "short-and-simple-python3-beats-99-9-runtime",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        for i, row in enumerate(mat):\\n            c = row.count(1)\\n            if c > res[1]:\\n                res[:] = i, c             \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        for i, row in enumerate(mat):\\n            c = row.count(1)\\n            if c > res[1]:\\n                res[:] = i, c             \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938486,
                "title": "c-o-n-logm-solution",
                "content": "# Intuition\\nIf the row was sorted then I can easily find the count of ones using by finding first occurence of 1 using lower bound/first occurence\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort every row\\nFind the first occrrence of 1.\\nCount of 1s in the row is then just row.size() - firstOccurrence\\n\\n# Complexity\\n- Time complexity:\\nO(n* log m) when n is number of rows and m is number of columns\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        for(auto &row:mat){\\n            sort(row.begin(), row.end());\\n        }\\n\\n        int currentMax=-1, idx=-1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int firstOccurrence = lower_bound(mat[i].begin(), mat[i].end(), 1) - mat[i].begin();\\n            int currentCount = mat[i].size()-firstOccurrence;\\n            if(currentCount>currentMax){\\n                currentMax=currentCount;\\n                idx=i;\\n            }\\n        }\\n        return {idx, currentMax};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        for(auto &row:mat){\\n            sort(row.begin(), row.end());\\n        }\\n\\n        int currentMax=-1, idx=-1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int firstOccurrence = lower_bound(mat[i].begin(), mat[i].end(), 1) - mat[i].begin();\\n            int currentCount = mat[i].size()-firstOccurrence;\\n            if(currentCount>currentMax){\\n                currentMax=currentCount;\\n                idx=i;\\n            }\\n        }\\n        return {idx, currentMax};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930828,
                "title": "easy-c-solution-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith one row at a time,you just need to iterate over the column elements of respective rows and update curr element.If max>curr just update your max and index.It is important to keep note that the curr variable should be updated to zero after each iteration in order to avoid any discrepancy.Its using just an additional space for storing result which makes it quite efficient.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity: 0(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        int firstrow = 0;\\n        int lastrow = m-1;\\n        int firstcol = 0;\\n        int lastcol = n-1;\\n\\n        vector<int>ans;\\n        int max_one = 0;\\n        int index = 0;\\n\\n        for(int row = firstrow;row<=lastrow;row++){\\n            int curr = 0;\\n            for(int col = firstcol;col<=lastcol;col++){\\n                if(mat[row][col] == 1){\\n                    curr++;\\n                }\\n                else{\\n                    continue;\\n                }\\n                if(curr>max_one){\\n                    max_one = curr;\\n                    index = row;\\n                }\\n            }\\n        }\\n        ans.push_back(index);\\n        ans.push_back(max_one);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        int firstrow = 0;\\n        int lastrow = m-1;\\n        int firstcol = 0;\\n        int lastcol = n-1;\\n\\n        vector<int>ans;\\n        int max_one = 0;\\n        int index = 0;\\n\\n        for(int row = firstrow;row<=lastrow;row++){\\n            int curr = 0;\\n            for(int col = firstcol;col<=lastcol;col++){\\n                if(mat[row][col] == 1){\\n                    curr++;\\n                }\\n                else{\\n                    continue;\\n                }\\n                if(curr>max_one){\\n                    max_one = curr;\\n                    index = row;\\n                }\\n            }\\n        }\\n        ans.push_back(index);\\n        ans.push_back(max_one);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929440,
                "title": "java-soluction",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum=0;\\n        int index=0;int count=0;\\n        for(int i=0;i<mat.length;i++){\\n            count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n                sum=count;\\n                index=i;\\n            }\\n        }\\n        int arr[]={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum=0;\\n        int index=0;int count=0;\\n        for(int i=0;i<mat.length;i++){\\n            count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n                sum=count;\\n                index=i;\\n            }\\n        }\\n        int arr[]={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926603,
                "title": "row-with-maximum-ones",
                "content": "# Complexity\\n- Time complexity:O(N*logM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\nint lowerbound(vector<int>arr,int n){\\n        if(n==1) return arr[0]==1;\\n        int low=0,high=n-1;\\n        sort(arr.begin(),arr.end());\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(arr[mid]==1){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return (n-1)-low+1;\\n    }\\n    public:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxi=0;\\n        int index=0;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        for(int i=0;i<n;i++){\\n            int cnt_ones=lowerbound(mat[i],m);\\n            if(cnt_ones>maxi){\\n                maxi=cnt_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\nint lowerbound(vector<int>arr,int n){\\n        if(n==1) return arr[0]==1;\\n        int low=0,high=n-1;\\n        sort(arr.begin(),arr.end());\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(arr[mid]==1){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return (n-1)-low+1;\\n    }\\n    public:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxi=0;\\n        int index=0;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        for(int i=0;i<n;i++){\\n            int cnt_ones=lowerbound(mat[i],m);\\n            if(cnt_ones>maxi){\\n                maxi=cnt_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923778,
                "title": "python-beats-96-runtime-95-memory-coded-on-mobile",
                "content": "![image](https://assets.leetcode.com/users/images/4cbb30dd-9007-4e98-938e-aee6c806a6b8_1692295282.9749117.jpeg)\\n![image](https://assets.leetcode.com/users/images/c46adaeb-f468-4681-bf13-4e6e8c7bf59f_1692295283.356553.jpeg)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/4cbb30dd-9007-4e98-938e-aee6c806a6b8_1692295282.9749117.jpeg)\\n![image](https://assets.leetcode.com/users/images/c46adaeb-f468-4681-bf13-4e6e8c7bf59f_1692295283.356553.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3923316,
                "title": "iteration-and-reduce-ts-js",
                "content": "\\n# Approach\\ninitialize max variable with values = [-1,-1]\\niterate through each row \\nsum all 1s in the row using reduce\\nif sum is greater than the stored value in max, update max\\n\\n\\n# Code\\n```\\nfunction rowAndMaximumOnes(mat: number[][]): number[] {\\n  let max = [-1, -1]\\n  mat.forEach((val, i) => {\\n    const x = val.reduce((acc,val) => val ? (acc + val) : acc, 0)\\n    if (x > max[1]) { max = [i, x]}\\n  })\\n  return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction rowAndMaximumOnes(mat: number[][]): number[] {\\n  let max = [-1, -1]\\n  mat.forEach((val, i) => {\\n    const x = val.reduce((acc,val) => val ? (acc + val) : acc, 0)\\n    if (x > max[1]) { max = [i, x]}\\n  })\\n  return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3904858,
                "title": "simple-javascript-80-ms-beats-92",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let m = mat.length;\\n    let n = mat[0].length;\\n\\n    let row = 0, count = 0;\\n\\n    for(let i = 0; i < m; i++) {\\n        let rowCount = 0;\\n        for(let j = 0; j < n; j++) {\\n            if(mat[i][j] === 1) {\\n                rowCount++;\\n            }\\n\\n            if(rowCount > count) {\\n                count = rowCount;\\n                row = i;\\n            }\\n        }\\n    }\\n    return [row, count];\\n};\\n\\n// TC: O(m * n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let m = mat.length;\\n    let n = mat[0].length;\\n\\n    let row = 0, count = 0;\\n\\n    for(let i = 0; i < m; i++) {\\n        let rowCount = 0;\\n        for(let j = 0; j < n; j++) {\\n            if(mat[i][j] === 1) {\\n                rowCount++;\\n            }\\n\\n            if(rowCount > count) {\\n                count = rowCount;\\n                row = i;\\n            }\\n        }\\n    }\\n    return [row, count];\\n};\\n\\n// TC: O(m * n)\\n// SC: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903945,
                "title": "python-simple-solution-nested-loops-beginner-friendly",
                "content": "# Intuition\\n\\n---\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(mat)\\n        n = len(mat[0])\\n        maxcount = 0\\n        index = 0\\n\\n        for i in range(m):\\n            count = 0\\n            for j in range(n):\\n                if mat[i][j] == 1:\\n                    count +=1\\n\\n                    if count > maxcount:\\n                        maxcount = count\\n                        index = i\\n        return [index,maxcount]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(mat)\\n        n = len(mat[0])\\n        maxcount = 0\\n        index = 0\\n\\n        for i in range(m):\\n            count = 0\\n            for j in range(n):\\n                if mat[i][j] == 1:\\n                    count +=1\\n\\n                    if count > maxcount:\\n                        maxcount = count\\n                        index = i\\n        return [index,maxcount]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894967,
                "title": "python3-solution-everything-explained-line-by-line-both-time-and-space-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #Both time (828ms beats 94%) and memory (16.73mb beats 92.38%) effiecent\\n        max_ones = 0\\n        ans = []\\n        i = 0     # a variable to trace the index we are at.\\n        for lst in mat:\\n            lst_sum = sum(lst)\\n            if max_ones <= lst_sum:\\n                max_ones =  lst_sum\\n                ans.append([i,lst_sum])\\n            i+=1\\n        num_once  = []\\n        final_ans  = []\\n        #the following code block ensures the row with the smallest row number is selected. \\n        for i in range(len(ans)):\\n            if ans[i][-1] not in num_once:\\n                num_once.append(ans[i][-1])\\n                final_ans.append(ans[i])\\n           \\n        return final_ans[-1] # Since, the one which is lastly selected, for sure contains max_ones \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #Both time (828ms beats 94%) and memory (16.73mb beats 92.38%) effiecent\\n        max_ones = 0\\n        ans = []\\n        i = 0     # a variable to trace the index we are at.\\n        for lst in mat:\\n            lst_sum = sum(lst)\\n            if max_ones <= lst_sum:\\n                max_ones =  lst_sum\\n                ans.append([i,lst_sum])\\n            i+=1\\n        num_once  = []\\n        final_ans  = []\\n        #the following code block ensures the row with the smallest row number is selected. \\n        for i in range(len(ans)):\\n            if ans[i][-1] not in num_once:\\n                num_once.append(ans[i][-1])\\n                final_ans.append(ans[i])\\n           \\n        return final_ans[-1] # Since, the one which is lastly selected, for sure contains max_ones \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885537,
                "title": "simple-and-easy-java-soulution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int max=0,ind=0;\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(max<c){\\n                ind=i;\\n                max=c;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int max=0,ind=0;\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(max<c){\\n                ind=i;\\n                max=c;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884509,
                "title": "rust-solution-easy-to-understand",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let (mut row_number, mut ones) = (0, 0);\\n        for (index, row) in mat.iter().enumerate() {\\n            let local_ones = row.iter().filter(|&&x| x == 1).count();\\n            if index == 0 {\\n                ones = local_ones;\\n                continue;\\n            }\\n            if local_ones > ones {\\n                row_number = index;\\n                ones = local_ones;\\n            }\\n        }\\n        vec![row_number as i32, ones as i32]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let (mut row_number, mut ones) = (0, 0);\\n        for (index, row) in mat.iter().enumerate() {\\n            let local_ones = row.iter().filter(|&&x| x == 1).count();\\n            if index == 0 {\\n                ones = local_ones;\\n                continue;\\n            }\\n            if local_ones > ones {\\n                row_number = index;\\n                ones = local_ones;\\n            }\\n        }\\n        vec![row_number as i32, ones as i32]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880237,
                "title": "swift-simple-solution-for-newbie",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func rowAndMaximumOnes(_ mat: [[Int]]) -> [Int] { \\n    var answer = [0,0]\\n\\n    for i in 0..<mat.count {\\n        let a = mat[i].reduce(0) {$0 + $1}\\n        if a > answer[1] {\\n            answer[1] = a\\n            answer[0] = i\\n        }\\n    }\\n\\n    return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func rowAndMaximumOnes(_ mat: [[Int]]) -> [Int] { \\n    var answer = [0,0]\\n\\n    for i in 0..<mat.count {\\n        let a = mat[i].reduce(0) {$0 + $1}\\n        if a > answer[1] {\\n            answer[1] = a\\n            answer[0] = i\\n        }\\n    }\\n\\n    return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877382,
                "title": "100-efficiant-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count;\\n        int ans=0;\\n        int row=0;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            count=0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if (count>ans) \\n            {\\n                ans = count;\\n                row = i;\\n            }\\n        }\\n        return {row,ans};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count;\\n        int ans=0;\\n        int row=0;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            count=0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if (count>ans) \\n            {\\n                ans = count;\\n                row = i;\\n            }\\n        }\\n        return {row,ans};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877021,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] ans = {0,0};\\n        int max  = 0, idx = 0;\\n        for(int i=0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n                if(count > max){\\n                    max  = count;\\n                    idx = i;\\n                }\\n            } \\n        }\\n        ans[0] = idx;\\n        ans[1] =  max;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] ans = {0,0};\\n        int max  = 0, idx = 0;\\n        for(int i=0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n                if(count > max){\\n                    max  = count;\\n                    idx = i;\\n                }\\n            } \\n        }\\n        ans[0] = idx;\\n        ans[1] =  max;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876131,
                "title": "java-clear-solution",
                "content": "\\n# Complexity\\n- Time complexity: *O(m * n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] result = new int[2];\\n        int n = mat.length, \\n            m = mat[0].length,\\n            max = 0,\\n            tem = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            tem = 0;\\n            for(int j = 0; j < m; j++)\\n               if(mat[i][j] == 1) tem ++;\\n            \\n            if(tem > max){\\n                max = tem;\\n                result[0] = i;\\n                result[1] = max;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] result = new int[2];\\n        int n = mat.length, \\n            m = mat[0].length,\\n            max = 0,\\n            tem = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            tem = 0;\\n            for(int j = 0; j < m; j++)\\n               if(mat[i][j] == 1) tem ++;\\n            \\n            if(tem > max){\\n                max = tem;\\n                result[0] = i;\\n                result[1] = max;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874937,
                "title": "easy-solution-in-c-beats-93",
                "content": "# Intuition\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ma=0;\\n        int mi=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(ma<c && c!=0){\\n                ma=c;\\n                if(mi<i){\\n                    mi=i;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        ans.push_back(mi);\\n        ans.push_back(ma);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ma=0;\\n        int mi=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(ma<c && c!=0){\\n                ma=c;\\n                if(mi<i){\\n                    mi=i;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        ans.push_back(mi);\\n        ans.push_back(ma);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873695,
                "title": "to-find-maximum-ones-in-2d-array-and-output-contains-index-of-maximum-ones-and-count-of-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int counter[] = new int[mat.length];\\n\\n//the below code to find the ones in the 2D array\\n        for(int i =0; i<mat.length; i++){\\n            for(int j = 0; j< mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    counter[i]++;\\n                }\\n            }\\n        }\\n\\n        int finalCount =Integer.MIN_VALUE; //to store minus infinity\\n       int m =0;\\n        for(int i = counter.length-1;i >= 0;i--){\\n            if(counter[i] >= finalCount){\\n                finalCount = counter[i];\\n                m = i;\\n            }\\n        }\\n     //  int max = finalCount;\\n       //int index = m;\\n        int con[] ={m,finalCount};\\n    return con;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int counter[] = new int[mat.length];\\n\\n//the below code to find the ones in the 2D array\\n        for(int i =0; i<mat.length; i++){\\n            for(int j = 0; j< mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    counter[i]++;\\n                }\\n            }\\n        }\\n\\n        int finalCount =Integer.MIN_VALUE; //to store minus infinity\\n       int m =0;\\n        for(int i = counter.length-1;i >= 0;i--){\\n            if(counter[i] >= finalCount){\\n                finalCount = counter[i];\\n                m = i;\\n            }\\n        }\\n     //  int max = finalCount;\\n       //int index = m;\\n        int con[] ={m,finalCount};\\n    return con;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870704,
                "title": "solution-with-enu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, float(\"-inf\")]\\n        for i, v in enumerate(mat):\\n            if res[1] < (s:=sum(v)):\\n                res[1] = s\\n                res[0] = i\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, float(\"-inf\")]\\n        for i, v in enumerate(mat):\\n            if res[1] < (s:=sum(v)):\\n                res[1] = s\\n                res[0] = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868524,
                "title": "simple-iterative-decision",
                "content": "## Code\\n![image.png](https://assets.leetcode.com/users/images/83391be2-74af-480c-bf4a-f1805a847370_1691256904.8159122.png)\\n\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        result = [0,0]\\n        for idx, row in enumerate(mat):\\n            s = sum(row)\\n            if s > result[1]:\\n                result = [idx, s]\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        result = [0,0]\\n        for idx, row in enumerate(mat):\\n            s = sum(row)\\n            if s > result[1]:\\n                result = [idx, s]\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864083,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n          int rows=mat.length;\\n          int cols=mat[0].length;\\n          \\n          int ans[]=new int[2];\\n          int idx=0;\\n          int count=Integer.MIN_VALUE;\\n\\n          for(int i=0; i<rows; i++)\\n          {\\n                 int cnt=0;\\n             for(int j=0; j<cols; j++)\\n             {\\n                 if(mat[i][j]==1)\\n                 {\\n                   cnt++;\\n                 }\\n             }\\n             if(cnt>count)\\n             {\\n                 count=cnt;\\n                 idx=i;\\n             }\\n          }\\n          ans[0]=idx;\\n          ans[1]=count;\\n\\n          return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n          int rows=mat.length;\\n          int cols=mat[0].length;\\n          \\n          int ans[]=new int[2];\\n          int idx=0;\\n          int count=Integer.MIN_VALUE;\\n\\n          for(int i=0; i<rows; i++)\\n          {\\n                 int cnt=0;\\n             for(int j=0; j<cols; j++)\\n             {\\n                 if(mat[i][j]==1)\\n                 {\\n                   cnt++;\\n                 }\\n             }\\n             if(cnt>count)\\n             {\\n                 count=cnt;\\n                 idx=i;\\n             }\\n          }\\n          ans[0]=idx;\\n          ans[1]=count;\\n\\n          return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857580,
                "title": "the-realworld-solution-for-java",
                "content": "# Intuition\\nThinking about the solution\\n\\n# Approach\\nWriting the solution\\n\\n# Complexity\\n- Time complexity:\\n\\u044F \\u0434\\u0443\\u043C\\u0430\\u044E \\u0448\\u043E \\u041E(n)\\n\\n- Space complexity:\\n\\u043D\\u0435 \\u041E(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0;\\n        int index = 0;\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            int count = 0;\\n\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) count++;\\n            }\\n\\n            if(count > max) index = i;\\n            max = Math.max(max, count);\\n        }\\n\\n        int[] RealWorld = new int[] {index, max};\\n\\n        return RealWorld;\\n    }\\n}\\n```\\n\\nUpvote if you want Andrew Tate to be free :)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0;\\n        int index = 0;\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            int count = 0;\\n\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) count++;\\n            }\\n\\n            if(count > max) index = i;\\n            max = Math.max(max, count);\\n        }\\n\\n        int[] RealWorld = new int[] {index, max};\\n\\n        return RealWorld;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854102,
                "title": "python-beginner-s-friendly-solution-think-easiest-way",
                "content": "I think the code is not like pythonic. But here is my simple solution.\\nPlease any advice me. It would be help.\\nThanks for reading. :)\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        max_cnt = 0\\n        answer = []\\n        for i in range(len(mat)):\\n            if mat[i].count(1) > max_cnt:\\n                answer = []\\n                max_cnt = mat[i].count(1)\\n                answer.append(i)\\n                answer.append(max_cnt)\\n        if max_cnt == 0:\\n            answer.append(0)\\n            answer.append(0)\\n        return answer\\n        \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        max_cnt = 0\\n        answer = []\\n        for i in range(len(mat)):\\n            if mat[i].count(1) > max_cnt:\\n                answer = []\\n                max_cnt = mat[i].count(1)\\n                answer.append(i)\\n                answer.append(max_cnt)\\n        if max_cnt == 0:\\n            answer.append(0)\\n            answer.append(0)\\n        return answer\\n        \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851496,
                "title": "easy-understandable",
                "content": "\\n# Complexity\\n- Time complexity: O (m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int sz = mat.size();\\n        int szin = mat[0].size();\\n\\n        int cntofone = 0;\\n        int idx = 0;\\n\\n        for(int i = 0; i < sz; i++){\\n            int cnt = 0;\\n            for(int j = 0; j <szin ; j++){\\n\\n                if(mat[i][j]==1)cnt++;\\n\\n            }\\n\\n            if(cntofone < cnt){\\n                cntofone = cnt;\\n                idx = i;\\n            }\\n        }\\n        vector<int>result = {idx, cntofone};\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int sz = mat.size();\\n        int szin = mat[0].size();\\n\\n        int cntofone = 0;\\n        int idx = 0;\\n\\n        for(int i = 0; i < sz; i++){\\n            int cnt = 0;\\n            for(int j = 0; j <szin ; j++){\\n\\n                if(mat[i][j]==1)cnt++;\\n\\n            }\\n\\n            if(cntofone < cnt){\\n                cntofone = cnt;\\n                idx = i;\\n            }\\n        }\\n        vector<int>result = {idx, cntofone};\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865174,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Perfect way  to start your day with this easy beautiful problem"
                    },
                    {
                        "username": "shahil3303",
                        "content": "simple solution\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain one way to do it in great length, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/row-with-maximum-ones/solutions/3422198/how-about-a-python-one-liner-detailed-begginer-friendly-explanations/)"
                    }
                ]
            },
            {
                "id": 1869530,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Perfect way  to start your day with this easy beautiful problem"
                    },
                    {
                        "username": "shahil3303",
                        "content": "simple solution\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain one way to do it in great length, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/row-with-maximum-ones/solutions/3422198/how-about-a-python-one-liner-detailed-begginer-friendly-explanations/)"
                    }
                ]
            },
            {
                "id": 1865186,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Perfect way  to start your day with this easy beautiful problem"
                    },
                    {
                        "username": "shahil3303",
                        "content": "simple solution\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain one way to do it in great length, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/row-with-maximum-ones/solutions/3422198/how-about-a-python-one-liner-detailed-begginer-friendly-explanations/)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sliding Subarray Beauty",
        "question_content": "<p>Given an integer array <code>nums</code> containing <code>n</code> integers, find the <strong>beauty</strong> of each subarray of size <code>k</code>.</p>\n\n<p>The <strong>beauty</strong> of a subarray is the <code>x<sup>th</sup></code><strong> smallest integer </strong>in the subarray if it is <strong>negative</strong>, or <code>0</code> if there are fewer than <code>x</code> negative integers.</p>\n\n<p>Return <em>an integer array containing </em><code>n - k + 1</code> <em>integers, which denote the </em><strong>beauty</strong><em> of the subarrays <strong>in order</strong> from the first index in the array.</em></p>\n\n<ul>\n\t<li>\n\t<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,-1,-3,-2,3], k = 3, x = 2\n<strong>Output:</strong> [-1,-2,-2]\n<strong>Explanation:</strong> There are 3 subarrays with size k = 3. \nThe first subarray is <code>[1, -1, -3]</code> and the 2<sup>nd</sup> smallest negative integer is -1.&nbsp;\nThe second subarray is <code>[-1, -3, -2]</code> and the 2<sup>nd</sup> smallest negative integer is -2.&nbsp;\nThe third subarray is <code>[-3, -2, 3]&nbsp;</code>and the 2<sup>nd</sup> smallest negative integer is -2.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3,-4,-5], k = 2, x = 2\n<strong>Output:</strong> [-1,-2,-3,-4]\n<strong>Explanation:</strong> There are 4 subarrays with size k = 2.\nFor <code>[-1, -2]</code>, the 2<sup>nd</sup> smallest negative integer is -1.\nFor <code>[-2, -3]</code>, the 2<sup>nd</sup> smallest negative integer is -2.\nFor <code>[-3, -4]</code>, the 2<sup>nd</sup> smallest negative integer is -3.\nFor <code>[-4, -5]</code>, the 2<sup>nd</sup> smallest negative integer is -4.&nbsp;</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-3,1,2,-3,0,-3], k = 2, x = 1\n<strong>Output:</strong> [-3,0,-3,-3,-3]\n<strong>Explanation:</strong> There are 5 subarrays with size k = 2<strong>.</strong>\nFor <code>[-3, 1]</code>, the 1<sup>st</sup> smallest negative integer is -3.\nFor <code>[1, 2]</code>, there is no negative integer so the beauty is 0.\nFor <code>[2, -3]</code>, the 1<sup>st</sup> smallest negative integer is -3.\nFor <code>[-3, 0]</code>, the 1<sup>st</sup> smallest negative integer is -3.\nFor <code>[0, -3]</code>, the 1<sup>st</sup> smallest negative integer is -3.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length&nbsp;</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>1 &lt;= x &lt;= k&nbsp;</code></li>\n\t<li><code>-50&nbsp;&lt;= nums[i] &lt;= 50&nbsp;</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3445659,
                "title": "c-java-python3-simple-counting",
                "content": "\\n# Intuition\\nSince the range of numbers is small `-50 <= nums[i] <= 50`  we can use this to our advantage. Store counts of numbers smaller than 0 in a counter array and use that to find the `xth` smallest number.  \\n\\n# Approach\\nIterate over the counter array and sum the counts of each number. When the sum of counts is greater than or equal to `x` we have found out `xth` smallest number. If sum of counts is never greater than or equal to `x` there aren\\'t enough negative numbers.\\nLine by line explanation:\\n1. `if nums[i] < 0: counter[nums[i] + 50] += 1` For negative numbers increment counter, -50 is mapped to 0, -1 is mapped to 49.\\n2. `if i - k >= 0 and nums[i - k] < 0: counter[nums[i - k] + 50] -= 1` Since we only have to consider a window of size k, we need to remove elements on the front of the sliding window. The front will be at  index `i - k`. Now since we only added negative numbers to the counter we\\'ll remove only if `nums[i - k]` is negative.\\n3. `if i - k + 1 < 0: continue` This checks if the sliding window has atleast k elements\\n4. The rest of the code iterates over the `counter` array to find the `xth` smallest number.\\n\\n# Complexity\\n- Time complexity: `O(n * 50)`\\n\\n- Space complexity: `O(n - k + 1 + 50)`\\n\\n# Code\\n**Python3**:\\n```\\ndef getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    counter, ans = [0] * 50, [0] * (len(nums) - k + 1)\\n    for i in range(len(nums)):\\n        if nums[i] < 0: counter[nums[i] + 50] += 1\\n        if i - k >= 0 and nums[i - k] < 0: counter[nums[i - k] + 50] -= 1\\n        if i - k + 1 < 0: continue\\n        count = 0\\n        for j in range(50):\\n            count += counter[j]\\n            if count >= x:\\n                ans[i - k + 1] = j - 50\\n                break\\n    return ans\\n```\\n\\n**C++**:\\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\n**C++ but more concise**:\\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\\n**Java**:\\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\n**Java but more concise**:\\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if ((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\\n\\n## Bonus:\\nUse `SortedList` in Python:\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl, ans = SortedList(), []\\n        for i, y in enumerate(nums):\\n            sl.add(y)\\n            if len(sl) > k: sl.remove(nums[i - k])\\n            if i >= k - 1: ans.append(min(0, sl[x - 1]))\\n        return ans\\n```\\nTime Complexity: `O(nlogk)`",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    counter, ans = [0] * 50, [0] * (len(nums) - k + 1)\\n    for i in range(len(nums)):\\n        if nums[i] < 0: counter[nums[i] + 50] += 1\\n        if i - k >= 0 and nums[i - k] < 0: counter[nums[i - k] + 50] -= 1\\n        if i - k + 1 < 0: continue\\n        count = 0\\n        for j in range(50):\\n            count += counter[j]\\n            if count >= x:\\n                ans[i - k + 1] = j - 50\\n                break\\n    return ans\\n```\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if ((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl, ans = SortedList(), []\\n        for i, y in enumerate(nums):\\n            sl.add(y)\\n            if len(sl) > k: sl.remove(nums[i - k])\\n            if i >= k - 1: ans.append(min(0, sl[x - 1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445677,
                "title": "cpp-java-python-sliding-window-explanation-with-comments",
                "content": "\\n\\n>##### \\uD83D\\uDD3C IF YOU HELPFUL, PLEASE UPVOTE \\n---\\n\\n#### Approach :\\n* First observation is `-50 <= nums[i] <= 50`, we have only 50 negative numbers so we track of them in freq array\\n* Calculate xth smallest number in freq array\\n\\n---\\n#### Explanation : \\n* In given question, we have `-50 <= nums[i] <= 50` means only ` -50 to -1` negative elements and we need to calculate `xth` smallest negative element. We only deal with negative element in `k` size of sliding window.\\n* But one question like that How to calculate `xth smallest negative element` in current sliding windows bcz each time smallest element change?\\n* We just track of negative number of each sliding window and calculate `xth` smallest element.\\n* But, How to calculate `xth` negative element in current windows?\\n* We have freq of negative numbers in current windows so just calculate from `-50 to -1` xth negative element in `O(50)` constant time.\\n---\\n\\n#### Coplexity :\\n* Time Complexity : `O(N * 50)`\\n* Space Complexity : `O(50)`\\n---\\n\\n\\n###### Special Thanks to `@ManojKumarPatnaik` for `Java` solution\\n---\\n#### Solution :\\n\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(51, 0), ans;\\n        \\n        for(int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if(nums[i] < 0) freq[abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { ans.push_back(-L); break;}\\n                }\\n                // No xth smallest number present \\n                if(cnt < x) ans.push_back(0);\\n                if(nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n```java []\\n public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if (nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) { \\n                        ans.add(-L);\\n                        break;\\n                    }\\n                }\\n                // No xth smallest number present \\n                if (cnt < x) ans.add(0);\\n                if (nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n```\\n\\n```python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        freq, ans, j = [0] * 51, [], 0\\n\\n        for i in range(len(nums)):\\n            # count freq of negative numbers in current sliding windows\\n            if nums[i] < 0 : freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k :\\n                cnt = 0\\n                # calculate xth smallest number in current sliding windows\\n                for L in reversed(range(51)):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        ans.append(-L)\\n                        break\\n                # No xth smallest number present \\n                if cnt < x : ans.append(0)\\n                if nums[j] < 0 : freq[abs(nums[j])] -= 1\\n                j += 1\\n            \\n        return ans\\n        \\n```\\n\\n>Have a good day. Happy Coding!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(51, 0), ans;\\n        \\n        for(int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if(nums[i] < 0) freq[abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { ans.push_back(-L); break;}\\n                }\\n                // No xth smallest number present \\n                if(cnt < x) ans.push_back(0);\\n                if(nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```java []\\n public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if (nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) { \\n                        ans.add(-L);\\n                        break;\\n                    }\\n                }\\n                // No xth smallest number present \\n                if (cnt < x) ans.add(0);\\n                if (nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n```\n```python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        freq, ans, j = [0] * 51, [], 0\\n\\n        for i in range(len(nums)):\\n            # count freq of negative numbers in current sliding windows\\n            if nums[i] < 0 : freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k :\\n                cnt = 0\\n                # calculate xth smallest number in current sliding windows\\n                for L in reversed(range(51)):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        ans.append(-L)\\n                        break\\n                # No xth smallest number present \\n                if cnt < x : ans.append(0)\\n                if nums[j] < 0 : freq[abs(nums[j])] -= 1\\n                j += 1\\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445945,
                "title": "using-map-sliding-window-very-simple-easy-to-understand",
                "content": "<b> Up Vote if you like the solution</b>\\n# Approach\\nUsing map we will keep storing the count of -50 to 50 in each window of size k.\\nThen with each window need to search the xth smallest element by counting the number of occurance of each element, in the map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); ++i){\\n            mp[nums[i]]++;\\n            if(i >= k-1){ \\n                if(i >= k) mp[nums[i-k]]--;\\n                int sum = 0, t = 0;\\n                for(auto m: mp){\\n                    sum += m.second;\\n                    if(sum >= x){\\n                        t = (m.first < 0)? m.first: 0;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); ++i){\\n            mp[nums[i]]++;\\n            if(i >= k-1){ \\n                if(i >= k) mp[nums[i-k]]--;\\n                int sum = 0, t = 0;\\n                for(auto m: mp){\\n                    sum += m.second;\\n                    if(sum >= x){\\n                        t = (m.first < 0)? m.first: 0;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445735,
                "title": "c-multiset-using-next-function-explained",
                "content": "**DISCLAIMER: This is not an optimised approach but it is working**\\t\\n\\n\\n**C++ Code:**\\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size(), j = 0;\\n        \\n        multiset<int> ms;\\n        vector<int> res;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(nums[i] < 0) ms.insert(nums[i]);\\n            \\n            if(i-j+1 == k) {\\n                \\n                if(ms.size() < x)res.push_back(0);\\n                else res.push_back(*next(ms.begin(), x - 1));\\n                \\n                if(nums[j] < 0) ms.erase(ms.find(nums[j]));\\n                \\n                j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size(), j = 0;\\n        \\n        multiset<int> ms;\\n        vector<int> res;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(nums[i] < 0) ms.insert(nums[i]);\\n            \\n            if(i-j+1 == k) {\\n                \\n                if(ms.size() < x)res.push_back(0);\\n                else res.push_back(*next(ms.begin(), x - 1));\\n                \\n                if(nums[j] < 0) ms.erase(ms.find(nums[j]));\\n                \\n                j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445781,
                "title": "python3-sortedlist",
                "content": "\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k: vals.remove(nums[i-k])\\n            if i >= k-1: ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k: vals.remove(nums[i-k])\\n            if i >= k-1: ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446019,
                "title": "policy-based-c",
                "content": "```\\n#include<iostream>\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp> \\n\\nusing namespace __gnu_pbds; \\nusing namespace std;\\n\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n    int rank = t.order_of_key(v);\\n    ordered_set::iterator it = t.find_by_order(rank);\\n    t.erase(it);\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set st;\\n        int i=0,j=0;\\n        vector<int> ans;\\n        while(j<nums.size())\\n        {\\n            if(nums[j]<0)\\n            st.insert(nums[j]);\\n            if(j-i+1==k)\\n            {\\n                if(st.size()<x)\\n                ans.push_back(0);\\n                else\\n                {\\n                    auto temp = st.find_by_order(x-1);\\n                    ans.push_back(*temp);\\n                }\\n                if(nums[i]<0)\\n                myerase(st,nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<iostream>\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp> \\n\\nusing namespace __gnu_pbds; \\nusing namespace std;\\n\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n    int rank = t.order_of_key(v);\\n    ordered_set::iterator it = t.find_by_order(rank);\\n    t.erase(it);\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set st;\\n        int i=0,j=0;\\n        vector<int> ans;\\n        while(j<nums.size())\\n        {\\n            if(nums[j]<0)\\n            st.insert(nums[j]);\\n            if(j-i+1==k)\\n            {\\n                if(st.size()<x)\\n                ans.push_back(0);\\n                else\\n                {\\n                    auto temp = st.find_by_order(x-1);\\n                    ans.push_back(*temp);\\n                }\\n                if(nums[i]<0)\\n                myerase(st,nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446035,
                "title": "javascript-2653-sliding-subarray-beauty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar getSubarrayBeauty = function (a, k, x) {\\n    let n = a.length;\\n\\n    let f = {}; // frequency count\\n    for (let i = -50; i <= 50; i++) {\\n        f[i] = 0;\\n    }\\n\\n    let an = [];\\n    let j = 0;\\n    for (let i = 0; i < n; i++) {\\n        f[a[i]]++;\\n        if (i < k - 1) continue; // skip first k-1 elements\\n\\n        let c = 0; // count\\n        for (let i2 = -50; i2 <= 50; i2++)\\n            if (f[i2]) {\\n                c += f[i2]; // add frequency to count\\n                if (c >= x) {\\n                    if (i2 < 0) an.push(i2);\\n                    else an.push(0);\\n                    break;\\n                }\\n            }\\n\\n        f[a[j]]--;\\n        j++;\\n    }\\n\\n    return an;\\n};\\n```\\n\\n---\\n\\n**Contest**\\n- https://leetcode.com/contest/weekly-contest-342/ranking/67/\\n\\n**All Answers**\\n- **Q1** - https://leetcode.com/problems/calculate-delayed-arrival-time/solutions/3446023/javascript-2651-calculate-delayed-arrival-time/?orderBy=most_votes\\n- **Q2** - https://leetcode.com/problems/sum-multiples/solutions/3446027/javascript-2652-sum-multiples/?orderBy=most_votes\\n- **Q3** - https://leetcode.com/problems/sliding-subarray-beauty/solutions/3446035/javascript-2653-sliding-subarray-beauty/?orderBy=most_votes\\n- **Q4** - https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solutions/3446411/javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1/?orderBy=most_votes\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/37970e7b-b559-4aa9-834c-e178df5ddaa7_1682232917.7638698.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getSubarrayBeauty = function (a, k, x) {\\n    let n = a.length;\\n\\n    let f = {}; // frequency count\\n    for (let i = -50; i <= 50; i++) {\\n        f[i] = 0;\\n    }\\n\\n    let an = [];\\n    let j = 0;\\n    for (let i = 0; i < n; i++) {\\n        f[a[i]]++;\\n        if (i < k - 1) continue; // skip first k-1 elements\\n\\n        let c = 0; // count\\n        for (let i2 = -50; i2 <= 50; i2++)\\n            if (f[i2]) {\\n                c += f[i2]; // add frequency to count\\n                if (c >= x) {\\n                    if (i2 < 0) an.push(i2);\\n                    else an.push(0);\\n                    break;\\n                }\\n            }\\n\\n        f[a[j]]--;\\n        j++;\\n    }\\n\\n    return an;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445753,
                "title": "cpp-window-sliding-open-addressing-map",
                "content": "### Intuition : \\nAs the numbers are in the range `[-50,50]` we can just increase , decrease count as we move ahead the window.\\nand loop through `[-50,50]` and keep on adding int `cnt` if `cnt >= x` that means that particular number is xth smallest.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<vector<int>> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50].push_back(v[end++]);\\n            if(end - start > k) {\\n                mp[v[start] + 50].pop_back();\\n                start++;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i].size();\\n                    if(cnt >= x) {\\n                        val = mp[i][0];\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n#### Optimisation 1 : \\nWe can just count instead of storing .\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<int> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50]++;\\n            end++;\\n            if(end - start > k) {\\n                mp[v[start++] + 50]--;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i];\\n                    if(cnt >= x) {\\n                        val = i - 50;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<vector<int>> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50].push_back(v[end++]);\\n            if(end - start > k) {\\n                mp[v[start] + 50].pop_back();\\n                start++;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i].size();\\n                    if(cnt >= x) {\\n                        val = mp[i][0];\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<int> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50]++;\\n            end++;\\n            if(end - start > k) {\\n                mp[v[start++] + 50]--;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i];\\n                    if(cnt >= x) {\\n                        val = i - 50;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445694,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int a[] = new int[101];\\n        int res[] = new int[n - k + 1];\\n        for (int i=0;i<k;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for (int i=0;i<=n-k;i++)\\n        {\\n            int count=0,val=-1;\\n            for(int j=0;j<=49;j++)\\n            {\\n                if(a[j]>0)\\n                {\\n                    count+=a[j];\\n                    if(count>=x)\\n                    {\\n                        val=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            a[nums[i]+50]--;\\n            if(i<n-k)\\n            {\\n                a[nums[i+k]+50]++;\\n            }\\n            res[i] = val == -1 ? 0 : val-50;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int a[] = new int[101];\\n        int res[] = new int[n - k + 1];\\n        for (int i=0;i<k;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for (int i=0;i<=n-k;i++)\\n        {\\n            int count=0,val=-1;\\n            for(int j=0;j<=49;j++)\\n            {\\n                if(a[j]>0)\\n                {\\n                    count+=a[j];\\n                    if(count>=x)\\n                    {\\n                        val=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            a[nums[i]+50]--;\\n            if(i<n-k)\\n            {\\n                a[nums[i+k]+50]++;\\n            }\\n            res[i] = val == -1 ? 0 : val-50;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445893,
                "title": "sliding-window-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConstraints are low like value of elements of array are between -50 to 50, so we can use map to optimise sliding window here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Push first k element in Map\\n2. Find second smallest element using counting if we find we compare the value with 0 and take minimum of it. (positive element is second smallest take ans[i] as 0).\\n3. push the second smallest element in ans,repeat this process n-k-1 times using sliding window.\\n4. Return the ans\\n\\n# Complexity\\n- Time complexity: O(N*LogN) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     \\n        int n=nums.size();\\n        map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<int> answer;\\n        int cnt=0;\\n        int res=0;\\n        for(auto y:mp)\\n        {\\n          cnt+=y.second;\\n            if(cnt>=x)\\n            {\\n                res=min(res,y.first);\\n                break;\\n            }\\n        }\\n        answer.push_back(res);\\n        for(int i=k;i<n;i++)\\n        {\\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]]==0) mp.erase(nums[i-k]);\\n            mp[nums[i]]++;\\n            int cnt=0;\\n            int res=0;\\n          for(auto y:mp)\\n          {\\n             cnt+=y.second;\\n             if(cnt>=x)\\n             {\\n                res=min(res,y.first);\\n                break;\\n             }\\n       \\n          }\\n         answer.push_back(res);     \\n        }\\n    return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     \\n        int n=nums.size();\\n        map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<int> answer;\\n        int cnt=0;\\n        int res=0;\\n        for(auto y:mp)\\n        {\\n          cnt+=y.second;\\n            if(cnt>=x)\\n            {\\n                res=min(res,y.first);\\n                break;\\n            }\\n        }\\n        answer.push_back(res);\\n        for(int i=k;i<n;i++)\\n        {\\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]]==0) mp.erase(nums[i-k]);\\n            mp[nums[i]]++;\\n            int cnt=0;\\n            int res=0;\\n          for(auto y:mp)\\n          {\\n             cnt+=y.second;\\n             if(cnt>=x)\\n             {\\n                res=min(res,y.first);\\n                break;\\n             }\\n       \\n          }\\n         answer.push_back(res);     \\n        }\\n    return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445704,
                "title": "python-3-sorted-containers",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        win = SortedList()\\n        \\n        for i in range(k):\\n            win.add(nums[i])\\n        \\n        res = []\\n        if win[x - 1] < 0:\\n            res.append(win[x - 1])\\n        else:\\n            res.append(0)\\n        \\n        for i in range(k, len(nums)):\\n            win.add(nums[i])\\n            win.discard(nums[i - k])\\n            \\n            if win[x - 1] < 0:\\n                res.append(win[x - 1])\\n            else:\\n                res.append(0)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        win = SortedList()\\n        \\n        for i in range(k):\\n            win.add(nums[i])\\n        \\n        res = []\\n        if win[x - 1] < 0:\\n            res.append(win[x - 1])\\n        else:\\n            res.append(0)\\n        \\n        for i in range(k, len(nums)):\\n            win.add(nums[i])\\n            win.discard(nums[i - k])\\n            \\n            if win[x - 1] < 0:\\n                res.append(win[x - 1])\\n            else:\\n                res.append(0)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445678,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int func(int x){\\n        int val=0;\\n        for(auto ele:mp){\\n            if(ele.second+val >= x){\\n                if(ele.first > 0)\\n                    return 0;\\n                return ele.first;\\n            }\\n            val += ele.second;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n            if(i>=k)\\n                mp[nums[i-k]]--;\\n            if(i>=k-1)\\n                ans.push_back(func(x));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int func(int x){\\n        int val=0;\\n        for(auto ele:mp){\\n            if(ele.second+val >= x){\\n                if(ele.first > 0)\\n                    return 0;\\n                return ele.first;\\n            }\\n            val += ele.second;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n            if(i>=k)\\n                mp[nums[i-k]]--;\\n            if(i>=k-1)\\n                ans.push_back(func(x));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446469,
                "title": "unordered-map-o-n-50-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(), i = 0;\\n        unordered_map<int, int> m;\\n        vector<int> ans;\\n        \\n        for(int j=0; j<n; j++) {\\n            m[nums[j]]++;\\n            if(j - i + 1 == k) {\\n                int cnt = x;\\n                for(int val=-50; val<=-1; val++) {\\n                    cnt -= m[val];\\n                    if(cnt <= 0) {\\n                        ans.push_back(val);\\n                        break;\\n                    }\\n                }\\n                if(cnt > 0) ans.push_back(0);\\n                m[nums[i++]]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(), i = 0;\\n        unordered_map<int, int> m;\\n        vector<int> ans;\\n        \\n        for(int j=0; j<n; j++) {\\n            m[nums[j]]++;\\n            if(j - i + 1 == k) {\\n                int cnt = x;\\n                for(int val=-50; val<=-1; val++) {\\n                    cnt -= m[val];\\n                    if(cnt <= 0) {\\n                        ans.push_back(val);\\n                        break;\\n                    }\\n                }\\n                if(cnt > 0) ans.push_back(0);\\n                m[nums[i++]]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446816,
                "title": "python-easiest-3-three-approach-hash-map-sortedlist-ds-slinding-windows",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition behind question is very simple sliding window but the extra things is added we have to find the xth smallest number so, we are using either sort again again or some data structure like sorted list to find the xth smallest number.\\nI think in this question only we have deal with optimization.\\nFirst i think in the slinding window we make the k size window and find x the minimum element by sorting again again but it giving TLE \\nafter so many TLE i think of the sortedList data structure.\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNote:SortedList Time Complexity is 0(log(n)) that\\'s why we are using SortedList Data structure \\n**Step1:First we are add element of k-1 range  make window of k-1 range in a sortedList\\nSTEP2: Then we are iterate from iterate from the( k+1,len(nums)) and if len(a)>=x and xth smallest is <0 negative number and add in ans list otherwise we are adding 0\\nSTEP3: Slide the window by adding and the remove first element**\\n![WhatsApp Image 2023-04-23 at 2.24.39 PM.jpeg](https://assets.leetcode.com/users/images/ada39c63-3883-4f25-a877-1a46e2c02c9f_1682240267.7857494.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n(log(n)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**GIVING LEETCODE CONTEST IN MORNING BE LIKE\\uD83D\\uDE05\\uD83D\\uDE05**\\n**US BRO US\\uD83E\\uDD72**\\n![6b6a5f7b23bcfbbea25e680b77369890.jpg](https://assets.leetcode.com/users/images/468495ef-994e-49d1-a69a-e0e12b96137e_1682239704.2012587.jpeg)\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        # Its Time Complexity is 0(log(n)) that\\'s why we are using SortedList Data structure \\n        a=SortedList([])\\n        ans=[]\\n        #STEP1: First we are add element of k-1 range  make window of k-1 range\\n        for ws in range(k):\\n            a.add(nums[ws])\\n        #STEP2: Then we are iterate from iterate from the k+1,len(nums) and if len(a)>=x and xth smallest is <0 \\n        for i in range(k,len(nums)):\\n            if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n            else:\\n                ans.append(0)\\n        #STEP3: Slide the window by adding and the remove first element\\n            a.remove(nums[i-k])\\n            a.add(nums[i])\\n         \\n        # print(ans)\\n    #Remaining last element \\n        if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n        else:\\n            ans.append(0)\\n \\n            # a.remove(nums[i-k])\\n            # a.add(nums[i])\\n        return ans\\n```\\n```python []\\n#TLE GIVING FOR THE 10 TASTE CASES THIS IS BRUTE FORCE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ws=0\\n        we=k-1\\n        l1=[]\\n        for i in range (we,len(nums)):\\n            arr=sorted(nums[ws:i+1])\\n            min1=arr[x-1]\\n            if min1>0:\\n                l1.append(0)\\n            else:\\n                l1.append(arr[x-1])\\n            ws+=1\\n        return l1\\n\\n\\n\\n```\\n```python []\\n#IN python their is no such ordered map so we make ordered hash map but is is also giving TLE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    \\n        dict1={}\\n        c=0\\n        w_start=0\\n        l1=[]\\n        def solve(dict1):\\n            c=0\\n            myKeys = list(dict1.keys())\\n            myKeys.sort()\\n            sorted_dict = {i: dict1[i] for i in myKeys}\\n            for i in sorted_dict  :\\n                c+=dict1[i]\\n                if c>=x:\\n                    return i\\n            return float(\\'inf\\')\\n        for we in range (len(nums)):\\n            if nums[we] not in dict1:\\n                dict1[nums[we]]=1\\n            else:\\n                dict1[nums[we]]+=1\\n            while we-w_start+1>k:\\n                dict1[nums[w_start]]-=1\\n                if dict1[nums[w_start]]==0:\\n                    del dict1[nums[w_start]]\\n                w_start+=1\\n            if we-w_start+1==k:\\n                #search for x smallest\\n                min1=solve(dict1)\\n                if min1>0 or min1==float(\\'inf\\'):\\n                    l1.append(0)\\n                else:\\n                    l1.append(min1)\\n        return l1\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        # Its Time Complexity is 0(log(n)) that\\'s why we are using SortedList Data structure \\n        a=SortedList([])\\n        ans=[]\\n        #STEP1: First we are add element of k-1 range  make window of k-1 range\\n        for ws in range(k):\\n            a.add(nums[ws])\\n        #STEP2: Then we are iterate from iterate from the k+1,len(nums) and if len(a)>=x and xth smallest is <0 \\n        for i in range(k,len(nums)):\\n            if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n            else:\\n                ans.append(0)\\n        #STEP3: Slide the window by adding and the remove first element\\n            a.remove(nums[i-k])\\n            a.add(nums[i])\\n         \\n        # print(ans)\\n    #Remaining last element \\n        if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n        else:\\n            ans.append(0)\\n \\n            # a.remove(nums[i-k])\\n            # a.add(nums[i])\\n        return ans\\n```\n```python []\\n#TLE GIVING FOR THE 10 TASTE CASES THIS IS BRUTE FORCE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ws=0\\n        we=k-1\\n        l1=[]\\n        for i in range (we,len(nums)):\\n            arr=sorted(nums[ws:i+1])\\n            min1=arr[x-1]\\n            if min1>0:\\n                l1.append(0)\\n            else:\\n                l1.append(arr[x-1])\\n            ws+=1\\n        return l1\\n\\n\\n\\n```\n```python []\\n#IN python their is no such ordered map so we make ordered hash map but is is also giving TLE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    \\n        dict1={}\\n        c=0\\n        w_start=0\\n        l1=[]\\n        def solve(dict1):\\n            c=0\\n            myKeys = list(dict1.keys())\\n            myKeys.sort()\\n            sorted_dict = {i: dict1[i] for i in myKeys}\\n            for i in sorted_dict  :\\n                c+=dict1[i]\\n                if c>=x:\\n                    return i\\n            return float(\\'inf\\')\\n        for we in range (len(nums)):\\n            if nums[we] not in dict1:\\n                dict1[nums[we]]=1\\n            else:\\n                dict1[nums[we]]+=1\\n            while we-w_start+1>k:\\n                dict1[nums[w_start]]-=1\\n                if dict1[nums[w_start]]==0:\\n                    del dict1[nums[w_start]]\\n                w_start+=1\\n            if we-w_start+1==k:\\n                #search for x smallest\\n                min1=solve(dict1)\\n                if min1>0 or min1==float(\\'inf\\'):\\n                    l1.append(0)\\n                else:\\n                    l1.append(min1)\\n        return l1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446064,
                "title": "leetcode-the-hard-way-sortedlist",
                "content": "```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        w = SortedList(nums[:k])\\n        res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        for i in range(k, len(nums)) :\\n            w.remove(nums[i - k])\\n            w.add(nums[i])\\n            res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        w = SortedList(nums[:k])\\n        res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        for i in range(k, len(nums)) :\\n            w.remove(nums[i - k])\\n            w.add(nums[i])\\n            res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445758,
                "title": "ez-c-using-sliding-window",
                "content": "**Time Complexity : O(Nlog N)\\nSpace Complexity : O(N)**\\n\\nInitial Thought Process : \\n* I thought of using a multiset to store the \\'k\\' elements and during each iteration add the \\'x\\' th smallest negative number to our answer.\\n* This resulted in TLE since the find opeartion takes O(log N) and erase also took time.\\n* Since multiset uses bidirectional iterator we won\\'t be directly able to access the xth element by doing `ms.begin()+x` . We need to advance the iterator, which is also very time consuming.\\n* So the next approach I thought was the sliding window approach and after a few trial and error I came upwith the solution.\\n\\n```\\nclass Solution {\\npublic:\\n    int find_element(map<int,int>&m,int x){\\n        int c=0;\\n        for(auto i:m){\\n             c+=i.second;//Incrementing counter to point to the corresponding elment in our key-value pair\\n            if(c>=x) //This means that the \\'x\\' element is present so we return it\\n                return i.first;\\n           \\n        }\\n        return INT_MAX; // \\'x\\' the smallest element not in our window\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        map<int,int>m;\\n        int i=0;\\n       vector<int>res;\\n        \\n        for(int j=0;j<nums.size();j++){\\n            \\n            m[nums[j]]++; // Add element to the window\\n            while((j-i+1)>k){           //Invalid Window Size     \\n                m[nums[i]]--;// Removing element from our window\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            \\n            if((j-i+1)==k){//Valid Window\\n                int minX=find_element(m,x);//Searching for the \\'x\\' th smallest negative element in our window\\n                if(minX==INT_MAX||minX>0)\\n                    res.push_back(0);\\n                else\\n                    res.push_back(minX);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_element(map<int,int>&m,int x){\\n        int c=0;\\n        for(auto i:m){\\n             c+=i.second;//Incrementing counter to point to the corresponding elment in our key-value pair\\n            if(c>=x) //This means that the \\'x\\' element is present so we return it\\n                return i.first;\\n           \\n        }\\n        return INT_MAX; // \\'x\\' the smallest element not in our window\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        map<int,int>m;\\n        int i=0;\\n       vector<int>res;\\n        \\n        for(int j=0;j<nums.size();j++){\\n            \\n            m[nums[j]]++; // Add element to the window\\n            while((j-i+1)>k){           //Invalid Window Size     \\n                m[nums[i]]--;// Removing element from our window\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            \\n            if((j-i+1)==k){//Valid Window\\n                int minX=find_element(m,x);//Searching for the \\'x\\' th smallest negative element in our window\\n                if(minX==INT_MAX||minX>0)\\n                    res.push_back(0);\\n                else\\n                    res.push_back(minX);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445737,
                "title": "c-code-using-multi-set-erase-without-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    { \\n        multiset<int> negNums = getInitialSet(nums, k);\\n        vector<int> ans = getBeautyArray(negNums, x);\\n        for (int i = k; i < nums.size(); i++) \\n        {\\n            updateSet(negNums, nums[i - k], nums[i]);\\n            ans.push_back(getBeautyElement(negNums, x));\\n        } \\n        return ans;  \\n    } \\nprivate:\\n    multiset<int> getInitialSet(const vector<int>& nums, int k) \\n    {\\n        multiset<int> negNums; \\n        for (int i = 0; i < k; i++) \\n        { \\n            if (nums[i] < 0) \\n            { \\n                negNums.insert(nums[i]); \\n            } \\n        } \\n        return negNums;\\n    }\\n    \\n    vector<int> getBeautyArray(const multiset<int>& negNums, int x) \\n    {\\n        vector<int> ans; \\n        if (negNums.size() >= x) \\n        { \\n            ans.push_back(*next(negNums.begin(), x - 1)); \\n        } \\n        else \\n        { \\n            ans.push_back(0); \\n        } \\n        return ans;\\n    }\\n    void updateSet(multiset<int>& negNums, int oldNum, int newNum) \\n    {\\n        if (oldNum < 0) \\n        { \\n            negNums.erase(negNums.lower_bound(oldNum)); \\n        } \\n        if (newNum < 0) \\n        { \\n            negNums.insert(newNum); \\n        }\\n    }\\n    int getBeautyElement(const multiset<int>& negNums, int x) \\n    {\\n        if (negNums.size() >= x) \\n        { \\n            return *next(negNums.begin(), x - 1); \\n        } \\n        else \\n        { \\n            return 0; \\n        } \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    { \\n        multiset<int> negNums = getInitialSet(nums, k);\\n        vector<int> ans = getBeautyArray(negNums, x);\\n        for (int i = k; i < nums.size(); i++) \\n        {\\n            updateSet(negNums, nums[i - k], nums[i]);\\n            ans.push_back(getBeautyElement(negNums, x));\\n        } \\n        return ans;  \\n    } \\nprivate:\\n    multiset<int> getInitialSet(const vector<int>& nums, int k) \\n    {\\n        multiset<int> negNums; \\n        for (int i = 0; i < k; i++) \\n        { \\n            if (nums[i] < 0) \\n            { \\n                negNums.insert(nums[i]); \\n            } \\n        } \\n        return negNums;\\n    }\\n    \\n    vector<int> getBeautyArray(const multiset<int>& negNums, int x) \\n    {\\n        vector<int> ans; \\n        if (negNums.size() >= x) \\n        { \\n            ans.push_back(*next(negNums.begin(), x - 1)); \\n        } \\n        else \\n        { \\n            ans.push_back(0); \\n        } \\n        return ans;\\n    }\\n    void updateSet(multiset<int>& negNums, int oldNum, int newNum) \\n    {\\n        if (oldNum < 0) \\n        { \\n            negNums.erase(negNums.lower_bound(oldNum)); \\n        } \\n        if (newNum < 0) \\n        { \\n            negNums.insert(newNum); \\n        }\\n    }\\n    int getBeautyElement(const multiset<int>& negNums, int x) \\n    {\\n        if (negNums.size() >= x) \\n        { \\n            return *next(negNums.begin(), x - 1); \\n        } \\n        else \\n        { \\n            return 0; \\n        } \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446465,
                "title": "c-easiest-solution-using-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0;\\n        int j=0;\\n        int n=nums.size();\\n        vector<int> v(51,0);\\n        vector<int> ans;\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            v[(nums[j]+50)%50]++;\\n            if(j-i+1==k)\\n            {\\n                int p=x;\\n                bool flag=false;\\n                vector<int> v1=v;\\n                for(int i=0;i<=50;i++)\\n                {\\n                    if(v1[i]>0)\\n                    {\\n                        p-=v1[i];\\n                    }\\n                    if(p<=0)\\n                    {\\n                        ans.push_back(i-50);\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                ans.push_back(0);\\n                if(nums[i]<0)\\n                v[(nums[i]+50)%50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0;\\n        int j=0;\\n        int n=nums.size();\\n        vector<int> v(51,0);\\n        vector<int> ans;\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            v[(nums[j]+50)%50]++;\\n            if(j-i+1==k)\\n            {\\n                int p=x;\\n                bool flag=false;\\n                vector<int> v1=v;\\n                for(int i=0;i<=50;i++)\\n                {\\n                    if(v1[i]>0)\\n                    {\\n                        p-=v1[i];\\n                    }\\n                    if(p<=0)\\n                    {\\n                        ans.push_back(i-50);\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                ans.push_back(0);\\n                if(nums[i]<0)\\n                v[(nums[i]+50)%50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445799,
                "title": "c-soutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe function takes an input array of integers, the length of the subarray to be considered, and a count x. It then returns an array of integers that contains the maximum negative integer of the subarrays of length k that contain at least x negative integers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a sliding window approach to go through the input array nums. We maintain a counter for negative integers in negative_count initialized with 50 elements (covering the range from -49 to 0). Whenever we add a new integer to the current window, we increment the counter at the corresponding index if it\\'s negative. Similarly, when we move the window to the right, we decrement the counter at the corresponding index if the element falling out of the window is negative.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(nk), where n is the size of the input array nums, and k is the input parameter representing the size of the subarrays.\\n\\nThe function iterates through the array nums once, and for each element it performs three operations: updating the counter for the current element, removing the counter for the element outside the current subarray, and finding the smallest negative element with frequency >= x.\\n\\nEach of these operations takes O(1) time, except for finding the smallest negative element with frequency >= x, which takes O(50) time (since there are at most 50 distinct negative numbers in the input).\\n\\nSince the function iterates through nums once and performs O(1) operations for each element, the overall time complexity is O(nk).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is O(1) for the input array nums and the input parameters k and x.\\n\\nThe function uses two additional vectors: ans and counter. The size of ans is nums.size() - k + 1, which is O(n) in the worst case. The size of counter is 50, which is a constant. Therefore, the space complexity of the function is O(n) in the worst case.\\n\\nHowever, we can optimize the space complexity by using a sliding window approach to update the counter vector, and computing the result for each subarray as we go along, instead of storing it in the ans vector. This would reduce the space complexity to O(1), since we would only need to store a constant amount of additional variables to compute the result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans(nums.size() - k + 1, 0), counter(50, 0);\\n        for (int i = 0; i < nums.size(); i++) {\\n            // Update counter for current element\\n            if (nums[i] < 0) counter[nums[i] + 50]++;\\n            // Remove counter for the element outside the current subarray\\n            if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n            // Check if current subarray size is greater than k\\n            if (i - k + 1 < 0) continue;\\n            // Find the smallest negative element with frequency >= x\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans(nums.size() - k + 1, 0), counter(50, 0);\\n        for (int i = 0; i < nums.size(); i++) {\\n            // Update counter for current element\\n            if (nums[i] < 0) counter[nums[i] + 50]++;\\n            // Remove counter for the element outside the current subarray\\n            if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n            // Check if current subarray size is greater than k\\n            if (i - k + 1 < 0) continue;\\n            // Find the smallest negative element with frequency >= x\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448390,
                "title": "easy-understable-sliding-window-using-map",
                "content": "# Intuition\\nUSe sliding window and use map to find the Xth smallest negative number.\\n\\n# Approach\\nRun a loop and count the frequency of negative number and check if frequency is equal to the X. If yes then push that element in ans vector and if no then just push 0.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=0;i<k;++i){\\n            mp[nums[i]]++;\\n        } \\n        \\n        vector<int>ans;\\n        int j=0;\\n        for(int i=k;i<=n;++i){\\n            int cnt=0;\\n            for(auto m:mp){\\n                if(m.first<=0){\\n                    if(m.second>0) cnt+=m.second;\\n                    if(cnt>=x){\\n                        ans.push_back(m.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            if(cnt<x) ans.push_back(0);\\n            if(i==n) break;\\n            mp[nums[i]]++;\\n            mp[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=0;i<k;++i){\\n            mp[nums[i]]++;\\n        } \\n        \\n        vector<int>ans;\\n        int j=0;\\n        for(int i=k;i<=n;++i){\\n            int cnt=0;\\n            for(auto m:mp){\\n                if(m.first<=0){\\n                    if(m.second>0) cnt+=m.second;\\n                    if(cnt>=x){\\n                        ans.push_back(m.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            if(cnt<x) ans.push_back(0);\\n            if(i==n) break;\\n            mp[nums[i]]++;\\n            mp[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447155,
                "title": "brute-force-200-717-tc-priority-queue-702-717-tc-passed-optimised-queue-map-c",
                "content": "class Solution {\\npublic:\\n    \\n    //APPROACH 2- PRIORITY QUEUE TLE\\n        int priority(vector<int>&nums,int i,int j,int x){\\n            priority_queue<int> pq;\\n            for(int l=i;l<j;l++){\\n                pq.push(nums[l]);\\n                if(pq.size()>x)pq.pop();\\n            }\\n            return pq.top();\\n        }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        //APPROACH-1 BRUTE FORCE\\n        int n=nums.size();\\n       \\n        int i=0,j=0;\\n        bool ok=false;\\n            priority_queue<int,vector<int>,greater<int>> pq;\\n        vector<int> ans;\\n        if(k==1 && x==1) {\\n            ok=true;\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]<0)ans.push_back(nums[i]);\\n                else ans.push_back(0);\\n            }\\n        }\\n        if(ok==false)\\n        while(j<nums.size()){\\n            pq.push(nums[j]);\\n            if(j-i+1<k)j++;\\n            else if(j-i+1<=k){\\n                int temp=0;\\n                int cnt=0;\\n                bool flag=false;\\n                for(int k=0;k<x;k++){\\n                     if(pq.top()>0){ \\n                            cnt++;\\n                        }\\n                    else break;\\n                }\\n                if(k==cnt){\\n                    temp=0;\\n                    flag=true;\\n                }\\n               if(flag==false) for(int k=0;k<x;k++){\\n                       \\n                        temp=(pq.top());\\n                        //cout<<pq.top()<<\" \";\\n                   if(k==0)pq.pop();\\n                    if(k==x-1) break;\\n                    \\n                }\\n                if(temp>0) temp=0;\\n                //cout<<pq.top()<<\" \";\\n              //  cout<<temp<<\" \";\\n                ans.push_back(temp);\\n               // for(auto it:ans) cout<<it<<\" \";\\n                pq.push(nums[j]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    \\n        //APPROACH 2- PRIORITY QUEUE\\n        int n=nums.size();\\n        int i=0;\\n        vector<int> ans;\\n        int j=k;\\n        while(j-1!=n){\\n            int minElement=priority(nums,i,j,x);\\n            if(minElement>0) ans.push_back(0);\\n            else ans.push_back(minElement);\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n        \\n        //OPTIMISED QUEUE+MAP\\n         int n=nums.size();\\n         map<int,int> mp;\\n        vector<int> ans;\\n        queue<int> q;\\n        for(auto it:nums){\\n            mp[it]++;\\n            q.push(it);\\n        \\n        if(q.size()==k){\\n        int curr=q.front();\\n        q.pop();\\n        int siz=0;\\n        for(auto it:mp){\\n            siz+=it.second;\\n            if(siz>=x){\\n                if(it.first>0) ans.push_back(0);\\n                else ans.push_back(it.first);\\n                break;\\n            }\\n        }\\n            if(mp[curr]>1)mp[curr]--;\\n            else mp.erase(curr);\\n         }\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //APPROACH 2- PRIORITY QUEUE TLE\\n        int priority(vector<int>&nums,int i,int j,int x){\\n            priority_queue<int> pq;\\n            for(int l=i;l<j;l++){\\n                pq.push(nums[l]);\\n                if(pq.size()>x)pq.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3446993,
                "title": "easy-explanation-multiset-pointer-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we require `xth` smallest element, we should use a container which keeps element sorted for quick queries. Also, note that the values may repeat.\\nSo we can use a `multiset`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to always keep the pointer at the `xth` smallest element after insertion/deletion operations.\\n\\n**But exactly how?**\\nOnce, we insert first `k` set of numbers. We can simply move to the `xth` smallest element in the multiset from the begining to initialize our pointer `ptr`. This would take `x - 1` steps. \\nThen for each insertion/deletion we can follow below steps to maintain our pointer at correct position.\\n\\nAssume that we are at `ith` iteration and value at our `ptr` is `ptr_value`.\\n**Insertion**\\nElement to be inserted is `nums[i]`. First insert this element. Then:\\n* If `nums[i] < ptr_value`: \\nThis value is inserted to the left of `ptr` hence the `ptr` is now pointing to `x+1`th smallest element. Therefore, simply shift `ptr` to one place left(`ptr--`).\\n* Otherwise, the `ptr` remains at correct position.\\n\\n**Deletion**\\nElement to be removed is `nums[i - k]`.\\n* If `nums[i - k] <= ptr_value`: \\nThis value was at left of `ptr`. After it gets removed, our `ptr` points to `x-1th` smallest element. Threfore, shift `ptr` to one position right(`ptr++`).\\n* Otherwise, the `ptr` remains at correct position.\\n\\nNow, remove `nums[i - k]`.\\n\\n**Note**\\nIf a new value is to be inserted which is already present in multiset then it gets inserted after all the same value element.\\nAnd, `st.find(e)` finds the first position of `e`. \\nThese properties helped us in considering edge cases in our if conditions of insertion and deletion.\\n\\n# Complexity\\n- Time complexity:$$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> res;\\n        multiset<int> st;\\n\\n        multiset<int>::iterator ptr;\\n        for(int i = 0; i < n; i++)\\n        {\\n            st.insert(nums[i]);\\n\\n            // initialize ptr\\n            if(i == k - 1)\\n                ptr = next(st.begin(), x - 1);\\n\\n            if(i >= k && nums[i] < *ptr)\\n                ptr--;\\n            \\n            if(i >= k)\\n            {\\n                if(nums[i - k] <= *ptr)  \\n                    ptr++;\\n                st.erase(st.find(nums[i - k]));\\n            }\\n\\n            if(i >= k - 1)\\n                res.push_back(min(0, *ptr));\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\nPlease upvote if it helped\\uD83D\\uDE42.",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> res;\\n        multiset<int> st;\\n\\n        multiset<int>::iterator ptr;\\n        for(int i = 0; i < n; i++)\\n        {\\n            st.insert(nums[i]);\\n\\n            // initialize ptr\\n            if(i == k - 1)\\n                ptr = next(st.begin(), x - 1);\\n\\n            if(i >= k && nums[i] < *ptr)\\n                ptr--;\\n            \\n            if(i >= k)\\n            {\\n                if(nums[i - k] <= *ptr)  \\n                    ptr++;\\n                st.erase(st.find(nums[i - k]));\\n            }\\n\\n            if(i >= k - 1)\\n                res.push_back(min(0, *ptr));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446927,
                "title": "pbds-c-helpful-data-structure-commented-code",
                "content": "# Intuition\\nWhen the question mentioned find the xth smallest element from the array I quickly thought of PBDS. It is basically a ordered set but the elements can be inedexed. Read more about it [here](https://codeforces.com/blog/entry/11080).\\n\\nTo handle the case of duplicate elements, I have stored the elements along with a index so that every element in the set is unique.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update>\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &arr, int k, int x)\\n    {\\n        int i = 0, j = 0;\\n        ordered_set st;\\n        int n = arr.size();\\n        vector<int> temp;\\n        int ind = 0;\\n        while (j < n)\\n        {\\n            // Insert the current element into the ordered set along with its index\\n            st.insert({arr[j], ind});\\n\\n            // If the window size is less than k, increment j to expand the window\\n            if (j - i + 1 < k)\\n            {\\n                j++;\\n            }\\n\\n            // If the window size is equal to k\\n            else if (j - i + 1 == k)\\n            {\\n                // Find the x-th smallest element in the window and get its value\\n                int ans = (st.find_by_order(x - 1))->first;\\n                \\n                // If the value is non-negative, push 0 to the result vector\\n                if (ans >= 0)\\n                {\\n                    temp.push_back(0);\\n                }\\n                // Otherwise, push the value to the result vector\\n                else\\n                {\\n                    temp.push_back(ans);\\n                }\\n\\n                //Now to slide the window, Erase the element pointed by i from the window\\n                st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n\\n                // sliding the window\\n                i++;\\n                j++;\\n            }\\n            // Increment ind to keep track of the index of the current element\\n            ind++;\\n        }\\n        // Return the result vector\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update>\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &arr, int k, int x)\\n    {\\n        int i = 0, j = 0;\\n        ordered_set st;\\n        int n = arr.size();\\n        vector<int> temp;\\n        int ind = 0;\\n        while (j < n)\\n        {\\n            // Insert the current element into the ordered set along with its index\\n            st.insert({arr[j], ind});\\n\\n            // If the window size is less than k, increment j to expand the window\\n            if (j - i + 1 < k)\\n            {\\n                j++;\\n            }\\n\\n            // If the window size is equal to k\\n            else if (j - i + 1 == k)\\n            {\\n                // Find the x-th smallest element in the window and get its value\\n                int ans = (st.find_by_order(x - 1))->first;\\n                \\n                // If the value is non-negative, push 0 to the result vector\\n                if (ans >= 0)\\n                {\\n                    temp.push_back(0);\\n                }\\n                // Otherwise, push the value to the result vector\\n                else\\n                {\\n                    temp.push_back(ans);\\n                }\\n\\n                //Now to slide the window, Erase the element pointed by i from the window\\n                st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n\\n                // sliding the window\\n                i++;\\n                j++;\\n            }\\n            // Increment ind to keep track of the index of the current element\\n            ind++;\\n        }\\n        // Return the result vector\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446252,
                "title": "c-easy-to-understand-sliding-window",
                "content": "````\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int n = nums.size(), i, j, y;\\n        vector<int> count(50, 0), ans(n - k + 1, 0);\\n        for (i = 0; i < n; i++)\\n        {\\n            if (nums[i] < 0)\\n                count[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0)\\n                count[nums[i - k] + 50]--;\\n            y = 0;\\n            if (i - k + 1 >= 0)\\n            {\\n                for (j = 0; j < 50; j++)\\n                {\\n                    y += count[j];\\n                    if (y >= x)\\n                    {\\n                        ans[i - k + 1] = j - 50;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "````\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int n = nums.size(), i, j, y;\\n        vector<int> count(50, 0), ans(n - k + 1, 0);\\n        for (i = 0; i < n; i++)\\n        {\\n            if (nums[i] < 0)\\n                count[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0)\\n                count[nums[i - k] + 50]--;\\n            y = 0;\\n            if (i - k + 1 >= 0)\\n            {\\n                for (j = 0; j < 50; j++)\\n                {\\n                    y += count[j];\\n                    if (y >= x)\\n                    {\\n                        ans[i - k + 1] = j - 50;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446139,
                "title": "sliding-window-mapping-ve-integers-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int>m;\\n        \\n        int negcnt=0;          // Keeping Track Of Count Of Negative Numbers\\n        \\n        for(int i=0;i<k;i++)   //mapping first k elements\\n        {\\n            if(nums[i]<0) {\\n                m[nums[i]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        vector<int>res;\\n        int i=0,j=k-1;\\n        while(j<nums.size())     //sliding window\\n        {\\n            if(negcnt>=x)       //if we have sufficient element\\n            {\\n                int pos=x;\\n                for(auto ele:m)  //finding xth element\\n                {\\n                    if(pos-ele.second>0)\\n                    {\\n                        pos=pos-ele.second;\\n                    }\\n                    else\\n                    {\\n                        res.push_back(ele.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            else             //if we do not have suficient elements the push 0\\n            {\\n                res.push_back(0);\\n            }\\n            \\n            if(nums[i]<0)     // removing element at ith position\\n            {\\n                m[nums[i]]--;\\n                negcnt--;\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n            }\\n            \\n            i++;   //incrementing i\\n            if(j+1<nums.size()) j++;  //incrementing j\\n            else break;\\n            \\n            if(nums[j]<0)      //mapping new element in map\\n            {\\n                m[nums[j]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        return res;    //return final result\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int>m;\\n        \\n        int negcnt=0;          // Keeping Track Of Count Of Negative Numbers\\n        \\n        for(int i=0;i<k;i++)   //mapping first k elements\\n        {\\n            if(nums[i]<0) {\\n                m[nums[i]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        vector<int>res;\\n        int i=0,j=k-1;\\n        while(j<nums.size())     //sliding window\\n        {\\n            if(negcnt>=x)       //if we have sufficient element\\n            {\\n                int pos=x;\\n                for(auto ele:m)  //finding xth element\\n                {\\n                    if(pos-ele.second>0)\\n                    {\\n                        pos=pos-ele.second;\\n                    }\\n                    else\\n                    {\\n                        res.push_back(ele.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            else             //if we do not have suficient elements the push 0\\n            {\\n                res.push_back(0);\\n            }\\n            \\n            if(nums[i]<0)     // removing element at ith position\\n            {\\n                m[nums[i]]--;\\n                negcnt--;\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n            }\\n            \\n            i++;   //incrementing i\\n            if(j+1<nums.size()) j++;  //incrementing j\\n            else break;\\n            \\n            if(nums[j]<0)      //mapping new element in map\\n            {\\n                m[nums[j]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        return res;    //return final result\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445867,
                "title": "sliding-window-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs mention in problem statement numbers are with in -50 to 50.\\nWith this we can Maintain a TreeMap with frequency. Once we reached the window size K compute the xth smallest in O(100) in worst case time complexity. This is enough to pass the Time limit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(K log(K)) + O(100 * n)$$ \\n- \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int start = 0;\\n        int n = nums.length;\\n        int [] ans = new int[n - k + 1];\\n        int idx = 0;\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        \\n        for(int end = 0;end < n; end++){\\n            \\n            //System.out.println(\"Size = \" + (end - start + 1) + \" k = \" + k);\\n            if(end - start + 1 <= k){\\n                \\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n\\n            }else{\\n                //System.out.println(\"computing ans \" + getSecondSmall(tmap));\\n                ans[idx++] = Kth_smallest(tmap, x);//secmin;\\n                \\n                int val = nums[start];\\n                int tf = tmap.getOrDefault(nums[start], 0);\\n                if(tf <= 1)tmap.remove(nums[start]);\\n                else{\\n                    tmap.put(nums[start], tf-1);\\n                }\\n                start++;\\n\\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n            }\\n        }\\n        \\n        ans[idx++] = Kth_smallest(tmap, x);\\n        return ans;\\n    }\\n    \\n    int Kth_smallest(TreeMap<Integer, Integer> mp,int K){\\n        int freq = 0;\\n        for (Map.Entry it : mp.entrySet()) {\\n\\n            freq += (int)it.getValue();\\n\\n            if (freq >= K) {\\n                return Math.min((int)it.getKey(), 0);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int start = 0;\\n        int n = nums.length;\\n        int [] ans = new int[n - k + 1];\\n        int idx = 0;\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        \\n        for(int end = 0;end < n; end++){\\n            \\n            //System.out.println(\"Size = \" + (end - start + 1) + \" k = \" + k);\\n            if(end - start + 1 <= k){\\n                \\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n\\n            }else{\\n                //System.out.println(\"computing ans \" + getSecondSmall(tmap));\\n                ans[idx++] = Kth_smallest(tmap, x);//secmin;\\n                \\n                int val = nums[start];\\n                int tf = tmap.getOrDefault(nums[start], 0);\\n                if(tf <= 1)tmap.remove(nums[start]);\\n                else{\\n                    tmap.put(nums[start], tf-1);\\n                }\\n                start++;\\n\\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n            }\\n        }\\n        \\n        ans[idx++] = Kth_smallest(tmap, x);\\n        return ans;\\n    }\\n    \\n    int Kth_smallest(TreeMap<Integer, Integer> mp,int K){\\n        int freq = 0;\\n        for (Map.Entry it : mp.entrySet()) {\\n\\n            freq += (int)it.getValue();\\n\\n            if (freq >= K) {\\n                return Math.min((int)it.getKey(), 0);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445738,
                "title": "min-heap-java",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\xA0\\xA0\\xA0 public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = nums.length;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int[] result = new int[n - k + 1];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> maxHeap = new TreeMap<>(Collections.reverseOrder());\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int i = 0; i < n; i++) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int num = nums[i];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Add the new element to the minHeap\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Remove the element that is out of the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int outOfWindow = nums[i - k];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(outOfWindow, minHeap.get(outOfWindow) - 1);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (minHeap.get(outOfWindow) == 0) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.remove(outOfWindow);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Get the xth smallest element in the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k - 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int count = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int beautifulValue = 0;\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 count += entry.getValue();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (count >= x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 beautifulValue = entry.getKey();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 break;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 result[i - k + 1] = beautifulValue < 0 ? beautifulValue : 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return result;\\n\\xA0\\xA0\\xA0 }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\xA0\\xA0\\xA0 public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = nums.length;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int[] result = new int[n - k + 1];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> maxHeap = new TreeMap<>(Collections.reverseOrder());\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int i = 0; i < n; i++) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int num = nums[i];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Add the new element to the minHeap\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Remove the element that is out of the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int outOfWindow = nums[i - k];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(outOfWindow, minHeap.get(outOfWindow) - 1);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (minHeap.get(outOfWindow) == 0) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.remove(outOfWindow);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Get the xth smallest element in the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k - 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int count = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int beautifulValue = 0;\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 count += entry.getValue();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (count >= x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 beautifulValue = entry.getKey();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 break;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 result[i - k + 1] = beautifulValue < 0 ? beautifulValue : 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return result;\\n\\xA0\\xA0\\xA0 }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445727,
                "title": "simple-solution-with-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an integer array nums containing n integers, find the beauty of each subarray of size k.\\n\\nThe beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers.\\n\\nReturn an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array.\\n\\nA subarray is a contiguous non-empty sequence of elements within an array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe problem requires finding the \"beauty\" of all possible subarrays of a given length k in an array nums. The beauty of a subarray is defined as the smallest number that appears at least x times in the subarray. If no number appears at least x times, then the beauty is 0.\\n\\nTo solve this problem, we can use a sliding window approach, where we slide a window of length k over the array nums and calculate the beauty of each subarray. We can keep track of the counts of each number in the current window using a hash map. Then, for each subarray of length k, we can iterate through the hash map to find the smallest number that appears at least x times, and set the beauty of the subarray to that number. If no number appears at least x times, we set the beauty to 0.\\n\\nWe repeat this process for all possible subarrays of length k in the array nums and store the beauties in an output array of length n - k + 1, where n is the length of nums. Finally, we return the output array.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the getSubarrayBeauty method is O(nklogk), where n is the length of the input array nums and k is the length of the subarrays.\\n\\nThe method uses a sliding window approach to iterate through the input array nums, which takes O(n) time. Within each window of size k, the method performs the following operations:\\n\\nAdding an element to the minHeap takes O(logk) time.\\nRemoving an element from the minHeap takes O(logk) time.\\nIterating through the elements of the minHeap takes O(k) time in the worst case, since there can be up to k elements in the minHeap.\\nSince we perform these operations for each window of size k, the overall time complexity is O(nklogk).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity of the getSubarrayBeauty method is O(k), which is the space used by the minHeap and maxHeap data structures. This is because the method only needs to keep track of the counts of the numbers within the current window of size k, which is at most k distinct numbers. The output array of length n - k + 1 also takes O(n - k + 1) = O(n) space, but this is not considered as extra space used by the method.\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] result = new int[n - k + 1];\\n\\n  \\n        TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n        \\n\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n\\n            \\n            minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n            \\n            if (i >= k) {\\n                int out = nums[i - k];\\n                minHeap.put(out, minHeap.get(out) - 1);\\n                if (minHeap.get(out) == 0) {\\n                    minHeap.remove(out);\\n                }\\n            }\\n\\n            if (i >= k - 1) {\\n                int cnt = 0;\\n                int beauty = 0;\\n                Iterator<Map.Entry<Integer, Integer>> it = minHeap.entrySet().iterator();\\n                while (it.hasNext() && cnt < x) {\\n                    Map.Entry<Integer, Integer> entry = it.next();\\n                    cnt += entry.getValue();\\n                    if (cnt >= x) {\\n                        beauty = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                result[i - k + 1] = beauty < 0 ? beauty : 0;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] result = new int[n - k + 1];\\n\\n  \\n        TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n        \\n\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n\\n            \\n            minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n            \\n            if (i >= k) {\\n                int out = nums[i - k];\\n                minHeap.put(out, minHeap.get(out) - 1);\\n                if (minHeap.get(out) == 0) {\\n                    minHeap.remove(out);\\n                }\\n            }\\n\\n            if (i >= k - 1) {\\n                int cnt = 0;\\n                int beauty = 0;\\n                Iterator<Map.Entry<Integer, Integer>> it = minHeap.entrySet().iterator();\\n                while (it.hasNext() && cnt < x) {\\n                    Map.Entry<Integer, Integer> entry = it.next();\\n                    cnt += entry.getValue();\\n                    if (cnt >= x) {\\n                        beauty = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                result[i - k + 1] = beauty < 0 ? beauty : 0;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446913,
                "title": "map-and-sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int checker(int x){\\n        for(auto k : mp){\\n            x -= k.second;\\n            if(x <= 0 && k.first < 0){\\n                return k.first;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++){\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(checker(x));\\n        int ptr = 0;\\n        for(int i = k; i < nums.size(); i++){\\n            mp[nums[ptr]]--;\\n            mp[nums[i]]++;\\n            if(mp[nums[ptr]] == 0) mp.erase(nums[ptr]);\\n            ans.push_back(checker(x));\\n            ptr++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int checker(int x){\\n        for(auto k : mp){\\n            x -= k.second;\\n            if(x <= 0 && k.first < 0){\\n                return k.first;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++){\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(checker(x));\\n        int ptr = 0;\\n        for(int i = k; i < nums.size(); i++){\\n            mp[nums[ptr]]--;\\n            mp[nums[i]]++;\\n            if(mp[nums[ptr]] == 0) mp.erase(nums[ptr]);\\n            ans.push_back(checker(x));\\n            ptr++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446809,
                "title": "python-easy-to-read-solution-hashmap-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question most important hint to get solution is constraints. n <= 10^5 so you should look to solve this with  Time Complexity of O(N).\\n\\nNow how to get count of negative numbers in O(1) time. because if you do any other way you cant solve this problem in O(N). Again if you look at the constraint , -50 <= nums[i] <=50. Can we maintain hashmap of negative numbers ? to get x smallest negative numbers we can simply traverse from -50 to -1 and count frequency of negative numbers. The moment this frequency is more than or equal  to x, we can return negative number for which this is achieved while traversing from -50 to -1. I said \\'more than equal\\'  because same number can occur multiple times . egde case: [-46, -46 , -30]\\n\\n\\nIf this was helpful. Feel free to follow me on \\nhttps://www.youtube.com/@punitvara1924\\nhttps://medium.com/@punitvara\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445948,
                "title": "c-counting-sliding-window-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans, mp(101, 0);\\n        int s=0, e=0;\\n        while(e < nums.size())  {\\n            mp[nums[e] + 50]++;\\n            if(e-s+1 == k)    {\\n                int cnt = 0;\\n                for(int i=0; i<101; i++)    {\\n                    cnt += mp[i];\\n                    if(cnt >= x)    {\\n                        if(i > 50) ans.push_back(0);\\n                        else ans.push_back(i - 50);\\n                        break;\\n                    }\\n                }\\n                mp[nums[s] + 50]--;\\n                s++;\\n            }\\n            e++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans, mp(101, 0);\\n        int s=0, e=0;\\n        while(e < nums.size())  {\\n            mp[nums[e] + 50]++;\\n            if(e-s+1 == k)    {\\n                int cnt = 0;\\n                for(int i=0; i<101; i++)    {\\n                    cnt += mp[i];\\n                    if(cnt >= x)    {\\n                        if(i > 50) ans.push_back(0);\\n                        else ans.push_back(i - 50);\\n                        break;\\n                    }\\n                }\\n                mp[nums[s] + 50]--;\\n                s++;\\n            }\\n            e++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445865,
                "title": "c-brute-force-optimized-simplest-solution-faster-than-95",
                "content": "# Code\\n##### Method 1\\nBrute Force ~ TLE - 703/717 \\nTime Complexity: $$O(nklok)$$\\n```\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = nums.size();\\n        vector<int> sub(k),alt(k);\\n        int j = 0;\\n        vector<int> beauty(n - k + 1);\\n\\n        for (int i = 0; i < k; i++) {\\n            alt[i] = nums[i];\\n        }\\n        for (int i = k; i <= n; i++) {\\n            sub=alt;\\n            sort(sub.begin(), sub.end());    \\n            beauty[j++] = (sub[x - 1] < 0) ? sub[x - 1] : 0;\\n\\n            if (i == n) {\\n                break;\\n            }\\n\\n            alt.erase(alt.begin());\\n            alt.push_back(nums[i]);\\n        }\\n\\n        return beauty;\\n    }\\n```\\n\\n##### Method 2\\nFrequency Array \\nTime Complexity: $$O(50n)$$\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans(n - k + 1, 0), freq(50, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0) freq[nums[i - k] + 50]--;\\n            if (i - k + 1 < 0) continue;\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += freq[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = nums.size();\\n        vector<int> sub(k),alt(k);\\n        int j = 0;\\n        vector<int> beauty(n - k + 1);\\n\\n        for (int i = 0; i < k; i++) {\\n            alt[i] = nums[i];\\n        }\\n        for (int i = k; i <= n; i++) {\\n            sub=alt;\\n            sort(sub.begin(), sub.end());    \\n            beauty[j++] = (sub[x - 1] < 0) ? sub[x - 1] : 0;\\n\\n            if (i == n) {\\n                break;\\n            }\\n\\n            alt.erase(alt.begin());\\n            alt.push_back(nums[i]);\\n        }\\n\\n        return beauty;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans(n - k + 1, 0), freq(50, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0) freq[nums[i - k] + 50]--;\\n            if (i - k + 1 < 0) continue;\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += freq[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445830,
                "title": "sliding-window-with-ve-freq-counting-easy-explanation-o-n",
                "content": "# Intuition\\nThe code uses a sliding window technique to create subarrays of length `k`, and then counts the frequency of negative numbers in each subarray. It then finds the `xth` smallest element in the subarray by counting the frequencies of numbers from `50` down to `1` until it reaches the `xth` smallest element. If no `xth` smallest element is present, `0` is added to the answer list.\\n\\n# Complexity\\n- Time complexity:\\n`O(n*50)` = `O(n)`\\n\\n- Space complexity:\\n`O(50)` = `O(1)`\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        int[] res = new int[nums.length - k + 1];\\n        \\n        for(int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if(nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { res[idx++] = -L; break;}\\n                }\\n                if(cnt < x) res[idx++] = 0;\\n                if(nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    std::vector<int> getSubarrayBeauty(std::vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        std::vector<int> freq(51);\\n        std::vector<int> res(n - k + 1);\\n\\n        for (int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) {\\n                        res[idx++] = -L;\\n                        break;\\n                    }\\n                }\\n                if (cnt < x) res[idx++] = 0;\\n                if (nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n``` python []\\nfrom typing import List\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        freq = [0] * 51\\n        res = [0] * (n - k + 1)\\n\\n        j = 0\\n        idx = 0\\n        for i in range(n):\\n            if nums[i] < 0:\\n                freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k:\\n                cnt = 0\\n                for L in range(50, 0, -1):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        res[idx] = -L\\n                        idx += 1\\n                        break\\n                if cnt < x:\\n                    res[idx] = 0\\n                    idx += 1\\n                if nums[j] < 0:\\n                    freq[abs(nums[j])] -= 1\\n                j += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        int[] res = new int[nums.length - k + 1];\\n        \\n        for(int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if(nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { res[idx++] = -L; break;}\\n                }\\n                if(cnt < x) res[idx++] = 0;\\n                if(nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    std::vector<int> getSubarrayBeauty(std::vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        std::vector<int> freq(51);\\n        std::vector<int> res(n - k + 1);\\n\\n        for (int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) {\\n                        res[idx++] = -L;\\n                        break;\\n                    }\\n                }\\n                if (cnt < x) res[idx++] = 0;\\n                if (nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n``` python []\\nfrom typing import List\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        freq = [0] * 51\\n        res = [0] * (n - k + 1)\\n\\n        j = 0\\n        idx = 0\\n        for i in range(n):\\n            if nums[i] < 0:\\n                freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k:\\n                cnt = 0\\n                for L in range(50, 0, -1):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        res[idx] = -L\\n                        idx += 1\\n                        break\\n                if cnt < x:\\n                    res[idx] = 0\\n                    idx += 1\\n                if nums[j] < 0:\\n                    freq[abs(nums[j])] -= 1\\n                j += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445749,
                "title": "java-use-bucket-sort-with-sliding-window-given-the-constraints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought is to observe the constraints since sorting for each subarray would not scale.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce I noticed the -50 < elem < 50 , try to either a map or array.\\nMap - would not keep things sorted. Has to be array, but\\narray cannot handle negative numbers. So, have to shift the \\nelements by 50 and get an index for each element - back and forth.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] rslt = new int[n-k+1];\\n        \\n        int[] bucket = new int[101];\\n        \\n        for(int i = 0; i < k; i++){\\n            int elem = nums[i];\\n            int bktidx = elem + 50;\\n            bucket[bktidx]++;\\n        }\\n        \\n        rslt[0] = getBucket(bucket, x);\\n        for(int i = k; i < n; i++){\\n            int outgoing = nums[i-k];\\n            int outbktidx = outgoing + 50;\\n            bucket[outbktidx]--;\\n            \\n            int incoming = nums[i];\\n            int inxbktidx = incoming + 50;\\n            bucket[inxbktidx]++;\\n            \\n            rslt[i-k+1] = getBucket(bucket, x);\\n        }\\n        return rslt;\\n    }\\n    private int getBucket(int[] bucket, int x){\\n        int cnt = 0;\\n        for(int i = 0; i < bucket.length; i++){\\n            int frqi = bucket[i];\\n            if (cnt + frqi >= x){\\n                return Math.min(0, i-50);\\n            } \\n            cnt += frqi;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] rslt = new int[n-k+1];\\n        \\n        int[] bucket = new int[101];\\n        \\n        for(int i = 0; i < k; i++){\\n            int elem = nums[i];\\n            int bktidx = elem + 50;\\n            bucket[bktidx]++;\\n        }\\n        \\n        rslt[0] = getBucket(bucket, x);\\n        for(int i = k; i < n; i++){\\n            int outgoing = nums[i-k];\\n            int outbktidx = outgoing + 50;\\n            bucket[outbktidx]--;\\n            \\n            int incoming = nums[i];\\n            int inxbktidx = incoming + 50;\\n            bucket[inxbktidx]++;\\n            \\n            rslt[i-k+1] = getBucket(bucket, x);\\n        }\\n        return rslt;\\n    }\\n    private int getBucket(int[] bucket, int x){\\n        int cnt = 0;\\n        for(int i = 0; i < bucket.length; i++){\\n            int frqi = bucket[i];\\n            if (cnt + frqi >= x){\\n                return Math.min(0, i-50);\\n            } \\n            cnt += frqi;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671158,
                "title": "c-easiest-sliding-window-using-array-of-size-50",
                "content": "# Intuition\\nIntuition is to use an array of size 50 to keep track of 2nd -ve smallest element.\\n\\nif ```nums[i]<0``` then we will make ```mp[nums[i] + 50]+=1```, here 0th index is -50 and so on.\\n\\n# Approach\\n\\nif ```nums[i]<0``` we are incresing the count of that element in mp by help of ```mp[nums[i] + 50]+=1```.\\n\\nWhen our window will hit size k. then we will run a loop till 50 and find 2nd smallest number inside array. To find this we will have a temp varibale when it is ```temp>=x``` we will push that element in answer and break. And if ``` temp<x ``` then we will add mp[k1] in temp. Here mp[k1] is total number of negative element having value k1-50.\\n\\nAs we have hitted then window size we need to remove ith element. So if nums[i] < 0 then make mp[nums[i] - 50]--.\\n\\n\\n``` \\nHappy coding and do upvote if it helped :)\\n```\\n# Complexity\\n- Time complexity:\\n$$O(N*50)$$\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        \\n        vector<int> mp(51);\\n\\n        int i=0,j=0;\\n        while(j<n){\\n            if(nums[j]<0){\\n                int ele = nums[j]+50;\\n                mp[ele]+=1;\\n            }\\n\\n            if(j-i+1>=k){\\n                int temp=0;\\n                bool ok=false;\\n                for(int k1=0;k1<50;++k1){\\n                    if(mp[k1]>0){\\n                        if(temp+mp[k1] >= x){\\n                            ans.push_back(k1-50);\\n                            ok= true;\\n                            break;\\n                        }else{\\n                            temp += mp[k1];\\n                        }\\n                    }\\n                }\\n                if(!ok){\\n                    ans.push_back(0);\\n                }\\n\\n                if(nums[i] < 0){\\n                    mp[nums[i]+50] -=1;\\n                }\\n                i+=1;\\n            }\\n            j+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```nums[i]<0```\n```mp[nums[i] + 50]+=1```\n```nums[i]<0```\n```mp[nums[i] + 50]+=1```\n```temp>=x```\n``` temp<x ```\n``` \\nHappy coding and do upvote if it helped :)\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        \\n        vector<int> mp(51);\\n\\n        int i=0,j=0;\\n        while(j<n){\\n            if(nums[j]<0){\\n                int ele = nums[j]+50;\\n                mp[ele]+=1;\\n            }\\n\\n            if(j-i+1>=k){\\n                int temp=0;\\n                bool ok=false;\\n                for(int k1=0;k1<50;++k1){\\n                    if(mp[k1]>0){\\n                        if(temp+mp[k1] >= x){\\n                            ans.push_back(k1-50);\\n                            ok= true;\\n                            break;\\n                        }else{\\n                            temp += mp[k1];\\n                        }\\n                    }\\n                }\\n                if(!ok){\\n                    ans.push_back(0);\\n                }\\n\\n                if(nums[i] < 0){\\n                    mp[nums[i]+50] -=1;\\n                }\\n                i+=1;\\n            }\\n            j+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501383,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int res[]=new int[n-k+1];\\n        int neg[]=new int[51];\\n        int index=0;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)neg[-nums[i]]++;\\n            if(i+1>=k){\\n                int c=0;\\n                int j=0;\\n                for(j=50;j>0;j--)\\n                {\\n                    c+=neg[j];\\n                    if(x<=c){res[index]=-j;break;}\\n                }\\n                if(j==0)res[index]=0;\\n                if(nums[a]<0)neg[-nums[a]]--;\\n                index++;\\n                a++;\\n            }\\n        }\\n       return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int res[]=new int[n-k+1];\\n        int neg[]=new int[51];\\n        int index=0;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)neg[-nums[i]]++;\\n            if(i+1>=k){\\n                int c=0;\\n                int j=0;\\n                for(j=50;j>0;j--)\\n                {\\n                    c+=neg[j];\\n                    if(x<=c){res[index]=-j;break;}\\n                }\\n                if(j==0)res[index]=0;\\n                if(nums[a]<0)neg[-nums[a]]--;\\n                index++;\\n                a++;\\n            }\\n        }\\n       return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476254,
                "title": "python3-code",
                "content": "# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        beauts = []\\n        i = 0\\n        j = k\\n        LEN = len(nums)\\n        sortedL = SortedList(nums[i:j])\\n        while j - 1 < LEN:\\n            if x <= j and sortedL[x - 1] < 0:\\n                beauts.append(sortedL[x-1])\\n            else:\\n                beauts.append(0)\\n            if j < LEN:\\n                sortedL.add(nums[j])\\n            sortedL.discard(nums[i])\\n            i += 1\\n            j += 1\\n        return beauts\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        beauts = []\\n        i = 0\\n        j = k\\n        LEN = len(nums)\\n        sortedL = SortedList(nums[i:j])\\n        while j - 1 < LEN:\\n            if x <= j and sortedL[x - 1] < 0:\\n                beauts.append(sortedL[x-1])\\n            else:\\n                beauts.append(0)\\n            if j < LEN:\\n                sortedL.add(nums[j])\\n            sortedL.discard(nums[i])\\n            i += 1\\n            j += 1\\n        return beauts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460286,
                "title": "super-easy-and-intuitive-problem-sliding-window-c",
                "content": "The problem that you will face will be to get the xth minimum element in less time .\\nJust see the constraints and you will notice that negative elements are just -50 to -1 that is only 50 elements.\\nso store it in array based on index and it will ofcourse be sorted.\\n**Note** store negative element on index along with its count.\\nGetting index using arr[50 + nums[i]] and getting the element from index back by i - 50.\\nExample: for -3 we get 50-3=47 as its index and from index 47 we can get 47-50=-3 the orginal elemnt back.\\n```\\nclass Solution\\n{\\n    public:\\n        int gen(int x, int *arr)//getting xth smallest element.\\n        {\\n            int i = 0;\\n            while (i < 50)\\n            {\\n                if (arr[i] < x)\\n                    x -= arr[i];\\n                else\\n                    x = 0;\\n                if (x == 0)\\n                    return i - 50;\\n\\n                i++;\\n            }\\n            return 0;\\n        }\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int arr[50] = { 0 };\\n        int start = 0;\\n        vector<int> ans;\\n        for (int end = k - 1; end < nums.size(); end++)\\n        {\\n            if (end == k - 1)//making window\\n            {\\n                for (int j = 0; j < k; j++)\\n                {\\n                    if (nums[j] < 0)\\n                        arr[50 + nums[j]] += 1;\\n                }\\n            }\\n            else\\n            {\\n                if (nums[start] < 0)//sliding the window\\n                    arr[50 + nums[start]] -= 1;\\n                start++;\\n                if (nums[end] < 0)\\n                    arr[50 + nums[end]] += 1;\\n            }\\n            ans.push_back(gen(x, arr));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int gen(int x, int *arr)//getting xth smallest element.\\n        {\\n            int i = 0;\\n            while (i < 50)\\n            {\\n                if (arr[i] < x)\\n                    x -= arr[i];\\n                else\\n                    x = 0;\\n                if (x == 0)\\n                    return i - 50;\\n\\n                i++;\\n            }\\n            return 0;\\n        }\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int arr[50] = { 0 };\\n        int start = 0;\\n        vector<int> ans;\\n        for (int end = k - 1; end < nums.size(); end++)\\n        {\\n            if (end == k - 1)//making window\\n            {\\n                for (int j = 0; j < k; j++)\\n                {\\n                    if (nums[j] < 0)\\n                        arr[50 + nums[j]] += 1;\\n                }\\n            }\\n            else\\n            {\\n                if (nums[start] < 0)//sliding the window\\n                    arr[50 + nums[start]] -= 1;\\n                start++;\\n                if (nums[end] < 0)\\n                    arr[50 + nums[end]] += 1;\\n            }\\n            ans.push_back(gen(x, arr));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454006,
                "title": "c-ordered-set-systematic-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\n  \\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set s;\\n        vector<int>ans;\\n        int i=0, j=0;\\n        while(j<nums.size()){\\n            if(nums[j]<0){\\n                s.insert(nums[j]);\\n            }\\n            if(j-i+1==k){\\n                if(s.size()<x){\\n                    ans.push_back(0);\\n                }\\n                else{\\n                    auto it=s.find_by_order(x-1);\\n                    ans.push_back(*it);\\n                }\\n                if(nums[i]<0){\\n                    s.erase(s.find_by_order(s.order_of_key(nums[i])));\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\n  \\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set s;\\n        vector<int>ans;\\n        int i=0, j=0;\\n        while(j<nums.size()){\\n            if(nums[j]<0){\\n                s.insert(nums[j]);\\n            }\\n            if(j-i+1==k){\\n                if(s.size()<x){\\n                    ans.push_back(0);\\n                }\\n                else{\\n                    auto it=s.find_by_order(x-1);\\n                    ans.push_back(*it);\\n                }\\n                if(nums[i]<0){\\n                    s.erase(s.find_by_order(s.order_of_key(nums[i])));\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3454001,
                "title": "without-using-stl-c",
                "content": "# ***Complexity-***\\n- **Time complexity:** *O(n * 101)* \\n\\n- **Space complexity:** *O(101)*\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> arr1(101, 0);\\n        vector<int> arr2(nums.size()-k+1);\\n        int index = 0, count = 0, temp = 0;\\n        for(int i = 0; i < k-1; i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n        }\\n        for(int i = k-1; i < nums.size(); i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n            for(int j = 0; j < 101; j++)\\n            {\\n                count += arr1[j];\\n                if(x <= count)\\n                {\\n                    temp = j - 50;\\n                    if(temp > 0)\\n                    {\\n                        arr2[index++] = 0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        arr2[index++] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            count = 0;\\n            arr1[nums[i-k+1] + 50]--;\\n        }\\n        return arr2;\\n    }\\n};\\n```\\n\\n*Do Upvote!* \\uD83D\\uDE03\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> arr1(101, 0);\\n        vector<int> arr2(nums.size()-k+1);\\n        int index = 0, count = 0, temp = 0;\\n        for(int i = 0; i < k-1; i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n        }\\n        for(int i = k-1; i < nums.size(); i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n            for(int j = 0; j < 101; j++)\\n            {\\n                count += arr1[j];\\n                if(x <= count)\\n                {\\n                    temp = j - 50;\\n                    if(temp > 0)\\n                    {\\n                        arr2[index++] = 0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        arr2[index++] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            count = 0;\\n            arr1[nums[i-k+1] + 50]--;\\n        }\\n        return arr2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452363,
                "title": "sliding-subarray-beauty-90-76-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size();\\n        vector<int> a(n-k+1);\\n        vector<int>b(50);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            b[nums[i]+50]++;\\n            if(i-k>=0 && nums[i-k]<0)\\n            b[nums[i-k]+50]--;\\n            if(i-k+1<0)\\n            continue;\\n        \\n            int c=0;\\n            for(int j=0;j<50;j++)\\n            {\\n                c+=b[j];\\n                if(c>=x)\\n                {\\n                    a[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size();\\n        vector<int> a(n-k+1);\\n        vector<int>b(50);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            b[nums[i]+50]++;\\n            if(i-k>=0 && nums[i-k]<0)\\n            b[nums[i-k]+50]--;\\n            if(i-k+1<0)\\n            continue;\\n        \\n            int c=0;\\n            for(int j=0;j<50;j++)\\n            {\\n                c+=b[j];\\n                if(c>=x)\\n                {\\n                    a[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447388,
                "title": "java-solution-most-noob-solution",
                "content": "```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[52];// as all elements lie in between -50 to +50 {i have taken 2 extra elements}\\n        for (int i = 0; i < k; i++) { // for the 1st window of size k\\n            if (nums[i] < 0) {  // i will be only inserting the -ve elements but i will treat them positive \\n\\t\\t\\t// in order  to do that i will add 50 to them \\n                int val = nums[i] + 50; \\n                map[val]++; // increase the number\\'s frequency by 1 \\n            }\\n        }\\n        int cnt = 0;\\n        boolean flag = true;\\n        for (int a = 0; a < 52; a++) { // i will iterate over map    \\n            if (map[a] != 0) {\\n                if (map[a] + cnt >= x) { \\n                    ans[idx++] = a - 50;\\n                    flag = false;\\n                    cnt = 0;\\n                    break;\\n                } else {\\n                    cnt += map[a]; \\n                }\\n            }\\n        }\\n        if (flag) {// there doesn\\'t exist a xth smallest -ve number so i will put zero\\n            ans[idx++] = 0;\\n            cnt = 0;\\n        }\\n        int j = 0;\\n        for (int i = k; i < n; i++) {\\n\\t\\t// release the element outside the window\\n            if (nums[j] < 0) {\\n                int val = nums[j] + 50;\\n                map[val]--;\\n            }\\n            j++;\\n\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n\\n            flag = true;\\n            for (int a = 0; a < 52; a++) {\\n                if (map[a] != 0) {\\n                    if (map[a] + cnt >= x) {\\n                        ans[idx++] = a - 50;\\n                        flag = false;\\n                        cnt = 0;\\n                        break;\\n                    } else {\\n                        cnt += map[a];\\n                    }\\n                }\\n            }\\n            if (flag) {\\n                ans[idx++] = 0;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n# A Bit Optimized Solution\\n```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[50];\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n            if (i - j + 1 == k) {\\n                int cnt = 0;\\n                boolean flag = true;\\n                for (int a = 0; a < 50; a++) {\\n                    if (map[a] != 0) {\\n                        if (map[a] + cnt >= x) {\\n                            ans[idx++] = a - 50;\\n                            flag = false;\\n                            cnt = 0;\\n                            break;\\n                        } else {\\n                            cnt += map[a];\\n                        }\\n                    }\\n                }\\n                if (flag) {\\n                    ans[idx++] = 0;\\n                    cnt = 0;\\n                }\\n                if (nums[j] < 0) {\\n                    int val = nums[j] + 50;\\n                    map[val]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[52];// as all elements lie in between -50 to +50 {i have taken 2 extra elements}\\n        for (int i = 0; i < k; i++) { // for the 1st window of size k\\n            if (nums[i] < 0) {  // i will be only inserting the -ve elements but i will treat them positive \\n\\t\\t\\t// in order  to do that i will add 50 to them \\n                int val = nums[i] + 50; \\n                map[val]++; // increase the number\\'s frequency by 1 \\n            }\\n        }\\n        int cnt = 0;\\n        boolean flag = true;\\n        for (int a = 0; a < 52; a++) { // i will iterate over map    \\n            if (map[a] != 0) {\\n                if (map[a] + cnt >= x) { \\n                    ans[idx++] = a - 50;\\n                    flag = false;\\n                    cnt = 0;\\n                    break;\\n                } else {\\n                    cnt += map[a]; \\n                }\\n            }\\n        }\\n        if (flag) {// there doesn\\'t exist a xth smallest -ve number so i will put zero\\n            ans[idx++] = 0;\\n            cnt = 0;\\n        }\\n        int j = 0;\\n        for (int i = k; i < n; i++) {\\n\\t\\t// release the element outside the window\\n            if (nums[j] < 0) {\\n                int val = nums[j] + 50;\\n                map[val]--;\\n            }\\n            j++;\\n\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n\\n            flag = true;\\n            for (int a = 0; a < 52; a++) {\\n                if (map[a] != 0) {\\n                    if (map[a] + cnt >= x) {\\n                        ans[idx++] = a - 50;\\n                        flag = false;\\n                        cnt = 0;\\n                        break;\\n                    } else {\\n                        cnt += map[a];\\n                    }\\n                }\\n            }\\n            if (flag) {\\n                ans[idx++] = 0;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[50];\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n            if (i - j + 1 == k) {\\n                int cnt = 0;\\n                boolean flag = true;\\n                for (int a = 0; a < 50; a++) {\\n                    if (map[a] != 0) {\\n                        if (map[a] + cnt >= x) {\\n                            ans[idx++] = a - 50;\\n                            flag = false;\\n                            cnt = 0;\\n                            break;\\n                        } else {\\n                            cnt += map[a];\\n                        }\\n                    }\\n                }\\n                if (flag) {\\n                    ans[idx++] = 0;\\n                    cnt = 0;\\n                }\\n                if (nums[j] < 0) {\\n                    int val = nums[j] + 50;\\n                    map[val]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446917,
                "title": "video-explanation-includes-harder-follow-ups",
                "content": "# Explanation\\n\\nhttps://youtu.be/Atdtf57Cuj8\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/Atdtf57Cuj8)\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_map <int, int> frq;\\n    \\n    void Add (int val) {\\n        frq [val] ++;\\n    }\\n    \\n    void Remove (int val) {\\n        frq [val] --;\\n    }\\n    \\n    int XthLargest (int x) {\\n        int cnt = 0;\\n        \\n        for (int val = -50; val < 0; val ++) {\\n            cnt += frq[val];\\n            if (cnt >= x) return val;\\n        }\\n        return 0;\\n    }\\n    \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> result;\\n        int n = nums.size();\\n        \\n        for (int j = 0; j < k-1; j ++) Add (nums[j]);\\n        for (int j = k-1; j < n; j ++) {\\n            Add (nums[j]);\\n\\n            result.push_back(XthLargest (x));\\n            \\n            Remove (nums[j-k+1]);\\n        }\\n        \\n        frq.clear();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map <int, int> frq;\\n    \\n    void Add (int val) {\\n        frq [val] ++;\\n    }\\n    \\n    void Remove (int val) {\\n        frq [val] --;\\n    }\\n    \\n    int XthLargest (int x) {\\n        int cnt = 0;\\n        \\n        for (int val = -50; val < 0; val ++) {\\n            cnt += frq[val];\\n            if (cnt >= x) return val;\\n        }\\n        return 0;\\n    }\\n    \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> result;\\n        int n = nums.size();\\n        \\n        for (int j = 0; j < k-1; j ++) Add (nums[j]);\\n        for (int j = k-1; j < n; j ++) {\\n            Add (nums[j]);\\n\\n            result.push_back(XthLargest (x));\\n            \\n            Remove (nums[j-k+1]);\\n        }\\n        \\n        frq.clear();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446908,
                "title": "unique-solution-pbds-c",
                "content": "\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\nvector<int> getSubarrayBeauty(vector<int>& arr,int k, int x) {\\n       int i=0,j=0;\\n        ordered_set st;\\n        int n=arr.size();\\n        vector<int>temp;\\n        int y=0;\\n        while(j<n){\\n            st.insert({arr[j],y});          \\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n              int ans = (st.find_by_order(x-1))->first;\\n              if(ans>=0)temp.push_back(0);\\n              else temp.push_back(ans);\\n              st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n              i++;\\n              j++;\\n            }\\n            y++;\\n        }\\n       return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\nvector<int> getSubarrayBeauty(vector<int>& arr,int k, int x) {\\n       int i=0,j=0;\\n        ordered_set st;\\n        int n=arr.size();\\n        vector<int>temp;\\n        int y=0;\\n        while(j<n){\\n            st.insert({arr[j],y});          \\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n              int ans = (st.find_by_order(x-1))->first;\\n              if(ans>=0)temp.push_back(0);\\n              else temp.push_back(ans);\\n              st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n              i++;\\n              j++;\\n            }\\n            y++;\\n        }\\n       return temp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446649,
                "title": "java-2-solution-easy-to-understand",
                "content": "# 1st :\\n# *** sliding window with frequency counter ***\\n# Complexity\\n- Time complexity: O(N*101)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(101 + (nums.length - k + 1))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] counter = new int[101];\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            counter[nums[i] + 50]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i < counter.length; i++) {\\n            count += counter[i];\\n\\n            if(count >= x) {\\n                if(i - 50 < 0) {\\n                    arr[index++] = i - 50;\\n                } else {\\n                    index++;\\n                }   \\n                break;\\n            }\\n        }\\n\\n        if(count < x) {\\n            index++;\\n        }\\n        \\n        for(int i = k; i < nums.length; i++) {\\n            counter[nums[i] + 50]++;\\n            counter[nums[i-k] + 50]--;\\n\\n            int c = 0;\\n            for(int j = 0; j < counter.length; j++) {\\n                c += counter[j];\\n\\n                if(c >= x) {\\n                    if(j - 50 < 0) {\\n                        arr[index++] = j - 50;\\n                    } else {\\n                        index++;\\n                    }      \\n                    break;\\n                }\\n            }\\n\\n            if(c < x) {\\n                index++;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```\\n\\n# 2nd : \\n# ***************** Tree Set *******************\\n# Complexity\\n- Time complexity: O(N*logK)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        arr[index++] = findXthSmallest(map, x);\\n\\n        for(int i = k; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            map.put(nums[i-k], map.getOrDefault(nums[i-k], 0) - 1);\\n            \\n            if(map.get(nums[i-k]) == 0) {\\n                map.remove(nums[i-k]);\\n            }\\n\\n            arr[index++] = findXthSmallest(map, x);\\n        }\\n\\n        return arr;\\n    }\\n\\n    private int findXthSmallest(TreeMap<Integer, Integer> map, int x) {\\n        int xth = 0;\\n        for(int n : map.keySet()) {\\n            if(n < 0) {\\n                xth += map.get(n);\\n            } else {\\n                break;\\n            }\\n\\n            if(xth >= x) {\\n                return n;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] counter = new int[101];\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            counter[nums[i] + 50]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i < counter.length; i++) {\\n            count += counter[i];\\n\\n            if(count >= x) {\\n                if(i - 50 < 0) {\\n                    arr[index++] = i - 50;\\n                } else {\\n                    index++;\\n                }   \\n                break;\\n            }\\n        }\\n\\n        if(count < x) {\\n            index++;\\n        }\\n        \\n        for(int i = k; i < nums.length; i++) {\\n            counter[nums[i] + 50]++;\\n            counter[nums[i-k] + 50]--;\\n\\n            int c = 0;\\n            for(int j = 0; j < counter.length; j++) {\\n                c += counter[j];\\n\\n                if(c >= x) {\\n                    if(j - 50 < 0) {\\n                        arr[index++] = j - 50;\\n                    } else {\\n                        index++;\\n                    }      \\n                    break;\\n                }\\n            }\\n\\n            if(c < x) {\\n                index++;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        arr[index++] = findXthSmallest(map, x);\\n\\n        for(int i = k; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            map.put(nums[i-k], map.getOrDefault(nums[i-k], 0) - 1);\\n            \\n            if(map.get(nums[i-k]) == 0) {\\n                map.remove(nums[i-k]);\\n            }\\n\\n            arr[index++] = findXthSmallest(map, x);\\n        }\\n\\n        return arr;\\n    }\\n\\n    private int findXthSmallest(TreeMap<Integer, Integer> map, int x) {\\n        int xth = 0;\\n        for(int n : map.keySet()) {\\n            if(n < 0) {\\n                xth += map.get(n);\\n            } else {\\n                break;\\n            }\\n\\n            if(xth >= x) {\\n                return n;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446577,
                "title": "sliding-subarray-beauty-c-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     int n=nums.size();\\n        vector<int> freq(51,0),ans;\\n        for(int i=0,j=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                freq[abs(nums[i])]++;\\n            }\\n            if(i-j+1>=k)\\n            {\\n                int count=0;\\n                for(int L=50;L>=1;L--)\\n                {\\n                    count+=freq[L];\\n                    if(count>=x)\\n                    {\\n                        ans.push_back(-L);\\n                        break;\\n                    }\\n                }\\n                if(count<x)\\n                {\\n                    ans.push_back(0);\\n                }\\n                if(nums[j]<0)\\n                {\\n                    freq[abs(nums[j])]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     int n=nums.size();\\n        vector<int> freq(51,0),ans;\\n        for(int i=0,j=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                freq[abs(nums[i])]++;\\n            }\\n            if(i-j+1>=k)\\n            {\\n                int count=0;\\n                for(int L=50;L>=1;L--)\\n                {\\n                    count+=freq[L];\\n                    if(count>=x)\\n                    {\\n                        ans.push_back(-L);\\n                        break;\\n                    }\\n                }\\n                if(count<x)\\n                {\\n                    ans.push_back(0);\\n                }\\n                if(nums[j]<0)\\n                {\\n                    freq[abs(nums[j])]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446342,
                "title": "c-easiest-code-explanation-with-comments-space-o-1-time-o-n",
                "content": "# Intuition\\nFirstly you need to check the constraints carefully, If you miss out on them than probably you wont be able to come out with viable solution . If you see, the range of numbers is onlyfrom [-50,50].Thus, We can simply Store counts of negative numbers only in a counter array and use it to find the xth smallest number.\\n\\n# Approach\\nNow Just iterate over the counter array and sum the counts of each number. When the sum of counts is greater than or equal to x we have found out xth smallest number and break the iteration . If sum of counts is never greater than or equal to x there aren\\'t enough negative numbers.\\n\\n# Complexity\\n- Time complexity: O(N*50)\\n\\n- Space complexity: O(1), as we have used constant extra space .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        // Answer Array\\n        vector<int> ans;\\n        int n = nums.size();\\n\\n        // We declare a array of size 51 to store the count \\n        // of each negative element among last k elements .\\n        // and size is 51 because neative elements are in \\n        // range of [-50,-1] only \\n\\n        // Also we dont need to store the count of positive elements \\n        // because there is no need \\n        int mp[51] = {0};\\n\\n        // Step 1 : Stored the count of each negative elemnts among first k elements\\n        for(int i = 0 ; i< k ; i++){\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n        }\\n        \\n        // Now check the xth smallest element \\n        // If there are more than or qual to x elements store the ans \\n        // else store zero \\n        int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n        \\n        \\n        // Now simply increase the count of next element and decrease \\n        // the count of last (i-k) element if they are negative respectively.\\n        // And check for Xth smallest element .\\n        for(int i = k ; i<n ; i++)\\n        {\\n            \\n            if(nums[i-k]<0 )\\n                mp[-nums[i-k]]--;\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n            int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        // Answer Array\\n        vector<int> ans;\\n        int n = nums.size();\\n\\n        // We declare a array of size 51 to store the count \\n        // of each negative element among last k elements .\\n        // and size is 51 because neative elements are in \\n        // range of [-50,-1] only \\n\\n        // Also we dont need to store the count of positive elements \\n        // because there is no need \\n        int mp[51] = {0};\\n\\n        // Step 1 : Stored the count of each negative elemnts among first k elements\\n        for(int i = 0 ; i< k ; i++){\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n        }\\n        \\n        // Now check the xth smallest element \\n        // If there are more than or qual to x elements store the ans \\n        // else store zero \\n        int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n        \\n        \\n        // Now simply increase the count of next element and decrease \\n        // the count of last (i-k) element if they are negative respectively.\\n        // And check for Xth smallest element .\\n        for(int i = k ; i<n ; i++)\\n        {\\n            \\n            if(nums[i-k]<0 )\\n                mp[-nums[i-k]]--;\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n            int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446275,
                "title": "clean-c-code-tc-o-n-100",
                "content": "# Approach\\n-> take a freq array of size 101 as  -50 <= nums[i] <= 50\\n-> represent -50 -> 0       50 -> 100     nums[i] += 50 sot that all are done 0 based indexing\\n-> then simply for each subarry traverse over the freq array\\n\\n# Complexity\\n- Time complexity:\\nO(n * 100)\\n\\n- Space complexity:\\nO(100)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(101), ans;\\n        for(int i = 0; i < k - 1; i++){\\n            freq[nums[i] + 50]++;\\n        }\\n        for(int i = k - 1; i < n; i++){\\n            freq[nums[i] + 50]++;\\n            int cnt = 0, val;\\n            for(int j = 0; j <= 100; j++){\\n                cnt += freq[j];\\n                if(cnt >= x){\\n                    val = min(0, j - 50);\\n                    ans.push_back(val);\\n                    break;\\n                }\\n            }\\n            freq[nums[i - k + 1] + 50]--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(101), ans;\\n        for(int i = 0; i < k - 1; i++){\\n            freq[nums[i] + 50]++;\\n        }\\n        for(int i = k - 1; i < n; i++){\\n            freq[nums[i] + 50]++;\\n            int cnt = 0, val;\\n            for(int j = 0; j <= 100; j++){\\n                cnt += freq[j];\\n                if(cnt >= x){\\n                    val = min(0, j - 50);\\n                    ans.push_back(val);\\n                    break;\\n                }\\n            }\\n            freq[nums[i - k + 1] + 50]--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446205,
                "title": "easy-sorting-optimisation-c",
                "content": "# Explaination\\n We shall store the count of negative numbers and find Xth smallest number  \\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int it(vector<int>& a, int x){ // to find xth smallest integer in subarray\\n        int ans=0;\\n        for(int i=50;i>=0;i--){\\n           if(a[i]>0){ \\n               x-=a[i];\\n               if(x<=0){\\n                   ans=i;\\n                   break;\\n               }\\n           }\\n        }\\n        return ans;\\n     }\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> m(51,0); // constraints : -50 <= nums[i] <= 50 \\n        int n=nums.size();\\n        vector<int> ans(n-k+1); \\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0){\\n                m[abs(nums[i])]++; //Storing negative integer counts\\n            }\\n        }\\n        ans[0]=-it(m,x); \\n        for(int i=1;i<=n-k;i++){\\n            if(nums[i+k-1]<0){\\n                m[abs(nums[i+k-1])]++;\\n            }\\n            if(nums[i-1]<0){  //If previous index is -ve reduce that count\\n                m[abs(nums[i-1])]--; \\n            }\\n            ans[i]=-it(m,x);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int it(vector<int>& a, int x){ // to find xth smallest integer in subarray\\n        int ans=0;\\n        for(int i=50;i>=0;i--){\\n           if(a[i]>0){ \\n               x-=a[i];\\n               if(x<=0){\\n                   ans=i;\\n                   break;\\n               }\\n           }\\n        }\\n        return ans;\\n     }\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> m(51,0); // constraints : -50 <= nums[i] <= 50 \\n        int n=nums.size();\\n        vector<int> ans(n-k+1); \\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0){\\n                m[abs(nums[i])]++; //Storing negative integer counts\\n            }\\n        }\\n        ans[0]=-it(m,x); \\n        for(int i=1;i<=n-k;i++){\\n            if(nums[i+k-1]<0){\\n                m[abs(nums[i+k-1])]++;\\n            }\\n            if(nums[i-1]<0){  //If previous index is -ve reduce that count\\n                m[abs(nums[i-1])]--; \\n            }\\n            ans[i]=-it(m,x);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446149,
                "title": "java-solution-1005-faster-frequency-array-sliding-window-o-n-x",
                "content": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int ans[]=new int[n-k+1];\\n        int count=0;\\n        int arr[]=new int[50+1];\\n        for(int i=0,j=0;i<n-k+1;i++){\\n            while(j<=i+k-1){\\n                if(nums[j]<0){\\n                    arr[Math.abs(nums[j])]++;\\n                    count++;\\n                }\\n                j++;\\n            }  \\n            if(count>=x){\\n                int pop=0;\\n                int idx=50;\\n                int small=0;\\n                while(pop<x){\\n                    if(arr[idx]!=0){\\n                        pop+=arr[idx];\\n                        small=idx;\\n                    }\\n                    idx--;\\n                }\\n                ans[i]=(-small);\\n            }\\n            \\n            if(nums[i]<0){\\n                count--;\\n                arr[Math.abs(nums[i])]--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int ans[]=new int[n-k+1];\\n        int count=0;\\n        int arr[]=new int[50+1];\\n        for(int i=0,j=0;i<n-k+1;i++){\\n            while(j<=i+k-1){\\n                if(nums[j]<0){\\n                    arr[Math.abs(nums[j])]++;\\n                    count++;\\n                }\\n                j++;\\n            }  \\n            if(count>=x){\\n                int pop=0;\\n                int idx=50;\\n                int small=0;\\n                while(pop<x){\\n                    if(arr[idx]!=0){\\n                        pop+=arr[idx];\\n                        small=idx;\\n                    }\\n                    idx--;\\n                }\\n                ans[i]=(-small);\\n            }\\n            \\n            if(nums[i]<0){\\n                count--;\\n                arr[Math.abs(nums[i])]--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445994,
                "title": "best-solution-using-set-explained-in-detail",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s; //we are using multiset because there can be multiple occurences of an element\\n        vector<int> ans;\\n        \\n        for(int i=0; i<k-1; i++)\\n        { \\n            if(nums[i] < 0)  //insert negative elements present in first window\\n            s.insert(nums[i]);\\n        }\\n        \\n        for(int i=k-1; i<nums.size(); i++)\\n        {\\n            if(nums[i] < 0)  //only insert -ve elements in the set\\n             s.insert(nums[i]);\\n\\n            if(s.size() < x)        //if current window does not have at least x -ve elements\\n                ans.push_back(0);   //then insert 0, as given in problem statement\\n            else\\n            {\\n            //otherwise, insert the xth element of the set \\n            //i.e. x-1 elements after the first element\\n              auto it = next(s.begin(), x-1); \\n              ans.push_back(*it);\\n            }\\n\\n        //now, window will shift by one place to the right, so we need to delete the first element of the window\\n        //but our set contains only -ve elements\\n        //so, if i-k+1 th was negative,then it must be in our set also, and we need to remove it\\n        //otherwise, no need to do anything\\n            if(nums[i-k+1] < 0) \\n            s.erase(s.find(nums[i-k+1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s; //we are using multiset because there can be multiple occurences of an element\\n        vector<int> ans;\\n        \\n        for(int i=0; i<k-1; i++)\\n        { \\n            if(nums[i] < 0)  //insert negative elements present in first window\\n            s.insert(nums[i]);\\n        }\\n        \\n        for(int i=k-1; i<nums.size(); i++)\\n        {\\n            if(nums[i] < 0)  //only insert -ve elements in the set\\n             s.insert(nums[i]);\\n\\n            if(s.size() < x)        //if current window does not have at least x -ve elements\\n                ans.push_back(0);   //then insert 0, as given in problem statement\\n            else\\n            {\\n            //otherwise, insert the xth element of the set \\n            //i.e. x-1 elements after the first element\\n              auto it = next(s.begin(), x-1); \\n              ans.push_back(*it);\\n            }\\n\\n        //now, window will shift by one place to the right, so we need to delete the first element of the window\\n        //but our set contains only -ve elements\\n        //so, if i-k+1 th was negative,then it must be in our set also, and we need to remove it\\n        //otherwise, no need to do anything\\n            if(nums[i-k+1] < 0) \\n            s.erase(s.find(nums[i-k+1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445973,
                "title": "python3-solution",
                "content": "\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k:\\n                vals.remove(nums[i-k])\\n            if i >= k-1: \\n                ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k:\\n                vals.remove(nums[i-k])\\n            if i >= k-1: \\n                ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445892,
                "title": "easy-c-sliding-window-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size(), neg=0, hav=0;\\n\\t\\t\\n\\t\\t// TAKE HASHMAP OF SIZE 102 ( It take all neg & positive values )\\n        vector<int> hashMap(102,0), res;\\n        \\n        for(int i=0; i<k; i++){ \\n            if(nums[i]<0) { neg++; hashMap[nums[i]+50]++; }\\n        }\\n        \\n        if(neg<x) res.push_back(0);\\n        for(int i=0; i<102; i++){\\n            if(hashMap[i]>0) {\\n                if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                hav+= hashMap[i];\\n            }\\n        }\\n        \\n        for(int i=k; i<n; i++){\\n            hav=0;\\n            if(nums[i-k]<0){ neg--; hashMap[nums[i-k]+50]--; } \\n            if(nums[i]<0) { neg++;hashMap[nums[i]+50]++; } \\n    \\n            if(neg<x){ res.push_back(0); continue; }\\n            for(int i=0; i<102; i++){\\n                if(hashMap[i]>0) {\\n                    if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                    hav+= hashMap[i];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size(), neg=0, hav=0;\\n\\t\\t\\n\\t\\t// TAKE HASHMAP OF SIZE 102 ( It take all neg & positive values )\\n        vector<int> hashMap(102,0), res;\\n        \\n        for(int i=0; i<k; i++){ \\n            if(nums[i]<0) { neg++; hashMap[nums[i]+50]++; }\\n        }\\n        \\n        if(neg<x) res.push_back(0);\\n        for(int i=0; i<102; i++){\\n            if(hashMap[i]>0) {\\n                if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                hav+= hashMap[i];\\n            }\\n        }\\n        \\n        for(int i=k; i<n; i++){\\n            hav=0;\\n            if(nums[i-k]<0){ neg--; hashMap[nums[i-k]+50]--; } \\n            if(nums[i]<0) { neg++;hashMap[nums[i]+50]++; } \\n    \\n            if(neg<x){ res.push_back(0); continue; }\\n            for(int i=0; i<102; i++){\\n                if(hashMap[i]>0) {\\n                    if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                    hav+= hashMap[i];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445866,
                "title": "simple-to-understand-just-count-and-traverse-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRange of an element is between -50 to 50 and we need just negative so at each element i have to find xth smallest that will be in betwenn -1 to -50;\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake a array of size 50 to ->\\nsliding window = just store the frequency of each negative number in window in array and easily find the xth smallest by reversing the array the simple\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n*50)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int arr[],int x){\\n        for(int i=50;i>0;i--){\\n            if(arr[i]>0)x-=arr[i];\\n            if(x<=0)return i;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int arr[52]={0};// to store freq in a window\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)\\n            arr[abs(nums[i])]+=1;\\n        }\\n        vector<int> ans(nums.size()-k+1,0);\\n        for(int i=k;i<=nums.size();i++){\\n            int l=find(arr,x);// seach xth smallest elementsl\\n            if(l>0)\\n            ans[i-k]=(-l);             \\n            if(i<nums.size()&&nums[i]<0)// to store new element\\n            arr[abs(nums[i])]+=1;\\n            if(nums[i-k]<0)// to remove out of window element\\n            arr[abs(nums[i-k])]-=1;\\n            \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int arr[],int x){\\n        for(int i=50;i>0;i--){\\n            if(arr[i]>0)x-=arr[i];\\n            if(x<=0)return i;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int arr[52]={0};// to store freq in a window\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)\\n            arr[abs(nums[i])]+=1;\\n        }\\n        vector<int> ans(nums.size()-k+1,0);\\n        for(int i=k;i<=nums.size();i++){\\n            int l=find(arr,x);// seach xth smallest elementsl\\n            if(l>0)\\n            ans[i-k]=(-l);             \\n            if(i<nums.size()&&nums[i]<0)// to store new element\\n            arr[abs(nums[i])]+=1;\\n            if(nums[i-k]<0)// to remove out of window element\\n            arr[abs(nums[i-k])]-=1;\\n            \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445858,
                "title": "c-easy-sliding-window-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n     void push_ele(map<int,int>&mp,vector<int>&ans,int x)\\n     { \\n         int num=0;   // if cnt of negative elements is less than x\\n         int cnt=0;\\n         for(auto it:mp)\\n         {\\n             cnt+=it.second;\\n             if(cnt>=x)  // if cnt becomes greater than or equals to x\\n             {\\n                 num=it.first;  // xth element equals it.first\\n                 break;\\n             }\\n         }\\n         ans.push_back(num);\\n\\n     }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x)\\n    {\\n        map<int,int>mp; // to cnt the number of elements \\n        int cnt=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n            mp[nums[i]]++; // if it is negative then insert in map\\n            \\n            }\\n        }\\n        vector<int>ans;\\n        push_ele(mp,ans,x); \\n        for(int i=k;i<nums.size();i++) // sliding the window\\n        {\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n            if(nums[i-k]<0)\\n            mp[nums[i-k]]--;\\n            push_ele(mp,ans,x); // function to insert xth negative element if exists\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n     void push_ele(map<int,int>&mp,vector<int>&ans,int x)\\n     { \\n         int num=0;   // if cnt of negative elements is less than x\\n         int cnt=0;\\n         for(auto it:mp)\\n         {\\n             cnt+=it.second;\\n             if(cnt>=x)  // if cnt becomes greater than or equals to x\\n             {\\n                 num=it.first;  // xth element equals it.first\\n                 break;\\n             }\\n         }\\n         ans.push_back(num);\\n\\n     }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x)\\n    {\\n        map<int,int>mp; // to cnt the number of elements \\n        int cnt=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n            mp[nums[i]]++; // if it is negative then insert in map\\n            \\n            }\\n        }\\n        vector<int>ans;\\n        push_ele(mp,ans,x); \\n        for(int i=k;i<nums.size();i++) // sliding the window\\n        {\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n            if(nums[i-k]<0)\\n            mp[nums[i-k]]--;\\n            push_ele(mp,ans,x); // function to insert xth negative element if exists\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445851,
                "title": "c-using-multiset",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        1. To handle duplicates, use multiset.\\n        2. Use the next function to find the subarray\\'s xth smallest integer.\\n        3. There is no need to take care of positive integers (according to question).\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    multiset<int>mul;\\n    vector<int>result;\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        int z=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                mul.insert(nums[i]);\\n            }\\n            if(i-z+1==k){\\n                if(mul.size()<x){\\n                    result.push_back(0);\\n                }else{\\n                    result.push_back(*next(mul.begin(),x-1));\\n                }\\n                if(nums[z]<0){\\n                    mul.erase(mul.find(nums[z]));\\n                }\\n                z++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    multiset<int>mul;\\n    vector<int>result;\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        int z=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                mul.insert(nums[i]);\\n            }\\n            if(i-z+1==k){\\n                if(mul.size()<x){\\n                    result.push_back(0);\\n                }else{\\n                    result.push_back(*next(mul.begin(),x-1));\\n                }\\n                if(nums[z]<0){\\n                    mul.erase(mul.find(nums[z]));\\n                }\\n                z++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445847,
                "title": "c-very-simple-explanation-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. take a freq array,f, where index(-50)=0, and index (50)= 100\\nas -50<=nums[i]<=50\\n2. take 2 pointers i,j..i points to start of window, j points to end of window...j is used to stretch the sliding window\\nas you increase j, do f[nums[j]+50]++ \\n3. for the current window find the xth smallest number,and push it to ans vector\\n\\nHow this freq array f helps in finding the xth smallest?\\nsay a window= [-2, -1, 3, -5, -5, -2], x= 5\\n5th smallest number= -1\\nso for the window, freq array will look like this\\nfreq(-5)= 2, freq(-2)= 2, freq(-1)= 1, freq(3)= 1\\nf[-5+50]= 2, f[-2+50]= 2, f[-1+50]= 1, f[3+50]= 1\\n\\nwe move from index 0 to 100 and we have totalCount=0 initially:\\ni=45: f[45]>0: totalCount=totalCount+ f[45]= 2\\ni=48: f[48]>0: totalCount=totalCount+ f[48]= 4\\ni=49: f[49]>0: totalCount=totalCount+ f[49]= 5\\nat i=49, totalCount=5 which is >=x..this means at i=49, we have the xth smallest number...hence i-50 is the xth smallest number ,which is 49-50, ie -1\\n\\n\\n# Complexity\\n- Time complexity: O(n)+ O((n-k+1)*100)= O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(100)= O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findXthSmallest(vector<int>&f, int x){\\n        int totalCount=0;\\n        for(int i=0;i<101;i++){\\n            totalCount+= f[i];\\n            if(totalCount>=x) {\\n                if(i-50<0) return i-50;//index i points to number i-50..if i-50 is negative return it \\n                else return 0;//if i-50 is +ve, return 0\\n            }\\n        }\\n        return 0;//return anything..Whatever is to be returned ,will return from loop only\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> f(105,0), ans;//index of (-50)= 0, index of (50)= 100\\n        int i=0, j=0, n=nums.size();\\n        \\n        while(j<n){\\n            while(j-i<k && j<n){\\n                f[nums[j]+50]++;\\n                j++;\\n            }\\n            //find x th smallest\\n            int xSmallest= findXthSmallest(f, x);\\n            ans.push_back(xSmallest);\\n            f[nums[i]+50]--;//sliding the subarray, so remove ith element\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findXthSmallest(vector<int>&f, int x){\\n        int totalCount=0;\\n        for(int i=0;i<101;i++){\\n            totalCount+= f[i];\\n            if(totalCount>=x) {\\n                if(i-50<0) return i-50;//index i points to number i-50..if i-50 is negative return it \\n                else return 0;//if i-50 is +ve, return 0\\n            }\\n        }\\n        return 0;//return anything..Whatever is to be returned ,will return from loop only\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> f(105,0), ans;//index of (-50)= 0, index of (50)= 100\\n        int i=0, j=0, n=nums.size();\\n        \\n        while(j<n){\\n            while(j-i<k && j<n){\\n                f[nums[j]+50]++;\\n                j++;\\n            }\\n            //find x th smallest\\n            int xSmallest= findXthSmallest(f, x);\\n            ans.push_back(xSmallest);\\n            f[nums[i]+50]--;//sliding the subarray, so remove ith element\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445833,
                "title": "c-java-min-heap-using-maps",
                "content": "## Explanation\\nI tried to solve using priority queues and multisets initially but it gave me TLE as I was iterating over duplicate values every time !! Then I tried this approach where we use Maps as MinHeaps to store the values in the array and their frequencies so that while calculating the x-th smallest integer each time, the code runs fast as we don\\'t need to traverse over all the elements with same values in the subarray !!\\n\\n## Code\\n\\n**Code that gave me TLE using Multisets :**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int findKthSmallest(multiset <int> &pq, int x){\\n        int i = 1;\\n        for(auto it = pq.begin(); it != pq.end(); it++){\\n            if(*it >= 0) return 0;\\n            if(i == x) {\\n                return *it;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset <int> st;\\n        int n = size(nums);\\n        vector<int>res;\\n\\n        for(int i = 0; i < k; i++) st.insert(nums[i]);\\n        res.push_back(findKthSmallest(st,x));\\n\\n        for(int i = 0; i < n-k; i++){\\n            auto it = st.find(nums[i]);\\n            st.erase(it);\\n            st.insert(nums[i+k]);\\n            res.push_back(findKthSmallest(st,x));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**Working Code using Maps :**\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        int n = size(nums);\\n        vector<int>res;\\n        map <int, int> minHeap;\\n\\n        for(int i = 0; i < n; i++){\\n            minHeap[nums[i]]++;\\n            if(i >= k){\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap[nums[i-k]]--;\\n                if(minHeap[nums[i-k]] == 0) minHeap.erase(nums[i-k]);\\n            }\\n            if(i >= k-1){\\n                int cnt = 0, val = 0;\\n                for(auto &[k,v] : minHeap){\\n                    cnt += v;\\n                    if(cnt >= x) {\\n                        val = k;\\n                        break;\\n                    }\\n                }\\n                res.push_back((val > 0)? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> minHeap = new TreeMap<>();\\n\\n        for(int i = 0; i < n; i++) {\\n            minHeap.put(nums[i], minHeap.getOrDefault(nums[i], 0) + 1);\\n            if(i >= k) {\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap.put(nums[i-k], minHeap.get(nums[i-k]) - 1);\\n                if(minHeap.get(nums[i-k]) == 0) minHeap.remove(nums[i-k]);\\n            }\\n            if(i >= k-1) {\\n                int cnt = 0, val = 0;\\n                for(Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n                    cnt += entry.getValue();\\n                    if(cnt >= x) {\\n                        val = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                res.add((val > 0) ? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n}\\n\\n```\\n## Complexity\\n- Time complexity: $$O(n log(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findKthSmallest(multiset <int> &pq, int x){\\n        int i = 1;\\n        for(auto it = pq.begin(); it != pq.end(); it++){\\n            if(*it >= 0) return 0;\\n            if(i == x) {\\n                return *it;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset <int> st;\\n        int n = size(nums);\\n        vector<int>res;\\n\\n        for(int i = 0; i < k; i++) st.insert(nums[i]);\\n        res.push_back(findKthSmallest(st,x));\\n\\n        for(int i = 0; i < n-k; i++){\\n            auto it = st.find(nums[i]);\\n            st.erase(it);\\n            st.insert(nums[i+k]);\\n            res.push_back(findKthSmallest(st,x));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        int n = size(nums);\\n        vector<int>res;\\n        map <int, int> minHeap;\\n\\n        for(int i = 0; i < n; i++){\\n            minHeap[nums[i]]++;\\n            if(i >= k){\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap[nums[i-k]]--;\\n                if(minHeap[nums[i-k]] == 0) minHeap.erase(nums[i-k]);\\n            }\\n            if(i >= k-1){\\n                int cnt = 0, val = 0;\\n                for(auto &[k,v] : minHeap){\\n                    cnt += v;\\n                    if(cnt >= x) {\\n                        val = k;\\n                        break;\\n                    }\\n                }\\n                res.push_back((val > 0)? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> minHeap = new TreeMap<>();\\n\\n        for(int i = 0; i < n; i++) {\\n            minHeap.put(nums[i], minHeap.getOrDefault(nums[i], 0) + 1);\\n            if(i >= k) {\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap.put(nums[i-k], minHeap.get(nums[i-k]) - 1);\\n                if(minHeap.get(nums[i-k]) == 0) minHeap.remove(nums[i-k]);\\n            }\\n            if(i >= k-1) {\\n                int cnt = 0, val = 0;\\n                for(Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n                    cnt += entry.getValue();\\n                    if(cnt >= x) {\\n                        val = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                res.add((val > 0) ? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445804,
                "title": "ordered-set-map",
                "content": "# Method 1\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<int, null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update>\\n  \\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        ordered_set st;\\n        int i=0,j=0,n=size(nums);\\n        while(j < n){\\n            st.insert(nums[j]);\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int e = *(st.find_by_order(x-1));\\n                ans.push_back(e < 0 ? e : 0);\\n                myerase(st,(nums[i]));\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Method 2\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = size(nums), i = 0, j = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            mp[nums[j]]++;\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int ct=0;\\n                for(auto&[k,e]: mp){\\n                    if(ct+e>=x){\\n                        ans.push_back(k>0?0:k);\\n                        break;\\n                    }\\n                    ct += e;\\n                }\\n                if(--mp[nums[i]] == 0) mp.erase(nums[i]);\\n                j++,i++;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<int, null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update>\\n  \\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        ordered_set st;\\n        int i=0,j=0,n=size(nums);\\n        while(j < n){\\n            st.insert(nums[j]);\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int e = *(st.find_by_order(x-1));\\n                ans.push_back(e < 0 ? e : 0);\\n                myerase(st,(nums[i]));\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = size(nums), i = 0, j = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            mp[nums[j]]++;\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int ct=0;\\n                for(auto&[k,e]: mp){\\n                    if(ct+e>=x){\\n                        ans.push_back(k>0?0:k);\\n                        break;\\n                    }\\n                    ct += e;\\n                }\\n                if(--mp[nums[i]] == 0) mp.erase(nums[i]);\\n                j++,i++;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445751,
                "title": "python3-sorted-list-solution-o-nlogn",
                "content": "**Approach**\\nMaintain an ordered list to store the integers and update it using two pointers.\\n\\n**Complexity**\\nO(NlogN)\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl = SortedList()\\n        n = len(nums)\\n        ng = 0\\n        for i in range(k):\\n            sl.add(nums[i])\\n\\n        ans = []\\n        ans.append(min(sl[x - 1], 0))\\n        \\n        i, j = 0, k\\n        \\n        while j < n:\\n            sl.discard(nums[i])\\n            sl.add(nums[j])\\n            i += 1\\n            j += 1\\n            ans.append(min(sl[x - 1], 0))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl = SortedList()\\n        n = len(nums)\\n        ng = 0\\n        for i in range(k):\\n            sl.add(nums[i])\\n\\n        ans = []\\n        ans.append(min(sl[x - 1], 0))\\n        \\n        i, j = 0, k\\n        \\n        while j < n:\\n            sl.discard(nums[i])\\n            sl.add(nums[j])\\n            i += 1\\n            j += 1\\n            ans.append(min(sl[x - 1], 0))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445717,
                "title": "map-cpp-two-map-solution-with-detailed-explanation-o-n-log-n",
                "content": "### if you like the solution, please give me a up vote.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to find the xth smallest integer in subarray,\\nwhen we move the subarray, do following operations,\\n1. add new value `nums[i]`\\n2. remove the oldest value `nums[i-k+1]`\\n\\n### Concept\\n<!-- Describe your approach to solving the problem. -->\\nWe can use two map `lower, upper` to maintain the value order,\\nthe count of `lower` is x\\nthe count of `upper` is k - x\\n\\nso the xth smallest integer is at `lower.rbegin()`\\n\\n\\n\\n### Operation : remove the oldest value\\nafter remove the oldest value,\\nwe want to maintain map as below,\\n- the count of `lower` is `x - 1`\\n- the count of `upper` is `k - x`\\n\\nthe oldest value maybe in `lower` or `upper`\\n1. the oldest value in `lower`\\n    directly remove the oldest value from `lower`.\\n\\n2. the oldest value in `upper`\\na. remove the oldest value from `upper`.\\nb. get the largest value from `lower` and insert into `upper`\\n\\n\\n### Operation: add new value\\n1. insert the value into `upper`\\n2. get the smallest value from `upper` and insert into `lower`\\n\\n\\n\\n### Operation: get the xth smallest value\\nthe xth smallest integer is at `lower.rbegin()`\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void remove_val(map<int, int> &m, int val) {\\n        m[val]--;\\n        if(m[val] == 0) {\\n            m.erase(val);\\n        }\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> output(n-k+1, 0);\\n        int upper_cnt = 0;\\n        int val;\\n        map<int, int> lower;\\n        map<int, int> upper;\\n        \\n        for(int i = 0 ; i < (k-1) ; i++) {\\n            upper[nums[i]]++;\\n            upper_cnt++;\\n            if(upper_cnt <= (k - x)) {\\n                continue;\\n            }\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            \\n            remove_val(upper, val);\\n        }\\n        \\n        for(int i = k-1; i < n; i++) {\\n            int idx = i - k + 1;\\n            val = nums[i];\\n            upper[val]++;\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            remove_val(upper, val);\\n            \\n            \\n            if(lower.rbegin()->first < 0) {\\n                output[idx] = lower.rbegin()->first;\\n            }\\n            \\n        \\n            //remove val\\n            val = nums[idx];\\n            if(val >= upper.begin()->first) {\\n                remove_val(upper, val);\\n                \\n                //move lower to upper;\\n                val = lower.rbegin()->first;\\n                upper[val]++;\\n                remove_val(lower, val);\\n            }\\n            else {\\n                remove_val(lower, val);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void remove_val(map<int, int> &m, int val) {\\n        m[val]--;\\n        if(m[val] == 0) {\\n            m.erase(val);\\n        }\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> output(n-k+1, 0);\\n        int upper_cnt = 0;\\n        int val;\\n        map<int, int> lower;\\n        map<int, int> upper;\\n        \\n        for(int i = 0 ; i < (k-1) ; i++) {\\n            upper[nums[i]]++;\\n            upper_cnt++;\\n            if(upper_cnt <= (k - x)) {\\n                continue;\\n            }\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            \\n            remove_val(upper, val);\\n        }\\n        \\n        for(int i = k-1; i < n; i++) {\\n            int idx = i - k + 1;\\n            val = nums[i];\\n            upper[val]++;\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            remove_val(upper, val);\\n            \\n            \\n            if(lower.rbegin()->first < 0) {\\n                output[idx] = lower.rbegin()->first;\\n            }\\n            \\n        \\n            //remove val\\n            val = nums[idx];\\n            if(val >= upper.begin()->first) {\\n                remove_val(upper, val);\\n                \\n                //move lower to upper;\\n                val = lower.rbegin()->first;\\n                upper[val]++;\\n                remove_val(lower, val);\\n            }\\n            else {\\n                remove_val(lower, val);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445702,
                "title": "sliding-window-ordered-set-c",
                "content": "# Intuition\\nProblem statement gives clear indication. All you need to is to think of a data structure which perofrms insertion and deletion in logn time and finds kth-element in logn. Ordered set is perfect for that\\n\\n# Approach\\nKeep moving the sliding window and find the kth element of each window using Ordered Set.\\n\\n# Complexity\\n- Time complexity:\\nNlogN for Ordered Set\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n//INCLUDE ORDERED SET\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_multiset tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\n//ORDERED SET doesn\\'t contains duplicate so use pair and pass index along with number to avoid duplicates\\n\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_multiset os;\\n        int start=0;\\n        int end=0;\\n        vector <int> ans;\\n        while(end<nums.size()){\\n            os.insert({nums[end],end});\\n            if(end-start+1>k){\\n                //MOVE the sliding window\\n                os.erase({nums[start],start});\\n                ++start;\\n            }\\n            if(end-start+1==k){\\n                //Find xth smallest element\\n                auto it = os.find_by_order(x - 1);\\n                ans.push_back(it->first);\\n            }\\n            ++end;\\n        }\\n        for(auto &it:ans)if(it>0)it=0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\n//INCLUDE ORDERED SET\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_multiset tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\n//ORDERED SET doesn\\'t contains duplicate so use pair and pass index along with number to avoid duplicates\\n\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_multiset os;\\n        int start=0;\\n        int end=0;\\n        vector <int> ans;\\n        while(end<nums.size()){\\n            os.insert({nums[end],end});\\n            if(end-start+1>k){\\n                //MOVE the sliding window\\n                os.erase({nums[start],start});\\n                ++start;\\n            }\\n            if(end-start+1==k){\\n                //Find xth smallest element\\n                auto it = os.find_by_order(x - 1);\\n                ans.push_back(it->first);\\n            }\\n            ++end;\\n        }\\n        for(auto &it:ans)if(it>0)it=0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445695,
                "title": "pbds-policy-based-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n  \\n// namespace necessary for GNU based \\n// policy based data structures\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int n= nums.size();\\n        // multiset<int> m;\\n        ordered_set m;\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            m.insert(nums[i]);\\n            if(i-j+1==k)\\n            {\\n                auto it = m.find_by_order(x-1); \\n                if((*it)>=0)\\n                    ans.push_back(0);\\n                else\\n                ans.push_back((*it));\\n                m.erase(--m.lower_bound(nums[j]));\\n                j++;\\n            }\\n            i++;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n  \\n// namespace necessary for GNU based \\n// policy based data structures\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int n= nums.size();\\n        // multiset<int> m;\\n        ordered_set m;\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            m.insert(nums[i]);\\n            if(i-j+1==k)\\n            {\\n                auto it = m.find_by_order(x-1); \\n                if((*it)>=0)\\n                    ans.push_back(0);\\n                else\\n                ans.push_back((*it));\\n                m.erase(--m.lower_bound(nums[j]));\\n                j++;\\n            }\\n            i++;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445666,
                "title": "map-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        map<int, int> freq;\\n        \\n        int l = 0, r = 0;\\n        \\n        while (r < n) {\\n            freq[nums[r]]++;\\n            \\n            if (r >= k-1) {\\n                \\n                int cnt = 0;\\n                for (auto it : freq) {\\n                    cnt += it.second;\\n                    if (cnt >= x) {\\n                        ans.push_back((it.first < 0) ? it.first : 0);\\n                        break;\\n                    }\\n                }\\n                \\n                if (--freq[nums[l]] == 0) \\n                    freq.erase(nums[l]);\\n                \\n                l++;\\n            }\\n            \\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        map<int, int> freq;\\n        \\n        int l = 0, r = 0;\\n        \\n        while (r < n) {\\n            freq[nums[r]]++;\\n            \\n            if (r >= k-1) {\\n                \\n                int cnt = 0;\\n                for (auto it : freq) {\\n                    cnt += it.second;\\n                    if (cnt >= x) {\\n                        ans.push_back((it.first < 0) ? it.first : 0);\\n                        break;\\n                    }\\n                }\\n                \\n                if (--freq[nums[l]] == 0) \\n                    freq.erase(nums[l]);\\n                \\n                l++;\\n            }\\n            \\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101014,
                "title": "simple-c-easy-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<k-1;i++)   // to avoid computing for the first time min value\\n            mp[nums[i]]++;\\n        vector<int> ans;\\n        for(int i=k-1;i<nums.size();i++){\\n            mp[nums[i]]++;\\n            int count = 0;\\n            int num = 0;\\n            for(auto s:mp){\\n                count += s.second;\\n                if(count>=x){\\n                    num = min(num,s.first);\\n                    break;\\n                }\\n            }\\n            ans.push_back(num);\\n            mp[nums[i-k+1]]--;\\n            // if(mp[nums[i-k+1]]==0)\\n            //     mp.erase(nums[i-k+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<k-1;i++)   // to avoid computing for the first time min value\\n            mp[nums[i]]++;\\n        vector<int> ans;\\n        for(int i=k-1;i<nums.size();i++){\\n            mp[nums[i]]++;\\n            int count = 0;\\n            int num = 0;\\n            for(auto s:mp){\\n                count += s.second;\\n                if(count>=x){\\n                    num = min(num,s.first);\\n                    break;\\n                }\\n            }\\n            ans.push_back(num);\\n            mp[nums[i-k+1]]--;\\n            // if(mp[nums[i-k+1]]==0)\\n            //     mp.erase(nums[i-k+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062124,
                "title": "segment-tree-solution-o-n-log-64",
                "content": "\\t# we utilize the fact that the range of negative numbers we have to track (-50 -> -1)\\n\\t# is small.  We build a segment tree where each leaf is the cnt of negative values in\\n\\t# the range and each parent is the count of negative numbers in its children.  We \\n\\t# scroll through the nums array, adding negative numbers as we see them and \\n\\t# removing them as they leave our window.  \\n\\t\\n\\tdef removeVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] -= 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def addVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] += 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def checkX(tree, x):\\n            index = 1\\n            while True:\\n                indexL = 2*index\\n                indexR = 2*index + 1\\n                \\n                if indexL >= len(tree):\\n                    return(index - 2*64)\\n                \\n                if tree[indexL] < x:\\n                    x -= tree[indexL]\\n                    index = indexR\\n                else:\\n                    index = indexL\\n                    \\n        #########\\n        n = len(nums)\\n        \\n        tree = [0]*(2*64)\\n        \\n        ans = []\\n\\t\\t# build the tree for our initial window of size k:\\n        for val in nums[:k]:\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n        if tree[1] < x:\\n            ans.append(0)\\n        else:\\n            ans.append(checkX(tree, x))\\n        \\n\\t\\t# scroll through nums, updating our segment tree and array ans:\\n        for ii in range(k, n):\\n            val = nums[ii]\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n            val2 = nums[ii-k]\\n            if val2 < 0:\\n                tree = removeVal(tree, val2)\\n                \\n            if tree[1] < x:\\n                ans.append(0)\\n            else:\\n                ans.append(checkX(tree, x))\\n        \\n        return(ans)",
                "solutionTags": [],
                "code": "\\t# we utilize the fact that the range of negative numbers we have to track (-50 -> -1)\\n\\t# is small.  We build a segment tree where each leaf is the cnt of negative values in\\n\\t# the range and each parent is the count of negative numbers in its children.  We \\n\\t# scroll through the nums array, adding negative numbers as we see them and \\n\\t# removing them as they leave our window.  \\n\\t\\n\\tdef removeVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] -= 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def addVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] += 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def checkX(tree, x):\\n            index = 1\\n            while True:\\n                indexL = 2*index\\n                indexR = 2*index + 1\\n                \\n                if indexL >= len(tree):\\n                    return(index - 2*64)\\n                \\n                if tree[indexL] < x:\\n                    x -= tree[indexL]\\n                    index = indexR\\n                else:\\n                    index = indexL\\n                    \\n        #########\\n        n = len(nums)\\n        \\n        tree = [0]*(2*64)\\n        \\n        ans = []\\n\\t\\t# build the tree for our initial window of size k:\\n        for val in nums[:k]:\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n        if tree[1] < x:\\n            ans.append(0)\\n        else:\\n            ans.append(checkX(tree, x))\\n        \\n\\t\\t# scroll through nums, updating our segment tree and array ans:\\n        for ii in range(k, n):\\n            val = nums[ii]\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n            val2 = nums[ii-k]\\n            if val2 < 0:\\n                tree = removeVal(tree, val2)\\n                \\n            if tree[1] < x:\\n                ans.append(0)\\n            else:\\n                ans.append(checkX(tree, x))\\n        \\n        return(ans)",
                "codeTag": "Python3"
            },
            {
                "id": 4032841,
                "title": "simple-java-o-n-50",
                "content": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] arr, int k, int x) {\\n        int[] ans = new int[arr.length - k + 1];\\n        int[] temp = new int[51];\\n        for(int i = 0 ; i < k ; i++){\\n            int ele = arr[i];\\n            if(ele < 0){\\n                temp[-1 * ele]++;\\n            }\\n        }\\n        int ptr = 0;\\n        ans[ptr++] = getValue(temp , x);\\n        for(int i = k ; i < arr.length ; i++){\\n            int prev = i - k;\\n            if(arr[prev] < 0)\\n                temp[arr[prev] * -1]--;\\n            if(arr[i] < 0)\\n                temp[arr[i] * -1]++;\\n            ans[ptr++] = getValue(temp , x);\\n        }\\n        return ans;\\n    }\\n    private int getValue(int[] arr , int x){\\n        int count = 0;\\n        int value = 0;\\n        for(int i = 50 ; i >= 0 ; i--){\\n            if(arr[i] > 0){\\n                count += arr[i];\\n                value = i;\\n            }\\n            if(count >= x) return i * -1;\\n        }\\n        return 0;\\n    }\\n}\\n\\n```\\n***Please UpVote, if found useful :)***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] arr, int k, int x) {\\n        int[] ans = new int[arr.length - k + 1];\\n        int[] temp = new int[51];\\n        for(int i = 0 ; i < k ; i++){\\n            int ele = arr[i];\\n            if(ele < 0){\\n                temp[-1 * ele]++;\\n            }\\n        }\\n        int ptr = 0;\\n        ans[ptr++] = getValue(temp , x);\\n        for(int i = k ; i < arr.length ; i++){\\n            int prev = i - k;\\n            if(arr[prev] < 0)\\n                temp[arr[prev] * -1]--;\\n            if(arr[i] < 0)\\n                temp[arr[i] * -1]++;\\n            ans[ptr++] = getValue(temp , x);\\n        }\\n        return ans;\\n    }\\n    private int getValue(int[] arr , int x){\\n        int count = 0;\\n        int value = 0;\\n        for(int i = 50 ; i >= 0 ; i--){\\n            if(arr[i] > 0){\\n                count += arr[i];\\n                value = i;\\n            }\\n            if(count >= x) return i * -1;\\n        }\\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013740,
                "title": "c-easy-solution-using-sliding-window-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(),i = 0,j = 0,sz = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            if(nums[j] < 0){ \\n                mp[nums[j]]++;\\n                sz++;\\n            }\\n            if(j-i+1 == k){\\n                if(sz >= x){\\n                    int ct = 0;\\n                    for(auto it:mp){\\n                        ct += it.second;\\n                        if(ct >= x){\\n                            ans.push_back(it.first);\\n                            break;\\n                        }\\n                    }\\n                }else{\\n                    ans.push_back(0);\\n                }\\n                if(nums[i] < 0){\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]] == 0) mp.erase(nums[i]);\\n                    sz--;\\n                }\\n                i++;\\n            }\\n\\t\\t\\tj++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(),i = 0,j = 0,sz = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            if(nums[j] < 0){ \\n                mp[nums[j]]++;\\n                sz++;\\n            }\\n            if(j-i+1 == k){\\n                if(sz >= x){\\n                    int ct = 0;\\n                    for(auto it:mp){\\n                        ct += it.second;\\n                        if(ct >= x){\\n                            ans.push_back(it.first);\\n                            break;\\n                        }\\n                    }\\n                }else{\\n                    ans.push_back(0);\\n                }\\n                if(nums[i] < 0){\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]] == 0) mp.erase(nums[i]);\\n                    sz--;\\n                }\\n                i++;\\n            }\\n\\t\\t\\tj++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002083,
                "title": "easy-java-o-n-time-and-o-1-memory-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nAfter reading the problem statement there is one thing which is quite apparent. All numbers >= 0 in the array are useless to us. They do not influence the \"beauty\" of any subarray in any way.\\n\\nAnother important thing to notice in the constraints is that nums[i] is between -50 and 50.\\n\\nSince we only care about negative values, this means that there are a total of 50 potential distinct values in this array which we care about [-50, -1]. Let\\'s try and use this!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet\\'s use our usual left and right pointer technique to create a window of k elements, and then shift it accordingly every iteration.\\n\\nFor every window let\\'s use an array of size 50 representing the count of all negative numbers in our window. We will update the count accordingly as we go left to right.\\n\\nOne task remains, checking for the Xth smallest negative number in each window. We can easily do this using our array of negative number counts. Index 0 represents the count of -50 in a given window, index 1 represents -49, and so on. The last index represents the count of -1. We can just traverse this small array of size 50 from left to right for every window and increase our count of the smallest negative numbers until we hit or surpass x. If we break out of the loop before hitting x that means that there are less than x negative numbers so we return 0.\\n\\n\\n# Complexity\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- O(n)\\n- Going through the whole array with left and right pointers takes is a linear time operation. Going through the array of negative number counts is a constant time operation since there are only 50 entries.\\n\\n\\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- O(1)\\n- We are using an auxilary array of size 50, but size 50 is constant.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int[] ans = new int[nums.length - k + 1];\\n        int[] negCount = new int[50];\\n        int left = 0;\\n        int ansPtr = 0;\\n\\n        for(int right = 0; right < nums.length; right++){\\n\\n            if(nums[right] < 0){\\n                negCount[nums[right] + 50] += 1;\\n            }\\n\\n            if(right - left >= k){\\n\\n                if(nums[left] < 0){\\n                    negCount[nums[left] + 50] -= 1;\\n                }\\n\\n                left+= 1;\\n\\n            }\\n\\n            if(right - left == k - 1){\\n                int result = findXSmallest(negCount, x);\\n                ans[ansPtr] = result;\\n                ansPtr += 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n    public int findXSmallest(int[] negCount, int x){\\n        int count = 0;\\n\\n        for(int i = 0; i < negCount.length; i++){\\n\\n            count += negCount[i];\\n\\n            if(count >= x){\\n                return i - 50;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Counting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int[] ans = new int[nums.length - k + 1];\\n        int[] negCount = new int[50];\\n        int left = 0;\\n        int ansPtr = 0;\\n\\n        for(int right = 0; right < nums.length; right++){\\n\\n            if(nums[right] < 0){\\n                negCount[nums[right] + 50] += 1;\\n            }\\n\\n            if(right - left >= k){\\n\\n                if(nums[left] < 0){\\n                    negCount[nums[left] + 50] -= 1;\\n                }\\n\\n                left+= 1;\\n\\n            }\\n\\n            if(right - left == k - 1){\\n                int result = findXSmallest(negCount, x);\\n                ans[ansPtr] = result;\\n                ansPtr += 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n    public int findXSmallest(int[] negCount, int x){\\n        int count = 0;\\n\\n        for(int i = 0; i < negCount.length; i++){\\n\\n            count += negCount[i];\\n\\n            if(count >= x){\\n                return i - 50;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943657,
                "title": "beats-74-run-time-o-n",
                "content": "# Intuition\\nDefine a hash fuction for all -50 to -1 element and keep a tarck of the count. when window size got hit then start keeping track of count via prefix sum in for loop. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        hm = defaultdict(int)\\n        i = 0 \\n        out = []\\n\\n        for h in range(-50,0):\\n            hm[h] = 0 \\n        \\n        for j in range(len(nums)):\\n            if nums[j] < 0 :\\n                hm[nums[j]] += 1\\n\\n            if j-i+1 == k : \\n                count = 0 \\n                for m in range(-50,0):\\n                    count += hm[m]\\n                    if count >= x :\\n                        out.append(m)\\n                        break \\n                if count < x: \\n                    out.append(0)\\n                hm[nums[i]] -= 1\\n                i += 1\\n        \\n        return out\\n                    \\n\\n                \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        hm = defaultdict(int)\\n        i = 0 \\n        out = []\\n\\n        for h in range(-50,0):\\n            hm[h] = 0 \\n        \\n        for j in range(len(nums)):\\n            if nums[j] < 0 :\\n                hm[nums[j]] += 1\\n\\n            if j-i+1 == k : \\n                count = 0 \\n                for m in range(-50,0):\\n                    count += hm[m]\\n                    if count >= x :\\n                        out.append(m)\\n                        break \\n                if count < x: \\n                    out.append(0)\\n                hm[nums[i]] -= 1\\n                i += 1\\n        \\n        return out\\n                    \\n\\n                \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860893,
                "title": "c-beats-99-3-solution-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n*50)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int z) {\\n   \\n    vector<int>v(101,0);\\n     for(int i=0;i<k-1;i++)\\n     {\\n      \\n      v[nums[i]+50]++;\\n     }\\n     vector<int>ans;\\n     int l=0;\\n    for(int i=k-1;i<nums.size();i++)\\n    {\\n     v[nums[i]+50]++;\\n      int cnt=0;\\n      for(int j=0;j<=50;j++)\\n      { \\n        cnt+=v[j];\\n        if(cnt>=z){ans.push_back(j-50);\\n        break;\\n        }\\n\\n      }\\n      if(cnt<z)ans.push_back(0);\\n   v[nums[l]+50]--;\\n   \\n   \\n   l++;\\n\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int z) {\\n   \\n    vector<int>v(101,0);\\n     for(int i=0;i<k-1;i++)\\n     {\\n      \\n      v[nums[i]+50]++;\\n     }\\n     vector<int>ans;\\n     int l=0;\\n    for(int i=k-1;i<nums.size();i++)\\n    {\\n     v[nums[i]+50]++;\\n      int cnt=0;\\n      for(int j=0;j<=50;j++)\\n      { \\n        cnt+=v[j];\\n        if(cnt>=z){ans.push_back(j-50);\\n        break;\\n        }\\n\\n      }\\n      if(cnt<z)ans.push_back(0);\\n   v[nums[l]+50]--;\\n   \\n   \\n   l++;\\n\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859545,
                "title": "easy-c-solution-using-map",
                "content": "# Complexity\\n- Time complexity:\\n(n*k)\\n\\n- Space complexity:\\n- O(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n// [1,2,3,3,3] k = 2, x = 2;\\n// ans = [0, 0, 0]  devil\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n\\n        for(int i=0 ;i<k ;i++){\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n        }\\n        int temp = x, val = 0;\\n        for(auto pa:mp){\\n            temp -= pa.second;\\n            val = pa.first;\\n            if(temp<=0)\\n            break;\\n        }\\n        if(temp<=0)\\n        ans.push_back(val);\\n        else\\n        ans.push_back(0);\\n\\n        int start = 0;\\n        \\n        for(int i=k ;i<nums.size() ;i++){\\n            \\n            if(nums[start]<0){\\n                mp[nums[start]]--;\\n                if(mp[nums[start]] == 0)\\n                mp.erase(nums[start]);\\n            }\\n            start++;\\n\\n            if(nums[i]<0)\\n             mp[nums[i]]++;\\n            \\n            temp = x, val = 0;\\n            for(auto pa:mp){\\n                temp -= pa.second;\\n                val = pa.first;\\n                if(temp<=0)\\n                break;\\n            }\\n            if(temp<=0)\\n            ans.push_back(val);\\n            else\\n            ans.push_back(0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n// [1,2,3,3,3] k = 2, x = 2;\\n// ans = [0, 0, 0]  devil\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n\\n        for(int i=0 ;i<k ;i++){\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n        }\\n        int temp = x, val = 0;\\n        for(auto pa:mp){\\n            temp -= pa.second;\\n            val = pa.first;\\n            if(temp<=0)\\n            break;\\n        }\\n        if(temp<=0)\\n        ans.push_back(val);\\n        else\\n        ans.push_back(0);\\n\\n        int start = 0;\\n        \\n        for(int i=k ;i<nums.size() ;i++){\\n            \\n            if(nums[start]<0){\\n                mp[nums[start]]--;\\n                if(mp[nums[start]] == 0)\\n                mp.erase(nums[start]);\\n            }\\n            start++;\\n\\n            if(nums[i]<0)\\n             mp[nums[i]]++;\\n            \\n            temp = x, val = 0;\\n            for(auto pa:mp){\\n                temp -= pa.second;\\n                val = pa.first;\\n                if(temp<=0)\\n                break;\\n            }\\n            if(temp<=0)\\n            ans.push_back(val);\\n            else\\n            ans.push_back(0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837400,
                "title": "python3-2-methods",
                "content": "```\\nfrom sortedcontainers import SortedList \\n\\nclass Solution:\\n    def method1(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1) # O(n) initialization\\n        nums.append(0)\\n        sliding_window = SortedList(nums[:k]) # O(nlog(n)) initialization\\n        for start in range(len(ans)): # O(n) iterations\\n            ans[start] = min(sliding_window[x - 1], 0)\\n            sliding_window.remove(nums[start]) # O(log(n)) operation\\n            sliding_window.add(nums[start + k]) # O(log(n)) operation\\n        return ans\\n    \\n    def method2(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1)\\n        \\n        counts = [0] * 101 # O(1) initialization\\n        # init snapshot of counts for first subarray\\n        for val in nums[:k]: # O(n) initialization\\n            counts[val] += 1\\n\\n        # pad nums to avoid index error at end of iteration\\n        nums += [0]\\n        for subarray_start in range(len(ans)): # O(n) iterations\\n            curr_count = 0\\n            for val in range(-50,0): # O(1) iterations\\n                curr_count += counts[val]\\n                if curr_count >= x:\\n                    ans[subarray_start] = val\\n                    break\\n            # update snapshot of counts for next subarray\\n            counts[nums[subarray_start]] -= 1\\n            counts[nums[subarray_start + k]] += 1\\n        return ans\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        return self.method2(nums, k, x)\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList \\n\\nclass Solution:\\n    def method1(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1) # O(n) initialization\\n        nums.append(0)\\n        sliding_window = SortedList(nums[:k]) # O(nlog(n)) initialization\\n        for start in range(len(ans)): # O(n) iterations\\n            ans[start] = min(sliding_window[x - 1], 0)\\n            sliding_window.remove(nums[start]) # O(log(n)) operation\\n            sliding_window.add(nums[start + k]) # O(log(n)) operation\\n        return ans\\n    \\n    def method2(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1)\\n        \\n        counts = [0] * 101 # O(1) initialization\\n        # init snapshot of counts for first subarray\\n        for val in nums[:k]: # O(n) initialization\\n            counts[val] += 1\\n\\n        # pad nums to avoid index error at end of iteration\\n        nums += [0]\\n        for subarray_start in range(len(ans)): # O(n) iterations\\n            curr_count = 0\\n            for val in range(-50,0): # O(1) iterations\\n                curr_count += counts[val]\\n                if curr_count >= x:\\n                    ans[subarray_start] = val\\n                    break\\n            # update snapshot of counts for next subarray\\n            counts[nums[subarray_start]] -= 1\\n            counts[nums[subarray_start + k]] += 1\\n        return ans\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        return self.method2(nums, k, x)\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793367,
                "title": "golang-solution-without-sorting",
                "content": "# Code\\n```go\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n\\tcounter := make(map[int]int, 101)\\n\\tfor i := 0; i < k-1; i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t}\\n\\tbeauty := make([]int, 0, len(nums)-k+1)\\n\\tfor i := k-1; i < len(nums); i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t\\tif i - k >= 0 {\\n\\t\\t\\tcounter[nums[i-k]]--\\n\\t\\t}\\n\\t\\tnegative := 0\\n\\t\\tfor i := -50; i <= 50; i++ {\\n\\t\\t\\tif i >= 0 {\\n\\t\\t\\t\\tbeauty = append(beauty, 0)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tnegative += counter[i]\\n\\t\\t\\tif negative >= x {\\n\\t\\t\\t\\tbeauty = append(beauty, i)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn beauty\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n\\tcounter := make(map[int]int, 101)\\n\\tfor i := 0; i < k-1; i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t}\\n\\tbeauty := make([]int, 0, len(nums)-k+1)\\n\\tfor i := k-1; i < len(nums); i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t\\tif i - k >= 0 {\\n\\t\\t\\tcounter[nums[i-k]]--\\n\\t\\t}\\n\\t\\tnegative := 0\\n\\t\\tfor i := -50; i <= 50; i++ {\\n\\t\\t\\tif i >= 0 {\\n\\t\\t\\t\\tbeauty = append(beauty, 0)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tnegative += counter[i]\\n\\t\\t\\tif negative >= x {\\n\\t\\t\\t\\tbeauty = append(beauty, i)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn beauty\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781954,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int i=0,j=0;\\n        multiset<int> st;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] < 0)\\n            {\\n               st.insert(nums[i]);\\n            }\\n            if(i-j+1==k)\\n            {\\n                if(st.size() < x)\\n                { \\n                  ans.push_back(0);\\n                }else\\n                {\\n                    ans.push_back(*next(st.begin(),x-1));\\n                }\\n                auto it=st.find(nums[j]);\\n                if(nums[j] < 0)\\n                {\\n                    st.erase(it);\\n                }\\n                j++;\\n                \\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int i=0,j=0;\\n        multiset<int> st;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] < 0)\\n            {\\n               st.insert(nums[i]);\\n            }\\n            if(i-j+1==k)\\n            {\\n                if(st.size() < x)\\n                { \\n                  ans.push_back(0);\\n                }else\\n                {\\n                    ans.push_back(*next(st.begin(),x-1));\\n                }\\n                auto it=st.find(nums[j]);\\n                if(nums[j] < 0)\\n                {\\n                    st.erase(it);\\n                }\\n                j++;\\n                \\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771657,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> s;\\n        vector<int> v;\\n        for (int i = 0; i < k; i++) {\\n            s[nums[i]]++;\\n        }\\n        \\n        int i = 0, j = k - 1;\\n        while (j < nums.size()) {\\n            int x2 = x;\\n            for(auto x1:s){\\n                if(x1.first < 0){\\n                    if(x1.second>=x2){\\n                        v.push_back(x1.first);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }else{\\n                    if(x1.second>=x2){\\n                        v.push_back(0);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }\\n            }\\n            //if(v.size() <= x)v.push_back(0);\\n            if(s[nums[i]]==1){\\n                s.erase(nums[i]);\\n            }else{\\n                s[nums[i]]--;\\n            }\\n            i++;\\n            j++;\\n            if (j < nums.size()) {\\n                s[nums[j]]++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> s;\\n        vector<int> v;\\n        for (int i = 0; i < k; i++) {\\n            s[nums[i]]++;\\n        }\\n        \\n        int i = 0, j = k - 1;\\n        while (j < nums.size()) {\\n            int x2 = x;\\n            for(auto x1:s){\\n                if(x1.first < 0){\\n                    if(x1.second>=x2){\\n                        v.push_back(x1.first);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }else{\\n                    if(x1.second>=x2){\\n                        v.push_back(0);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }\\n            }\\n            //if(v.size() <= x)v.push_back(0);\\n            if(s[nums[i]]==1){\\n                s.erase(nums[i]);\\n            }else{\\n                s[nums[i]]--;\\n            }\\n            i++;\\n            j++;\\n            if (j < nums.size()) {\\n                s[nums[j]]++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770589,
                "title": "easy-solution-using-map-c-not-using-any-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n            int i=0, j=0;\\n        map<int, int> mp; // it store the val key in sorted order\\n            vector<int> ans; // it is use for store ans\\n          while(j<nums.size()){\\n                mp[nums[j]]++;\\n              if(j-i+1<k){  // checking window size if size is less then k\\n                  j++;\\n              }else{  // if window size is equal to k\\n                   int mini=INT_MAX;  // it will store the xth min\\n                  int t=0;  \\n                  for(auto k:mp){\\n                      t+=k.second; // it is storing size\\n                      if(t>=x){ // here t is greter then or equal to x in this time  key is xth val \\n                          mini=k.first;\\n                          break;\\n                      }\\n                  }\\n                  if(mini>0){ // also if xth val is greter then 0 then  we have to made this 0;\\n                      mini=0;\\n                  }\\n                  ans.push_back(mini);\\n                  mp[nums[i]]--; \\n                  if(mp[nums[i]]==0){\\n                      mp.erase(nums[i]);\\n                  }\\n                  i++;\\n                  j++;\\n              }\\n          }\\n          \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n            int i=0, j=0;\\n        map<int, int> mp; // it store the val key in sorted order\\n            vector<int> ans; // it is use for store ans\\n          while(j<nums.size()){\\n                mp[nums[j]]++;\\n              if(j-i+1<k){  // checking window size if size is less then k\\n                  j++;\\n              }else{  // if window size is equal to k\\n                   int mini=INT_MAX;  // it will store the xth min\\n                  int t=0;  \\n                  for(auto k:mp){\\n                      t+=k.second; // it is storing size\\n                      if(t>=x){ // here t is greter then or equal to x in this time  key is xth val \\n                          mini=k.first;\\n                          break;\\n                      }\\n                  }\\n                  if(mini>0){ // also if xth val is greter then 0 then  we have to made this 0;\\n                      mini=0;\\n                  }\\n                  ans.push_back(mini);\\n                  mp[nums[i]]--; \\n                  if(mp[nums[i]]==0){\\n                      mp.erase(nums[i]);\\n                  }\\n                  i++;\\n                  j++;\\n              }\\n          }\\n          \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750844,
                "title": "easy-c-code-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        int n=v.size();\\n        vector<int>count(50,0),ans(n-k+1,0);\\n        for(int i=0;i<k;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n        }\\n        int u=0;\\n        for(int j=0;j<50;j++){\\n            if(u+count[j]<x) u+=count[j];\\n            else{\\n                ans[0]=j-50;\\n                break;\\n            }\\n        }\\n\\n        for(int i=k;i<n;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n            if(i-k>=0 and v[i-k]<0) count[v[i-k]+50]--;\\n            int u=0;\\n            for(int j=0;j<50;j++){\\n                if(u+count[j]<x) u+=count[j];\\n                else{\\n                    ans[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        int n=v.size();\\n        vector<int>count(50,0),ans(n-k+1,0);\\n        for(int i=0;i<k;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n        }\\n        int u=0;\\n        for(int j=0;j<50;j++){\\n            if(u+count[j]<x) u+=count[j];\\n            else{\\n                ans[0]=j-50;\\n                break;\\n            }\\n        }\\n\\n        for(int i=k;i<n;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n            if(i-k>=0 and v[i-k]<0) count[v[i-k]+50]--;\\n            int u=0;\\n            for(int j=0;j<50;j++){\\n                if(u+count[j]<x) u+=count[j];\\n                else{\\n                    ans[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747861,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        negatives = [0]*50\\n        final = []\\n\\n        for i in range(k):\\n            if nums[i]<0:\\n                negatives[nums[i]] += 1\\n\\n        for i in range(k-1, len(nums)):\\n            if i>=k:\\n                if nums[i-k]<0: negatives[nums[i-k]] -= 1\\n                if nums[i]<0: negatives[nums[i]] += 1\\n\\n            remaining = x\\n            for i in range(len(negatives)):\\n                remaining -= negatives[i]\\n                if remaining<=0:\\n                    final.append(-50+i)\\n                    break\\n            \\n            if remaining>0:\\n                final.append(0)\\n        \\n        return final\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        negatives = [0]*50\\n        final = []\\n\\n        for i in range(k):\\n            if nums[i]<0:\\n                negatives[nums[i]] += 1\\n\\n        for i in range(k-1, len(nums)):\\n            if i>=k:\\n                if nums[i-k]<0: negatives[nums[i-k]] -= 1\\n                if nums[i]<0: negatives[nums[i]] += 1\\n\\n            remaining = x\\n            for i in range(len(negatives)):\\n                remaining -= negatives[i]\\n                if remaining<=0:\\n                    final.append(-50+i)\\n                    break\\n            \\n            if remaining>0:\\n                final.append(0)\\n        \\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683403,
                "title": "striver-sliding-window-approach-easy-to-understand-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        //approaches\\n        //1. naive -- O(n^3nlogn)\\n        //2.using sliding window :\\n        // use freq array (-50 to 50)\\n        //update the frequencies for window size \\n\\n        vector<int> freq(101, 0), ans;\\n        int i=0, j=0, n = nums.size();\\n\\n        while(j<n){\\n            // 1. find out the calculations\\n            freq[nums[j]+50]++;\\n            \\n            if(j-i+1 < k) j++;\\n\\n            else if(j-i+1 == k){\\n                //2. ans <- calculations\\n                int cnt = 0, val = 0;\\n                while(cnt!=x){\\n                    for(int i=0; i<101; i++){\\n                        if(freq[i]!=0 && cnt+freq[i] > x){\\n                            cnt = x;\\n                        }\\n                        else if(freq[i]!=0 && cnt+freq[i] <= x){\\n                                cnt = cnt + freq[i];\\n                        }\\n\\n                        if(cnt==x){\\n                            val = i-50;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(val < 0) ans.push_back(val);\\n                else ans.push_back(0);\\n\\n                //3. sliding the window\\n                freq[nums[i]+50]--;\\n                i++, j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        //approaches\\n        //1. naive -- O(n^3nlogn)\\n        //2.using sliding window :\\n        // use freq array (-50 to 50)\\n        //update the frequencies for window size \\n\\n        vector<int> freq(101, 0), ans;\\n        int i=0, j=0, n = nums.size();\\n\\n        while(j<n){\\n            // 1. find out the calculations\\n            freq[nums[j]+50]++;\\n            \\n            if(j-i+1 < k) j++;\\n\\n            else if(j-i+1 == k){\\n                //2. ans <- calculations\\n                int cnt = 0, val = 0;\\n                while(cnt!=x){\\n                    for(int i=0; i<101; i++){\\n                        if(freq[i]!=0 && cnt+freq[i] > x){\\n                            cnt = x;\\n                        }\\n                        else if(freq[i]!=0 && cnt+freq[i] <= x){\\n                                cnt = cnt + freq[i];\\n                        }\\n\\n                        if(cnt==x){\\n                            val = i-50;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(val < 0) ans.push_back(val);\\n                else ans.push_back(0);\\n\\n                //3. sliding the window\\n                freq[nums[i]+50]--;\\n                i++, j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673489,
                "title": "sliding-window-map-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mpp;\\n        vector<int> ans;\\n        int left = 0; int right = k - 1;\\n        for(int i=0;i<k-1;i++) mpp[nums[i]]++;\\n        while( right < nums.size()){\\n            mpp[nums[right]]++;\\n            int xtracker=0;\\n            for(auto it: mpp){\\n               xtracker += it.second;\\n               if(xtracker>=x){\\n                   if(it.first > 0) ans.push_back(0);\\n                   else ans.push_back(it.first);\\n                   break;\\n               }\\n            }\\n            mpp[nums[left]]--;\\n            if(mpp[nums[left]]<=0) mpp.erase(nums[left]);\\n            left++; right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mpp;\\n        vector<int> ans;\\n        int left = 0; int right = k - 1;\\n        for(int i=0;i<k-1;i++) mpp[nums[i]]++;\\n        while( right < nums.size()){\\n            mpp[nums[right]]++;\\n            int xtracker=0;\\n            for(auto it: mpp){\\n               xtracker += it.second;\\n               if(xtracker>=x){\\n                   if(it.first > 0) ans.push_back(0);\\n                   else ans.push_back(it.first);\\n                   break;\\n               }\\n            }\\n            mpp[nums[left]]--;\\n            if(mpp[nums[left]]<=0) mpp.erase(nums[left]);\\n            left++; right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644670,
                "title": "golang-sliding-window-counting-sort",
                "content": "Use sliding window and counting sort to get the xth smallest negative number.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1) since the we only need to store 101 elements\\n\\n# Code\\n```\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n  // nums[i] is [-50...50] so we can easily do counting sort\\n  // Using an array with an offset so we don\\'t have to use a map\\n  var counts [101]int\\n  left := 0\\n  offset := 50\\n  var res []int\\n  for right := 0; right < len(nums); right++ {\\n    counts[nums[right]+offset]++\\n    if right - left + 1 == k { // subarray with size k is found\\n      // Let\\'s find if ser have xth smallest negative integer\\n      var pos int\\n      var elem int\\n      for i := 0; i < offset; i++ { // only iterate the negative numbers\\n        pos += counts[i]\\n        if pos >= x {\\n          elem = i-offset\\n          break\\n        }\\n      }\\n      // If we can\\'t find a negative element, elem will be 0 which is what we want\\n      res = append(res, elem)\\n      counts[nums[left]+offset]--\\n      left++\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "Sliding Window",
                    "Counting",
                    "Counting Sort"
                ],
                "code": "```\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n  // nums[i] is [-50...50] so we can easily do counting sort\\n  // Using an array with an offset so we don\\'t have to use a map\\n  var counts [101]int\\n  left := 0\\n  offset := 50\\n  var res []int\\n  for right := 0; right < len(nums); right++ {\\n    counts[nums[right]+offset]++\\n    if right - left + 1 == k { // subarray with size k is found\\n      // Let\\'s find if ser have xth smallest negative integer\\n      var pos int\\n      var elem int\\n      for i := 0; i < offset; i++ { // only iterate the negative numbers\\n        pos += counts[i]\\n        if pos >= x {\\n          elem = i-offset\\n          break\\n        }\\n      }\\n      // If we can\\'t find a negative element, elem will be 0 which is what we want\\n      res = append(res, elem)\\n      counts[nums[left]+offset]--\\n      left++\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642345,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr = new int[101];\\n        int j=0;\\n        int[] ans = new int[nums.length-k+1];\\n        int ind=0;\\n        for(int i=0;i<nums.length;i++){\\n            arr[nums[i]+50]++;\\n            if(i<k-1){\\n                continue;\\n            }\\n\\n// this if is to optimize the code further, code will run without this if also. \\n            if(ind >0 && ans[ind-1]<nums[i] && ans[ind-1] <nums[j-1]){\\n                arr[nums[j++]+50]--;\\n                ans[ind] = ans[ind-1];\\n                ind++;\\n                continue;\\n            }\\n            int count =0;\\n            int si=-1;\\n            while(count<x){\\n                si++;\\n                if(arr[si]!=0){\\n                    count +=arr[si];\\n                }\\n\\n            }\\n            arr[nums[j++]+50]--;\\n            ans[ind++] = (si-50<1)?si-50:0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr = new int[101];\\n        int j=0;\\n        int[] ans = new int[nums.length-k+1];\\n        int ind=0;\\n        for(int i=0;i<nums.length;i++){\\n            arr[nums[i]+50]++;\\n            if(i<k-1){\\n                continue;\\n            }\\n\\n// this if is to optimize the code further, code will run without this if also. \\n            if(ind >0 && ans[ind-1]<nums[i] && ans[ind-1] <nums[j-1]){\\n                arr[nums[j++]+50]--;\\n                ans[ind] = ans[ind-1];\\n                ind++;\\n                continue;\\n            }\\n            int count =0;\\n            int si=-1;\\n            while(count<x){\\n                si++;\\n                if(arr[si]!=0){\\n                    count +=arr[si];\\n                }\\n\\n            }\\n            arr[nums[j++]+50]--;\\n            ans[ind++] = (si-50<1)?si-50:0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592646,
                "title": "simple-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr= new int[101];\\n        int[] ans=new int[nums.length-k+1];\\n        int l=0;\\n        for(int i=0;i<k;i++){\\n            arr[nums[i]+50]+=1;   \\n        }\\n        int n=x;\\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n             continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                 if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        int j=k;\\n        int s=0;\\n        while(j<nums.length){\\n            \\n            arr[nums[s++]+50]-=1;\\n            arr[nums[j++]+50]+=1;\\n           \\n            \\n            n=x;\\n            \\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n            continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr= new int[101];\\n        int[] ans=new int[nums.length-k+1];\\n        int l=0;\\n        for(int i=0;i<k;i++){\\n            arr[nums[i]+50]+=1;   \\n        }\\n        int n=x;\\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n             continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                 if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        int j=k;\\n        int s=0;\\n        while(j<nums.length){\\n            \\n            arr[nums[s++]+50]-=1;\\n            arr[nums[j++]+50]+=1;\\n           \\n            \\n            n=x;\\n            \\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n            continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578713,
                "title": "c-ac-using-maxheap-and-minheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n         vector<int>ans;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>maxHeap;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minHeap;\\n        for(int i=0;i<k;i++)\\n        {\\n            \\n                if(maxHeap.size()<x)\\n                maxHeap.push({nums[i],i});\\n                else\\n                {\\n                    if(maxHeap.top().first>nums[i])\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                        maxHeap.push({nums[i],i});\\n                    }\\n                    else minHeap.push({nums[i],i});\\n                }\\n\\n        }\\n        if(maxHeap.top().first>=0)\\n        ans.push_back(0);\\n        else\\n        {\\n            ans.push_back(maxHeap.top().first);\\n        }\\n   //     cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n        int i=1,j=k,size=x;\\n        while(j<n)\\n        {\\n            // cout<<\"i=\"<<i<<\" j=\"<<j<<\\'\\\\n\\';\\n            // cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n            if(nums[i-1]<=maxHeap.top().first)\\n            {\\n                 //maxHeap.push({nums[j],j});\\n                 size++;\\n            }\\n                   if(nums[j]<maxHeap.top().first)\\n                {\\n                    maxHeap.push({nums[j],j});\\n                    if(maxHeap.size()>size)\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    minHeap.push({nums[j],j});\\n                }\\n            while(!maxHeap.empty()&&maxHeap.top().second<i)\\n            {\\n                maxHeap.pop();\\n                size--;\\n            }\\n            while(!minHeap.empty()&&minHeap.top().second<i)\\n            {\\n                minHeap.pop();\\n            }\\n            if(maxHeap.size()<size)\\n            {\\n                maxHeap.push(minHeap.top());\\n                minHeap.pop();\\n            }\\n             if(maxHeap.top().first>=0)\\n             ans.push_back(0);\\n            else\\n            {\\n            ans.push_back(maxHeap.top().first);\\n            }\\n            i++;\\n            j++;\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n         vector<int>ans;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>maxHeap;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minHeap;\\n        for(int i=0;i<k;i++)\\n        {\\n            \\n                if(maxHeap.size()<x)\\n                maxHeap.push({nums[i],i});\\n                else\\n                {\\n                    if(maxHeap.top().first>nums[i])\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                        maxHeap.push({nums[i],i});\\n                    }\\n                    else minHeap.push({nums[i],i});\\n                }\\n\\n        }\\n        if(maxHeap.top().first>=0)\\n        ans.push_back(0);\\n        else\\n        {\\n            ans.push_back(maxHeap.top().first);\\n        }\\n   //     cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n        int i=1,j=k,size=x;\\n        while(j<n)\\n        {\\n            // cout<<\"i=\"<<i<<\" j=\"<<j<<\\'\\\\n\\';\\n            // cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n            if(nums[i-1]<=maxHeap.top().first)\\n            {\\n                 //maxHeap.push({nums[j],j});\\n                 size++;\\n            }\\n                   if(nums[j]<maxHeap.top().first)\\n                {\\n                    maxHeap.push({nums[j],j});\\n                    if(maxHeap.size()>size)\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    minHeap.push({nums[j],j});\\n                }\\n            while(!maxHeap.empty()&&maxHeap.top().second<i)\\n            {\\n                maxHeap.pop();\\n                size--;\\n            }\\n            while(!minHeap.empty()&&minHeap.top().second<i)\\n            {\\n                minHeap.pop();\\n            }\\n            if(maxHeap.size()<size)\\n            {\\n                maxHeap.push(minHeap.top());\\n                minHeap.pop();\\n            }\\n             if(maxHeap.top().first>=0)\\n             ans.push_back(0);\\n            else\\n            {\\n            ans.push_back(maxHeap.top().first);\\n            }\\n            i++;\\n            j++;\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3554007,
                "title": "java-frequency-counter-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n\\tpublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\t\\tint[] freqCounter = new int[50];\\n\\t\\tint index = 0;\\n\\t\\tint[] results = new int[nums.length - k + 1];\\n\\t\\t\\n\\t\\tfor(int i = 0; i < k; i++) {\\n\\t\\t\\tif(nums[i] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[i] + 50]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\n\\t\\t\\n\\t\\twhile (index < results.length) {\\n\\t\\t\\tif(nums[index-1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index - 1] + 50]--;\\n\\t\\t\\t}\\n\\t\\t\\tif(nums[index + k -1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index + k -1] + 50]++;\\n\\t\\t\\t}\\n\\t\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn results;\\n\\t}\\n\\t\\n\\tprivate int getXthSmallest(int[] freqCounter, int x) {\\n\\t\\tint count = 0;\\n\\t\\tfor(int i = 0; i < 50; i++) {\\n\\t\\t\\tcount += freqCounter[i];\\n\\t\\t\\tif(count >= x) {\\n\\t\\t\\t\\treturn i - 50;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n\\tpublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\t\\tint[] freqCounter = new int[50];\\n\\t\\tint index = 0;\\n\\t\\tint[] results = new int[nums.length - k + 1];\\n\\t\\t\\n\\t\\tfor(int i = 0; i < k; i++) {\\n\\t\\t\\tif(nums[i] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[i] + 50]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\n\\t\\t\\n\\t\\twhile (index < results.length) {\\n\\t\\t\\tif(nums[index-1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index - 1] + 50]--;\\n\\t\\t\\t}\\n\\t\\t\\tif(nums[index + k -1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index + k -1] + 50]++;\\n\\t\\t\\t}\\n\\t\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn results;\\n\\t}\\n\\t\\n\\tprivate int getXthSmallest(int[] freqCounter, int x) {\\n\\t\\tint count = 0;\\n\\t\\tfor(int i = 0; i < 50; i++) {\\n\\t\\t\\tcount += freqCounter[i];\\n\\t\\t\\tif(count >= x) {\\n\\t\\t\\t\\treturn i - 50;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539749,
                "title": "slow-python-sliding-window",
                "content": "# Intuition\\nThe numbers are in the range -50, 50.\\nWe can keep track of the frequency of numbers in a sliding window of length k.\\nThen we can loop over values (in increasing order) to see which is the x-th smallest element. Since the possible values are in [-50, 50], we can just loop over the whole range.\\n\\n# Approach\\nCount frequency for the first k elements. Then, for the remaining elements, add one by one and update the frequency. \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ -- ~100x n, but still O(n). \\n\\n- Space complexity:\\n$$O(1)$$ - we keep frequency for unique elements -- this can be at most 101 values.\\n\\n# Improvements\\nCan replace the `defaultdict` with an `OrderedDict` or use an ordered set to keep track of elements present in the range.\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        from collections import defaultdict\\n        counts = defaultdict(int)\\n        res = []\\n\\n        for i in range(k):\\n            counts[nums[i]] += 1\\n        \\n        crt_cnt = 0\\n        \\n        for j in range(-50, 51):\\n            if counts[j] > 0:\\n                if crt_cnt < x:\\n                    crt_cnt += counts[j]\\n                if crt_cnt >= x:\\n                    res.append(min(0, j))\\n                    break\\n        \\n        for i in range(k, len(nums)):\\n            counts[nums[i - k]] -= 1\\n            counts[nums[i]] += 1\\n            crt_cnt = 0\\n            for j in range(-50, 51):\\n                if counts[j] > 0:\\n                    if crt_cnt < x:\\n                        crt_cnt += counts[j]\\n                    if crt_cnt >= x:\\n                        res.append(min(0, j))\\n                        break\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        from collections import defaultdict\\n        counts = defaultdict(int)\\n        res = []\\n\\n        for i in range(k):\\n            counts[nums[i]] += 1\\n        \\n        crt_cnt = 0\\n        \\n        for j in range(-50, 51):\\n            if counts[j] > 0:\\n                if crt_cnt < x:\\n                    crt_cnt += counts[j]\\n                if crt_cnt >= x:\\n                    res.append(min(0, j))\\n                    break\\n        \\n        for i in range(k, len(nums)):\\n            counts[nums[i - k]] -= 1\\n            counts[nums[i]] += 1\\n            crt_cnt = 0\\n            for j in range(-50, 51):\\n                if counts[j] > 0:\\n                    if crt_cnt < x:\\n                        crt_cnt += counts[j]\\n                    if crt_cnt >= x:\\n                        res.append(min(0, j))\\n                        break\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538695,
                "title": "java-treemap-slow-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < k; i++) {\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n        }\\n        int count = 0, c = 0;\\n        int[] res = new int[nums.length - k + 1];\\n        for (int key : map.keySet()) {\\n            count += map.get(key);\\n            if (count >= x) {\\n                res[c] = Math.min(key, 0);\\n                break;\\n            }\\n        }\\n        for (int i = k; i < nums.length; i++) {\\n            int kk = map.get(nums[c]);\\n            if (kk == 0) map.remove(nums[c]);\\n            else map.put(nums[c], kk - 1);\\n            c++;\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n            count = 0;\\n            for (int key : map.keySet()) {\\n                count += map.get(key);\\n                if (count >= x) {\\n                    res[c] = Math.min(key, 0);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < k; i++) {\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n        }\\n        int count = 0, c = 0;\\n        int[] res = new int[nums.length - k + 1];\\n        for (int key : map.keySet()) {\\n            count += map.get(key);\\n            if (count >= x) {\\n                res[c] = Math.min(key, 0);\\n                break;\\n            }\\n        }\\n        for (int i = k; i < nums.length; i++) {\\n            int kk = map.get(nums[c]);\\n            if (kk == 0) map.remove(nums[c]);\\n            else map.put(nums[c], kk - 1);\\n            c++;\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n            count = 0;\\n            for (int key : map.keySet()) {\\n                count += map.get(key);\\n                if (count >= x) {\\n                    res[c] = Math.min(key, 0);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535654,
                "title": "java-c-python-just-a-solution-explained",
                "content": "# TL;DR\\n``` java []\\nclass Solution {\\n    private static final int MAX_VAL = 50;\\n    private static final int MIN_VAL = -50;\\n    private static final int OFFSET = -MIN_VAL;\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        var res = new int[nums.length - k + 1];\\n        var counts = new int[MAX_VAL - MIN_VAL + 2];\\n\\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n        }\\n\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = Math.max(max, next);\\n            min = Math.min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = Math.min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        const int MAX_VAL = 50;\\n        const int MIN_VAL = -50;\\n        const int OFFSET = -MIN_VAL;\\n        int n = nums.size();\\n        vector<int> res(n - k + 1);\\n        vector<int> counts(MAX_VAL - MIN_VAL + 2, 0);\\n        \\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = std::min(min, nums[i]);\\n            max = std::max(max, nums[i]);\\n        }\\n        \\n        for (int i = 0; i < n - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = std::max(max, next);\\n            min = std::min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = std::min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        MAX_VAL = 50\\n        MIN_VAL = -50\\n        OFFSET = -MIN_VAL\\n        n = len(nums)\\n        res = [0] * (n - k + 1)\\n        counts = [0] * (MAX_VAL - MIN_VAL + 2)\\n        \\n        min_val = MAX_VAL\\n        max_val = MIN_VAL\\n        for i in range(k - 1):\\n            counts[nums[i] + OFFSET] += 1\\n            min_val = min(min_val, nums[i])\\n            max_val = max(max_val, nums[i])\\n        \\n        for i in range(n - k + 1):\\n            next_val = nums[i + k - 1]\\n            counts[next_val + OFFSET] += 1\\n            max_val = max(max_val, next_val)\\n            min_val = min(min_val, next_val)\\n            xMin = 0\\n            count = 0\\n            for j in range(min_val - MIN_VAL, max_val + OFFSET + 1):\\n                count += counts[j]\\n                if count >= x:\\n                    xMin = j - OFFSET\\n                    break\\n            res[i] = min(xMin, 0)\\n            counts[nums[i] + OFFSET] -= 1\\n            if counts[nums[i] + OFFSET] == 0:\\n                if nums[i] == max_val:\\n                    max_val = MAX_VAL\\n                if nums[i] == min_val:\\n                    min_val = MIN_VAL\\n        return res\\n```\\n---\\n#### \\u26A0\\uFE0F Please upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n# Intuition\\n\\nThe problem asks us to find the beauty of each subarray of size k in the input array. The beauty of a subarray is defined as the xth smallest negative integer in the subarray if there are at least x negative integers, or 0 otherwise. \\n\\nA straightforward approach to this problem would be to sort each subarray and select the xth smallest negative integer. However, this approach is not efficient due to the repeated sorting operation, which would result in a time complexity of O(n*k*log(k)), where n is the length of the array and k is the size of the subarray.\\n\\nTo optimize this, we can use a sliding window approach and maintain a frequency count of the integers in the current subarray. We also keep track of the minimum and maximum values in the current subarray. \\n\\n# Approach\\n\\nThe optimized approach is to use a sliding window of size `k`. As we slide the window, we keep track of the frequency of numbers in the current window using a frequency array `counts`. For each new window, we add the new number to the frequency array and remove the number that is no longer in the window.\\n\\nWe keep track of the minimum and maximum numbers in the current window. This helps in searching for the xth smallest negative number in the frequency array. \\n\\nAs we slide the window, we keep adding the xth smallest negative number in the window to our result array `res`.\\n\\n# Complexity Analysis\\n\\n- Time complexity: The time complexity of this approach is $$O(n)$$, where $$n$$ is the number of elements in the array. We iterate over the array once, and for each iteration, we perform constant time operations such as updating the frequency array, searching for the xth smallest negative number, and updating the result array.\\n\\n- Space complexity: The space complexity is $$O(n)$$ for the `res` array, and $$O(1)$$ for the `counts` array as it has a fixed size based on the problem constraints (range of the numbers in the array). Therefore, the total space complexity is $$O(n)$$.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "``` java []\\nclass Solution {\\n    private static final int MAX_VAL = 50;\\n    private static final int MIN_VAL = -50;\\n    private static final int OFFSET = -MIN_VAL;\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        var res = new int[nums.length - k + 1];\\n        var counts = new int[MAX_VAL - MIN_VAL + 2];\\n\\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n        }\\n\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = Math.max(max, next);\\n            min = Math.min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = Math.min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        const int MAX_VAL = 50;\\n        const int MIN_VAL = -50;\\n        const int OFFSET = -MIN_VAL;\\n        int n = nums.size();\\n        vector<int> res(n - k + 1);\\n        vector<int> counts(MAX_VAL - MIN_VAL + 2, 0);\\n        \\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = std::min(min, nums[i]);\\n            max = std::max(max, nums[i]);\\n        }\\n        \\n        for (int i = 0; i < n - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = std::max(max, next);\\n            min = std::min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = std::min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        MAX_VAL = 50\\n        MIN_VAL = -50\\n        OFFSET = -MIN_VAL\\n        n = len(nums)\\n        res = [0] * (n - k + 1)\\n        counts = [0] * (MAX_VAL - MIN_VAL + 2)\\n        \\n        min_val = MAX_VAL\\n        max_val = MIN_VAL\\n        for i in range(k - 1):\\n            counts[nums[i] + OFFSET] += 1\\n            min_val = min(min_val, nums[i])\\n            max_val = max(max_val, nums[i])\\n        \\n        for i in range(n - k + 1):\\n            next_val = nums[i + k - 1]\\n            counts[next_val + OFFSET] += 1\\n            max_val = max(max_val, next_val)\\n            min_val = min(min_val, next_val)\\n            xMin = 0\\n            count = 0\\n            for j in range(min_val - MIN_VAL, max_val + OFFSET + 1):\\n                count += counts[j]\\n                if count >= x:\\n                    xMin = j - OFFSET\\n                    break\\n            res[i] = min(xMin, 0)\\n            counts[nums[i] + OFFSET] -= 1\\n            if counts[nums[i] + OFFSET] == 0:\\n                if nums[i] == max_val:\\n                    max_val = MAX_VAL\\n                if nums[i] == min_val:\\n                    min_val = MIN_VAL\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517791,
                "title": "python-counting-sort-o-n-50",
                "content": "As the value range is only `[-50, 50]`, or to be more specific actual range that we work with only `[-50, -1]` we can use instead of `nlogn` sorting `counting sort` with `O(50)`.\\n\\nInstead of counting every time `k-size window` we can use `sliding window of fixed size k`.\\n\\n2641ms ~99.4%\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        freq = [0] * 51\\n        neg_nums_count = 0\\n        start = 0\\n        for end in range(len(nums)):\\n            if nums[end] < 0:\\n                neg_nums_count += 1\\n                freq[nums[end]] += 1\\n\\n            if end >= k - 1:\\n                pos = 0\\n                current = x\\n                if x > neg_nums_count:\\n                    pos = 51\\n                else:\\n                    while freq[pos] < current:\\n                        current -= freq[pos]\\n                        pos += 1\\n                res.append(pos - 51)\\n\\n                if nums[start] < 0:\\n                    neg_nums_count -= 1\\n                    freq[nums[start]] -= 1\\n                start += 1\\n        \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        freq = [0] * 51\\n        neg_nums_count = 0\\n        start = 0\\n        for end in range(len(nums)):\\n            if nums[end] < 0:\\n                neg_nums_count += 1\\n                freq[nums[end]] += 1\\n\\n            if end >= k - 1:\\n                pos = 0\\n                current = x\\n                if x > neg_nums_count:\\n                    pos = 51\\n                else:\\n                    while freq[pos] < current:\\n                        current -= freq[pos]\\n                        pos += 1\\n                res.append(pos - 51)\\n\\n                if nums[start] < 0:\\n                    neg_nums_count -= 1\\n                    freq[nums[start]] -= 1\\n                start += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506204,
                "title": "easy-cpp-solution-time-complexity-explained-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->the value for nums are given from -50 to 50 think upon this and write a code for their count\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The function aims to find subarrays of length k in nums that have a \"beauty\" value of at least x. A subarray\\'s beauty is defined as the absolute difference between its maximum and minimum elements.\\n\\nThe implementation uses a sliding window approach to iterate over all subarrays of length k in nums. At each iteration, it maintains a map mp that tracks the frequency of each element in the current subarray.\\n\\nThe while loop iterates from j=0 to j=nums.size()-1. At each iteration, if the subarray length is less than k, the frequency of the element at index j is incremented in the map mp, and j is incremented. If the subarray length is equal to k, the function checks the beauty value of the current subarray by iterating over all elements in the map mp and calculating their contribution to the beauty value. The iteration continues until the sum of the frequencies of the elements encountered so far is greater than or equal to x. If the beauty value of the subarray is greater than or equal to x, the minimum element in the subarray is added to the vector v.\\n\\nAfter checking the beauty value of the subarray, the implementation removes the first element of the current subarray by decrementing its frequency in the map mp. If the frequency of the element becomes zero, it is removed from the map. The indices i and j are incremented to move the sliding window forward.\\n\\nFinally, when the while loop completes, the function returns the vector v containing the minimum elements of all subarrays of length k with a beauty value of at least x.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The while loop in the implementation iterates over each element in the input vector nums exactly once, so the time complexity of the loop is O(n).\\n\\nInside the while loop, the implementation uses a map to keep track of the frequency of each element in the current subarray. The map operations, such as insertion, deletion, and finding an element, have a time complexity of O(log(n)) on average. In the worst case, when the map is unbalanced, the time complexity of these operations can be O(n). Since the map operations are performed for each element in nums, the overall time complexity of the map operations is O(n*log(n)) on average and O(n^2) in the worst case.\\n\\nTherefore, the overall time complexity of the implementation is dominated by the time complexity of the while loop, which is O(n). Thus, the time complexity of the implementation is O(n*log(n)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The implementation uses a map to keep track of the frequency of each element in the current subarray, so the space complexity of the map is at most O(k). This is because the map will store at most k distinct elements, one for each position in the sliding window.\\n\\nIn addition to the map, the implementation uses a vector to store the minimum elements of the subarrays with beauty value at least x. The length of this vector is at most n/k, since there can be at most n/k subarrays of length k in the input vector nums that the function checks. Therefore, the space complexity of the vector is O(n/k).\\n\\nSince O(k) is less than or equal to O(n/k), the overall space complexity of the implementation is O(n/k).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        map<int,int>mp;\\n        int i=0; int j=0;\\n        vector<int>v;\\n        while(j<nums.size()){\\n            if(j-i+1<k){\\n                mp[nums[j]]++;\\n                j++;\\n            }\\n            else{\\n                mp[nums[j]]++;\\n                int count=0;\\n               for(auto it:mp){\\n                   count+=it.second;\\n                   if(count>=x){\\n                       if(it.first<=0){\\n                          v.push_back(it.first);  \\n                       }\\n                      else{\\n                          v.push_back(0);\\n                      }\\n                       break;\\n                   }\\n               } \\n               mp[nums[i]]--;\\n               if(mp[nums[i]]==0) {\\n                   mp.erase(nums[i]);\\n               }\\n               i++;\\n               j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        map<int,int>mp;\\n        int i=0; int j=0;\\n        vector<int>v;\\n        while(j<nums.size()){\\n            if(j-i+1<k){\\n                mp[nums[j]]++;\\n                j++;\\n            }\\n            else{\\n                mp[nums[j]]++;\\n                int count=0;\\n               for(auto it:mp){\\n                   count+=it.second;\\n                   if(count>=x){\\n                       if(it.first<=0){\\n                          v.push_back(it.first);  \\n                       }\\n                      else{\\n                          v.push_back(0);\\n                      }\\n                       break;\\n                   }\\n               } \\n               mp[nums[i]]--;\\n               if(mp[nums[i]]==0) {\\n                   mp.erase(nums[i]);\\n               }\\n               i++;\\n               j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497251,
                "title": "easy-to-understand-sliding-window-ordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nk) \\n-  n-> for iterating over nums array\\n-  k-> for iterating over map\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int i=0;\\n        for(;i<k-1;i++)\\n          mp[nums[i]]++;\\n\\n            vector<int> ans;\\n          for(;i<nums.size();i++){\\n              mp[nums[i]]++;\\n              int count=0,beauty=0;\\n              for(auto [ele,f]:mp){\\n                  count+=f;\\n                  if(count>=x){ beauty=ele; break;}\\n              }\\n              if(beauty<0)\\n              ans.push_back(beauty);\\n              else \\n              ans.push_back(0);\\n\\n              mp[nums[i-k+1]]--;\\n              if(mp[nums[i-k+1]]==0) mp.erase(nums[i-k+1]);\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int i=0;\\n        for(;i<k-1;i++)\\n          mp[nums[i]]++;\\n\\n            vector<int> ans;\\n          for(;i<nums.size();i++){\\n              mp[nums[i]]++;\\n              int count=0,beauty=0;\\n              for(auto [ele,f]:mp){\\n                  count+=f;\\n                  if(count>=x){ beauty=ele; break;}\\n              }\\n              if(beauty<0)\\n              ans.push_back(beauty);\\n              else \\n              ans.push_back(0);\\n\\n              mp[nums[i-k+1]]--;\\n              if(mp[nums[i-k+1]]==0) mp.erase(nums[i-k+1]);\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488084,
                "title": "c-easy-solution-frequency-vector",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        vector<int> fre(101);\\n        int i=0,j=0,n = nums.size();\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            {\\n                fre[nums[j]+50]++;\\n            }\\n            if(j-i+1==k)\\n            {\\n                int cnt = 0;\\n                for(int s=0;s<101;s++)\\n                {\\n                    cnt+=fre[s];\\n                    if(cnt>=x)\\n                    {\\n                        ans.push_back(s-50);\\n                        break;\\n                    }\\n                }\\n                if(cnt<x)\\n                ans.push_back(0);\\n                fre[nums[i]+50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        vector<int> fre(101);\\n        int i=0,j=0,n = nums.size();\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            {\\n                fre[nums[j]+50]++;\\n            }\\n            if(j-i+1==k)\\n            {\\n                int cnt = 0;\\n                for(int s=0;s<101;s++)\\n                {\\n                    cnt+=fre[s];\\n                    if(cnt>=x)\\n                    {\\n                        ans.push_back(s-50);\\n                        break;\\n                    }\\n                }\\n                if(cnt<x)\\n                ans.push_back(0);\\n                fre[nums[i]+50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486317,
                "title": "99-84-tc-easy-python-solution-using-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        def solve(negative):\\n            if(negative < x):\\n                return 0\\n            temp = x\\n            for i in range(50):\\n                if(temp <= count[i]):\\n                    return i-50\\n                temp -= count[i]\\n                \\n        neg = 0\\n        count = [0] * 50\\n        for i in range(k):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n        ans = [solve(neg)]\\n        for i in range(k, len(nums)):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n            if(nums[i-k] < 0):\\n                count[nums[i-k]] -= 1\\n                neg -= 1\\n            ans.append(solve(neg))\\n        return ans\\n            \\n        \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        def solve(negative):\\n            if(negative < x):\\n                return 0\\n            temp = x\\n            for i in range(50):\\n                if(temp <= count[i]):\\n                    return i-50\\n                temp -= count[i]\\n                \\n        neg = 0\\n        count = [0] * 50\\n        for i in range(k):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n        ans = [solve(neg)]\\n        for i in range(k, len(nums)):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n            if(nums[i-k] < 0):\\n                count[nums[i-k]] -= 1\\n                neg -= 1\\n            ans.append(solve(neg))\\n        return ans\\n            \\n        \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485287,
                "title": "easy-java-solution-array-sliding-window",
                "content": "```\\nTC = O(N*101)~= O(N)\\nSC = O(101) ~= O(1)\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          \\n        int freq[] = new int[101];\\n        int N = nums.length;\\n        int len = N - k + 1;\\n        int ans[] = new int[len];\\n        \\n        for(int i=0; i<k; i++) {\\n            freq[nums[i]+50]++;\\n        }\\n        int index =0; \\n\\n        int count = 0;\\n        for(int i=0; i<101; i++) {\\n            count += freq[i];\\n            if(count>=x) {\\n                ans[index++] = i-50 < 0 ? i-50 : 0;\\n                break;\\n            }\\n        }\\n        for(int i=k; i<N; i++) {\\n            freq[nums[i-k]+50]--;\\n            freq[nums[i]+50]++;\\n            count = 0;\\n            for(int j=0; j<101; j++) {\\n                count += freq[j];\\n                if(count>=x) {\\n                    ans[index++] = j-50 < 0 ? j-50 : 0;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nTC = O(N*101)~= O(N)\\nSC = O(101) ~= O(1)\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          \\n        int freq[] = new int[101];\\n        int N = nums.length;\\n        int len = N - k + 1;\\n        int ans[] = new int[len];\\n        \\n        for(int i=0; i<k; i++) {\\n            freq[nums[i]+50]++;\\n        }\\n        int index =0; \\n\\n        int count = 0;\\n        for(int i=0; i<101; i++) {\\n            count += freq[i];\\n            if(count>=x) {\\n                ans[index++] = i-50 < 0 ? i-50 : 0;\\n                break;\\n            }\\n        }\\n        for(int i=k; i<N; i++) {\\n            freq[nums[i-k]+50]--;\\n            freq[nums[i]+50]++;\\n            count = 0;\\n            for(int j=0; j<101; j++) {\\n                count += freq[j];\\n                if(count>=x) {\\n                    ans[index++] = j-50 < 0 ? j-50 : 0;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480168,
                "title": "java-only-array-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int t[] = new int[101];\\n  int X;\\n\\n  private int findX(){\\n    for(int i = 0, c = 0; i != 50; ++i)\\n      if( (c+=t[i]) >= X) return i - 50;\\n    return 0;\\n  }\\n\\n  public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int ans[] = new int[nums.length - k + 1];\\n    X = x;\\n    \\n    for(int i = 0; i != k; ++i) ++t[nums[i]+50];\\n    ans[0] = findX();\\n\\n    for(int i = k, j = 1; i != nums.length; ++i, ++j){\\n      ++t[nums[i]+50];\\n      --t[nums[j-1]+50];\\n      ans[j] = findX();\\n    }\\n\\n    return ans;  \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  int t[] = new int[101];\\n  int X;\\n\\n  private int findX(){\\n    for(int i = 0, c = 0; i != 50; ++i)\\n      if( (c+=t[i]) >= X) return i - 50;\\n    return 0;\\n  }\\n\\n  public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int ans[] = new int[nums.length - k + 1];\\n    X = x;\\n    \\n    for(int i = 0; i != k; ++i) ++t[nums[i]+50];\\n    ans[0] = findX();\\n\\n    for(int i = k, j = 1; i != nums.length; ++i, ++j){\\n      ++t[nums[i]+50];\\n      --t[nums[j-1]+50];\\n      ans[j] = findX();\\n    }\\n\\n    return ans;  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478045,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_subarray_beauty(nums: Vec<i32>, k: i32, x: i32) -> Vec<i32> {\\n        let mut ans = vec![];\\n        let mut mp = std::collections::BTreeMap::new();\\n        for i in 0..nums.len() {\\n            *mp.entry(nums[i]).or_insert(0) += 1;\\n            if i >= k as usize - 1 {\\n                if i >= k as usize {\\n                    *mp.get_mut(&nums[i - k as usize]).unwrap() -= 1;\\n                }\\n                let mut sum = 0;\\n                let mut t = 0;\\n                for (key, value) in mp.iter() {\\n                    sum += value;\\n                    if sum >= x {\\n                        t = if *key < 0 { *key } else { 0 };\\n                        break;\\n                    }\\n                }\\n                ans.push(t);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_subarray_beauty(nums: Vec<i32>, k: i32, x: i32) -> Vec<i32> {\\n        let mut ans = vec![];\\n        let mut mp = std::collections::BTreeMap::new();\\n        for i in 0..nums.len() {\\n            *mp.entry(nums[i]).or_insert(0) += 1;\\n            if i >= k as usize - 1 {\\n                if i >= k as usize {\\n                    *mp.get_mut(&nums[i - k as usize]).unwrap() -= 1;\\n                }\\n                let mut sum = 0;\\n                let mut t = 0;\\n                for (key, value) in mp.iter() {\\n                    sum += value;\\n                    if sum >= x {\\n                        t = if *key < 0 { *key } else { 0 };\\n                        break;\\n                    }\\n                }\\n                ans.push(t);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477265,
                "title": "c-solution-using-multiset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use multisets to store the elements in sorted order. One multiset(here m1) will store the first x elements and the other(here m2) will store the next k-x elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we slide the window, we will check if the element to be removed is present in the first multiset or the second and remove it from there.\\nThe new element will be added to the other multiset. Suppose we are removing the element from the first multiset then the new element will be added to the second multiset and vice-versa.\\nNow we will adjust the multisets accordingly such that the first multiset contains x elements and the other contains k-x elements.\\nNow, we check if the last element of first multiset is negative or positive and push it to the answer vector accordingly.\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int>m1,m2;\\n        int i=0,j=0;\\n        for(;i<k;i++)\\n            m1.insert(nums[i]);\\n        while(m1.size()>x)\\n        {\\n            m2.insert(*m1.rbegin());\\n            m1.erase(m1.find(*m1.rbegin()));\\n        }\\n        vector<int>res;\\n        if(*m1.rbegin()>=0)\\n            res.push_back(0);\\n        else\\n            res.push_back(*m1.rbegin());\\n        for(;i<nums.size();i++,j++)\\n        {\\n            if(m1.find(nums[j])!=m1.end())\\n            {\\n                m1.erase(m1.find(nums[j]));\\n                m2.insert(nums[i]);\\n                m1.insert(*m2.begin());\\n                m2.erase(m2.begin());\\n            }\\n            else\\n            {\\n                m2.erase(m2.find(nums[j]));\\n                m1.insert(nums[i]);\\n                m2.insert(*m1.rbegin());\\n                m1.erase(m1.find(*m1.rbegin()));\\n            }\\n            if(*m1.rbegin()>=0)\\n                res.push_back(0);\\n            else\\n                res.push_back(*m1.rbegin());\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int>m1,m2;\\n        int i=0,j=0;\\n        for(;i<k;i++)\\n            m1.insert(nums[i]);\\n        while(m1.size()>x)\\n        {\\n            m2.insert(*m1.rbegin());\\n            m1.erase(m1.find(*m1.rbegin()));\\n        }\\n        vector<int>res;\\n        if(*m1.rbegin()>=0)\\n            res.push_back(0);\\n        else\\n            res.push_back(*m1.rbegin());\\n        for(;i<nums.size();i++,j++)\\n        {\\n            if(m1.find(nums[j])!=m1.end())\\n            {\\n                m1.erase(m1.find(nums[j]));\\n                m2.insert(nums[i]);\\n                m1.insert(*m2.begin());\\n                m2.erase(m2.begin());\\n            }\\n            else\\n            {\\n                m2.erase(m2.find(nums[j]));\\n                m1.insert(nums[i]);\\n                m2.insert(*m1.rbegin());\\n                m1.erase(m1.find(*m1.rbegin()));\\n            }\\n            if(*m1.rbegin()>=0)\\n                res.push_back(0);\\n            else\\n                res.push_back(*m1.rbegin());\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471955,
                "title": "c-o-n-log-k-using-ordered-multiset-but-code-is-awful-to-read",
                "content": "I didn\\'t notice the constraint of the range of values, so I didn\\'t think to use counting sort. By the time I noticed the constraint, I had already most of the code for this solution, which is O(n log k) and uses a multiset to store the window. \\n\\nWe insert and delete elements from the window as it slides through the input, and store an iterator to the xth element of the multiset. When processing the next element, we may need to shift the iterator for the xth element left or right based on its relation to the inserted and deleted element. That\\'s why there\\'s so many cases to check. Although this took me a while to do, I learned a lot about the std::multiset which I hadn\\'t known prior.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> res(n-k+1);\\n        multiset<int> s;\\n        for (int i = 0; i < k; i ++){\\n            s.insert(nums[i]);\\n        }\\n        \\n        auto it = s.begin();\\n        for (int i = 1; i < x; i++){  \\n            it++;\\n        }\\n        \\n        int xth = *it;\\n        res[0] = (xth < 0 ) ? xth : 0;\\n\\n        for (int i = k; i < n; i++){\\n            int ins = nums[i];\\n            int del = nums[i-k];\\n\\n            if (ins == del){\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n            }else if (xth > ins && xth > del || xth < ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth > ins && xth < del){\\n                s.insert(ins);\\n                it = prev(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth > del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth == del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }  \\n            }else if (xth > ins && xth == del){\\n                //hardest part\\n                s.insert(ins);\\n                auto itr = s.lower_bound(del);\\n                if (itr == it){\\n                    it = prev(it);\\n                    s.erase(itr);\\n                }else{\\n                    s.erase(itr);\\n                }\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;         \\n            }else if (xth == ins && xth > del ){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth == ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> res(n-k+1);\\n        multiset<int> s;\\n        for (int i = 0; i < k; i ++){\\n            s.insert(nums[i]);\\n        }\\n        \\n        auto it = s.begin();\\n        for (int i = 1; i < x; i++){  \\n            it++;\\n        }\\n        \\n        int xth = *it;\\n        res[0] = (xth < 0 ) ? xth : 0;\\n\\n        for (int i = k; i < n; i++){\\n            int ins = nums[i];\\n            int del = nums[i-k];\\n\\n            if (ins == del){\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n            }else if (xth > ins && xth > del || xth < ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth > ins && xth < del){\\n                s.insert(ins);\\n                it = prev(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth > del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth == del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }  \\n            }else if (xth > ins && xth == del){\\n                //hardest part\\n                s.insert(ins);\\n                auto itr = s.lower_bound(del);\\n                if (itr == it){\\n                    it = prev(it);\\n                    s.erase(itr);\\n                }else{\\n                    s.erase(itr);\\n                }\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;         \\n            }else if (xth == ins && xth > del ){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth == ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471317,
                "title": "java",
                "content": "The main trick is to understand that -50 <= nums[i] <= 50, before wasting time on any creative ideas.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int negs=0,n=nums.length;\\n        int [] sol = new int [n-k+1], frqs = new int[101]; //-50 - +50\\n        for (int i=0;i<k;i++){\\n            frqs[nums[i]+50]++;\\n            if (nums[i]<0) negs++;\\n        }\\n        for (int i=0;i<n-k+1;i++){\\n            sol[i] = (negs<x)?0:findXth(frqs,x);\\n            if (i==n-k) break;\\n            frqs[nums[i]+50]--;\\n            if (nums[i]<0) negs--;\\n            frqs[nums[i+k]+50]++;\\n            if (nums[i+k]<0) negs++;\\n        }\\n        return sol;\\n    }\\n\\n    public int findXth(int frqs[],int x){\\n        int counter=0;\\n        for (int i=0;i<51;i++){\\n            counter+=frqs[i];\\n            if (counter>=x) return i-50;\\n        }\\n        return 777;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int negs=0,n=nums.length;\\n        int [] sol = new int [n-k+1], frqs = new int[101]; //-50 - +50\\n        for (int i=0;i<k;i++){\\n            frqs[nums[i]+50]++;\\n            if (nums[i]<0) negs++;\\n        }\\n        for (int i=0;i<n-k+1;i++){\\n            sol[i] = (negs<x)?0:findXth(frqs,x);\\n            if (i==n-k) break;\\n            frqs[nums[i]+50]--;\\n            if (nums[i]<0) negs--;\\n            frqs[nums[i+k]+50]++;\\n            if (nums[i+k]<0) negs++;\\n        }\\n        return sol;\\n    }\\n\\n    public int findXth(int frqs[],int x){\\n        int counter=0;\\n        for (int i=0;i<51;i++){\\n            counter+=frqs[i];\\n            if (counter>=x) return i-50;\\n        }\\n        return 777;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467658,
                "title": "max-heap-min-heap",
                "content": "# Intuition\\nIf we remove the ridiculous -50..50 condition from the task (or just didn\\'t notice it, haha), we would not be able to use the counting-based solutions, so we need something smarter.\\nThe idea is to use max heap for the x smaller numbers, and min heap for the larger numbers and \"transfuse\" numbers between them. When we remove the 1st element from the sliding array, we will either remove it from the maxHeap (and put there the smallest of the larger numbers from the minHeap); or we just remove it from the maxHeap.\\n\\n# Approach\\nI tried to explain everything in details in comments in the code\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        // we will store x smallest numbers in the maxHeap, so that the element on teh top is the x-th smallest\\n        val maxHeap = PriorityQueue<Int>(reverseOrder())\\n        // we will store the rest of the elements (the bigger ones) in the minHeap\\n        val minHeap = PriorityQueue<Int>()\\n        for (i in 0 until k) {\\n            maxHeap.offer(nums[i])\\n        }\\n        var result  = IntArray(nums.size - k + 1)\\n        for (i in 0 .. nums.size-k) {\\n            // remove the bigger elements from the maxHeap and put them in the minHeap\\n            while (maxHeap.size > x) {\\n                minHeap.offer(maxHeap.poll())\\n            }\\n            // get the x-th smallest element from the top of the maxHeap\\n            result[i] = Math.min(0, maxHeap.peek())\\n            // now we need to remove the 1st element of our sliding array from the heaps\\n            // if this element is less or equal than the top of the maxHeap - it means it participates in the x-size set of minimum elements\\n            // this means we need to remove it from the maxHeap, and put there the smallest number from the remaining elements (which we store in the minHeap)\\n            // otherwise this 1st element is one of the bigger elements, so we just remove it from the minHeap\\n            if (nums[i] <= maxHeap.peek()) {\\n                maxHeap.remove(nums[i])\\n                // if x == k, the minHeap will always be empty\\n                if (minHeap.size > 0) maxHeap.offer(minHeap.poll())\\n            } else minHeap.remove(nums[i])\\n            \\n            // and finally we are adding the next element to the maxHeap\\n            if (k+i < nums.size) maxHeap.offer(nums[k+i])\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        // we will store x smallest numbers in the maxHeap, so that the element on teh top is the x-th smallest\\n        val maxHeap = PriorityQueue<Int>(reverseOrder())\\n        // we will store the rest of the elements (the bigger ones) in the minHeap\\n        val minHeap = PriorityQueue<Int>()\\n        for (i in 0 until k) {\\n            maxHeap.offer(nums[i])\\n        }\\n        var result  = IntArray(nums.size - k + 1)\\n        for (i in 0 .. nums.size-k) {\\n            // remove the bigger elements from the maxHeap and put them in the minHeap\\n            while (maxHeap.size > x) {\\n                minHeap.offer(maxHeap.poll())\\n            }\\n            // get the x-th smallest element from the top of the maxHeap\\n            result[i] = Math.min(0, maxHeap.peek())\\n            // now we need to remove the 1st element of our sliding array from the heaps\\n            // if this element is less or equal than the top of the maxHeap - it means it participates in the x-size set of minimum elements\\n            // this means we need to remove it from the maxHeap, and put there the smallest number from the remaining elements (which we store in the minHeap)\\n            // otherwise this 1st element is one of the bigger elements, so we just remove it from the minHeap\\n            if (nums[i] <= maxHeap.peek()) {\\n                maxHeap.remove(nums[i])\\n                // if x == k, the minHeap will always be empty\\n                if (minHeap.size > 0) maxHeap.offer(minHeap.poll())\\n            } else minHeap.remove(nums[i])\\n            \\n            // and finally we are adding the next element to the maxHeap\\n            if (k+i < nums.size) maxHeap.offer(nums[k+i])\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466590,
                "title": "java-26ms-96-and-clean-code",
                "content": "# Approach\\n1. Use an int[101] window to mark & count the nums[-50..50]. Just add 50 to the num (-50 + 50) -> 0, (4 +50) -> 54\\n2. Create the initial window with the nums[0..k-1].\\n3. While adding them, keep track of the negative count. If num < 0, increase negative count.\\nWhen quering a given interval, if negativeCount < x, then return 0 immediately.\\n4. Finding the xth negative. \\n    - As mentioned on #3, if negativeCount < x, return 0\\n    - Else loop from 0 to < 50 (representing the nums -50, -1) and do a prefix sum.\\n    - Stop when prefixSum >= x. Return index - 50 (an index 4 will represent the number -46 becuase -46+50 = 4;\\n5. When moving to next element, just remove the left number of the window (nums[i - k]). Also, adjust the negative count. (decrease if the eliminated number is negative). \\n\\n# Complexity\\n- Time complexity:$$O((n-k) * 50)$$ - worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(102)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] negativeCount = {0};\\n        int[] window = createWindow(nums, k, negativeCount);\\n        int[] beauty = new int[nums.length - k + 1];\\n        for (int i = k; i < nums.length; i++) {\\n            beauty[i - k] = findXthSmallestInteger(window, x, negativeCount);\\n            removePreviousElement(window, nums, i - k, negativeCount);\\n            addNextElement(window, nums, i, negativeCount);\\n        }\\n        beauty[nums.length - k] = findXthSmallestInteger(window, x, negativeCount);\\n        return beauty;\\n    }\\n\\n    private void removePreviousElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]--;\\n        }\\n        window[nums[index] + 50]--;\\n    }\\n\\n    private void addNextElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]++;\\n        }\\n        window[nums[index] + 50]++;\\n    }\\n\\n    private int findXthSmallestInteger(int[] window, int x, int[] negativeCount) {\\n        if (negativeCount[0] < x) {\\n            return 0;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < 50; i++) {\\n            if (window[i] > 0) {\\n                count += window[i];\\n                if (count >= x) {\\n                   return index - 50;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] createWindow(int[] nums, int size, int[] negativeCount) {\\n        int[] window = new int[101];\\n        while(--size >= 0) {\\n            window[nums[size] + 50]++;\\n            if (nums[size] < 0) {\\n                negativeCount[0]++;\\n            }\\n        }\\n        return window;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] negativeCount = {0};\\n        int[] window = createWindow(nums, k, negativeCount);\\n        int[] beauty = new int[nums.length - k + 1];\\n        for (int i = k; i < nums.length; i++) {\\n            beauty[i - k] = findXthSmallestInteger(window, x, negativeCount);\\n            removePreviousElement(window, nums, i - k, negativeCount);\\n            addNextElement(window, nums, i, negativeCount);\\n        }\\n        beauty[nums.length - k] = findXthSmallestInteger(window, x, negativeCount);\\n        return beauty;\\n    }\\n\\n    private void removePreviousElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]--;\\n        }\\n        window[nums[index] + 50]--;\\n    }\\n\\n    private void addNextElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]++;\\n        }\\n        window[nums[index] + 50]++;\\n    }\\n\\n    private int findXthSmallestInteger(int[] window, int x, int[] negativeCount) {\\n        if (negativeCount[0] < x) {\\n            return 0;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < 50; i++) {\\n            if (window[i] > 0) {\\n                count += window[i];\\n                if (count >= x) {\\n                   return index - 50;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] createWindow(int[] nums, int size, int[] negativeCount) {\\n        int[] window = new int[101];\\n        while(--size >= 0) {\\n            window[nums[size] + 50]++;\\n            if (nums[size] < 0) {\\n                negativeCount[0]++;\\n            }\\n        }\\n        return window;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466479,
                "title": "java-93-faster-simple-counting-array",
                "content": "**Approach:**\\n* We are provided with a range of `-50 <= nums[i] <= 50 ` , so we can create a count array of size 50 to store only negative number as we only need negative numbers.\\n* Now as we have a fix range of 50, we iterate we iterate over 50 elements to calculate xth negative number with TC: `O(50)` for each operation we do this using frequency by adding frequency to a local variable and checking if it becomes greator or equals to x.\\n* In each iteration we slide over array and increase the frequency of each negative no and remove the element from start if negative.\\n\\n\\n**Tme Complexity:**\\n```\\nTC: O(N)\\nSC: O(1)\\n```\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          int[] count = new int[50];\\n          int[] sol = new int[nums.length-k+1];\\n          int i=0;\\n          for(;i<k;i++){\\n              if(nums[i]<0)count[nums[i]+50]++;\\n          }\\n          int l=0,val=0;\\n          for(int q=0;q<50;q++){\\n                  l+=count[q];\\n                  if(l>=x){\\n                      val=q-50;\\n                      break;\\n                  }\\n          }\\n          sol[0]=val;\\n          int idx=1;\\n          for(;i<nums.length;i++){\\n              if(nums[idx-1]<0)count[nums[idx-1]+50]--;\\n              if(nums[i]<0)count[nums[i]+50]++;\\n              int loc=0,v=0;\\n              for(int q=0;q<50;q++){\\n                  loc+=count[q];\\n                  if(loc>=x){\\n                      v=q-50;\\n                      break;\\n                  }\\n              }\\n              sol[idx++]=v;\\n          }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nTC: O(N)\\nSC: O(1)\\n```\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          int[] count = new int[50];\\n          int[] sol = new int[nums.length-k+1];\\n          int i=0;\\n          for(;i<k;i++){\\n              if(nums[i]<0)count[nums[i]+50]++;\\n          }\\n          int l=0,val=0;\\n          for(int q=0;q<50;q++){\\n                  l+=count[q];\\n                  if(l>=x){\\n                      val=q-50;\\n                      break;\\n                  }\\n          }\\n          sol[0]=val;\\n          int idx=1;\\n          for(;i<nums.length;i++){\\n              if(nums[idx-1]<0)count[nums[idx-1]+50]--;\\n              if(nums[i]<0)count[nums[i]+50]++;\\n              int loc=0,v=0;\\n              for(int q=0;q<50;q++){\\n                  loc+=count[q];\\n                  if(loc>=x){\\n                      v=q-50;\\n                      break;\\n                  }\\n              }\\n              sol[idx++]=v;\\n          }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465886,
                "title": "very-easy-solution-c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nused set and map \\nset is used because in it searching insertion and deletion is done in O(logN) time\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0 , j=0;\\n        int n = nums.size();\\n        map<int , int>mpp;\\n        set<int>st;\\n        vector<int>ans;\\n        \\n        while(j<n)\\n        {\\n            mpp[nums[j]]++;\\n            st.insert(nums[j]);\\n            \\n            if(j-i+1<k)j++;\\n            \\n            else if(j-i+1==k)\\n            {\\n                int cnt=0;\\n\\n                for(auto ele : st)\\n                {\\n                    cnt+=mpp[ele];\\n                    if(cnt>=x)\\n                    {\\n                        if(ele<0)ans.push_back(ele);\\n                        else ans.push_back(0);\\n                        break;\\n                    }\\n                }\\n\\n                if(mpp[nums[i]]==1)\\n                {\\n                    st.erase(nums[i]);\\n                }\\n                mpp[nums[i]]--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0 , j=0;\\n        int n = nums.size();\\n        map<int , int>mpp;\\n        set<int>st;\\n        vector<int>ans;\\n        \\n        while(j<n)\\n        {\\n            mpp[nums[j]]++;\\n            st.insert(nums[j]);\\n            \\n            if(j-i+1<k)j++;\\n            \\n            else if(j-i+1==k)\\n            {\\n                int cnt=0;\\n\\n                for(auto ele : st)\\n                {\\n                    cnt+=mpp[ele];\\n                    if(cnt>=x)\\n                    {\\n                        if(ele<0)ans.push_back(ele);\\n                        else ans.push_back(0);\\n                        break;\\n                    }\\n                }\\n\\n                if(mpp[nums[i]]==1)\\n                {\\n                    st.erase(nums[i]);\\n                }\\n                mpp[nums[i]]--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463444,
                "title": "python3-hashtable-and-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg > 0 and neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg > 0 and neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462116,
                "title": "sliding-window-treemap",
                "content": "# Code\\n```\\nclass Solution {\\n    private int getXthSmallest(Map<Integer, Integer> map, int x) {\\n        int count = 0;\\n\\n        for (var entry: map.entrySet()) {\\n            count += entry.getValue();\\n\\n            if (count >= x) {\\n                return entry.getKey();\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n     public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int j = 0;\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        var frequency = new TreeMap<Integer, Integer>();\\n\\n        for (int i = 0; i < k; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n        }\\n\\n        ans[j++] = getXthSmallest(frequency, x);\\n\\n        for (int i = k; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n\\n            if (nums[i - k] < 0) {\\n                frequency.merge(nums[i - k], -1, Integer::sum);\\n            }\\n\\n            ans[j++] = getXthSmallest(frequency, x);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int getXthSmallest(Map<Integer, Integer> map, int x) {\\n        int count = 0;\\n\\n        for (var entry: map.entrySet()) {\\n            count += entry.getValue();\\n\\n            if (count >= x) {\\n                return entry.getKey();\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n     public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int j = 0;\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        var frequency = new TreeMap<Integer, Integer>();\\n\\n        for (int i = 0; i < k; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n        }\\n\\n        ans[j++] = getXthSmallest(frequency, x);\\n\\n        for (int i = k; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n\\n            if (nums[i - k] < 0) {\\n                frequency.merge(nums[i - k], -1, Integer::sum);\\n            }\\n\\n            ans[j++] = getXthSmallest(frequency, x);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461681,
                "title": "easy-beginner-friendly-fixed-sized-sliding-window-problem-well-commented-cpp",
                "content": "# Intuition + Approach\\n1. Converted the problem into Fixed Size Sliding Window Problem. \\n2. Used a Map to store the negative numbers, such that we can easily extract the xth smallest element at any point of time.\\n3. At any point the map would only contain the negative numbers present in the window\\n4. Once window size K is reached the challeneging point is to get into the xth position in the map.\\n5. However, while travelling to xth position in map, we need to take into account of the frequency.\\n6. Ran a for loop to take into the number of times we are iterating. \\n\\n# Complexity\\n- Time complexity:\\nO(n*x)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n  {\\n    // to store -ve numbers in order for quick extraction of xth smallest element\\n    map<int, int> umap;\\n    vector<int> ans;\\n    int i = 0, j = 0, flag = 1, c = 0, no = 0;\\n    // sliding window starts\\n    while (j < nums.size())\\n    {\\n      // calculation - insert only negative numbers in map [contains]\\n      if (nums[j] < 0)\\n        umap[nums[j]]++;\\n      // if window size k isn\\'t reached\\n      if (j - i + 1 < k)\\n        j++;\\n      // if window size k is reached\\n      else if (j - i + 1 == k)\\n      {\\n        // this loop is run to get into xth smallest element in map\\n        for (auto it = umap.begin(); it != umap.end(); it++)\\n        {\\n          c += it->second; // to take into account of the number of times it apperared, as if it\\'s present in map means the window has this element of these many occurences\\n          if (c >= x)\\n          { // while adding to it->second, c might exceed x , so if c!=x && c>x doesn\\'t mean xth smallest element isn\\'t present.\\n            no = it->first;\\n            flag = 0;\\n            break;\\n          }\\n        }\\n        c = 0;\\n        if (flag == 0)\\n          ans.push_back(no);\\n        else\\n          ans.push_back(0); // flag!=0 indicates xth smallest element wasn\\'t found so return 0.\\n        flag = 1;\\n        // slide the window\\n        // as k is reached, so delete 1 element from start and update in map accordingly\\n        auto index = umap.find(nums[i]);\\n        if (index != umap.end())\\n        {\\n          if (umap[nums[i]] == 1)\\n            umap.erase(nums[i]);\\n          else\\n            umap[nums[i]]--;\\n        }\\n        i++;\\n        j++;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n  {\\n    // to store -ve numbers in order for quick extraction of xth smallest element\\n    map<int, int> umap;\\n    vector<int> ans;\\n    int i = 0, j = 0, flag = 1, c = 0, no = 0;\\n    // sliding window starts\\n    while (j < nums.size())\\n    {\\n      // calculation - insert only negative numbers in map [contains]\\n      if (nums[j] < 0)\\n        umap[nums[j]]++;\\n      // if window size k isn\\'t reached\\n      if (j - i + 1 < k)\\n        j++;\\n      // if window size k is reached\\n      else if (j - i + 1 == k)\\n      {\\n        // this loop is run to get into xth smallest element in map\\n        for (auto it = umap.begin(); it != umap.end(); it++)\\n        {\\n          c += it->second; // to take into account of the number of times it apperared, as if it\\'s present in map means the window has this element of these many occurences\\n          if (c >= x)\\n          { // while adding to it->second, c might exceed x , so if c!=x && c>x doesn\\'t mean xth smallest element isn\\'t present.\\n            no = it->first;\\n            flag = 0;\\n            break;\\n          }\\n        }\\n        c = 0;\\n        if (flag == 0)\\n          ans.push_back(no);\\n        else\\n          ans.push_back(0); // flag!=0 indicates xth smallest element wasn\\'t found so return 0.\\n        flag = 1;\\n        // slide the window\\n        // as k is reached, so delete 1 element from start and update in map accordingly\\n        auto index = umap.find(nums[i]);\\n        if (index != umap.end())\\n        {\\n          if (umap[nums[i]] == 1)\\n            umap.erase(nums[i]);\\n          else\\n            umap[nums[i]]--;\\n        }\\n        i++;\\n        j++;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460988,
                "title": "a-few-solutions",
                "content": "Let `cnt` be \"buckets\" which store the count of values `1..50` inclusive which represent each corresponding negative value `x` of the input array `A`.\\n\\nUse a sliding window `i..j` inclusive of size `K` along with the function `f()` to perform a linear scan of the \"buckets\" to find and return the target `T`<sup>th</sup> smallest negative value (if it exists).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun getSubarrayBeauty(A: IntArray, K: Int, T: Int): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var cnt = IntArray(50 + 1) { 0 }\\n        fun f(): Int {\\n            var t = 0\\n            for (x in 50 downTo 1) {\\n                t += cnt[x]\\n                if (T <= t)\\n                    return -x\\n            }\\n            return 0\\n        }\\n        for (j in 0 until A.size) {\\n            if (A[j] < 0) ++cnt[-A[j]]\\n            var i = j - K + 1\\n            if (0 <= i) {\\n                ans.add(f())\\n                if (A[i] < 0) --cnt[-A[i]]\\n            }\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet getSubarrayBeauty = (A, K, T, cnt = Array(50 + 1).fill(0), ans = []) => {\\n    let f = () => {\\n        let t = 0;\\n        for (let x = 50; 0 < x; --x) {\\n            t += cnt[x];\\n            if (T <= t)\\n                return -x;\\n        }\\n        return 0;\\n    };\\n    for (let j = 0; j < A.length; ++j) {\\n        if (A[j] < 0) ++cnt[-A[j]];\\n        let i = j - K + 1;\\n        if (0 <= i) {\\n            ans.push(f());\\n            if (A[i] < 0) --cnt[-A[i]];\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, A: List[int], K: int, T: int) -> List[int]:\\n        ans = []\\n        cnt = [0] * (50 + 1)\\n        def f():\\n            t = 0\\n            for x in range(50, 0, -1):\\n                t += cnt[x]\\n                if T <= t:\\n                    return -x\\n            return 0\\n        for j in range(len(A)):\\n            if A[j] < 0: cnt[-A[j]] += 1\\n            i = j - K + 1\\n            if 0 <= i:\\n                ans.append(f())\\n                if A[i] < 0: cnt[-A[i]] -= 1\\n        return ans\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn get_subarray_beauty(A: VI, K: i32, T: i32) -> VI {\\n        let mut ans = vec![];\\n        let mut cnt = vec![0; 50 + 1];\\n        fn f(A: &VI, T: i32, cnt: &VI) -> i32 {\\n            let mut t = 0;\\n            for x in (1..=50).rev() {\\n                t += cnt[x];\\n                if T <= t {\\n                    return -(x as i32);\\n                }\\n            }\\n            0\\n        }\\n        for j in 0..A.len() {\\n            if A[j] < 0 { cnt[-A[j] as usize] += 1; }\\n            let i = j as i32 - K + 1;\\n            if 0 <= i {\\n                ans.push(f(&A, T, &cnt));\\n                let i = i as usize;\\n                if A[i] < 0 { cnt[-A[i] as usize] -= 1; }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI getSubarrayBeauty(VI& A, int K, int T, VI ans = {}) {\\n        VI cnt(50 + 1);\\n        auto f = [&]() {\\n            auto t = 0;\\n            for (auto x{ 50 }; 0 < x; --x) {\\n                t += cnt[x];\\n                if (T <= t)\\n                    return -x;\\n            }\\n            return 0;\\n        };\\n        for (auto j{ 0 }; j < A.size(); ++j) {\\n            if (A[j] < 0) ++cnt[-A[j]];\\n            auto i = j - K + 1;\\n            if (0 <= i) {\\n                ans.push_back(f());\\n                if (A[i] < 0) --cnt[-A[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getSubarrayBeauty(A: IntArray, K: Int, T: Int): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var cnt = IntArray(50 + 1) { 0 }\\n        fun f(): Int {\\n            var t = 0\\n            for (x in 50 downTo 1) {\\n                t += cnt[x]\\n                if (T <= t)\\n                    return -x\\n            }\\n            return 0\\n        }\\n        for (j in 0 until A.size) {\\n            if (A[j] < 0) ++cnt[-A[j]]\\n            var i = j - K + 1\\n            if (0 <= i) {\\n                ans.add(f())\\n                if (A[i] < 0) --cnt[-A[i]]\\n            }\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet getSubarrayBeauty = (A, K, T, cnt = Array(50 + 1).fill(0), ans = []) => {\\n    let f = () => {\\n        let t = 0;\\n        for (let x = 50; 0 < x; --x) {\\n            t += cnt[x];\\n            if (T <= t)\\n                return -x;\\n        }\\n        return 0;\\n    };\\n    for (let j = 0; j < A.length; ++j) {\\n        if (A[j] < 0) ++cnt[-A[j]];\\n        let i = j - K + 1;\\n        if (0 <= i) {\\n            ans.push(f());\\n            if (A[i] < 0) --cnt[-A[i]];\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, A: List[int], K: int, T: int) -> List[int]:\\n        ans = []\\n        cnt = [0] * (50 + 1)\\n        def f():\\n            t = 0\\n            for x in range(50, 0, -1):\\n                t += cnt[x]\\n                if T <= t:\\n                    return -x\\n            return 0\\n        for j in range(len(A)):\\n            if A[j] < 0: cnt[-A[j]] += 1\\n            i = j - K + 1\\n            if 0 <= i:\\n                ans.append(f())\\n                if A[i] < 0: cnt[-A[i]] -= 1\\n        return ans\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn get_subarray_beauty(A: VI, K: i32, T: i32) -> VI {\\n        let mut ans = vec![];\\n        let mut cnt = vec![0; 50 + 1];\\n        fn f(A: &VI, T: i32, cnt: &VI) -> i32 {\\n            let mut t = 0;\\n            for x in (1..=50).rev() {\\n                t += cnt[x];\\n                if T <= t {\\n                    return -(x as i32);\\n                }\\n            }\\n            0\\n        }\\n        for j in 0..A.len() {\\n            if A[j] < 0 { cnt[-A[j] as usize] += 1; }\\n            let i = j as i32 - K + 1;\\n            if 0 <= i {\\n                ans.push(f(&A, T, &cnt));\\n                let i = i as usize;\\n                if A[i] < 0 { cnt[-A[i] as usize] -= 1; }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI getSubarrayBeauty(VI& A, int K, int T, VI ans = {}) {\\n        VI cnt(50 + 1);\\n        auto f = [&]() {\\n            auto t = 0;\\n            for (auto x{ 50 }; 0 < x; --x) {\\n                t += cnt[x];\\n                if (T <= t)\\n                    return -x;\\n            }\\n            return 0;\\n        };\\n        for (auto j{ 0 }; j < A.size(); ++j) {\\n            if (A[j] < 0) ++cnt[-A[j]];\\n            auto i = j - K + 1;\\n            if (0 <= i) {\\n                ans.push_back(f());\\n                if (A[i] < 0) --cnt[-A[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460189,
                "title": "a-short-and-general-multiset-solution",
                "content": "# Intuition\\nMultiset with pointer to xth largest element in the sliding window set maintained\\n\\n# Approach\\nMultiset with pointer to xth largest element in the sliding window set maintained\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(k)) which is independent of nums[i]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        x = x-1;\\n        \\n        vector<int> temp(nums.begin(), nums.begin()+k);\\n        sort(temp.begin(), temp.end());\\n        vector<int> ans = {temp[x]};\\n        int prev = temp[x];\\n        \\n        multiset<int> s;\\n        for(int i = 0; i<k; i++) s.insert(nums[i]);\\n        auto ptr = s.begin();\\n        for(int i = 0; i<x; i++) ptr++;\\n        \\n        \\n        for(int i = k; i<n; i++){\\n            s.insert(nums[i]);\\n            if(nums[i] < prev) ptr--;\\n            prev = *ptr;\\n            if(nums[i-k] <= prev) ptr++;\\n            s.erase(s.find(nums[i-k]));\\n            prev = *ptr;\\n            ans.push_back(prev);\\n        }\\n        for(auto &x : ans) if(x>0) x = 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        x = x-1;\\n        \\n        vector<int> temp(nums.begin(), nums.begin()+k);\\n        sort(temp.begin(), temp.end());\\n        vector<int> ans = {temp[x]};\\n        int prev = temp[x];\\n        \\n        multiset<int> s;\\n        for(int i = 0; i<k; i++) s.insert(nums[i]);\\n        auto ptr = s.begin();\\n        for(int i = 0; i<x; i++) ptr++;\\n        \\n        \\n        for(int i = k; i<n; i++){\\n            s.insert(nums[i]);\\n            if(nums[i] < prev) ptr--;\\n            prev = *ptr;\\n            if(nums[i-k] <= prev) ptr++;\\n            s.erase(s.find(nums[i-k]));\\n            prev = *ptr;\\n            ans.push_back(prev);\\n        }\\n        for(auto &x : ans) if(x>0) x = 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459761,
                "title": "java-simple-solution-greedy-sliding-window-tc-o-n-sc-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int cnt = 0;\\n        int[] freq = new int[60];\\n        for(int i = 0;i < k;i++){\\n            if(nums[i] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[i])]++;\\n            }\\n        }\\n        if(cnt >= x){\\n            int csf = 0;\\n            for(int i = 50;i >= 0;i--){\\n                if(freq[i] + csf >= x){\\n                    ans[0] = -i;\\n                    break;\\n                }\\n                csf += freq[i];\\n            }\\n        }\\n        int start = 0;\\n        int end = k;\\n\\n        while(end < n){\\n            if(nums[end] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[end])]++;\\n            }\\n\\n            if(nums[start] < 0){\\n                cnt--;\\n                freq[Math.abs(nums[start])]--;\\n            }\\n\\n            if(cnt >= x){\\n                int csf = 0;\\n                for(int i = 50;i >= 0;i--){\\n                    if(freq[i] + csf >= x){\\n                        ans[start + 1] = -i;\\n                        break;\\n                    }\\n                    csf += freq[i];\\n                }\\n            }\\n            start++;\\n            end++;\\n        }    \\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int cnt = 0;\\n        int[] freq = new int[60];\\n        for(int i = 0;i < k;i++){\\n            if(nums[i] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[i])]++;\\n            }\\n        }\\n        if(cnt >= x){\\n            int csf = 0;\\n            for(int i = 50;i >= 0;i--){\\n                if(freq[i] + csf >= x){\\n                    ans[0] = -i;\\n                    break;\\n                }\\n                csf += freq[i];\\n            }\\n        }\\n        int start = 0;\\n        int end = k;\\n\\n        while(end < n){\\n            if(nums[end] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[end])]++;\\n            }\\n\\n            if(nums[start] < 0){\\n                cnt--;\\n                freq[Math.abs(nums[start])]--;\\n            }\\n\\n            if(cnt >= x){\\n                int csf = 0;\\n                for(int i = 50;i >= 0;i--){\\n                    if(freq[i] + csf >= x){\\n                        ans[start + 1] = -i;\\n                        break;\\n                    }\\n                    csf += freq[i];\\n                }\\n            }\\n            start++;\\n            end++;\\n        }    \\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459566,
                "title": "sliding-window-concept-done-with-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        \\n        for(int i = 0; i < k; i++)\\n          tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n        ans[0] = getMin(tmap, x);\\n\\n        for(int i = k; i < n; i++){\\n            tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n            tmap.put(nums[i - k], tmap.getOrDefault(nums[i - k], 0) - 1);\\n\\n            if(tmap.get(nums[i - k]) == 0)\\n               tmap.remove(nums[i - k]);\\n\\n            ans[i - k + 1] = getMin(tmap, x);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    public int getMin(TreeMap<Integer, Integer> tmap, int x){\\n        int sma = 0;\\n        for(Integer val : tmap.keySet()){\\n            if(val < 0) \\n               sma += tmap.get(val);\\n            else return 0;\\n\\n            if(sma >= x) \\n               return val;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        \\n        for(int i = 0; i < k; i++)\\n          tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n        ans[0] = getMin(tmap, x);\\n\\n        for(int i = k; i < n; i++){\\n            tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n            tmap.put(nums[i - k], tmap.getOrDefault(nums[i - k], 0) - 1);\\n\\n            if(tmap.get(nums[i - k]) == 0)\\n               tmap.remove(nums[i - k]);\\n\\n            ans[i - k + 1] = getMin(tmap, x);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    public int getMin(TreeMap<Integer, Integer> tmap, int x){\\n        int sma = 0;\\n        for(Integer val : tmap.keySet()){\\n            if(val < 0) \\n               sma += tmap.get(val);\\n            else return 0;\\n\\n            if(sma >= x) \\n               return val;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458923,
                "title": "java-freq-count-o-n-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolution is based on constraints where we violate the nums[i] >= -50 and <= 50\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse frequency of numbers and traverse the constant 50-100 numbers and find the xth number from the freq array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N*100)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n            \\n            int i = 0;\\n            int n = nums.length;\\n            int[] ans = new int[n-k+1];\\n            int st = 0;\\n\\n\\n            int[] map = new int[200];\\n\\n\\n            while(i<k-1)\\n                map[nums[i++]+50]++;\\n            int j = 0;\\n            while(i<n){\\n                map[nums[i++]+50]++;\\n                ans[j++] = getRes(map, x);\\n                map[nums[st++]+50]--;\\n\\n            }\\n            return ans;\\n    }\\n\\n    public int getRes(int[] m, int x){\\n        int i = 0;\\n        while(x>0 & i < 101){\\n            int j = m[i];\\n            x = Math.max(0, x-j);\\n            if(x > 0)\\n            i++;\\n        }\\n        // System.out.println(i);\\n        return i-50 < 0 ? i-50 : 0; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n            \\n            int i = 0;\\n            int n = nums.length;\\n            int[] ans = new int[n-k+1];\\n            int st = 0;\\n\\n\\n            int[] map = new int[200];\\n\\n\\n            while(i<k-1)\\n                map[nums[i++]+50]++;\\n            int j = 0;\\n            while(i<n){\\n                map[nums[i++]+50]++;\\n                ans[j++] = getRes(map, x);\\n                map[nums[st++]+50]--;\\n\\n            }\\n            return ans;\\n    }\\n\\n    public int getRes(int[] m, int x){\\n        int i = 0;\\n        while(x>0 & i < 101){\\n            int j = m[i];\\n            x = Math.max(0, x-j);\\n            if(x > 0)\\n            i++;\\n        }\\n        // System.out.println(i);\\n        return i-50 < 0 ? i-50 : 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458671,
                "title": "easy-to-understand-using-sliding-window-and-map-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each window search the xth min by maintaining a map and running a\\nloop from -50 to 0 as the num value is mentioned in constraints\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = -50; i <= 50; i++)\\n        map.put(i, 0);\\n\\n        int start = 0;\\n        int end = 0;\\n        int [] res = new int[nums.length - k + 1];\\n        int idx = 0;\\n        while(end < nums.length)\\n        {\\n            if(nums[end] < 0)\\n            map.put(nums[end], map.getOrDefault(nums[end], 0) + 1);\\n            end++;\\n            if(end - start == k)\\n            {\\n               res[idx++] = findXMin(map, x);\\n               map.put(nums[start], map.get(nums[start]) - 1);\\n               start++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int findXMin(HashMap<Integer,Integer> map, int x)\\n    {\\n        int xthMin = 0;\\n        for(int i = -50; i <= 0; i++)\\n        {\\n            if(map.get(i) > 0)\\n            xthMin+= map.get(i);\\n\\n            if(xthMin >= x)\\n            return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = -50; i <= 50; i++)\\n        map.put(i, 0);\\n\\n        int start = 0;\\n        int end = 0;\\n        int [] res = new int[nums.length - k + 1];\\n        int idx = 0;\\n        while(end < nums.length)\\n        {\\n            if(nums[end] < 0)\\n            map.put(nums[end], map.getOrDefault(nums[end], 0) + 1);\\n            end++;\\n            if(end - start == k)\\n            {\\n               res[idx++] = findXMin(map, x);\\n               map.put(nums[start], map.get(nums[start]) - 1);\\n               start++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int findXMin(HashMap<Integer,Integer> map, int x)\\n    {\\n        int xthMin = 0;\\n        for(int i = -50; i <= 0; i++)\\n        {\\n            if(map.get(i) > 0)\\n            xthMin+= map.get(i);\\n\\n            if(xthMin >= x)\\n            return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458670,
                "title": "c-solution-simple-counting-simple-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    vector<int>getSubarrayBeauty(vector<int>&nums,int k,int x){\\n        vector<int>dp(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k;i++)\\n            dp[nums[i]+50]+=1;\\n        int cnt=0;\\n        for(int j=0;j<=50;j++){\\n            cnt+=dp[j];\\n            if(cnt>=x){\\n                res.push_back(j-50);\\n                break;\\n            }\\n        }\\n        if(cnt<x)\\n            res.push_back(0);\\n        \\n        for(int i=k;i<nums.size();i++){\\n            cnt=0;\\n            dp[nums[i]+50]+=1;\\n            dp[nums[i-k]+50]-=1;\\n            for(int j=0;j<=50;j++){\\n                cnt+=dp[j];\\n                if(cnt>=x){\\n                    res.push_back(j-50);\\n                    break;\\n                }\\n            }\\n            if(cnt<x)\\n                res.push_back(0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    vector<int>getSubarrayBeauty(vector<int>&nums,int k,int x){\\n        vector<int>dp(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k;i++)\\n            dp[nums[i]+50]+=1;\\n        int cnt=0;\\n        for(int j=0;j<=50;j++){\\n            cnt+=dp[j];\\n            if(cnt>=x){\\n                res.push_back(j-50);\\n                break;\\n            }\\n        }\\n        if(cnt<x)\\n            res.push_back(0);\\n        \\n        for(int i=k;i<nums.size();i++){\\n            cnt=0;\\n            dp[nums[i]+50]+=1;\\n            dp[nums[i-k]+50]-=1;\\n            for(int j=0;j<=50;j++){\\n                cnt+=dp[j];\\n                if(cnt>=x){\\n                    res.push_back(j-50);\\n                    break;\\n                }\\n            }\\n            if(cnt<x)\\n                res.push_back(0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458438,
                "title": "faster-than-99-97-maintain-a-histogram-of-seen-negative-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nKeep `cnt[i]` number of times `-i` is in the window\\n`n` number of negatives in the window\\nfirst init the window, `cnt` and `n` wih the first loop over k elements. Then keep updating the window by removing the leftmost element `nums[i-k]` and adding an element to the ritht: `nums[i]`.\\n\\nThe x^th element is found each time by going over the histogram and accounting for up to `x` first elements found.\\nThis could be improved, by maintaining the x^th element and checking if the new element is lower or higher-or-equel than it, but since my solution is the fastest, no one did so.\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        cnt = [0] * 51\\n        n = 0\\n        for i in range(k):\\n            if nums[i] < 0:\\n                n += 1\\n                cnt[-nums[i]] += 1\\n        if n < x:\\n            ret = [0]\\n        else:\\n            j = x\\n            for i in range(50,0,-1):\\n                j -= cnt[i]\\n                if j <= 0:\\n                    ret = [-i]\\n                    break\\n        for i in range(k, len(nums)):\\n            if nums[i-k] < 0:\\n                cnt[-nums[i-k]] -= 1\\n                n -= 1\\n            if nums[i] < 0:\\n                cnt[-nums[i]] += 1\\n                n += 1\\n            if n < x:\\n                ret.append(0)\\n            else:\\n                j = x\\n                for i in range(50,0,-1):\\n                    j -= cnt[i]\\n                    if j <= 0:\\n                        ret.append(-i)\\n                        break\\n        return ret\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        cnt = [0] * 51\\n        n = 0\\n        for i in range(k):\\n            if nums[i] < 0:\\n                n += 1\\n                cnt[-nums[i]] += 1\\n        if n < x:\\n            ret = [0]\\n        else:\\n            j = x\\n            for i in range(50,0,-1):\\n                j -= cnt[i]\\n                if j <= 0:\\n                    ret = [-i]\\n                    break\\n        for i in range(k, len(nums)):\\n            if nums[i-k] < 0:\\n                cnt[-nums[i-k]] -= 1\\n                n -= 1\\n            if nums[i] < 0:\\n                cnt[-nums[i]] += 1\\n                n += 1\\n            if n < x:\\n                ret.append(0)\\n            else:\\n                j = x\\n                for i in range(50,0,-1):\\n                    j -= cnt[i]\\n                    if j <= 0:\\n                        ret.append(-i)\\n                        break\\n        return ret\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457425,
                "title": "c-ordered-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n        }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        vector<int> v;\\n        ordered_set o_set;\\n        for (int i = 0; i < k; i++)\\n        {\\n            o_set.insert(nums[i]);\\n        }\\n        int tp = *(o_set.find_by_order(x-1));\\n        if(tp<0) v.push_back(tp);\\n        else v.push_back(0);\\n        int ct = 0;\\n        for (int i = k; i < nums.size(); i++)\\n        {\\n            // auto it1 = o_set.find(nums[ct]);\\n            myerase(o_set, nums[ct]);\\n            o_set.insert(nums[i]);\\n            int tp1 = *(o_set.find_by_order(x-1));\\n            if(tp1<0) v.push_back(tp1);\\n            else v.push_back(0);\\n            ct++;\\n\\n        }\\n        \\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n        }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        vector<int> v;\\n        ordered_set o_set;\\n        for (int i = 0; i < k; i++)\\n        {\\n            o_set.insert(nums[i]);\\n        }\\n        int tp = *(o_set.find_by_order(x-1));\\n        if(tp<0) v.push_back(tp);\\n        else v.push_back(0);\\n        int ct = 0;\\n        for (int i = k; i < nums.size(); i++)\\n        {\\n            // auto it1 = o_set.find(nums[ct]);\\n            myerase(o_set, nums[ct]);\\n            o_set.insert(nums[i]);\\n            int tp1 = *(o_set.find_by_order(x-1));\\n            if(tp1<0) v.push_back(tp1);\\n            else v.push_back(0);\\n            ct++;\\n\\n        }\\n        \\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3457215,
                "title": "easy-c-solution-using-two-array-with-0-n-time-ans-constant-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntwo array for sort using hashing and sliding window\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int neg[51]={0},pos[51]={0};\\n        int i=0,j=0;\\n        while(i<k-1)\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n        }\\n          vector<int>  ans;\\n      \\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n                int cnt=x;\\n          bool no=true;\\n           for(int l=50;l>0;l--)\\n           {\\n             if(neg[l]>0)\\n             {\\n                 cnt-=neg[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(-l);\\n                 no=false;\\n                 break;\\n             }\\n           }\\n           if(no==true)\\n              {\\n                    for(int l=0;l<=50;l++)\\n           {\\n             if(pos[l]>0)\\n             {\\n                 cnt-=pos[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(0);\\n                 break;\\n             }\\n           }\\n              }\\n              else\\n              no= false;\\n               if(nums[j]<0)\\n            neg[-nums[j]]--;\\n            else\\n            pos[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int neg[51]={0},pos[51]={0};\\n        int i=0,j=0;\\n        while(i<k-1)\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n        }\\n          vector<int>  ans;\\n      \\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n                int cnt=x;\\n          bool no=true;\\n           for(int l=50;l>0;l--)\\n           {\\n             if(neg[l]>0)\\n             {\\n                 cnt-=neg[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(-l);\\n                 no=false;\\n                 break;\\n             }\\n           }\\n           if(no==true)\\n              {\\n                    for(int l=0;l<=50;l++)\\n           {\\n             if(pos[l]>0)\\n             {\\n                 cnt-=pos[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(0);\\n                 break;\\n             }\\n           }\\n              }\\n              else\\n              no= false;\\n               if(nums[j]<0)\\n            neg[-nums[j]]--;\\n            else\\n            pos[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457062,
                "title": "brute-force-c-solution-without-using-stl-with-93-memory-beats",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> v1(101,0);\\n        vector<int> v2(nums.size()-k+1);\\n        int idx=0,c=0,t=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            v1[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            v1[nums[i]+50]++;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c+=v1[j];\\n                if(x<=c)\\n                {\\n                    t=j-50;\\n                    if(t>0)\\n                    {\\n                        v2[idx++]=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        v2[idx++]=t;\\n                        break;\\n                    }\\n                \\n                }\\n            }\\n            c=0;\\n            v1[nums[i-k+1]+50]--;\\n        }\\n        return v2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> v1(101,0);\\n        vector<int> v2(nums.size()-k+1);\\n        int idx=0,c=0,t=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            v1[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            v1[nums[i]+50]++;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c+=v1[j];\\n                if(x<=c)\\n                {\\n                    t=j-50;\\n                    if(t>0)\\n                    {\\n                        v2[idx++]=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        v2[idx++]=t;\\n                        break;\\n                    }\\n                \\n                }\\n            }\\n            c=0;\\n            v1[nums[i-k+1]+50]--;\\n        }\\n        return v2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456713,
                "title": "c-ordered-map-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findMin(map<int,int> mp,int x){\\n        int smallest=0;\\n        for(auto it : mp){\\n        \\n            if(it.first<0){\\n                smallest+=it.second;\\n            }\\n            else return 0;\\n            \\n            if(smallest>=x){\\n            \\n                return it.first;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        long long int n=nums.size();\\n       \\n        map<int,int> mp;\\n        vector<int> ans;\\n       \\n        for(int i=0;i<k-1;i++) mp[nums[i]]++;\\n        \\n        for(int j=k-1;j<n;j++){\\n             \\n                mp[nums[j]]++;\\n             \\n               ans.push_back(findMin(mp,x));\\n           \\n            \\n               mp[nums[j-k+1]]--;\\n        \\n                \\n            }\\n      return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(map<int,int> mp,int x){\\n        int smallest=0;\\n        for(auto it : mp){\\n        \\n            if(it.first<0){\\n                smallest+=it.second;\\n            }\\n            else return 0;\\n            \\n            if(smallest>=x){\\n            \\n                return it.first;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        long long int n=nums.size();\\n       \\n        map<int,int> mp;\\n        vector<int> ans;\\n       \\n        for(int i=0;i<k-1;i++) mp[nums[i]]++;\\n        \\n        for(int j=k-1;j<n;j++){\\n             \\n                mp[nums[j]]++;\\n             \\n               ans.push_back(findMin(mp,x));\\n           \\n            \\n               mp[nums[j-k+1]]--;\\n        \\n                \\n            }\\n      return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456282,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n  int getXthSmallest(unordered_map<int, int>& freq, int x) {\\n    int tot = 0;\\n    for (int i = -50; i < 0; ++i) {\\n      tot += freq[i];\\n      if (tot >= x) return i;\\n    }\\n    return 0;\\n  }\\n  \\n  vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    int n = nums.size();\\n    vector<int> ans;\\n    unordered_map<int, int> freq;\\n    for (int i = 0; i < k; ++i) {\\n      freq[nums[i]]++;\\n    }\\n    ans.push_back(getXthSmallest(freq, x));\\n    for (int i = 1; i <= (n - k); ++i) {\\n      freq[nums[i - 1]]--;\\n      freq[nums[i + k - 1]]++;\\n      ans.push_back(getXthSmallest(freq, x));\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int getXthSmallest(unordered_map<int, int>& freq, int x) {\\n    int tot = 0;\\n    for (int i = -50; i < 0; ++i) {\\n      tot += freq[i];\\n      if (tot >= x) return i;\\n    }\\n    return 0;\\n  }\\n  \\n  vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    int n = nums.size();\\n    vector<int> ans;\\n    unordered_map<int, int> freq;\\n    for (int i = 0; i < k; ++i) {\\n      freq[nums[i]]++;\\n    }\\n    ans.push_back(getXthSmallest(freq, x));\\n    for (int i = 1; i <= (n - k); ++i) {\\n      freq[nums[i - 1]]--;\\n      freq[nums[i + k - 1]]++;\\n      ans.push_back(getXthSmallest(freq, x));\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456059,
                "title": "short-easy-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> cnt(51, 0), res(n - k + 1);\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] <= 0) cnt[-nums[i]]++;\\n            if(i - k >= 0 && nums[i - k] < 0) cnt[-nums[i - k]]--;\\n            int t = 0;\\n            for(int j = 50; j >= 0 && i >= k - 1; j--) {\\n                t += cnt[j];\\n                if(t >= x) {\\n                    res[i - k + 1] = -j;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> cnt(51, 0), res(n - k + 1);\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] <= 0) cnt[-nums[i]]++;\\n            if(i - k >= 0 && nums[i - k] < 0) cnt[-nums[i - k]]--;\\n            int t = 0;\\n            for(int j = 50; j >= 0 && i >= k - 1; j--) {\\n                t += cnt[j];\\n                if(t >= x) {\\n                    res[i - k + 1] = -j;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455999,
                "title": "c-solution-count-negative-numbers-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        SortedDictionary<int, int> negFreqMap = new();\\n        int[] res = new int[nums.Length - k + 1];\\n\\n        for(int i=-50; i<0; i++){\\n            negFreqMap.Add(i, 0);\\n        }\\n\\n        for(int i=0; i<k; i++){\\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        for(int i=k; i<nums.Length; i++){\\n            res[i-k] = GetXthSmallest(negFreqMap, x);\\n\\n            if(nums[i-k] < 0){\\n                negFreqMap[nums[i-k]]--;\\n            }\\n            \\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        res[nums.Length - k] = GetXthSmallest(negFreqMap, x);\\n\\n        return res;\\n    }\\n\\n    private int GetXthSmallest(SortedDictionary<int, int> negFreqMap, int x){\\n        foreach(var kvp in negFreqMap){\\n            x -= kvp.Value;\\n\\n            if(x<=0){\\n                return kvp.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        SortedDictionary<int, int> negFreqMap = new();\\n        int[] res = new int[nums.Length - k + 1];\\n\\n        for(int i=-50; i<0; i++){\\n            negFreqMap.Add(i, 0);\\n        }\\n\\n        for(int i=0; i<k; i++){\\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        for(int i=k; i<nums.Length; i++){\\n            res[i-k] = GetXthSmallest(negFreqMap, x);\\n\\n            if(nums[i-k] < 0){\\n                negFreqMap[nums[i-k]]--;\\n            }\\n            \\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        res[nums.Length - k] = GetXthSmallest(negFreqMap, x);\\n\\n        return res;\\n    }\\n\\n    private int GetXthSmallest(SortedDictionary<int, int> negFreqMap, int x){\\n        foreach(var kvp in negFreqMap){\\n            x -= kvp.Value;\\n\\n            if(x<=0){\\n                return kvp.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455753,
                "title": "sliding-window-map-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int, int> mapp;\\n        vector<int> out;\\n        int ws=0;\\n        for(int we=ws; we<n; we++) {\\n            // we can use the freq of elements in ordered-map to find xth smallest element\\n            mapp[nums[we]]++;\\n            if(we >= k-1) { //if window size(k) hits\\n                int elements=0;\\n                for(auto i: mapp) {\\n                    elements+=i.second;\\n                    if(elements >= x) { // we are at xth smallest\\n                        out.push_back(min(0, i.first)); //if xth element is positive, push 0\\n                        break;\\n                    }\\n                }\\n                mapp[nums[ws]]--;\\n                ws++;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int, int> mapp;\\n        vector<int> out;\\n        int ws=0;\\n        for(int we=ws; we<n; we++) {\\n            // we can use the freq of elements in ordered-map to find xth smallest element\\n            mapp[nums[we]]++;\\n            if(we >= k-1) { //if window size(k) hits\\n                int elements=0;\\n                for(auto i: mapp) {\\n                    elements+=i.second;\\n                    if(elements >= x) { // we are at xth smallest\\n                        out.push_back(min(0, i.first)); //if xth element is positive, push 0\\n                        break;\\n                    }\\n                }\\n                mapp[nums[ws]]--;\\n                ws++;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455665,
                "title": "c-using-sorteddictionary-as-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain sliding windows with **SortedDictionary** data structure. \\nDictionary:\\n* Key = num\\n* Value = count of occurence. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlso has *GetValueForXth* helper function to identify Xth pos of negative numbers in **SortedDictionary**\\n\\n# Complexity\\n- Time complexity:$$O(nlog(k))$$, where N = nums size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(k)$$, SortedDictionary size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- Runtime: 2165 ms\\n- Memory: 65 MB\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        var sorted = new SortedDictionary<int, int>();\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0) {\\n                int prev = nums[i - k];\\n                sorted[prev]--;\\n                if (sorted[prev] == 0) {\\n                    sorted.Remove(prev);\\n                }\\n            }\\n\\n            sorted.TryAdd(nums[i], 0);\\n            sorted[nums[i]]++;\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            res[i - k + 1] = Math.Min(0, GetValueForXth(sorted, x));\\n        }\\n\\n        return res;\\n    }\\n\\n    public int GetValueForXth(SortedDictionary<int, int> sortedMap, int x) {\\n        int count = 0;\\n\\n        foreach (var kv in sortedMap) {\\n            count += kv.Value;\\n            if (count >= x) {\\n\\n                return kv.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n```\\n\\n# Aproach #2 with array counter much faster\\n# Complexity\\n- Time complexity:$$O(n*50))$$, where N = nums size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: additional $$O(50)$$, counter size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- Runtime: 487 ms\\n- Memory: 57.6 MB\\n\\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        int[] counter = new int[50];\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0 && nums[i - k] < 0) {\\n                counter[nums[i - k] + 50]--;\\n            }\\n\\n            if (nums[i] < 0) {\\n                counter[nums[i] + 50]++;\\n            }\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            for (int j = 0, count = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    res[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        var sorted = new SortedDictionary<int, int>();\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0) {\\n                int prev = nums[i - k];\\n                sorted[prev]--;\\n                if (sorted[prev] == 0) {\\n                    sorted.Remove(prev);\\n                }\\n            }\\n\\n            sorted.TryAdd(nums[i], 0);\\n            sorted[nums[i]]++;\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            res[i - k + 1] = Math.Min(0, GetValueForXth(sorted, x));\\n        }\\n\\n        return res;\\n    }\\n\\n    public int GetValueForXth(SortedDictionary<int, int> sortedMap, int x) {\\n        int count = 0;\\n\\n        foreach (var kv in sortedMap) {\\n            count += kv.Value;\\n            if (count >= x) {\\n\\n                return kv.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        int[] counter = new int[50];\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0 && nums[i - k] < 0) {\\n                counter[nums[i - k] + 50]--;\\n            }\\n\\n            if (nums[i] < 0) {\\n                counter[nums[i] + 50]++;\\n            }\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            for (int j = 0, count = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    res[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455222,
                "title": "o-n-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        c= [0]*51\\n        temp = nums[:k]\\n        l=len(nums)\\n        \\n        for neg in temp:\\n            if neg<0:\\n                c[-neg]+=1\\n        ans=[]\\n        sum_=0\\n        for j in range(50,-1,-1):\\n            sum_+=c[j]\\n            if sum_>=x:\\n                ans.append(-j)\\n                break\\n        if sum_ < x:\\n            ans.append(0)\\n        t=0\\n        for i in range(k,l):\\n            sum_=0\\n            if nums[t]<0:\\n                c[-nums[t]]-=1\\n            t+=1\\n            if nums[i]<0:\\n                c[-nums[i]]+=1\\n            for j in range(50,-1,-1):\\n                sum_+=c[j]\\n                if sum_>=x:\\n                    ans.append(-j)\\n                    break\\n            if sum_<x:\\n                ans.append(0)\\n        return ans\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        c= [0]*51\\n        temp = nums[:k]\\n        l=len(nums)\\n        \\n        for neg in temp:\\n            if neg<0:\\n                c[-neg]+=1\\n        ans=[]\\n        sum_=0\\n        for j in range(50,-1,-1):\\n            sum_+=c[j]\\n            if sum_>=x:\\n                ans.append(-j)\\n                break\\n        if sum_ < x:\\n            ans.append(0)\\n        t=0\\n        for i in range(k,l):\\n            sum_=0\\n            if nums[t]<0:\\n                c[-nums[t]]-=1\\n            t+=1\\n            if nums[i]<0:\\n                c[-nums[i]]+=1\\n            for j in range(50,-1,-1):\\n                sum_+=c[j]\\n                if sum_>=x:\\n                    ans.append(-j)\\n                    break\\n            if sum_<x:\\n                ans.append(0)\\n        return ans\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454911,
                "title": "segment-tree-with-sliding-window",
                "content": "```\\n#define ll long long\\nclass Solution {\\n    ll offset=52;\\n    vector<ll> st;\\npublic:\\n    void update(ll tind,ll tl,ll tr,ll ind,ll val){\\n        if(tl>tr)\\n            return;\\n        if(tl==tr){\\n            st[tind]+=val;\\n            return;\\n        }\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        if(tm>=ind)\\n            update(left,tl,tm,ind,val);\\n        else\\n            update(left+1,tm+1,tr,ind,val);\\n        st[tind]=st[left]+st[left|1];\\n    }\\n    \\n    ll findSum(ll tind,ll tl,ll tr,ll ql,ll qr){\\n        if(tl>tr or ql>tr or qr<ql or qr<tl)\\n            return 0;\\n        if(tl>=ql and tr<=qr)\\n            return st[tind];\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        return findSum(left,tl,tm,ql,qr)+findSum(left|1,tm+1,tr,ql,qr);\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) {\\n        ll n=a.size();\\n        vector<int> f;\\n        st.resize(550,0);\\n        \\n        for(ll i=0;i<n;i++){\\n            update(1,1,110,a[i]+offset,1);\\n            if(i>=k)\\n                update(1,1,110,a[i-k]+offset,-1);\\n            if(i>=(k-1)){\\n                int l=1,r=110,ans=0;\\n                while(l<=r){\\n                    ll m=l+((r-l)>>1);\\n                    ll s=findSum(1,1,110,1,m);\\n                    if(s>=x){\\n                        if(m<offset)\\n                            ans=m-offset;\\n                        r=m-1;\\n                    }\\n                    else\\n                        l=m+1;\\n                }\\n                f.push_back(ans);\\n            }\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\n    ll offset=52;\\n    vector<ll> st;\\npublic:\\n    void update(ll tind,ll tl,ll tr,ll ind,ll val){\\n        if(tl>tr)\\n            return;\\n        if(tl==tr){\\n            st[tind]+=val;\\n            return;\\n        }\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        if(tm>=ind)\\n            update(left,tl,tm,ind,val);\\n        else\\n            update(left+1,tm+1,tr,ind,val);\\n        st[tind]=st[left]+st[left|1];\\n    }\\n    \\n    ll findSum(ll tind,ll tl,ll tr,ll ql,ll qr){\\n        if(tl>tr or ql>tr or qr<ql or qr<tl)\\n            return 0;\\n        if(tl>=ql and tr<=qr)\\n            return st[tind];\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        return findSum(left,tl,tm,ql,qr)+findSum(left|1,tm+1,tr,ql,qr);\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) {\\n        ll n=a.size();\\n        vector<int> f;\\n        st.resize(550,0);\\n        \\n        for(ll i=0;i<n;i++){\\n            update(1,1,110,a[i]+offset,1);\\n            if(i>=k)\\n                update(1,1,110,a[i-k]+offset,-1);\\n            if(i>=(k-1)){\\n                int l=1,r=110,ans=0;\\n                while(l<=r){\\n                    ll m=l+((r-l)>>1);\\n                    ll s=findSum(1,1,110,1,m);\\n                    if(s>=x){\\n                        if(m<offset)\\n                            ans=m-offset;\\n                        r=m-1;\\n                    }\\n                    else\\n                        l=m+1;\\n                }\\n                f.push_back(ans);\\n            }\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454308,
                "title": "sliding-window-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) \\n    {\\n        int len = a.size()-k+1;\\n        map <int,int> mp;\\n        vector <int> v;\\n        for (int i = 0, j = 0; i < a.size(); i++) \\n        {\\n            mp[a[i]]++;\\n            int sm = 0;\\n            if (i-j+1 == k)\\n            {\\n                for (auto it : mp)\\n                {\\n                    sm += it.second;\\n                    if (sm >= x) \\n                    {\\n                        v.push_back(min(0,it.first));\\n                        break;\\n                    }\\n                }\\n                mp[a[j]]--;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) \\n    {\\n        int len = a.size()-k+1;\\n        map <int,int> mp;\\n        vector <int> v;\\n        for (int i = 0, j = 0; i < a.size(); i++) \\n        {\\n            mp[a[i]]++;\\n            int sm = 0;\\n            if (i-j+1 == k)\\n            {\\n                for (auto it : mp)\\n                {\\n                    sm += it.second;\\n                    if (sm >= x) \\n                    {\\n                        v.push_back(min(0,it.first));\\n                        break;\\n                    }\\n                }\\n                mp[a[j]]--;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454152,
                "title": "cpp-code-without-using-stl-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int>ans(n-k+1,0),counter(51, 0);\\n    \\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++;\\n        }\\n        int index=0;\\n        for(int i=k-1;i<n;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++; \\n            int count=0;\\n            for(int j=50;j>0;j--)\\n            {\\n                count+=counter[j];\\n                if(count>=x)\\n                {\\n                    ans[index]=-1*(j); \\n                    break;\\n                }\\n            }\\n            if(nums[i-k+1]<0)\\n            {\\n                counter[abs(nums[i-k+1])]--;\\n            }\\n            index++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int>ans(n-k+1,0),counter(51, 0);\\n    \\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++;\\n        }\\n        int index=0;\\n        for(int i=k-1;i<n;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++; \\n            int count=0;\\n            for(int j=50;j>0;j--)\\n            {\\n                count+=counter[j];\\n                if(count>=x)\\n                {\\n                    ans[index]=-1*(j); \\n                    break;\\n                }\\n            }\\n            if(nums[i-k+1]<0)\\n            {\\n                counter[abs(nums[i-k+1])]--;\\n            }\\n            index++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453989,
                "title": "easy-c-solution-without-stl",
                "content": "\\n# Complexity\\n- Time complexity :O(n*100)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int>a(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            a[nums[i]+50]++;\\n            int c=0,mi;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c=c+a[j];\\n                if(c>=x)\\n                {\\n                    mi=min(0,j-50);\\n                    res.push_back(mi);\\n                    break;\\n                }\\n            }\\n            a[nums[i-k+1]+50]--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int>a(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            a[nums[i]+50]++;\\n            int c=0,mi;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c=c+a[j];\\n                if(c>=x)\\n                {\\n                    mi=min(0,j-50);\\n                    res.push_back(mi);\\n                    break;\\n                }\\n            }\\n            a[nums[i-k+1]+50]--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453978,
                "title": "using-sortedlist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        final=[0]*(len(nums)-k+1)\\n        j=0\\n        n=len(nums)\\n        ans=SortedList()\\n        print(ans)\\n        for i,a in enumerate(nums):\\n            ans.add(a)\\n            if(i>=k):\\n                ans.remove(nums[i-k])\\n            if(i>=k-1):\\n                if(ans[x-1]<0):\\n                    final[j]=ans[x-1]\\n                j+=1\\n        return final\\n    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        final=[0]*(len(nums)-k+1)\\n        j=0\\n        n=len(nums)\\n        ans=SortedList()\\n        print(ans)\\n        for i,a in enumerate(nums):\\n            ans.add(a)\\n            if(i>=k):\\n                ans.remove(nums[i-k])\\n            if(i>=k-1):\\n                if(ans[x-1]<0):\\n                    final[j]=ans[x-1]\\n                j+=1\\n        return final\\n    \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453254,
                "title": "c-map-sliding-window-easy-to-understand-clean-code-tc-sc-explained",
                "content": "# Intuition\\nSimple case of sliding window.\\n\\n# Complexity\\n- Time complexity:\\nO(10^5 * 100 * log 100) ~= O(2 * 10^7) at worst case because there can be 100 different numbers in the hashmap\\n\\n- Space complexity:\\nO(100) for the hashmap that we have used in this solution because numbers can range from -50 to 50.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(map<int,int>&mp, int x){\\n        for(auto e: mp){\\n            if(e.second<x){\\n                x-=e.second;\\n            }\\n            else{\\n                if(e.first>0){\\n                    return 0;\\n                }\\n\\n                else{\\n                    return e.first;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int>ans(nums.size()-k+1);\\n        map<int,int>mp;\\n        int i =0, j = 0;\\n\\n        while(j<nums.size()){\\n            mp[nums[j]]++;\\n\\n            if(j-i+1==k){\\n                ans[j-k+1] = func(mp,x);\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0){\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(map<int,int>&mp, int x){\\n        for(auto e: mp){\\n            if(e.second<x){\\n                x-=e.second;\\n            }\\n            else{\\n                if(e.first>0){\\n                    return 0;\\n                }\\n\\n                else{\\n                    return e.first;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int>ans(nums.size()-k+1);\\n        map<int,int>mp;\\n        int i =0, j = 0;\\n\\n        while(j<nums.size()){\\n            mp[nums[j]]++;\\n\\n            if(j-i+1==k){\\n                ans[j-k+1] = func(mp,x);\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0){\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451879,
                "title": "c-simple-sliding-window-counting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding Window + Counting\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n        map<int,int> freq;\\n        vector<int> res; \\n        while(right<n){\\n            freq[nums[right]]++;\\n            if(right>=k-1){\\n                //maintain window\\n                if(right-left+1>k){\\n                    freq[nums[left]]--;\\n                    if(freq[nums[left]]==0){\\n                        freq.erase(nums[left]);\\n                    }\\n                    left++;\\n                }\\n                int ret = helper(freq, x);\\n                res.push_back(ret);\\n            }\\n            right++;\\n        }\\n        return res;\\n    }\\n\\n\\n    int helper(map<int,int>& freq, int x){\\n        int count = 0;\\n\\n        for(auto iter:freq){\\n            if(iter.first>=0){\\n                break;\\n            }\\n            count+=iter.second;\\n            if(count>=x){\\n                return iter.first;\\n            }\\n        }\\n        return 0;\\n\\n\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n        map<int,int> freq;\\n        vector<int> res; \\n        while(right<n){\\n            freq[nums[right]]++;\\n            if(right>=k-1){\\n                //maintain window\\n                if(right-left+1>k){\\n                    freq[nums[left]]--;\\n                    if(freq[nums[left]]==0){\\n                        freq.erase(nums[left]);\\n                    }\\n                    left++;\\n                }\\n                int ret = helper(freq, x);\\n                res.push_back(ret);\\n            }\\n            right++;\\n        }\\n        return res;\\n    }\\n\\n\\n    int helper(map<int,int>& freq, int x){\\n        int count = 0;\\n\\n        for(auto iter:freq){\\n            if(iter.first>=0){\\n                break;\\n            }\\n            count+=iter.second;\\n            if(count>=x){\\n                return iter.first;\\n            }\\n        }\\n        return 0;\\n\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451755,
                "title": "java-treemap-ordered-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans= new int[nums.length-k+1];\\n        TreeMap<Integer, Integer> map= new TreeMap<>();\\n        int count=0;\\n        int ind=0;\\n        int si=0;\\n        int i=0;\\n        for(;i<nums.length;i++)\\n        {\\n             if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {   ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                si++;\\n                count--;\\n            }\\n            if(count<k)\\n            {\\n                if(nums[i]<=0)\\n                {\\n                if(!map.containsKey(nums[i]))\\n                {\\n                    map.put(nums[i],1);\\n                }\\n                else{\\n                    map.put(nums[i],map.get(nums[i])+1);\\n                }\\n                }\\n                count++;\\n            }\\n           \\n        }\\n        if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {\\n                        ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                \\n                si++;\\n                count--;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans= new int[nums.length-k+1];\\n        TreeMap<Integer, Integer> map= new TreeMap<>();\\n        int count=0;\\n        int ind=0;\\n        int si=0;\\n        int i=0;\\n        for(;i<nums.length;i++)\\n        {\\n             if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {   ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                si++;\\n                count--;\\n            }\\n            if(count<k)\\n            {\\n                if(nums[i]<=0)\\n                {\\n                if(!map.containsKey(nums[i]))\\n                {\\n                    map.put(nums[i],1);\\n                }\\n                else{\\n                    map.put(nums[i],map.get(nums[i])+1);\\n                }\\n                }\\n                count++;\\n            }\\n           \\n        }\\n        if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {\\n                        ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                \\n                si++;\\n                count--;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451678,
                "title": "using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int st = 0;\\n        int n = nums.length;\\n        int []res = new int[n - k + 1];\\n        int freq[] = new int[51];\\n        int itr = 0;\\n        for(int i = 0; i < n ;i++){\\n            int ele = -1 * nums[i];\\n            if(ele > 0){\\n                freq[ele]++;\\n            }\\n            if(i >= k - 1){\\n                int cnt = x;\\n                boolean flag = false;\\n                for(int j = 50; j >= 1; j--){\\n                    if(freq[j] > 0){\\n                        cnt -= freq[j];\\n                        if(cnt <= 0){\\n                            flag = true;\\n                            res[itr++] = -j;\\n                            int stEle = -1 * nums[st];\\n                            if(stEle > 0){\\n                                freq[stEle]--;\\n                            }\\n                            st++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag == false){\\n                    res[itr++] = 0;\\n                    int stEle = -1 * nums[st];\\n                    if(stEle > 0){\\n                        freq[stEle]--;\\n                    }\\n                    st++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int st = 0;\\n        int n = nums.length;\\n        int []res = new int[n - k + 1];\\n        int freq[] = new int[51];\\n        int itr = 0;\\n        for(int i = 0; i < n ;i++){\\n            int ele = -1 * nums[i];\\n            if(ele > 0){\\n                freq[ele]++;\\n            }\\n            if(i >= k - 1){\\n                int cnt = x;\\n                boolean flag = false;\\n                for(int j = 50; j >= 1; j--){\\n                    if(freq[j] > 0){\\n                        cnt -= freq[j];\\n                        if(cnt <= 0){\\n                            flag = true;\\n                            res[itr++] = -j;\\n                            int stEle = -1 * nums[st];\\n                            if(stEle > 0){\\n                                freq[stEle]--;\\n                            }\\n                            st++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag == false){\\n                    res[itr++] = 0;\\n                    int stEle = -1 * nums[st];\\n                    if(stEle > 0){\\n                        freq[stEle]--;\\n                    }\\n                    st++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451198,
                "title": "intuitive-simulation-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int smallx(const vector<int>& sub, int x) {\\n        int acc = 0;\\n        for (int i = 0; i <= 50; ++i) {\\n            acc += sub[i];\\n            if (acc >= x) return i - 50;\\n        }\\n        return 0;\\n    }\\n\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> sub(101);\\n        for (int i = 0; i < k - 1; ++i) {\\n            sub[nums[i] + 50]++;\\n        }\\n\\n        vector<int> res;\\n        for (int i = k - 1; i < nums.size(); ++i) {\\n            sub[nums[i] + 50]++;\\n            res.push_back(smallx(sub, x));\\n            sub[nums[i - k + 1] + 50]--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int smallx(const vector<int>& sub, int x) {\\n        int acc = 0;\\n        for (int i = 0; i <= 50; ++i) {\\n            acc += sub[i];\\n            if (acc >= x) return i - 50;\\n        }\\n        return 0;\\n    }\\n\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> sub(101);\\n        for (int i = 0; i < k - 1; ++i) {\\n            sub[nums[i] + 50]++;\\n        }\\n\\n        vector<int> res;\\n        for (int i = k - 1; i < nums.size(); ++i) {\\n            sub[nums[i] + 50]++;\\n            res.push_back(smallx(sub, x));\\n            sub[nums[i - k + 1] + 50]--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451161,
                "title": "100-faster-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[]res = new int[n-k+1];\\n        int[]arr = new int[101];\\n        for(int i = 0;i<n;i++){\\n            arr[nums[i]+50]++;\\n            if(i>=(k-1)){\\n                int t = x;\\n                for(int j = 0;j<=100;j++){ // just created an array of\\n                // 100 numbers and each index storing frq of ith number (offset is 50 because nums\\n                // can be negetive also) . now just iterate and find x largest in each window \\n                    if(t-arr[j] <=0){\\n                        res[i-(k-1)] = j-50;\\n                        if(j>=50) res[i-(k-1)] = 0;\\n                        break;\\n                    }\\n                    t-=arr[j];\\n                }\\n                arr[nums[i-(k-1)]+50]--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[]res = new int[n-k+1];\\n        int[]arr = new int[101];\\n        for(int i = 0;i<n;i++){\\n            arr[nums[i]+50]++;\\n            if(i>=(k-1)){\\n                int t = x;\\n                for(int j = 0;j<=100;j++){ // just created an array of\\n                // 100 numbers and each index storing frq of ith number (offset is 50 because nums\\n                // can be negetive also) . now just iterate and find x largest in each window \\n                    if(t-arr[j] <=0){\\n                        res[i-(k-1)] = j-50;\\n                        if(j>=50) res[i-(k-1)] = 0;\\n                        break;\\n                    }\\n                    t-=arr[j];\\n                }\\n                arr[nums[i-(k-1)]+50]--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451056,
                "title": "c-use-two-multiset-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBorrow the idea from finding the median of the stream, we use the two muliset to store the sliding window, and make sure the begin of the second multiset is the xth smallest value.\\n\\nIn order to handle the multiple value, we use the multiset instead of the set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key point is that we need to make sure the size of the s1 is equal or less than x - 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s1, s2; \\n        int n = nums.size(), j = 0;\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(nums[i]);\\n            if(s1.size() >= x) {\\n                auto tmp = (--s1.end());\\n                s2.insert(*tmp);\\n                s1.erase(tmp);\\n            }\\n            if(s1.size() + s2.size() > k) {\\n                if(s1.find(nums[j]) != s1.end()) {\\n                    s1.erase(s1.find(nums[j++]));\\n                    auto tmp = s2.begin();\\n                    s1.insert(*tmp);\\n                    s2.erase(tmp);\\n                } else \\n                    s2.erase(s2.find(nums[j++]));\\n            }\\n            \\n            if(i >= k - 1) {\\n                int be = *(s2.begin());\\n                ans.push_back(be >= 0 ? 0 : be);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n/*\\n[-3,1,2,-3,0,-3]\\n2\\n1\\n\\ns1 -3\\n\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s1, s2; \\n        int n = nums.size(), j = 0;\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(nums[i]);\\n            if(s1.size() >= x) {\\n                auto tmp = (--s1.end());\\n                s2.insert(*tmp);\\n                s1.erase(tmp);\\n            }\\n            if(s1.size() + s2.size() > k) {\\n                if(s1.find(nums[j]) != s1.end()) {\\n                    s1.erase(s1.find(nums[j++]));\\n                    auto tmp = s2.begin();\\n                    s1.insert(*tmp);\\n                    s2.erase(tmp);\\n                } else \\n                    s2.erase(s2.find(nums[j++]));\\n            }\\n            \\n            if(i >= k - 1) {\\n                int be = *(s2.begin());\\n                ans.push_back(be >= 0 ? 0 : be);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n/*\\n[-3,1,2,-3,0,-3]\\n2\\n1\\n\\ns1 -3\\n\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450916,
                "title": "simple-c-counting",
                "content": "# Intuition\\nThe big hint in this problem is in the bounds  ```-50 <= nums[i] <= 50```. Here we know that we can simply hold an array of length 101 that represents the possible numbers seen in the array nums (-50, -49, ... , -1, 0, 1, ... 49, 50). \\n# Approach\\nSimilarly to how some sorting functions can achieve O(n) time given some bounds on the values to be sorted (ie. our ```-50 <= nums[i] <= 50```) we can simply hold the counts of numbers seen and find the x^th smallest number as we go. \\n\\nNote: helper functions were used to keep code concise\\n\\n# getSubarrayBeauty Algorithm:\\n- First initialize an array (in my code arr) that simple holds the values seen so far in nums. Its size is 101 since there are only 101 unique values in nums. This array holds the counts of each unique number seen. \\n\\n- Initialize a vector (in my code list), this is where we will house our solutions. \\n\\n- Loop through nums\\n    - add the number to arr\\n    - if we have seen k numbers then we can find the xth smallest\\n    - add the xth smallest to the list\\n    - remove the number at the back of the sliding window\\n- Make sure to set all positive x^th smallest numbers to 0\\n- Return list\\n\\n# getXthSmallest Algorithm:\\n- Loop through arr\\n    - if there is an element seen at the index i\\n    - Check if x - arr[i] is negative, if so then we have found x^th smallest\\n    - else, update x and continue to the next number in arr\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int arr[101] = {0};\\n        vector<int> list;\\n        for(int i=0; i<nums.size(); i++) {\\n            addNum(nums[i], arr);\\n            if(i + 1 - k >= 0) {\\n                list.push_back(getXthSmallest(x, arr));\\n                removeNum(nums[i - k + 1], arr);\\n            }\\n        }\\n        for(int i=0; i<list.size(); i++) {\\n            if(list[i] > 0) {\\n                list[i] = 0;\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    private:\\n        void addNum(int num, int arr[101]) {\\n            arr[num + 50]++;\\n        }\\n    \\n    private: \\n        void removeNum(int num, int arr[101]) {\\n            arr[num + 50]--;\\n        }\\n    \\n    private: \\n        int getXthSmallest(int x, int arr[101]) {\\n            for(int i=0; i<101; i++) {\\n                if(arr[i] != 0) {\\n                    int temp = x - arr[i];\\n                    if(temp <= 0) {\\n                        return i - 50;\\n                    } else {\\n                        x = x - arr[i];\\n                    }\\n                }\\n            }\\n            return 0;\\n        }  \\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "```-50 <= nums[i] <= 50```\n```-50 <= nums[i] <= 50```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450842,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) \\n    {\\n        int n = nums.length;\\n        int[] count = new int[50];\\n        for(int i = 0; i<k; i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]++;\\n            }\\n        }\\n        int[] ans = new int[n-k+1];\\n        int j = k;\\n        for(int i = 0; i<n && j<=n; i++, j++)\\n        {\\n            int sum = 0;\\n            boolean flag = false;\\n            for(int m = 0; m < 50; m++)\\n            {\\n                sum += count[m];\\n                if(sum >= x)\\n                {\\n                    ans[i] = m - 50;\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                ans[i] = 0;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]--;\\n            }\\n            if(j<n && nums[j] < 0)\\n            {\\n                count[nums[j] + 50]++;\\n            }\\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) \\n    {\\n        int n = nums.length;\\n        int[] count = new int[50];\\n        for(int i = 0; i<k; i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]++;\\n            }\\n        }\\n        int[] ans = new int[n-k+1];\\n        int j = k;\\n        for(int i = 0; i<n && j<=n; i++, j++)\\n        {\\n            int sum = 0;\\n            boolean flag = false;\\n            for(int m = 0; m < 50; m++)\\n            {\\n                sum += count[m];\\n                if(sum >= x)\\n                {\\n                    ans[i] = m - 50;\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                ans[i] = 0;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]--;\\n            }\\n            if(j<n && nums[j] < 0)\\n            {\\n                count[nums[j] + 50]++;\\n            }\\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450771,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n      var map=new TreeMap<Integer,Integer>();\\n      int n=nums.length,res=0;\\n      var result=new int[n-k+1];\\n      for(int i=0;i<n;i++){\\n          map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n          int out=i-k<0?Integer.MAX_VALUE:nums[i-k];\\n          map.put(out,map.getOrDefault(out,0)-1);\\n          if(i>=k-1){\\n              result[res++]=getsnum(map,x);\\n          }\\n      }return result;\\n    } \\n    private int getsnum(TreeMap<Integer,Integer>map,int x){\\n        int run=0;\\n        for(var entry:map.entrySet()){\\n            int key=entry.getKey();\\n            int val=entry.getValue();\\n            if(key<0){\\n                run+=val;\\n            }\\n            if(run>=x)return key;\\n\\n        }return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n      var map=new TreeMap<Integer,Integer>();\\n      int n=nums.length,res=0;\\n      var result=new int[n-k+1];\\n      for(int i=0;i<n;i++){\\n          map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n          int out=i-k<0?Integer.MAX_VALUE:nums[i-k];\\n          map.put(out,map.getOrDefault(out,0)-1);\\n          if(i>=k-1){\\n              result[res++]=getsnum(map,x);\\n          }\\n      }return result;\\n    } \\n    private int getsnum(TreeMap<Integer,Integer>map,int x){\\n        int run=0;\\n        for(var entry:map.entrySet()){\\n            int key=entry.getKey();\\n            int val=entry.getValue();\\n            if(key<0){\\n                run+=val;\\n            }\\n            if(run>=x)return key;\\n\\n        }return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450680,
                "title": "very-easy-optimized-solution-using-frequency-array",
                "content": "# Complexity\\n- Time complexity: O(n*50)\\n\\n# Code\\n```\\nO(n*50)\\n  int getElement(vector<int>& neg, int x){\\n        int i;\\n        int count=0;\\n        for(int i=50; i>=0; i--){\\n            count+=neg[i];\\n            if(count>=x)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> neg(51,0);\\n        int i=0, j=0;\\n        int n=nums.size();\\n        vector<int> ans;\\n        while(j<n){\\n            //Calculation\\n            if(nums[j]<0)   neg[abs(nums[j])]++;\\n\\n\\n            //if window size is less than k\\n            if(j-i+1<k){\\n                j++;\\n\\n\\n            //else if window size==k\\n            }else if(j-i+1==k){\\n                int res = getElement(neg, x);\\n                ans.push_back(res);\\n                if(nums[i]<0){\\n                    neg[abs(nums[i])]--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nO(n*50)\\n  int getElement(vector<int>& neg, int x){\\n        int i;\\n        int count=0;\\n        for(int i=50; i>=0; i--){\\n            count+=neg[i];\\n            if(count>=x)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> neg(51,0);\\n        int i=0, j=0;\\n        int n=nums.size();\\n        vector<int> ans;\\n        while(j<n){\\n            //Calculation\\n            if(nums[j]<0)   neg[abs(nums[j])]++;\\n\\n\\n            //if window size is less than k\\n            if(j-i+1<k){\\n                j++;\\n\\n\\n            //else if window size==k\\n            }else if(j-i+1==k){\\n                int res = getElement(neg, x);\\n                ans.push_back(res);\\n                if(nums[i]<0){\\n                    neg[abs(nums[i])]--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450622,
                "title": "beats-100-runtime-as-of-24mar2023-38ms-sliding-windows-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince normal approach even using the priority queue it was giving TLE, finally tried sliding window. Keep sliding the windows of k array. And find the xth smallest for the current windows of k element. We do not need to keep all elements of k windows instead just keep/manage negative elements. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create windows queueu of all negative element in the first k index.\\n2. begin the loop of sliding windows.\\n3. in the loop first find the xth smallest as in the current window queue.\\n4. as a logical slide check if the left most element which is outgoing is a negative or not. If it is negative then decrease the frequency counter. This basically means that the number is removed from our calculations. Also similarly check the right most incoming number and if this is negative increment its frequency.\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] res = new int[nums.length-k+1];\\n\\t\\tint[] q = new int[50]; \\n        for(int i=0;i<k;i++) // for all the negative values of k windows count up the frequency: first window\\n            if(nums[i]<0)\\n                q[50+nums[i]]++;\\n        \\n       \\t\\t\\n\\t    for(int i=0;i<nums.length - k+1;i++){ // keep sliding the window\\n\\t    \\tres[i] = getXthSmallest(q,x); // in the current windows find the smallest xth value.\\n\\t    \\tif(i+k>nums.length-1) break; // as windows are sliding in next step check the over-run.\\n            //below is logical shift of window to right. \\n            if (nums[i]<0) //if the left most number is negative then it is being removed so update its frequency.\\n                q[50+nums[i]]--;\\n            if(nums[i+k]<0) // the new number coming in and if it is negative update its frequency.\\n                q[50+nums[i+k]]++;\\n        }\\n\\t    \\n        return res;\\n        \\n    }\\n    \\n    // to find the xth smallest by just going through the each index and adding its frequency.\\n    public int getXthSmallest(int[]q, int x){\\n        int count =0; \\n        int res = 0;\\n\\t\\tfor(int j=0;j<50;j++){\\n\\t\\t    count+=q[j];\\n\\t\\t\\tif(count>=x) {\\n                res = j - 50;\\n                break;\\n            }\\n        }\\n        return res;     \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] res = new int[nums.length-k+1];\\n\\t\\tint[] q = new int[50]; \\n        for(int i=0;i<k;i++) // for all the negative values of k windows count up the frequency: first window\\n            if(nums[i]<0)\\n                q[50+nums[i]]++;\\n        \\n       \\t\\t\\n\\t    for(int i=0;i<nums.length - k+1;i++){ // keep sliding the window\\n\\t    \\tres[i] = getXthSmallest(q,x); // in the current windows find the smallest xth value.\\n\\t    \\tif(i+k>nums.length-1) break; // as windows are sliding in next step check the over-run.\\n            //below is logical shift of window to right. \\n            if (nums[i]<0) //if the left most number is negative then it is being removed so update its frequency.\\n                q[50+nums[i]]--;\\n            if(nums[i+k]<0) // the new number coming in and if it is negative update its frequency.\\n                q[50+nums[i+k]]++;\\n        }\\n\\t    \\n        return res;\\n        \\n    }\\n    \\n    // to find the xth smallest by just going through the each index and adding its frequency.\\n    public int getXthSmallest(int[]q, int x){\\n        int count =0; \\n        int res = 0;\\n\\t\\tfor(int j=0;j<50;j++){\\n\\t\\t    count+=q[j];\\n\\t\\t\\tif(count>=x) {\\n                res = j - 50;\\n                break;\\n            }\\n        }\\n        return res;     \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450606,
                "title": "commented-solution-with-time-complexityma",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nstore the ele in map as in sorted form count the freq , calling the fun in order to find the xth smallest val nd now moving the window size by itrating from k\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:NlogN\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint funCall(map<int, int>&mp, int x){\\n    int cnt=0;\\n    for(auto it:mp){\\n        int val = it.first;\\n        if(val<0){\\n            cnt+=it.second;\\n        }\\n        else{\\n            return 0; //map is already sorted slo if not find return 0\\n        }\\n        if(cnt>=x){\\n            return val;\\n        }\\n    }\\n    return 0;\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int, int>mp;\\n        int n = nums.size();\\n        vector<int>ans(n-k+1);//storing the ans req of size k \\n        for(int i= 0 ; i<k; i++){\\n            mp[nums[i]]++;//storing the freq \\n        }\\n        ans[0]= funCall(mp, x);//findng the x smallest val\\n        for(int i = k ; i <n ; i++){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;//revoing the first ele from window\\n            if(mp[nums[i-k]]==0){\\n                mp.erase(nums[i-k]);\\n            }\\n            ans[i-k+1]= funCall(mp,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint funCall(map<int, int>&mp, int x){\\n    int cnt=0;\\n    for(auto it:mp){\\n        int val = it.first;\\n        if(val<0){\\n            cnt+=it.second;\\n        }\\n        else{\\n            return 0; //map is already sorted slo if not find return 0\\n        }\\n        if(cnt>=x){\\n            return val;\\n        }\\n    }\\n    return 0;\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int, int>mp;\\n        int n = nums.size();\\n        vector<int>ans(n-k+1);//storing the ans req of size k \\n        for(int i= 0 ; i<k; i++){\\n            mp[nums[i]]++;//storing the freq \\n        }\\n        ans[0]= funCall(mp, x);//findng the x smallest val\\n        for(int i = k ; i <n ; i++){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;//revoing the first ele from window\\n            if(mp[nums[i-k]]==0){\\n                mp.erase(nums[i-k]);\\n            }\\n            ans[i-k+1]= funCall(mp,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450541,
                "title": "c-tc-0-n-50-frequency-array-fixed-size-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(int a[],int n,int k){\\n        int i;\\n        int count=0;\\n        for(int i=50;i>=0;i--){\\n            count+=a[i];\\n            if(count>=k)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int a[51];\\n        memset(a,0,sizeof(a));\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)a[nums[i]*-1]++;\\n        }\\n        ans.push_back(findMin(a,51,x));\\n        int n=nums.size();\\n        int start=0,end=k;\\n        while(end<n){\\n            if(nums[start]<0){\\n                if(a[nums[start]*-1]>0)\\n                    a[nums[start]*-1]--;\\n            }\\n            start++;\\n            if(nums[end]<0)\\n                a[nums[end]*-1]++;\\n            end++;\\n            ans.push_back(findMin(a,51,x));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(int a[],int n,int k){\\n        int i;\\n        int count=0;\\n        for(int i=50;i>=0;i--){\\n            count+=a[i];\\n            if(count>=k)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int a[51];\\n        memset(a,0,sizeof(a));\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)a[nums[i]*-1]++;\\n        }\\n        ans.push_back(findMin(a,51,x));\\n        int n=nums.size();\\n        int start=0,end=k;\\n        while(end<n){\\n            if(nums[start]<0){\\n                if(a[nums[start]*-1]>0)\\n                    a[nums[start]*-1]--;\\n            }\\n            start++;\\n            if(nums[end]<0)\\n                a[nums[end]*-1]++;\\n            end++;\\n            ans.push_back(findMin(a,51,x));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450416,
                "title": "kotlin-accepted",
                "content": "# Intuition\\nIt turns out that limits on the size of array elements are important. A completely different approach to subarray analysis.\\n\\n# Approach\\nWindow shift + frequency.\\n\\n# Complexity\\n- Time complexity:\\nO(n(101))\\n\\n- Space complexity:\\nO(n(101))\\n\\n# Code\\n```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        val Counts: Array<Int> = Array(101, {0})\\n        var nn_zam = 0\\n        var sum = 0\\n        var len = nums.size\\n        var rez: Array<Int> = Array(len-k+1, {0})\\n\\n        nn_zam = nums[0]\\n        for (j in 0..k-1) {\\n            Counts[nums[j]+50] +=1\\n        }\\n        \\n        sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n        for (i in 0..49) {\\n            if (Counts[i] == 0) continue\\n            sum += Counts[i] \\n            if (sum>=x) {\\n                rez[0] = i-50\\n                break\\n            }\\n        }\\n        if (k == len) return rez.toIntArray()\\n        for (j in 1..len-k) {\\n            Counts[nn_zam+50] -=1\\n            Counts[nums[j+k-1]+50] +=1\\n            sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n            for (i in 0..49) {\\n                if (Counts[i] == 0) continue\\n                sum += Counts[i] \\n                if (sum>=x) {\\n                    rez[j] = i-50\\n                    break\\n                }\\n            }\\n            nn_zam = nums[j]\\n        }\\n        return rez.toIntArray()\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        val Counts: Array<Int> = Array(101, {0})\\n        var nn_zam = 0\\n        var sum = 0\\n        var len = nums.size\\n        var rez: Array<Int> = Array(len-k+1, {0})\\n\\n        nn_zam = nums[0]\\n        for (j in 0..k-1) {\\n            Counts[nums[j]+50] +=1\\n        }\\n        \\n        sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n        for (i in 0..49) {\\n            if (Counts[i] == 0) continue\\n            sum += Counts[i] \\n            if (sum>=x) {\\n                rez[0] = i-50\\n                break\\n            }\\n        }\\n        if (k == len) return rez.toIntArray()\\n        for (j in 1..len-k) {\\n            Counts[nn_zam+50] -=1\\n            Counts[nums[j+k-1]+50] +=1\\n            sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n            for (i in 0..49) {\\n                if (Counts[i] == 0) continue\\n                sum += Counts[i] \\n                if (sum>=x) {\\n                    rez[j] = i-50\\n                    break\\n                }\\n            }\\n            nn_zam = nums[j]\\n        }\\n        return rez.toIntArray()\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450151,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhash negative elements\\n\\n# Complexity\\n- Time complexity:`O(n * 50) = O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        // size of input array\\n        int n = nums.size();\\n\\n        vector<int>freq(51,0); // store frequecies of negative elements\\n        vector<int>result;     // resultant vector\\n\\n        // some variables\\n        int i = 0 , j = 0;\\n        \\n        // traverse input array\\n        while(j < n){\\n            \\n            // hash only negatives\\n            if(nums[j] < 0) freq[nums[j]*(-1)]++; \\n\\n            // subarray size is less than k\\n            if(j - i + 1 < k) j++;\\n            else if(j - i + 1 == k){  // k size subarray is fixed\\n\\n                // for counting negatives & store possible candidate\\n                int cnt = 0 , negative = 0;\\n\\n                // traverse from back to get xth smallest negative\\n                for(int i=50;i>=1;i--){\\n                    \\n                    // if we have x negatives in subarray it will automatically update negative.. otherwise it will remain 0\\n                    if(freq[i] && cnt < x){\\n                        cnt += freq[i];\\n                        if(cnt >= x) negative = i * (-1); \\n                    }\\n\\n                }\\n\\n                // add negative or 0 in result\\n                result.push_back(negative);\\n\\n                // if first element of subarray is negative then remove it from subarray & hash it\\'s value\\n                if(nums[i] < 0) freq[nums[i]*(-1)]--;\\n\\n                // update the subarray\\n                i++; j++;\\n            }\\n        }\\n        // result \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        // size of input array\\n        int n = nums.size();\\n\\n        vector<int>freq(51,0); // store frequecies of negative elements\\n        vector<int>result;     // resultant vector\\n\\n        // some variables\\n        int i = 0 , j = 0;\\n        \\n        // traverse input array\\n        while(j < n){\\n            \\n            // hash only negatives\\n            if(nums[j] < 0) freq[nums[j]*(-1)]++; \\n\\n            // subarray size is less than k\\n            if(j - i + 1 < k) j++;\\n            else if(j - i + 1 == k){  // k size subarray is fixed\\n\\n                // for counting negatives & store possible candidate\\n                int cnt = 0 , negative = 0;\\n\\n                // traverse from back to get xth smallest negative\\n                for(int i=50;i>=1;i--){\\n                    \\n                    // if we have x negatives in subarray it will automatically update negative.. otherwise it will remain 0\\n                    if(freq[i] && cnt < x){\\n                        cnt += freq[i];\\n                        if(cnt >= x) negative = i * (-1); \\n                    }\\n\\n                }\\n\\n                // add negative or 0 in result\\n                result.push_back(negative);\\n\\n                // if first element of subarray is negative then remove it from subarray & hash it\\'s value\\n                if(nums[i] < 0) freq[nums[i]*(-1)]--;\\n\\n                // update the subarray\\n                i++; j++;\\n            }\\n        }\\n        // result \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450069,
                "title": "o-n-solution",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n         int[] res = new int[nums.length - k + 1];\\n        int[] track = new int[150];\\n        for (int i = 0; i < k; i++) {\\n            track[nums[i] + 50]++;\\n        }\\n        int xClone = x;\\n        for (int i = 0; i < 50; i++) {\\n            if (track[i] > 0) {\\n                if (xClone - track[i] <= 0) {\\n                    res[0] = i - 50;\\n                    xClone -= track[i];\\n                    break;\\n                } else {\\n                    xClone -= track[i];\\n                }\\n            }\\n        }\\n        if (xClone > 0)\\n            res[0] = 0;\\n        for (int i = 0; i < nums.length - k; i++) {\\n            track[nums[i] + 50]--;\\n            track[nums[i + k] + 50]++;\\n            int xClone2 = x;\\n            for (int j = 0; j < 50; j++) {\\n                if (track[j] > 0) {\\n                    if (xClone2 - track[j] <= 0) {\\n                        res[i + 1] = j - 50;\\n                        xClone2 -= track[j];\\n                        break;\\n                    } else {\\n                        xClone2 -= track[j];\\n                    }\\n                }\\n            }\\n            if (xClone2 > 0)\\n                res[i + 1] = 0;\\n        }\\n        return res;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n         int[] res = new int[nums.length - k + 1];\\n        int[] track = new int[150];\\n        for (int i = 0; i < k; i++) {\\n            track[nums[i] + 50]++;\\n        }\\n        int xClone = x;\\n        for (int i = 0; i < 50; i++) {\\n            if (track[i] > 0) {\\n                if (xClone - track[i] <= 0) {\\n                    res[0] = i - 50;\\n                    xClone -= track[i];\\n                    break;\\n                } else {\\n                    xClone -= track[i];\\n                }\\n            }\\n        }\\n        if (xClone > 0)\\n            res[0] = 0;\\n        for (int i = 0; i < nums.length - k; i++) {\\n            track[nums[i] + 50]--;\\n            track[nums[i + k] + 50]++;\\n            int xClone2 = x;\\n            for (int j = 0; j < 50; j++) {\\n                if (track[j] > 0) {\\n                    if (xClone2 - track[j] <= 0) {\\n                        res[i + 1] = j - 50;\\n                        xClone2 -= track[j];\\n                        break;\\n                    } else {\\n                        xClone2 -= track[j];\\n                    }\\n                }\\n            }\\n            if (xClone2 > 0)\\n                res[i + 1] = 0;\\n        }\\n        return res;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449950,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x)\\n    {\\n        var n = nums.Length;\\n        var result = new int[n - k + 1];\\n        var negatives = new List<int>();\\n\\n        InitNegatives(negatives, nums, k);\\n\\n        negatives.Sort();\\n        result[0] = negatives.Count >= x ? negatives[x - 1] : 0;\\n\\n        for (var i = k; i < n; i++)\\n        {\\n            if (nums[i - k] < 0)\\n                negatives.Remove(nums[i - k]);\\n\\n            if (nums[i] < 0)\\n            {\\n                var index = negatives.BinarySearch(nums[i]);\\n\\n                if (index < 0)\\n                    index = ~index;\\n\\n                negatives.Insert(index, nums[i]);\\n            }\\n\\n            result[i - k + 1] = negatives.Count >= x ? negatives[x - 1] : 0;\\n        }\\n\\n        return result;\\n    }\\n\\n    private static void InitNegatives(List<int> negatives, int[] nums, int k)\\n    {\\n        for (var i = 0; i < k; i++)\\n            if (nums[i] < 0)\\n                negatives.Add(nums[i]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x)\\n    {\\n        var n = nums.Length;\\n        var result = new int[n - k + 1];\\n        var negatives = new List<int>();\\n\\n        InitNegatives(negatives, nums, k);\\n\\n        negatives.Sort();\\n        result[0] = negatives.Count >= x ? negatives[x - 1] : 0;\\n\\n        for (var i = k; i < n; i++)\\n        {\\n            if (nums[i - k] < 0)\\n                negatives.Remove(nums[i - k]);\\n\\n            if (nums[i] < 0)\\n            {\\n                var index = negatives.BinarySearch(nums[i]);\\n\\n                if (index < 0)\\n                    index = ~index;\\n\\n                negatives.Insert(index, nums[i]);\\n            }\\n\\n            result[i - k + 1] = negatives.Count >= x ? negatives[x - 1] : 0;\\n        }\\n\\n        return result;\\n    }\\n\\n    private static void InitNegatives(List<int> negatives, int[] nums, int k)\\n    {\\n        for (var i = 0; i < k; i++)\\n            if (nums[i] < 0)\\n                negatives.Add(nums[i]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449712,
                "title": "java-javascript-sliding-window-with-counting-table-counting-sort",
                "content": "### Brute Force, O(n^2), TLE\\n#### Javascript\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    const res = [];\\n    for(let i = 0; i <= n - k; i++){\\n        const list = [];\\n        for(let j = i; j - i + 1 <= k; j++){\\n            list.push(nums[j]);\\n        }\\n        list.sort((a, b) => a - b);\\n        res.push(list[x - 1] > 0 ? 0 : list[x - 1]);\\n    }\\n    return res;\\n};\\n\\n// 0 1 2 3 4 5\\n// X X X X X X\\n//   i     j\\n```\\n\\n---\\n\\nIf you have done a similar problem before, you might immediately think of using maxHeap to maintain size == x to find the xth smallest integer.\\nHere is the list of problems that I have done before. \\n\\n(Medium)\\n[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)\\n[378.\\xA0Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\\n[2583.\\xA0Kth Largest Sum in a Binary Tree (Weekly Contest 335)](https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/)\\n\\n(Hard)\\n[295.\\xA0Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)\\n\\nOf course, if you have more question lists about it, down below your question list is welcome.\\n\\n---\\n\\nOK, come back to the problem.\\n\\nIf we use the sliding window method together when we need to remove the left pointer of the window, we cannot efficiently find a specific number in the heap, which need O(n) time to find, we also get TLE result.\\n\\nHow can we solve this? We can discover the constraints and conditions, `-50 <= nums[i] <= 50`, the range of value is too small, then we can try to use the counting table to calculate the frequency of number in the current window.\\n\\n\\n```\\nindex   =      0   1   2 ... 49  50  51  52\\ncnt     =    [ 0,  0,  0,     0,  0,  0,  0 ]  => size == 101\\nnums[i] =>   -50 -49 -48 ... -1   0   1   2\\n```\\n\\nThen, we don\\'t need to consider the positive number. So, just open the 51 sizes.\\n```\\nindex   =      0   1   2 ... 49  50\\ncnt     =    [ 0,  0,  0,     0,  0 ]  => size == 51\\nnums[i] =>   -50 -49 -48 ... -1   0\\n```\\n\\nNow we can add and remove the number really efficiently, we only traverse the counting table to calculate xth smallest integer.\\n\\n---\\n### **Solution**\\n\\n#### Javascript\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    // Build counting table, we don\\'t need to consider the positive number.\\n    // So, just open the 51 sizes.\\n    const cnt = new Array(51).fill(0);  \\n    const res = [];\\n    let j = 0;\\n    for(let i = 0; i <= n - k; i++){\\n        // window size of k\\n        while(j < n && j - i + 1 <= k){\\n            if(nums[j] <= 0){\\n                cnt[nums[j] + 50]++;\\n            }\\n            j++;\\n        }\\n        \\n        // Search and calculate the number of xth smallest in the counting table, \\n        // If we found, add the current index key into the result.\\n        let numberOf = 0;\\n        for(let key = 0; key < 51; key++){\\n            numberOf += cnt[key];\\n            if(numberOf >= x || key === 50){\\n                res.push(key - 50); // Restore to the original number.\\n                break;\\n            }\\n        }\\n        \\n        // remove the left side\\'s number of the window.\\n        if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n    }\\n    return res;\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n#### Java\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] cnt = new int[51];\\n        int[] res = new int[n - k + 1];\\n        int index = 0, j = 0;\\n        \\n        for(int i = 0; i <= n - k; i++){\\n            while(j < n && j - i + 1 <= k){\\n                if(nums[j] <= 0){\\n                    cnt[nums[j] + 50]++;\\n                }\\n                j++;\\n            }\\n            \\n            int numberOf = 0;\\n            for(int key = 0; key < 51; key++){\\n                numberOf += cnt[key];\\n                if(numberOf >= x || key == 50){\\n                    res[index++] = key - 50;\\n                    break;\\n                }\\n            }\\n            \\n            if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n* Time : O(51n) --> O(n)\\n* Space : O(51)  --> O(1)",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Counting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    const res = [];\\n    for(let i = 0; i <= n - k; i++){\\n        const list = [];\\n        for(let j = i; j - i + 1 <= k; j++){\\n            list.push(nums[j]);\\n        }\\n        list.sort((a, b) => a - b);\\n        res.push(list[x - 1] > 0 ? 0 : list[x - 1]);\\n    }\\n    return res;\\n};\\n\\n// 0 1 2 3 4 5\\n// X X X X X X\\n//   i     j\\n```\n```\\nindex   =      0   1   2 ... 49  50  51  52\\ncnt     =    [ 0,  0,  0,     0,  0,  0,  0 ]  => size == 101\\nnums[i] =>   -50 -49 -48 ... -1   0   1   2\\n```\n```\\nindex   =      0   1   2 ... 49  50\\ncnt     =    [ 0,  0,  0,     0,  0 ]  => size == 51\\nnums[i] =>   -50 -49 -48 ... -1   0\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    // Build counting table, we don\\'t need to consider the positive number.\\n    // So, just open the 51 sizes.\\n    const cnt = new Array(51).fill(0);  \\n    const res = [];\\n    let j = 0;\\n    for(let i = 0; i <= n - k; i++){\\n        // window size of k\\n        while(j < n && j - i + 1 <= k){\\n            if(nums[j] <= 0){\\n                cnt[nums[j] + 50]++;\\n            }\\n            j++;\\n        }\\n        \\n        // Search and calculate the number of xth smallest in the counting table, \\n        // If we found, add the current index key into the result.\\n        let numberOf = 0;\\n        for(let key = 0; key < 51; key++){\\n            numberOf += cnt[key];\\n            if(numberOf >= x || key === 50){\\n                res.push(key - 50); // Restore to the original number.\\n                break;\\n            }\\n        }\\n        \\n        // remove the left side\\'s number of the window.\\n        if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n    }\\n    return res;\\n};\\n```\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] cnt = new int[51];\\n        int[] res = new int[n - k + 1];\\n        int index = 0, j = 0;\\n        \\n        for(int i = 0; i <= n - k; i++){\\n            while(j < n && j - i + 1 <= k){\\n                if(nums[j] <= 0){\\n                    cnt[nums[j] + 50]++;\\n                }\\n                j++;\\n            }\\n            \\n            int numberOf = 0;\\n            for(int key = 0; key < 51; key++){\\n                numberOf += cnt[key];\\n                if(numberOf >= x || key == 50){\\n                    res[index++] = key - 50;\\n                    break;\\n                }\\n            }\\n            \\n            if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449690,
                "title": "python3-sliding-window-and-sorted-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        from sortedcontainers import SortedList\\n        # created a sorted list , with first k elements from nums\\n        s=SortedList()\\n        for i in range(k):\\n            s.add(nums[i])\\n\\n        # append xth smallest number to ans if it is negative, else append 0\\n        # using x-1 since zero based index\\n        if s[x-1] < 0:\\n            ans.append(s[x-1])\\n        else:\\n            ans.append(0)\\n        \\n        # right shift our sliding window by,\\n        # 1. remove nums[i-k] \\n        # 2. add nums[i]\\n        for i in range(k, len(nums)):\\n            s.remove(nums[i-k])\\n            s.add(nums[i])\\n            # append xth smallest number to ans if it is negative, else append 0\\n            if s[x-1] < 0:\\n                ans.append(s[x-1])\\n            else:\\n                ans.append(0)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        from sortedcontainers import SortedList\\n        # created a sorted list , with first k elements from nums\\n        s=SortedList()\\n        for i in range(k):\\n            s.add(nums[i])\\n\\n        # append xth smallest number to ans if it is negative, else append 0\\n        # using x-1 since zero based index\\n        if s[x-1] < 0:\\n            ans.append(s[x-1])\\n        else:\\n            ans.append(0)\\n        \\n        # right shift our sliding window by,\\n        # 1. remove nums[i-k] \\n        # 2. add nums[i]\\n        for i in range(k, len(nums)):\\n            s.remove(nums[i-k])\\n            s.add(nums[i])\\n            # append xth smallest number to ans if it is negative, else append 0\\n            if s[x-1] < 0:\\n                ans.append(s[x-1])\\n            else:\\n                ans.append(0)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1871468,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872730,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872389,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872061,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872592,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872035,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871801,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871441,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 2018090,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1972216,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871468,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872730,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872389,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872061,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872592,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872035,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871801,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871441,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 2018090,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1972216,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1963849,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1873927,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1872141,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871938,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871711,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871650,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871617,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871587,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871576,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871563,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Latest Salaries",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1983461,
                "content": [
                    {
                        "username": "manpreetsarao",
                        "content": "select a.emp_id, a.firstname, a.lastname, a.salary,\\na.department_id from salary a\\njoin salary b on b.salary <=a.salary\\ngroup by emp_id\\norder by emp_id\\n\\ncan anyone help me with this code it worked well for all other test cases but failed the 21-test case without any reason, it gives the same output but still failed"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Senior Citizens",
        "question_content": "<p>You are given a <strong>0-indexed</strong> array of strings <code>details</code>. Each element of <code>details</code> provides information about a given passenger compressed into a string of length <code>15</code>. The system is such that:</p>\n\n<ul>\n\t<li>The first ten characters consist of the phone number of passengers.</li>\n\t<li>The next character denotes the gender of the person.</li>\n\t<li>The following two characters are used to indicate the age of the person.</li>\n\t<li>The last two characters determine the seat allotted to that person.</li>\n</ul>\n\n<p>Return <em>the number of passengers who are <strong>strictly </strong><strong>more than 60 years old</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> details = [&quot;7868190130M7522&quot;,&quot;5303914400F9211&quot;,&quot;9273338290F4010&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> details = [&quot;1313579440F2036&quot;,&quot;2921522980M5644&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> None of the passengers are older than 60.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= details.length &lt;= 100</code></li>\n\t<li><code>details[i].length == 15</code></li>\n\t<li><code>details[i] consists of digits from &#39;0&#39; to &#39;9&#39;.</code></li>\n\t<li><code>details[i][10] is either &#39;M&#39; or &#39;F&#39; or &#39;O&#39;.</code></li>\n\t<li>The phone numbers and seat numbers of the passengers are distinct.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3520270,
                "title": "very-simple-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\n\\n    int countSeniors(vector<string>& details) {\\n        int ans = 0;\\n        for(auto d: details){\\n            int age = (d[11] - \\'0\\') * 10 + (d[12] - \\'0\\');\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n    int countSeniors(vector<string>& details) {\\n        int ans = 0;\\n        for(auto d: details){\\n            int age = (d[11] - \\'0\\') * 10 + (d[12] - \\'0\\');\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520201,
                "title": "python-elegant-short-just-slice",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return sum(int(p[-4:-2]) > 60 for p in details)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return sum(int(p[-4:-2]) > 60 for p in details)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715837,
                "title": "99-memory-beats-a-very-good-solution-for-early-users-as-a-knive-way-and-easily-understandable",
                "content": "# Intuition\\nPLEASE \"UPVOTE\" ME\\n\\n# Approach\\nBRUTE FORCE \\n\\n# Complexity\\n- Time complexity:\\n- n-times\\n\\n- Space complexity:\\n16.2 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        e=[]\\n        d=[]\\n        count=0\\n        for i in range(len(details)):\\n           e.append(details[i][-4]+details[i][-3])\\n        for j in range(len(e)):\\n            x=int(e[j])\\n            d.append(x)\\n        for k in range(len(d)):\\n            if d[k]>60:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        e=[]\\n        d=[]\\n        count=0\\n        for i in range(len(details)):\\n           e.append(details[i][-4]+details[i][-3])\\n        for j in range(len(e)):\\n            x=int(e[j])\\n            d.append(x)\\n        for k in range(len(d)):\\n            if d[k]>60:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525994,
                "title": "python-go-100-faster-easy-solution",
                "content": "# Python\\u2705\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for item in details:\\n            age = int(item[11]+item[12])\\n            if age > 60:\\n                count +=1\\n        return count\\n\\n```\\n# Go\\u2705\\n```\\nfunc countSeniors(details []string) int {\\n    count := 0\\n    for _, item := range details {\\n        firstDigit := string(item[11])\\n        if firstDigit == \"7\" || firstDigit == \"8\" || firstDigit == \"9\" {\\n            count++\\n        } else if firstDigit == \"6\" && string(item[12]) != \"0\"{\\n            count++\\n        }\\n    }\\n    return count\\n}\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for item in details:\\n            age = int(item[11]+item[12])\\n            if age > 60:\\n                count +=1\\n        return count\\n\\n```\n```\\nfunc countSeniors(details []string) int {\\n    count := 0\\n    for _, item := range details {\\n        firstDigit := string(item[11])\\n        if firstDigit == \"7\" || firstDigit == \"8\" || firstDigit == \"9\" {\\n            count++\\n        } else if firstDigit == \"6\" && string(item[12]) != \"0\"{\\n            count++\\n        }\\n    }\\n    return count\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520297,
                "title": "easy-java-solution-0-ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String s:details){\\n            int age=((s.charAt(11)-\\'0\\')*10)+s.charAt(12)-\\'0\\';\\n            if(age>60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String s:details){\\n            int age=((s.charAt(11)-\\'0\\')*10)+s.charAt(12)-\\'0\\';\\n            if(age>60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520240,
                "title": "day-408-one-liner-100-python-java-c-explained",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIterates over each string in the input array, and extracts the age of the person from the string using the \\nsubstring method and the  parseInt method. If the age is greater than 60, the function increments the count. Finally, the function returns the count.\\n\\n# Complexity\\nThe time complexity of this function is O(n), where n is the number of strings in the input array, since we need to iterate over each string in the array. The space complexity is O(1), since we only need to store the count of seniors in memory.\\n\\n\\n\\n# Code\\n```java []\\n    public int countSeniors(String[] details) {\\n        int cnt=0;\\n        for(String tem:details){\\n            int age = Integer.parseInt(tem.substring(11,13));\\n            if(age>60)cnt++;\\n        }return cnt;\\n        \\n    }\\n```\\n```c++ []\\nint countSeniors(vector<string>& details) {\\n    int cnt = 0;\\n    for (string tem : details) {\\n        int age = stoi(tem.substr(11, 2));\\n        if (age > 60) {\\n            cnt++;\\n        }\\n    }\\n    return cnt;\\n}\\n```\\n```python []\\ndef countSeniors(details: List[str]) -> int:\\n    cnt = 0\\n    for tem in details:\\n        age = int(tem[11:13])\\n        if age > 60:\\n            cnt += 1\\n    return cnt\\n```\\n# ONE LINER\\n\\n```PYTHON  []\\ndef countSeniors(details: List[str]) -> int:\\n    return sum(int(detail[11:13]) > 60 for detail in details)\\n```\\n```C++ []\\nint countSeniors(vector<string>& details) {\\n    return count_if(details.begin(), details.end(), [](string detail) {\\n        int age = stoi(detail.substr(11, 2));\\n        return age > 60;\\n    });\\n}\\n```\\n```JAVA []\\npublic int countSeniors(String[] details) {\\n        return (int) Arrays.stream(details)\\n                .mapToInt(detail -> Integer.parseInt(detail.substring(11, 13)))\\n                .filter(age -> age > 60)\\n                .count();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```java []\\n    public int countSeniors(String[] details) {\\n        int cnt=0;\\n        for(String tem:details){\\n            int age = Integer.parseInt(tem.substring(11,13));\\n            if(age>60)cnt++;\\n        }return cnt;\\n        \\n    }\\n```\n```c++ []\\nint countSeniors(vector<string>& details) {\\n    int cnt = 0;\\n    for (string tem : details) {\\n        int age = stoi(tem.substr(11, 2));\\n        if (age > 60) {\\n            cnt++;\\n        }\\n    }\\n    return cnt;\\n}\\n```\n```python []\\ndef countSeniors(details: List[str]) -> int:\\n    cnt = 0\\n    for tem in details:\\n        age = int(tem[11:13])\\n        if age > 60:\\n            cnt += 1\\n    return cnt\\n```\n```PYTHON  []\\ndef countSeniors(details: List[str]) -> int:\\n    return sum(int(detail[11:13]) > 60 for detail in details)\\n```\n```C++ []\\nint countSeniors(vector<string>& details) {\\n    return count_if(details.begin(), details.end(), [](string detail) {\\n        int age = stoi(detail.substr(11, 2));\\n        return age > 60;\\n    });\\n}\\n```\n```JAVA []\\npublic int countSeniors(String[] details) {\\n        return (int) Arrays.stream(details)\\n                .mapToInt(detail -> Integer.parseInt(detail.substring(11, 13)))\\n                .filter(age -> age > 60)\\n                .count();\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3520864,
                "title": "simple-easy-to-understand-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int x = 0;\\n        for(auto &i: details){\\n            // cout<<i[11]<<\" \"<<i[12]<<endl;\\n            if(i[11]>\\'6\\'){\\n                x++;\\n            }else if(i[11]==\\'6\\'&&i[12]>\\'0\\')x++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int x = 0;\\n        for(auto &i: details){\\n            // cout<<i[11]<<\" \"<<i[12]<<endl;\\n            if(i[11]>\\'6\\'){\\n                x++;\\n            }else if(i[11]==\\'6\\'&&i[12]>\\'0\\')x++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520283,
                "title": "brute-force-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for(auto str:details){\\n            int age=(str[11]-\\'0\\')*10+str[12]-\\'0\\';\\n            if(age>60) count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for(auto str:details){\\n            int age=(str[11]-\\'0\\')*10+str[12]-\\'0\\';\\n            if(age>60) count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521469,
                "title": "python-3-1-line-string-comparison-t-m-89-87",
                "content": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n\\n        return sum(d[11:13] > \\'60\\' for d in details)\\n\\n```\\n[https://leetcode.com/problems/number-of-senior-citizens/submissions/985081922/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n\\n        return sum(d[11:13] > \\'60\\' for d in details)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520726,
                "title": "well-explained-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs it given that the 12th and the 13th position of each string is denoting the age of the passenger so we can get the age of each passenger from that position and then we can find out total number of passengers who are older than 60. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Loop through the given string type vector and get the char at index 11 and 12 . Store char of 11th index in a variable (dec) and store char of 12th index in a variable (uni).\\n- Convert them into integer (char-\\'0\\')\\n- Find out the age (age = (dec*10)+uni)\\n- Store age of each passenger in a integer type vector(ageList)\\n- Then find out count of the passengers who are strictly older than 60.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nAt first it is looping through the given vector to find out their age, which will take O(n)\\nThen it is looping through the created vector (ageList) to find out the count of people who are older than 60, it will also take O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nIf the size of the given vector is \\'n\\', then size of the vector which we have created (ageList), will also be n.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int n=details.size();\\n        vector<int>age;\\n        for(int i=0;i<n;i++){\\n            string given=details[i];\\n            char char11=given.at(11);\\n            char char12=given.at(12);\\n            \\n            int dec=char11-\\'0\\';\\n            int uni=char12-\\'0\\';\\n            int num=(dec*10)+uni;\\n            age.push_back(num);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<age.size();i++){\\n            if(age[i]>60){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# One like can be really encouraging\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int n=details.size();\\n        vector<int>age;\\n        for(int i=0;i<n;i++){\\n            string given=details[i];\\n            char char11=given.at(11);\\n            char char12=given.at(12);\\n            \\n            int dec=char11-\\'0\\';\\n            int uni=char12-\\'0\\';\\n            int num=(dec*10)+uni;\\n            age.push_back(num);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<age.size();i++){\\n            if(age[i]>60){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520296,
                "title": "easy-approach-in-java-detailed-explained",
                "content": "# Intuition\\nTake a substring and convert to Integer.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Iterate through all the strings in details and take a substring(startIndex, endIndex)(11, 13).\\n2) Convert that string into Integer to get age.\\n3) Comapre if greater than 60.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int n = details.length, a = 0, count = 0;\\n        for(int i = 0; i < n; i++){\\n            String s = details[i].substring(11, 13);\\n            a = Integer.parseInt(s);\\n            if(a > 60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int n = details.length, a = 0, count = 0;\\n        for(int i = 0; i < n; i++){\\n            String s = details[i].substring(11, 13);\\n            a = Integer.parseInt(s);\\n            if(a > 60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968858,
                "title": "beats-100-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String temp=details[i];\\n            if(((temp.charAt(11)-\\'0\\')*10)+(temp.charAt(12)-\\'0\\')>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String temp=details[i];\\n            if(((temp.charAt(11)-\\'0\\')*10)+(temp.charAt(12)-\\'0\\')>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688200,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        vector<int> ages;\\n        int ans = 0;\\n        for(auto it:details){\\n            string s = it.substr(11,2);\\n            cout<<s<<\" \";\\n            int temp = stoi(s);\\n            ages.push_back(temp);\\n        }\\n        for(auto it:ages){\\n            if(it > 60)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        vector<int> ages;\\n        int ans = 0;\\n        for(auto it:details){\\n            string s = it.substr(11,2);\\n            cout<<s<<\" \";\\n            int temp = stoi(s);\\n            ages.push_back(temp);\\n        }\\n        for(auto it:ages){\\n            if(it > 60)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3600476,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int countSeniors(vector<string>& details) {\\n      \\n\\t  int count = 0 ; \\n        for(int i=0 ;i<details.size();i++){\\n           int a = (details[i][11]-\\'0\\')*10 + (details[i][12]-\\'0\\');\\n            if(a>60) count++ ; }\\n        return count ;  \\n    }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countSeniors(vector<string>& details) {\\n      \\n\\t  int count = 0 ; \\n        for(int i=0 ;i<details.size();i++){\\n           int a = (details[i][11]-\\'0\\')*10 + (details[i][12]-\\'0\\');\\n            if(a>60) count++ ; }",
                "codeTag": "Java"
            },
            {
                "id": 3561065,
                "title": "simple-solution-runtime-0-ms-100-beats-memory-41-3-mb-99-5-beats",
                "content": "# Approach\\nApproach:\\n1. Initialize a variable `count` to 0.\\n2. Iterate over each string `s` in the `details` array.\\n3. Extract the age information from `s` by converting the characters at indices 11 and 12 to an integer.\\n4. If the extracted age is greater than 60, increment the `count` variable.\\n5. After iterating over all strings, return the final `count` value, which represents the number of passengers who are strictly more than 60 years old.\\n\\nAlgorithm:\\n1. Initialize `count` to 0.\\n2. For each `s` in `details`, do steps 3-4.\\n   - Extract the age from `s` using `(s.charAt(11) - \\'0\\') * 10 + (s.charAt(12) - \\'0\\')`.\\n   - If the age is greater than 60, increment `count`.\\n3. Return `count` as the result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String s : details){\\n            int age = (s.charAt(11) - \\'0\\') * 10 + (s.charAt(12) - \\'0\\');\\n            if(age > 60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String s : details){\\n            int age = (s.charAt(11) - \\'0\\') * 10 + (s.charAt(12) - \\'0\\');\\n            if(age > 60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557401,
                "title": "number-of-senior-citizens-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int i, count=0;\\n        for(i=0 ; i<details.size() ; i++)\\n        {\\n            if((int)details[i][11]>54 || (int)details[i][11]==54 && (int)details[i][12]>=49)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6888ef7d-dc4b-4298-8f1b-4d3f4848d9ad_1684899245.7077143.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int i, count=0;\\n        for(i=0 ; i<details.size() ; i++)\\n        {\\n            if((int)details[i][11]>54 || (int)details[i][11]==54 && (int)details[i][12]>=49)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520885,
                "title": "c-python-easy-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(auto i : details) {\\n            if(i[11] - \\'0\\' > 6) count++;\\n            else if (i[11] - \\'0\\' == 6 && i[12] - \\'0\\' > 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for i in details:\\n            if int(i[11]) > 6:\\n                count += 1\\n            elif int(i[11]) == 6 and int(i[12]) > 0:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(auto i : details) {\\n            if(i[11] - \\'0\\' > 6) count++;\\n            else if (i[11] - \\'0\\' == 6 && i[12] - \\'0\\' > 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for i in details:\\n            if int(i[11]) > 6:\\n                count += 1\\n            elif int(i[11]) == 6 and int(i[12]) > 0:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520256,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] s) {\\n        int ans=0;\\n        for(String ss:s){\\n            int a1=ss.charAt(11)-\\'0\\';\\n            int a2=ss.charAt(12)-\\'0\\'; \\n            if((a1*10)+a2>60)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] s) {\\n        int ans=0;\\n        for(String ss:s){\\n            int a1=ss.charAt(11)-\\'0\\';\\n            int a2=ss.charAt(12)-\\'0\\'; \\n            if((a1*10)+a2>60)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072941,
                "title": "beats-93-of-users-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& nums) {\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(stoi(nums[i].substr(11,2)) > 60)ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& nums) {\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(stoi(nums[i].substr(11,2)) > 60)ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793211,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int n,c=0;\\n        for (n=0;n<details.length;n++){\\n            int i=Integer.parseInt(details[n].substring(11,13));\\n            if(i>60) {\\n                 c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int n,c=0;\\n        for (n=0;n<details.length;n++){\\n            int i=Integer.parseInt(details[n].substring(11,13));\\n            if(i>60) {\\n                 c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786738,
                "title": "java-easy-solution-0ms",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n      int count = 0;\\n      for(String s : details) {\\n          int age = Integer.parseInt(s.substring(11, 13));\\n          if(age > 60) count ++;\\n      }  \\n      return count;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n      int count = 0;\\n      for(String s : details) {\\n          int age = Integer.parseInt(s.substring(11, 13));\\n          if(age > 60) count ++;\\n      }  \\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751961,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String i : details)\\n        {\\n           if( check(i)==true) // check for separete word\\n           {\\n               count++;\\n           }\\n        }\\n        return count;\\n    }\\n    public Boolean check(String s)\\n    {\\n        char ch1=s.charAt(s.length()-4);\\n        char ch2=s.charAt(s.length()-3);\\nif(ch1==54 && ch2==48)\\n{\\n    return false;\\n}\\n      if(ch1>=54 && ch2>=48)\\n      {\\n          return true;\\n      }\\n      return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String i : details)\\n        {\\n           if( check(i)==true) // check for separete word\\n           {\\n               count++;\\n           }\\n        }\\n        return count;\\n    }\\n    public Boolean check(String s)\\n    {\\n        char ch1=s.charAt(s.length()-4);\\n        char ch2=s.charAt(s.length()-3);\\nif(ch1==54 && ch2==48)\\n{\\n    return false;\\n}\\n      if(ch1>=54 && ch2>=48)\\n      {\\n          return true;\\n      }\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714030,
                "title": "js-one-liner-beats-94",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(detail => parseInt(detail.substring(11,13)) > 60).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(detail => parseInt(detail.substring(11,13)) > 60).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670082,
                "title": "2678-number-of-senior-citizens-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n\\n        for(int i=0; i<details.length; i++){\\n            String d = details[i].substring(11,13);\\n            int s = Integer.parseInt(d);\\n            if(s>60){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n\\n        for(int i=0; i<details.length; i++){\\n            String d = details[i].substring(11,13);\\n            int s = Integer.parseInt(d);\\n            if(s>60){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666867,
                "title": "easy-c-solution-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for(int i=0; i<details.size(); i++)\\n        {\\n            int l = details[i][11], r=details[i][12];\\n            if(l>=\\'6\\')\\n            {\\n                if(l==\\'6\\' && r==\\'0\\')\\n                    continue;\\n                else \\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for(int i=0; i<details.size(); i++)\\n        {\\n            int l = details[i][11], r=details[i][12];\\n            if(l>=\\'6\\')\\n            {\\n                if(l==\\'6\\' && r==\\'0\\')\\n                    continue;\\n                else \\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653835,
                "title": "simplest-way",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int res = 0;\\n        for (auto info: details)\\n            if (stoi(info.substr(11, 2)) > 60) res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int res = 0;\\n        for (auto info: details)\\n            if (stoi(info.substr(11, 2)) > 60) res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578685,
                "title": "100-efficient-solution-java-with-t-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String i : details){\\n        int age_of_passengers = Integer.parseInt(i.substring(11,13));\\n        \\n            if(age_of_passengers > 60) \\n                count++;\\n        \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String i : details){\\n        int age_of_passengers = Integer.parseInt(i.substring(11,13));\\n        \\n            if(age_of_passengers > 60) \\n                count++;\\n        \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563889,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(el => el.slice(-4, -2) > 60).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(el => el.slice(-4, -2) > 60).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558388,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func countSeniors(_ details: [String]) -> Int {\\n        details\\n            .map { Int(String($0.suffix(4).prefix(2)))! }\\n            .filter { $0 > 60 }\\n            .count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countSeniors(_ details: [String]) -> Int {\\n        details\\n            .map { Int(String($0.suffix(4).prefix(2)))! }\\n            .filter { $0 > 60 }\\n            .count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543268,
                "title": "beginners-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String data: details){\\n            // System.out.println(data.substring(11,13));\\n            int age= Integer.parseInt(data.substring(11,13));\\n            if(age>60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String data: details){\\n            // System.out.println(data.substring(11,13));\\n            int age= Integer.parseInt(data.substring(11,13));\\n            if(age>60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537834,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String x : details) {\\n            count += ((x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\') > 60 ? 1 : 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String x : details) {\\n            count += ((x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\') > 60 ? 1 : 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537822,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String x : details) {\\n            count += Integer.parseInt(x.substring(11, 13)) > 60 ? 1 : 0;            \\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String x : details) {\\n            count += Integer.parseInt(x.substring(11, 13)) > 60 ? 1 : 0;            \\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537811,
                "title": "simple-java-solution-for-beginners-1ms-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            String s = x.substring(11, 13);\\n            age = Integer.parseInt(s);\\n            count += age > 60 ? 1 : 0;            \\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            String s = x.substring(11, 13);\\n            age = Integer.parseInt(s);\\n            count += age > 60 ? 1 : 0;            \\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537787,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            age = (x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\';\\n            count += age > 60 ? 1 : 0;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            age = (x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\';\\n            count += age > 60 ? 1 : 0;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526089,
                "title": "substring-and-parseint",
                "content": "# Code\\n```\\npublic int countSeniors(String[] details) {\\n    int res = 0;\\n    for (String d : details) {\\n        int age = Integer.parseInt(d.substring(11, 13));\\n        if (age > 60) res++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countSeniors(String[] details) {\\n    int res = 0;\\n    for (String d : details) {\\n        int age = Integer.parseInt(d.substring(11, 13));\\n        if (age > 60) res++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524881,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let counter = 0;\\n    for(let i = 0;i < details.length;i++){\\n        if(details[i][11].concat(details[i][12]) > 60){\\n            counter++\\n        }\\n    }\\n    return counter\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let counter = 0;\\n    for(let i = 0;i < details.length;i++){\\n        if(details[i][11].concat(details[i][12]) > 60){\\n            counter++\\n        }\\n    }\\n    return counter\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524223,
                "title": "java-very-easy-beats-100-time-and-space",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] d) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : d) {\\n            sb.append(s.charAt(s.length() - 4));\\n            sb.append(s.charAt(s.length() - 3));\\n            sb.append(\" \");\\n        }\\n        String str =  sb.toString();\\n        String res[] = str.split(\" \");\\n        for(String i : res) {\\n            if(Integer.valueOf(i) > 60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] d) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : d) {\\n            sb.append(s.charAt(s.length() - 4));\\n            sb.append(s.charAt(s.length() - 3));\\n            sb.append(\" \");\\n        }\\n        String str =  sb.toString();\\n        String res[] = str.split(\" \");\\n        for(String i : res) {\\n            if(Integer.valueOf(i) > 60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523009,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt=0;\\n        for(auto it: details){\\n            int num=(it[11]-\\'0\\')*10+(it[12]-\\'0\\');\\n            cout<<num<<endl;\\n            if(num>60){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt=0;\\n        for(auto it: details){\\n            int num=(it[11]-\\'0\\')*10+(it[12]-\\'0\\');\\n            cout<<num<<endl;\\n            if(num>60){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3523007,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countSeniors(vector<string>& details) \\n    {\\n        int ans=0;\\n        for(auto p: details)\\n        {\\n            string op1(1,p[11]);\\n            string op2(1,p[12]);\\n            string age=op1+op2;\\n            int a=stoi(age);\\n            if(a>60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countSeniors(vector<string>& details) \\n    {\\n        int ans=0;\\n        for(auto p: details)\\n        {\\n            string op1(1,p[11]);\\n            string op2(1,p[12]);\\n            string age=op1+op2;\\n            int a=stoi(age);\\n            if(a>60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521937,
                "title": "c-easy-to-understand-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for (int i=0; i<details.size(); i++){\\n            string s= details[i];\\n            int age= s[11]-\\'0\\';\\n            age*=10;\\n            age+= (s[12]-\\'0\\');\\n            if (age>60)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for (int i=0; i<details.size(); i++){\\n            string s= details[i];\\n            int age= s[11]-\\'0\\';\\n            age*=10;\\n            age+= (s[12]-\\'0\\');\\n            if (age>60)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521856,
                "title": "simple-typescript-solution-o-n-time-o-1-space",
                "content": "# Intuition\\nWe need to get the age from the string positions, convert it to number and compare\\n\\n# Approach\\nSince the position of the age digits is always fixed at **11 and 12**,\\n \\n## Step 1: Take out the substring of age from the given string,\\n\\n## Step 2: Use the unary + operator to directly convert the string to a number and then compare it. \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Simple String, Indexes, to Number Solution \\nfunction countSeniors(details: string[]): number {\\n    let result:number = 0;\\n    for (let person of details){\\n        if(+person.substring(11,13) > 60){\\n            result+=1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// Simple String, Indexes, to Number Solution \\nfunction countSeniors(details: string[]): number {\\n    let result:number = 0;\\n    for (let person of details){\\n        if(+person.substring(11,13) > 60){\\n            result+=1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521222,
                "title": "c-simple-parse-no-built-in-string-number-conversion-0ms-13-4mb",
                "content": "Pretty plain problem in which we basically just need to code what we are told to code:\\n* reading the age \"hidden\" in the personal details of each user;\\n* check if said age is above the required threshold and if so increase a counter;\\n* finally, `return` the counter.\\n\\nOur support variables are going to be:\\n* `res`, our counter initially set to `0`;\\n* `age`, that we will use when parsing each user.\\n\\nFor each `code` in `details`, we will:\\n* extract the digits at indexes `11` and `12`;\\n* subtract `0` from both of them to get their value in numbers;\\n* multiply the first by `10` and add the second, to get their value in numbers to get the `age`;\\n* check if `age > 60` and if so increase `res` by `1`.\\n\\nOnce done, we can `return` `res`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        // support variables\\n        int res = 0, age;\\n        // parsing details\\n        for (auto &code: details) {\\n            age = (code[11] - \\'0\\') * 10 + (code[12] - \\'0\\');\\n            if (age > 60) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        // support variables\\n        int res = 0, age;\\n        // parsing details\\n        for (auto &code: details) {\\n            age = (code[11] - \\'0\\') * 10 + (code[12] - \\'0\\');\\n            if (age > 60) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520805,
                "title": "easy-java-solution-100-faster-0ms",
                "content": "\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n     int count=0;\\n     for(int i=0;i<details.length;i++)\\n     {\\n         int a=details[i].charAt(11)-\\'0\\';\\n         a*=10;\\n         a+=details[i].charAt(12)-\\'0\\';\\n         if(a>60)\\n         {\\n             count++;\\n         }\\n     }\\n     return count;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n     int count=0;\\n     for(int i=0;i<details.length;i++)\\n     {\\n         int a=details[i].charAt(11)-\\'0\\';\\n         a*=10;\\n         a+=details[i].charAt(12)-\\'0\\';\\n         if(a>60)\\n         {\\n             count++;\\n         }\\n     }\\n     return count;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520729,
                "title": "easy-solution-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint countSeniors(char ** details, int detailsSize){\\n    int a=0,ind=0;\\n    \\n    for(int i=0;i<detailsSize;i++)\\n    { \\n        a=10*(details[i][11]-\\'0\\')+details[i][12]-\\'0\\';\\n        if(a>60)\\n        {\\n            ind++;\\n        }\\n    }\\n    return ind;\\n}\\n            \\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint countSeniors(char ** details, int detailsSize){\\n    int a=0,ind=0;\\n    \\n    for(int i=0;i<detailsSize;i++)\\n    { \\n        a=10*(details[i][11]-\\'0\\')+details[i][12]-\\'0\\';\\n        if(a>60)\\n        {\\n            ind++;\\n        }\\n    }\\n    return ind;\\n}\\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520715,
                "title": "full-explanation-in-steps-simplest-approach",
                "content": "# Intuition\\n- The solution follows a simple and straightforward approach to count the number of passengers who are more than 60 years old.\\n- By iterating through each string in the `details` array, we extract the age of each passenger.\\n- The age is obtained by extracting the relevant substring from each string and converting it into an integer.\\n- If the extracted age is greater than 60, it means the passenger is a senior citizen, so we increment the `count` variable.\\n- Finally, we return the total count of senior passengers as the result.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a variable, `count`, to keep track of the number of passengers who are strictly more than 60 years old.\\n2. Iterate through each string, `str`, in the `details` array.\\n3. Extract the age of the passenger from the substring `str.substring(11, 13)`.\\n4. Convert the extracted age from a string to an integer using `Integer.parseInt()`.\\n5. If the age is greater than 60, increment the `count` variable.\\n6. Return the final value of `count` as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for (String str : details) {\\n            int age = Integer.parseInt(str.substring(11, 13));\\n            if (age > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/2f224d46-b7c5-4a7a-add2-fbfa74226820_1683998207.5152655.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for (String str : details) {\\n            int age = Integer.parseInt(str.substring(11, 13));\\n            if (age > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520691,
                "title": "count-if",
                "content": "**C++**\\n```cpp\\nint countSeniors(vector<string>& details) {\\n    return count_if(begin(details), end(details), [](const auto &d){\\n        return d.substr(11, 2) > \"60\";\\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countSeniors(vector<string>& details) {\\n    return count_if(begin(details), end(details), [](const auto &d){\\n        return d.substr(11, 2) > \"60\";\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520634,
                "title": "c-easy-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& d) {\\n        string x;\\n        int cnt=0;\\n        for(int i=0;i<d.size();i++){\\n            string cand = d[i]; \\n            string ans;\\n            ans.push_back(cand[11]);\\n            ans.push_back(cand[12]); \\n            int num=0;\\n            num=num*10+ans[0]-\\'0\\';\\n            num = num*10+ans[1]-\\'0\\'; \\n        } \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& d) {\\n        string x;\\n        int cnt=0;\\n        for(int i=0;i<d.size();i++){\\n            string cand = d[i]; \\n            string ans;\\n            ans.push_back(cand[11]);\\n            ans.push_back(cand[12]); \\n            int num=0;\\n            num=num*10+ans[0]-\\'0\\';\\n            num = num*10+ans[1]-\\'0\\'; \\n        } \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520526,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        senior_citizen=0\\n        for detail in details:\\n            age=int(detail[11:13])\\n            if age>60:\\n                senior_citizen+=1\\n\\n\\n        return senior_citizen       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        senior_citizen=0\\n        for detail in details:\\n            age=int(detail[11:13])\\n            if age>60:\\n                senior_citizen+=1\\n\\n\\n        return senior_citizen       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520470,
                "title": "the-best-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int countSeniors(vector<string>& details) {\\n    int res = 0;\\n    for(string& st: details){\\n      res += (st[11] > \\'6\\' || st[11] == \\'6\\' && st[12] > \\'0\\');\\n    }\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countSeniors(vector<string>& details) {\\n    int res = 0;\\n    for(string& st: details){\\n      res += (st[11] > \\'6\\' || st[11] == \\'6\\' && st[12] > \\'0\\');\\n    }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520432,
                "title": "implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& d) {\\n        int ans = 0;\\n        for(string&e: d){\\n            string s = e.substr(11,2);\\n            int age = stoi(s);\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& d) {\\n        int ans = 0;\\n        for(string&e: d){\\n            string s = e.substr(11,2);\\n            int age = stoi(s);\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520379,
                "title": "c-1-line",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int CountSeniors(string[] details) \\n    {\\n        return details.Count(d => int.Parse(d.Substring(11, 2)) > 60);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int CountSeniors(string[] details) \\n    {\\n        return details.Count(d => int.Parse(d.Substring(11, 2)) > 60);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520322,
                "title": "java-beats-100-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < details.length; i++) {\\n            int age = (details[i].charAt(11) - \\'0\\') * 10 + (details[i].charAt(12) - \\'0\\');\\n            \\n            if(age > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < details.length; i++) {\\n            int age = (details[i].charAt(11) - \\'0\\') * 10 + (details[i].charAt(12) - \\'0\\');\\n            \\n            if(age > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520317,
                "title": "very-easy-java-code-with-explaination",
                "content": "# Algorithm steps\\n\\nAlgorithm for countSeniors method in the Solution class:\\n\\n1. Create a method called \"countSeniors\" that takes a String array called \"details\" as input and returns an integer.\\n2. Initialize an integer variable called \"res\" to 0.\\n3. For each String \"s\" in the \"details\" array, do the following:\\n   a. Extract the age of the person from the String \"s\" by getting the substring that starts at index 11 and ends at index 13 (exclusive).\\n   b. Convert the extracted substring to an integer using the \"Integer.parseInt\" method.\\n   c. If the age is greater than 60, increment the \"res\" variable by 1.\\n4. After processing all the elements in the \"details\" array, return the value of \"res\" as the count of seniors.\\n\\nOverall, this algorithm counts the number of seniors in an array of Strings by iterating through each String, extracting the age of the person, and incrementing the count if the age is greater than 60.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int res = 0;\\n        for (String s : details) {\\n            if (Integer.parseInt(s.substring(11, 13)) > 60) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int res = 0;\\n        for (String s : details) {\\n            if (Integer.parseInt(s.substring(11, 13)) > 60) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520300,
                "title": "simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            if(possible(details[i].substring(11,13))){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean possible(String age){\\n        int a=Integer.parseInt(age);\\n        if(a>60){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            if(possible(details[i].substring(11,13))){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean possible(String age){\\n        int a=Integer.parseInt(age);\\n        if(a>60){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520252,
                "title": "using-java-substring",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int countaccepted = 0;\\n        for(int i = 0; i < details.length; i++){\\n            String passen = details[i];\\n            String AgeOfPerson = passen.substring(11, 13);\\n            int Age = Integer.parseInt(AgeOfPerson);\\n            if(Age > 60){\\n                countaccepted++;\\n            }\\n        }\\n        return countaccepted;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int countaccepted = 0;\\n        for(int i = 0; i < details.length; i++){\\n            String passen = details[i];\\n            String AgeOfPerson = passen.substring(11, 13);\\n            int Age = Integer.parseInt(AgeOfPerson);\\n            if(Age > 60){\\n                countaccepted++;\\n            }\\n        }\\n        return countaccepted;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520229,
                "title": "c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(auto ele: details){\\n            int num = (ele[11]-\\'0\\')*10 + (ele[12]-\\'0\\');\\n            if(num > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(auto ele: details){\\n            int num = (ele[11]-\\'0\\')*10 + (ele[12]-\\'0\\');\\n            if(num > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520216,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n         int count = 0;\\n\\n        for (const string& info : details) {\\n        int age = stoi(info.substr(11, 2));\\n\\n        if (age > 60) {\\n            count++;\\n        }\\n    }\\n\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n         int count = 0;\\n\\n        for (const string& info : details) {\\n        int age = stoi(info.substr(11, 2));\\n\\n        if (age > 60) {\\n            count++;\\n        }\\n    }\\n\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100480,
                "title": "pyhton3-easy-solution",
                "content": "# Intuition\\n![Screenshot from 2023-09-28 16-26-13.png](https://assets.leetcode.com/users/images/cf2dbe13-5f16-4b4c-bf9f-6bf3dc6d7d63_1695900383.1126714.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: list[str]) -> int:\\n        return sum(1 for x in details if int(x[11:13]) > 60)\\n\\n\\nobj = Solution()\\nprint(obj.countSeniors(details=[\"7868190130M7522\", \"5303914400F9211\", \"9273338290F4010\"]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: list[str]) -> int:\\n        return sum(1 for x in details if int(x[11:13]) > 60)\\n\\n\\nobj = Solution()\\nprint(obj.countSeniors(details=[\"7868190130M7522\", \"5303914400F9211\", \"9273338290F4010\"]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097530,
                "title": "easiest-solution-that-can-exist-0ms-best-solution-java-anyone-can-do-leetcode",
                "content": "\\n\\n# Complexity\\n- Time complexity: 0ms\\nBeats 100.00%of users with Java\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 40.42MB\\nBeats 99.83%of users with Java\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String d: details)\\n        {\\n            if(d.charAt(11)==\\'6\\' && d.charAt(12)==\\'0\\')\\n            continue;\\n            else if(d.charAt(11)>=\\'6\\' && d.charAt(12)>=\\'0\\')\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String d: details)\\n        {\\n            if(d.charAt(11)==\\'6\\' && d.charAt(12)==\\'0\\')\\n            continue;\\n            else if(d.charAt(11)>=\\'6\\' && d.charAt(12)>=\\'0\\')\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096639,
                "title": "task-solution-number-of-senior-citizens-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n        count = 0\\n        for I in details:\\n          if int(I[11:-2]) > 60:\\n              count += 1\\n        return count\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n        count = 0\\n        for I in details:\\n          if int(I[11:-2]) > 60:\\n              count += 1\\n        return count\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093688,
                "title": "1ms-o-n-simple-java-solution-number-of-senior-citizens",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String person: details) {\\n            int age = Integer.valueOf(person.substring(11,13));\\n            if (age>60) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String person: details) {\\n            int age = Integer.valueOf(person.substring(11,13));\\n            if (age>60) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092812,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String str=details[i];\\n            int a=(str.charAt(11)-\\'0\\')*10+(str.charAt(12)-\\'0\\');\\n            if(a>60)\\n            {\\n                c+=1;\\n            }\\n            \\n        }\\n        return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String str=details[i];\\n            int a=(str.charAt(11)-\\'0\\')*10+(str.charAt(12)-\\'0\\');\\n            if(a>60)\\n            {\\n                c+=1;\\n            }\\n            \\n        }\\n        return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086189,
                "title": "python-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for i in details:\\n            if int(i[11:13]) > 60:\\n                count += 1\\n        return count\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for i in details:\\n            if int(i[11:13]) > 60:\\n                count += 1\\n        return count\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085861,
                "title": "best-method-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n               // please upvote if it help you\\uD83D\\uDE0A\\uD83D\\uDE0A\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(int i=0;i<details.size();i++){\\n            if(details[i][11]>=\\'6\\' && details[i][12]>\\'0\\') ans++;\\n            else if(details[i][11]>\\'6\\' && details[i][12]>=\\'0\\') ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n               // please upvote if it help you\\uD83D\\uDE0A\\uD83D\\uDE0A\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(int i=0;i<details.size();i++){\\n            if(details[i][11]>=\\'6\\' && details[i][12]>\\'0\\') ans++;\\n            else if(details[i][11]>\\'6\\' && details[i][12]>=\\'0\\') ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085666,
                "title": "220103011",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans = 0;\\n        for (var x : details) {\\n            int age = Integer.parseInt(x.substring(11, 13));\\n            if (age > 60) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans = 0;\\n        for (var x : details) {\\n            int age = Integer.parseInt(x.substring(11, 13));\\n            if (age > 60) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083839,
                "title": "java-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\nint age=((details[i].charAt(11)-\\'0\\'))*10+(details[i].charAt(12))-\\'0\\';\\n    if(age>60)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\nint age=((details[i].charAt(11)-\\'0\\'))*10+(details[i].charAt(12))-\\'0\\';\\n    if(age>60)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082724,
                "title": "java-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n        int count = 0 ;\\n\\n        for(String detail : details){\\n            int age = detail.charAt(12) - \\'0\\' ;\\n            age = 10 * (detail.charAt(11) - \\'0\\') + age ;\\n            if(age > 60){\\n                count++ ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n        int count = 0 ;\\n\\n        for(String detail : details){\\n            int age = detail.charAt(12) - \\'0\\' ;\\n            age = 10 * (detail.charAt(11) - \\'0\\') + age ;\\n            if(age > 60){\\n                count++ ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080968,
                "title": "my-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        suj=0\\n        for i in range(len(details)):\\n            if int(details[i][11]+details[i][12])>60:\\n                suj+=1\\n        return suj\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        suj=0\\n        for i in range(len(details)):\\n            if int(details[i][11]+details[i][12])>60:\\n                suj+=1\\n        return suj\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080778,
                "title": "java-oms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n            int count=0;\\n\\n        for (int i=0;i<details.length;i++)\\n        {\\n//checking if the passenger is 60 if not then then increse the count++\\n            if (details[i].charAt(11)==\\'6\\')\\n            {\\n                if (details[i].charAt(12)>\\'0\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            else\\n            {\\n                if (details[i].charAt(11)>\\'6\\')\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n            int count=0;\\n\\n        for (int i=0;i<details.length;i++)\\n        {\\n//checking if the passenger is 60 if not then then increse the count++\\n            if (details[i].charAt(11)==\\'6\\')\\n            {\\n                if (details[i].charAt(12)>\\'0\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            else\\n            {\\n                if (details[i].charAt(11)>\\'6\\')\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074837,
                "title": "java-easy-3-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(int i = 0; i < details.length; i++) {\\n            if(Integer.parseInt(details[i].substring(11, 13)) > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(int i = 0; i < details.length; i++) {\\n            if(Integer.parseInt(details[i].substring(11, 13)) > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072872,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\n//  0-9 - phone \\n//  10 - gender\\n//  11-12 - age\\nvar countSeniors = function(details) {\\n    let count = 0\\n    details.forEach(passenger => {\\n        if(parseInt(passenger[11]+passenger[12]) > 60){\\n            count++;\\n        }\\n    })\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\n//  0-9 - phone \\n//  10 - gender\\n//  11-12 - age\\nvar countSeniors = function(details) {\\n    let count = 0\\n    details.forEach(passenger => {\\n        if(parseInt(passenger[11]+passenger[12]) > 60){\\n            count++;\\n        }\\n    })\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071544,
                "title": "easy-java-solution-100-beats-5-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int answer =0;\\n        for(String detail:details){\\n            int age = detail.charAt(11)-\\'0\\';\\n            age = age*10 + detail.charAt(12)-\\'0\\';\\n            if(age > 60) answer++;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int answer =0;\\n        for(String detail:details){\\n            int age = detail.charAt(11)-\\'0\\';\\n            age = age*10 + detail.charAt(12)-\\'0\\';\\n            if(age > 60) answer++;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070795,
                "title": "solution-by-latif-problem-no-2678-number-of-senior-citizens",
                "content": "# Approach\\n1) First, we need to slice the age from all the given string in array\\n2) Then we need to store all the sliced string into another new string array (here I used store[])\\n3) Now, convert all the sliced string into integer by using parseInt technique\\n4) After converting string to integer, count those integers which is greater than 60 (here I used \\'result\\' to count)\\n5) Return the result\\n\\n# Runtime - 1ms\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int result = 0;\\n        String[] store = new String[details.length];\\n        for(int i=0;i<store.length;i++){\\n            store[i] = details[i].substring(11,13);\\n        }\\n        int[] arr = convert(store);\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i] > 60){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int[] convert(String[] store){\\n        int[] arr = new int[store.length];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i] = Integer.parseInt(store[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int result = 0;\\n        String[] store = new String[details.length];\\n        for(int i=0;i<store.length;i++){\\n            store[i] = details[i].substring(11,13);\\n        }\\n        int[] arr = convert(store);\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i] > 60){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int[] convert(String[] store){\\n        int[] arr = new int[store.length];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i] = Integer.parseInt(store[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068712,
                "title": "very-simple-code-dead-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        String s;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            s=details[i].substring(11,13);\\n            if(Integer.valueOf(s)>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        String s;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            s=details[i].substring(11,13);\\n            if(Integer.valueOf(s)>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067997,
                "title": "java-0-ms-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe know that the age digits are at the 11th and 12th index of the string so compare the ascii values for >60.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n       for(int i=0;i<details.length;i++){\\n\\n       if((details[i].charAt(11)>54)){\\n           c++;\\n       }\\n       if((details[i].charAt(11)==54)&&(details[i].charAt(12)>48))\\n        c++;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n       for(int i=0;i<details.length;i++){\\n\\n       if((details[i].charAt(11)>54)){\\n           c++;\\n       }\\n       if((details[i].charAt(11)==54)&&(details[i].charAt(12)>48))\\n        c++;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067604,
                "title": "python-simple-approach-beats-96-17-ms-13-4-mb-string-slicing",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for passenger in details:\\n            if int(passenger[-4:-2]) > 60:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for passenger in details:\\n            if int(passenger[-4:-2]) > 60:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067531,
                "title": "python-simple-approach-beats-96-17ms-13-36-mb",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for passenger in details:\\n            if int(passenger[-4:-2]) > 60:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for passenger in details:\\n            if int(passenger[-4:-2]) > 60:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066002,
                "title": "python3-simple-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for val in details:\\n            if int(val[11:13]) > 60:  # [11: 13-1] \\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for val in details:\\n            if int(val[11:13]) > 60:  # [11: 13-1] \\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065367,
                "title": "python3-solution-with-using-position-calculating",
                "content": "# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        res = 0\\n        for detail in details:\\n            if int(detail[11:len(detail) - 2]) > 60: res += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        res = 0\\n        for detail in details:\\n            if int(detail[11:len(detail) - 2]) > 60: res += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055914,
                "title": "java-easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            age = (x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\';\\n            count += age > 60 ? 1 : 0;\\n            \\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            age = (x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\';\\n            count += age > 60 ? 1 : 0;\\n            \\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055231,
                "title": "beats-96-in-memory-python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        c=0\\n        for ele in details:\\n            if int(ele[-4:-2])>60:\\n                c+=1\\n        return c\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        c=0\\n        for ele in details:\\n            if int(ele[-4:-2])>60:\\n                c+=1\\n        return c\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055077,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   func countSeniors(_ details: [String]) -> Int {\\n    var str = details\\n    \\n    for i in 0..<details.count {\\n        str[i].removeFirst(11)\\n        str[i].removeLast(2)\\n    }\\n    \\n    let result = str.filter { Int($0)! > 60 }.count\\n    \\n    return result\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n   func countSeniors(_ details: [String]) -> Int {\\n    var str = details\\n    \\n    for i in 0..<details.count {\\n        str[i].removeFirst(11)\\n        str[i].removeLast(2)\\n    }\\n    \\n    let result = str.filter { Int($0)! > 60 }.count\\n    \\n    return result\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053108,
                "title": "easy-solution",
                "content": "# 1ms\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int noOfSeniorCitizens = 0;\\n        for(String  detail: details){\\n            if(Integer.parseInt(detail.substring(11,13)) > 60)\\n               noOfSeniorCitizens++; \\n        }\\n        return noOfSeniorCitizens;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int noOfSeniorCitizens = 0;\\n        for(String  detail: details){\\n            if(Integer.parseInt(detail.substring(11,13)) > 60)\\n               noOfSeniorCitizens++; \\n        }\\n        return noOfSeniorCitizens;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049260,
                "title": "java-straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for (String s : details) {\\n            int age = Integer.parseInt(s.substring(11, 13));\\n            if (age > 60) count++;\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for (String s : details) {\\n            int age = Integer.parseInt(s.substring(11, 13));\\n            if (age > 60) count++;\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048585,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count=0\\n        for i in details:\\n            a=i[11:13]\\n            \\n            if a>\\'60\\':\\n                count+=1\\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count=0\\n        for i in details:\\n            a=i[11:13]\\n            \\n            if a>\\'60\\':\\n                count+=1\\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048431,
                "title": "const-js-ts-single-line-solution-great-explanation",
                "content": "This code defines a TypeScript function `countSeniors` that takes an array of strings called `details` as its input. Each string in the `details` array is assumed to represent some kind of information. The goal of this function is to count the number of seniors in the given `details` array based on some criteria.\\n\\nHere\\'s a breakdown of the code and an analysis of its time and space complexity:\\n\\n```typescript\\nfunction countSeniors(details: string[]): number {\\n    return details.reduce((acc, curr) => +curr.slice(11, 13) > 60 ? acc + 1 : acc, 0);\\n};\\n```\\n\\n1. `details.reduce(...)`: This line uses the `reduce` method to iterate through the `details` array, accumulating a count of seniors. The `reduce` method applies a given function to each element of the array and maintains an accumulator (`acc`) to keep track of the count.\\n\\n2. `(acc, curr) => +curr.slice(11, 13) > 60 ? acc + 1 : acc`: This is the function that is called for each element in the `details` array during the reduction process. It takes two parameters: `acc` (the accumulator) and `curr` (the current element being processed).\\n\\n   - `curr.slice(11, 13)`: This extracts a substring of `curr` from index 11 to 12 (inclusive). This assumes that the format of each string in the `details` array is such that characters at index 11 and 12 represent the age of the person.\\n   \\n   - `+curr.slice(11, 13) > 60`: This converts the extracted substring to a number and checks if it\\'s greater than 60, indicating that the person is a senior.\\n\\n   - If the condition is true (`+curr.slice(11, 13) > 60`), it increments the accumulator (`acc + 1`); otherwise, it leaves the accumulator unchanged (`acc`).\\n\\n3. The `reduce` method starts with an initial accumulator value of `0` (`0` is the second argument to `reduce`).\\n\\nTime Complexity:\\n- The `reduce` method iterates through each element in the `details` array exactly once. For each element, it performs some constant-time operations, including slicing the string and comparing the age to 60. Therefore, the time complexity of this function is O(n), where n is the number of elements in the `details` array.\\n\\nSpace Complexity:\\n- The space complexity is O(1) because the function uses a constant amount of memory regardless of the size of the `details` array. It doesn\\'t create any additional data structures that grow with the input size.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction countSeniors(details: string[]): number {\\n    return details.reduce((acc, curr) => +curr.slice(11, 13) > 60 ? acc + 1 : acc, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047622,
                "title": "220103354",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int index = 0;\\n        for(String str: details){\\n            String s = str.substring(11, 13);\\n            int age = Integer.parseInt(s);\\n            if (age>60){index++;}\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int index = 0;\\n        for(String str: details){\\n            String s = str.substring(11, 13);\\n            int age = Integer.parseInt(s);\\n            if (age>60){index++;}\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047503,
                "title": "220103341",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n         int count = 0;\\n        for(String i : details){\\n        int age_of_passengers = Integer.parseInt(i.substring(11,13));\\n        \\n            if(age_of_passengers > 60) \\n                count++;\\n        \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n         int count = 0;\\n        for(String i : details){\\n        int age_of_passengers = Integer.parseInt(i.substring(11,13));\\n        \\n            if(age_of_passengers > 60) \\n                count++;\\n        \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047462,
                "title": "220103086",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        \\n        for (String detail : details) {\\n            int jas = Integer.parseInt(detail.substring(11, 13));\\n            if (jas > 60) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        \\n        for (String detail : details) {\\n            int jas = Integer.parseInt(detail.substring(11, 13));\\n            if (jas > 60) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044156,
                "title": "simple-and-easy-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  Using wrapper classes converting string into integer and thus finding the solution\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String temp = details[i];\\n            int age = Integer.parseInt(temp.substring(11,13));\\n            if(age>60)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String temp = details[i];\\n            int age = Integer.parseInt(temp.substring(11,13));\\n            if(age>60)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041383,
                "title": "java-simple-python-solution-for-beginners-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            int val1=Integer.valueOf(details[i].substring(11,13));\\n            if(val1>60){\\n                ans=ans+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            int val1=Integer.valueOf(details[i].substring(11,13));\\n            if(val1>60){\\n                ans=ans+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039864,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            if( ((10*(details[i].charAt(11)-\\'0\\'))+details[i].charAt(12)-\\'0\\')>60){\\n                ans+=1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            if( ((10*(details[i].charAt(11)-\\'0\\'))+details[i].charAt(12)-\\'0\\')>60){\\n                ans+=1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036012,
                "title": "sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nQuestion itself is very clear no need to think any thing\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt was straigth forward to convert the substring into int and check the condition and return the result\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int r=0;\\n        int x=0;\\n        for(String s : details){\\n            x = Integer.parseInt(s.substring(11,13));\\n            if(x>60){\\n                r++;\\n            }\\n        }\\n        return r;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int r=0;\\n        int x=0;\\n        for(String s : details){\\n            x = Integer.parseInt(s.substring(11,13));\\n            if(x>60){\\n                r++;\\n            }\\n        }\\n        return r;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035266,
                "title": "very-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int seniors = 0;\\n        for(String s : details){\\n            int age = Integer.parseInt(s.substring(11,13));\\n            if(age > 60)\\n            seniors++;\\n        }\\n        return seniors;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int seniors = 0;\\n        for(String s : details){\\n            int age = Integer.parseInt(s.substring(11,13));\\n            if(age > 60)\\n            seniors++;\\n        }\\n        return seniors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030940,
                "title": "easy-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String e:details)\\n        {\\n            int num1=Integer.parseInt(String.valueOf(e.charAt(11)));\\n            int num2=Integer.parseInt(String.valueOf(e.charAt(12)));\\n            int age=num1*10+num2;\\n            if(age>60)\\n            count++;\\n        }\\n        return count;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String e:details)\\n        {\\n            int num1=Integer.parseInt(String.valueOf(e.charAt(11)));\\n            int num2=Integer.parseInt(String.valueOf(e.charAt(12)));\\n            int age=num1*10+num2;\\n            if(age>60)\\n            count++;\\n        }\\n        return count;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028536,
                "title": "python-one-line",
                "content": "# Approach\\nThis is not difficult. It was first try. I am open for a better suggestions.\\n\\n# Stats\\n- Runtime: 47ms, beats 85.59% of users with Python3\\n\\n- Memory: 16.34MB, beats 40.75% of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return len([int(age[11:13]) for age in details if int(age[11:13]) > 60])\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return len([int(age[11:13]) for age in details if int(age[11:13]) > 60])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022884,
                "title": "java-simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n\\n        for(int i=0; i<details.length; i++){\\n            \\n         if(((details[i].charAt(11) - \\'0\\' == 6) && \\n         (details[i].charAt(12) - \\'0\\' > 0) )  || \\n         (details[i].charAt(11) - \\'0\\' > 6) )  {\\n                count++;\\n         }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n\\n        for(int i=0; i<details.length; i++){\\n            \\n         if(((details[i].charAt(11) - \\'0\\' == 6) && \\n         (details[i].charAt(12) - \\'0\\' > 0) )  || \\n         (details[i].charAt(11) - \\'0\\' > 6) )  {\\n                count++;\\n         }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021461,
                "title": "c-foreach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let res = 0;\\n    details.forEach((detail) => {\\n        let age = detail.slice(11, 13);\\n        if(age > 60){\\n            res++;\\n        }\\n    });\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let res = 0;\\n    details.forEach((detail) => {\\n        let age = detail.slice(11, 13);\\n        if(age > 60){\\n            res++;\\n        }\\n    });\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019391,
                "title": "very-very-easy-solution-in-c-using-substr",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> string problem so think all parameter about string \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int res = 0;\\n        for (auto it: details)\\n            if (stoi(it.substr(11, 2)) > 60) \\n            res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int res = 0;\\n        for (auto it: details)\\n            if (stoi(it.substr(11, 2)) > 60) \\n            res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018400,
                "title": "beats-100-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for( int i = 0; i < details.length; i++ ){\\n            if(details[i].charAt(11) >= \\'6\\'  ){\\n                if(details[i].charAt(11) == \\'6\\' && details[i].charAt(12) < \\'1\\' )\\n                continue;\\n                else\\n                count++;\\n            }\\n            \\n        } \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for( int i = 0; i < details.length; i++ ){\\n            if(details[i].charAt(11) >= \\'6\\'  ){\\n                if(details[i].charAt(11) == \\'6\\' && details[i].charAt(12) < \\'1\\' )\\n                continue;\\n                else\\n                count++;\\n            }\\n            \\n        } \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017451,
                "title": "one-liner-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {int a=0;\\n        for(int i=0;i<details.length;i++){\\n            if(((details[i].charAt(11)-\\'0\\')*10+details[i].charAt(12)-\\'0\\')>60)a++;\\n        }\\n                return a;                        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {int a=0;\\n        for(int i=0;i<details.length;i++){\\n            if(((details[i].charAt(11)-\\'0\\')*10+details[i].charAt(12)-\\'0\\')>60)a++;\\n        }\\n                return a;                        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016636,
                "title": "easy-way-to-understanding-the-program-beginners-friendly-2-ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] a) {\\n\\n\\n        int count=0;\\n\\t\\t//String []a={\"1313579440F2036\",\"2921522980M5644\"};\\n\\t\\tfor(int i=0;i<a.length;i++)\\n\\t\\t{\\n\\t\\t\\tString c=\"\";\\n\\t\\t\\tc=c+a[i].charAt(11);\\n\\t\\t\\tc=c+a[i].charAt(12);\\n\\t\\t\\tint d=Integer.parseInt(c);\\n\\t\\t\\tif(d>60)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] a) {\\n\\n\\n        int count=0;\\n\\t\\t//String []a={\"1313579440F2036\",\"2921522980M5644\"};\\n\\t\\tfor(int i=0;i<a.length;i++)\\n\\t\\t{\\n\\t\\t\\tString c=\"\";\\n\\t\\t\\tc=c+a[i].charAt(11);\\n\\t\\t\\tc=c+a[i].charAt(12);\\n\\t\\t\\tint d=Integer.parseInt(c);\\n\\t\\t\\tif(d>60)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014570,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let count = 0\\n\\n    details.forEach((detail) => {\\n        let age = detail.slice(11, 13)\\n        if(+age > 60) count++\\n    })\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let count = 0\\n\\n    details.forEach((detail) => {\\n        let age = detail.slice(11, 13)\\n        if(+age > 60) count++\\n    })\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011615,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n int countSeniors(List<String> details) {\\n  int result = 0;\\n  for (int i = 0; i < details.length; i++) {\\n    if (int.parse(details[i][11]) >= 6 && int.parse(details[i][12]) > 0||\\n        int.parse(details[i][11]) > 6) {\\n      result++;\\n    }\\n  }\\n  return result;\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n int countSeniors(List<String> details) {\\n  int result = 0;\\n  for (int i = 0; i < details.length; i++) {\\n    if (int.parse(details[i][11]) >= 6 && int.parse(details[i][12]) > 0||\\n        int.parse(details[i][11]) > 6) {\\n      result++;\\n    }\\n  }\\n  return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010237,
                "title": "90-easy-js-solution",
                "content": "# Code\\n```\\nfor: \\nvar countSeniors = function (details) {\\n  let count = 0;\\n\\n  for (let i = 0; i < details.length; i++) {\\n    let age = details[i].slice(11, 13);\\n    if (age > 60) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n\\n\\nreduce: \\nconst countSeniors = (details) => {\\n  return details.reduce((count, detail) => {\\n    const age = Number(detail.slice(11, 13));\\n    return age > 60 ? count + 1 : count;\\n  }, 0);\\n};\\n\\n\\nforEach: \\nconst countSeniors = (details) => {\\n  let count = 0;\\n\\n  details.forEach((person) => {\\n    let age = person.slice(11, 13);\\n    return age > 60 ? count++ : count;\\n  });\\n\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor: \\nvar countSeniors = function (details) {\\n  let count = 0;\\n\\n  for (let i = 0; i < details.length; i++) {\\n    let age = details[i].slice(11, 13);\\n    if (age > 60) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n\\n\\nreduce: \\nconst countSeniors = (details) => {\\n  return details.reduce((count, detail) => {\\n    const age = Number(detail.slice(11, 13));\\n    return age > 60 ? count + 1 : count;\\n  }, 0);\\n};\\n\\n\\nforEach: \\nconst countSeniors = (details) => {\\n  let count = 0;\\n\\n  details.forEach((person) => {\\n    let age = person.slice(11, 13);\\n    return age > 60 ? count++ : count;\\n  });\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008719,
                "title": "typescript-javascript-solution",
                "content": "```\\nfunction countSeniors(details: string[]): number {\\n    const ages: string[] = details.filter(id => +id.slice(-4, -2) > 60);\\n    return ages.length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction countSeniors(details: string[]): number {\\n    const ages: string[] = details.filter(id => +id.slice(-4, -2) > 60);\\n    return ages.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007036,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for (int i=0;i<details.size();i++)\\n        {\\n            string s=details[i];\\n            if ((s[11]>=\\'6\\' && s[12]>\\'0\\') || s[11]>\\'6\\')\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for (int i=0;i<details.size();i++)\\n        {\\n            string s=details[i];\\n            if ((s[11]>=\\'6\\' && s[12]>\\'0\\') || s[11]>\\'6\\')\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005503,
                "title": "world-easy-solution-in-js-anyone-can-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let number = 0;\\n    for (let i = 0; i<details.length ; i++){\\n        let x = checkage(details[i]);\\n        if(x){\\n            number++;\\n        }\\n    }\\n    return number;\\n};\\nfunction checkage(detail)\\n{\\n    // console.log(detail[12]);\\n    if(detail[11]==6){\\n        if(detail[12]>0){\\n            return true;\\n        }\\n        // return true;\\n    }else if(detail[11]>6){\\n        return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let number = 0;\\n    for (let i = 0; i<details.length ; i++){\\n        let x = checkage(details[i]);\\n        if(x){\\n            number++;\\n        }\\n    }\\n    return number;\\n};\\nfunction checkage(detail)\\n{\\n    // console.log(detail[12]);\\n    if(detail[11]==6){\\n        if(detail[12]>0){\\n            return true;\\n        }\\n        // return true;\\n    }else if(detail[11]>6){\\n        return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003470,
                "title": "elixir-simple-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec count_seniors(details :: [String.t()]) :: integer\\n  def count_seniors(details) do\\n    details\\n    |> Enum.reduce(0, fn d, acc ->\\n      age = d |> String.slice(11..12) |> String.to_integer()\\n\\n      if age > 60 do\\n        acc + 1\\n      else\\n        acc\\n      end\\n    end)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec count_seniors(details :: [String.t()]) :: integer\\n  def count_seniors(details) do\\n    details\\n    |> Enum.reduce(0, fn d, acc ->\\n      age = d |> String.slice(11..12) |> String.to_integer()\\n\\n      if age > 60 do\\n        acc + 1\\n      else\\n        acc\\n      end\\n    end)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4000912,
                "title": "4ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for (int i=0;i<details.size();i++){\\n            if (details[i].substr(11,2)>\"60\"){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for (int i=0;i<details.size();i++){\\n            if (details[i].substr(11,2)>\"60\"){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999519,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        a = 0\\n        for i in details:\\n            b = int(i[11:13])\\n            if b > 60:\\n                a+=1\\n        return a\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        a = 0\\n        for i in details:\\n            b = int(i[11:13])\\n            if b > 60:\\n                a+=1\\n        return a\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992134,
                "title": "easy-solution-in-java-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(int i = 0; i<details.length; i++){\\n            String s = details[i];\\n            if(((s.charAt(11)-\\'0\\')*10) + (s.charAt(12)-\\'0\\')>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(int i = 0; i<details.length; i++){\\n            String s = details[i];\\n            if(((s.charAt(11)-\\'0\\')*10) + (s.charAt(12)-\\'0\\')>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984916,
                "title": "c-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt=0;\\n        for(string& st:details){\\n            cnt+=(st[11]> \\'6\\' || st[11]==\\'6\\' && st[12]>\\'0\\');\\n        }\\n        return   cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt=0;\\n        for(string& st:details){\\n            cnt+=(st[11]> \\'6\\' || st[11]==\\'6\\' && st[12]>\\'0\\');\\n        }\\n        return   cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984009,
                "title": "java-easy-solution-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] d) {\\n        String s=\"\";\\n        int count=0;\\n        for(int i=0;i<d.length;i++){\\n             String a=d[i];\\n             s=a.substring(11,13);\\n             int n=Integer.parseInt(s);\\n              if(n>60){\\n                  count++;\\n              }\\n        }\\n       return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] d) {\\n        String s=\"\";\\n        int count=0;\\n        for(int i=0;i<d.length;i++){\\n             String a=d[i];\\n             s=a.substring(11,13);\\n             int n=Integer.parseInt(s);\\n              if(n>60){\\n                  count++;\\n              }\\n        }\\n       return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982087,
                "title": "javascript-simple-filter",
                "content": "# Code\\n```\\nvar countSeniors = function(details) {\\n    return details.filter(d => +d.substr(11, 2) > 60).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countSeniors = function(details) {\\n    return details.filter(d => +d.substr(11, 2) > 60).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981769,
                "title": "solution-for-number-of-senior-citizens",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        {\\n            for(int i=0;i<details.length;i++)\\n            {\\n                int greater=Integer.parseInt(details[i].substring(11,13));\\n                if(greater>60)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        {\\n            for(int i=0;i<details.length;i++)\\n            {\\n                int greater=Integer.parseInt(details[i].substring(11,13));\\n                if(greater>60)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981337,
                "title": "fastest-34ms-runtime-python-easy-to-understand-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute Force Approach\\n\\n# Complexity\\n- Time  complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for citizen in details:\\n            age = citizen[11:13]\\n            if int(age) > 60:\\n                count += 1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for citizen in details:\\n            age = citizen[11:13]\\n            if int(age) > 60:\\n                count += 1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977496,
                "title": "c-beats-94-86-in-time-complexity-and-80-89-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(string s: details)\\n        {\\n            if(s[11]>\\'6\\' || (s[11]==\\'6\\' && s[12]>\\'0\\')){ans++;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(string s: details)\\n        {\\n            if(s[11]>\\'6\\' || (s[11]==\\'6\\' && s[12]>\\'0\\')){ans++;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977325,
                "title": "c-beats-100-using-std-string-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(std::string &str : details) { \\n            int temp = std::stoi(str.substr(11, 2));\\n            if(temp > 60) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(std::string &str : details) { \\n            int temp = std::stoi(str.substr(11, 2));\\n            if(temp > 60) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975290,
                "title": "java-1-ms-beats-96-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c = 0;\\n        for(int i=0; i<details.length; i++){\\n            if((details[i].charAt(11)-\\'0\\')*10+(details[i].charAt(12)-\\'0\\') > 60)\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c = 0;\\n        for(int i=0; i<details.length; i++){\\n            if((details[i].charAt(11)-\\'0\\')*10+(details[i].charAt(12)-\\'0\\') > 60)\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972473,
                "title": "age-checking-easy-to-understand-intuition-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean ageC(String s){\\n        int i=0;\\n        int len = s.length();\\n        String st=\"\";\\n        for(i=0; i<len-1; i++){\\n            if(s.charAt(i)==\\'M\\' || s.charAt(i)==\\'F\\' || s.charAt(i)==\\'O\\'){\\n                st = Character.toString(s.charAt(i+1))+Character.toString(s.charAt(i+2));\\n                break; \\n            }\\n        }\\n        if(st==\"\"){\\n            return false;\\n        }\\n        return Integer.parseInt(st)>60;\\n    }\\n\\n    public int countSeniors(String[] d) {/*\\n        int count=0;\\n        for(int i=0; i<details.length; i++){\\n            int c;\\n            for(int j=0; j<details[i].length(); j++){\\n                if(details[i].charAt(j)==\\'M\\'){\\n                    String s1 = Character.toString(details.charAt(j+1));\\n                    String s2 = Character.toString(details.charAt(j+2));\\n                    break;\\n                }\\n            }\\n            if(Integer.parseInt(s1)+ Integer.parseInt(s2) > 60){\\n                count++;\\n            }\\n        }\\n        return count;*/\\n\\n        int count=0;\\n        for(int i=0; i<d.length; i++){\\n            if(ageC(d[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    boolean ageC(String s){\\n        int i=0;\\n        int len = s.length();\\n        String st=\"\";\\n        for(i=0; i<len-1; i++){\\n            if(s.charAt(i)==\\'M\\' || s.charAt(i)==\\'F\\' || s.charAt(i)==\\'O\\'){\\n                st = Character.toString(s.charAt(i+1))+Character.toString(s.charAt(i+2));\\n                break; \\n            }\\n        }\\n        if(st==\"\"){\\n            return false;\\n        }\\n        return Integer.parseInt(st)>60;\\n    }\\n\\n    public int countSeniors(String[] d) {/*\\n        int count=0;\\n        for(int i=0; i<details.length; i++){\\n            int c;\\n            for(int j=0; j<details[i].length(); j++){\\n                if(details[i].charAt(j)==\\'M\\'){\\n                    String s1 = Character.toString(details.charAt(j+1));\\n                    String s2 = Character.toString(details.charAt(j+2));\\n                    break;\\n                }\\n            }\\n            if(Integer.parseInt(s1)+ Integer.parseInt(s2) > 60){\\n                count++;\\n            }\\n        }\\n        return count;*/\\n\\n        int count=0;\\n        for(int i=0; i<d.length; i++){\\n            if(ageC(d[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970930,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n        unsigned int ret = 0;\\n        for (const auto& detail : details)\\n        {\\n            ret += std::stoi(detail.substr(11,2)) > 60;\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n        unsigned int ret = 0;\\n        for (const auto& detail : details)\\n        {\\n            ret += std::stoi(detail.substr(11,2)) > 60;\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963287,
                "title": "c-easy-and-readable-solution-less-than-88",
                "content": "![image.png](https://assets.leetcode.com/users/images/2bdc6c1f-0c16-45dc-864f-a5c0e540e4a1_1693061554.2383866.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int CountSeniors(string[] details) {\\n        int counter = 0;\\n        foreach (string d in details)\\n            if (Convert.ToInt32(d.Substring(11, 2)) > 60)\\n                counter++;\\n        return counter;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountSeniors(string[] details) {\\n        int counter = 0;\\n        foreach (string d in details)\\n            if (Convert.ToInt32(d.Substring(11, 2)) > 60)\\n                counter++;\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961404,
                "title": "c-very-simple-solution-runtime-3-ms-beats-95-34-memory-13-5-mb-beats-32-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans = 0;\\n        for(int i = 0; i < details.size(); ++i){\\n            int age = (details[i][11] - \\'0\\')*10 + (details[i][12] - \\'0\\');\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans = 0;\\n        for(int i = 0; i < details.size(); ++i){\\n            int age = (details[i][11] - \\'0\\')*10 + (details[i][12] - \\'0\\');\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960949,
                "title": "by-using-ascii-value-without-typecasting-and-one-more-thing-all-beginners-in-a-easy-way-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\n        if((details[i].charAt(11)>=54) && details[i].charAt(12)>=48){\\n            //System.out.print(details[i].charAt(11)+\"\"+count);\\n            count++;\\n        }if(details[i].charAt(11)==54&& (details[i].charAt(12)==48)){\\n            count--;\\n        }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\n        if((details[i].charAt(11)>=54) && details[i].charAt(12)>=48){\\n            //System.out.print(details[i].charAt(11)+\"\"+count);\\n            count++;\\n        }if(details[i].charAt(11)==54&& (details[i].charAt(12)==48)){\\n            count--;\\n        }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959879,
                "title": "java-easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n      int count=0;\\n\\n       for(int i=0;i<details.length;i++){\\n    \\n     char a=details[i].charAt(11);\\n      char b=details[i].charAt(12);\\n\\n      int a1=a-\\'0\\';\\n      int b1=b-\\'0\\';\\n\\n      int c=a1*10+b1;\\n\\n      if(c>60){\\n          count++;\\n      }\\n\\n       } return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n      int count=0;\\n\\n       for(int i=0;i<details.length;i++){\\n    \\n     char a=details[i].charAt(11);\\n      char b=details[i].charAt(12);\\n\\n      int a1=a-\\'0\\';\\n      int b1=b-\\'0\\';\\n\\n      int c=a1*10+b1;\\n\\n      if(c>60){\\n          count++;\\n      }\\n\\n       } return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954187,
                "title": "very-clear-and-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for detail in details:\\n            if detail[11:13] > \"60\":\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for detail in details:\\n            if detail[11:13] > \"60\":\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953765,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int x = 0;\\n        String s = \"\";\\n        String str = \"\";\\n        for(String i:details){\\n            s = s + i;\\n        }\\n        int count = 0;\\n        int p = 1;\\n        int q = 2;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'M\\'|| s.charAt(i)==\\'F\\'||s.charAt(i)==\\'O\\'){\\n                str = str+ s.charAt(i+1) + s.charAt(i+2);\\n                x = Integer.parseInt(str);\\n                System.out.println(x);\\n                if(x>60){\\n                    count = count+1;\\n                }\\n            }\\n            str = \"\";\\n            p++;\\n            q++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int x = 0;\\n        String s = \"\";\\n        String str = \"\";\\n        for(String i:details){\\n            s = s + i;\\n        }\\n        int count = 0;\\n        int p = 1;\\n        int q = 2;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'M\\'|| s.charAt(i)==\\'F\\'||s.charAt(i)==\\'O\\'){\\n                str = str+ s.charAt(i+1) + s.charAt(i+2);\\n                x = Integer.parseInt(str);\\n                System.out.println(x);\\n                if(x>60){\\n                    count = count+1;\\n                }\\n            }\\n            str = \"\";\\n            p++;\\n            q++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953533,
                "title": "countseniors-brute-force-beginner-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(1) - constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(auto it:details){\\n            int num = (it[11]-\\'0\\')*10 + (it[12]-\\'0\\');\\n            if(num>60)  count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(auto it:details){\\n            int num = (it[11]-\\'0\\')*10 + (it[12]-\\'0\\');\\n            if(num>60)  count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952955,
                "title": "java-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\n            String s=details[i];\\n            int num=((s.charAt(11)-\\'0\\')*10)+(s.charAt(12)-\\'0\\');\\n            if(num>60){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\n            String s=details[i];\\n            int num=((s.charAt(11)-\\'0\\')*10)+(s.charAt(12)-\\'0\\');\\n            if(num>60){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952379,
                "title": "python-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return sum([1 for detail in details if int(detail[11:13])>60])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return sum([1 for detail in details if int(detail[11:13])>60])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948609,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n*Simply we store 11th and 12th element into one variable and check it greater than 60 or not if greater then count increases. \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n     int ans=0;\\n     int count=0;\\n     for(auto it:details){\\n        ans=(it[11]-\\'0\\')*10+(it[12]-\\'0\\');\\n         if(ans>60){\\n             count++;\\n         }\\n    }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n     int ans=0;\\n     int count=0;\\n     for(auto it:details){\\n        ans=(it[11]-\\'0\\')*10+(it[12]-\\'0\\');\\n         if(ans>60){\\n             count++;\\n         }\\n    }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948332,
                "title": "most-easy-approach",
                "content": "# Intuition\\nNorth East University Bangladesh\\n\\n# Approach\\nBrute force\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt = 0;\\n        for(int i=0;i<details.size();i++)\\n        {\\n            string s = details[i];\\n            string str = \"\";\\n            str+=s[11];\\n            str+=s[12];\\n            int temp = stoi(str);\\n            if(temp>60)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt = 0;\\n        for(int i=0;i<details.size();i++)\\n        {\\n            string s = details[i];\\n            string str = \"\";\\n            str+=s[11];\\n            str+=s[12];\\n            int temp = stoi(str);\\n            if(temp>60)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947571,
                "title": "java-solution-substring-runtime-1ms",
                "content": "# Intuition\\nfetch age using substring()\\nconvert it into integer\\ncheck if it is >60\\nreturn the count of senior passenger\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String s : details){\\n           if(Integer.parseInt(s.substring(11,13))>60){\\n               count++;\\n           }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String s : details){\\n           if(Integer.parseInt(s.substring(11,13))>60){\\n               count++;\\n           }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945080,
                "title": "1ms-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n    \\n        int count=0;\\n      for(int i=0;i<details.length;i++){\\n        int a=Integer.parseInt(details[i].substring(11,13));\\n          if(a>60){\\n              count++;\\n          }\\n      }  \\n      return  count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n    \\n        int count=0;\\n      for(int i=0;i<details.length;i++){\\n        int a=Integer.parseInt(details[i].substring(11,13));\\n          if(a>60){\\n              count++;\\n          }\\n      }  \\n      return  count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935054,
                "title": "javascript-single-line-declarative-and-functionaly-solution-beats-99-58",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(detail => +detail.slice(11, -2) > 60).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(detail => +detail.slice(11, -2) > 60).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931301,
                "title": "substring-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n            int ct=0;\\n        for(auto it:details)\\n         {\\n             //first 10 ignore\\n             //next denote gender\\n             //age\\n             int ind=11;\\n             int age=stoi(it.substr(ind,2));\\n             cout<<age<<\" \";\\n             if(age>60)\\n             ct++;\\n\\n         }\\n         return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n            int ct=0;\\n        for(auto it:details)\\n         {\\n             //first 10 ignore\\n             //next denote gender\\n             //age\\n             int ind=11;\\n             int age=stoi(it.substr(ind,2));\\n             cout<<age<<\" \";\\n             if(age>60)\\n             ct++;\\n\\n         }\\n         return ct;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3922531,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String s:details){\\n            int a = (s.charAt(11) - \\'0\\') * 10 + s.charAt(12) - \\'0\\';\\n            if(a > 60){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String s:details){\\n            int a = (s.charAt(11) - \\'0\\') * 10 + s.charAt(12) - \\'0\\';\\n            if(a > 60){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919334,
                "title": "easy-python",
                "content": "# Intuition\\nGet the age out of the string and count\\n\\n# Approach\\nNothing to explain\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        count=0\\n        for item in details:\\n            age = int(item[11:13])\\n            if age > 60:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        count=0\\n        for item in details:\\n            age = int(item[11:13])\\n            if age > 60:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919283,
                "title": "python-beats-98-runtime-99-memory-coded-on-mobile",
                "content": "![image](https://assets.leetcode.com/users/images/0c60d744-f23d-4692-971a-a8f6b1cd6ea2_1692209121.3218896.jpeg)\\n![image](https://assets.leetcode.com/users/images/51973d5e-2448-4517-bd35-27f30f70ae27_1692209121.2971199.jpeg)\\n\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/0c60d744-f23d-4692-971a-a8f6b1cd6ea2_1692209121.3218896.jpeg)\\n![image](https://assets.leetcode.com/users/images/51973d5e-2448-4517-bd35-27f30f70ae27_1692209121.2971199.jpeg)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3919246,
                "title": "easiest-solution-in-java",
                "content": ">\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        \\n        int sc = 0;\\n        for(int i =0;i<details.length;i++)\\n        {\\n            String str = details[i];\\n            int age = Integer.parseInt(str.substring(11,13));\\n            if(age>60)\\n            sc++;\\n        }\\n\\n        return sc;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        \\n        int sc = 0;\\n        for(int i =0;i<details.length;i++)\\n        {\\n            String str = details[i];\\n            int age = Integer.parseInt(str.substring(11,13));\\n            if(age>60)\\n            sc++;\\n        }\\n\\n        return sc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917656,
                "title": "javascript-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Dev Bhayani\\n//16/08/2023\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let count=0;\\n    for(let i=0;i<details.length;i++){\\n        let age=details[i].substring(11,13)\\n        if(parseInt(age)>60){\\n            count++;\\n        }\\n        console.log(age)\\n        // if(parseInt(,10)>60){\\n        //     count++;\\n        // }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//Dev Bhayani\\n//16/08/2023\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let count=0;\\n    for(let i=0;i<details.length;i++){\\n        let age=details[i].substring(11,13)\\n        if(parseInt(age)>60){\\n            count++;\\n        }\\n        console.log(age)\\n        // if(parseInt(,10)>60){\\n        //     count++;\\n        // }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917550,
                "title": "java-2-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int max = 0 , ans = 0;\\n        for(String i : details){\\n            max = (i.charAt(11)-\\'0\\')*10 + (i.charAt(12)-\\'0\\');\\n            if(max > 60) ans++;          \\n        }\\n        return ans;\\n    }\\n}          \\n//                 Another solution\\n        // int ans = 0;\\n        // for(String i : details){\\n        //     String d = i.substring(11,13);\\n        //     int s = Integer.parseInt(d);\\n        //     if(s>60) ans++;\\n        // }\\n        // return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int max = 0 , ans = 0;\\n        for(String i : details){\\n            max = (i.charAt(11)-\\'0\\')*10 + (i.charAt(12)-\\'0\\');\\n            if(max > 60) ans++;          \\n        }\\n        return ans;\\n    }\\n}          \\n//                 Another solution\\n        // int ans = 0;\\n        // for(String i : details){\\n        //     String d = i.substring(11,13);\\n        //     int s = Integer.parseInt(d);\\n        //     if(s>60) ans++;\\n        // }\\n        // return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917517,
                "title": "simple-solution-with-filter",
                "content": "# Code\\n```\\nclass Solution {\\n    func countSeniors(_ details: [String]) -> Int {\\n       return details.filter { detail in\\n            let ageStartIndex = detail.index(detail.startIndex, offsetBy: 11)\\n            let ageEndIndex = detail.index(ageStartIndex, offsetBy: 2)\\n            let ageString = detail[ageStartIndex..<ageEndIndex]\\n            return Int(ageString) ?? 0 > 60\\n        }.count \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countSeniors(_ details: [String]) -> Int {\\n       return details.filter { detail in\\n            let ageStartIndex = detail.index(detail.startIndex, offsetBy: 11)\\n            let ageEndIndex = detail.index(ageStartIndex, offsetBy: 2)\\n            let ageString = detail[ageStartIndex..<ageEndIndex]\\n            return Int(ageString) ?? 0 > 60\\n        }.count \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916559,
                "title": "python-rust-solution",
                "content": "\\n# Code\\n\\nThe code block has solutions in both Python and Rust.\\n\\n```python []\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        count = 0\\n        for detail in details:\\n            if int(detail[11:13]) > 60:\\n                count += 1\\n\\n        return count\\n```\\n```rust []\\nimpl Solution {\\n    pub fn count_seniors(details: Vec<String>) -> i32 {\\n        let mut count = 0;\\n        for detail in details.iter() {\\n            if detail.get(11..=12).unwrap().parse::<i32>().unwrap() > 60 {\\n                count += 1;\\n            }\\n        }\\n        count\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        count = 0\\n        for detail in details:\\n            if int(detail[11:13]) > 60:\\n                count += 1\\n\\n        return count\\n```\n```rust []\\nimpl Solution {\\n    pub fn count_seniors(details: Vec<String>) -> i32 {\\n        let mut count = 0;\\n        for detail in details.iter() {\\n            if detail.get(11..=12).unwrap().parse::<i32>().unwrap() > 60 {\\n                count += 1;\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916292,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\niterate over each element and create a astring of that after that check combination of character is >60 if true add in ans else do nothing ..... .... ... .. .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            String s=\"\"+details[i];\\n            int a=s.charAt(s.length()-4)-\\'0\\';\\n                        int b=s.charAt(s.length()-3)-\\'0\\';\\n                        if((a*10)+b>60)\\n                        ans++;\\n\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            String s=\"\"+details[i];\\n            int a=s.charAt(s.length()-4)-\\'0\\';\\n                        int b=s.charAt(s.length()-3)-\\'0\\';\\n                        if((a*10)+b>60)\\n                        ans++;\\n\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910474,
                "title": "simple-dart",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n  int countSeniors(List<String> details) {\\n   int count=0;\\n   for(String s in details){\\n       if(int.parse(s[11])>=6&&int.parse(s[12])>0)\\n       {\\n           count++;\\n       }\\n       else if(int.parse(s[11])>6)\\n       count++;\\n   }\\n   return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int countSeniors(List<String> details) {\\n   int count=0;\\n   for(String s in details){\\n       if(int.parse(s[11])>=6&&int.parse(s[12])>0)\\n       {\\n           count++;\\n       }\\n       else if(int.parse(s[11])>6)\\n       count++;\\n   }\\n   return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907788,
                "title": "the-native-solution-is-explained-in-detail-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code aims to count the number of senior passengers based on their ages from a vector of passenger details.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.The code defines a function countSeniors that takes a vector of strings (details) as input.\\n2.It initializes a counter variable (counter) to keep track of the number of senior passengers.\\n3.It iterates through each element (string) in the details vector using a loop.\\n4.For each passenger\\'s details, it extracts the age information from the string.\\n5.The age is extracted by converting the characters representing tens and units of age to integer values and combining them.\\n6.If the calculated age is greater than 60, the counter is incremented.\\n7.After iterating through all passenger details, the function returns the final count of senior passengers.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is determined by the loop that iterates through the details vector. Let n be the number of passenger details in the vector.\\n\\nThe loop runs n times, and for each iteration, a constant amount of work is done (extracting age and checking the condition). Therefore, the overall time complexity is O(n).\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is relatively low, as it only uses a few integer variables (counter, i, age) and a string (passenger) to temporarily store data.\\n\\nThe integer variables (counter, i, age) take constant space.\\nThe passenger string takes space proportional to the length of the longest passenger detail string.\\nTherefore, the space complexity of this code can be considered O(1) (constant space), given that the length of the longest passenger detail string is not significantly large compared to the number of passenger details.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n        int counter = 0;\\n        for(int i = 0; i < details.size(); ++i){\\n            string passenger = details[i];\\n\\n            int age = (((passenger[11] - \\'0\\') * 10) + (passenger[12] - \\'0\\'));\\n\\n            if(age > 60) ++counter;\\n        }\\n\\n        return counter; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n        int counter = 0;\\n        for(int i = 0; i < details.size(); ++i){\\n            string passenger = details[i];\\n\\n            int age = (((passenger[11] - \\'0\\') * 10) + (passenger[12] - \\'0\\'));\\n\\n            if(age > 60) ++counter;\\n        }\\n\\n        return counter; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905078,
                "title": "easy-using-substring",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String s : details)\\n        {\\n            int val = Integer.valueOf(s.substring(11,13));\\n            if(val>60)\\n            {\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String s : details)\\n        {\\n            int val = Integer.valueOf(s.substring(11,13));\\n            if(val>60)\\n            {\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902873,
                "title": "simple-approach-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int n = details.size(), c=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            string age = details[i].substr(11,2);\\n            if(stoi(age,0,10)>60) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int n = details.size(), c=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            string age = details[i].substr(11,2);\\n            if(stoi(age,0,10)>60) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1892585,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1892719,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1893030,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2024304,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1974369,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1895358,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2026552,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2013093,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1941609,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1919220,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1892585,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1892719,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1893030,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2024304,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1974369,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1895358,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2026552,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2013093,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1941609,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1919220,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            }
        ]
    },
    {
        "title": "Array Wrapper",
        "question_content": "<p>Create a class&nbsp;<code>ArrayWrapper</code> that accepts&nbsp;an array of integers in its constructor. This class should have two features:</p>\n\n<ul>\n\t<li>When two instances of this class are added together with the&nbsp;<code>+</code>&nbsp;operator, the resulting value is the sum of all the elements in&nbsp;both arrays.</li>\n\t<li>When the&nbsp;<code>String()</code>&nbsp;function is called on the instance, it will return a comma separated string surrounded by brackets. For example, <code>[1,2,3]</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[1,2],[3,4]], operation = &quot;Add&quot;\n<strong>Output:</strong> 10\n<strong>Explanation:</strong>\nconst obj1 = new ArrayWrapper([1,2]);\nconst obj2 = new ArrayWrapper([3,4]);\nobj1 + obj2; // 10\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[23,98,42,70]], operation = &quot;String&quot;\n<strong>Output:</strong> &quot;[23,98,42,70]&quot;\n<strong>Explanation:</strong>\nconst obj = new ArrayWrapper([23,98,42,70]);\nString(obj); // &quot;[23,98,42,70]&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[],[]], operation = &quot;Add&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\nconst obj1 = new ArrayWrapper([]);\nconst obj2 = new ArrayWrapper([]);\nobj1 + obj2; // 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 1000</code></li>\n\t<li><code>Note: nums is the array passed to the constructor</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3584650,
                "title": "2695-array-wrapper-level-up-your-js-skills-with-these-intuitive-implementations-day-28",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> The `ArrayWrapper` class is designed to encapsulate an array of integers and provide two features: computing the sum of all elements when two instances are added together, and returning a string representation of the array surrounded by brackets.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>1. The `ArrayWrapper` class is defined as a function constructor that takes an array of numbers (`nums`) as an argument and assigns it to the instance property `this.nums`.\\n\\n>2. The `valueOf` method is defined on the prototype of the `ArrayWrapper` class. This method is automatically called when the instance is used in a context where a primitive value is expected, such as addition with the `+` operator. It uses the `reduce` method to calculate the sum of all the numbers in the `this.nums` array.\\n\\n>3. The `toString` method is also defined on the prototype of the `ArrayWrapper` class. This method is automatically called when the instance is converted to a string, such as when using `String(obj)` or implicitly during string concatenation. It uses the `join` method to convert the `this.nums` array into a comma-separated string, and surrounds it with square brackets to represent an array.\\n# Code\\n```JS []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\\n## Here are alternative implementations of the `ArrayWrapper` class:\\n## Implementation 1: \\n>Using the spread operator and Array.prototype.reduce\\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return [...this.nums].reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n  }\\n}\\n```\\n## Implementation 2:\\n> Using a for loop\\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n      sum += this.nums[i];\\n    }\\n    return sum;\\n  }\\n\\n  toString() {\\n    let str = \\'[\\';\\n    for (let i = 0; i < this.nums.length; i++) {\\n      str += this.nums[i];\\n      if (i !== this.nums.length - 1) {\\n        str += \\',\\';\\n      }\\n    }\\n    str += \\']\\';\\n    return str;\\n  }\\n}\\n\\n```\\n## Implementation 3:\\n>Using Array.prototype.reduce and template literals\\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.map(num => String(num)).join(\\',\\')}]`;\\n  }\\n}\\n\\n```\\n## Implementation 4:\\n>Using Array.prototype.reduceRight\\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduceRight((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.reduceRight((str, num, index) => {\\n      if (index === this.nums.length - 1) {\\n        return String(num) + str;\\n      } else {\\n        return String(num) + \\',\\' + str;\\n      }\\n    }, \\'\\')}]`;\\n  }\\n}\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The `valueOf` method computes the sum of the elements in the array, which requires iterating over all elements once. Thus, its time complexity is O(n), where n is the number of elements in the array.\\n\\n>The `toString` method uses the `join` function, which concatenates allelements of the array into a string. Its time complexity is also O(n).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>The space complexity of the `ArrayWrapper` class is O(1) as it only stores the array as an instance variable and does not use any additional space that grows with the input size.\\n\\n\\n\\n# Important topic to Learn \\n\\n| Sr No. | Topic | Sr No. | Topic |\\n|-----|-----|-----|-----|\\n1.|Arrays , Array methods() * |2.|Function programming *|\\n3.|Higher-order function|4.|Memoization|\\n5.|Currying|6.|Promises, async/await|\\n7.|Compare Objects|8.|Prototypes, inheritance|\\n\\n>[ Note:- * marked is related to today\\'s problem ]\\n\\n\\n<img src=\"https://media.giphy.com/media/Xd6WrGsyh1su7X0ZGF/giphy.gif\" width=\"40\">\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D \\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JS []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return [...this.nums].reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n  }\\n}\\n```\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n      sum += this.nums[i];\\n    }\\n    return sum;\\n  }\\n\\n  toString() {\\n    let str = \\'[\\';\\n    for (let i = 0; i < this.nums.length; i++) {\\n      str += this.nums[i];\\n      if (i !== this.nums.length - 1) {\\n        str += \\',\\';\\n      }\\n    }\\n    str += \\']\\';\\n    return str;\\n  }\\n}\\n\\n```\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.map(num => String(num)).join(\\',\\')}]`;\\n  }\\n}\\n\\n```\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduceRight((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.reduceRight((str, num, index) => {\\n      if (index === this.nums.length - 1) {\\n        return String(num) + str;\\n      } else {\\n        return String(num) + \\',\\' + str;\\n      }\\n    }, \\'\\')}]`;\\n  }\\n}\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550702,
                "title": "easy-js-implementation-beats-100-constructor-building-js-40-mb",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \"[\" + this.array.join(\",\") + \"]\";\\n};\\n\\n\\n\\n```\\n\\n# Overview\\n\\n1. The `ArrayWrapper` function is defined with `nums` as a parameter. This function serves as the constructor for the `ArrayWrapper` class.\\n\\n2. Inside the `ArrayWrapper` constructor, `this.array = nums` assigns the `nums` array passed to the constructor to the `array` property of the instance. This ensures that each instance of `ArrayWrapper` has its own array.\\n\\n3. The `valueOf` method is added to the `ArrayWrapper.prototype`. This method is used to override the default behavior of the `valueOf` function and define how the instance should be evaluated in a numeric context.\\n\\n4. Inside the `valueOf` method, the `reduce` function is used on `this.array` to calculate the sum of all the numbers in the array. The initial value of the sum is set to `0`. The `reduce` function iterates over each element of the array, adding it to the running sum.\\n\\n5. The `toString` method is added to the `ArrayWrapper.prototype`. This method is used to override the default behavior of the `toString` function and define how the instance should be represented as a string.\\n\\n6. Inside the `toString` method, the `join` function is used on `this.array` to concatenate all the elements of the array into a single string, separated by commas. The resulting string is then enclosed in square brackets to match the desired format.\\n\\n# Approach\\n\\nThe approach for solving this problem is as follows:\\n\\n1. Create an instance of `ArrayWrapper` using the `new` keyword and pass an array of numbers to the constructor.\\n   ```javascript\\n   const obj1 = new ArrayWrapper([1, 2]);\\n\\n2. When you use the `+` operator between two `ArrayWrapper` instances (`obj1 + obj2`), JavaScript implicitly calls the `valueOf` method for both instances.\\n   - In the `valueOf` method, the `reduce` function sums all the elements in the `array` property of the instance.\\n   - The sum of the elements is then returned.\\n\\n3. The result of `obj1 + obj2` will be the sum of all the elements in both `obj1.array` and `obj2.array`.\\n\\n4. When you call `String(obj1)` or `obj1.toString()`, JavaScript implicitly calls the `toString` method for the `ArrayWrapper` instance.\\n   - In the `toString` method, the `join` function is used to concatenate all the elements in the `array` property of the instance with commas.\\n   - The resulting string is returned, enclosed in square brackets.\\n\\n5. The output of `String(obj1)` will be the string representation of the `obj1.array` enclosed in square brackets.\\n\\nThe code provides a convenient way to handle the sum of arrays and obtain their string representation in a specific format using the `ArrayWrapper` class.\\n\\n# PLEASE UPVOTE IF THIS HELPED YOU IN ANY MANNER \\u2705\\n![image.png](https://assets.leetcode.com/users/images/c2a9ee75-9d19-4742-89f2-482ec48d148e_1684732245.0597358.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Design"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \"[\" + this.array.join(\",\") + \"]\";\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584189,
                "title": "easy-javascript-solution-detailed-explanation-o-n-t-n-and-s-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n - For the valueof method, we will access the array which basically contains elements of an array of both objects and simply return its sum.\\n - For the toString method, we will modify the array into a string using the stringify method of JSON.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\\n**Please consider liking my post if you found it usefull.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584730,
                "title": "arraywrapper-easy-self-explanatory",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\",\") + \"]\";\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\",\") + \"]\";\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569540,
                "title": "full-thorough-explanation-o-1-time-for-valueof-and-tostring-funcs",
                "content": "\\n# Code\\n```\\n// Store sum and string in ArrayWrapper\\n// That way, if we call sum or string multiple times, it\\'s only calculated once!\\nvar ArrayWrapper = function(nums) {\\n    this.sum = nums.reduce((acc, cur) => acc + cur, 0);\\n    this.string = JSON.stringify(nums);\\n};\\n\\n// Since sum is stored in the object, O(1) time\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.sum;\\n}\\n\\n// Since string is stored in the object, O(1) time\\nArrayWrapper.prototype.toString = function() {\\n    return this.string;\\n}\\n```\\n# Overview\\n- In general, it is good practice to store a value that might be accessed multiple times. We wouldn\\'t want to calculate the value of the array every time we need its value. It is better to simply store it in our ArrayWrapper. And so, we define ```this.sum``` and ```this.string```.\\n- ```this.sum``` will be the sum of all the integers in the array. We do this with the reduce function. The reduce function I wrote here is ```nums.reduce((acc, cur) => acc + cur, 0)```.\\n    - What this does is it iterates throughout the array, sets cur to the current element it iterated to, and uses the specified function (in this, the function does ```acc + cur```), and stores the value in ```acc```. And so, if our array is [1, 2, 3, 4], the reduce function will set cur to 1, add acc + 1 = 1 (acc was initialized to 0), then go to the next element, which is 2, sets cur to 2, then does acc + 2 = 3, and so on.\\n- Next, we set ```this.string```. We can do this with ```JSON.stringify(nums)```. This stores the array as a string.\\n- And so, our ArrayWrapper variable is now storing all the values we\\'ll need. So in the ```ArrayWrapper.prototype.valueOf``` function, we simply return ```this.sum```, and for the ```ArrayWrapper.prototype.toString``` function, we return ```this.string```.\\n- NOTE: We only use the ```this``` keyword if we are accessing variables in the ArrayWrapper object. For example, when we access the sum variable stored in the ArrayWrapper, we need to use ```this.sum```. Simply returning ```sum``` does not work, as there is no parameter or local variable named ```sum```. However, when creating the ArrayWrapper, we do not write ```this.nums``` when trying to access ```nums```. It is not defined as part of the ArrayWrapper variable, it is simply a parameter being passed. So any time we use ```nums```, we simply write ```nums```.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ to build ArrayWrapper, $$O(1)$$ to access the value of array or string of array.\\n\\n- Space complexity: $$O(n)$$, due to storing the string.\\n\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "String",
                    "Design"
                ],
                "code": "```\\n// Store sum and string in ArrayWrapper\\n// That way, if we call sum or string multiple times, it\\'s only calculated once!\\nvar ArrayWrapper = function(nums) {\\n    this.sum = nums.reduce((acc, cur) => acc + cur, 0);\\n    this.string = JSON.stringify(nums);\\n};\\n\\n// Since sum is stored in the object, O(1) time\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.sum;\\n}\\n\\n// Since string is stored in the object, O(1) time\\nArrayWrapper.prototype.toString = function() {\\n    return this.string;\\n}\\n```\n```this.sum```\n```this.string```\n```this.sum```\n```nums.reduce((acc, cur) => acc + cur, 0)```\n```acc + cur```\n```acc```\n```this.string```\n```JSON.stringify(nums)```\n```ArrayWrapper.prototype.valueOf```\n```this.sum```\n```ArrayWrapper.prototype.toString```\n```this.string```\n```this```\n```this.sum```\n```sum```\n```sum```\n```this.nums```\n```nums```\n```nums```\n```nums```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584341,
                "title": "3-lines-easy-commented",
                "content": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n};\\n```\\n\\nThis code defines a constructor function called `ArrayWrapper`, which creates an object that wraps an array of numbers. The constructor function takes an argument `nums`, which represents the array of numbers.\\n\\nThe `valueOf` method is defined on the `ArrayWrapper.prototype`. This method is used to provide a primitive representation of the object. In this case, `valueOf` returns the sum of all the numbers in the `nums` array using the `reduce` method. The `reduce` method iterates over each element of the array, accumulating the sum in the variable `a`. The initial value of `a` is set to 0.\\n\\nThe `toString` method is also defined on the `ArrayWrapper.prototype`. This method is used to convert the object to a string representation. In this case, `toString` returns a string that represents the `nums` array enclosed in square brackets. It uses the `toString` method of the `nums` array to convert each element to a string and then concatenates them together with commas.\\n\\nHere\\'s an example usage of the code:\\n\\n```javascript\\nvar wrapper = new ArrayWrapper([1, 2, 3, 4, 5]);\\n\\nconsole.log(wrapper.valueOf());  // Output: 15\\nconsole.log(wrapper.toString()); // Output: [1,2,3,4,5]\\n```\\n\\nIn this example, a new `ArrayWrapper` object is created with the array `[1, 2, 3, 4, 5]`. When `wrapper.valueOf()` is called, it returns the sum of all the numbers in the array, which is 15. When `wrapper.toString()` is called, it returns the string representation of the array, `[1,2,3,4,5]`.",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n};\\n```\n```javascript\\nvar wrapper = new ArrayWrapper([1, 2, 3, 4, 5]);\\n\\nconsole.log(wrapper.valueOf());  // Output: 15\\nconsole.log(wrapper.toString()); // Output: [1,2,3,4,5]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546591,
                "title": "easiest-detailed-explanation-reduce-string-interpolation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n<img src=\"https://assets.leetcode.com/users/images/b93dcc50-7e19-44d3-80ec-c41558d719ba_1684043630.2104852.png\" width=\"50%\">\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nclass ArrayWrapper {\\n    constructor(nums){\\n        this.nums = nums;\\n    }\\n\\n    valueOf (){\\n        return this.nums.reduce((acc, val) => acc += val, 0)\\n    }\\n\\n    toString(){\\n        return `[${this.nums.join(\",\")}]`\\n    }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nclass ArrayWrapper {\\n    constructor(nums){\\n        this.nums = nums;\\n    }\\n\\n    valueOf (){\\n        return this.nums.reduce((acc, val) => acc += val, 0)\\n    }\\n\\n    toString(){\\n        return `[${this.nums.join(\",\")}]`\\n    }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584277,
                "title": "java-script-solution-for-array-wrapper-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The ArrayWrapper constructor initializes the instance with the provided array of integers.\\n- The valueOf() method calculates the sum of all integers in the array.\\n- The toString() method converts the array to a string representation in the format of a comma-separated list surrounded by square brackets.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The ArrayWrapper class is defined with a constructor that takes an array nums as input and assigns it to the instance variable this.nums.\\n1. The valueOf() method is overridden to calculate the sum of all elements in the nums array using the reduce() function. It returns the sum.\\n1. The toString() method is overridden to convert the nums array to a string representation in the format of a comma-separated list surrounded by square brackets. It uses the join() method to join the elements with commas. It returns the formatted string.\\n1. Example usage demonstrates the addition of two ArrayWrapper instances using the + operator and the conversion of an ArrayWrapper instance to a string using the String() function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The valueOf() method has a time complexity of O(n), where n is the length of the input array. This is because it iterates over all elements of the array once to calculate the sum.\\n- The toString() method also has a time complexity of O(n), as it iterates over all elements of the array to join them into a string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of the ArrayWrapper class is O(1) because it only stores the input array and does not use any additional space that grows with the input size.\\n- The valueOf() and toString() methods do not allocate any significant additional space. The space used by these methods is negligible compared to the input size.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n      this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.join(\\',\\') + \\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n      this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.join(\\',\\') + \\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540218,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((subSum,subNum)=>subSum+subNum,0)\\n    \\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\'+this.nums.flat().join(\\',\\')+\\']\\'  \\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((subSum,subNum)=>subSum+subNum,0)\\n    \\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\'+this.nums.flat().join(\\',\\')+\\']\\'  \\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539856,
                "title": "100-typescript-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass ArrayWrapper {\\n  private nums: number[];\\n\\n  constructor(nums: number[]) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf(): number {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString(): string {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\n// console.log(obj1 + obj2); // 10\\n// console.log(String(obj1)); // \"[1,2]\"\\n// console.log(String(obj2)); // \"[3,4]\"\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  private nums: number[];\\n\\n  constructor(nums: number[]) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf(): number {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString(): string {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\n// console.log(obj1 + obj2); // 10\\n// console.log(String(obj1)); // \"[1,2]\"\\n// console.log(String(obj2)); // \"[3,4]\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539852,
                "title": "best-js-solution-for-beginners",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584222,
                "title": "best-javascript-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688655,
                "title": "reduce-json-stringify",
                "content": "```js\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584408,
                "title": "easy-1-1-1-line-solution",
                "content": "# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,num) => acc + num,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,num) => acc + num,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3581477,
                "title": "java-style",
                "content": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var res = 0;\\n    for (var i=0;i<this.nums.length;i++) res+=this.nums[i];\\n    return res;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+this.nums.join(\\',\\')+\"]\";\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var res = 0;\\n    for (var i=0;i<this.nums.length;i++) res+=this.nums[i];\\n    return res;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+this.nums.join(\\',\\')+\"]\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565190,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((pre, cur)=>pre+cur,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.array)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((pre, cur)=>pre+cur,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.array)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 3546378,
                "title": "ts-just-store-two-values-59ms-45mb",
                "content": "Another super plain one, with the best thing to do here being to create both our results (that will never change) in the `constructor`:\\n* `str` will bhe the stringified version of `nums` that we can quickly get using a simple template literal and a `.join` operation;\\n* `tot` will store the total of the values contained in `nums`, easily obtained by calling `.reduce` on it.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nclass ArrayWrapper {\\n    str: string;\\n    tot: number;\\n\\tconstructor(nums: number[]) {\\n        this.str = `[${nums.join(\",\")}]`;\\n        this.tot = nums.reduce((acc, iter) => acc + iter, 0);\\n    }\\n\\n\\tvalueOf(): number {\\n        return this.tot;\\n    }\\n\\n\\ttoString(): string {\\n        return this.str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array"
                ],
                "code": "```ts\\nclass ArrayWrapper {\\n    str: string;\\n    tot: number;\\n\\tconstructor(nums: number[]) {\\n        this.str = `[${nums.join(\",\")}]`;\\n        this.tot = nums.reduce((acc, iter) => acc + iter, 0);\\n    }\\n\\n\\tvalueOf(): number {\\n        return this.tot;\\n    }\\n\\n\\ttoString(): string {\\n        return this.str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540093,
                "title": "array-wrapper-javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n return this.nums.reduce((subSum, subNum) => subSum + subNum, 0)\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\' + this.nums.flat().join(\\',\\') + \\']\\';\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n return this.nums.reduce((subSum, subNum) => subSum + subNum, 0)\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\' + this.nums.flat().join(\\',\\') + \\']\\';\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100707,
                "title": "my-solution",
                "content": "class ArrayWrapper {\\n  arrays = [];\\n  constructor(nums: number[]) {\\n    this.arrays.push(nums);\\n  }\\n  valueOf(): number {\\n    let result = 0;\\n    let [arr1, arr2] = this.arrays;\\n    if (arr1) {\\n      arr1.forEach((element: number) => {\\n         result+= element;\\n      });\\n    }\\n    if (arr2) {\\n      arr2.forEach((element: number) => {\\n         result += element;\\n      });\\n    }\\n    return result;\\n  }\\n\\n  toString(): string {\\n    return JSON.stringify(this.arrays[0]);\\n  }\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "class ArrayWrapper {\\n  arrays = [];\\n  constructor(nums: number[]) {\\n    this.arrays.push(nums);\\n  }\\n  valueOf(): number {\\n    let result = 0;\\n    let [arr1, arr2] = this.arrays;\\n    if (arr1) {\\n      arr1.forEach((element: number) => {\\n         result+= element;\\n      });\\n    }\\n    if (arr2) {\\n      arr2.forEach((element: number) => {\\n         result += element;\\n      });\\n    }\\n    return result;\\n  }\\n\\n  toString(): string {\\n    return JSON.stringify(this.arrays[0]);\\n  }\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100042,
                "title": "simple-js-ts-solution-1-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n    private arr: number[];\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf = (): number => this.arr.reduce((acc, arr) => acc+arr, 0);\\n\\n\\ttoString = (): string => `[${this.arr.toString()}]`;\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    private arr: number[];\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf = (): number => this.arr.reduce((acc, arr) => acc+arr, 0);\\n\\n\\ttoString = (): string => `[${this.arr.toString()}]`;\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097555,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\n/**\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr)=>acc+curr,0)\\n}\\n\\n/**\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\n/**\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr)=>acc+curr,0)\\n}\\n\\n/**\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096695,
                "title": "step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Constructor function for ArrayWrapper.\\n *\\n * @param {number[]} nums - An array of numbers to be wrapped.\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * Custom valueOf method to calculate the sum of wrapped numbers.\\n *\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, num) => acc + num, 0);\\n};\\n\\n/**\\n * Custom toString method to convert the wrapped array to a string.\\n *\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n};\\n\\n// Create instances of ArrayWrapper\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\n// Using the custom methods and demonstrating their behavior\\nobj1 + obj2; // When used in an addition context, it calculates the sum of both arrays, resulting in 10.\\nString(obj1); // Converts obj1 to a string, resulting in \"[1,2]\".\\nString(obj2); // Converts obj2 to a string, resulting in \"[3,4]\".\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Constructor function for ArrayWrapper.\\n *\\n * @param {number[]} nums - An array of numbers to be wrapped.\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * Custom valueOf method to calculate the sum of wrapped numbers.\\n *\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, num) => acc + num, 0);\\n};\\n\\n/**\\n * Custom toString method to convert the wrapped array to a string.\\n *\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n};\\n\\n// Create instances of ArrayWrapper\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\n// Using the custom methods and demonstrating their behavior\\nobj1 + obj2; // When used in an addition context, it calculates the sum of both arrays, resulting in 10.\\nString(obj1); // Converts obj1 to a string, resulting in \"[1,2]\".\\nString(obj2); // Converts obj2 to a string, resulting in \"[3,4]\".\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095722,
                "title": "2695-array-wrapper",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\\n}\\n\\n/**\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\\n}\\n\\n/**\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085116,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return \"[\" + this.nums.join(\",\") + \"]\";\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return \"[\" + this.nums.join(\",\") + \"]\";\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077441,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function (nums) {\\n  this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n  return this.arr.reduce((acc, next) => acc + next, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function () {\\n  return JSON.stringify(this.arr);\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function (nums) {\\n  this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n  return this.arr.reduce((acc, next) => acc + next, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function () {\\n  return JSON.stringify(this.arr);\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070058,
                "title": "s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065488,
                "title": "const-js-ts-single-line-solution",
                "content": "# Code\\n```\\nclass ArrayWrapper {\\n    private nums: number [];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, curr) => acc + curr, 0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.join(\",\")}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    private nums: number [];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, curr) => acc + curr, 0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.join(\",\")}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063300,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+String(this.nums) + \"]\";    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+String(this.nums) + \"]\";    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060816,
                "title": "very-simple-use-reduce-and-json-stringify",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = [...nums]\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum,num) => num + sum, 0)\\n    \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = [...nums]\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum,num) => num + sum, 0)\\n    \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046290,
                "title": "beats-97-87-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, curr) => acc+=curr,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, curr) => acc+=curr,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034492,
                "title": "solution-using-reduce",
                "content": "# Intuition\\nThis can be handled by Array.reduce\\n\\n# Approach\\nStore the array as a member by spreading nums. Use Array.reduce for the sum with the + operator. Use reduce for the string add conditionals to apend the \"[],\" characters depending on index of the array element.\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=[...nums];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((total,n) => total + n,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    if (!this.nums.length) \\n        return \\'[]\\';\\n    return this.nums.reduce((str,n,i) => {\\n        if(i == 0) \\n            str += \\'[\\';\\n        str += n;\\n        if (i == this.nums.length-1)\\n            str += \\']\\'\\n        else\\n            str += \\',\\';\\n        return str\\n    },\"\");\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=[...nums];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((total,n) => total + n,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    if (!this.nums.length) \\n        return \\'[]\\';\\n    return this.nums.reduce((str,n,i) => {\\n        if(i == 0) \\n            str += \\'[\\';\\n        str += n;\\n        if (i == this.nums.length-1)\\n            str += \\']\\'\\n        else\\n            str += \\',\\';\\n        return str\\n    },\"\");\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034457,
                "title": "easy-solution",
                "content": "# Intuition\\nThis is easy\\n\\n# Approach\\nStore the array as a member. Iterate over the elements and add to a string. Use Array.reduce for the sum\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=[...nums];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((total,n) => total + n,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = \"[\";\\n    this.nums.forEach((n) => { \\n        str += n;\\n        str += \\',\\';\\n    });\\n    if (this.nums.length)\\n        str = str.substring(0,str.length - 1);\\n    str += \\']\\';\\n    return str;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=[...nums];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((total,n) => total + n,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = \"[\";\\n    this.nums.forEach((n) => { \\n        str += n;\\n        str += \\',\\';\\n    });\\n    if (this.nums.length)\\n        str = str.substring(0,str.length - 1);\\n    str += \\']\\';\\n    return str;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020561,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum=0;\\n    for(let i=0;i<this.nums.length;i++){\\n               sum+=this.nums[i];\\n    }\\n    return sum;\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum=0;\\n    for(let i=0;i<this.nums.length;i++){\\n               sum+=this.nums[i];\\n    }\\n    return sum;\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020556,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum=0;\\n    for(let i=0;i<this.nums.length;i++){\\n           \\n               sum+=this.nums[i];\\n           \\n    }\\n    return sum;\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum=0;\\n    for(let i=0;i<this.nums.length;i++){\\n           \\n               sum+=this.nums[i];\\n           \\n    }\\n    return sum;\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011731,
                "title": "implementation-with-nested-array-and-recursive-ts",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n  constructor(private nums: number[] | number[][]) {}\\n  calcSum(array: number[] | number[][], index: number, sum: number): number {\\n    if (index === array.length) {\\n      return sum;\\n    }\\n    const item = array[index];\\n    if (Array.isArray(item)) {\\n      return this.calcSum(array, index + 1, sum + this.calcSum(item, 0, 0));\\n    }\\n    return this.calcSum(array, index + 1, sum + item);\\n  }\\n  valueOf() {\\n    return this.calcSum(this.nums, 0, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  constructor(private nums: number[] | number[][]) {}\\n  calcSum(array: number[] | number[][], index: number, sum: number): number {\\n    if (index === array.length) {\\n      return sum;\\n    }\\n    const item = array[index];\\n    if (Array.isArray(item)) {\\n      return this.calcSum(array, index + 1, sum + this.calcSum(item, 0, 0));\\n    }\\n    return this.calcSum(array, index + 1, sum + item);\\n  }\\n  valueOf() {\\n    return this.calcSum(this.nums, 0, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009418,
                "title": "the-10x-approach-don-t-forget-about-the-redooocer",
                "content": "# Intuition\\nWhen given an array of numbers, we often want to perform certain operations on it. The `ArrayWrapper` class seems to be a way to encapsulate an array and provide additional methods to operate on it. The methods provided are:\\n- `valueOf()`: Returns the sum of all numbers in the array.\\n- `toString()`: Returns a string representation of the array.\\n\\n# Approach\\n1. **Constructor**: The class takes an array of numbers as its argument and initializes its `nums` property with this array.\\n2. **valueOf()**: This method uses the `reduce` function to sum up all the numbers in the array and return the result.\\n3. **toString()**: This method returns a stringified version of the array using `JSON.stringify`.\\n\\n# Complexity\\n- **Time complexity**:\\n  - Constructor: \\\\(O(1)\\\\) (Assigning a reference)\\n  - valueOf(): \\\\(O(n)\\\\) (Iterating over the array to sum up)\\n  - toString(): \\\\(O(n)\\\\) (Stringifying the array)\\n\\n- **Space complexity**:\\n  - Constructor: \\\\(O(n)\\\\) (Storing the array)\\n  - valueOf(): \\\\(O(1)\\\\) (Just returning a single number)\\n  - toString(): \\\\(O(n)\\\\) (Returning a string representation of the array)\\n\\n# Code\\n```typescript\\nclass ArrayWrapper {\\n    nums: number[] = [];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, n) => acc+n, 0);\\n    }\\n\\n\\ttoString() {\\n        return JSON.stringify(this.nums);\\n    }\\n};\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Intuition\\nWhen given an array of numbers, we often want to perform certain operations on it. The `ArrayWrapper` class seems to be a way to encapsulate an array and provide additional methods to operate on it. The methods provided are:\\n- `valueOf()`: Returns the sum of all numbers in the array.\\n- `toString()`: Returns a string representation of the array.\\n\\n# Approach\\n1. **Constructor**: The class takes an array of numbers as its argument and initializes its `nums` property with this array.\\n2. **valueOf()**: This method uses the `reduce` function to sum up all the numbers in the array and return the result.\\n3. **toString()**: This method returns a stringified version of the array using `JSON.stringify`.\\n\\n# Complexity\\n- **Time complexity**:\\n  - Constructor: \\\\(O(1)\\\\) (Assigning a reference)\\n  - valueOf(): \\\\(O(n)\\\\) (Iterating over the array to sum up)\\n  - toString(): \\\\(O(n)\\\\) (Stringifying the array)\\n\\n- **Space complexity**:\\n  - Constructor: \\\\(O(n)\\\\) (Storing the array)\\n  - valueOf(): \\\\(O(1)\\\\) (Just returning a single number)\\n  - toString(): \\\\(O(n)\\\\) (Returning a string representation of the array)\\n\\n# Code\\n```typescript\\nclass ArrayWrapper {\\n    nums: number[] = [];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, n) => acc+n, 0);\\n    }\\n\\n\\ttoString() {\\n        return JSON.stringify(this.nums);\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 4008929,
                "title": "typescript-javascript-solution",
                "content": "```ts\\nclass ArrayWrapper {\\n    private nums: number[];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((total, num) => total += num, 0);\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.toString()}]`;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nclass ArrayWrapper {\\n    private nums: number[];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((total, num) => total += num, 0);\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.toString()}]`;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008030,
                "title": "self-explanatory-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return JSON.stringify(this.nums)\\n    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return JSON.stringify(this.nums)\\n    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006079,
                "title": "array-wrapper",
                "content": "\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const initialValue = 0;\\n    const sumWithInitial = this.nums.reduce((a, c) => a + c, initialValue);\\n    return sumWithInitial;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join()}]`;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const initialValue = 0;\\n    const sumWithInitial = this.nums.reduce((a, c) => a + c, initialValue);\\n    return sumWithInitial;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join()}]`;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987186,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985517,
                "title": "simple-js-solution-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.numbers=nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    \\n    return this.numbers.reduce((prev,curr)=>prev+=curr,0)\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.numbers.toString()}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.numbers=nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    \\n    return this.numbers.reduce((prev,curr)=>prev+=curr,0)\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.numbers.toString()}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974708,
                "title": "one-liner-solution-no-confusion",
                "content": "\\n```\\nclass ArrayWrapper {\\n    private nums: number[]\\n    constructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n    valueOf() {\\n        return this.nums.reduce((acc, item) => acc += item,0)\\n    }\\n\\n    toString() {\\n        return JSON.stringify(this.nums)\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    private nums: number[]\\n    constructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n    valueOf() {\\n        return this.nums.reduce((acc, item) => acc += item,0)\\n    }\\n\\n    toString() {\\n        return JSON.stringify(this.nums)\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969364,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums =nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums =nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962529,
                "title": "constructor-function-with-prototype",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957490,
                "title": "simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((n, acc) => n + acc, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((n, acc) => n + acc, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955652,
                "title": "js-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var sum=0;\\n    for(let i=0;i<this.arr.length;i++){\\n        sum+=this.arr[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var sum=0;\\n    for(let i=0;i<this.arr.length;i++){\\n        sum+=this.arr[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941660,
                "title": "single-line-solutions-beats-100-users",
                "content": "# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((sum, item) => sum + item, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((sum, item) => sum + item, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925399,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function (nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function () {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function (nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function () {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924471,
                "title": "typescript-simple-solution",
                "content": "# Code\\n```\\nclass ArrayWrapper {\\n\\tconstructor(private nums: number[]) {}\\n\\tvalueOf(): number { return this.nums.reduce( ( acc, val ) => acc += val, 0 ) }\\n\\ttoString() { return \\'[\\' + this.nums.toString() + \\']\\'; }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n\\tconstructor(private nums: number[]) {}\\n\\tvalueOf(): number { return this.nums.reduce( ( acc, val ) => acc += val, 0 ) }\\n\\ttoString() { return \\'[\\' + this.nums.toString() + \\']\\'; }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910769,
                "title": "easy-to-understand-javascript-solution-with-explanation",
                "content": "# Intuition\\nI had a really hard time figuring out how to solve this problem initially because there were a few concepts I had to learn in order to solve the problem. \\n\\nI needed to understand a few things:\\n\\n- When we perform operations like obj1 + obj2 or String(obj1), we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for valueOf() (which is a method on Object.prototype)\\n- If the primitive that\\'s expected is a string, then JS engine looks for toString() (which is a method on Object.prototype)\\n\\n# Approach\\nWith an understanding now of the concepts the problem expects us to know, I designed my solution as follows:\\n\\n- create a variable in the class that takes in `nums`\\n- `valueOf` is expected to return an integer, so we need to reduce our class variable in this method\\n- `toString` is expected to return a string, so we need to turn our class variable into a string\\n\\n# Complexity\\n- Time complexity:\\n`valueOf` is O(n)\\n`toString` is O(n)\\n\\n- Space complexity:\\n`valueOf` is O(1)\\n`toString` is O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900649,
                "title": "easy-wrapper-with-class-json-stringify",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.array = nums;\\n    }\\n\\n    toString() {\\n        return JSON.stringify(this.array);\\n    }\\n    valueOf() {\\n        return this.array.reduce((acc, value) => {\\n        return acc + value;\\n    }, 0);\\n    }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.array = nums;\\n    }\\n\\n    toString() {\\n        return JSON.stringify(this.array);\\n    }\\n    valueOf() {\\n        return this.array.reduce((acc, value) => {\\n        return acc + value;\\n    }, 0);\\n    }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889935,
                "title": "2695-array-wrapper",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((accomulation, value) => accomulation + value, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.array.toString() + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((accomulation, value) => accomulation + value, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.array.toString() + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877221,
                "title": "best-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- In constructor we can initialize the stringfiedArray and valueof that array.\\n- When the functions will be called for that object then it will directly return the saved value and no need of calculating again and again.\\n\\n# Code\\n```js\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n    this.value = this.nums.reduce((acc, curr) => acc+curr, 0);\\n    this.stringifiedArray = JSON.stringify(this.nums);\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.value;\\n}\\n\\nArrayWrapper.prototype.toString = function() {  \\n    return this.stringifiedArray;\\n}\\n\\n// creating object\\nconst obj1 = new ArrayWrapper([1,2]);\\nconst obj2 = new ArrayWrapper([3,4]);\\n\\n// testing \\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n    this.value = this.nums.reduce((acc, curr) => acc+curr, 0);\\n    this.stringifiedArray = JSON.stringify(this.nums);\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.value;\\n}\\n\\nArrayWrapper.prototype.toString = function() {  \\n    return this.stringifiedArray;\\n}\\n\\n// creating object\\nconst obj1 = new ArrayWrapper([1,2]);\\nconst obj2 = new ArrayWrapper([3,4]);\\n\\n// testing \\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876603,
                "title": "simple-solution-faster-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.length > 0\\n    ? this.nums.reduce((a, b) => a + b)\\n    : 0\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString(\\'\\') + \\']\\'\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.length > 0\\n    ? this.nums.reduce((a, b) => a + b)\\n    : 0\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString(\\'\\') + \\']\\'\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867415,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    for ( let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    for ( let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861426,
                "title": "check-it-guys",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\\',\\')}]`;\\n};\\n\\n// Test cases\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // Output: 10\\nconsole.log(String(obj1)); // Output: \"[1,2]\"\\nconsole.log(String(obj2)); // Output: \"[3,4]\"\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\\',\\')}]`;\\n};\\n\\n// Test cases\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // Output: 10\\nconsole.log(String(obj1)); // Output: \"[1,2]\"\\nconsole.log(String(obj2)); // Output: \"[3,4]\"\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837970,
                "title": "very-simple-solution",
                "content": "\\n```\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3820660,
                "title": "array-wrapper-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>{\\n        return a + b\\n    },0)    \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n   return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>{\\n        return a + b\\n    },0)    \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n   return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816785,
                "title": "most-easy-and-simple-solution",
                "content": "# Approach\\n- For first method,use reduce function of arrays to add two elements of array at a time till end of array which will give us sum.\\n- For second method,use join() to join each element of array with \\',\\'.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum,num)=>sum+num,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum,num)=>sum+num,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816368,
                "title": "basic-approach-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return  this.nums.reduce((accum,item) => accum + item,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return  this.nums.reduce((accum,item) => accum + item,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806918,
                "title": "easy-to-understand-login-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    constructor(nums)\\n    {\\n        this.nums=nums;\\n    }\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const nums=this.nums;\\n    const sum=nums.reduce((accumalator,currentvalues)=>accumalator+currentvalues,0);\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    if(this.nums.length==0)\\n    {\\n        return \"[]\";\\n    }\\n    else\\n    {\\n         var result=\"[\";\\n    const arra=this.nums;\\n    for(var i=0;i<arra.length;i++)\\n    {\\n        \\n        if(i==arra.length-1)\\n        {\\n            result=result+arra[i]+\"]\";\\n        \\n        }\\n        else\\n        {\\n            result=result+arra[i].toString()+\\',\\';\\n\\n        }\\n    }\\n    return result;\\n\\n    }\\n\\n   \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    constructor(nums)\\n    {\\n        this.nums=nums;\\n    }\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const nums=this.nums;\\n    const sum=nums.reduce((accumalator,currentvalues)=>accumalator+currentvalues,0);\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    if(this.nums.length==0)\\n    {\\n        return \"[]\";\\n    }\\n    else\\n    {\\n         var result=\"[\";\\n    const arra=this.nums;\\n    for(var i=0;i<arra.length;i++)\\n    {\\n        \\n        if(i==arra.length-1)\\n        {\\n            result=result+arra[i]+\"]\";\\n        \\n        }\\n        else\\n        {\\n            result=result+arra[i].toString()+\\',\\';\\n\\n        }\\n    }\\n    return result;\\n\\n    }\\n\\n   \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806547,
                "title": "javascript-this-valueof-tostring-explained-with-space-time-complexity",
                "content": "# Intuition\\nThe special keyword \\'this\\'. We can bind it to any value and that is automatically available to prototype object\\n\\n# Approach\\n1. Assing the passed \\'nums\\' to a variable of your choice inside \\'this\\'\\n2. For valueOf, use Array.reduce() to sum up all the nums\\n3. For toString, use concatination and Array.join() for desired output as asked in the question\\n4. Please note that both \\'valeuOf\\' and \\'toString\\' are recogonised by javascript. Name it anything else and your logic will fail. These are reserved keywords (proto functions) in javascript. The use of operator \\'+\\' between two or more object of ArrayWrapper \"type\" invokes the \\'valueOf\\' function automatically to get their respective values. The only thing we have modified here is the logic of that \\'valueOf\\' function. Same goes for \\'toString\\', we have only modified the underlying logic.\\n\\n# Complexity\\n- Time complexity:\\nConstructor: O(1)\\nvalueOf method: O(n)\\ntoString method: O(n)\\n\\n- Space complexity:\\nConstructor: O(1)\\nvalueOf method: O(1)\\ntoString method: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arrOfNums = nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arrOfNums.reduce((t,n)=>t+n,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\'+this.arrOfNums.join()+\\']\\'\\n}\\n\\n\\nconst obj1 = new ArrayWrapper([1,2]);\\nconst obj2 = new ArrayWrapper([3,4]);\\nobj1 + obj2; // 10\\nString(obj1); // \"[1,2]\"\\nString(obj2); // \"[3,4]\"\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arrOfNums = nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arrOfNums.reduce((t,n)=>t+n,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\'+this.arrOfNums.join()+\\']\\'\\n}\\n\\n\\nconst obj1 = new ArrayWrapper([1,2]);\\nconst obj2 = new ArrayWrapper([3,4]);\\nobj1 + obj2; // 10\\nString(obj1); // \"[1,2]\"\\nString(obj2); // \"[3,4]\"\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786722,
                "title": "solution-with-simple-foreach-beats-91-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    constructor(nums)\\n    {\\n        this.nums = nums;\\n    }\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let result = 0;\\n    this.nums.forEach(v=>{\\n        result += v;\\n    })\\n    return result;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[` + this.nums.join(\\',\\') + `]`;\\n}   \\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    constructor(nums)\\n    {\\n        this.nums = nums;\\n    }\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let result = 0;\\n    this.nums.forEach(v=>{\\n        result += v;\\n    })\\n    return result;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[` + this.nums.join(\\',\\') + `]`;\\n}   \\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770544,
                "title": "array-wrapper",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum1=0\\n    for(var num of this.nums){\\n        sum1+=num\\n    }\\n    return sum1\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str1=\"\"\\n    for(var i=0;i<this.nums.length;i++)\\n    {\\n        if(i===this.nums.length-1){\\n            str1+=this.nums[i]\\n        }\\n        else{\\n            str1+=this.nums[i]+\",\"\\n        }\\n    }\\n    return \"[\"+str1+\"]\"\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum1=0\\n    for(var num of this.nums){\\n        sum1+=num\\n    }\\n    return sum1\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str1=\"\"\\n    for(var i=0;i<this.nums.length;i++)\\n    {\\n        if(i===this.nums.length-1){\\n            str1+=this.nums[i]\\n        }\\n        else{\\n            str1+=this.nums[i]+\",\"\\n        }\\n    }\\n    return \"[\"+str1+\"]\"\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3764843,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3758001,
                "title": "2695-array-wrapper-umarbek-s-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738296,
                "title": "the-most-obvious-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst thought: implement `valueOf` with reducer and `toString` with (the most obvious for me) `JSON.stringify`.\\n\\n# Code (TS)\\n```\\nclass ArrayWrapper {\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    nums = []\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, num) => acc + num, 0);\\n    }\\n\\n\\ttoString() {\\n        return JSON.stringify(this.nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    nums = []\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, num) => acc + num, 0);\\n    }\\n\\n\\ttoString() {\\n        return JSON.stringify(this.nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731976,
                "title": "easy-js-solution",
                "content": "\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  if(this.nums.length === 0) return 0;\\n  return  this.nums.reduce((acc, cur) => acc + cur)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  if(this.nums.length === 0) return 0;\\n  return  this.nums.reduce((acc, cur) => acc + cur)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730153,
                "title": "js-easy-solition-enjoy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum +num, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum +num, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3719270,
                "title": "what-you-were-looking-for-3-lines-easy",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, val) => acc + val, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, val) => acc + val, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3696629,
                "title": "easy-3-lines-solution-uses-array-reduce-for-sum",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr)=>acc+curr,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr)=>acc+curr,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694771,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.length ? this.arr.reduce((a, b) => a + b) : 0;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.length ? this.arr.reduce((a, b) => a + b) : 0;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691009,
                "title": "js",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    sum = 0;\\n    for (i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    ans = \"[\";\\n    for (i = 0; i < this.nums.length; i++){\\n        ans += this.nums[i];\\n        if (i+1 != this.nums.length) {\\n            ans += \\',\\';\\n        }\\n    }\\n    ans += \"]\";\\n    return ans;\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    sum = 0;\\n    for (i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    ans = \"[\";\\n    for (i = 0; i < this.nums.length; i++){\\n        ans += this.nums[i];\\n        if (i+1 != this.nums.length) {\\n            ans += \\',\\';\\n        }\\n    }\\n    ans += \"]\";\\n    return ans;\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3690749,
                "title": "array-wrapper",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3661479,
                "title": "one-line-simple-solutions",
                "content": "- #### *Intuition*\\n\\n---\\n\\n- <!-- Describe your first thoughts on how to solve this problem. -->\\n\\n---\\n\\n- \\n\\n---\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n  return this.nums.length != 0 ? this.nums.reduce((a, b) => a + b) : 0;\\n};\\n\\nArrayWrapper.prototype.toString = function () {\\n  return \"[\" + this.nums.join(\",\") + \"]\"\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n  return this.nums.length != 0 ? this.nums.reduce((a, b) => a + b) : 0;\\n};\\n\\nArrayWrapper.prototype.toString = function () {\\n  return \"[\" + this.nums.join(\",\") + \"]\"\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3648159,
                "title": "solution-using-symbol-obj",
                "content": "# Description\\nThis article will help you understand my solution much better than I could explain to you. [link](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.nums = nums\\n    }\\n    [Symbol.toPrimitive](hint) {\\n        if (hint === \"string\") {\\n            return \"[\" + this.nums + \"]\"\\n        } else {\\n            let sum = 0\\n            for (const num of this.nums) {\\n                sum += num\\n            }\\n            return sum\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.nums = nums\\n    }\\n    [Symbol.toPrimitive](hint) {\\n        if (hint === \"string\") {\\n            return \"[\" + this.nums + \"]\"\\n        } else {\\n            let sum = 0\\n            for (const num of this.nums) {\\n                sum += num\\n            }\\n            return sum\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630525,
                "title": "array-wrapper-javascript-this-in-a-method",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() { \\n    return this.arr.reduce((a, b) => a + b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {    \\n    return \\'[\\' + this.arr + \\']\\'\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() { \\n    return this.arr.reduce((a, b) => a + b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {    \\n    return \\'[\\' + this.arr + \\']\\'\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3627046,
                "title": "js-arraywrapper-noodkhan-navin",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\n```\\n```\\nvar ArrayWrapper = function (nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function () {\\n    return `[${String(this.nums)}]`;\\n}\\n```\\n```\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n```\n```\\nvar ArrayWrapper = function (nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function () {\\n    return `[${String(this.nums)}]`;\\n}\\n```\n```\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623557,
                "title": "javascript-typeof",
                "content": "# Code\\n```\\nclass ArrayWrapper {\\n    nums: number[];\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    valueOf() {\\n        return this.nums.reduce((n, a) => n + a, 0);\\n    }\\n\\n    toString() {\\n        return \\'[\\' + this.nums.join(\\',\\') + \\']\\'\\n    }\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    nums: number[];\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    valueOf() {\\n        return this.nums.reduce((n, a) => n + a, 0);\\n    }\\n\\n    toString() {\\n        return \\'[\\' + this.nums.join(\\',\\') + \\']\\'\\n    }\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619648,
                "title": "simple-o-n-solution-with-explanation",
                "content": "# Intuition\\n- add this.nums property to ArrayWrapper constructor\\n- - (nums is already passed as an arg just add prop this.nums = nums)\\n\\n- update ArrayWrapper.valueOf to sum all values of array\\n- - use .flat method on this.nums to flatten nested arrays\\n- - use .reduce callback function to sum values of flattenedd array\\n- - return summedArray \\n\\n- update ArrayWrapper.toString to convert nums to a string\\n- - use JSON.stringify on this.nums to produce desired output format (.toString method removes brackets)\\n- - return stringified array\\n\\n# Approach\\nObject Oriented / Functional Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n) / linear\\n\\n- Space complexity:\\nO(n) / linear\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let flattenedArr = this.nums.flat(Infinity);\\n    let sumArr = flattenedArr.reduce(function(acc, curr) {\\n        return acc + curr;\\n    }, 0);\\n    return sumArr;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let arrayStr = JSON.stringify(this.nums);\\n    return arrayStr;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let flattenedArr = this.nums.flat(Infinity);\\n    let sumArr = flattenedArr.reduce(function(acc, curr) {\\n        return acc + curr;\\n    }, 0);\\n    return sumArr;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let arrayStr = JSON.stringify(this.nums);\\n    return arrayStr;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612053,
                "title": "javascript-reduce-tostring-2-solutions",
                "content": "# Code\\n##### Solution 1\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.toString() + \"]\";\\n}\\n```\\n##### Solution 2\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n    this.valueOf = () => this.nums.reduce((acc, cur) => acc + cur, 0);\\n    this.toString = () => \"[\" + this.nums.toString() + \"]\";\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.toString() + \"]\";\\n}\\n```\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n    this.valueOf = () => this.nums.reduce((acc, cur) => acc + cur, 0);\\n    this.toString = () => \"[\" + this.nums.toString() + \"]\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612038,
                "title": "javascript-reduce-tostring",
                "content": "# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.toString() + \"]\";\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.toString() + \"]\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601757,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594495,
                "title": "javascript-faster-than-95",
                "content": "# Intuition\\nJust keep an array in a class\\'s field.\\n\\n# Approach\\nIn the constructor just keep an array in a class\\'s field.\\n```\\nthis.nums = nums;\\n```\\nThen in both methods use cycle to iterate through all the items of array:\\n```\\nfor (let i = 0; i < this.nums.length; i++){\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is the number of items in array.\\n\\n- Space complexity:\\n$$O(n)$$, where n is the number of items in array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var rs = 0;\\n    for (let i = 0; i < this.nums.length; i++){\\n        rs += this.nums[i];\\n    }\\n    return rs;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    var rs = \"[\";\\n    for (let i = 0; i < this.nums.length; i++){\\n        rs += this.nums[i];\\n        if (i < this.nums.length - 1) rs+= \",\";\\n    }\\n    rs += \"]\";\\n    return rs;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nthis.nums = nums;\\n```\n```\\nfor (let i = 0; i < this.nums.length; i++){\\n```\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var rs = 0;\\n    for (let i = 0; i < this.nums.length; i++){\\n        rs += this.nums[i];\\n    }\\n    return rs;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    var rs = \"[\";\\n    for (let i = 0; i < this.nums.length; i++){\\n        rs += this.nums[i];\\n        if (i < this.nums.length - 1) rs+= \",\";\\n    }\\n    rs += \"]\";\\n    return rs;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594481,
                "title": "easy-self-explainary-day-28",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((n,a) => n + a, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((n,a) => n + a, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593241,
                "title": "day-28-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((accumulator, item) => accumulator += item, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((accumulator, item) => accumulator += item, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593089,
                "title": "3-line-easy-solution-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, n) => sum + n, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, n) => sum + n, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591971,
                "title": "beginner-friendly-js-solution",
                "content": "> **DISCLAIMER: ** I am not a Pro, Just sharing my solution here to start a healthy discussion, if you feel it could have been better, please feel free to share your solution and thoughts \\uD83D\\uDE4F below\\n\\n# Intuition\\nArray `reduce()` method and String Interpolation might be useful \\uD83E\\uDD14\\uD83D\\uDE00\\n\\n# Approach\\nWhile creating an object we are passing an array of integers and the value of instance we are expecting it to be the sum of all the integers to achieve this we have `Array.prototype.reduce()`.\\n\\nAnd for showing the instance in form of a string, we can use string interpolation to retain those `[Square brackets]`\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/7cde9949-6770-4d4c-b6c3-d8506c56a0ee_1685775711.1795843.png)\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.length > 0 ? this.nums.reduce( (acc,e) => acc+e) : 0;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return String(`[${this.nums}]`);\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.length > 0 ? this.nums.reduce( (acc,e) => acc+e) : 0;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return String(`[${this.nums}]`);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590939,
                "title": "easy-ts-solution-reduce",
                "content": "Ja# Code\\n```\\nclass ArrayWrapper {\\n    arr: Array<number>;\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.arr.reduce((accumulated, curr) => {\\n            accumulated += curr;\\n            return accumulated;\\n        },0);\\n    }\\n\\n\\ttoString() {\\n        return `[${this.arr.toString()}]`;\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    arr: Array<number>;\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.arr.reduce((accumulated, curr) => {\\n            accumulated += curr;\\n            return accumulated;\\n        },0);\\n    }\\n\\n\\ttoString() {\\n        return `[${this.arr.toString()}]`;\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590825,
                "title": "my-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this._nums = nums ? nums : [];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this._nums.reduce( (sum,cur) => {return sum + cur}, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this._nums.join()}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this._nums = nums ? nums : [];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this._nums.reduce( (sum,cur) => {return sum + cur}, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this._nums.join()}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590686,
                "title": "javascript-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBy assigning the numbers array to the this.numbers property, we make the array accessible within the instance. This allows other methods or functions defined on the instance, such as the sum() prototype function, to access and work with the numbers array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let total = 0;\\n    for(let i = 0; i < this.nums.length; ++i) {\\n        total += this.nums[i];\\n    }\\n    return total;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = JSON.stringify(this.nums);\\n    return str;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let total = 0;\\n    for(let i = 0; i < this.nums.length; ++i) {\\n        total += this.nums[i];\\n    }\\n    return total;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = JSON.stringify(this.nums);\\n    return str;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588447,
                "title": "easy-solution",
                "content": "Kindly upvote if you like my solution\\n\\n```\\n/**\\n * @param {number[]} nums\\n */\\n let nums;\\nvar ArrayWrapper = function(nums) {\\n    this.nums= nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const initialValue = 0;\\n    const sumWithInitial = this.nums.reduce(\\n  (accumulator, currentValue) => accumulator + currentValue,\\n  initialValue\\n);\\nreturn sumWithInitial;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n let nums;\\nvar ArrayWrapper = function(nums) {\\n    this.nums= nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const initialValue = 0;\\n    const sumWithInitial = this.nums.reduce(\\n  (accumulator, currentValue) => accumulator + currentValue,\\n  initialValue\\n);\\nreturn sumWithInitial;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587699,
                "title": "js-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => {\\n        return a+b\\n    }, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => {\\n        return a+b\\n    }, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587321,
                "title": "one-line-code-for-each-method",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587279,
                "title": "if-you-don-t-know-now-you-know",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHonestly, I just felt something inside of me and just cracked this bad boy out\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed my fingers to press buttons on my keyboard then finally clicking submit with my mousepad\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.storage = nums\\n    this.added = this.storage.reduce((accum, curr) => accum + curr, 0)\\n    this.stringy = `[${this.storage.join(\",\")}]`\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.added\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return this.stringy\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.storage = nums\\n    this.added = this.storage.reduce((accum, curr) => accum + curr, 0)\\n    this.stringy = `[${this.storage.join(\",\")}]`\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.added\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return this.stringy\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587198,
                "title": "simple-typescript-solution",
                "content": "\\n# Code\\n```\\nclass ArrayWrapper {\\n    nums: number[] = [];\\n\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    valueOf() {\\n        return this.nums.length > 0 \\n            ? this.nums.reduce((acc, value) => acc + value)\\n            : 0;\\n    }\\n    toString() {\\n        return `[${this.nums.join(\\',\\')}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    nums: number[] = [];\\n\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    valueOf() {\\n        return this.nums.length > 0 \\n            ? this.nums.reduce((acc, value) => acc + value)\\n            : 0;\\n    }\\n    toString() {\\n        return `[${this.nums.join(\\',\\')}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586864,
                "title": "3-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,total)=>acc+total, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,total)=>acc+total, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586789,
                "title": "easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **reduce method:**\\n    - Syntax: `reduce(callbackFn, initialValue)`\\n    - callbackFn (in this Case):\\n        - `(accumulator, currentValue) => accumulator + currentValue, initialValue)`\\n        - accumulator:\\n            - Holds resulting value from the previous call to callbackFn.\\n            - Initially holds initialValue (if specified).\\n            - Otherwise holds the value of array[0].\\n        - currentValue:\\n            - It is the current element\\'s value.\\n            - On first call:\\n                - If initial value was specified:\\n                    - It has value of array[0]\\n                - Otherwise:\\n                    - it has the value of array[1].\\n\\n\\n# Code\\n``` javaScript []\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((sum, currentValue) => sum + currentValue, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.arr.join(\",\") + \"]\";\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((sum, currentValue) => sum + currentValue, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.arr.join(\",\") + \"]\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586768,
                "title": "array-wrapper-easy-solution-es6",
                "content": "# Code 1\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr)=>acc+curr,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n\\n```\\n# Code 2\\n```\\nclass ArrayWrapper{\\n    constructor(nums){\\n        this.nums = nums;\\n    }\\n\\n    valueOf(){\\n        return this.nums.reduce((a,b)=>a+b, 0);\\n    }\\n\\n    toString(){\\n        return `[${this.nums}]`;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr)=>acc+curr,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n\\n```\n```\\nclass ArrayWrapper{\\n    constructor(nums){\\n        this.nums = nums;\\n    }\\n\\n    valueOf(){\\n        return this.nums.reduce((a,b)=>a+b, 0);\\n    }\\n\\n    toString(){\\n        return `[${this.nums}]`;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586699,
                "title": "simple-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586595,
                "title": "simple-solution-typescript-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe `ArrayWrapper` class is designed to provide custom behavior when used in arithmetic operations and when converted to a string. In this case, the `ArrayWrapper` objects are expected to behave like arrays when added together and should return the sum of their elements. When converted to a string, they should return a formatted string representation of the wrapped array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a constructor function `ArrayWrapper` that takes an array `nums` as its parameter ans store in it\\'s instance.\\n\\n2. Implement the `valueOf()` method for the `ArrayWrapper` prototype. This method calculates the sum of nums and return the calculated sum.\\n\\n3. Implement the `toString()` method for the `ArrayWrapper` prototype. This method concatenate the array elements to a string representation, separated by commas. Wrap the resulting string with square brackets (`[]`) to match the desired format. Return the formatted string.\\n\\n# Code\\n``` javascript []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((prev, cur) => cur + prev, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\\n``` typescript []\\nclass ArrayWrapper {\\n    nums: number[];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n       return this.nums.reduce((prev, cur) => cur + prev, 0) \\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.join(\\',\\')}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Design"
                ],
                "code": "``` javascript []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((prev, cur) => cur + prev, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\n``` typescript []\\nclass ArrayWrapper {\\n    nums: number[];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n       return this.nums.reduce((prev, cur) => cur + prev, 0) \\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.join(\\',\\')}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586575,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\ninterface ArrayWrapper {\\n    nums: number[];\\n    valueOf: () => number;\\n    toString: () => string;\\n}\\n\\nfunction ArrayWrapper(this: ArrayWrapper, nums: number[]) {\\n    this.nums = nums;\\n}\\n\\nArrayWrapper.prototype.valueOf = function(this: ArrayWrapper): number {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function(this: ArrayWrapper): string {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```\\n``` javascript []\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\ninterface ArrayWrapper {\\n    nums: number[];\\n    valueOf: () => number;\\n    toString: () => string;\\n}\\n\\nfunction ArrayWrapper(this: ArrayWrapper, nums: number[]) {\\n    this.nums = nums;\\n}\\n\\nArrayWrapper.prototype.valueOf = function(this: ArrayWrapper): number {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function(this: ArrayWrapper): string {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```\n``` javascript []\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586351,
                "title": "js-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=> a+b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=> a+b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586232,
                "title": "new-syntax-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntbh, at first thought I didn\\'t know what to do. I\\'m not too familiar with classes in javascrpt.\\n\\nI learned a lot with this exercise.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n  valueOf() {\\n    const a = this.nums.reduce((sum, current) => {\\n      return sum + current;\\n    }, 0);\\n    return a;\\n  }\\n  toString() {\\n    return `[${this.nums}]`;\\n  }\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n  valueOf() {\\n    const a = this.nums.reduce((sum, current) => {\\n      return sum + current;\\n    }, 0);\\n    return a;\\n  }\\n  toString() {\\n    return `[${this.nums}]`;\\n  }\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586127,
                "title": "easy-ts-implementation",
                "content": "\\n```\\nclass ArrayWrapper {\\n    array: number[]\\n\\tconstructor(nums: number[]) {\\n        this.array = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.array.reduce((sum, item) => sum+item,0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.array.join(\\',\\')}]`\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    array: number[]\\n\\tconstructor(nums: number[]) {\\n        this.array = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.array.reduce((sum, item) => sum+item,0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.array.join(\\',\\')}]`\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585898,
                "title": "day-28-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585850,
                "title": "3-lines-easy-and-clean-solution",
                "content": "# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585816,
                "title": "easy-to-read",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, currentValue) => acc + currentValue, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.arr.join() + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, currentValue) => acc + currentValue, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.arr.join() + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585776,
                "title": "day28-simple-beginner-friendly-js-solution",
                "content": "# Intuition\\n**The given  question have 3 parts**\\n\\n\\n1. **ArrayWrapper constructor** : this just takes an array as parameter and assign it to nums of arrayWrapper.\\n2. **valueOf** : this function just returns the sum of each element of the array in ArrayWrapper class.\\n3. **toString** : this method just converts the array : [1,2,3] to string \"[1,2,3]\" form .\\n\\n# Approach\\n**Step 1**: \\n```\\n this.array = nums;\\n\\n    here the parameterized array is now stored as array element\\n    of ArrayWrapper Class.\\n```\\n\\n\\n**Step 2** :\\n```\\nlet sum = 0;\\n    this.array.forEach((val)=>{\\n        sum += val;\\n    })\\n    return sum;\\n\\nHere a sum var will store the value of sum of each element of \\nthe array of arrayWrapper classes obj.\\n\\nthis can be accessed by : this.array\\n\\n\\nLater on sum is returned.\\n```\\n\\n**Step 3** : \\n```\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n}\\n\\nHere we just need to convert the array into string \\nSo we will use join method .\\nhere the returning string will \\n\\'[\\'  + string returned  by the this.array.join(\\',\\') + \\']\\'\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    this.array.forEach((val)=>{\\n        sum += val;\\n    })\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n this.array = nums;\\n\\n    here the parameterized array is now stored as array element\\n    of ArrayWrapper Class.\\n```\n```\\nlet sum = 0;\\n    this.array.forEach((val)=>{\\n        sum += val;\\n    })\\n    return sum;\\n\\nHere a sum var will store the value of sum of each element of \\nthe array of arrayWrapper classes obj.\\n\\nthis can be accessed by : this.array\\n\\n\\nLater on sum is returned.\\n```\n```\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n}\\n\\nHere we just need to convert the array into string \\nSo we will use join method .\\nhere the returning string will \\n\\'[\\'  + string returned  by the this.array.join(\\',\\') + \\']\\'\\n```\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    this.array.forEach((val)=>{\\n        sum += val;\\n    })\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585765,
                "title": "simple-typescript-solution-using-array-reduce-and-string-function",
                "content": "# Code\\n```\\nclass ArrayWrapper {\\n    protected arr: number[];\\n\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\tvalueOf() {\\n        return this.arr.reduce((acc, val) => acc + val, 0);\\n    }\\n\\ttoString() {\\n        return \"[\" + String(this.arr) + \"]\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    protected arr: number[];\\n\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\tvalueOf() {\\n        return this.arr.reduce((acc, val) => acc + val, 0);\\n    }\\n\\ttoString() {\\n        return \"[\" + String(this.arr) + \"]\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585663,
                "title": "easy-typescript-solution",
                "content": "\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n    arr: number[] = [];\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.arr.reduce((a, b) => a + b, 0);\\n    }\\n\\n\\ttoString() {\\n        return \\'[\\' + this.arr.toString() + \\']\\';\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    arr: number[] = [];\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.arr.reduce((a, b) => a + b, 0);\\n    }\\n\\n\\ttoString() {\\n        return \\'[\\' + this.arr.toString() + \\']\\';\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585620,
                "title": "chatgpt-code-snippet",
                "content": "**Intuition:**\\n\\nThe goal of the problem is to create a class called `ArrayWrapper` that performs addition and string conversion operations on arrays. The `ArrayWrapper` class accepts an array of integers as input.\\n\\nTo achieve this, we can implement the `ArrayWrapper` class with two methods: `valueOf()` and `toString()`. \\n\\nThe `valueOf()` method calculates the sum of all the elements in the array by iterating over the array and adding each element to a running sum. This method is invoked when the instances of `ArrayWrapper` are added together using the `+` operator.\\n\\nThe `toString()` method converts the array to a string representation surrounded by brackets. It uses the `join()` method to concatenate the elements of the array with a comma as the separator. This method is invoked when the `String()` function is called on an instance of `ArrayWrapper`.\\n\\n**Approach:**\\n\\n1. Define the `ArrayWrapper` class that accepts an array of integers as the constructor parameter. Store the array as an instance variable (`this.nums`).\\n2. Implement the `valueOf()` method:\\n   - Initialize a variable `sum` to 0.\\n   - Iterate over each element `num` in `this.nums`.\\n   - Add `num` to `sum` in each iteration.\\n   - Return the final `sum`.\\n3. Implement the `toString()` method:\\n   - Convert the array to a comma-separated string using the `join()` method.\\n   - Prepend `\\'[\\'` and append `\\']\\'` to the resulting string.\\n   - Return the final string representation.\\n4. Test the `ArrayWrapper` class by creating instances and performing the required operations.\\n\\n**Complexity Analysis:**\\n\\nLet\\'s analyze the time and space complexity of the solution:\\n\\n- Time Complexity: The `valueOf()` method iterates over each element of the array, resulting in a time complexity of O(N), where N is the number of elements in the array. The `toString()` method also has a time complexity of O(N) due to the `join()` operation. Therefore, the overall time complexity is O(N), where N is the size of the input array.\\n- Space Complexity: The space complexity is O(1) since the additional space used by the class does not depend on the input size.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "**Intuition:**\\n\\nThe goal of the problem is to create a class called `ArrayWrapper` that performs addition and string conversion operations on arrays. The `ArrayWrapper` class accepts an array of integers as input.\\n\\nTo achieve this, we can implement the `ArrayWrapper` class with two methods: `valueOf()` and `toString()`. \\n\\nThe `valueOf()` method calculates the sum of all the elements in the array by iterating over the array and adding each element to a running sum. This method is invoked when the instances of `ArrayWrapper` are added together using the `+` operator.\\n\\nThe `toString()` method converts the array to a string representation surrounded by brackets. It uses the `join()` method to concatenate the elements of the array with a comma as the separator. This method is invoked when the `String()` function is called on an instance of `ArrayWrapper`.\\n\\n**Approach:**\\n\\n1. Define the `ArrayWrapper` class that accepts an array of integers as the constructor parameter. Store the array as an instance variable (`this.nums`).\\n2. Implement the `valueOf()` method:\\n   - Initialize a variable `sum` to 0.\\n   - Iterate over each element `num` in `this.nums`.\\n   - Add `num` to `sum` in each iteration.\\n   - Return the final `sum`.\\n3. Implement the `toString()` method:\\n   - Convert the array to a comma-separated string using the `join()` method.\\n   - Prepend `\\'[\\'` and append `\\']\\'` to the resulting string.\\n   - Return the final string representation.\\n4. Test the `ArrayWrapper` class by creating instances and performing the required operations.\\n\\n**Complexity Analysis:**\\n\\nLet\\'s analyze the time and space complexity of the solution:\\n\\n- Time Complexity: The `valueOf()` method iterates over each element of the array, resulting in a time complexity of O(N), where N is the number of elements in the array. The `toString()` method also has a time complexity of O(N) due to the `join()` operation. Therefore, the overall time complexity is O(N), where N is the size of the input array.\\n- Space Complexity: The space complexity is O(1) since the additional space used by the class does not depend on the input size.",
                "codeTag": "Java"
            },
            {
                "id": 3585574,
                "title": "javascript-simple-javascript-typescript-solution-basic-coding-technique",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 60 ms, faster than 57.14% of JavaScript online submissions for Array Wrapper.\\n# Memory Usage: 44.7 MB, less than 10.28% of JavaScript online submissions for Array Wrapper.\\n\\n\\t\\tvar ArrayWrapper = function(nums) {\\n\\t\\t\\tthis.nums = nums;\\n\\t\\t};\\n\\n\\t\\tArrayWrapper.prototype.valueOf = function() {\\n\\n\\t\\t\\tlet result = 0;\\n\\n\\t\\t\\tfor(let index = 0; index < this.nums.length ; index++){\\n\\t\\t\\t\\tresult = result + this.nums[index];\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tArrayWrapper.prototype.toString = function() {\\n\\n\\t\\t\\tlet result = \"[\";\\n\\n\\t\\t\\tfor(let index = 0; index < this.nums.length ; index++){\\n\\n\\t\\t\\t\\tif(index === this.nums.length - 1){\\n\\t\\t\\t\\t\\tresult = result + this.nums[index];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tresult = result + this.nums[index] + \",\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult = result + \"]\";\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 60 ms, faster than 57.14% of JavaScript online submissions for Array Wrapper.\\n# Memory Usage: 44.7 MB, less than 10.28% of JavaScript online submissions for Array Wrapper.\\n\\n\\t\\tvar ArrayWrapper = function(nums) {\\n\\t\\t\\tthis.nums = nums;\\n\\t\\t};\\n\\n\\t\\tArrayWrapper.prototype.valueOf = function() {\\n\\n\\t\\t\\tlet result = 0;\\n\\n\\t\\t\\tfor(let index = 0; index < this.nums.length ; index++){\\n\\t\\t\\t\\tresult = result + this.nums[index];\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tArrayWrapper.prototype.toString = function() {\\n\\n\\t\\t\\tlet result = \"[\";\\n\\n\\t\\t\\tfor(let index = 0; index < this.nums.length ; index++){\\n\\n\\t\\t\\t\\tif(index === this.nums.length - 1){\\n\\t\\t\\t\\t\\tresult = result + this.nums[index];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tresult = result + this.nums[index] + \",\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult = result + \"]\";\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3585468,
                "title": "js-inbuilt-operators-time-61ms-49-space-44mb-57",
                "content": "# Approach\\nWe\\'ll store the arrays of integers and overload the inbuilt ValueOf and String operator as requested by the function.\\n\\n# Complexity\\n- Time complexity:\\nO(n) *, where n is the lenght of the array*\\n\\n- Space complexity:\\nO(n) *, where n is the lenght of the array*\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585369,
                "title": "easy-javascript-solution-using-reduce",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/7a315f9e-9e80-4c59-a572-c32556614966_1685610772.228738.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585344,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, v)=>acc+v,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+this.nums.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, v)=>acc+v,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+this.nums.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585316,
                "title": "use-reduce-and-string",
                "content": "# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, elem) => acc + elem, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, elem) => acc + elem, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585123,
                "title": "typescript-solution",
                "content": "```\\nclass ArrayWrapper {\\n    nums: number[]\\n\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((sum, value) => sum + value, 0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.toString()}]`\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    nums: number[]\\n\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((sum, value) => sum + value, 0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.toString()}]`\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585077,
                "title": "beats-93-easy-javascript-solution-2695-array-wrapper-javascript-day-28",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce(\\n        (n,a) => n+a,0\\n    );\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce(\\n        (n,a) => n+a,0\\n    );\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585010,
                "title": "simple-solution-using-prototype-and-class-2-solutions",
                "content": "# Code Using Prototype\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n//Time complexity: O(n) - where n is the length of the nums array\\n//Space complexity: O(1)\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\n\\n//Time complexity: O(n) - where n is the length of the nums array\\n//Space complexity: O(1)\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\",\")}]`;\\n}\\n```\\n\\n# Code Using Class\\n```\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.nums = nums;\\n    }\\n\\n    //Time complexity: O(n) - where n is the length of the nums array\\n    //Space complexity: O(1)\\n    valueOf() {\\n        return this.nums.reduce((acc, cur) => acc + cur, 0);\\n    }\\n\\n    //Time complexity: O(n) - where n is the length of the nums array\\n    //Space complexity: O(1)\\n    toString() {\\n        return `[${this.nums.join(\",\")}]`;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n//Time complexity: O(n) - where n is the length of the nums array\\n//Space complexity: O(1)\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\n\\n//Time complexity: O(n) - where n is the length of the nums array\\n//Space complexity: O(1)\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\",\")}]`;\\n}\\n```\n```\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.nums = nums;\\n    }\\n\\n    //Time complexity: O(n) - where n is the length of the nums array\\n    //Space complexity: O(1)\\n    valueOf() {\\n        return this.nums.reduce((acc, cur) => acc + cur, 0);\\n    }\\n\\n    //Time complexity: O(n) - where n is the length of the nums array\\n    //Space complexity: O(1)\\n    toString() {\\n        return `[${this.nums.join(\",\")}]`;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584977,
                "title": "typescript-using-reduce-method-and-storing-the-sum-runtime-70-memory-60",
                "content": "\\n# Complexity\\n- Time complexity: $$O(1)$$ for adding and $$O(n)$$ for reduce() and toString()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```TypeScript\\nclass ArrayWrapper {\\n    nums: number[];\\n    sum: number;\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n        this.sum = nums.reduce((a, b) => a + b, 0);\\n    }\\n\\n\\tvalueOf(): number {\\n        return this.sum;\\n    }\\n\\n\\ttoString(): string {\\n        return `[${this.nums.toString()}]`;\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```TypeScript\\nclass ArrayWrapper {\\n    nums: number[];\\n    sum: number;\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n        this.sum = nums.reduce((a, b) => a + b, 0);\\n    }\\n\\n\\tvalueOf(): number {\\n        return this.sum;\\n    }\\n\\n\\ttoString(): string {\\n        return `[${this.nums.toString()}]`;\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584905,
                "title": "easy-one-line-solutions-with-respectible-space-and-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSum the values and turn them into strings\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nsimple one line solutions \\n\\n# Complexity\\n- Time complexity: 0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1), O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) { \\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((acc,curr)=>acc+curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) { \\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((acc,curr)=>acc+curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584745,
                "title": "javascript-class-for-arraywrapper-with-sum-and-string-representation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can create a class called `ArrayWrapper` that accepts an array of integers in its constructor. The class should have two methods: `valueOf` and `toString`. The `valueOf` method will be called when two instances of the class are added together with the `+` operator, and the `toString` method will be called when the `String()` function is used on the instance.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a class `ArrayWrapper` with a constructor that accepts an array of integers(`nums`) and assigns it to the class instance.\\n2. Implement the `valueOf` method that calculates the sum of all the elements in the `nums` array using the `reduce` method.\\n3. Implement the `toString` method that converts the `nums` array to a string representation using the `join` method to join the elements with commas, and surround the resulting string with brackets.\\n4. Test the class by creating instances of `ArrayWrapper` and performing the required operations.\\n\\n# Complexity\\n- Time complexity: The `valueOf` method has a time complexity of O(n) as it uses the `reduce` method to iterate over the array and calculate the sum. The `toString` method has a time complexity of O(n) as it uses the `join` method to concatenate the elements of the array into a string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity is O(n), where n is the length of the `nums` array. The `ArrayWrapper` class stores the `nums` array as an instance variable, which requires space proportional to the length of the array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584735,
                "title": "easy-solution-javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr) => acc+ curr, 0 )\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + String(this.nums) + \"]\"\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr) => acc+ curr, 0 )\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + String(this.nums) + \"]\"\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584703,
                "title": "easy-solution-o-n-one-liner",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, cur) => acc + cur, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, cur) => acc + cur, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584698,
                "title": "create-arraywrapper-class-in-javascript",
                "content": "1. The ArrayWrapper class is defined with a constructor that takes an array of integers as input and assigns it to the nums property of the instance.\\n\\n2. The valueOf() method is implemented to calculate the sum of all the elements in the array (nums) using the reduce() method with an initial value of 0.\\n\\n3. The toString() method is implemented to return a string representation of the array (nums) by joining its elements with commas and surrounding them with brackets.\\n\\n4. Since JavaScript automatically converts objects to their primitive values when the + operator is used, we don\\'t need to explicitly define the + operator behavior for ArrayWrapper. Instead, we leverage the valueOf() method, which returns the sum of all the elements in the array, allowing us to use the + operator on two ArrayWrapper instances to get the desired result.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584657,
                "title": "easy-js-solution-for-beginners",
                "content": "\\nvar ArrayWrapper = function(nums) {\\n     this.nums = nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n   return this.nums.reduce((sum, num) => sum + num, 0); \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\nvar ArrayWrapper = function(nums) {\\n     this.nums = nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n   return this.nums.reduce((sum, num) => sum + num, 0); \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3584630,
                "title": "fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return JSON.stringify(this.array);\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return JSON.stringify(this.array);\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584600,
                "title": "day-28-easy-solution-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\'+this.nums.toString()+\\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\'+this.nums.toString()+\\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584522,
                "title": "best-solution-for-array-wrappes-99-99-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.array.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.array.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584504,
                "title": "array-wrapper-easy-solution-o-n-complexity",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584497,
                "title": "simple-arraywrapper-using-function-declaration",
                "content": "# Intuition\\n- for converting any object to string (`toString()`) should be overridden\\n- for taking out value we have another method `valueof()`\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nfunction ArrayWrapper(nums) {\\n  this.values = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n return this.values.reduce((acc, item) => acc+item, 0)   \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.values.join(\\',\\')}]`\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nfunction ArrayWrapper(nums) {\\n  this.values = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n return this.values.reduce((acc, item) => acc+item, 0)   \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.values.join(\\',\\')}]`\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584466,
                "title": "simple-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.data = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this?.data?.reduce((prev, cur) => prev + cur, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.data.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.data = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this?.data?.reduce((prev, cur) => prev + cur, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.data.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584413,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.arr=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\nlet Sum=0;\\n    let arr1=this.arr;\\n    for(v of arr1){\\n        Sum+=v;\\n    }\\n    return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.arr=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\nlet Sum=0;\\n    let arr1=this.arr;\\n    for(v of arr1){\\n        Sum+=v;\\n    }\\n    return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584386,
                "title": "array-wrapper",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\n\\n// constructor funfor ArrayWrapper\\nvar ArrayWrapper = function(nums) {\\n  this.arr = nums;\\n};\\n\\n//  calculate the sum of all elements \\nArrayWrapper.prototype.valueOf = function() {\\n  return this.arr.reduce(function(sum, num) {\\n    return sum + num;\\n  }, 0);\\n};\\n\\n//  converting the array to a string \\nArrayWrapper.prototype.toString = function() {\\n  return \"[\" + this.arr.join(\",\") + \"]\";\\n};\\n\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\n\\n// constructor funfor ArrayWrapper\\nvar ArrayWrapper = function(nums) {\\n  this.arr = nums;\\n};\\n\\n//  calculate the sum of all elements \\nArrayWrapper.prototype.valueOf = function() {\\n  return this.arr.reduce(function(sum, num) {\\n    return sum + num;\\n  }, 0);\\n};\\n\\n//  converting the array to a string \\nArrayWrapper.prototype.toString = function() {\\n  return \"[\" + this.arr.join(\",\") + \"]\";\\n};\\n\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584377,
                "title": "easy-solution-daily-lc-javascript-challenge-june-day-28-30",
                "content": "\\n# Approach\\nThe approach of the code is to use the reduce method of arrays to calculate the sum of the numbers in the nums property of the ArrayWrapper instance. The toString method uses the JSON.stringify function to convert the nums property to a JSON string.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the valueOf method is O(n), where n is the length of the nums array, because it iterates over all elements of the array to compute the sum. The time complexity of the toString method is also O(n), because JSON.stringify iterates over all elements of the array to create a JSON string.\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n        return this.nums.reduce((acc, curr) => acc + curr, 0);\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n        return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n        return this.nums.reduce((acc, curr) => acc + curr, 0);\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n        return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584357,
                "title": "javascript-easy-to-understand-solution-97",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584339,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((sum,val)=>{\\n        return sum+val;\\n    },0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.array.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((sum,val)=>{\\n        return sum+val;\\n    },0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.array.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584239,
                "title": "java-script-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584216,
                "title": "javascript-add-string-nums",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let tot = 0\\n    for (let i =0; i< this.arr.length; i ++){\\n        tot += this.arr[i]\\n    }\\n    return tot\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = \\'[\\'\\n    for (let i =0; i< this.arr.length; i ++){\\n        if (i == this.arr.length - 1){\\n            str += String(this.arr[i])\\n        }\\n        else{\\n            str += String(this.arr[i]) + \\',\\'\\n        }\\n    }\\n    str += \\']\\'\\n    \\n    return str\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let tot = 0\\n    for (let i =0; i< this.arr.length; i ++){\\n        tot += this.arr[i]\\n    }\\n    return tot\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = \\'[\\'\\n    for (let i =0; i< this.arr.length; i ++){\\n        if (i == this.arr.length - 1){\\n            str += String(this.arr[i])\\n        }\\n        else{\\n            str += String(this.arr[i]) + \\',\\'\\n        }\\n    }\\n    str += \\']\\'\\n    \\n    return str\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3584199,
                "title": "easy-solution-with-this-array-reduce-and-array-join",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc,cur) => acc + cur, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc,cur) => acc + cur, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584146,
                "title": "javascript-typescript-1-line-each-time-space-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums\\n}\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce( ( s, v ) => s + v, 0 )\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.array)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums\\n}\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce( ( s, v ) => s + v, 0 )\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.array)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584133,
                "title": "day-28-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584069,
                "title": "solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n    \\n}\\n\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n    \\n}\\n\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584028,
                "title": "easy-javascript-solution",
                "content": "# Approach\\n\\n1. The `ArrayWrapper` constructor accepts an array of numbers (`nums`) as input and assigns it to the `array` property of the instance.\\n\\n2. The `valueOf` method is overridden to provide a custom behavior when the object is used in a numerical context (such as addition). It uses the `reduce` method on the `array` property to calculate the sum of all elements and returns the result.\\n\\n3. The `toString` method is overridden to provide a custom behavior when the object is converted to a string. It uses the `join` method on the `array` property to concatenate all elements with commas, and surrounds the resulting string with brackets.\\n\\nBy implementing these methods, we ensure that the `ArrayWrapper` instances can be added together using the `+` operator and that they produce the expected string representation when converted to a string using `String(obj)` or `obj.toString()`.\\n\\nThe usage examples demonstrate how to create instances of `ArrayWrapper`, perform addition between them (`obj1 + obj2`), and convert them to strings (`String(obj1)`).\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((acc, curr) => acc + curr, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((acc, curr) => acc + curr, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584012,
                "title": "day-28",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((subSum,subNum)=>subSum+subNum,0)\\n    \\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\'+this.nums.flat().join(\\',\\')+\\']\\'  \\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((subSum,subNum)=>subSum+subNum,0)\\n    \\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\'+this.nums.flat().join(\\',\\')+\\']\\'  \\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583579,
                "title": "javascript-good-enough",
                "content": "``` JavaScript []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((x,y) => x+y, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaScript []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((x,y) => x+y, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3581502,
                "title": "immutable-array-snapshot",
                "content": "Creates string and numerical representation right away, doesn\\'t process array afterwards:\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.str = \"[\" + nums.join(\\',\\') + \"]\";\\n    this.val = nums.reduce((a,b)=>a+b,0);\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.val;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return this.str;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.str = \"[\" + nums.join(\\',\\') + \"]\";\\n    this.val = nums.reduce((a,b)=>a+b,0);\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.val;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return this.str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580455,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n   return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n   return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578786,
                "title": "js",
                "content": "\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.list=nums\\n}\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.list.reduce((t,e)=>t+e,0) \\n}\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.list}]`\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.list=nums\\n}\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.list.reduce((t,e)=>t+e,0) \\n}\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.list}]`\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1899981,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 1912728,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 1912967,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 2014522,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 2074746,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 2028003,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 1930339,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 1901472,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            }
        ]
    },
    {
        "title": "Compact Object",
        "question_content": "<p>Given an object or array&nbsp;<code>obj</code>, return a <strong>compact object</strong>. A <strong>compact object</strong>&nbsp;is the same as the original object, except with keys containing <strong>falsy</strong> values removed. This operation applies to the object and any nested objects. Arrays are considered objects where&nbsp;the indices are&nbsp;keys. A value is&nbsp;considered <strong>falsy</strong>&nbsp;when <code>Boolean(value)</code> returns <code>false</code>.</p>\n\n<p>You may assume the&nbsp;<code>obj</code> is&nbsp;the output of&nbsp;<code>JSON.parse</code>. In other words, it is valid JSON.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = [null, 0, false, 1]\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> All falsy values have been removed from the array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = {&quot;a&quot;: null, &quot;b&quot;: [false, 1]}\n<strong>Output:</strong> {&quot;b&quot;: [1]}\n<strong>Explanation:</strong> obj[&quot;a&quot;] and obj[&quot;b&quot;][0] had falsy values and were removed.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = [null, 0, 5, [0], [false, 16]]\n<strong>Output:</strong> [5, [], [16]]\n<strong>Explanation:</strong> obj[0], obj[1], obj[3][0], and obj[4][0] were falsy and removed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>obj</code> is a valid JSON object</li>\n\t<li><code>2 &lt;= JSON.stringify(obj).length &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3567296,
                "title": "simple-easy-full-thorough-explanation-beginner-friendly",
                "content": "# Intuition\\nSince the object can have subarrays and subobjects, recursion should be used. If the current recursive call is not an object, dealing with this is easy, and will be discussed below. If it is an object, then one should create a new object, let\\'s call this object ```compacted```. Then, iterate through each key in the object, and if the value is desireable (is not falsy), add the key and value to ```compacted```. When the entire object is iterated through, return ```comapcted```.\\n\\n# Approach\\n1. Check if ```obj``` is null. If so, return ```null```.\\n2. Check if ```obj``` is an array.\\n    - If so, we can first use the filter function. In this problem, one should use ```obj.filter(Boolean)```. Boolean is a function that returns true if the input value is truthy, and false if falsy. And so, the filter function will iterate through each element of the array and input it into the Boolean function (the filter function calls ```Boolean(obj[i])``` for all valid ```i```), and if the Boolean function returns true, filter will add the element into the return array, otherwise it will leave it out of the return array.\\n    - Next, we should call the map function on the array the filter function returns. The map function replaces each element in the array with the result of inputting the element in a specified function. In this problem, we want to make a recursive call on compactObject for each element, so that we can continue to remove falsy elements in any potential subobjects. So, we write ```obj.filter(Boolean).map(compactObject);``` so that the map function will call ```compactObject(obj[i])``` for all ```i``` in the array that the filter function returns. To make it clear, one can conceptualize this as: ```filterArr = obj.filter(Boolean);```, ```return filterArr.map(compactObject);```\\n3. Check if ```obj``` is not an object. If it isn\\'t return ```obj```.\\n4. If the past three steps have done nothing, that means ```obj``` is not null, an array, or not an object. So, it is an object, and we treat it as such.\\n    - Create empty variable. Here, it will be called ```compacted```.\\n    - Iterate through each key in ```obj```. For each key, we call compactObject on the key\\'s corresponding value, so we can remove any falsy values in any potential subarrays or subobjects in the value. If the result of this is truthy, we add the key and value to the ```compacted``` object. Else, do nothing, we do not want to add the key and falsy value.\\n5. After iterating through all of ```obj```, return ```compacted```.\\n\\n# Code\\n```\\nvar compactObject = function(obj) {\\n    // These three if statements deal with when obj is not an iterable object\\n    // Steps 1-3 as described above\\n    if (obj === null) return null;\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n    if (typeof obj !== \"object\") return obj;\\n\\n    // This for loop deals with when obj is an iterable object\\n    // Steps 4-5 as described above\\n    const compacted = {};\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n        if (Boolean(value)) compacted[key] = value;\\n    }\\n\\n    return compacted;\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```compacted```\n```compacted```\n```comapcted```\n```obj```\n```null```\n```obj```\n```obj.filter(Boolean)```\n```Boolean(obj[i])```\n```i```\n```obj.filter(Boolean).map(compactObject);```\n```compactObject(obj[i])```\n```i```\n```filterArr = obj.filter(Boolean);```\n```return filterArr.map(compactObject);```\n```obj```\n```obj```\n```obj```\n```compacted```\n```obj```\n```compacted```\n```obj```\n```compacted```\n```\\nvar compactObject = function(obj) {\\n    // These three if statements deal with when obj is not an iterable object\\n    // Steps 1-3 as described above\\n    if (obj === null) return null;\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n    if (typeof obj !== \"object\") return obj;\\n\\n    // This for loop deals with when obj is an iterable object\\n    // Steps 4-5 as described above\\n    const compacted = {};\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n        if (Boolean(value)) compacted[key] = value;\\n    }\\n\\n    return compacted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595607,
                "title": "very-easy-to-understand-compact-object-by-removing-keys-with-falsy-values-recursive-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Check if the obj is not an object or is null. If so, return it as is.**\\n2. **If obj is an array:**\\n    - Create an empty compactArr.\\n    - Iterate through each element in the array, recursively compacting it.\\n    - If the compacted value is truthy, add it to compactArr.\\n    - Return \\n3. **If obj is an object**\\n    - Create an empty compactObj.\\n    - Iterate through each key in the object.\\n    - Recursively compact each value and add it to compactObj if it is truthy.\\n    - Return\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: **O(d)** , where d represents the depth of the nesting.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n\\nvar compactObject = function(obj) {\\n    // Base case: if obj is not an object or is null, return it as is\\n    if(typeof obj !== \\'object\\' || obj === null){\\n        return obj\\n    }\\n\\n    // Case for arrays: recursively compact each element and remove falsy values\\n    if(Array.isArray(obj)){\\n        const compactArr = []\\n        for(let i = 0; i < obj.length; i++){\\n            let val = compactObject(obj[i]);\\n            if(val){\\n                compactArr.push(val)\\n            }\\n        }\\n\\n        return compactArr\\n    } \\n\\n    // Case for objects: create a new compacted object\\n    const compactObj = {};\\n\\n    for(let key in obj){\\n        // Iterate over each key in the object\\n        const val = compactObject(obj[key]);\\n        // If the value is truthy, add it to the compacted object\\n        if(val){\\n            compactObj[key] = val\\n        }\\n    }\\n\\n    return compactObj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n\\nvar compactObject = function(obj) {\\n    // Base case: if obj is not an object or is null, return it as is\\n    if(typeof obj !== \\'object\\' || obj === null){\\n        return obj\\n    }\\n\\n    // Case for arrays: recursively compact each element and remove falsy values\\n    if(Array.isArray(obj)){\\n        const compactArr = []\\n        for(let i = 0; i < obj.length; i++){\\n            let val = compactObject(obj[i]);\\n            if(val){\\n                compactArr.push(val)\\n            }\\n        }\\n\\n        return compactArr\\n    } \\n\\n    // Case for objects: create a new compacted object\\n    const compactObj = {};\\n\\n    for(let key in obj){\\n        // Iterate over each key in the object\\n        const val = compactObject(obj[key]);\\n        // If the value is truthy, add it to the compacted object\\n        if(val){\\n            compactObj[key] = val\\n        }\\n    }\\n\\n    return compactObj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567111,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n  if (obj === null || typeof obj !== \\'object\\') {\\n    return obj;\\n  }\\n\\n  const result = {};\\n  for (const key in obj) {\\n    const value = compactObject(obj[key]);\\n    if (Boolean(value)) {\\n      result[key] = value;\\n    }\\n  }\\n  return result;   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n  if (obj === null || typeof obj !== \\'object\\') {\\n    return obj;\\n  }\\n\\n  const result = {};\\n  for (const key in obj) {\\n    const value = compactObject(obj[key]);\\n    if (Boolean(value)) {\\n      result[key] = value;\\n    }\\n  }\\n  return result;   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3789578,
                "title": "easy-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n -Check for the object or array.\\n -If array: \\n 1.Iterate through it.\\n 2.Check for falsy of object type:\\na)*If falsy*, delete it. and remove index by one to check\\n again for same index.\\n        b)*If object* type than call compactObject() with iterated value as parameter.\\n\\n-If Object:\\nSame process as array just different iterating method i used.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n\\n   if(Array.isArray(obj)){\\n      for(let i = 0;i< obj.length;i++){\\n         if(obj[i] ===null|| obj[i] ===0 || obj[i]===false||obj[i]===\"\"){\\n            obj.splice(i,1);\\n            i--;\\n         }\\n         if(typeof obj[i]===\\'object\\'){\\n            compactObject(obj[i]);\\n         }\\n      }\\n   }\\n   else{\\n      for(const key in obj){\\n         if(obj[key]===null||obj[key]===0||obj[key]===false||obj[key]===\"\"){\\n            delete obj[key];\\n         }\\n         if(typeof obj[key]===\\'object\\'){\\n            compactObject(obj[key]);\\n         }\\n      }\\n\\n   }\\n   return obj;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n\\n   if(Array.isArray(obj)){\\n      for(let i = 0;i< obj.length;i++){\\n         if(obj[i] ===null|| obj[i] ===0 || obj[i]===false||obj[i]===\"\"){\\n            obj.splice(i,1);\\n            i--;\\n         }\\n         if(typeof obj[i]===\\'object\\'){\\n            compactObject(obj[i]);\\n         }\\n      }\\n   }\\n   else{\\n      for(const key in obj){\\n         if(obj[key]===null||obj[key]===0||obj[key]===false||obj[key]===\"\"){\\n            delete obj[key];\\n         }\\n         if(typeof obj[key]===\\'object\\'){\\n            compactObject(obj[key]);\\n         }\\n      }\\n\\n   }\\n   return obj;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642392,
                "title": "easy-solution-o-n-time-and-space-complexity-javascript-typescript-versions",
                "content": "# Intuition\\nThe given solution aims to implement a function called **compactObject** that takes an object *obj* as input and returns a new object where all the falsy values (null, undefined, empty strings, etc.) are removed. This function uses recursion to traverse the object and its nested properties to solve this problem\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nFirst, we are checking if the input obj is an array. If it is, use the reduce method to iterate over each item in the array. For each item, recursively apply the **compactObject** function to obtain the compacted item. If the compacted item is truthy, adding it to the accumulator array. Finally, return the accumulated array.\\n\\nNext, we are checking if the input obj is an object (not an array) and not null. If it is, use the reduce method on the keys of the object. For each key, recursively apply the **compactObject** function to obtain the compacted value. If the compacted value is truthy, add it to the accumulator object with the same key. Finally, return the accumulated object.\\n\\nIf none of the above conditions are met, it means the input obj is a primitive value. Return the value if it is truthy or null if it is falsy.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upwote this solution if it will be useful for you \\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\n\\n# Javascript Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function (obj) {\\n    //check is it an array\\n    if (Array.isArray(obj)) {\\n        return obj.reduce((acc, cur) => {\\n            let value = compactObject(cur);\\n\\n            if (value) {\\n                acc.push(value);\\n            }\\n            \\n            return acc;\\n        }, [])\\n    }\\n\\n    //check is it an object\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).reduce((acc, key) => {\\n            let value = compactObject(obj[key]);\\n\\n            if (value) {\\n                acc[key] = value;\\n            }\\n            \\n            return acc\\n        }, {});\\n    }\\n\\n    // If it is neither an array, nor an object, nor null, return the value (which can be a string, number, or boolean)\\n    return obj || null;\\n};\\n\\n```\\n\\n# Typescript Code\\nIn the TypeScript version, the code includes type annotations for the functions parameter and the return type of the **compactObject** function. \\n\\nIn the TypeScript version, the function **compactObject** is defined as a generic function using the type parameter **T**. This allows the function to maintain type safety by preserving the input type and returning the same type.\\n\\nThe logic and flow of the code remain the same as in the original JavaScript solution. The only difference is the addition of type annotations to make the code TypeScript-compliant.\\n\\n```\\nconst compactObject = <T>(obj: T): T => {\\n    //check is it an array\\n    if (Array.isArray(obj)) {\\n        return obj.reduce((acc, cur) => {\\n            let value = compactObject(cur);\\n\\n            if (value) {\\n                acc.push(value);\\n            }\\n            \\n            return acc;\\n        }, [])\\n    }\\n\\n    //check is it an object\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).reduce((acc, key) => {\\n            let value = compactObject(obj[key]);\\n\\n            if (value) {\\n                acc[key] = value;\\n            }\\n            \\n            return acc\\n        }, {});\\n    }\\n\\n    // If it is neither an array, nor an object, nor null, return the value (which can be a string, number, or boolean)\\n    return obj || null;\\n};\\n\\n```\\n# Please Upwote this solution if it was useful for you \\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function (obj) {\\n    //check is it an array\\n    if (Array.isArray(obj)) {\\n        return obj.reduce((acc, cur) => {\\n            let value = compactObject(cur);\\n\\n            if (value) {\\n                acc.push(value);\\n            }\\n            \\n            return acc;\\n        }, [])\\n    }\\n\\n    //check is it an object\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).reduce((acc, key) => {\\n            let value = compactObject(obj[key]);\\n\\n            if (value) {\\n                acc[key] = value;\\n            }\\n            \\n            return acc\\n        }, {});\\n    }\\n\\n    // If it is neither an array, nor an object, nor null, return the value (which can be a string, number, or boolean)\\n    return obj || null;\\n};\\n\\n```\n```\\nconst compactObject = <T>(obj: T): T => {\\n    //check is it an array\\n    if (Array.isArray(obj)) {\\n        return obj.reduce((acc, cur) => {\\n            let value = compactObject(cur);\\n\\n            if (value) {\\n                acc.push(value);\\n            }\\n            \\n            return acc;\\n        }, [])\\n    }\\n\\n    //check is it an object\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).reduce((acc, key) => {\\n            let value = compactObject(obj[key]);\\n\\n            if (value) {\\n                acc[key] = value;\\n            }\\n            \\n            return acc\\n        }, {});\\n    }\\n\\n    // If it is neither an array, nor an object, nor null, return the value (which can be a string, number, or boolean)\\n    return obj || null;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582761,
                "title": "straight-forward-recursive-solution-with-comments",
                "content": "# Intuition\\nRecursive iteration thru the object keys and array elements.\\n\\n# Approach\\nCheck the type of given object. If the type is an array or object, loop thru each sub object inside the array/object rescursively. If the type a primitive element (not an array or object), keep it or ignore it based on whether it is a \\'truthy\\' value.\\n\\n# Complexity\\n- Time complexity:\\nO(n): Need to check every element and sub-element in the given object.\\n\\n- Space complexity:\\nO(n): Need to construct a new object that could be of same size as the given object.\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nlet getCompact = (val) => {\\n    if (Array.isArray(val)) {\\n        let resultArray = [];\\n        // console.log(`Iterating thru array: ${JSON.stringify(val)}`);\\n        for (let subVal of val) {\\n            let compactSub = getCompact(subVal);\\n            if (Boolean(compactSub)) {\\n                resultArray.push(compactSub);\\n            }\\n        }\\n        return resultArray;\\n    }\\n\\n    if (typeof val === \\'object\\' && val !== null) {\\n        let resultObject = {};\\n        // console.log(`Iterating thru object: ${JSON.stringify(val)}`);\\n        for (let [key, subVal] of Object.entries(val)) {\\n            // console.log(`Checking key ${key}: ${JSON.stringify(subVal)}`);\\n            let compactSub = getCompact(subVal);\\n            if (Boolean(compactSub)) {\\n                resultObject[key] = compactSub;\\n            }\\n        }\\n        return resultObject;\\n    }\\n\\n    if (Boolean(val) === true) return val;\\n    return undefined;\\n}\\n\\nvar compactObject = function(obj) {\\n    // console.log(Object.entries(obj));\\n    return getCompact(obj);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nlet getCompact = (val) => {\\n    if (Array.isArray(val)) {\\n        let resultArray = [];\\n        // console.log(`Iterating thru array: ${JSON.stringify(val)}`);\\n        for (let subVal of val) {\\n            let compactSub = getCompact(subVal);\\n            if (Boolean(compactSub)) {\\n                resultArray.push(compactSub);\\n            }\\n        }\\n        return resultArray;\\n    }\\n\\n    if (typeof val === \\'object\\' && val !== null) {\\n        let resultObject = {};\\n        // console.log(`Iterating thru object: ${JSON.stringify(val)}`);\\n        for (let [key, subVal] of Object.entries(val)) {\\n            // console.log(`Checking key ${key}: ${JSON.stringify(subVal)}`);\\n            let compactSub = getCompact(subVal);\\n            if (Boolean(compactSub)) {\\n                resultObject[key] = compactSub;\\n            }\\n        }\\n        return resultObject;\\n    }\\n\\n    if (Boolean(val) === true) return val;\\n    return undefined;\\n}\\n\\nvar compactObject = function(obj) {\\n    // console.log(Object.entries(obj));\\n    return getCompact(obj);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566156,
                "title": "simple-check",
                "content": "Simple check.\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\nif (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  if (typeof obj !== \\'object\\' || obj === null) {\\n    return obj;\\n  }\\n\\n  const compactedObj = {};\\n  for (const key in obj) {\\n    const value = compactObject(obj[key]);\\n    if (Boolean(value)) {\\n      compactedObj[key] = value;\\n    }\\n  }\\n  return compactedObj;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\nif (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  if (typeof obj !== \\'object\\' || obj === null) {\\n    return obj;\\n  }\\n\\n  const compactedObj = {};\\n  for (const key in obj) {\\n    const value = compactObject(obj[key]);\\n    if (Boolean(value)) {\\n      compactedObj[key] = value;\\n    }\\n  }\\n  return compactedObj;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3579479,
                "title": "ts-dfs-like-traversal-90ms-53-5mb",
                "content": "Another one we can conveniently solve just by traversing our objects as we would traverse any other tree structure: with a BFS or, as I prefer since it tends to be more efficient, with a DFS.\\n\\nWe will split our logic by type so that our result value `Obj` can also be a boolean and act depending on the type of `obj`:\\n* if `obj` is not an object of if it is `null`, we will just `return` it;\\n* it is an array, we will `return` what we get if we `reduce` it with an accumulator `acc` initially set to be an empty array, going through all its properties as `iter` and:\\n    * `return` `acc` if `iter` is falsey;\\n    * `.push` into `acc` the result of calling `compactObject` on `iter`;\\n    * `return` `acc`;\\n* if it is any other kind of object, we will proceed in a fashion similar to the previous looping through the `[key, val]` pairs in `Object.entries(obj)` and:\\n* if `val` is truthy, we will add to `acc` a new property `key` and `compactObject(val)` as its value;\\n* `return` `acc`.\\n\\nCheck [json deep equal](https://leetcode.com/problems/check-if-object-instance-of-class/https://leetcode.com/problems/json-deep-equal/) ([cracked here](https://leetcode.com/problems/json-deep-equal/solutions/3530101/c-diffing-algo-with-dfs-traversal-68ms-50-5mb/)) if you want to practice more of this kind of problems.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```ts\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    // obj is not an object or is null\\n    if (typeof obj !== \\'object\\' || obj === null) return obj;\\n    // obj is an array\\n    if (Array.isArray(obj)) return obj.reduce((acc, iter) => {\\n        if (!iter) return acc;\\n        acc.push(compactObject(iter));\\n        return acc;\\n    }, []);\\n    // obj is an ordinary object\\n    return Object.entries(obj).reduce((acc, [key, val]) => {\\n        if (val) acc[key] = compactObject(val);\\n        return acc;\\n    }, {});\\n};\\n```\\n\\nMore functional programming way of doing the same, creating a new `acc` at each step:\\n\\n```ts\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    // obj is not an object or is null\\n    if (typeof obj !== \\'object\\' || obj === null) return obj;\\n    // obj is an array\\n    if (Array.isArray(obj)) return obj.reduce((acc, iter) => {\\n        if (!iter) return acc;\\n        acc = [... acc, compactObject(iter)];\\n        return acc;\\n    }, []);\\n    // obj is an ordinary object\\n    return Object.entries(obj).reduce((acc, [key, val]) => {\\n        if (val) acc = {...acc, [key]: compactObject(val)};\\n        return acc;\\n    }, {});\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Depth-First Search"
                ],
                "code": "```ts\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    // obj is not an object or is null\\n    if (typeof obj !== \\'object\\' || obj === null) return obj;\\n    // obj is an array\\n    if (Array.isArray(obj)) return obj.reduce((acc, iter) => {\\n        if (!iter) return acc;\\n        acc.push(compactObject(iter));\\n        return acc;\\n    }, []);\\n    // obj is an ordinary object\\n    return Object.entries(obj).reduce((acc, [key, val]) => {\\n        if (val) acc[key] = compactObject(val);\\n        return acc;\\n    }, {});\\n};\\n```\n```ts\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    // obj is not an object or is null\\n    if (typeof obj !== \\'object\\' || obj === null) return obj;\\n    // obj is an array\\n    if (Array.isArray(obj)) return obj.reduce((acc, iter) => {\\n        if (!iter) return acc;\\n        acc = [... acc, compactObject(iter)];\\n        return acc;\\n    }, []);\\n    // obj is an ordinary object\\n    return Object.entries(obj).reduce((acc, [key, val]) => {\\n        if (val) acc = {...acc, [key]: compactObject(val)};\\n        return acc;\\n    }, {});\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085078,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    if (obj === null) return null;\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n    if (typeof obj !== \"object\") \\n    return obj;\\n    const compacted = {};\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n        if (Boolean(value)) compacted[key] = value;\\n    }\\n    return compacted;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    if (obj === null) return null;\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n    if (typeof obj !== \"object\") \\n    return obj;\\n    const compacted = {};\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n        if (Boolean(value)) compacted[key] = value;\\n    }\\n    return compacted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079891,
                "title": "recursion-approach",
                "content": "# Code\\n```\\nvar compactObject = function (obj) {\\n  if (typeof obj !== \"object\") {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  for (const key in obj) {\\n    if (!obj[key]) {\\n      delete obj[key];\\n      continue;\\n    }\\n\\n    obj[key] = compactObject(obj[key]);\\n  }\\n\\n  return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar compactObject = function (obj) {\\n  if (typeof obj !== \"object\") {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  for (const key in obj) {\\n    if (!obj[key]) {\\n      delete obj[key];\\n      continue;\\n    }\\n\\n    obj[key] = compactObject(obj[key]);\\n  }\\n\\n  return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068437,
                "title": "d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n if (obj === null) return null;\\n if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n if (typeof obj !== \"object\") return obj;\\n \\n const compacted = {};\\n for (const key in obj) {\\n let value = compactObject(obj[key]);\\n if (Boolean(value)) compacted[key] = value;\\n }\\n\\n return compacted;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n if (obj === null) return null;\\n if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n if (typeof obj !== \"object\") return obj;\\n \\n const compacted = {};\\n for (const key in obj) {\\n let value = compactObject(obj[key]);\\n if (Boolean(value)) compacted[key] = value;\\n }\\n\\n return compacted;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058309,
                "title": "an-easy-and-readable-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar compactObject = function (obj) {\\n \\n\\n   \\n   if(Array.isArray(obj))\\n    obj = obj.reduce((acc,e)=>{\\n      if(typeof(e) == \"object\" && e != null)\\n       e =  compactObject(e)\\n      //  console.log(e, acc)\\n       if(Boolean(e)){\\n         acc.push(e)\\n        //  console.log(acc)\\n       } \\n     return acc\\n    },[])\\n    // console.log(obj)\\n\\n    if(typeof(obj) == \"object\" && !Array.isArray(obj)){\\n       for(let i in obj ){\\n        if(typeof(obj[i]) == \"object\" && obj[i] != null){\\n          obj[i] = compactObject(obj[i])\\n        }\\n\\n        \\n\\n        // console.log(obj[i])\\n        \\n        !Boolean(obj[i]) && delete obj[i]\\n      }\\n    }\\n\\n   return obj\\n   \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar compactObject = function (obj) {\\n \\n\\n   \\n   if(Array.isArray(obj))\\n    obj = obj.reduce((acc,e)=>{\\n      if(typeof(e) == \"object\" && e != null)\\n       e =  compactObject(e)\\n      //  console.log(e, acc)\\n       if(Boolean(e)){\\n         acc.push(e)\\n        //  console.log(acc)\\n       } \\n     return acc\\n    },[])\\n    // console.log(obj)\\n\\n    if(typeof(obj) == \"object\" && !Array.isArray(obj)){\\n       for(let i in obj ){\\n        if(typeof(obj[i]) == \"object\" && obj[i] != null){\\n          obj[i] = compactObject(obj[i])\\n        }\\n\\n        \\n\\n        // console.log(obj[i])\\n        \\n        !Boolean(obj[i]) && delete obj[i]\\n      }\\n    }\\n\\n   return obj\\n   \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057752,
                "title": "use-of-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n\\n    let res = Array.isArray(obj)? [] : {}\\n    function compact(obj, result)\\n    { \\n        Object.keys(obj).map(key =>{\\n            if(obj[key])\\n            {\\n                if (obj[key] instanceof Object) {\\n                    const inter = compact(obj[key], Array.isArray(obj[key])? [] : {})\\n                    Array.isArray(obj) ? result.push(inter) : (result[key] = inter)\\n                    return \\n                }\\n                Array.isArray(obj) ? result.push(obj[key]) : (result[key] = obj[key])\\n                return\\n                \\n            }\\n        } )\\n        return result\\n    }\\n    obj = compact(obj, res)\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n\\n    let res = Array.isArray(obj)? [] : {}\\n    function compact(obj, result)\\n    { \\n        Object.keys(obj).map(key =>{\\n            if(obj[key])\\n            {\\n                if (obj[key] instanceof Object) {\\n                    const inter = compact(obj[key], Array.isArray(obj[key])? [] : {})\\n                    Array.isArray(obj) ? result.push(inter) : (result[key] = inter)\\n                    return \\n                }\\n                Array.isArray(obj) ? result.push(obj[key]) : (result[key] = obj[key])\\n                return\\n                \\n            }\\n        } )\\n        return result\\n    }\\n    obj = compact(obj, res)\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050659,
                "title": "beats-96-34-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nfunction compactObject(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.reduce((acc, val) => {\\n      if (val) {\\n        if (Array.isArray(val)) {\\n          acc.push(compactObject(val));\\n        } else if (typeof val === \\'object\\') {\\n          acc.push(compactObject(val));\\n        } else {\\n          acc.push(val);\\n        }\\n      }\\n      return acc;\\n    }, []);\\n  }\\n\\n  if (typeof obj === \\'object\\') {\\n    const result = {};\\n    Object.entries(obj).forEach(([key, value]) => {\\n      if (value) {\\n        if (Array.isArray(value) || typeof value === \\'object\\') {\\n          result[key] = compactObject(value);\\n        } else {\\n          result[key] = value;\\n        }\\n      }\\n    });\\n\\n    return result\\n\\n    \\n  }\\n\\n  return obj;\\n}\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nfunction compactObject(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.reduce((acc, val) => {\\n      if (val) {\\n        if (Array.isArray(val)) {\\n          acc.push(compactObject(val));\\n        } else if (typeof val === \\'object\\') {\\n          acc.push(compactObject(val));\\n        } else {\\n          acc.push(val);\\n        }\\n      }\\n      return acc;\\n    }, []);\\n  }\\n\\n  if (typeof obj === \\'object\\') {\\n    const result = {};\\n    Object.entries(obj).forEach(([key, value]) => {\\n      if (value) {\\n        if (Array.isArray(value) || typeof value === \\'object\\') {\\n          result[key] = compactObject(value);\\n        } else {\\n          result[key] = value;\\n        }\\n      }\\n    });\\n\\n    return result\\n\\n    \\n  }\\n\\n  return obj;\\n}\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024545,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    function dfs(obj){\\n        if(!obj) return false;\\n        if(typeof obj !== \\'object\\') return obj\\n\\n        if(Array.isArray(obj)){\\n            const newArr = []\\n            for(let i=0; i<obj.length; i++){\\n                const curr = obj[i]\\n                const subRes = dfs(curr)\\n                if(subRes){\\n                    newArr.push(subRes)\\n                }\\n            }\\n            return newArr\\n        }\\n        const newObj = {}\\n\\n        for(const key in obj){\\n            const subRes = dfs(obj[key])\\n            if(subRes){\\n                newObj[key] = subRes\\n            }\\n        }\\n        return newObj\\n    }\\n    return dfs(obj)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    function dfs(obj){\\n        if(!obj) return false;\\n        if(typeof obj !== \\'object\\') return obj\\n\\n        if(Array.isArray(obj)){\\n            const newArr = []\\n            for(let i=0; i<obj.length; i++){\\n                const curr = obj[i]\\n                const subRes = dfs(curr)\\n                if(subRes){\\n                    newArr.push(subRes)\\n                }\\n            }\\n            return newArr\\n        }\\n        const newObj = {}\\n\\n        for(const key in obj){\\n            const subRes = dfs(obj[key])\\n            if(subRes){\\n                newObj[key] = subRes\\n            }\\n        }\\n        return newObj\\n    }\\n    return dfs(obj)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4017369,
                "title": "recursive-inner-function-beat-2",
                "content": "# Intuition\\nThis can be solved using a recursive function\\n# Approach\\nCreate an inner function that identifies the argument as array or object and filter acordingly, the value of each element is processed by the recursive function before being added, if it is neither an array or object then return the value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    function deFalsy(a){\\n        if (Array.isArray(a))\\n        {\\n            let r = [];\\n            a.forEach((e) => \\n            {\\n                if (e)\\n                {  \\n                    r.push(deFalsy(e))\\n                }    \\n            });\\n            return r;\\n        }\\n        else if(typeof a === \"object\" && a !== null)\\n        {\\n            let r = {};\\n            for(let key of Object.keys(a))\\n            {\\n                if (a[key])\\n                { \\n                    r[key] = deFalsy(a[key]);;\\n                }\\n            }\\n            return r;\\n        }\\n        return a;\\n    }\\n    return deFalsy(obj);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    function deFalsy(a){\\n        if (Array.isArray(a))\\n        {\\n            let r = [];\\n            a.forEach((e) => \\n            {\\n                if (e)\\n                {  \\n                    r.push(deFalsy(e))\\n                }    \\n            });\\n            return r;\\n        }\\n        else if(typeof a === \"object\" && a !== null)\\n        {\\n            let r = {};\\n            for(let key of Object.keys(a))\\n            {\\n                if (a[key])\\n                { \\n                    r[key] = deFalsy(a[key]);;\\n                }\\n            }\\n            return r;\\n        }\\n        return a;\\n    }\\n    return deFalsy(obj);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016068,
                "title": "typescript-recursive",
                "content": "# Intuition\\nyou can use *undefined* or *null* to check the return value \\n \\n\\n# Code\\n```\\ntype Obj = Record<string, any> | Array<any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (!Boolean(obj)) return undefined;\\n    if (typeof obj !== \\'object\\' ) return obj;\\n    \\n    if (Array.isArray(obj)) {\\n        let result = obj.map(item => compactObject(item));\\n        return result.filter(item =>  item!==undefined) ;\\n    }\\n    let resultObj = {};\\n    for (let key in obj) {\\n        let result = compactObject(obj[key]);\\n        if (result!=undefined) {\\n            resultObj[key] = result;\\n        }\\n    }\\n    return resultObj;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<string, any> | Array<any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (!Boolean(obj)) return undefined;\\n    if (typeof obj !== \\'object\\' ) return obj;\\n    \\n    if (Array.isArray(obj)) {\\n        let result = obj.map(item => compactObject(item));\\n        return result.filter(item =>  item!==undefined) ;\\n    }\\n    let resultObj = {};\\n    for (let key in obj) {\\n        let result = compactObject(obj[key]);\\n        if (result!=undefined) {\\n            resultObj[key] = result;\\n        }\\n    }\\n    return resultObj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013769,
                "title": "recursion-easy-to-understand",
                "content": "\\n```\\nfunction solve(obj){\\n    if(!obj)\\n        return false;\\n    \\n    let ans;\\n    if(Array.isArray(obj)){\\n        ans = [];\\n        for(let i=0;i<obj.length;i++){\\n            let b = solve(obj[i]);\\n            if(b)\\n                ans.push(b);\\n        }\\n    }else{\\n        if(typeof(obj)!=\"object\")\\n            return obj;\\n        ans = {};\\n        for(const ky in obj){\\n            let b = solve(obj[ky]);\\n            if(b)\\n                ans[ky] = b;\\n        }\\n    }\\n    return ans;\\n    \\n}\\n\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    return solve(obj);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction solve(obj){\\n    if(!obj)\\n        return false;\\n    \\n    let ans;\\n    if(Array.isArray(obj)){\\n        ans = [];\\n        for(let i=0;i<obj.length;i++){\\n            let b = solve(obj[i]);\\n            if(b)\\n                ans.push(b);\\n        }\\n    }else{\\n        if(typeof(obj)!=\"object\")\\n            return obj;\\n        ans = {};\\n        for(const ky in obj){\\n            let b = solve(obj[ky]);\\n            if(b)\\n                ans[ky] = b;\\n        }\\n    }\\n    return ans;\\n    \\n}\\n\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    return solve(obj);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985930,
                "title": "short-json-replacer-solution",
                "content": "\\n```\\n\\nconst compactObject = obj =>\\n  JSON.parse(\\n    JSON.stringify(obj, (_, val) => {\\n      if (Array.isArray(val)) return val.filter(Boolean);\\n      if (val) return val;\\n    }),\\n  );\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst compactObject = obj =>\\n  JSON.parse(\\n    JSON.stringify(obj, (_, val) => {\\n      if (Array.isArray(val)) return val.filter(Boolean);\\n      if (val) return val;\\n    }),\\n  );\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983672,
                "title": "compact-object-using-recursion",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nlet compactObject = function(obj) {\\n    const compactedData = {};\\n\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n\\n    if (typeof obj !== \"object\") return obj;\\n\\n    if (obj === null) return null;\\n\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n\\n        if (Boolean(value)) compactedData[key] = value;\\n    }\\n\\n    return compactedData;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nlet compactObject = function(obj) {\\n    const compactedData = {};\\n\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n\\n    if (typeof obj !== \"object\") return obj;\\n\\n    if (obj === null) return null;\\n\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n\\n        if (Boolean(value)) compactedData[key] = value;\\n    }\\n\\n    return compactedData;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982167,
                "title": "my-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n\\tconst result = Array.isArray(obj) ? [] : {}\\n\\tconst addToResult = (i, obj) => {\\n\\t\\tif(Array.isArray(result)) {\\n\\t\\t\\tresult.push(obj)\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = obj\\n\\t\\t}\\n\\t}\\n\\tfor (const i in obj) {\\n\\t\\t\\tif (i === null || !Boolean(obj[i])) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else if (typeof obj[i] === \\'object\\') {\\n\\t\\t\\t\\taddToResult(i, compactObject(obj[i]))\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taddToResult(i, obj[i])\\n\\t\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n\\tconst result = Array.isArray(obj) ? [] : {}\\n\\tconst addToResult = (i, obj) => {\\n\\t\\tif(Array.isArray(result)) {\\n\\t\\t\\tresult.push(obj)\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = obj\\n\\t\\t}\\n\\t}\\n\\tfor (const i in obj) {\\n\\t\\t\\tif (i === null || !Boolean(obj[i])) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else if (typeof obj[i] === \\'object\\') {\\n\\t\\t\\t\\taddToResult(i, compactObject(obj[i]))\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taddToResult(i, obj[i])\\n\\t\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957333,
                "title": "elegant-simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (typeof obj !== \\'object\\') return obj\\n\\n    if (Array.isArray(obj)) {\\n        return obj\\n                .reduce((acc, el) => {\\n                    if (el) acc.push(compactObject(el))\\n                    return acc\\n                }, [])\\n    } else if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj)\\n            .reduce((acc,key) => {\\n                if (obj[key]) acc[key] = compactObject(obj[key])\\n                return acc\\n            }, {})\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (typeof obj !== \\'object\\') return obj\\n\\n    if (Array.isArray(obj)) {\\n        return obj\\n                .reduce((acc, el) => {\\n                    if (el) acc.push(compactObject(el))\\n                    return acc\\n                }, [])\\n    } else if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj)\\n            .reduce((acc,key) => {\\n                if (obj[key]) acc[key] = compactObject(obj[key])\\n                return acc\\n            }, {})\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938286,
                "title": "typescript-1-line-solution-84ms",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    return Array.isArray( obj ) \\n        ? obj.filter( Boolean ).map( compactObject )\\n        : ( obj && typeof obj === \\'object\\' )\\n        ? Object.assign( {}, ...Object.keys( obj ).map( key => obj[ key ] ? { [key]: compactObject( obj[ key ] ) } : {} ) )\\n        : obj;\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    return Array.isArray( obj ) \\n        ? obj.filter( Boolean ).map( compactObject )\\n        : ( obj && typeof obj === \\'object\\' )\\n        ? Object.assign( {}, ...Object.keys( obj ).map( key => obj[ key ] ? { [key]: compactObject( obj[ key ] ) } : {} ) )\\n        : obj;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930265,
                "title": "simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        return obj.map(compactObject).filter(Boolean);\\n    }else if(obj && typeof obj == \"object\"){\\n        let result = {};\\n        for(const k in obj){\\n            const compactValue = compactObject(obj[k]);\\n            if(Boolean(compactValue)) result[k] = compactValue;\\n        }\\n        return result;\\n    }else{\\n        return obj;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        return obj.map(compactObject).filter(Boolean);\\n    }else if(obj && typeof obj == \"object\"){\\n        let result = {};\\n        for(const k in obj){\\n            const compactValue = compactObject(obj[k]);\\n            if(Boolean(compactValue)) result[k] = compactValue;\\n        }\\n        return result;\\n    }else{\\n        return obj;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927268,
                "title": "2705-compact-object",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\' || obj === null){\\n        return obj\\n    }\\n\\n    if(Array.isArray(obj)){\\n        const compactArr = []\\n        for(let i = 0; i < obj.length; i++){\\n            let val = compactObject(obj[i]);\\n            if(val)\\n                compactArr.push(val)\\n        }\\n\\n        return compactArr\\n    } \\n\\n    const compactObj = {};\\n    for(let key in obj){\\n        const val = compactObject(obj[key]);\\n        if(val)\\n            compactObj[key] = val\\n    }\\n\\n    return compactObj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\' || obj === null){\\n        return obj\\n    }\\n\\n    if(Array.isArray(obj)){\\n        const compactArr = []\\n        for(let i = 0; i < obj.length; i++){\\n            let val = compactObject(obj[i]);\\n            if(val)\\n                compactArr.push(val)\\n        }\\n\\n        return compactArr\\n    } \\n\\n    const compactObj = {};\\n    for(let key in obj){\\n        const val = compactObject(obj[key]);\\n        if(val)\\n            compactObj[key] = val\\n    }\\n\\n    return compactObj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911310,
                "title": "simple-solution-beats-98-2-step-by-step-explanation",
                "content": "# Intuition/Thought Process\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thoughts on how to solve this problem involved creating an initial if else block to handle whether the JSON Object was an array of an Object with key-value pairs, and then to iterate through the values of the object, filtering out anything that is `falsy`.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy final solution is a recursive solution operating in two similar ways depending on whether `obj` is an array or an object. We can check that with this if else:\\n```javascript\\nif (Array.isArray(obj)) {\\n    // handle array\\n} else {\\n    // handle object\\n}\\n```\\n\\nIf it is an array we first filter out any element that evaluates as `falsy` with this:\\n```javascript\\n.filter(el => Boolean(el))\\n```\\nThis iterates through every element of `obj`, referring to the current element as `el`, and checks if `Boolean(el)` evalues to a true value. If it does, it is included in the resulting array. \\nAfter this, we map through all the remaining values and check if they are an object, indicating that there is nesting going on in `obj` and we need to recursively call `compactObject()` to deal with it. We do this like this:\\n```javascript\\n.map(el => typeof el === \\'object\\' ? compactObject(el) : el)\\n```\\nThis now iterates through every `el` in the resulting array from out `.filter()` call just a line earlier. It checks that the `typeof el === \\'object\\'` which means that `el` does not just contain a value, but is a nested object within `obj`. If it is, we implicitly return `compactObject(el)`, and if not we simply return `el`. This line could be rewritten without the implicit return like this, for more clarity:\\n```javascript\\n.map(el => {\\n    return typeof el === \\'object\\' ? compactObject(el) : el\\n}\\n```\\n\\nWe can take a very similar approach to filtering out `falsy` values from the object now.\\nFirst, we\\'ll define a resulting object to return:\\n```javascript\\nlet res = {}\\n```\\nNow, we can iterate through the keys of the object and check if the value associated with the key is `truthy` or `falsy`:\\n```javascript\\nfor (const key of Object.keys(obj)) {\\n    if (Boolean(obj[key])) {\\n        // ...\\n    }\\n}\\n```\\nThen, inside the if statement, we do something similar to earlier to check if we can to recursively handle any nested objects:\\n```javascript\\nres[key] = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key]\\n```\\nNow, we just return res! :)\\n```javascript\\nreturn res\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n+d)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere `n` is the total number of elements/properties across all objects/arrays in the structure, and `d` is the maximum depth of nested structures.\\n\\n- Space complexity: $$O(n+d)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj\\n            .filter(el => Boolean(el))\\n            .map(el => typeof el === \\'object\\' ? compactObject(el) : el)\\n    } else {\\n        let res = {}\\n        for (const key of Object.keys(obj)) {\\n            if (Boolean(obj[key])) {\\n                res[key] = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key]\\n            }\\n        }\\n        return res\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/5838a724-e2c3-4736-a11c-bc0a2c51d41f_1692073895.2148383.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nif (Array.isArray(obj)) {\\n    // handle array\\n} else {\\n    // handle object\\n}\\n```\n```javascript\\n.filter(el => Boolean(el))\\n```\n```javascript\\n.map(el => typeof el === \\'object\\' ? compactObject(el) : el)\\n```\n```javascript\\n.map(el => {\\n    return typeof el === \\'object\\' ? compactObject(el) : el\\n}\\n```\n```javascript\\nlet res = {}\\n```\n```javascript\\nfor (const key of Object.keys(obj)) {\\n    if (Boolean(obj[key])) {\\n        // ...\\n    }\\n}\\n```\n```javascript\\nres[key] = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key]\\n```\n```javascript\\nreturn res\\n```\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj\\n            .filter(el => Boolean(el))\\n            .map(el => typeof el === \\'object\\' ? compactObject(el) : el)\\n    } else {\\n        let res = {}\\n        for (const key of Object.keys(obj)) {\\n            if (Boolean(obj[key])) {\\n                res[key] = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key]\\n            }\\n        }\\n        return res\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909368,
                "title": "javascript-solution-recursive-approach-beats-90-79",
                "content": "```javascript\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        const result = [];\\n        for (const elem of obj) {\\n            if (!elem) continue;\\n            result.push(typeof(elem) === \\'object\\' ? compactObject(elem) : elem);\\n        }\\n        return result;\\n    }\\n    \\n    const result = {};\\n    for (const key in obj) {\\n        const value = obj[key];\\n        if (!value) continue;\\n        result[key] = typeof(value) === \\'object\\' ? compactObject(value) : value;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        const result = [];\\n        for (const elem of obj) {\\n            if (!elem) continue;\\n            result.push(typeof(elem) === \\'object\\' ? compactObject(elem) : elem);\\n        }\\n        return result;\\n    }\\n    \\n    const result = {};\\n    for (const key in obj) {\\n        const value = obj[key];\\n        if (!value) continue;\\n        result[key] = typeof(value) === \\'object\\' ? compactObject(value) : value;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906524,
                "title": "clear-solution-using-recursive",
                "content": "# Intuition\\nrecursive iteration to handle array items or object keys.\\n\\n# Approach\\nLoop over each item in array or key-value in object, if `Boolean(entry)` is false, then drop it; otherwise check its type via `typeof`: if `object` which means array or object, then recursively call the function to handle it, else for other primitives type, just push/add to result array or restult object.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where N is the total number of the entries including all elements and sub-elements inside.\\n\\n- Space complexity: $$O(n)$$, same as the above\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n    const res: any[] = [];\\n    obj.forEach((e) => {\\n      if (e) {\\n        res.push(typeof e === \\'object\\' ? compactObject(e) : e);\\n      }\\n    });\\n    return res;\\n  }\\n\\n  const res: Obj = {};\\n  for (const key in obj) {\\n    if (obj[key]) {\\n      res[key] =\\n        typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key];\\n    }\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n    const res: any[] = [];\\n    obj.forEach((e) => {\\n      if (e) {\\n        res.push(typeof e === \\'object\\' ? compactObject(e) : e);\\n      }\\n    });\\n    return res;\\n  }\\n\\n  const res: Obj = {};\\n  for (const key in obj) {\\n    if (obj[key]) {\\n      res[key] =\\n        typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key];\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3901513,
                "title": "intuitive-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar compactObject = function(obj) {\\n  if (typeof obj !== \\'object\\') {\\n    return obj;\\n  }\\n  if (Array.isArray(obj)) {\\n    let result = [];\\n    for (let n of obj) {\\n      if (Boolean(n)) {\\n        result.push(compactObject(n));\\n      }\\n    }    \\n    return result;\\n  } else {\\n    let result = {};\\n    for (let [k, v] of Object.entries(obj)) {\\n      if (Boolean(v)) {\\n        result[k] = compactObject(v);\\n      }\\n    }    \\n    return result;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar compactObject = function(obj) {\\n  if (typeof obj !== \\'object\\') {\\n    return obj;\\n  }\\n  if (Array.isArray(obj)) {\\n    let result = [];\\n    for (let n of obj) {\\n      if (Boolean(n)) {\\n        result.push(compactObject(n));\\n      }\\n    }    \\n    return result;\\n  } else {\\n    let result = {};\\n    for (let [k, v] of Object.entries(obj)) {\\n      if (Boolean(v)) {\\n        result[k] = compactObject(v);\\n      }\\n    }    \\n    return result;\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896356,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nfunction modifyArray(arr) {\\n  const result = [];\\n\\n  arr.forEach((value) => {\\n    if(Array.isArray(value)) {\\n      const res = modifyArray(value);\\n      result.push(res);\\n      return;\\n    }\\n\\n    const res = modifyObject(value);\\n    if(res)\\n      result.push(res);\\n  })\\n\\n  return result;\\n}\\n\\nfunction modifyObject(obj) {\\n  if(!obj) return null;\\n\\n  const result = {};\\n\\n  if(typeof obj === \\'object\\') {\\n    for(let key in obj) {\\n      const value = obj[key]\\n      if(Array.isArray(value)) {\\n        result[key] = modifyArray(value);\\n        continue;\\n      }\\n\\n      const res = modifyObject(value);\\n\\n      if(res) {\\n        result[key] = res;\\n      }\\n    }\\n\\n    return result;\\n  }  \\n\\n  return obj;\\n}\\n\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n      return modifyArray(obj);\\n    }\\n\\n    return modifyObject(obj)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nfunction modifyArray(arr) {\\n  const result = [];\\n\\n  arr.forEach((value) => {\\n    if(Array.isArray(value)) {\\n      const res = modifyArray(value);\\n      result.push(res);\\n      return;\\n    }\\n\\n    const res = modifyObject(value);\\n    if(res)\\n      result.push(res);\\n  })\\n\\n  return result;\\n}\\n\\nfunction modifyObject(obj) {\\n  if(!obj) return null;\\n\\n  const result = {};\\n\\n  if(typeof obj === \\'object\\') {\\n    for(let key in obj) {\\n      const value = obj[key]\\n      if(Array.isArray(value)) {\\n        result[key] = modifyArray(value);\\n        continue;\\n      }\\n\\n      const res = modifyObject(value);\\n\\n      if(res) {\\n        result[key] = res;\\n      }\\n    }\\n\\n    return result;\\n  }  \\n\\n  return obj;\\n}\\n\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n      return modifyArray(obj);\\n    }\\n\\n    return modifyObject(obj)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888842,
                "title": "recursive-falsy-key-removal-for-compact-objects",
                "content": "# Intuition\\nThe compactObject function aims to remove keys containing falsy values from an input object or array, while also recursively applying the same process to nested objects and arrays. The intuition behind the approach is to traverse the input structure, filtering out any keys with falsy values, and transforming the structure into a more compact form.\\n\\nThe function uses a combination of conditional statements, filtering, mapping, and recursion to achieve this compacting behavior.\\n\\n# Approach\\nThe compactObject function recursively processes an object or array and removes keys containing falsy values. Here\\'s how it works:\\n\\nThe function first checks if the input obj is not an object (including null) or if it\\'s an array. If so, it directly returns the object (or array) since no further processing is needed.\\n\\nIf the input obj is an array, it uses the filter method to remove falsy values from the array and then applies the compactObject function to each remaining item using the map method.\\n\\nIf the input obj is an object, it uses Object.entries to get an array of [key, value] pairs, filters out pairs where the value is falsy, and then uses reduce to build the compacted object. During the reduction, it recursively applies the compactObject function to each value.\\n\\n# Complexity\\n- Time complexity:\\na time complexity of O(n), where n is the length of the array.\\n\\n- Space complexity:\\nThe space complexity is determined by the memory usage of the recursive call stack and the auxiliary space used during object transformation.\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n     if (typeof obj !== \\'object\\' || obj === null) {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.filter(item => Boolean(item)).map(compactObject);\\n  }\\n\\n  return Object.entries(obj)\\n    .filter(([key, value]) => Boolean(value))\\n    .reduce((result, [key, value]) => {\\n      result[key] = compactObject(value);\\n      return result;\\n    }, {});\\n};\\n```\\nThe compactObject function applies a recursive approach to traverse and compact an input object or array by removing keys with falsy values. The time complexity is influenced by the number of keys and the maximum number of elements within arrays, while the space complexity is determined by the recursive call stack depth and auxiliary space required for intermediate data structures.\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n     if (typeof obj !== \\'object\\' || obj === null) {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.filter(item => Boolean(item)).map(compactObject);\\n  }\\n\\n  return Object.entries(obj)\\n    .filter(([key, value]) => Boolean(value))\\n    .reduce((result, [key, value]) => {\\n      result[key] = compactObject(value);\\n      return result;\\n    }, {});\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880795,
                "title": "accepted-javascript",
                "content": "```\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj\\n            .map(i => compactObject(i))\\n            .filter(i => Boolean(i));\\n    }\\n    else if (obj != null && typeof(obj) == \"object\") {\\n        var entries = Object\\n            .entries(obj)\\n            .map(v => compactObject(v))\\n            .filter(([_, v]) => v != null)\\n        return Object.fromEntries(entries);\\n    }\\n    else {\\n        return obj;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj\\n            .map(i => compactObject(i))\\n            .filter(i => Boolean(i));\\n    }\\n    else if (obj != null && typeof(obj) == \"object\") {\\n        var entries = Object\\n            .entries(obj)\\n            .map(v => compactObject(v))\\n            .filter(([_, v]) => v != null)\\n        return Object.fromEntries(entries);\\n    }\\n    else {\\n        return obj;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867660,
                "title": "easy-peasy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    \\n    const isArray = Array.isArray(obj);\\n    const r =  isArray ? [] : {};\\n    \\n    for (let key in obj) {\\n        var el = obj[key];\\n        \\n        if(typeof el === \"object\" && el !== null){\\n            isArray ? r.push(compactObject(el)) : r[key] = compactObject(el)\\n        }\\n        else if(Boolean(el)){\\n            isArray ? r.push(el) : r[key] = el \\n        }\\n    }\\n    return r\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    \\n    const isArray = Array.isArray(obj);\\n    const r =  isArray ? [] : {};\\n    \\n    for (let key in obj) {\\n        var el = obj[key];\\n        \\n        if(typeof el === \"object\" && el !== null){\\n            isArray ? r.push(compactObject(el)) : r[key] = compactObject(el)\\n        }\\n        else if(Boolean(el)){\\n            isArray ? r.push(el) : r[key] = el \\n        }\\n    }\\n    return r\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847083,
                "title": "easy-solution-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Array.property.filter() and delete key object method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Filter obj\\nStep 2: Obj key loop\\n    - If obj[key] is falsy, delete this key\\n    - If type of obj[key] is object (array also has type object), callback compactObject() function with obj[key] instead of obj\\n# Complexity\\n- Time complexity: 80ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 52.54mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) obj = obj.filter(val => val);\\n    for (const key in obj) {\\n        if (!obj[key]) {\\n            delete obj[key]\\n        } else if (typeof obj[key] === \\'object\\') {\\n            obj[key] = compactObject(obj[key]);\\n        }\\n    }\\n    return obj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) obj = obj.filter(val => val);\\n    for (const key in obj) {\\n        if (!obj[key]) {\\n            delete obj[key]\\n        } else if (typeof obj[key] === \\'object\\') {\\n            obj[key] = compactObject(obj[key]);\\n        }\\n    }\\n    return obj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845167,
                "title": "compact-js",
                "content": "# Code\\n```\\nvar compactObject = function(obj) {    \\n    const isFalsy = (v) => {\\n        return !v;\\n    }\\n\\n    const getObjType = (o) => {\\n        if(o === null) return null\\n        if(o === undefined) return undefined;\\n\\n        if(typeof o === \"number\") return \"number\";\\n        if(typeof o === \"string\") return \"string\";\\n        if(typeof o === \"boolean\") return \"boolean\";\\n        \\n        if(Array.isArray(o)) return \"array\";\\n        \\n        return \"object\";\\n    }\\n\\n    const compactArray = (o) => {\\n        const res = [];\\n\\n        for(let val of o) {\\n            const type = getObjType(val);\\n            if(type === \"array\") {\\n                res.push(compactArray(val));\\n            }else if(type === \"object\") {\\n                res.push(compactObj(val));\\n            }else if(!isFalsy(val)){\\n                res.push(val);\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    const compactObj = (o) => {\\n        const res = {};\\n\\n        for(let k in o) {\\n            const type = getObjType(o[k]);\\n            if(type === \"array\") {\\n                res[k] = compactArray(o[k]);\\n            }else if(type === \"object\") {\\n                res[k] = compactObj(o[k]);\\n            }else if(!isFalsy(o[k])){\\n                res[k] = o[k];\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    let res = null;\\n    \\n    const type = getObjType(obj);\\n    if(type === \"array\") {\\n        res = compactArray(obj);\\n    }else if(type === \"object\") {\\n        res = compactObj(obj);\\n    }else if(!isFalsy(obj)){\\n        res = obj;\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar compactObject = function(obj) {    \\n    const isFalsy = (v) => {\\n        return !v;\\n    }\\n\\n    const getObjType = (o) => {\\n        if(o === null) return null\\n        if(o === undefined) return undefined;\\n\\n        if(typeof o === \"number\") return \"number\";\\n        if(typeof o === \"string\") return \"string\";\\n        if(typeof o === \"boolean\") return \"boolean\";\\n        \\n        if(Array.isArray(o)) return \"array\";\\n        \\n        return \"object\";\\n    }\\n\\n    const compactArray = (o) => {\\n        const res = [];\\n\\n        for(let val of o) {\\n            const type = getObjType(val);\\n            if(type === \"array\") {\\n                res.push(compactArray(val));\\n            }else if(type === \"object\") {\\n                res.push(compactObj(val));\\n            }else if(!isFalsy(val)){\\n                res.push(val);\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    const compactObj = (o) => {\\n        const res = {};\\n\\n        for(let k in o) {\\n            const type = getObjType(o[k]);\\n            if(type === \"array\") {\\n                res[k] = compactArray(o[k]);\\n            }else if(type === \"object\") {\\n                res[k] = compactObj(o[k]);\\n            }else if(!isFalsy(o[k])){\\n                res[k] = o[k];\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    let res = null;\\n    \\n    const type = getObjType(obj);\\n    if(type === \"array\") {\\n        res = compactArray(obj);\\n    }else if(type === \"object\") {\\n        res = compactObj(obj);\\n    }else if(!isFalsy(obj)){\\n        res = obj;\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840543,
                "title": "compact-object-beats-92-12-of-users-with-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nfunction isFalsy(value) {\\n  return !value; // Converts value to a boolean and negates it\\n}\\n\\nfunction compactObject(obj) {\\n  if (typeof obj !== \"object\" || obj === null) {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.map(compactObject).filter((value) => !isFalsy(value));\\n  }\\n\\n  return Object.entries(obj).reduce((acc, [key, value]) => {\\n    const compactValue = compactObject(value);\\n    if (!isFalsy(compactValue)) {\\n      acc[key] = compactValue;\\n    }\\n    return acc;\\n  }, {});\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nfunction isFalsy(value) {\\n  return !value; // Converts value to a boolean and negates it\\n}\\n\\nfunction compactObject(obj) {\\n  if (typeof obj !== \"object\" || obj === null) {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.map(compactObject).filter((value) => !isFalsy(value));\\n  }\\n\\n  return Object.entries(obj).reduce((acc, [key, value]) => {\\n    const compactValue = compactObject(value);\\n    if (!isFalsy(compactValue)) {\\n      acc[key] = compactValue;\\n    }\\n    return acc;\\n  }, {});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840312,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const newObj = new Object(obj);\\n    if (obj instanceof Array){\\n        for (let i = 0; i< obj.length; i++){\\n            if (obj[i] instanceof Object){\\n                const t = compactObject(obj[i]);\\n                if (t){\\n                    newObj[i] = t;\\n                } else{\\n                    obj.splice(i, 1);\\n                    i--;\\n                }\\n            } else{\\n                if (!obj[i]){\\n                    obj.splice(i, 1);\\n                    i--;\\n                }\\n            }\\n        }\\n    } else {\\n        for (let key in obj){\\n            if (obj[key] instanceof Object){\\n                const t = compactObject(obj[key]);\\n                if (t){\\n                    newObj[key] = t;\\n                } else{\\n                    delete newObj[key];\\n                }\\n            } else{\\n                if (!obj[key]){\\n                    delete newObj[key];\\n                }\\n            }\\n        }\\n        return newObj;\\n    }\\n    return obj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const newObj = new Object(obj);\\n    if (obj instanceof Array){\\n        for (let i = 0; i< obj.length; i++){\\n            if (obj[i] instanceof Object){\\n                const t = compactObject(obj[i]);\\n                if (t){\\n                    newObj[i] = t;\\n                } else{\\n                    obj.splice(i, 1);\\n                    i--;\\n                }\\n            } else{\\n                if (!obj[i]){\\n                    obj.splice(i, 1);\\n                    i--;\\n                }\\n            }\\n        }\\n    } else {\\n        for (let key in obj){\\n            if (obj[key] instanceof Object){\\n                const t = compactObject(obj[key]);\\n                if (t){\\n                    newObj[key] = t;\\n                } else{\\n                    delete newObj[key];\\n                }\\n            } else{\\n                if (!obj[key]){\\n                    delete newObj[key];\\n                }\\n            }\\n        }\\n        return newObj;\\n    }\\n    return obj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837956,
                "title": "100-run-time-enjoy-the-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const result = Array.isArray(obj);\\n\\n    if(result){\\n        let newArray = new Array();\\n        for(let item of obj){\\n            if(item && typeof item === \\'object\\'){\\n                const res = compactObject(item);\\n                if(res) newArray.push(res);\\n            }else{\\n                if(item) newArray.push(item);\\n            }\\n        }\\n        return newArray;\\n\\n    }\\n    \\n    else{\\n        let newObject = new Object();\\n        for(let item in obj){\\n            if(obj[item] &&  typeof obj[item] === \\'object\\'){\\n                const res = compactObject(obj[item]);\\n                if(res) newObject[item] = res;\\n            }\\n            else {\\n                if(obj[item]){\\n                    newObject[item] = obj[item];\\n                }\\n            }\\n        }\\n        return newObject;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const result = Array.isArray(obj);\\n\\n    if(result){\\n        let newArray = new Array();\\n        for(let item of obj){\\n            if(item && typeof item === \\'object\\'){\\n                const res = compactObject(item);\\n                if(res) newArray.push(res);\\n            }else{\\n                if(item) newArray.push(item);\\n            }\\n        }\\n        return newArray;\\n\\n    }\\n    \\n    else{\\n        let newObject = new Object();\\n        for(let item in obj){\\n            if(obj[item] &&  typeof obj[item] === \\'object\\'){\\n                const res = compactObject(obj[item]);\\n                if(res) newObject[item] = res;\\n            }\\n            else {\\n                if(obj[item]){\\n                    newObject[item] = obj[item];\\n                }\\n            }\\n        }\\n        return newObject;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836985,
                "title": "ts-solution",
                "content": "\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(!obj) return obj;\\n\\n    if(Array.isArray(obj)) {\\n        return obj.reduce((acc, curr) => {\\n            if(!curr) return acc;\\n\\n            if(typeof curr === \\'object\\') {\\n                acc.push(compactObject(curr))\\n                return acc\\n            }\\n            \\n            acc.push(curr)\\n            return acc;\\n        }, []);\\n    }\\n\\n    const output: Obj = {}\\n    Object.entries(obj).forEach(([key, value]) => {\\n        if(typeof value === \\'object\\') {\\n            const filteredValue = compactObject(value);\\n\\n            if(!!filteredValue) {\\n                output[key] = filteredValue;\\n            } \\n        } else {\\n            if(!!value) {\\n                output[key] = value;\\n            }\\n        }\\n    })\\n\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(!obj) return obj;\\n\\n    if(Array.isArray(obj)) {\\n        return obj.reduce((acc, curr) => {\\n            if(!curr) return acc;\\n\\n            if(typeof curr === \\'object\\') {\\n                acc.push(compactObject(curr))\\n                return acc\\n            }\\n            \\n            acc.push(curr)\\n            return acc;\\n        }, []);\\n    }\\n\\n    const output: Obj = {}\\n    Object.entries(obj).forEach(([key, value]) => {\\n        if(typeof value === \\'object\\') {\\n            const filteredValue = compactObject(value);\\n\\n            if(!!filteredValue) {\\n                output[key] = filteredValue;\\n            } \\n        } else {\\n            if(!!value) {\\n                output[key] = value;\\n            }\\n        }\\n    })\\n\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833881,
                "title": "javascript-reduce-to-reduce-compact-the-object-d",
                "content": "# Intuition\\nDo operations on object and use reduce for better efficiency on deeply nested objects with many falsy values ( edge over filter + map )\\n\\n# Approach\\n1. At parent level we have null checks in place and all the logic we\\'ve written only works if the object has some data in it ( be it an Array / Object, Object.keys length check works for both )\\n2. Inside our parent block, we have 2 things to check => if it is an array or an object.\\n3. If obj is an array, we use reduce function to iterate with accumulator (acc) initialized to an empty array []. We only push the items to the accumulator if those are truthy. A double !! does the trick for boolean typecasting. In addition it it, we also check that if the current item of iteration is an object or not, if yes, we send it for getting further compacted with the help of same function \\'compacObject\\' via recursion.\\n4. Assing the accumulator back to original object (obj) to update it with compacted nested data.\\n5. Now, for the else block, since we already have handled the array part in if block, we can start writing logic for if it is an Object.\\n6. For this, simply iterate over object keys via a loop of yuor choice.\\n7. During the iteration, we again have similar conditions that we handled for Array type, i.e. compacting the nested items further if it an object, using the value directly otherwise.\\n8. We can do all operations on obj itself to delete falsy keys, assign new values to keys etc.\\n9. Firstly, we assign the compacted data back to the original object which is nothing but obj.\\n10. Secondly we delete the key entirely from \\'obj\\' if in case it is falsy using \\'delete OBJECT.KEYNAME\\'\\n11. That\\'s all, now only thing left to do is return the object obj as last statement of our function. Since all operations happend in sequence directly on obj, it will have the end result by the time we reach this last line.\\n\\n# Complexity\\n- Time complexity:\\ncompactObject = O(n)\\n\\n- Space complexity:\\ncompactObject = O(1)\\nInput object = O(h) | h = number of inputs\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nconst compactObject = function(obj) {\\n    if(!!obj && typeof obj === \\'object\\' && Object.keys(obj).length){\\n        if(Array.isArray(obj)){\\n            obj = obj.reduce((acc, item)=>{\\n                const compacted = typeof item === \\'object\\' ? compactObject(item) : item;\\n                !!compacted && acc.push(compacted);\\n                return acc;\\n            },[])\\n        }\\n        else{\\n            Object.keys(obj).forEach(key=>{\\n                const compacted = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key];\\n                if(!!compacted) obj[key] = compacted;\\n                !compacted && delete(obj[key]);\\n            })\\n        }\\n    }\\n    return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nconst compactObject = function(obj) {\\n    if(!!obj && typeof obj === \\'object\\' && Object.keys(obj).length){\\n        if(Array.isArray(obj)){\\n            obj = obj.reduce((acc, item)=>{\\n                const compacted = typeof item === \\'object\\' ? compactObject(item) : item;\\n                !!compacted && acc.push(compacted);\\n                return acc;\\n            },[])\\n        }\\n        else{\\n            Object.keys(obj).forEach(key=>{\\n                const compacted = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key];\\n                if(!!compacted) obj[key] = compacted;\\n                !compacted && delete(obj[key]);\\n            })\\n        }\\n    }\\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3829136,
                "title": "easy-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n  // Scenario obj is array\\n  if (Array.isArray(obj)) {\\n    return obj\\n      .filter((val) => Boolean(val))\\n      .map((curr) => {\\n        if (typeof curr === \"object\") {\\n          return compactObject(curr);\\n        } else {\\n          return curr;\\n        }\\n      });\\n  } else {\\n    const compactObj = {} as any;\\n    for (const key in obj) {\\n      if (obj.hasOwnProperty(key) && Boolean(obj[key])) {\\n        // Only truthy keys\\nif (typeof obj[key] === \"object\")\\n          compactObj[key] = compactObject(obj[key]);\\n          else {\\n            compactObj[key] = obj[key]; \\n          }      }\\n    }\\n    return compactObj;\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n  // Scenario obj is array\\n  if (Array.isArray(obj)) {\\n    return obj\\n      .filter((val) => Boolean(val))\\n      .map((curr) => {\\n        if (typeof curr === \"object\") {\\n          return compactObject(curr);\\n        } else {\\n          return curr;\\n        }\\n      });\\n  } else {\\n    const compactObj = {} as any;\\n    for (const key in obj) {\\n      if (obj.hasOwnProperty(key) && Boolean(obj[key])) {\\n        // Only truthy keys\\nif (typeof obj[key] === \"object\")\\n          compactObj[key] = compactObject(obj[key]);\\n          else {\\n            compactObj[key] = obj[key]; \\n          }      }\\n    }\\n    return compactObj;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815558,
                "title": "javascript-solution-easy-with-recursion",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (!obj) return;\\n    if (typeof obj !== \\'object\\') return obj;\\n\\n    let output;\\n    let curr;\\n    \\n    if (Array.isArray(obj)) {\\n        output = [];\\n\\n        for (let i = 0; i < obj.length; i++) {\\n            curr = compactObject(obj[i]);\\n            if (curr) output.push(curr);\\n        }\\n\\n    } else if (typeof obj === \\'object\\') {\\n      output = {};\\n\\n      for (const key in obj) {\\n          curr = compactObject(obj[key]);\\n          if (curr) output[key] = curr;\\n      } \\n    } \\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (!obj) return;\\n    if (typeof obj !== \\'object\\') return obj;\\n\\n    let output;\\n    let curr;\\n    \\n    if (Array.isArray(obj)) {\\n        output = [];\\n\\n        for (let i = 0; i < obj.length; i++) {\\n            curr = compactObject(obj[i]);\\n            if (curr) output.push(curr);\\n        }\\n\\n    } else if (typeof obj === \\'object\\') {\\n      output = {};\\n\\n      for (const key in obj) {\\n          curr = compactObject(obj[key]);\\n          if (curr) output[key] = curr;\\n      } \\n    } \\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807198,
                "title": "typescript-straightforward-solution",
                "content": "# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)) {\\n        let retArr = []\\n        obj.forEach((e, idx) => {\\n            if(e) {\\n                retArr.push(compactObject(e))\\n            }\\n        })\\n        return retArr\\n    } else if(obj !== null && typeof obj === \\'object\\') {\\n        let retObj = {}\\n        for(const key of Object.keys(obj)) {\\n            if(obj[key]) {\\n                retObj[key] = compactObject(obj[key])\\n            }\\n        }\\n        return retObj\\n    } \\n    return obj;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)) {\\n        let retArr = []\\n        obj.forEach((e, idx) => {\\n            if(e) {\\n                retArr.push(compactObject(e))\\n            }\\n        })\\n        return retArr\\n    } else if(obj !== null && typeof obj === \\'object\\') {\\n        let retObj = {}\\n        for(const key of Object.keys(obj)) {\\n            if(obj[key]) {\\n                retObj[key] = compactObject(obj[key])\\n            }\\n        }\\n        return retObj\\n    } \\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775024,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(obj === null) return false;\\n    if(typeof obj !== \\'object\\' ) {\\n        return obj ? obj: false;\\n    }\\n\\n    if(Array.isArray(obj)) {\\n        return obj.map((val) => {\\n            if(compactObject(val)) return compactObject(val);\\n            return false\\n        }).filter(v => v !== false)\\n    }\\n    const res = {}\\n    const keys = Object.keys(obj);\\n    for(const key of keys) {\\n        if(compactObject(obj[key])) res[key] = compactObject(obj[key]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(obj === null) return false;\\n    if(typeof obj !== \\'object\\' ) {\\n        return obj ? obj: false;\\n    }\\n\\n    if(Array.isArray(obj)) {\\n        return obj.map((val) => {\\n            if(compactObject(val)) return compactObject(val);\\n            return false\\n        }).filter(v => v !== false)\\n    }\\n    const res = {}\\n    const keys = Object.keys(obj);\\n    for(const key of keys) {\\n        if(compactObject(obj[key])) res[key] = compactObject(obj[key]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770456,
                "title": "simple-recursive-approach-for-both-array-and-object",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### If the input is an Array:\\n- Create a separate function to handle all the elements in it.\\n- Traverse the elements of the array\\n- If the value is falsy, ignore it and continue to the next element\\n- If value is truthy and is not an object or array, add it to the result\\n- If the value is object, then recursively call the compactObject function\\n\\n##### Otherwise\\n- Traverse the keys of the object\\n- If the value is falsy, ignore it and continue to the next key\\n- If value is truthy and is not an object or array, add it to the result\\n- If the value is object, then recursively call the compactObject function\\n\\n# Complexity\\n- Time complexity: \\n    $$O(n)$$ - We will be checking every element and sub element\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n    $$O(n)$$ - Used to store the result\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        return compactArray(obj);\\n    } else {\\n        const result = {};\\n        for(const key in obj){\\n            const value = obj[key];\\n\\n            if(Boolean(value)){\\n                if(typeof value !== \\'object\\'){\\n                    result[key] = value;\\n                } else {\\n                    result[key] = compactObject(value);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nconst compactArray = (arr) => {\\n    const result = [];\\n\\n    for(let i = 0; i < arr.length; i++){\\n        const element = arr[i];\\n\\n        if(!Boolean(element)){\\n            continue;\\n        }\\n\\n        if(typeof element !== \\'object\\'){\\n            result.push(element);\\n        } else {\\n            result.push(compactObject(element));\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        return compactArray(obj);\\n    } else {\\n        const result = {};\\n        for(const key in obj){\\n            const value = obj[key];\\n\\n            if(Boolean(value)){\\n                if(typeof value !== \\'object\\'){\\n                    result[key] = value;\\n                } else {\\n                    result[key] = compactObject(value);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nconst compactArray = (arr) => {\\n    const result = [];\\n\\n    for(let i = 0; i < arr.length; i++){\\n        const element = arr[i];\\n\\n        if(!Boolean(element)){\\n            continue;\\n        }\\n\\n        if(typeof element !== \\'object\\'){\\n            result.push(element);\\n        } else {\\n            result.push(compactObject(element));\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753218,
                "title": "javascript-naive-solution",
                "content": "# Intuition\\nTruthy False is a term to describe whether a value should be considered as invalid to an if statement. Simply putting the value into the if statement will coerce it to be a truthy boolean.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nKnowing that when an object is passed into a `for (x in o)` means for each `key x` in `object o` we can then store the truthy true values into a new object.\\n\\nAs for the `Array.isArray` which is a builtin function (but not for leetcode) it simply checks that when the object is coerced into a string, that it is `\"[object Array]\"` which all arrays do when coerced.\\n\\n# Complexity\\n- Time complexity: $$o(n)$$ $$&$$ $$ O(n)$$ where $$n = obj$$\\n\\n- Space complexity: $$o(n)$$ $$&$$ $$O(2n)$$ where $$n = obj$$\\n\\n# Code\\n```\\n/**\\n * @brief Returns whether the object is an Array\\n * @param {Object} obj\\n * @return {Boolean}\\n */\\nArray.IsArray = (obj) => {\\n    return (Object.prototype.toString.call(obj) === \\'[object Array]\\')\\n}\\n\\n/**\\n * @brief Deep removes all values that are truthy false\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function (obj) {\\n    var nobj = {};\\n    if (Array.IsArray(obj)) {\\n        nobj = [];\\n        for (var entry in obj) {\\n            entry = obj[entry];\\n            if (!entry) continue;\\n            if (typeof entry == \"object\")\\n                entry = compactObject(entry);\\n            nobj.push(entry);\\n        }\\n    } else {\\n        for (var key in obj) {\\n            var entry = obj[key];\\n            if (!entry) continue;\\n            if (typeof entry == \"object\")\\n                entry = compactObject(entry);\\n            nobj[key] = entry;\\n        }\\n    }\\n    return nobj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @brief Returns whether the object is an Array\\n * @param {Object} obj\\n * @return {Boolean}\\n */\\nArray.IsArray = (obj) => {\\n    return (Object.prototype.toString.call(obj) === \\'[object Array]\\')\\n}\\n\\n/**\\n * @brief Deep removes all values that are truthy false\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function (obj) {\\n    var nobj = {};\\n    if (Array.IsArray(obj)) {\\n        nobj = [];\\n        for (var entry in obj) {\\n            entry = obj[entry];\\n            if (!entry) continue;\\n            if (typeof entry == \"object\")\\n                entry = compactObject(entry);\\n            nobj.push(entry);\\n        }\\n    } else {\\n        for (var key in obj) {\\n            var entry = obj[key];\\n            if (!entry) continue;\\n            if (typeof entry == \"object\")\\n                entry = compactObject(entry);\\n            nobj[key] = entry;\\n        }\\n    }\\n    return nobj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3751835,
                "title": "2705-compact-object-easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        let array = []\\n        for (const element of obj) {\\n            if (element) {\\n                if (typeof element == \\'object\\') array.push(compactObject(element))\\n                else array.push(element)   \\n            }\\n        }\\n        return array;\\n    }\\n\\n    let newObj = {}\\n\\n    for (let element in obj) {\\n        if (obj[element]) {\\n            if (typeof obj[element] == \\'object\\') newObj[element] = compactObject(obj[element])\\n             else  newObj[element] = obj[element]\\n        }\\n    }\\n    return newObj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        let array = []\\n        for (const element of obj) {\\n            if (element) {\\n                if (typeof element == \\'object\\') array.push(compactObject(element))\\n                else array.push(element)   \\n            }\\n        }\\n        return array;\\n    }\\n\\n    let newObj = {}\\n\\n    for (let element in obj) {\\n        if (obj[element]) {\\n            if (typeof obj[element] == \\'object\\') newObj[element] = compactObject(obj[element])\\n             else  newObj[element] = obj[element]\\n        }\\n    }\\n    return newObj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743716,
                "title": "recursive-removal-of-falsy-values-in-nested-objects-an-approach-with-o-n-time-and-space-complexity",
                "content": "# Intuition\\nThe task here is to remove all \"falsy\" (false, null, 0, \"\", undefined, and NaN) values from a given object which can be either an array or a plain object (dictionary). The function compactObject does this by traversing the object. If it encounters an array or another object, it makes a recursive call to handle it. If it encounters a \"truthy\" value, it keeps that value. The isObject function is used to check if a value is a plain object.\\n\\n# Approach\\nWe make use of the recursion to traverse the input object. During traversal, if the current item is an array, we iterate over its elements, and for each element, we check its type. If the element is also an array or an object, we make a recursive call to **compactObject**. If the element is a \"truthy\" value, we include it in the results. The same process is applied for objects, but instead of iterating over indices, we iterate over keys.\\n\\nThe **isObject** function checks whether a given value is a plain object. It does this by checking whether the type of the value is \\'object\\', the value is not null, and the value is not an array.\\n\\n# Complexity\\n**- Time complexity:**\\nThe time complexity of this function is O(n), where n is the total number of elements or properties in the object. This is because we are traversing the entire object once.\\n\\n**- Space complexity:**\\nThe space complexity is also O(n), where n is the size of the input object. This is because in the worst-case scenario, we might end up creating a deep copy of the input object (if all values are \"truthy\"). In addition, due to the recursive calls, there will be n function calls placed onto the call stack.\\n\\nPlease note that \\'n\\' here refers to the total number of nested elements or properties in the object, not just the top-level ones.\\n\\n```\\nRuntime 95 ms\\nMemory 52.6 MB\\n```\\n\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        const res = []\\n        obj.forEach((value)=>{\\n            if(Array.isArray(value)){\\n               res.push(compactObject(value))\\n            } else if (isObject(value)){\\n               res.push(compactObject(value))\\n            } else if (Boolean(value)){\\n                res.push(value)\\n            } \\n        })\\n        return res\\n    } \\n    if (isObject(obj)){\\n        const res = {}\\n        Object.entries(obj).forEach(([key, value])=>{\\n            if (Array.isArray(value)){\\n               res[key] = compactObject(value)\\n            } else if (isObject(value)){\\n                res[key] = compactObject(value)\\n            } else if (Boolean(value)){\\n                res[key] = value\\n            }\\n        })\\n        return res\\n   }\\n};\\n\\nfunction isObject(val){\\n    if (typeof val === \\'object\\' \\n        && val !== null \\n        && !Array.isArray(val)) {\\n        return true\\n    }\\n    return false\\n }\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nRuntime 95 ms\\nMemory 52.6 MB\\n```\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        const res = []\\n        obj.forEach((value)=>{\\n            if(Array.isArray(value)){\\n               res.push(compactObject(value))\\n            } else if (isObject(value)){\\n               res.push(compactObject(value))\\n            } else if (Boolean(value)){\\n                res.push(value)\\n            } \\n        })\\n        return res\\n    } \\n    if (isObject(obj)){\\n        const res = {}\\n        Object.entries(obj).forEach(([key, value])=>{\\n            if (Array.isArray(value)){\\n               res[key] = compactObject(value)\\n            } else if (isObject(value)){\\n                res[key] = compactObject(value)\\n            } else if (Boolean(value)){\\n                res[key] = value\\n            }\\n        })\\n        return res\\n   }\\n};\\n\\nfunction isObject(val){\\n    if (typeof val === \\'object\\' \\n        && val !== null \\n        && !Array.isArray(val)) {\\n        return true\\n    }\\n    return false\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734240,
                "title": "js-solution",
                "content": "Recursively prune the object `o`\\n\\n---\\n\\n```\\nlet compactObject = o => {\\n    if (_.isBoolean(o) || _.isInteger(o))\\n        return o;\\n    if (_.isArray(o))\\n        return o.filter(x => x).map(x => compactObject(x));\\n    if (_.isObject(o))\\n        for (let [k, v] of Object.entries(o))\\n            if (v)\\n                o[k] = compactObject(v);\\n            else\\n                delete o[k];\\n    return o;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet compactObject = o => {\\n    if (_.isBoolean(o) || _.isInteger(o))\\n        return o;\\n    if (_.isArray(o))\\n        return o.filter(x => x).map(x => compactObject(x));\\n    if (_.isObject(o))\\n        for (let [k, v] of Object.entries(o))\\n            if (v)\\n                o[k] = compactObject(v);\\n            else\\n                delete o[k];\\n    return o;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3718590,
                "title": "easy-recursive-approach-2-3-line-solution",
                "content": "# Intuition\\n<!-- two cases to think about either ob can be array or normal object and just write recursive logic -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\' || obj === null) return obj;\\n    if(Array.isArray(obj)){\\n        return obj.filter(item => Boolean(item)).map(element=> compactObject(element));\\n    }\\n    return Object.fromEntries(\\n        Object.entries(obj).filter(([key, value])=> Boolean(value)).map(([key, value])=> [key, compactObject(value)])\\n    );\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\' || obj === null) return obj;\\n    if(Array.isArray(obj)){\\n        return obj.filter(item => Boolean(item)).map(element=> compactObject(element));\\n    }\\n    return Object.fromEntries(\\n        Object.entries(obj).filter(([key, value])=> Boolean(value)).map(([key, value])=> [key, compactObject(value)])\\n    );\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704279,
                "title": "javascript-solution",
                "content": "I mainly write in Python, I asked chatgpt to help me convert to JavaScript.\\n\\n```JavaScript\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.map(n => compactObject(n)).filter(n => n)\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    const item = {}\\n    for (let [k, v] of Object.entries(obj)) {\\n      if (v) {\\n        item[k] = compactObject(v)\\n      }\\n    }\\n    return item\\n  }\\n  return obj\\n}\\n```\\n\\n\\n```python\\nclass Solution:\\n    def compactObject(self, obj: Any):\\n        if isinstance(obj, list):\\n            return [self.compactObject(n) for n in obj if n]\\n        elif isinstance(obj, dict):\\n            item = {}\\n            for k, v in obj.items():\\n                if v:\\n                    item[k] = self.compactObject(v)\\n            return item\\n        return obj\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.map(n => compactObject(n)).filter(n => n)\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    const item = {}\\n    for (let [k, v] of Object.entries(obj)) {\\n      if (v) {\\n        item[k] = compactObject(v)\\n      }\\n    }\\n    return item\\n  }\\n  return obj\\n}\\n```\n```python\\nclass Solution:\\n    def compactObject(self, obj: Any):\\n        if isinstance(obj, list):\\n            return [self.compactObject(n) for n in obj if n]\\n        elif isinstance(obj, dict):\\n            item = {}\\n            for k, v in obj.items():\\n                if v:\\n                    item[k] = self.compactObject(v)\\n            return item\\n        return obj\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703952,
                "title": "recursive-solution-beats-more-than-90",
                "content": "# Approach\\nWe check whether given object is array or not, than act accordingly. Take a note that null is an object, but it\\'s falsy.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O (n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n        const temp = []\\n        for (const item of obj) {\\n            if (item) {\\n                if (typeof item === \\'object\\') temp.push(compactObject(item))\\n                else temp.push(item)\\n            }\\n        }\\n        return temp\\n    }\\n    for (const [key, value] of Object.entries(obj)) {\\n        if (!value) delete obj[key]\\n        else if (typeof value === \\'object\\') obj[key] = compactObject(value)\\n    }\\n    return obj\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n        const temp = []\\n        for (const item of obj) {\\n            if (item) {\\n                if (typeof item === \\'object\\') temp.push(compactObject(item))\\n                else temp.push(item)\\n            }\\n        }\\n        return temp\\n    }\\n    for (const [key, value] of Object.entries(obj)) {\\n        if (!value) delete obj[key]\\n        else if (typeof value === \\'object\\') obj[key] = compactObject(value)\\n    }\\n    return obj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685264,
                "title": "javascript-clean-solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (!obj) return obj;\\n    Object.entries(obj).forEach(([key, value]) => {\\n        if (!value) {\\n            console.log(value);\\n            delete obj[key];\\n            return;\\n        }\\n\\n        if (typeof value === \"object\") {\\n            compactObject(value);\\n            obj[key] = Array.isArray(value) ? value.filter((item) => item) : value;\\n        }\\n    })\\n\\n\\n\\n    return Array.isArray(obj) ? obj.filter((item) => item) : obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (!obj) return obj;\\n    Object.entries(obj).forEach(([key, value]) => {\\n        if (!value) {\\n            console.log(value);\\n            delete obj[key];\\n            return;\\n        }\\n\\n        if (typeof value === \"object\") {\\n            compactObject(value);\\n            obj[key] = Array.isArray(value) ? value.filter((item) => item) : value;\\n        }\\n    })\\n\\n\\n\\n    return Array.isArray(obj) ? obj.filter((item) => item) : obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3684604,
                "title": "beats-95-javascript-solution",
                "content": "# Intuition\\nRECURSION BABY\\n\\n# Approach\\nJUST USE SIMPLE RECURSION\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)) {\\n        for(let i=0; i<obj.length; i++){\\n            if(obj[i] === null || obj[i] === 0 || obj[i] === false || obj[i] === undefined || obj[i] === \"\")    {\\n                obj[i] = \"YOURNAME\";\\n            }\\n            if(Array.isArray(obj[i])){\\n                obj[i] = compactObject(obj[i]);\\n            }\\n            else if(typeof obj[i] === \\'object\\'){\\n                obj[i] = compactObject(obj[i]);\\n            }\\n        }\\n        obj = obj.filter(item => item !== \"YOURNAME\");\\n    } else{\\n    Object.keys(obj).forEach((k) => {\\n        if(obj[k] === null || obj[k] === 0 || obj[k] === false || obj[k] === \"\")    {\\n            delete obj[k];\\n        }\\n        if(Array.isArray(obj[k])){\\n            obj[k] = compactObject(obj[k]);\\n            }\\n        \\n        else if(typeof obj[k] === \\'object\\'){\\n            obj[k] = compactObject(obj[k]);\\n        }\\n    });\\n    }\\n    return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)) {\\n        for(let i=0; i<obj.length; i++){\\n            if(obj[i] === null || obj[i] === 0 || obj[i] === false || obj[i] === undefined || obj[i] === \"\")    {\\n                obj[i] = \"YOURNAME\";\\n            }\\n            if(Array.isArray(obj[i])){\\n                obj[i] = compactObject(obj[i]);\\n            }\\n            else if(typeof obj[i] === \\'object\\'){\\n                obj[i] = compactObject(obj[i]);\\n            }\\n        }\\n        obj = obj.filter(item => item !== \"YOURNAME\");\\n    } else{\\n    Object.keys(obj).forEach((k) => {\\n        if(obj[k] === null || obj[k] === 0 || obj[k] === false || obj[k] === \"\")    {\\n            delete obj[k];\\n        }\\n        if(Array.isArray(obj[k])){\\n            obj[k] = compactObject(obj[k]);\\n            }\\n        \\n        else if(typeof obj[k] === \\'object\\'){\\n            obj[k] = compactObject(obj[k]);\\n        }\\n    });\\n    }\\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3681645,
                "title": "javascript-2-lines-d-this-is-bait-of-excellent-quality",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nconst compactObject = val => {\\n  const data = Array.isArray(val) ? val.filter(Boolean) : val;\\n  \\n  return Object.keys(data).reduce(\\n    (acc, key) => {\\n      const value = data[key];\\n      if (Boolean(value))\\n        acc[key] = typeof value === \\'object\\' ? compactObject(value) : value;\\n      return acc;\\n    },\\n    Array.isArray(val) ? [] : {}\\n  );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nconst compactObject = val => {\\n  const data = Array.isArray(val) ? val.filter(Boolean) : val;\\n  \\n  return Object.keys(data).reduce(\\n    (acc, key) => {\\n      const value = data[key];\\n      if (Boolean(value))\\n        acc[key] = typeof value === \\'object\\' ? compactObject(value) : value;\\n      return acc;\\n    },\\n    Array.isArray(val) ? [] : {}\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679042,
                "title": "js-runtime-beats-99-91-memory-beats-99-26",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy original solution was with reduce, however it was not memory efficient\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, since obj can be an Array or Object I wanted to treat these two types differently. The Array can easily be filtered through using forEach and appending to a new array. The object can be filtered through and keys can be deleted if they are falsy.\\n\\nSecondly, since we don\\'t know the depth of the object, this has to be a recursive solution. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n    \\nvar compactObject = function(obj) {\\n    if (!obj) return\\n    if (obj instanceof Array) {\\n        let filtered = []\\n        obj.forEach((element) => {\\n            if (!element) return\\n            if (typeof element === \\'object\\') {\\n                filtered.push(compactObject(element))\\n            } else {\\n                filtered.push(element)\\n            }\\n        }, [])\\n        return filtered\\n    } else {\\n        Object.keys(obj).forEach((id) => {\\n            if (!obj[id]) {\\n                delete obj[id]\\n            } else {\\n                if (typeof obj[id] === \\'object\\') {\\n                    obj[id] = compactObject(obj[id])\\n                }\\n            }\\n        })\\n    }\\n\\n    return obj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n    \\nvar compactObject = function(obj) {\\n    if (!obj) return\\n    if (obj instanceof Array) {\\n        let filtered = []\\n        obj.forEach((element) => {\\n            if (!element) return\\n            if (typeof element === \\'object\\') {\\n                filtered.push(compactObject(element))\\n            } else {\\n                filtered.push(element)\\n            }\\n        }, [])\\n        return filtered\\n    } else {\\n        Object.keys(obj).forEach((id) => {\\n            if (!obj[id]) {\\n                delete obj[id]\\n            } else {\\n                if (typeof obj[id] === \\'object\\') {\\n                    obj[id] = compactObject(obj[id])\\n                }\\n            }\\n        })\\n    }\\n\\n    return obj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670685,
                "title": "typescript-recursive-in-place-solution",
                "content": "# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj))\\n        obj = obj.filter(Boolean);\\n    else for (const prop in obj)\\n            if (!obj[prop]) delete obj[prop];\\n\\n    for (const prop in obj)\\n        if (typeof obj[prop] === \\'object\\')\\n            obj[prop] = compactObject(obj[prop]);\\n\\n    return obj;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj))\\n        obj = obj.filter(Boolean);\\n    else for (const prop in obj)\\n            if (!obj[prop]) delete obj[prop];\\n\\n    for (const prop in obj)\\n        if (typeof obj[prop] === \\'object\\')\\n            obj[prop] = compactObject(obj[prop]);\\n\\n    return obj;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666824,
                "title": "js-intuitive-solution-in-3-lines-with-recursion",
                "content": "# Code\\n```\\n/**\\n * @param {Object} o\\n * @return {Object}\\n */\\nvar compactObject = function(o) {\\n    // step 1 : filter array\\n    if (Array.isArray(o)) o = o.filter((v) => v);\\n    // or object\\n    else Object.keys(o).forEach((key, index) => { if (! o[key]) delete o[key]});\\n    // step 2 : recursive call for each element of type \\'object\\'\\n    for (key in o) if (typeof o[key] == \\'object\\') o[key] = compactObject(o[key]);\\n    return o;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} o\\n * @return {Object}\\n */\\nvar compactObject = function(o) {\\n    // step 1 : filter array\\n    if (Array.isArray(o)) o = o.filter((v) => v);\\n    // or object\\n    else Object.keys(o).forEach((key, index) => { if (! o[key]) delete o[key]});\\n    // step 2 : recursive call for each element of type \\'object\\'\\n    for (key in o) if (typeof o[key] == \\'object\\') o[key] = compactObject(o[key]);\\n    return o;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666675,
                "title": "easy-solution-heavily-explained",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n \\nvar compactObject = function(obj) {\\n  // Step 1: Handle arrays\\n  if (Array.isArray(obj)) {\\n    // Filter out falsy values from the array and recursively compact each element\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  // Step 2: Handle non-object values\\n  if (typeof obj !== \\'object\\' || obj === null) {\\n    // Return the truthy value as it is\\n    return obj;\\n  }\\n\\n  // Step 3: Handle objects\\n  const compactedObj = {};\\n\\n  // Step 4: Iterate over each key in the object\\n  for (let key in obj) {\\n    // Step 5: Recursively compact the value of each key\\n    const compactedValue = compactObject(obj[key]);\\n\\n    // Step 6: Check if the compactedValue is truthy\\n    if (Boolean(compactedValue)) {\\n      // Step 7: Add the truthy value to the compactedObj with the same key\\n      compactedObj[key] = compactedValue;\\n    }\\n  }\\n\\n  // Step 8: Return the compacted object\\n  return compactedObj;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n \\nvar compactObject = function(obj) {\\n  // Step 1: Handle arrays\\n  if (Array.isArray(obj)) {\\n    // Filter out falsy values from the array and recursively compact each element\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  // Step 2: Handle non-object values\\n  if (typeof obj !== \\'object\\' || obj === null) {\\n    // Return the truthy value as it is\\n    return obj;\\n  }\\n\\n  // Step 3: Handle objects\\n  const compactedObj = {};\\n\\n  // Step 4: Iterate over each key in the object\\n  for (let key in obj) {\\n    // Step 5: Recursively compact the value of each key\\n    const compactedValue = compactObject(obj[key]);\\n\\n    // Step 6: Check if the compactedValue is truthy\\n    if (Boolean(compactedValue)) {\\n      // Step 7: Add the truthy value to the compactedObj with the same key\\n      compactedObj[key] = compactedValue;\\n    }\\n  }\\n\\n  // Step 8: Return the compacted object\\n  return compactedObj;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659158,
                "title": "javascript-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar compactObject = function(obj) {\\n\\n    let ans;\\n\\n    if(Array.isArray(obj)){\\n\\n      ans = [];\\n      let index = 0;\\n\\n      for(let val of obj){\\n      \\n        if(val){\\n          \\n          if(typeof val == \"object\"){\\n            ans[index++] = compactObject(val);\\n          }\\n          else{\\n            ans[index++] = val;\\n          }\\n\\n        }\\n\\n      }\\n\\n    }\\n    else{ \\n\\n      ans = {};\\n\\n      for(let key in obj){\\n      \\n        if(obj[key]){\\n          \\n          if(typeof obj[key] == \"object\"){\\n            ans[key] = compactObject(obj[key]);\\n          }\\n          else{\\n            ans[key] = obj[key];\\n          }\\n\\n        }\\n\\n      }\\n\\n    }\\n\\n    return ans;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar compactObject = function(obj) {\\n\\n    let ans;\\n\\n    if(Array.isArray(obj)){\\n\\n      ans = [];\\n      let index = 0;\\n\\n      for(let val of obj){\\n      \\n        if(val){\\n          \\n          if(typeof val == \"object\"){\\n            ans[index++] = compactObject(val);\\n          }\\n          else{\\n            ans[index++] = val;\\n          }\\n\\n        }\\n\\n      }\\n\\n    }\\n    else{ \\n\\n      ans = {};\\n\\n      for(let key in obj){\\n      \\n        if(obj[key]){\\n          \\n          if(typeof obj[key] == \"object\"){\\n            ans[key] = compactObject(obj[key]);\\n          }\\n          else{\\n            ans[key] = obj[key];\\n          }\\n\\n        }\\n\\n      }\\n\\n    }\\n\\n    return ans;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657195,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const isArray = Array.isArray(obj);\\n    const result = isArray ? [] : {};\\n    for(const key of Object.keys(obj)){\\n        if(typeof obj[key] === \\'object\\' && obj[key]){\\n            result[key] = compactObject(obj[key])\\n        }\\n        else if(obj[key]){\\n            result[key] = obj[key]\\n        }\\n    }\\n\\n    return isArray ? result.filter(Boolean) : result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const isArray = Array.isArray(obj);\\n    const result = isArray ? [] : {};\\n    for(const key of Object.keys(obj)){\\n        if(typeof obj[key] === \\'object\\' && obj[key]){\\n            result[key] = compactObject(obj[key])\\n        }\\n        else if(obj[key]){\\n            result[key] = obj[key]\\n        }\\n    }\\n\\n    return isArray ? result.filter(Boolean) : result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3652180,
                "title": "easy-js-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        let resultArray = [];\\n        for (let val of obj) {\\n            let value = compactObject(val);\\n            if (Boolean(value)) {\\n                resultArray.push(value);\\n            }\\n        }\\n        return resultArray;\\n    }\\n\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        let resultObject = {};\\n        for (let [key, val] of Object.entries(obj)) {\\n            let value = compactObject(val);\\n            if (Boolean(value)) {\\n                resultObject[key] = value;\\n            }\\n        }\\n        return resultObject;\\n    }\\n\\n    if (Boolean(obj) === true) return obj;\\n\\n    return undefined;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        let resultArray = [];\\n        for (let val of obj) {\\n            let value = compactObject(val);\\n            if (Boolean(value)) {\\n                resultArray.push(value);\\n            }\\n        }\\n        return resultArray;\\n    }\\n\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        let resultObject = {};\\n        for (let [key, val] of Object.entries(obj)) {\\n            let value = compactObject(val);\\n            if (Boolean(value)) {\\n                resultObject[key] = value;\\n            }\\n        }\\n        return resultObject;\\n    }\\n\\n    if (Boolean(obj) === true) return obj;\\n\\n    return undefined;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643957,
                "title": "short-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n        for(let i in obj){\\n            if(obj[i] instanceof Object){\\n                obj[i] = compactObject(obj[i])\\n            }\\n        }\\n        if(Array.isArray(obj)){\\n            return obj.filter(o => Boolean(o))\\n        }\\n        Object.keys(obj).forEach(e => {\\n            if(!Boolean(obj[e])){\\n                delete obj[e]\\n            }\\n        })\\n        return obj\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n        for(let i in obj){\\n            if(obj[i] instanceof Object){\\n                obj[i] = compactObject(obj[i])\\n            }\\n        }\\n        if(Array.isArray(obj)){\\n            return obj.filter(o => Boolean(o))\\n        }\\n        Object.keys(obj).forEach(e => {\\n            if(!Boolean(obj[e])){\\n                delete obj[e]\\n            }\\n        })\\n        return obj\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619229,
                "title": "simple-recursive-easy-to-understand-approach-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe question tells us we have a object or array given. So, we go by the following approach.\\n- First check for array (since its also an object). If the values are truthy (the if condition automatically checks for us) and not an object just insert it into a sub array (or results array) otherwise recurse on the value\\n- If an object, apply the same array approach if truthy and not object value add to sub object else recurse the sub object and then return it.\\n- If normal truthy value then return it.  \\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if(Array.isArray(obj)){\\n    let subArr = [];\\n    obj.forEach(o=>{\\n      if(o){\\n        if(typeof o===\\'object\\')subArr.push(compactObject(o));\\n        else subArr.push(o);\\n      }\\n    });\\n    return subArr;\\n  }else if(typeof obj === \\'object\\'){\\n    let subObj = {};\\n    Object.entries(obj).forEach(([key,val])=>{\\n      if(val){\\n        if(typeof val=== \\'object\\')subObj[key] = (compactObject(val)||{});\\n        else subObj[key]=val;\\n      };\\n    });\\n    return subObj;\\n  }else{\\n    if(obj)return obj;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if(Array.isArray(obj)){\\n    let subArr = [];\\n    obj.forEach(o=>{\\n      if(o){\\n        if(typeof o===\\'object\\')subArr.push(compactObject(o));\\n        else subArr.push(o);\\n      }\\n    });\\n    return subArr;\\n  }else if(typeof obj === \\'object\\'){\\n    let subObj = {};\\n    Object.entries(obj).forEach(([key,val])=>{\\n      if(val){\\n        if(typeof val=== \\'object\\')subObj[key] = (compactObject(val)||{});\\n        else subObj[key]=val;\\n      };\\n    });\\n    return subObj;\\n  }else{\\n    if(obj)return obj;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610045,
                "title": "recursively-apply-array-filter-and-delete-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const compact = obj => {\\n        if (Array.isArray(obj)){\\n            obj = obj.filter(o => !!o);\\n            for(let i = 0;i < obj.length; ++i) {\\n                obj[i] = compact(obj[i]);\\n            }\\n        }\\n        else if (obj !== null && typeof obj === \\'object\\') {\\n            for(const k in obj) {\\n                if (!obj[k]) {\\n                    delete obj[k];\\n                }\\n                else {\\n                    obj[k] = compact(obj[k]);\\n                }\\n            }\\n        }\\n        return obj;\\n    }\\n    return compact(obj);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const compact = obj => {\\n        if (Array.isArray(obj)){\\n            obj = obj.filter(o => !!o);\\n            for(let i = 0;i < obj.length; ++i) {\\n                obj[i] = compact(obj[i]);\\n            }\\n        }\\n        else if (obj !== null && typeof obj === \\'object\\') {\\n            for(const k in obj) {\\n                if (!obj[k]) {\\n                    delete obj[k];\\n                }\\n                else {\\n                    obj[k] = compact(obj[k]);\\n                }\\n            }\\n        }\\n        return obj;\\n    }\\n    return compact(obj);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3603846,
                "title": "js-flatmap-solution",
                "content": "Instead of doing `map + filter` for the array, we traverse it only once via `flatMap`.\\n\\n`flatMap` allows to filter values with the return of an empty array in the callback. Also, it allows you to change the returned values.\\nFor example:\\n```\\nconst arr = [1, null, 2, null];\\nconst filtered = arr.flatMap(it => Boolean(it) ? it * 2 : []);\\n// filtered = [2, 4]\\n```\\n\\nSolution:\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction isObject(val: unknown) {\\n    return typeof val === \\'object\\' && val !== null;\\n}\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n        return obj.flatMap(it => {\\n            if (isObject(it)) {\\n                return [compactObject(it)];\\n            }\\n            return it || [];\\n        })\\n    } else {\\n        const copy = {};\\n\\n        for (let k of Object.keys(obj)) {\\n            if (isObject(obj[k])) {\\n                copy[k] = compactObject(obj[k])\\n            } else {\\n                if (obj[k]) {\\n                    copy[k] = obj[k];\\n                }\\n            }\\n        }\\n\\n        return copy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst arr = [1, null, 2, null];\\nconst filtered = arr.flatMap(it => Boolean(it) ? it * 2 : []);\\n// filtered = [2, 4]\\n```\n```\\ntype Obj = Record<any, any>;\\n\\nfunction isObject(val: unknown) {\\n    return typeof val === \\'object\\' && val !== null;\\n}\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n        return obj.flatMap(it => {\\n            if (isObject(it)) {\\n                return [compactObject(it)];\\n            }\\n            return it || [];\\n        })\\n    } else {\\n        const copy = {};\\n\\n        for (let k of Object.keys(obj)) {\\n            if (isObject(obj[k])) {\\n                copy[k] = compactObject(obj[k])\\n            } else {\\n                if (obj[k]) {\\n                    copy[k] = obj[k];\\n                }\\n            }\\n        }\\n\\n        return copy;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600649,
                "title": "easy-typescript-solution",
                "content": "\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)) return obj.filter(Boolean).map(compactObject)\\n    if(typeof obj !== \\'object\\' || obj === null) return obj\\n\\n    let res = {}\\n    for(let key in obj){\\n        let value = compactObject(obj[key])\\n        if(value) res[key] = value\\n\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)) return obj.filter(Boolean).map(compactObject)\\n    if(typeof obj !== \\'object\\' || obj === null) return obj\\n\\n    let res = {}\\n    for(let key in obj){\\n        let value = compactObject(obj[key])\\n        if(value) res[key] = value\\n\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589983,
                "title": "typescript-1-liner-solution-commented-with-approch",
                "content": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n\\t/*\\n\\t\\tWe are first looking if it is an array, if yes, we are using map any giving `compactObject` as callback, \\n\\t\\twhich will do same thing again and then we are filtering nullify values,\\n\\t\\tif it is an object we then we are reducing it by creating a new object which is holding only non null \\n\\t\\tvalues and if it is not array nor object just return it\\n\\t*/\\n\\treturn Array.isArray(obj) ? obj.map(compactObject).filter((item) => item) : (typeof obj === \"object\" && obj) ? Object.entries(obj).reduce((acc, [key, val]) => val ? ({...acc, [key]: compactObject(val)}) : acc, {}) : obj;\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n\\t/*\\n\\t\\tWe are first looking if it is an array, if yes, we are using map any giving `compactObject` as callback, \\n\\t\\twhich will do same thing again and then we are filtering nullify values,\\n\\t\\tif it is an object we then we are reducing it by creating a new object which is holding only non null \\n\\t\\tvalues and if it is not array nor object just return it\\n\\t*/\\n\\treturn Array.isArray(obj) ? obj.map(compactObject).filter((item) => item) : (typeof obj === \"object\" && obj) ? Object.entries(obj).reduce((acc, [key, val]) => val ? ({...acc, [key]: compactObject(val)}) : acc, {}) : obj;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582082,
                "title": "beats-100-memory-82-time",
                "content": "\\n# Approach\\nUsing recursion + simple if condition to distinguish array and object\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)){\\n        let result = [];\\n        obj.forEach((v,index)=>{\\n            if(Boolean(v)){\\n                if(Array.isArray(v)){\\n                    result.push(compactObject(v));                    \\n                }else if(typeof v ==\\'object\\'){\\n                    result.push(compactObject(v));\\n                }else {\\n                    result.push(v);\\n                }\\n            }            \\n        });\\n        return result;\\n    }\\n\\n    for(let key in obj){\\n        if(!Boolean(obj[key])){\\n            delete obj[key];\\n        }else{\\n            //Edge case 1: obj[key] is array or object\\n            if(Array.isArray(obj[key])){\\n                obj[key]=compactObject(obj[key]);\\n            }else if(typeof obj[key]==\\'object\\'){\\n                obj[key]=compactObject(obj[key]);\\n            }\\n        }\\n    }\\n    return obj;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)){\\n        let result = [];\\n        obj.forEach((v,index)=>{\\n            if(Boolean(v)){\\n                if(Array.isArray(v)){\\n                    result.push(compactObject(v));                    \\n                }else if(typeof v ==\\'object\\'){\\n                    result.push(compactObject(v));\\n                }else {\\n                    result.push(v);\\n                }\\n            }            \\n        });\\n        return result;\\n    }\\n\\n    for(let key in obj){\\n        if(!Boolean(obj[key])){\\n            delete obj[key];\\n        }else{\\n            //Edge case 1: obj[key] is array or object\\n            if(Array.isArray(obj[key])){\\n                obj[key]=compactObject(obj[key]);\\n            }else if(typeof obj[key]==\\'object\\'){\\n                obj[key]=compactObject(obj[key]);\\n            }\\n        }\\n    }\\n    return obj;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576498,
                "title": "javascript-runtime-79ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/58b8154e-8ecd-4af7-a7d6-edfa2efa8cc0_1685385820.780097.png)\\n\\n# Approach\\n```\\nfunction compactObject(obj) {\\n    // Handle array objets\\n    if (Array.isArray(obj)) return obj.filter(v => v).map(v => typeof v == \\'object\\' ? compactObject(v) : v);\\n\\n    // Handle map objects\\n    for (const key of Object.keys(obj)) {\\n        const val = obj[key];\\n\\n        if (!val) {\\n            delete obj[key];\\n        } else if (typeof val == \\'object\\') {\\n            obj[key] = compactObject(val);\\n        } \\n    }\\n\\n    return obj;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction compactObject(obj) {\\n    // Handle array objets\\n    if (Array.isArray(obj)) return obj.filter(v => v).map(v => typeof v == \\'object\\' ? compactObject(v) : v);\\n\\n    // Handle map objects\\n    for (const key of Object.keys(obj)) {\\n        const val = obj[key];\\n\\n        if (!val) {\\n            delete obj[key];\\n        } else if (typeof val == \\'object\\') {\\n            obj[key] = compactObject(val);\\n        } \\n    }\\n\\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576140,
                "title": "javascript-90-runtime",
                "content": "```\\nconst compactObject = (obj) => {\\n  let res;\\n  if (Array.isArray(obj)) {\\n    res = [];\\n    for (const x of obj) {\\n      if (typeof x == \"object\" && x) res.push(compactObject(x));\\n      else if (x) res.push(x);\\n    }\\n  } else if (typeof obj == \"object\") {\\n    res = {};\\n    for (const [key, val] of Object.entries(obj)) {\\n      if (typeof val == \"object\" && val) res[key] = compactObject(val);\\n      else if (val) res[key] = val;\\n    }\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst compactObject = (obj) => {\\n  let res;\\n  if (Array.isArray(obj)) {\\n    res = [];\\n    for (const x of obj) {\\n      if (typeof x == \"object\" && x) res.push(compactObject(x));\\n      else if (x) res.push(x);\\n    }\\n  } else if (typeof obj == \"object\") {\\n    res = {};\\n    for (const [key, val] of Object.entries(obj)) {\\n      if (typeof val == \"object\" && val) res[key] = compactObject(val);\\n      else if (val) res[key] = val;\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575516,
                "title": "use-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery time when we have nested complex object we need a recursion to traverse it, and that\\'s it!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. first we initialize a new variable `result` as an empty array (`[]`) if obj is an array, or as an empty object (`{}`) otherwise. This will store the reduced object.\\n\\n2. we iterate through each property (`key`) in the input object (`obj`).\\n\\n3. if the current property (obj[key]) is empty (falsy), the iteration continues (we just ignore this key).\\n\\n4. if the current value is an object (excluding arrays), recursively call the compactObject function on the property and assign the result to the corresponding property in the result object. If result is an array, push the result as a new element to the array.\\n\\n5. othwervise, if the current value is not an object, we assign the property value to the corresponding property in the result object. If result is an array, push the value as a new element to the array.\\n\\n6. finally, once all properties have been processed, the result object is returned.\\n\\n# Complexity\\n- Time complexity: n/a\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n/a\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  const result = (Array.isArray(obj) ? [] : {});\\n  for (let key in obj) {\\n    if (!obj[key]) { continue; }\\n    if (typeof obj[key] === \\'object\\') {\\n      if (Array.isArray(result)) {\\n        result.push(compactObject(obj[key]));\\n      } else {\\n        result[key] = compactObject(obj[key]);\\n      }\\n    } else {\\n      if (Array.isArray(result)) {\\n        result.push(obj[key]);\\n      } else {\\n        result[key] = obj[key];\\n      }\\n    }\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  const result = (Array.isArray(obj) ? [] : {});\\n  for (let key in obj) {\\n    if (!obj[key]) { continue; }\\n    if (typeof obj[key] === \\'object\\') {\\n      if (Array.isArray(result)) {\\n        result.push(compactObject(obj[key]));\\n      } else {\\n        result[key] = compactObject(obj[key]);\\n      }\\n    } else {\\n      if (Array.isArray(result)) {\\n        result.push(obj[key]);\\n      } else {\\n        result[key] = obj[key];\\n      }\\n    }\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3573298,
                "title": "recur",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\') {\\n        if(obj) return obj\\n        return null\\n    }\\n    if(obj === null) return null\\n    if(Array.isArray(obj)) {\\n        const res = [];\\n        for(const ele of obj) {\\n            const val = compactObject(ele)\\n            if(val === null) continue\\n            res.push(val)\\n        }\\n        return res\\n    }\\n    let res = {}\\n    for(let key in obj) {\\n        const ele = compactObject(obj[key])\\n        if(ele !== null) res[key] = ele;\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\') {\\n        if(obj) return obj\\n        return null\\n    }\\n    if(obj === null) return null\\n    if(Array.isArray(obj)) {\\n        const res = [];\\n        for(const ele of obj) {\\n            const val = compactObject(ele)\\n            if(val === null) continue\\n            res.push(val)\\n        }\\n        return res\\n    }\\n    let res = {}\\n    for(let key in obj) {\\n        const ele = compactObject(obj[key])\\n        if(ele !== null) res[key] = ele;\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569902,
                "title": "recursion",
                "content": "\\n\\n# Code\\n```\\nconst isObj = o => o?.constructor === Object;\\n\\nvar compactObject = function(obj) {\\n    if(Boolean(obj) === false) return null;\\n    else if(Array.isArray(obj)) {\\n        return obj.reduce((last, cur) => {\\n            const compacted = compactObject(cur);\\n            if(compacted !== null) {\\n                last.push(compacted)\\n            }\\n            return last;\\n        }, [])\\n    }\\n    else if(isObj(obj)) {\\n        return Object.keys(obj).reduce((last, key) => {\\n            const compacted = compactObject(obj[key]);\\n            if(compacted !== null) {\\n                last[key] = compacted;\\n            }\\n            return last;\\n        }, {})\\n    }\\n    return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isObj = o => o?.constructor === Object;\\n\\nvar compactObject = function(obj) {\\n    if(Boolean(obj) === false) return null;\\n    else if(Array.isArray(obj)) {\\n        return obj.reduce((last, cur) => {\\n            const compacted = compactObject(cur);\\n            if(compacted !== null) {\\n                last.push(compacted)\\n            }\\n            return last;\\n        }, [])\\n    }\\n    else if(isObj(obj)) {\\n        return Object.keys(obj).reduce((last, key) => {\\n            const compacted = compactObject(obj[key]);\\n            if(compacted !== null) {\\n                last[key] = compacted;\\n            }\\n            return last;\\n        }, {})\\n    }\\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569276,
                "title": "without-extra-functions-except-isarray",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const isArray = Array.isArray(obj);\\n    const ret = isArray ? [] : {};\\n\\n    for (const key in obj) {\\n        if (obj[key]) {\\n            if (isArray) ret.push(typeof obj[key] === \"object\" ? compactObject(obj[key]) : obj[key]);\\n            else ret[key] = typeof obj[key] === \"object\" ? compactObject(obj[key]) : obj[key];\\n        }\\n    }\\n\\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const isArray = Array.isArray(obj);\\n    const ret = isArray ? [] : {};\\n\\n    for (const key in obj) {\\n        if (obj[key]) {\\n            if (isArray) ret.push(typeof obj[key] === \"object\" ? compactObject(obj[key]) : obj[key]);\\n            else ret[key] = typeof obj[key] === \"object\" ? compactObject(obj[key]) : obj[key];\\n        }\\n    }\\n\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2063477,
                "content": [
                    {
                        "username": "Harsh-br0",
                        "content": "idk why comment section seems like speechless...."
                    },
                    {
                        "username": "antonbrypto",
                        "content": "anybody here?"
                    },
                    {
                        "username": "robin_rahman",
                        "content": "Throws a Runtime Error: \"RangeError: Maximum call stack size exceeded\" for Array.isArray(obj). But Run correctly, no idea what\\'s the problem in my case."
                    }
                ]
            },
            {
                "id": 2065435,
                "content": [
                    {
                        "username": "Harsh-br0",
                        "content": "idk why comment section seems like speechless...."
                    },
                    {
                        "username": "antonbrypto",
                        "content": "anybody here?"
                    },
                    {
                        "username": "robin_rahman",
                        "content": "Throws a Runtime Error: \"RangeError: Maximum call stack size exceeded\" for Array.isArray(obj). But Run correctly, no idea what\\'s the problem in my case."
                    }
                ]
            }
        ]
    },
    {
        "title": "Timeout Cancellation",
        "question_content": "<p>Given a function <code>fn</code>, an array of&nbsp;arguments&nbsp;<code>args</code>, and a timeout&nbsp;<code>t</code>&nbsp;in milliseconds, return a cancel function <code>cancelFn</code>.</p>\n\n<p>After a delay of&nbsp;<code>t</code>,&nbsp;<code>fn</code>&nbsp;should be called with <code>args</code> passed as parameters <strong>unless</strong> <code>cancelFn</code> was invoked before the delay of <code>t</code> milliseconds elapses, specifically at <code>cancelT</code>&nbsp;ms.&nbsp;In that case,&nbsp;<code>fn</code> should never be called.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (x) =&gt; x * 5, args = [2], t = 20, cancelT = 50\n<strong>Output:</strong> [{&quot;time&quot;: 20, &quot;returned&quot;: 10}]\n<strong>Explanation:</strong> \nconst result = []\n\nconst fn = (x) =&gt; x * 5\n\nconst start = performance.now()&nbsp;\n\nconst log = (...argsArr) =&gt; {\n    const diff = Math.floor(performance.now() - start);\n    result.push({&quot;time&quot;: diff, &quot;returned&quot;: fn(...argsArr)})\n}\n &nbsp; &nbsp;&nbsp;\nconst cancel = cancellable(log, [2], 20);\n\nconst maxT = Math.max(t, 50)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\nsetTimeout(cancel, cancelT)\n\nsetTimeout(() =&gt; {\n &nbsp; &nbsp; console.log(result) // [{&quot;time&quot;:20,&quot;returned&quot;:10}]\n}, 65)\n\nThe cancellation was scheduled to occur after a delay of cancelT (50ms), which happened after the execution of fn(2) at 20ms.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (x) =&gt; x**2, args = [2], t = 100, cancelT = 50 \n<strong>Output:</strong> []\n<strong>Explanation:</strong> The cancellation was scheduled to occur after a delay of cancelT (50ms), which happened before the execution of fn(2) at 100ms, resulting in fn(2) never being called.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (x1, x2) =&gt; x1 * x2, args = [2,4], t = 30, cancelT = 100\n<strong>Output:</strong> [{&quot;time&quot;: 30, &quot;returned&quot;: 8}]\n<strong>Explanation: </strong>The cancellation was scheduled to occur after a delay of cancelT (100ms), which happened after the execution of fn(2,4) at 30ms.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>fn</code> is a function</li>\n\t<li><code>args</code> is a valid JSON array</li>\n\t<li><code>1 &lt;= args.length &lt;= 10</code></li>\n\t<li><code><font face=\"monospace\">20 &lt;= t &lt;= 1000</font></code></li>\n\t<li><code><font face=\"monospace\">10 &lt;= cancelT &lt;= 1000</font></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3725241,
                "title": "full-explanation-unlike-any-others",
                "content": "# Intuition\\nThe following problem and the next one **\" Interval Cancellation \" **  represent an important concept in JavaScript . It\\'s gonna be a long but full through explanation so sit tight \\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\n# **Motive :**  Return a function after a specifc time only if you didn\\'t call other function , if we called the other function then the first function shouldn\\'t be called at all !!\\n\\n# Pre - Requistes : \\n- Familarity with callback functions\\n- Rest parameter\\n- clearTimeout and setTimeout methods\\n\\nIf you know those , Congrats \\uD83C\\uDF89 ! You can further continue reading , if not then please go back and understand those pretty well .\\n\\n# A QUESTION YOU MIGHT BE ASKING : WHY DO I NEED TO USE clearTimeout and setTimeout ?\\n\\nIn Javascript controlling the flow and exceution of tasks , is quite crucial. The following 2 questions (**Execute Cancellable function with delay**) and (**Interval Cnacellation**) , posses a really really important concept , sit tight and read well \\uD83D\\uDE0A !\\n\\nBy using such methods , we can easily control timing and execution of a code , we can either delay or cancel them .\\n\\n# OKAY I SEE THEY\\'RE IMPORTANT , BUT  WHERE MIGHT I USE THEM ?\\uD83E\\uDD14\\n\\nThey\\'re heavily used in scenarios such as :\\n- Animation\\n- Event Handling\\n- Scheduling\\n- Async Proggramming \\n\\n\\n# OTHER QUESTION YOU MIGHT BE ASKING : \\nHUM .... I THOUGHT I UNDERSTOOD THEM TURNS OUT I ONLY KNOW THE SYNTAX \\n\\nThat is alright , I will explain them fully don\\'t worry ! \\nLet\\'s start with the **setTimeout** Method :\\n\\n- The function takes two parameters: a callback function and a delay value in milliseconds. The callback function represents the code we want to execute after the delay.\\n- When we call setTimeout, it registers the callback function and starts a timer. After the specified delay, the JavaScript engine adds the callback function to the event queue.\\n-  In case you don\\'t know what an event Queue is , the event queue is a data structure that holds tasks to be processed by the JavaScript runtime. When the call stack is empty (all synchronous code has finished executing), the runtime picks the next task from the event queue and executes it.\\n- By using setTimeout, we introduce an asynchronous behavior in our code. This means that while the delay is counting down, the JavaScript engine can continue executing other code without waiting for the setTimeout callback to be invoked AND THIS IS REALLY IMPORTANT .\\n\\n# BUT WHY DID WE USE CLEARTIMEOUT ?\\n\\nWell , we need clearTimeout to cancel the scheduled execution before the delay expires.\\nWe already know that setTimeout returns a unique identifier called a timeout ID , right ????\\n\\nWell , clearTimeout is another built-in function that cancels a timeout previously set with setTimeout. By passing the timeout ID to clearTimeout, we  prevent the execution of the callback function and stop the timer .\\n\\n# Still not convinced ? Let\\'s ask ourselves what would happen if we didn\\'t use clearTimeout in our code ?!!\\n\\nUsing clearTimeout in conjunction with setTimeout provides us with the ability to control the execution of a scheduled function. When we set a timeout using setTimeout, the function inside it will run after the specified delay. However, by using clearTimeout, we can cancel the scheduled function before it runs which is what we want here .\\n\\n**In simpler terms, clearTimeout allows you to say, \"Hey, hold on! Don\\'t run that function yet!\" It gives you the ability to pause or cancel the scheduled execution, providing a smoother and more responsive user experience in situations where dynamic control is required.**\\n\\n# CONCLUSION :\\n Without clearTimeout, you wouldn\\'t have the option to stop or cancel the execution of a scheduled function. It would always run regardless of any subsequent logic or conditions. By using clearTimeout, you have the power to manage and adjust the timing of your code, ensuring it behaves exactly as you need it to.\\n\\n\\n\\n# Approach\\n- The code defines a function named \"cancellable\" that takes three parameters: \"fn\" (a function), \"args\" (an array of arguments), and \"t\" (a time delay in milliseconds).\\n- Inside the \"cancellable\" function, a nested function named \"cancelFn\" is defined. This function is responsible for canceling the execution of the scheduled function.\\n- The \"cancelFn\" function calls clearTimeout with the timer identifier to cancel the scheduled function execution.\\n- The setTimeout function is used to schedule the execution of a function, which is passed as the first parameter, after the specified time delay (t).\\n- The setTimeout function returns a timer identifier, which is stored in the \"timer\" variable.\\n- The scheduled function (fn) is executed using the spread operator (...args) to pass the arguments array to the function.\\n- Finally, the \"cancelFn\" function is returned from the \"cancellable\" function, allowing you to call it later to cancel the scheduled function if needed.\\n\\n# A beginner Level  Question you might be asking : why did you define cancelFn t the top ? \\nWell , The purpose of defining the \"cancelFn\" function at the top is to ensure that it is accessible within the scope of the \"cancellable\" function. This allows us to return the \"cancelFn\" function as part of the function\\'s result, making it available for later use outside of the \"cancellable\" function. It\\'s always a good practice to define functions at the top\\n\\n# FINAL CONCLUSION : \\n\\nThe concept of using clearTimeout and setTimeout provides a powerful mechanism for scheduling and canceling the execution of functions in JavaScript. By utilizing clearTimeout, you can prevent the scheduled function from running when it is no longer needed, allowing for more control and flexibility in managing asynchronous tasks. This concept is especially useful in scenarios where you want to delay the execution of code or schedule tasks to be performed in the future. Understanding and utilizing clearTimeout and setTimeout effectively can greatly enhance the efficiency and responsiveness of your JavaScript programs.\\n\\n**NOW THAT\\'S IT HOPE YOU ENJOYED MY EXPLANATION , CHECK OUT THE OTHER SOLUTION FOR THE NEXT PROBLEM (**Interval Cnacellation**) they\\'re both similar problems with slight difference tho \\uD83E\\uDD14\\uD83D\\uDE0A**\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = function(fn, args, t) {\\n    // cancelFn function//\\n    const cancelFn = function (){\\n      clearTimeout(timer);\\n  };\\n  const timer = setTimeout(()=>{\\n      fn(...args)\\n  }, t);\\n  return cancelFn ;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = function(fn, args, t) {\\n    // cancelFn function//\\n    const cancelFn = function (){\\n      clearTimeout(timer);\\n  };\\n  const timer = setTimeout(()=>{\\n      fn(...args)\\n  }, t);\\n  return cancelFn ;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3620608,
                "title": "full-thorough-explanation-simple-beginner-friendly",
                "content": "# Approach\\nThis problem can be a bit confusing, as simple as the solution code is, so I will convey the problem in a step-by-step concrete manner. The following example is how ```cancellable``` works:\\n\\nLet\\'s say we want to execute a function ```foo``` defined as follows:\\n```\\nfunction foo(message) {\\n    console.log(\"If you see this message, I wasn\\'t cancelled!!!\");\\n    console.log(\"I want to tell the world this:\");\\n    console.log(message);\\n}\\n```\\nHowever, we want ```foo``` to be cancellable within the next 1000 milliseconds. And so, we call ```foo``` with ```var myMsg = cancellable(foo, \"pineapple\", 1000);```\\n\\nOnce ```myMsg``` is defined, it will take 1000 milliseconds to execute ```foo```. However, if ```myMsg``` is ever called before 1000 milliseconds, ```foo``` will be cancelled. Aka, if we do ```myMsg()``` 1000 milliseconds after we defined ```myMsg```, then ```foo``` will not execute.\\n\\u2014\\nThe above is an example of ```cancellable``` in action. Now, to discuss how to implement it.\\n\\nFirst, let\\'s set a timeout. We can do this as one normally would:\\n```\\nvar timeout = setTimeout(() =>\\n    fn(...args)\\n, t)\\n```\\nNow the timeout is running. After this, let\\'s define a way to clear this timeout.\\n```\\nvar cancelFn = () => clearTimeout(timeout);\\n```\\nNote, unlike ```timeout```, we did not execute ```cancelFn```. This is due to the fact that ```timeout``` is calling a function (the right side is formatted as ```function(somestuff)```), whereas ```cancelFn``` is simply the definition of a function (the right side is formatted as ```() => function(somestuff)```). If we instead wrote ```var cancelFn = clearTimeout(timeout)```, we would always cancel right after we start the timeout, and always fail to execute the function.\\n\\nFinally, let\\'s have ```cancellable``` return ```cancelFn```. The reasoning behind this is as follows. We defined ```cancelFn```, but we need to be able to call it. By making ```cancellable``` return ```cancelFn```, the return line calls ```cancelFn```, which will cause ```cancelFn``` to execute (aka, it will cancel ```timeout```). And so, when we call cancellable, we execute the return line, thereby executing ```cancelFn```. Using the ```myMsg``` example above as demonstration, when we call ```myMsg()```, we return ```cancelFn```, which means we execute ```cancelFn```, thereby clearing ```timeout``` and cancelling ```foo```.\\n\\nAnd there you have it, a cancellable function!\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    // call setTimeout, which is set to call fn after t amount of time\\n    var timeout = setTimeout(() =>\\n        fn(...args)\\n    , t)\\n\\n    // define a clearTimeout\\n    var cancelFn = () => clearTimeout(timeout);\\n\\n    // When/if we call the function, it will return cancelFn,\\n    // and since the return line calls (and consequentially executes)\\n    // cancelFn, timeout will be cancelled, thereby cancelling fn\\n    return cancelFn;\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript",
                    "Design"
                ],
                "code": "```cancellable```\n```foo```\n```\\nfunction foo(message) {\\n    console.log(\"If you see this message, I wasn\\'t cancelled!!!\");\\n    console.log(\"I want to tell the world this:\");\\n    console.log(message);\\n}\\n```\n```foo```\n```foo```\n```var myMsg = cancellable(foo, \"pineapple\", 1000);```\n```myMsg```\n```foo```\n```myMsg```\n```foo```\n```myMsg()```\n```myMsg```\n```foo```\n```cancellable```\n```\\nvar timeout = setTimeout(() =>\\n    fn(...args)\\n, t)\\n```\n```\\nvar cancelFn = () => clearTimeout(timeout);\\n```\n```timeout```\n```cancelFn```\n```timeout```\n```function(somestuff)```\n```cancelFn```\n```() => function(somestuff)```\n```var cancelFn = clearTimeout(timeout)```\n```cancellable```\n```cancelFn```\n```cancelFn```\n```cancellable```\n```cancelFn```\n```cancelFn```\n```cancelFn```\n```timeout```\n```cancelFn```\n```myMsg```\n```myMsg()```\n```cancelFn```\n```cancelFn```\n```timeout```\n```foo```\n```\\nvar cancellable = function(fn, args, t) {\\n    // call setTimeout, which is set to call fn after t amount of time\\n    var timeout = setTimeout(() =>\\n        fn(...args)\\n    , t)\\n\\n    // define a clearTimeout\\n    var cancelFn = () => clearTimeout(timeout);\\n\\n    // When/if we call the function, it will return cancelFn,\\n    // and since the return line calls (and consequentially executes)\\n    // cancelFn, timeout will be cancelled, thereby cancelling fn\\n    return cancelFn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587129,
                "title": "simple-implementation",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  var timeoutId = setTimeout(function() {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  var cancelFn = function() {\\n    clearTimeout(timeoutId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  var timeoutId = setTimeout(function() {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  var cancelFn = function() {\\n    clearTimeout(timeoutId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587201,
                "title": "js-settimeout-cleartimeout-2-lines",
                "content": "# Intuition\\nsetTimeout for fn execution for given time t, return function that executes clearTimeout when called\\n\\n# Code\\n```\\nconst cancellable = function(fn, args, t) {\\n    const timeoutHandle = setTimeout(() => fn(...args), t)    \\n    return () => clearTimeout(timeoutHandle)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = function(fn, args, t) {\\n    const timeoutHandle = setTimeout(() => fn(...args), t)    \\n    return () => clearTimeout(timeoutHandle)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590547,
                "title": "ts-boolean-flag-75ms-43-2mb",
                "content": "This problem requires little more than following the instructions, so we will:\\n* create a boolean flag `willFnCall` initially set to `true`;\\n* set a timeout in `t` milliseconds to call `fn` with `args`, but only if `willFnCall` is still `true`;\\n* `return` a function that sets the flag to `false` when called.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nconst cancellable = (fn: Function, args: any[], t: number): Function => {\\n    let willFnCall = true;\\n    setTimeout(() => willFnCall && fn(...args), t);\\n    return () => willFnCall = false;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nconst cancellable = (fn: Function, args: any[], t: number): Function => {\\n    let willFnCall = true;\\n    setTimeout(() => willFnCall && fn(...args), t);\\n    return () => willFnCall = false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587568,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeoutId;\\n\\n  const cancelFn = () =>  clearTimeout(timeoutId);\\n\\n  timeoutId = setTimeout(() => fn(...args), t);\\n\\n  return cancelFn;  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeoutId;\\n\\n  const cancelFn = () =>  clearTimeout(timeoutId);\\n\\n  timeoutId = setTimeout(() => fn(...args), t);\\n\\n  return cancelFn;  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3639241,
                "title": "simple-solution-with-walk-through",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The cancellable function takes three parameters: `fn`, `args`, and `t`.\\n\\n2. `fn` is the function to be executed after a delay.\\n`args` is an array of arguments to be passed to the function `fn`.\\n`t` is the delay in milliseconds.\\nInside the `cancellable` function, a variable `cancel` is initialized to false. This variable will be used to determine if the execution of the delayed function should be canceled.\\n\\n3. The `setTimeout` function is called with an arrow function as the callback. This arrow function checks the value of `cancel` and executes the function fn with the provided arguments `...args` only if `cancel` is false. The timeout value is set to `t` milliseconds.\\n\\n4. The `setTimeout` function schedules the execution of the arrow function after the specified delay.\\n\\n5. Finally, the `cancellable` function returns another function. This returned function is used to cancel the execution of the delayed function.\\n    When the returned function is invoked, it sets `cancel` to true, effectively canceling the execution of `fn` if it hasn\\'t occurred yet.\\n\\n# Complexity\\n- Time complexity:\\nO(max(t,cancelT))\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027030,
                "title": "easy-js-solution-no-explanation-required-clean-code",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(()=>{\\n        fn(...args);\\n    },t)\\n    return cancel=()=>{\\n        clearTimeout(timeout);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(()=>{\\n        fn(...args);\\n    },t)\\n    return cancel=()=>{\\n        clearTimeout(timeout);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974411,
                "title": "easy-approach-towards-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis requires clearTimeout funtion which cancels a timeout previously established by calling setTimeout().\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst to make a timer for function execution for time t and cancelFn function for cancelling that timeout event. \\nconst cancel = cancellable(log, args, t);\\nand cancel would get cancelfn function returned from cancellable. \\n         \\n  setTimeout(() => {     cancel()\\n  }, cancelT)\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\n\\nvar cancellable = function(fn, args, t) {\\n  const timer = setTimeout(()=> {\\n    fn(...args);\\n  }, t);\\n\\n  const cancelFn = function(){\\n    clearTimeout(timer);\\n  }\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\n\\nvar cancellable = function(fn, args, t) {\\n  const timer = setTimeout(()=> {\\n    fn(...args);\\n  }, t);\\n\\n  const cancelFn = function(){\\n    clearTimeout(timer);\\n  }\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907338,
                "title": "simple-solution-2-liner",
                "content": "\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902413,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeoutId = setTimeout(function() {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  const cancelFn = function() {\\n    clearTimeout(timeoutId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeoutId = setTimeout(function() {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  const cancelFn = function() {\\n    clearTimeout(timeoutId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677243,
                "title": "js-easy-use-of-settimeout-cleartimeout",
                "content": "```javascript\\nvar cancellable = function(fn, args, t) {    \\n    let timerId = setTimeout(fn, t, ...args);\\n    let cancelFn = () => clearTimeout(timerId);\\n\\n    return cancelFn;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar cancellable = function(fn, args, t) {    \\n    let timerId = setTimeout(fn, t, ...args);\\n    let cancelFn = () => clearTimeout(timerId);\\n\\n    return cancelFn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587429,
                "title": "1-liner",
                "content": "```js\\nconst cancellable =\\n    (f, a, t, c = setTimeout(f, t, ...a)) => () => clearTimeout(c)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst cancellable =\\n    (f, a, t, c = setTimeout(f, t, ...a)) => () => clearTimeout(c)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101203,
                "title": "promise-closure-50ms-beats-96-51-42-46mb",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nlet cfn = true\\n\\n const promise = new Promise((resolve,reject)=>{\\n    setTimeout(()=>{\\n        if(cfn){\\n                fn(...args)\\n            resolve\\n        }else{\\n            reject\\n        }\\n    }, t);\\n  });\\n\\n\\nreturn function cancelFn(){\\n    cfn = false\\n}\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nlet cfn = true\\n\\n const promise = new Promise((resolve,reject)=>{\\n    setTimeout(()=>{\\n        if(cfn){\\n                fn(...args)\\n            resolve\\n        }else{\\n            reject\\n        }\\n    }, t);\\n  });\\n\\n\\nreturn function cancelFn(){\\n    cfn = false\\n}\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101194,
                "title": "promise-closure-50ms-beats-96-51-42-46mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nlet cfn = true\\n\\n const promise = new Promise((resolve,reject)=>{\\n    setTimeout(()=>{\\n        if(cfn){\\n                fn(...args)\\n            resolve\\n        }else{\\n            reject\\n        }\\n    }, t);\\n  });\\n\\n\\nreturn function cancelFn(){\\n    cfn = false\\n}\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nlet cfn = true\\n\\n const promise = new Promise((resolve,reject)=>{\\n    setTimeout(()=>{\\n        if(cfn){\\n                fn(...args)\\n            resolve\\n        }else{\\n            reject\\n        }\\n    }, t);\\n  });\\n\\n\\nreturn function cancelFn(){\\n    cfn = false\\n}\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089333,
                "title": "timeout-cancellation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerID=setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n    const cancelFn=()=>{\\n         clearTimeout(timerID)\\n    }\\n    return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerID=setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n    const cancelFn=()=>{\\n         clearTimeout(timerID)\\n    }\\n    return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085956,
                "title": "timeout-cancellation-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n      let isCancelled = true;\\n  setTimeout(() => {\\n      if(isCancelled)\\n          fn(...args);\\n  }, t);\\n\\n  return () => {\\n    isCancelled = false;\\n  };\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n      let isCancelled = true;\\n  setTimeout(() => {\\n      if(isCancelled)\\n          fn(...args);\\n  }, t);\\n\\n  return () => {\\n    isCancelled = false;\\n  };\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080810,
                "title": "cancel-response",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n \\n      let timeoutId;\\n      timeoutId = setTimeout(() => {\\n            fn(...args);\\n        }, t);\\n\\n    const cancelFn = () => {\\n        clearTimeout(timeoutId);\\n    };\\n  \\n    return cancelFn;\\n};\\n\\n   const result = []\\n \\n   const fn = (x) => x * 5\\n   const args = [2], t = 20, cancelT = 50\\n \\n   const start = performance.now() \\n \\n   const log = (...argsArr) => {\\n       const diff = Math.floor(performance.now() - start);\\n       result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n   }\\n        \\n   const cancel = cancellable(log, args, t);\\n \\n   const maxT = Math.max(t, cancelT)\\n           \\n   setTimeout(() => {\\n      cancel()\\n   }, cancelT)\\n \\n   setTimeout(() => {\\n      console.log(result) // [{\"time\":20,\"returned\":10}]\\n  }, maxT + 15)\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n \\n      let timeoutId;\\n      timeoutId = setTimeout(() => {\\n            fn(...args);\\n        }, t);\\n\\n    const cancelFn = () => {\\n        clearTimeout(timeoutId);\\n    };\\n  \\n    return cancelFn;\\n};\\n\\n   const result = []\\n \\n   const fn = (x) => x * 5\\n   const args = [2], t = 20, cancelT = 50\\n \\n   const start = performance.now() \\n \\n   const log = (...argsArr) => {\\n       const diff = Math.floor(performance.now() - start);\\n       result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n   }\\n        \\n   const cancel = cancellable(log, args, t);\\n \\n   const maxT = Math.max(t, cancelT)\\n           \\n   setTimeout(() => {\\n      cancel()\\n   }, cancelT)\\n \\n   setTimeout(() => {\\n      console.log(result) // [{\"time\":20,\"returned\":10}]\\n  }, maxT + 15)\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078986,
                "title": "simple-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Fn = (...args: JSONValue[]) => void\\n\\nfunction cancellable(fn: Fn, args: JSONValue[], t: number): Function {\\n    let timer = setTimeout(fn, t, ...args)\\n    return () => clearTimeout(timer)\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Fn = (...args: JSONValue[]) => void\\n\\nfunction cancellable(fn: Fn, args: JSONValue[], t: number): Function {\\n    let timer = setTimeout(fn, t, ...args)\\n    return () => clearTimeout(timer)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075333,
                "title": "2715-timeout-cancellation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const calculationTimer = setTimeout(() => fn(...args), t);\\n\\n    return () => clearTimeout(calculationTimer);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const calculationTimer = setTimeout(() => fn(...args), t);\\n\\n    return () => clearTimeout(calculationTimer);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074729,
                "title": "very-beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let cancelled = false;\\n\\n    const timer = setTimeout(() => {\\n        if (!cancelled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    const cancel = () => {\\n        cancelled = true;\\n        clearTimeout(timer);\\n    };\\n\\n    return cancel;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let cancelled = false;\\n\\n    const timer = setTimeout(() => {\\n        if (!cancelled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    const cancel = () => {\\n        cancelled = true;\\n        clearTimeout(timer);\\n    };\\n\\n    return cancel;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048692,
                "title": "js-ts-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Fn = (...args: JSONValue[]) => void\\n\\nconst cancellable = (fn: Fn, args: JSONValue[], t: number): Function => {\\n    const id = setTimeout(() => {\\n        fn(...args);\\n    }, t)\\n    return () => {\\n        clearTimeout(id);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Fn = (...args: JSONValue[]) => void\\n\\nconst cancellable = (fn: Fn, args: JSONValue[], t: number): Function => {\\n    const id = setTimeout(() => {\\n        fn(...args);\\n    }, t)\\n    return () => {\\n        clearTimeout(id);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046010,
                "title": "simple-solution-in-typescript-using-id-that-is-cached",
                "content": "\\n# Approach\\nLet\\'s just use build-in async API provided by javascript\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const id = setTimeout(() => {\\n        fn(...args);\\n    }, t)\\n\\n    return () => {\\n        clearTimeout(id);\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const id = setTimeout(() => {\\n        fn(...args);\\n    }, t)\\n\\n    return () => {\\n        clearTimeout(id);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043111,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(()=>{\\n        fn(...args);\\n    }, t);\\n    return () => {\\n        clearTimeout(timer);\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(()=>{\\n        fn(...args);\\n    }, t);\\n    return () => {\\n        clearTimeout(timer);\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038667,
                "title": "easy-to-understand-solution",
                "content": "```\\nvar cancellable = function(fn, args, t) {\\n  let ignore = false;\\n\\n  setTimeout(() => {\\n    if (!ignore) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  return function cancelT() {\\n    ignore = true;\\n  }; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n  let ignore = false;\\n\\n  setTimeout(() => {\\n    if (!ignore) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  return function cancelT() {\\n    ignore = true;\\n  }; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4031022,
                "title": "d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nconst cancelFn = ()=>{clearTimeout(pop)}\\nconst pop = setTimeout(()=>{\\nreturn fn(...args)\\n},t)\\nreturn cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nconst cancelFn = ()=>{clearTimeout(pop)}\\nconst pop = setTimeout(()=>{\\nreturn fn(...args)\\n},t)\\nreturn cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030863,
                "title": "simple-solution-with-explanation",
                "content": "# Intuition\\nThe idea of this problem is not to make the call `fn(...args)` if `cancelFn` is called prior to the time passed as the parameter which is `t`. \\n\\n# Approach\\nEvrerytime clearTimeout is called, it cancels the preiviously established `setTiemout` which in this case is saved as id variable. So, if id is found the time `cancelFn` is called, just cancel the preiviously established `setTiemout`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let id = setTimeout(() => fn(...args), t)\\n    \\n    return function cancelFn(){\\n        if(id) clearTimeout(id);\\n    }\\n    };\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let id = setTimeout(() => fn(...args), t)\\n    \\n    return function cancelFn(){\\n        if(id) clearTimeout(id);\\n    }\\n    };\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018481,
                "title": "with-explanation-easy-understanding",
                "content": "# Explanation\\n1. It sets a timer to run fn after t milliseconds.\\n2. If you decide to cancel, call the provided cancellation function (cancelFn) before the timer expires.\\n3. If cancelFn is called, the execution of fn is stopped.\\n4. If not canceled, fn runs as scheduled after the delay.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let isCancelled = false;\\n\\n    // Define the cancellation function\\n    const cancelFn = function() {\\n        isCancelled = true;\\n    };\\n\\n    // Set a timeout to call the original function after t milliseconds\\n    const timeoutId = setTimeout(function() {\\n        if (!isCancelled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    // Return the cancellation function\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let isCancelled = false;\\n\\n    // Define the cancellation function\\n    const cancelFn = function() {\\n        isCancelled = true;\\n    };\\n\\n    // Set a timeout to call the original function after t milliseconds\\n    const timeoutId = setTimeout(function() {\\n        if (!isCancelled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    // Return the cancellation function\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007198,
                "title": "timeout-cancellation",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    var cleartime = setTimeout(() => fn(...args),t);\\n    var cancelFn = () =>  clearTimeout(cleartime);\\n    \\n    return cancelFn;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    var cleartime = setTimeout(() => fn(...args),t);\\n    var cancelFn = () =>  clearTimeout(cleartime);\\n    \\n    return cancelFn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974112,
                "title": "easy-to-follow-solution-step-by-step",
                "content": "# Intuition\\nThe exercice is telling we receieve a function that will run in t miliseconds, and will return another function capable of stopping the execution of the original function, this implies with need to use `setTimeout` to set the delay and using `clearTimeout` to have the possibility of stopping the function execution.\\n\\n# Approach\\n\\nI create a `timeoutId` to save the `setTimeout` and be able to clear it later.\\n\\nThen I created a new promise and using `setTimeout` we will resolve it in `t` miliseconds, in this step we will store the `setTimeout` in the `timeoutId`.\\n\\nThen I created a boolean to track if the function has already been canceled.\\n\\nThen we create the `cancelT` function we will return, inside it we check if the function has already been canceled, if not execute `clearTimeout` and change the `canceled` boolean to true, indicating the function got canceled.\\n\\nThen we call the promise with `then`, we check if `canceled` is false (the function has not been canceled yet), if is not, we print the original function\\'s result.\\n\\nFinally we return the `cancelT` function we defined early.\\n\\n# Complexity\\n## Time complexity:\\n\\n- Creating the tempPromise and scheduling the function call using setTimeout takes O(1) time.\\n\\n- Resolving the tempPromise and invoking the original function takes O(1) time.\\n\\n- The tempPromise.then block runs only once the promise is resolved, and it performs a constant amount of work (console logging) if the cancellation state is not active. Thus, it also takes O(1) time.\\n\\n- The cancelT function, when invoked, cancels the timeout using clearTimeout. This is also a constant-time operation, O(1).\\n\\nSince each step involves constant time operations, the overall time complexity of the cancellable function can be approximated as O(1).\\n\\n## Space complexity:\\nThe main space-consuming factor is the memory required to store the `tempPromise` promise and related structures, which is O(1) in this case.\\n\\nThe other variables like `timeoutId`, `cancelled`, and the arguments passed to the original function are also stored in memory, but they are independent of the input size and are constant in terms of space.\\n\\nHence, they contribute to O(1) space complexity, taking into account all of the above, I conclude that the total space complexity of `cancelable`\\nif O(1) -> constant.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId; // To store the setTimeout ID\\n\\n    // Wait t milliseconds before calling the function\\n    const tempPromise = new Promise((resolve, reject) => {\\n        timeoutId = setTimeout(() => {\\n            resolve(fn(...args));\\n        }, t);\\n    });\\n\\n    // Create a variable to track if the function was canceled\\n    let cancelled = false;\\n\\n    // Return cancel function\\n    const cancelT = () => {\\n        if (!cancelled) {\\n            clearTimeout(timeoutId); // Cancel the timeout\\n            cancelled = true;\\n            console.log(\\'Function call cancelled\\');\\n        }\\n    };\\n\\n    tempPromise.then((result) => {\\n        if (!cancelled) {\\n            console.log(\"result: \", result);\\n        }\\n    });\\n\\n    return cancelT;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId; // To store the setTimeout ID\\n\\n    // Wait t milliseconds before calling the function\\n    const tempPromise = new Promise((resolve, reject) => {\\n        timeoutId = setTimeout(() => {\\n            resolve(fn(...args));\\n        }, t);\\n    });\\n\\n    // Create a variable to track if the function was canceled\\n    let cancelled = false;\\n\\n    // Return cancel function\\n    const cancelT = () => {\\n        if (!cancelled) {\\n            clearTimeout(timeoutId); // Cancel the timeout\\n            cancelled = true;\\n            console.log(\\'Function call cancelled\\');\\n        }\\n    };\\n\\n    tempPromise.then((result) => {\\n        if (!cancelled) {\\n            console.log(\"result: \", result);\\n        }\\n    });\\n\\n    return cancelT;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972953,
                "title": "js-clear-solution",
                "content": "\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{fn(...args)}, t)\\n    return function(cancelT) {\\n        setTimeout(()=>{clearTimeout(timeout)}, cancelT);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{fn(...args)}, t)\\n    return function(cancelT) {\\n        setTimeout(()=>{clearTimeout(timeout)}, cancelT);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947737,
                "title": "implementation-of-cancellable-function-with-timer-and-cancellation",
                "content": "# Intuition\\nThe problem requires setting up a mechanism to execute a function after a certain delay *t*, unless a cancellation function is invoked before another delay **cancelT**. This involves managing timers, function execution, and cancellation states.\\n\\n# Approach\\n1. **Defining the Cancellable Function**: The main function, cancellable, will take the input parameters fn, args, and t. It will create a timer to execute the function fn after t milliseconds unless cancelled.\\n2. **Execution Timer**: The function will set up an executionTimer using setTimeout. This timer will execute the function fn with the provided args after a delay of t milliseconds. Inside the callback of the timer, we will check if the cancellation flag is not set (cancelled is false). If it\\'s not cancelled, we will execute the function and log the result.\\n3. **Cancellation Function**: The cancellable function will return a function called cancelFn. When cancelFn is invoked, it will set the cancelled flag to true to indicate cancellation. It will also clear the executionTimer using clearTimeout, preventing the function from being executed.\\n\\n# Complexity\\n- **Time Complexity**: The execution of the cancellable function involves setting up a setTimeout timer, which takes constant time. Executing the function fn also takes constant time. Therefore, the time complexity is constant, i.e., O(1).\\n- **Space Complexity**: The space required for this implementation is minimal. We have a few variables (cancelled, executionTimer, etc.), but they do not depend on the input size. Thus, the space complexity is also constant, i.e., O(1).\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancelled = false;\\n\\n  const executionTimer = setTimeout(() => {\\n    if (!cancelled) {\\n      const result = fn(...args);\\n      console.log(`fn(${args.join(\\',\\')}) called at t=${t}ms`);\\n      console.log(`Returned: ${result}`);\\n    }\\n  }, t);\\n\\n  return function cancelFn() {\\n    cancelled = true;\\n    clearTimeout(executionTimer);\\n    console.log(`Cancellation called at t=${t}ms`);\\n  };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancelled = false;\\n\\n  const executionTimer = setTimeout(() => {\\n    if (!cancelled) {\\n      const result = fn(...args);\\n      console.log(`fn(${args.join(\\',\\')}) called at t=${t}ms`);\\n      console.log(`Returned: ${result}`);\\n    }\\n  }, t);\\n\\n  return function cancelFn() {\\n    cancelled = true;\\n    clearTimeout(executionTimer);\\n    console.log(`Cancellation called at t=${t}ms`);\\n  };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938301,
                "title": "typescript-shortest-solution",
                "content": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const ref = setTimeout( fn, t, ...args );\\n    return ( cancelT: number ) => setTimeout( clearTimeout, cancelT, ref );\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const ref = setTimeout( fn, t, ...args );\\n    return ( cancelT: number ) => setTimeout( clearTimeout, cancelT, ref );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935859,
                "title": "timeout-cancellation",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeoutId = setTimeout(function(){\\n    fn(...args);\\n  },t)\\n\\n  const cancelFn = function(){\\n    clearTimeout(timeoutId)\\n  }\\n   \\n  return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeoutId = setTimeout(function(){\\n    fn(...args);\\n  },t)\\n\\n  const cancelFn = function(){\\n    clearTimeout(timeoutId)\\n  }\\n   \\n  return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925413,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function (fn, args, t) {\\n    var timeout = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timeout);\\n};\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *\\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function (fn, args, t) {\\n    var timeout = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timeout);\\n};\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *\\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910645,
                "title": "beats-71-52-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeout=setTimeout(()=>{ \\n  fn(...args);\\n  },t)\\n  return ()=>clearTimeout(timeout);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeout=setTimeout(()=>{ \\n  fn(...args);\\n  },t)\\n  return ()=>clearTimeout(timeout);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909783,
                "title": "easy-use-of-settimeout-cleartimeout-js-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {    \\n    let timerId = setTimeout(fn, t, ...args);\\n    let cancelFn = () => clearTimeout(timerId);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {    \\n    let timerId = setTimeout(fn, t, ...args);\\n    let cancelFn = () => clearTimeout(timerId);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909396,
                "title": "javascript-solution-2-lines-super-easy-to-understand",
                "content": "```javascript\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeout);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeout);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891979,
                "title": "js-solution-runtime-65-ms-beats-71-45",
                "content": "# Code\\n```\\n\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n\\n    return () =>clearTimeout(timeout)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n\\n    return () =>clearTimeout(timeout)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891346,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    // create a variable to store the timeout id\\n  var timeoutId = null;\\n  // create a variable to store the cancellation flag\\n  var cancelled = false;\\n  // create a function to cancel the execution of fn\\n  var cancelFn = function() {\\n    // set the cancellation flag to true\\n    cancelled = true;\\n    // clear the timeout if it exists\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n    }\\n  };\\n  // set a timeout to execute fn after t milliseconds\\n  timeoutId = setTimeout(function() {\\n    // check if the cancellation flag is false\\n    if (!cancelled) {\\n      // call fn with args as parameters\\n      fn(...args);\\n    }\\n  }, t);\\n  // return the cancel function\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    // create a variable to store the timeout id\\n  var timeoutId = null;\\n  // create a variable to store the cancellation flag\\n  var cancelled = false;\\n  // create a function to cancel the execution of fn\\n  var cancelFn = function() {\\n    // set the cancellation flag to true\\n    cancelled = true;\\n    // clear the timeout if it exists\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n    }\\n  };\\n  // set a timeout to execute fn after t milliseconds\\n  timeoutId = setTimeout(function() {\\n    // check if the cancellation flag is false\\n    if (!cancelled) {\\n      // call fn with args as parameters\\n      fn(...args);\\n    }\\n  }, t);\\n  // return the cancel function\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3882379,
                "title": "easy-to-understand-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use a flag variable to track whether the timer has been canceled. If the timer has been canceled, the flag variable will be set to false and the timer will be cleared. This will prevent the fn function from being called.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to first create a flag variable. The flag variable is used to track whether the timer has been canceled.\\n\\nThe cancelFn function is then used to cancel the timer. If the cancelFn function is called before the timer fires, the flag variable will be set to false and the timer will be cleared. This will prevent the fn function from being called.\\n\\nThe setTimeout() function is then used to create a timer object. The timer object is set to fire after t milliseconds. When the timer fires, the fn function is called with the args passed as parameters.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(1). This is because the solution only needs to create a flag variable and a timer object.\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1). This is because the solution only needs to store the flag variable and the timer object.\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    var flag=true;\\n    var cancelFn = (cancelT)=>{\\n        if(flag)clearTimeout(flag);\\n    };\\n    flag = setTimeout(()=>{\\n        fn(...args);\\n    },t);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    var flag=true;\\n    var cancelFn = (cancelT)=>{\\n        if(flag)clearTimeout(flag);\\n    };\\n    flag = setTimeout(()=>{\\n        fn(...args);\\n    },t);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876283,
                "title": "accepted-javascript",
                "content": "```\\nvar cancellable = function(fn, args, t) {\\n    var cancel = false;\\n\\n    function call() {\\n        if (!cancel) {\\n            fn(...args);\\n        }\\n    }\\n\\n    setTimeout(call, t);\\n    \\n    return function() {\\n        cancel = true;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    var cancel = false;\\n\\n    function call() {\\n        if (!cancel) {\\n            fn(...args);\\n        }\\n    }\\n\\n    setTimeout(call, t);\\n    \\n    return function() {\\n        cancel = true;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872542,
                "title": "2-lines-of-code-beats-96-40-simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\n# Approach\\nTo understand the solution, it is important to grasp the entire execution process, not just the function itself.\\n\\nLet\\'s break down what happens when we call the cancellable() function:\\n\\n**1.** First, we **use setTimeout() to set a delay** for the execution of fn() and store the timeout ID in the timeoutId variable.\\n\\n`  let timeoutId = setTimeout(() => fn(...args), t);`\\n\\n**2.** Next, we **return a function** that clears the same timeout.\\n\\n`return () => clearTimeout(timeoutId);`\\n\\n**3.** Now, let\\'s focus on how we call the cancellable function:\\n\\n` const cancel = cancellable(log, args, t);`\\n\\nWe call the cancellable function, which initializes the setTimeout for fn. However, ****the returned function, which wraps the clearTimeout, is not executed immediately****. Instead, we save it in the variable cancel. This allows the fn() to keep executing after a specific period t.\\n\\n**4.** As time progresses, fn() will continue to execute after a specific time period defined by t. **Until the cancelT time delay is not reached, the fn() execution will continue based on its own delay t**. But once the cancelT time has reached, the cancel function will stop the execution by clearing the setTimeout.\\n\\n```\\n setTimeout(() => {\\n    cancel()\\n }, cancelT)\\n```\\n\\n**5.** The cancel function is able to **access the timeoutId due to closure**. When a function is defined inside another function, it forms a closure, which allows the inner function (cancel function in this case) to access variables and parameters of the outer function (cancellable function) even after the outer function has finished executing.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = (fn, args, t) => {\\n    let timeoutId = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n setTimeout(() => {\\n    cancel()\\n }, cancelT)\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = (fn, args, t) => {\\n    let timeoutId = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3869453,
                "title": "clear-explanation-with-example",
                "content": "# Code\\n```\\nconst cancellable = function(fn, args, T) {\\n    // This function will only execute after a delay of \\'T\\' ms.\\n    const delayedExecution = setTimeout(() => fn(...args), T);\\n\\n    // Returns a function that cancels the previous delayed fn.\\n    // You can invoke this function with another delayed execution\\n    // so that by the time clearTimeout is executed, \\'fn\\' has  \\n    // potentially finished.\\n    const cancelDelayedExecution = () => clearTimeout(delayedExecution);\\n\\n    return cancelDelayedExecution;\\n};\\n```\\n\\n# Example\\nYou want to provide a API which using openAI\\'s API key, which can be expensive if user keep calling it. You somehow decide to use this strange method to prevent user burn your money.\\n\\n### function provider\\n\\n```\\n// Example usage:\\nconst apiKey = \"your_openai_api_key\";\\nfunction expensiveAPICall(key) {\\n    console.log(`Calling expensive API with key: ${key}`);\\n    // Simulating an API call\\n};\\n\\n// Create a cancellable function for the expensive API call \\n// with a 20-second delay\\nexport const exeAfter20secs = cancellable(\\n    expensiveAPICall, \\n    [apiKey], \\n    20000);\\n```\\n\\n### function user\\n\\n```\\n// User decide to cancel the API call within 10 seconds \\n// and nothing happened!\\nsetTimeout(() => {\\n    expensiveCallwithMinimum20sDelay(); \\n}, 10000);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = function(fn, args, T) {\\n    // This function will only execute after a delay of \\'T\\' ms.\\n    const delayedExecution = setTimeout(() => fn(...args), T);\\n\\n    // Returns a function that cancels the previous delayed fn.\\n    // You can invoke this function with another delayed execution\\n    // so that by the time clearTimeout is executed, \\'fn\\' has  \\n    // potentially finished.\\n    const cancelDelayedExecution = () => clearTimeout(delayedExecution);\\n\\n    return cancelDelayedExecution;\\n};\\n```\n```\\n// Example usage:\\nconst apiKey = \"your_openai_api_key\";\\nfunction expensiveAPICall(key) {\\n    console.log(`Calling expensive API with key: ${key}`);\\n    // Simulating an API call\\n};\\n\\n// Create a cancellable function for the expensive API call \\n// with a 20-second delay\\nexport const exeAfter20secs = cancellable(\\n    expensiveAPICall, \\n    [apiKey], \\n    20000);\\n```\n```\\n// User decide to cancel the API call within 10 seconds \\n// and nothing happened!\\nsetTimeout(() => {\\n    expensiveCallwithMinimum20sDelay(); \\n}, 10000);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845180,
                "title": "js-closure",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const id = setTimeout(() => fn(...args), t);\\n    return function cancelFn() {\\n        clearTimeout(id);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const id = setTimeout(() => fn(...args), t);\\n    return function cancelFn() {\\n        clearTimeout(id);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835501,
                "title": "execute-cancellable-function-with-delay-javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const cancelFn = setTimeout(()=>fn(...args), t);\\n  return () => clearTimeout(cancelFn);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Design"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const cancelFn = setTimeout(()=>fn(...args), t);\\n  return () => clearTimeout(cancelFn);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831129,
                "title": "simple-solution-cleartimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeout = setTimeout(fn, t, ...args);\\n\\n  return () => clearTimeout(timeout);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeout = setTimeout(fn, t, ...args);\\n\\n  return () => clearTimeout(timeout);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830837,
                "title": "cleeartimeout-simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(() => {\\n        fn(...args)\\n    }, t)\\n\\n    return () => clearTimeout(timer)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(() => {\\n        fn(...args)\\n    }, t)\\n\\n    return () => clearTimeout(timer)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3818342,
                "title": "execute-cancellable-function-with-delay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let canceled = false;\\n\\n  const cancelFn = function () {\\n    canceled = true;\\n  };\\n\\n  const timeoutId = setTimeout(() => {\\n    if (!canceled) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let canceled = false;\\n\\n  const cancelFn = function () {\\n    canceled = true;\\n  };\\n\\n  const timeoutId = setTimeout(() => {\\n    if (!canceled) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816080,
                "title": "javascript-set-timeout-clear-timeout-easy-solution",
                "content": "\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    const setId = setTimeout(() => fn(...args), t);\\n\\n    return () => clearTimeout(setId)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    const setId = setTimeout(() => fn(...args), t);\\n\\n    return () => clearTimeout(setId)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3815897,
                "title": "fun-code",
                "content": "\\n# Code\\n```\\nconst cancellable = (fn, args, time) => {\\n  let timeOut\\n  timeOut = setTimeout(() => {\\n    fn(...args)\\n  }, time)\\n  return () => {\\n    clearTimeout(timeOut)\\n    return []\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (fn, args, time) => {\\n  let timeOut\\n  timeOut = setTimeout(() => {\\n    fn(...args)\\n  }, time)\\n  return () => {\\n    clearTimeout(timeOut)\\n    return []\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813771,
                "title": "2715-execute-cancellable-function-with-delay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n  let r = setTimeout(() => fn(...args), t)\\n  return function () { clearTimeout(r) }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n  let r = setTimeout(() => fn(...args), t)\\n  return function () { clearTimeout(r) }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813288,
                "title": "easy-cancellable-solution-using-timeoutid",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId;\\n    let isCanceled = false;\\n\\n    const cancelFn = () => {\\n        isCanceled = true;\\n        clearTimeout(timeoutId);\\n    };\\n\\n    timeoutId = setTimeout(() => {\\n        if (!isCanceled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId;\\n    let isCanceled = false;\\n\\n    const cancelFn = () => {\\n        isCanceled = true;\\n        clearTimeout(timeoutId);\\n    };\\n\\n    timeoutId = setTimeout(() => {\\n        if (!isCanceled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810918,
                "title": "javascript-o-1-solution",
                "content": "# Intuition\\nreturn a clearTimeout of a setTimeout\\n\\n# Approach\\n1. Create a setTimeout for the passed arguments.\\n2. Take a reference variable for the timeout.\\n3. Create & return a clearTimeout for the setTimeout.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n  const ref = setTimeout(()=>fn(...args), t);\\n  return () => clearTimeout(ref);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n  const ref = setTimeout(()=>fn(...args), t);\\n  return () => clearTimeout(ref);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784592,
                "title": "2715-execute-cancellable-function-with-delay",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let lock = false;\\n    setTimeout(() => { if(!lock) fn(...args)}, t);\\n    return () => {\\n        lock = true;\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let lock = false;\\n    setTimeout(() => { if(!lock) fn(...args)}, t);\\n    return () => {\\n        lock = true;\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767477,
                "title": "very-tricky-indeed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo be honest, I had to look at other solutions inorder to write this.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem essentially boils down to this implementation.. However \\nit\\'s kind of hard to reach to this thought process ..\\n\\nWrap the fn inside setTimeout that it get\\'s executed after t sec..\\n\\nif cancelFn is executed before fn (cancelTime is less than t), the case when you don\\'t want to execute fn ..do a clear the timer of the execution of fn.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const  timer = setTimeout(() => {\\n        fn(...args);\\n    }, t);\\n\\n    return () => {\\n        clearTimeout(timer);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const  timer = setTimeout(() => {\\n        fn(...args);\\n    }, t);\\n\\n    return () => {\\n        clearTimeout(timer);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757797,
                "title": "ts-very-simple-approach-settimeout-cleartimeout",
                "content": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const timeoutId = setTimeout(()=>{\\n        fn(...args)\\n    },t);\\n\\n    const cancelFn:Function = ()=>{\\n        clearTimeout(timeoutId);\\n    }\\n    return cancelFn;\\n};\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const timeoutId = setTimeout(()=>{\\n        fn(...args)\\n    },t);\\n\\n    const cancelFn:Function = ()=>{\\n        clearTimeout(timeoutId);\\n    }\\n    return cancelFn;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3757796,
                "title": "ts-very-simple-approach-settimeout-cleartimeout",
                "content": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const timeoutId = setTimeout(()=>{\\n        fn(...args)\\n    },t);\\n\\n    const cancelFn:Function = ()=>{\\n        clearTimeout(timeoutId);\\n    }\\n    return cancelFn;\\n};\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const timeoutId = setTimeout(()=>{\\n        fn(...args)\\n    },t);\\n\\n    const cancelFn:Function = ()=>{\\n        clearTimeout(timeoutId);\\n    }\\n    return cancelFn;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3753898,
                "title": "soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => {\\n        fn(...args)\\n    },t)\\n    const cancelFn = () => clearTimeout(timeout);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => {\\n        fn(...args)\\n    },t)\\n    const cancelFn = () => clearTimeout(timeout);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746025,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746024,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745054,
                "title": "solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    const timeOut = setTimeout(() => fn(...args), t)\\n    const delay = () => clearTimeout(timeOut)\\n    return delay;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    const timeOut = setTimeout(() => fn(...args), t)\\n    const delay = () => clearTimeout(timeOut)\\n    return delay;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3741299,
                "title": "short-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timerId)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timerId)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3741298,
                "title": "short-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timerId)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timerId)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733291,
                "title": "simple-approach",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let a=setTimeout(() => {\\n      fn(...args)\\n  }, t)\\n    return function(){\\n        clearTimeout(a);\\n    } \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let a=setTimeout(() => {\\n      fn(...args)\\n  }, t)\\n    return function(){\\n        clearTimeout(a);\\n    } \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732231,
                "title": "easiest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let id1 = setTimeout(fn,t,...args)\\n    return cancelFn = (cancelTime) => {\\n        setTimeout(()=>clearTimeout(id1),cancelTime)\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let id1 = setTimeout(fn,t,...args)\\n    return cancelFn = (cancelTime) => {\\n        setTimeout(()=>clearTimeout(id1),cancelTime)\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721734,
                "title": "easiest-way-to-solve-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function (fn, args, t) {\\n    var timeout = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n\\n    var cancelFn = ()=> clearTimeout(timeout);\\n    return cancelFn\\n        \\n\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function (fn, args, t) {\\n    var timeout = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n\\n    var cancelFn = ()=> clearTimeout(timeout);\\n    return cancelFn\\n        \\n\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695460,
                "title": "two-lines-easy-to-understand-ts-js-solution",
                "content": "\\n# Code\\n``` Javascript []\\nfunction cancellable(fn, args, t){\\n    const id = setTimeout(() => fn(...args),t)\\n    return () => clearTimeout(id)\\n};\\n```\\n\\n``` Typescript []\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const id: ReturnType<typeof setTimeout> = setTimeout(()=>fn(...args),t)\\n    return ()=>clearTimeout(id)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` Javascript []\\nfunction cancellable(fn, args, t){\\n    const id = setTimeout(() => fn(...args),t)\\n    return () => clearTimeout(id)\\n};\\n```\n``` Typescript []\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const id: ReturnType<typeof setTimeout> = setTimeout(()=>fn(...args),t)\\n    return ()=>clearTimeout(id)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694682,
                "title": "simple-settimeout-and-cleartimeout-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => {\\n      fn(...args)\\n    }, t)\\n\\n    return () => clearTimeout(timeout)\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => {\\n      fn(...args)\\n    }, t)\\n\\n    return () => clearTimeout(timeout)\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683367,
                "title": "easy-solution-cancellable-function-with-delay",
                "content": "# Approach\\nTo solve this problem, we can use a combination of **setTimeout** and a **flag variable** to keep track of whether the cancellation function has been called or not.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let canceled = false;\\n\\n  const timer = setTimeout(() => {\\n    if (!canceled) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  const cancelFn = () => {\\n    canceled = true;\\n    clearTimeout(timer);\\n  };\\n\\n  return cancelFn;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let canceled = false;\\n\\n  const timer = setTimeout(() => {\\n    if (!canceled) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  const cancelFn = () => {\\n    canceled = true;\\n    clearTimeout(timer);\\n  };\\n\\n  return cancelFn;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3674049,
                "title": "easiest-to-understand-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeoutHandle = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n    return ()=>clearTimeout(timeoutHandle)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeoutHandle = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n    return ()=>clearTimeout(timeoutHandle)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670282,
                "title": "simple-solution-with-explanation",
                "content": "# Intuition\\nThe `timeout` function returns an `ID` so that we can clear it whenever needed.\\nWe just use this timeout ID to delete the timeout action whenever cancelFn is called.\\n\\n# Approach\\n1. create a setTimeout with the function and arguments given.\\n2. save the timeout ID returned the setTimeout function\\n3. return the requested function `cancelFn`. This function clears the timeout.\\nYou can see an example of timeout and clearTimeout on the official documentation [here](https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout).\\n\\n\\n# Code\\n```\\n\\nvar cancellable = function(fn, args, t) {\\n    const timeoutID = setTimeout(() => fn(...args), t);\\n    return cancelFn = () => clearTimeout(timeoutID);\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\nThe `timeout` function returns an `ID` so that we can clear it whenever needed.\\nWe just use this timeout ID to delete the timeout action whenever cancelFn is called.\\n\\n# Approach\\n1. create a setTimeout with the function and arguments given.\\n2. save the timeout ID returned the setTimeout function\\n3. return the requested function `cancelFn`. This function clears the timeout.\\nYou can see an example of timeout and clearTimeout on the official documentation [here](https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout).\\n\\n\\n# Code\\n```\\n\\nvar cancellable = function(fn, args, t) {\\n    const timeoutID = setTimeout(() => fn(...args), t);\\n    return cancelFn = () => clearTimeout(timeoutID);\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3666649,
                "title": "the-best-and-shortest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(fn, t, ...args);\\n    return () => clearTimeout(timerId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(fn, t, ...args);\\n    return () => clearTimeout(timerId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3660850,
                "title": "very-simple-solution",
                "content": "Inspired by [setTimeout() MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout).\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n  const timeoutID = setTimeout(() => {\\n    fn(...args);\\n  }, t);\\n\\n  return () => {\\n    clearTimeout(timeoutID);\\n  };\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n  const timeoutID = setTimeout(() => {\\n    fn(...args);\\n  }, t);\\n\\n  return () => {\\n    clearTimeout(timeoutID);\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3654573,
                "title": "javascript-soution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeout = setTimeout(()=>{\\n      fn(...args)\\n  }, t);\\n  return ()=>{\\n      clearTimeout(timeout);\\n  }  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeout = setTimeout(()=>{\\n      fn(...args)\\n  }, t);\\n  return ()=>{\\n      clearTimeout(timeout);\\n  }  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3633283,
                "title": "why-this-give-error",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let exe=setTimeout(fn(...args)\\n    ,t);\\n\\n    let cancel=()=>{\\n        clearTimeout(exe);\\n    }\\n\\n    return cancel;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let exe=setTimeout(fn(...args)\\n    ,t);\\n\\n    let cancel=()=>{\\n        clearTimeout(exe);\\n    }\\n\\n    return cancel;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625551,
                "title": "javascript-solution-with-boolean-variable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just need 2 things to solve this question- \\n(1) setTimeout() for giving t ms delay before calling the function fn.\\n(2) a boolean variable which decides whether calling function fn is allowed for not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a boolean variable \\'isCancelled\\' and initialize it with false, ie, the funtion fn is not cancelled initially.\\nThen we use setTimeout() which calls the function fn after t ms delay only if the \\'isCancelled\\' variable is set to false.\\nFrom our cancellable function we are just returning a function which flips our \\'isCancelled\\' boolean variable to true , ie, function fn is never called.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let isCancelled = false;\\n    setTimeout(() => {\\n        if(!isCancelled)\\n            fn(...args);\\n    }, t);\\n    return () => isCancelled = true;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let isCancelled = false;\\n    setTimeout(() => {\\n        if(!isCancelled)\\n            fn(...args);\\n    }, t);\\n    return () => isCancelled = true;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616242,
                "title": "javascript-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar cancellable = function(fn, args, t) {\\n    \\n    let tmot = setTimeout(()=>{ fn(...args); }, t);\\n    return ()=>{ clearTimeout(tmot); }\\n\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar cancellable = function(fn, args, t) {\\n    \\n    let tmot = setTimeout(()=>{ fn(...args); }, t);\\n    return ()=>{ clearTimeout(tmot); }\\n\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611988,
                "title": "javascript-settimeout-cleartimeout-2lines",
                "content": "# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    const timeoutID = setTimeout(fn, t, ...args);\\n    return () => clearTimeout(timeoutID);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    const timeoutID = setTimeout(fn, t, ...args);\\n    return () => clearTimeout(timeoutID);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3603876,
                "title": "simple-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    var t = setTimeout(()=>{fn(...args)},t);\\n    return () => {\\n        clearTimeout(t);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    var t = setTimeout(()=>{fn(...args)},t);\\n    return () => {\\n        clearTimeout(t);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596956,
                "title": "javascript-2-lines",
                "content": "```\\nconst cancellable = (fn, args, t) => {\\n  const timer = setTimeout(() => fn(...args), t);\\n  return () => clearTimeout(timer);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (fn, args, t) => {\\n  const timer = setTimeout(() => fn(...args), t);\\n  return () => clearTimeout(timer);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595669,
                "title": "very-easy-solution-with-cleartimeout",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n   const id = setTimeout(() => {\\n     return fn(...args)\\n   },t)\\n    return function(){\\n      clearTimeout(id)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n   const id = setTimeout(() => {\\n     return fn(...args)\\n   },t)\\n    return function(){\\n      clearTimeout(id)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594328,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{\\n        return fn(...args);\\n    },t);\\n\\n    return () => {\\n        clearTimeout(timeout);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{\\n        return fn(...args);\\n    },t);\\n\\n    return () => {\\n        clearTimeout(timeout);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593116,
                "title": "javascript-beats-100-2-line-code",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const exec = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(exec)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const exec = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(exec)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592885,
                "title": "2-lines-of-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou are supposed to execute `fn` after delay of `t`, and alongwith return a function `cancel`.\\nNow if `cancel` function is called, then stop the timeout of fn.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\nNote: Just put a `setTimeout` before returning the function cancel. and the timeout will resolve into execution of `fn`. and put `clearTimeout` in cancel function.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    timeoutId =  setTimeout(fn, t, ...args);\\n\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    timeoutId =  setTimeout(fn, t, ...args);\\n\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591725,
                "title": "simple-js-solution-using-closures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(() => fn(...args), t);\\n\\n    return () => {\\n        clearTimeout(timer);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(() => fn(...args), t);\\n\\n    return () => {\\n        clearTimeout(timer);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591098,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timerId;\\n    timerId = setTimeout(() => fn(...args), t);\\n    return function(){\\n        clearTimeout(timerId)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timerId;\\n    timerId = setTimeout(() => fn(...args), t);\\n    return function(){\\n        clearTimeout(timerId)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590142,
                "title": "simple-javascript-solution-using-cleartimeout-and-settimeout",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeoutId;\\n\\n  const cancelFn = () =>  clearTimeout(timeoutId);\\n\\n  timeoutId = setTimeout(() => fn(...args), t);\\n\\n  return cancelFn;  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeoutId;\\n\\n  const cancelFn = () =>  clearTimeout(timeoutId);\\n\\n  timeoutId = setTimeout(() => fn(...args), t);\\n\\n  return cancelFn;  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589196,
                "title": "72ms-45mb-short-typescript-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    let tf = setTimeout(() => {\\n        fn(...args);\\n    }, t);\\n    return () => clearTimeout(tf);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    let tf = setTimeout(() => {\\n        fn(...args);\\n    }, t);\\n    return () => clearTimeout(tf);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589074,
                "title": "closure",
                "content": "```\\nvar cancellable = function(fn, args, t) \\n{\\n    let timeout = setTimeout(()=>fn(...args), t);\\n    return ()=>clearTimeout(timeout);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar cancellable = function(fn, args, t) \\n{\\n    let timeout = setTimeout(()=>fn(...args), t);\\n    return ()=>clearTimeout(timeout);\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1913955,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1913840,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1921885,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1975295,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1961560,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1969825,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 2062026,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1986039,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1940498,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1990067,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1913955,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1913840,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1921885,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1975295,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1961560,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1969825,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 2062026,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1986039,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1940498,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1990067,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find a Good Subset of the Matrix",
        "question_content": "<p>You are given a <strong>0-indexed</strong> <code>m x n</code> binary matrix <code>grid</code>.</p>\n\n<p>Let us call a <strong>non-empty</strong> subset of rows <strong>good</strong> if the sum of each column of the subset is at most half of the length of the subset.</p>\n\n<p>More formally, if the length of the chosen subset of rows is <code>k</code>, then the sum of each column should be at most <code>floor(k / 2)</code>.</p>\n\n<p>Return <em>an integer array that contains row indices of a good subset sorted in <strong>ascending</strong> order.</em></p>\n\n<p>If there are multiple good subsets, you can return any of them. If there are no good subsets, return an empty array.</p>\n\n<p>A <strong>subset</strong> of rows of the matrix <code>grid</code> is any matrix that can be obtained by deleting some (possibly none or all) rows from <code>grid</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> We can choose the 0<sup>th</sup> and 1<sup>st</sup> rows to create a good subset of rows.\nThe length of the chosen subset is 2.\n- The sum of the 0<sup>th</sup>&nbsp;column is 0 + 0 = 0, which is at most half of the length of the subset.\n- The sum of the 1<sup>st</sup>&nbsp;column is 1 + 0 = 1, which is at most half of the length of the subset.\n- The sum of the 2<sup>nd</sup>&nbsp;column is 1 + 0 = 1, which is at most half of the length of the subset.\n- The sum of the 3<sup>rd</sup>&nbsp;column is 0 + 1 = 1, which is at most half of the length of the subset.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0]]\n<strong>Output:</strong> [0]\n<strong>Explanation:</strong> We can choose the 0<sup>th</sup> row to create a good subset of rows.\nThe length of the chosen subset is 1.\n- The sum of the 0<sup>th</sup>&nbsp;column is 0, which is at most half of the length of the subset.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,1,1],[1,1,1]]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> It is impossible to choose any subset of rows to create a good subset.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 5</code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3622824,
                "title": "easy-o-n-simple-greedy-with-math-proof",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince each row in the input is small ($n < 5$), we can encode them into a integer. We have at most $2^5$ integers to handle. We call them **values**.\\n\\nA valid subset of **values** can be a single `{0}` or a pair `{a, b}` where `a & b == 0`.\\n\\nIn the sections below we will always consider subset of **values** rather than their indices. It is trivial to get the indices once we figured out the values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe prove that if any valid non empty subset exists then there must be a valid subset of one of the following types:\\n  1. A subset of a single value `{0}`.\\n  1. A subset of two values`{a, b}` where `a & b == 0`\\n\\nWe prove it by contradiction:\\n\\nAssume there is a valid non empty subset $S$ and there is no valid subset of the two above cases.\\n  * If $|S| = 1$, then the single element in it must be 0, which is the type 1 above. Therefore $|S| > 1$\\n  * For two elements $a \\\\in S$ and $b \\\\in S$, if `a & b == 0` then we have a subset `{a, b}` of type 2 above. Therefore any two elements in $S$ must share some bits.\\n\\nNow consider the average number of bits in all the values in $S$. They can be at most 2.5 since $n \\\\le 5$ (`n` is the number of bits involved in this question) and each bit \"column\" has at most half set. This means that we have at least one value $x \\\\in S$ that has at most 2 bits set.\\n  * If $x$ has 0 bit set, that gives us type 1.\\n  * If $x$ has 1 bit set, then all other values in $S$ must have that bit set as well, therefore that bit position will violate the \"half length\" condition.\\n\\nNow $x$ has exactly two bits set. **WLOG** let\\'s say we get `x = 0b00011`.\\nSince any other values in $S$ must share at least a bit with $x$, we have the total bit counts at bit position 0 and 1 to be at least $|S| + 1$ (each number has bit position 0 or 1 set and $x$ has both set). This means one of them will violate the \"half the length\" condition.\\nQ.E.D.\\n\\nNote: As the proof goes, we can see that it is only valid for $n \\\\le 5$. In fact for $n = 6$ we have a counter example:\\n`0 0 0 1 1 1`\\n`1 1 0 1 0 0`\\n`1 0 1 0 1 0`\\n`0 1 1 0 0 1`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$\\\\Theta(N)$ where $N$ is the number of rows.\\n\\nTechnically it is actually $\\\\Theta(N k + 2^{2k})$ where $k$ is the number of columns. We ignored that since our algorithm only works for $k \\\\le 5$ anyway so we treated it as a constant.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$\\\\Theta(2^k)$ where $k$ is the number of columns.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n    // This is actually the $2^k$ we mentioned in above explanation.\\n    // It is NOT the $N$ we mentioned.\\n    const int N = 1 << grid[0].size();\\n    vector<int> first_index(N, -1);\\n    for (int i = grid.size() - 1; i >=0; --i) {\\n      first_index[Encode(grid[i])] = i;\\n    }\\n    if (first_index[0] != -1) {\\n      // We got a 0 row.\\n      return {first_index[0]};\\n    }\\n\\n    for (int a = 1; a < N; ++a) {\\n      if (first_index[a] == -1) continue;\\n      for (int b = a + 1; b < N; ++b) {\\n        if (first_index[b] == -1) continue;\\n        if ((a & b) == 0) {\\n          // We found a valid pair.\\n          int ra = first_index[a];\\n          int rb = first_index[b];\\n          return {min(ra, rb), max(ra, rb)};\\n        }\\n      }\\n    }\\n    return {};\\n  }\\n  \\n  static uint Encode(const vector<int>& row) {\\n    uint x = 0;\\n    for (int i = 0; i < row.size(); ++i) {\\n      if (row[i] == 0) continue;\\n      x |= 1 << i;\\n    }\\n    return x;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n    // This is actually the $2^k$ we mentioned in above explanation.\\n    // It is NOT the $N$ we mentioned.\\n    const int N = 1 << grid[0].size();\\n    vector<int> first_index(N, -1);\\n    for (int i = grid.size() - 1; i >=0; --i) {\\n      first_index[Encode(grid[i])] = i;\\n    }\\n    if (first_index[0] != -1) {\\n      // We got a 0 row.\\n      return {first_index[0]};\\n    }\\n\\n    for (int a = 1; a < N; ++a) {\\n      if (first_index[a] == -1) continue;\\n      for (int b = a + 1; b < N; ++b) {\\n        if (first_index[b] == -1) continue;\\n        if ((a & b) == 0) {\\n          // We found a valid pair.\\n          int ra = first_index[a];\\n          int rb = first_index[b];\\n          return {min(ra, rb), max(ra, rb)};\\n        }\\n      }\\n    }\\n    return {};\\n  }\\n  \\n  static uint Encode(const vector<int>& row) {\\n    uint x = 0;\\n    for (int i = 0; i < row.size(); ++i) {\\n      if (row[i] == 0) continue;\\n      x |= 1 << i;\\n    }\\n    return x;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622708,
                "title": "beginner-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere was only a single thing to crack is that if there exists a subset , there will always exists a subset of size 2 (i.e. only 2 rows) or another case of a single row when whole row is zero.\\n\\n\\nTake an example of a row [1,0]. To make it desired we need another row with 0 at index 0 (to compensate for 1).\\n[0,1] [0,0] will work.\\nNow if you think there exist a [1,1] let\\'s try adding it to our row [1,0] -> [2,1]. Now to compensate it we need two more rows with 0 at 0th index. and if such a row exist that row and our original row will form a pair of desired subset.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is pretty simple\\nCheck if any row is full zero then return it otherwise,\\nUse two nested loops to choose two rows and check if they form a subset or not.\\nif there exist no two rows to form a desired pair return NULL.\\n\\nTwo rows form a desired pair, if there exist no two 1s at same index.\\n[0,0,1,1] [0,1,0,1] not desired because of index 3th.\\n\\nTime complexity - O(m*n*n)\\n\\nNow we can optimize it through bit masking,\\nthink of rows not as an array but with numbers.\\nwe can always represent a binary array with a number (ofcourse as every number has a unique binary representation).\\nCreate a vector and store number for every row and now to check if two rows are desired or not we simply need to and (&) them.\\nyeah , this much simple \\nthink of it and will only give 1 when there are two 1\\'s at same position.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid)\\n    {\\n        int n = grid.size() , m = grid[0].size();\\n        \\n        vector<int> vec;\\n        \\n        for(auto i : grid)\\n        {\\n            int num = 0;\\n            for(int j = 0;j<m;j++)\\n            {\\n                num |= (i[j]<<j);\\n            }\\n            \\n            vec.push_back(num);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vec[i]==0) return {i};\\n            \\n            for(int j = i+1;j<n;j++)\\n            {\\n                // cout<<vec[i]<<\" \"<<vec[j]<<\"\"\\n                if((vec[i]&vec[j])==0) return {i,j};\\n                \\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid)\\n    {\\n        int n = grid.size() , m = grid[0].size();\\n        \\n        vector<int> vec;\\n        \\n        for(auto i : grid)\\n        {\\n            int num = 0;\\n            for(int j = 0;j<m;j++)\\n            {\\n                num |= (i[j]<<j);\\n            }\\n            \\n            vec.push_back(num);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vec[i]==0) return {i};\\n            \\n            for(int j = i+1;j<n;j++)\\n            {\\n                // cout<<vec[i]<<\" \"<<vec[j]<<\"\"\\n                if((vec[i]&vec[j])==0) return {i,j};\\n                \\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3622530,
                "title": "c-bit-manipulation-time-o-n-and-constant-space",
                "content": "# Intuition\\nThink how can we compress a row in a number\\nHint 1: row.size() <= 5\\nHint 2: Think bit manipulation\\n\\n# Approach\\n```\\nFirstly convert all rows into some number.\\nThis number, 0 <= number < 32 \\nJust find out two rows whose bitwise AND turns out to 0.\\nWe can optimise N * N searching using hashmaps.\\nWe can discuss proof of above in comments.\\n```\\n\\n# Complexity\\n- Time complexity:\\n```O(N * 32) => O(N) only```\\n\\n- Space complexity:\\n```O(1) because we can only have at max 32 different number```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        unordered_map<int, int>hsh;\\n        for(int i = 0; i < n; i++) {\\n            int val = 0;\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j]) {\\n                    val += (1 << j);\\n                }\\n            }\\n\\n            if(val == 0) {\\n                return {i};\\n            }\\n\\n            for(int j = 1; j < 32; j++) {\\n                if((val & j) == 0 and hsh.count(j)) {\\n                    return {hsh[j], i};\\n                }\\n            }\\n            hsh[val] = i;\\n        }      \\n        return {};\\n    }\\n};\\n\\n```\\nThanks \\u2764\\uFE0F\\u2764\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nFirstly convert all rows into some number.\\nThis number, 0 <= number < 32 \\nJust find out two rows whose bitwise AND turns out to 0.\\nWe can optimise N * N searching using hashmaps.\\nWe can discuss proof of above in comments.\\n```\n```O(N * 32) => O(N) only```\n```O(1) because we can only have at max 32 different number```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        unordered_map<int, int>hsh;\\n        for(int i = 0; i < n; i++) {\\n            int val = 0;\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j]) {\\n                    val += (1 << j);\\n                }\\n            }\\n\\n            if(val == 0) {\\n                return {i};\\n            }\\n\\n            for(int j = 1; j < 32; j++) {\\n                if((val & j) == 0 and hsh.count(j)) {\\n                    return {hsh[j], i};\\n                }\\n            }\\n            hsh[val] = i;\\n        }      \\n        return {};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622298,
                "title": "java-python-3-hashmap-time-o-m-2-n",
                "content": "**Intuition**\\n\\n1. If there is an all `0`s row, it is one of the solutions.\\n2. Otherwise, if there are a pair of two rows that the `AND` operation between them is `0`, then it is one of the solutions.\\n3. Since `n <= 5`, we can use a `HashMap/dict` to store visited `row`(which can be converted to an int) and corresponding `row number`, and traverse all numbers within `2 ^ 5 - 1 = 31` to find current number\\'s pair.\\n\\n```java\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        int R = grid.length;\\n        if (R == 1) {\\n            return IntStream.of(grid[0]).sum() == 0 ? List.of(0) : List.of();\\n        }\\n        Map<Integer, Integer> rowIndices = new HashMap<>();\\n        for (int r = 0, C = grid[0].length; r < R; ++r) {\\n            int r1 = r, num = IntStream.range(0, C).map(k -> grid[r1][k] << k).sum();\\n            for (int i = 0; i < 32; ++i) {\\n                if ((i & num) == 0 && rowIndices.containsKey(i)) {\\n                    return List.of(rowIndices.get(i), r);\\n                }\\n            }\\n            rowIndices.putIfAbsent(num, r);\\n        }\\n        return List.of();\\n    }\\n```\\n```python\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid) == 1:\\n            return [0] if all(num == 0 for num in grid[0]) else []\\n        d = {}\\n        for r, row in enumerate(grid):\\n            num = sum(cell << c for c, cell in enumerate(row))\\n            for i in range(32):\\n                if (i & num) == 0 and i in d:\\n                    return [d[i], r]\\n            d.setdefault(num, r)    \\n        return []\\n```\\n\\n**Analysis**\\n\\nTime: `O(m * 2 ^ n)`, space: `O(m)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        int R = grid.length;\\n        if (R == 1) {\\n            return IntStream.of(grid[0]).sum() == 0 ? List.of(0) : List.of();\\n        }\\n        Map<Integer, Integer> rowIndices = new HashMap<>();\\n        for (int r = 0, C = grid[0].length; r < R; ++r) {\\n            int r1 = r, num = IntStream.range(0, C).map(k -> grid[r1][k] << k).sum();\\n            for (int i = 0; i < 32; ++i) {\\n                if ((i & num) == 0 && rowIndices.containsKey(i)) {\\n                    return List.of(rowIndices.get(i), r);\\n                }\\n            }\\n            rowIndices.putIfAbsent(num, r);\\n        }\\n        return List.of();\\n    }\\n```\n```python\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid) == 1:\\n            return [0] if all(num == 0 for num in grid[0]) else []\\n        d = {}\\n        for r, row in enumerate(grid):\\n            num = sum(cell << c for c, cell in enumerate(row))\\n            for i in range(32):\\n                if (i & num) == 0 and i in d:\\n                    return [d[i], r]\\n            d.setdefault(num, r)    \\n        return []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3622384,
                "title": "how-to-solve-this-problem-when-n-8-in-the-original-tiktok-oa",
                "content": "Originally the constraint is at most 8 cols. In this case, there are too many possibilities. \\n\\nI proposed a knapsack solution in the original post, which is wrong. Anyone knows how to solve it correctly? Thanks.\\n\\nhttps://leetcode.com/discuss/interview-question/3359129/Tiktok-OA-Good-subset-of-a-Binary-Matrix-HARD\\n\\n\\n**When n=8, we can have the following valid cases with more than 2 rows**\\n\\n111000\\n100110\\n010101\\n001011\\n \\n(from @hero080)\\n11110000\\n11110000\\n10000111\\n01001011\\n00101101\\n00011110\\n\\n(from @sebnyberg)\\n1100001\\n1011000\\n1010110\\n0110001\\n0101100\\n0001111",
                "solutionTags": [],
                "code": "Originally the constraint is at most 8 cols. In this case, there are too many possibilities. \\n\\nI proposed a knapsack solution in the original post, which is wrong. Anyone knows how to solve it correctly? Thanks.\\n\\nhttps://leetcode.com/discuss/interview-question/3359129/Tiktok-OA-Good-subset-of-a-Binary-Matrix-HARD\\n\\n\\n**When n=8, we can have the following valid cases with more than 2 rows**\\n\\n111000\\n100110\\n010101\\n001011\\n \\n(from @hero080)\\n11110000\\n11110000\\n10000111\\n01001011\\n00101101\\n00011110\\n\\n(from @sebnyberg)\\n1100001\\n1011000\\n1010110\\n0110001\\n0101100\\n0001111",
                "codeTag": "Unknown"
            },
            {
                "id": 3637588,
                "title": "c-solution-99-faster",
                "content": "# Intuition\\n\\nbit manipulation\\nnumber of columns <= 5\\n\\nthink how to simplify the problem\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwe can observe that if a row filled of zeros this is a solution ,\\n\\nand if there is a solution with size >2 it guarentee that there is  a solution with size == 2\\n\\nnow the problem is to find pair suitable rows\\n\\nwe should compress the rows into one integer for each row\\n\\nevery one in each row mustn\\'t face another one\\n\\nthis is suitable pair of rows \\n\\n0 0 1 0\\n0 1 0 1\\n\\n\\nthis isn\\'t suitable pair\\n\\n0 0 1 0\\n0 0 1 1\\n\\n\\n---\\n\\n\\n\\nwe can check for that by & operator on the integers \\n\\nif (firstRow&SecondRow) == 0 then it will be suitable pair\\n\\n\\nthen we map these integers \\n\\nnow the two numbers we search about are between 1 -> 63\\n\\nnow we can search about them by nested loop as in code\\n\\nif we couldn\\'t find a solution , return empty vector\\n\\n# Complexity\\n- Time complexity:$$(n*m + 2^{2n})$$ where n == number of grid columns that doesn\\'t exceed 5\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$(2^{n})$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        vector<int>mp(1<<n,-1);\\n        for(int i=0;i<grid.size();i++){\\n            int x=0;\\n            for(auto &j:grid[i]){\\n                x<<=1;\\n                x+=j;\\n            }\\n            mp[x] = i;\\n        }    \\n//      if we found a row that full by zeros we return its idnex\\n        if(mp[0] != -1)\\n            return {mp[0]};\\n\\n        for(int i=1;i<(1<<n);i++){\\n            for(int j=i+1;j<(1<<n);j++){\\n                if((i&j) == 0 && mp[i]!= -1 && mp[j] != -1){\\n                    int x = mp[i] , y = mp[j];\\n                    if(x>y)\\n                        swap(x,y);\\n                    return {x,y};\\n                }\\n            }\\n        }\\n\\n        return {};\\n    }    \\n};\\n```\\n\\n![d7d0f63f-6042-429c-959c-81c2108f856c_1676643902.4885135.jpeg](https://assets.leetcode.com/users/images/724d107c-041e-4bb4-a2fe-77682b5c139f_1689511181.5314376.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        vector<int>mp(1<<n,-1);\\n        for(int i=0;i<grid.size();i++){\\n            int x=0;\\n            for(auto &j:grid[i]){\\n                x<<=1;\\n                x+=j;\\n            }\\n            mp[x] = i;\\n        }    \\n//      if we found a row that full by zeros we return its idnex\\n        if(mp[0] != -1)\\n            return {mp[0]};\\n\\n        for(int i=1;i<(1<<n);i++){\\n            for(int j=i+1;j<(1<<n);j++){\\n                if((i&j) == 0 && mp[i]!= -1 && mp[j] != -1){\\n                    int x = mp[i] , y = mp[j];\\n                    if(x>y)\\n                        swap(x,y);\\n                    return {x,y};\\n                }\\n            }\\n        }\\n\\n        return {};\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622812,
                "title": "explanation-to-why-we-need-to-consider-maximum-2-rows",
                "content": "# Explanation\\nWe will assume our matrix has no rows that contain only zeroes (otherwise we have a trivial solution). Next, we claim that if there does not exist a valid subset of size 2, there doesn\\'t exist any other valid subset.\\nTo build a valid subset of size 2, we need two distinct rows such that there doesn\\'t exist any column on which we have two 1s - this is a sufficient and necessary condition. Now, let\\'s assume there\\'s no valid subset with 2 rows, this implies that for any pair of rows in our matrix there is at least one column populated with two 1s. Now, let\\'s suppose there exists a valid subset with size > 2. It is easy to prove that if there exists such a subset, there also exists a subset of even size (proof left to the reader). Let\\'s note the subset size with **2*k**. If we want this subset to be valid, then we must have at most **k** ones on each columns **(1)**. But don\\'t forget that for each pair of rows in our subset there exist at least one column that has two 1s **(2)**. From **(1)** and **(2)** we deduce that each row in our subset must have at least three 1s **(3)**. This is not hard to prove. Let\\'s fix one row in our solution. If it has less than 3 1s, this means we can form at most **2 * (k - 1)** pairs with our fixed row with the property specified in **(2)**, but that\\'s not sufficient as we need exatly **2*k - 1** pairs that contain our fixed row. For any valid subset the following property must hold: the sum of the matrix elements in the subset should be less than or equal to half the number of elements in the subset **(4)**. From **(3)** and **(4)** we deduce that we need a matrix with at least 6 columns for a valid subset of size greater than 2 to exists, but the problem restrictions say that the number of columns is at most 5, so we reached a contradiction.\\nIn conclusion, if there does not exist a solution of size less than or equal 2, there doesn\\'t exist any other solution.\\n# Code\\nAdded a $O(m*n + 2^{2n})$ implementation\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        const int MAX = (1 << m);\\n        vector<int> mp(MAX, -1);\\n\\n        for (int i = 0; i < n; i++) {\\n            int mask = 0;\\n            for (int j = 0; j < m; j++) {\\n                mask += (grid[i][j] << j);\\n            }\\n            mp[mask] = i;\\n        }\\n\\n        if (mp[0] != -1) {\\n            return {mp[0]};\\n        }\\n\\n        for (int mask1 = 1; mask1 < MAX; mask1++) {\\n            for (int mask2 = 1; mask2 < MAX; mask2++) {\\n                if (mask1 & mask2) {\\n                    continue;\\n                }\\n                if (mp[mask1] == -1 || mp[mask2] == -1) {\\n                    continue;\\n                }\\n                \\n                return {min(mp[mask1], mp[mask2]), max(mp[mask1], mp[mask2])};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        const int MAX = (1 << m);\\n        vector<int> mp(MAX, -1);\\n\\n        for (int i = 0; i < n; i++) {\\n            int mask = 0;\\n            for (int j = 0; j < m; j++) {\\n                mask += (grid[i][j] << j);\\n            }\\n            mp[mask] = i;\\n        }\\n\\n        if (mp[0] != -1) {\\n            return {mp[0]};\\n        }\\n\\n        for (int mask1 = 1; mask1 < MAX; mask1++) {\\n            for (int mask2 = 1; mask2 < MAX; mask2++) {\\n                if (mask1 & mask2) {\\n                    continue;\\n                }\\n                if (mp[mask1] == -1 || mp[mask2] == -1) {\\n                    continue;\\n                }\\n                \\n                return {min(mp[mask1], mp[mask2]), max(mp[mask1], mp[mask2])};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622337,
                "title": "bitmask-greedy-cpp-easy-solution-with-detailed-explanation-o-m-n-n-2-2n",
                "content": "### if you like the solution, please give me a up vote.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nBy observing, \\nif colums count is 3,\\nwe can find all available row combination is\\n`[0, 0, 0]`\\n`[0, 0, 1]`\\n`[0, 1, 0]`\\n`[0, 1, 1]`\\n`[1, 0, 0]`\\n`[1, 0, 1]`\\n`[1, 1, 0]`\\n`[1, 1, 1]`\\n\\nthe count of all available row combination is `2 ^ 3`.\\n\\n\\nthen if colums count is 5,\\nthe count of all available row combination is `2 ^ 5`.\\n\\nif we want to find the sum of each column should be at most floor`(k / 2)`,\\nwe may have three available solution,\\n\\ncase 1:\\n`row : [0, 0, 0]`\\n\\nif this row exist, we directly return row index.\\n\\n\\ncase 2: \\n`row1: [1, 0, 0]`\\n`row2: [0, 1, 0]`\\n`row3: [0, 0, 1]`\\nwe can find a subset satisfy rows good.\\nin this case, we need to know that duplicate rows do not provide any useful information for the answer.\\n\\ncase 3: \\n`row1: [1, 0, 0]`\\n`row2: [0, 1, 0]`\\n\\nif case 2 is exist, we can find two rows satisfy rows good,\\nso we only need to scan all available row, \\nif `(i != j) (row1[i] != 1 && row2[j] != 1)`, these two rows is the answer.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(m * n + n * 2 ^ 2n )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        bool success = false;\\n        vector<int> v(1<<n, -1);\\n        vector<int> output;\\n        \\n        for(int i = 0 ; i < m ; i++) {\\n            int sum = 0;\\n            for(int j = 0 ; j < n ; j++) {\\n                if(grid[i][j]) {\\n                    sum += (1 << j);\\n                }\\n            }\\n            v[sum] = i;\\n        }\\n        \\n        if(v[0] >= 0) {\\n            output.push_back(v[0]);\\n        }\\n        else {\\n            for(int i = 1 ; (i < v.size()) && !success; i++) {\\n                if(v[i] < 0) {\\n                    continue;\\n                } \\n                for(int j = i+1; (j < v.size()) && !success; j++) {\\n                    if(v[j] < 0) {\\n                        continue;\\n                    }\\n                    \\n                    success = true;\\n                    for(int k = 0 ; k < n ; k++) {\\n                        if((i & (1 << k)) && (j & (1 << k))) {\\n                            success = false;\\n                            break;\\n                        }\\n                    }\\n                    if(success) {\\n                        output.push_back(v[i]);\\n                        output.push_back(v[j]);\\n                        sort(output.begin(), output.end());\\n                    }\\n                }\\n            }\\n\\n        }\\n        \\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        bool success = false;\\n        vector<int> v(1<<n, -1);\\n        vector<int> output;\\n        \\n        for(int i = 0 ; i < m ; i++) {\\n            int sum = 0;\\n            for(int j = 0 ; j < n ; j++) {\\n                if(grid[i][j]) {\\n                    sum += (1 << j);\\n                }\\n            }\\n            v[sum] = i;\\n        }\\n        \\n        if(v[0] >= 0) {\\n            output.push_back(v[0]);\\n        }\\n        else {\\n            for(int i = 1 ; (i < v.size()) && !success; i++) {\\n                if(v[i] < 0) {\\n                    continue;\\n                } \\n                for(int j = i+1; (j < v.size()) && !success; j++) {\\n                    if(v[j] < 0) {\\n                        continue;\\n                    }\\n                    \\n                    success = true;\\n                    for(int k = 0 ; k < n ; k++) {\\n                        if((i & (1 << k)) && (j & (1 << k))) {\\n                            success = false;\\n                            break;\\n                        }\\n                    }\\n                    if(success) {\\n                        output.push_back(v[i]);\\n                        output.push_back(v[j]);\\n                        sort(output.begin(), output.end());\\n                    }\\n                }\\n            }\\n\\n        }\\n        \\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629909,
                "title": "c-a-b-0-hashing-bit-manipulation",
                "content": "# Intuition\\n\\n**WHY A&B == 0?**\\nFor sum of elements along the column to be half of the number of rows selected(assuming no of rows selected as k), we need at most k/2 1\\'s across all the rows for a particular column and rest all 0\\'s. In terms of bit, for a particular column(or bit), their Bitiwse AND should be 0. \\nAlso, we need atmost 2 rows(1 row will also suffice in case we have a row with all 0s) since if we\\'re able to find 3 or 4 rows, we can cut it short and return only 2 rows as our answer also. \\n\\n\\nNext, The number of columns is atmost 5 and the elements present are either 0 or 1. Hence we can represnt each row by a decimal number < 32.\\n\\n\\n# Approach\\nFind all possible pair of numbers < 32 which have their bitwise AND equal to 0 and store them in a set. Now store all the numbers that are present in the grid(by representing each row as a decimal number) in a map. \\nTraverse through the feasible pairs(stored in set) and check if both the numbers are present in the grid, if YES, return their rows, if NOT FOUND, return an empty array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(31*31) + O(grid.size()) + O(s.size())$$\\n`s.size() = 211 at max`\\nHence, overall **TC** is $$O(grid.size())$$ or $$O(m)$$\\n\\n\\n- Space complexity:\\nO(s.size()) + O(31*31)\\nHence, overall **SC** is $$O(1)$$(since both are constant and doesn\\'t depend on input)\\n\\n# Code\\n```\\nclass Solution {\\n    int binaryToDecimal(vector<int>& n) {\\n        int dec_value = 0, base = 1, len = n.size();\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (n[i]) dec_value += base;\\n            base <<= 1;\\n        }\\n        return dec_value;\\n    }\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        set<pair<int,int>> s;\\n        for(int i = 0; i < 32; i++) {\\n            for(int j = 1; j < 32; j++) {\\n                if((i&j) == 0) s.insert({i,j});\\n            }\\n        }\\n        int m = grid.size(), n = grid[0].size();\\n        unordered_map<int,vector<int>> mpp;\\n        for(int i = 0; i < m; i++) mpp[binaryToDecimal(grid[i])].push_back(i);\\n        if(mpp.find(0) != mpp.end()) {\\n            return mpp[0];\\n        }\\n        for(auto &i:s) {\\n            int num1 = i.first, num2 = i.second;\\n            if(mpp.find(num1) != mpp.end() and mpp.find(num2) != mpp.end()) {\\n                vector<int> ans(2);\\n                ans[0] = min(mpp[num1][0],mpp[num2][0]);\\n                ans[1] = max(mpp[num1][0],mpp[num2][0]);\\n\\n                return ans;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\\n\\nUpvote if it was helpful and you get the approach :)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    int binaryToDecimal(vector<int>& n) {\\n        int dec_value = 0, base = 1, len = n.size();\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (n[i]) dec_value += base;\\n            base <<= 1;\\n        }\\n        return dec_value;\\n    }\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        set<pair<int,int>> s;\\n        for(int i = 0; i < 32; i++) {\\n            for(int j = 1; j < 32; j++) {\\n                if((i&j) == 0) s.insert({i,j});\\n            }\\n        }\\n        int m = grid.size(), n = grid[0].size();\\n        unordered_map<int,vector<int>> mpp;\\n        for(int i = 0; i < m; i++) mpp[binaryToDecimal(grid[i])].push_back(i);\\n        if(mpp.find(0) != mpp.end()) {\\n            return mpp[0];\\n        }\\n        for(auto &i:s) {\\n            int num1 = i.first, num2 = i.second;\\n            if(mpp.find(num1) != mpp.end() and mpp.find(num2) != mpp.end()) {\\n                vector<int> ans(2);\\n                ans[0] = min(mpp[num1][0],mpp[num2][0]);\\n                ans[1] = max(mpp[num1][0],mpp[num2][0]);\\n\\n                return ans;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628481,
                "title": "simple-proof-intuition",
                "content": "There are various solution with proof out there, however I couldn\\'t understand any of them, After reading multiple of proofs, I did able to convince myself why only two rows are required. Below is example\\n\\n\\n> - At first, you try different (3-4) example, and it turns out you need 2 row to check if there bitwise AND is 0, you will have the answer.\\n\\nIf you are able to prove that only 2 row\\'s bitwise AND is only required/necessary condition, you will be convinced.\\n\\nLets prove this by contradiction. Check below two points :-\\n\\n> 1. None of the row should contains all zeros, else answer will be only this row.\\n> 2. If you want that 2 row can\\'t lead to solution, that means between each pair of row, there must be one column having both 1(overlapping 1). Example, \\n10**1**00\\n00**1**00\\n\\n\\n\\nlets try out all possible types, we are trying to find subset (that we have to pick as answer) where number of rows != 2 **and must be** >2. If we can\\'t find answer for rows != 2 and >2, that means no solution exist for >2, we would have proved, that row = 2 is only necessary and sufficient confition :-\\n \\n- 10000\\nLets say, in our subset (answer) `10000` is one row.\\nThat means, we must have\\n**10000**\\n1XXXX\\n1XXXX\\n1XXXX\\n... k times\\n\\nwhy?\\nSince, because of condition **2**, which says b/w each pair there must be 1, since we have only 1 in original row, we have to have 1 in all below. Now, obivously, this can\\'t lead to solution since, number of 1 in first column = k, (where k = number of rows in subset)\\n\\n- 11000\\nIn this case, because of condition 2, we must have\\n11000\\n10XXX\\n01XXX\\n10XXX (k times)\\n\\nLet k = 6.\\n\\nnote, in order for 2 and 3 row above we must have overlapping 1, so add as below\\n\\n11000\\n10**1**XX\\n01**1**XX\\n10XXX\\n01XXX \\n10XXX\\n\\ncheck, number of 1 in first column - 4, which is != k/2, we can\\'t pick 11000.\\n\\n- 11100\\nThis is also not possible for k = 3 or 4 or (k>2) (you can try yourself)\\n\\nWe just proved. How?\\nWe took an example of random row with random number of 1, and try to contruct a subset such that number of rows > 2 and there has to be overlapping of 1 in each pair and by doing so in optimising way, we ended up getting result, where sum of 1 in at least 1 column is > k/2. Means we can\\'t construct such subset with rows > 2 and contains the answer. \\nHence only two possiblilty, either all 0, or 2 row with bitwise 0.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        for(int i=0;i<n;i++) {\\n            boolean found = true;\\n            for(int j=0;j<m;j++) {\\n                if(grid[i][j] == 1) found = false;\\n            }\\n            if(found) return Arrays.asList(i);\\n        }\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            int[] x = grid[i];\\n            \\n            int num = convert(x);\\n            System.out.println(num);\\n            int ans = neg(x, map, new int[m]);\\n            if(ans != -1) {\\n                return Arrays.asList(ans, i);\\n            }\\n            map.put(num, i);\\n            \\n            System.out.println();\\n            \\n        }\\n            \\n        return new ArrayList<>();\\n            \\n         \\n    }\\n    \\n    private int neg(int[] x, HashMap<Integer, Integer> map, int[] num) {\\n       \\n        \\n        int n = x.length;\\n        return solve(x, 0, map, num);\\n        \\n    }\\n    \\n    private int solve(int[] x, int i, HashMap<Integer, Integer> map, int[] num) {\\n        \\n        int n = x.length;\\n        if(i==n) {\\n            int y = convert(num);\\n            System.out.println(Arrays.toString(num)+\" \" + y);\\n            if(map.containsKey(y)) return map.get(y);\\n            return -1;   \\n        }\\n        \\n        int ans = -1;\\n        \\n        if(x[i] == 0) {\\n            num[i] = 1;\\n            ans = solve(x, i+1, map, num);\\n            num[i] = 0;\\n        }\\n        \\n        if(ans != -1) return ans;\\n        ans = solve(x, i+1, map, num);\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    private int convert(int[] x) {\\n        int n = x.length;\\n        int ans = 0;\\n        int j = 0;\\n        for(int i=n-1;i>=0;i--) {\\n            if(x[i]==1) ans += 1<<j;\\n            j++;\\n        }\\n        \\n        return ans;\\n    } \\n    \\n }\\n\\n/*\\n\\n[[0,1,1,0],\\n [0,0,0,1],\\n [1,1,1,1]]\\n \\n \\n \\n [0,1]\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        for(int i=0;i<n;i++) {\\n            boolean found = true;\\n            for(int j=0;j<m;j++) {\\n                if(grid[i][j] == 1) found = false;\\n            }\\n            if(found) return Arrays.asList(i);\\n        }\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            int[] x = grid[i];\\n            \\n            int num = convert(x);\\n            System.out.println(num);\\n            int ans = neg(x, map, new int[m]);\\n            if(ans != -1) {\\n                return Arrays.asList(ans, i);\\n            }\\n            map.put(num, i);\\n            \\n            System.out.println();\\n            \\n        }\\n            \\n        return new ArrayList<>();\\n            \\n         \\n    }\\n    \\n    private int neg(int[] x, HashMap<Integer, Integer> map, int[] num) {\\n       \\n        \\n        int n = x.length;\\n        return solve(x, 0, map, num);\\n        \\n    }\\n    \\n    private int solve(int[] x, int i, HashMap<Integer, Integer> map, int[] num) {\\n        \\n        int n = x.length;\\n        if(i==n) {\\n            int y = convert(num);\\n            System.out.println(Arrays.toString(num)+\" \" + y);\\n            if(map.containsKey(y)) return map.get(y);\\n            return -1;   \\n        }\\n        \\n        int ans = -1;\\n        \\n        if(x[i] == 0) {\\n            num[i] = 1;\\n            ans = solve(x, i+1, map, num);\\n            num[i] = 0;\\n        }\\n        \\n        if(ans != -1) return ans;\\n        ans = solve(x, i+1, map, num);\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    private int convert(int[] x) {\\n        int n = x.length;\\n        int ans = 0;\\n        int j = 0;\\n        for(int i=n-1;i>=0;i--) {\\n            if(x[i]==1) ans += 1<<j;\\n            j++;\\n        }\\n        \\n        return ans;\\n    } \\n    \\n }\\n\\n/*\\n\\n[[0,1,1,0],\\n [0,0,0,1],\\n [1,1,1,1]]\\n \\n \\n \\n [0,1]\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625374,
                "title": "c-bit-manipulation-detailed-explanation-give-it-a-read",
                "content": "# Approach\\n- First we need to observe that the possible size can be 1 or 2, if these size are not possible then larger sizes subsets are not possible this can be proven like this-\\n- Consider 2 rows and if any column sum turns out to be 2 then it becomes **> k/2 (which is 2/2=1)** now if we think that it is not possible at 2 then maybe it is possible at size 3 this means we did not find any row at which the jth column sum was 1 which means that in all rows that column had 1 as element so now the sum would be 3 which is still greater than **3/2=1** now we try for 4, so **4/2 = 2** but not our sum would become **1+1+1+1=4** for that column by taking 4 rows because we did not get any row having 0 at the jth column hence we can say that if we are not able to find answer for size 2 then answer would not exist. \\n- **For size 1,** the answer would be that index which has all columns as 0. \\n- So, now our questions boils down to finding 2 rows with sum of column elements **<= 1**.\\n- This is only possible when at each column of the two rows either **both rows have 0** as the jth element or **one element is 0 and other is 1**.\\n- This seems familiar with the property of **bitwise AND**, hence the question again boils down to finding two elements whose bitwise AND is 0. \\n- So we need to convert all the binary rows into their decimal equivalent and store them in an array along with their index and now we need to iterate on the array to find 2 elements whose bitwise AND is 0, but this would lead to TLE because it finds the pair in O(n^2).\\n- As we can see that the number of columns is very less which is 5 this means that 5 bits are available hence possible numbers are from 0 to 31 so we will iterate on these elements **(0 to 31)** and find if 2 elements bitwise AND is 0 and those two elements are present in our grid or not.\\n-  This can be efficiently done using a map which will store the grid element\\'s decimal equivalent and it\\'s index hence this will work in **O((32^2)(log(n)))**. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        map<int,vector<int>> mt;\\n        for(int i=0;i<n;i++)\\n        {\\n            int num = 0;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                num+=grid[i][j]*((int)pow(2,m-1-j));\\n            }\\n            mt[num].push_back(i);\\n        }\\n        \\n        if(mt.find(0)!=mt.end())\\n        {\\n            return {mt[0][0]};\\n        }\\n        else if(mt.size()==1)\\n        return {};\\n        vector<int> tmp;\\n        for(int i=0;i<32;i++)\\n        {\\n            int flg = 0;\\n            for(int j=0;j<32;j++)\\n            {\\n                if((i&j)==0)\\n                {   \\n                    if(i==j)\\n                    {\\n                        if(mt.find(i)!=mt.end())\\n                        {\\n                            if(mt[i].size()>1)\\n                            {\\n                                tmp.push_back(mt[i][0]);\\n                                tmp.push_back(mt[i][1]);\\n                                flg = 1;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(mt.find(i)!=mt.end() && mt.find(j)!=mt.end())\\n                        {\\n                            tmp.push_back(mt[i][0]);\\n                            tmp.push_back(mt[j][0]);\\n                            flg = 1;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            if(flg)\\n            break;\\n        }\\n        sort(tmp.begin(),tmp.end());\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        map<int,vector<int>> mt;\\n        for(int i=0;i<n;i++)\\n        {\\n            int num = 0;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                num+=grid[i][j]*((int)pow(2,m-1-j));\\n            }\\n            mt[num].push_back(i);\\n        }\\n        \\n        if(mt.find(0)!=mt.end())\\n        {\\n            return {mt[0][0]};\\n        }\\n        else if(mt.size()==1)\\n        return {};\\n        vector<int> tmp;\\n        for(int i=0;i<32;i++)\\n        {\\n            int flg = 0;\\n            for(int j=0;j<32;j++)\\n            {\\n                if((i&j)==0)\\n                {   \\n                    if(i==j)\\n                    {\\n                        if(mt.find(i)!=mt.end())\\n                        {\\n                            if(mt[i].size()>1)\\n                            {\\n                                tmp.push_back(mt[i][0]);\\n                                tmp.push_back(mt[i][1]);\\n                                flg = 1;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(mt.find(i)!=mt.end() && mt.find(j)!=mt.end())\\n                        {\\n                            tmp.push_back(mt[i][0]);\\n                            tmp.push_back(mt[j][0]);\\n                            flg = 1;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            if(flg)\\n            break;\\n        }\\n        sort(tmp.begin(),tmp.end());\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623236,
                "title": "easy-solution-bitmask-explanatory-code",
                "content": "\\n# Code\\n```\\n// Before going through the solution I recommend you to see the hints hints given by the leetcode\\nclass Solution {\\npublic:\\n    // we have to find only 1 or 2 row who satisfy the condition\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> ans;\\n        // bi vector store the bitmap int value\\n        vector<int> bi(n);\\n        for(int i = 0; i < n; i++){\\n            int num = 0;\\n            bool isOne = false;\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 1){\\n                    isOne = true;\\n                    num |= (1<<j);\\n                }\\n            }\\n            // when row contain only zero\\n            if(!isOne){\\n                ans.push_back(i);\\n                return ans;\\n            }\\n            bi[i] = num;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                // if & of 2 int is zero means sum of each col is either one or zero which satisfy the condition.\\n                if((bi[i] & bi[j]) == 0){\\n                    ans.push_back(i);\\n                    ans.push_back(j);\\n                    return ans;\\n                }\\n            }\\n        }\\n        // return empty array if you didn\\'t find the pair\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nPlease do UPVOTE if you like it !!\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n// Before going through the solution I recommend you to see the hints hints given by the leetcode\\nclass Solution {\\npublic:\\n    // we have to find only 1 or 2 row who satisfy the condition\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> ans;\\n        // bi vector store the bitmap int value\\n        vector<int> bi(n);\\n        for(int i = 0; i < n; i++){\\n            int num = 0;\\n            bool isOne = false;\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 1){\\n                    isOne = true;\\n                    num |= (1<<j);\\n                }\\n            }\\n            // when row contain only zero\\n            if(!isOne){\\n                ans.push_back(i);\\n                return ans;\\n            }\\n            bi[i] = num;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                // if & of 2 int is zero means sum of each col is either one or zero which satisfy the condition.\\n                if((bi[i] & bi[j]) == 0){\\n                    ans.push_back(i);\\n                    ans.push_back(j);\\n                    return ans;\\n                }\\n            }\\n        }\\n        // return empty array if you didn\\'t find the pair\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622689,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool foo(vector<int>& v1,vector<int> & v2,int n){\\n        // int m=0;\\n        for(int i=0;i<n;i++){\\n            if(v1[i]+v2[i]==2) return false;\\n        }\\n        return true;\\n    }\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        int n=grid[0].size();\\n        int m=grid.size();\\n        vector<int> v(n,0);\\n        for(int i=0;i<m;i++){\\n            if(grid[i]==v){\\n                ans.push_back(i);\\n                return ans;\\n            }\\n                \\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=i+1;j<m;j++){\\n                if(foo(grid[i],grid[j],n)){\\n                    ans.push_back(i);\\n                    ans.push_back(j);\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool foo(vector<int>& v1,vector<int> & v2,int n){\\n        // int m=0;\\n        for(int i=0;i<n;i++){\\n            if(v1[i]+v2[i]==2) return false;\\n        }\\n        return true;\\n    }\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        int n=grid[0].size();\\n        int m=grid.size();\\n        vector<int> v(n,0);\\n        for(int i=0;i<m;i++){\\n            if(grid[i]==v){\\n                ans.push_back(i);\\n                return ans;\\n            }\\n                \\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=i+1;j<m;j++){\\n                if(foo(grid[i],grid[j],n)){\\n                    ans.push_back(i);\\n                    ans.push_back(j);\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622591,
                "title": "easy-to-understand-c-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you look carefully you will notice that we can only take two rows in a subset at a time, because it being a binary matrix and given constraint of floor(k/2) we can\\'t really have subsets with more than two rows.\\n\\nThis boils down our problem to a much simple one, first we check if any row has a sum 0, if it has then we simply return it because we have been given that we can return any subset.\\n\\nIf we dont find any such row then we iterate row wise in the matrix , generating pairs of unique rows and then we iterate with the help of another loop for calculating column sum !\\n\\nThe matrix being a binary one, if any two rows have both 1s for any col , we cant take it as we need it at most floor(k/2) times i.e 1 in our case as we are taking pairs, else if we find one row has 0 and another has 1 for the same column we return it as a good subset.\\n\\nHave a look at the code for better understanding !\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++) {\\n            int rsum=0;\\n            for(int j=0;j<m;j++) {\\n                rsum+=grid[i][j];\\n            }\\n            //if any row has sum 0 it automatically is a good subset !\\n            if(rsum==0) return {i};\\n        }\\n        for(int i=0;i<n;i++) {\\n            for (int j=i+1;j<n;j++) {\\n                int csum=0;\\n                for(int k=0;k<m;k++) {\\n                    //1 AND 0 = 0 , hence good subset\\n                    // if both 1 then sum exceeds floor(k/2){k=2 here}\\n                    csum+=grid[i][k] and grid[j][k];\\n                }\\n                if(csum==0) return {i, j};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++) {\\n            int rsum=0;\\n            for(int j=0;j<m;j++) {\\n                rsum+=grid[i][j];\\n            }\\n            //if any row has sum 0 it automatically is a good subset !\\n            if(rsum==0) return {i};\\n        }\\n        for(int i=0;i<n;i++) {\\n            for (int j=i+1;j<n;j++) {\\n                int csum=0;\\n                for(int k=0;k<m;k++) {\\n                    //1 AND 0 = 0 , hence good subset\\n                    // if both 1 then sum exceeds floor(k/2){k=2 here}\\n                    csum+=grid[i][k] and grid[j][k];\\n                }\\n                if(csum==0) return {i, j};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622342,
                "title": "only-even-no-of-rows-should-be-selected-only-2-rows-should-be-selected-c-easiest",
                "content": "# Intuition\\n\\nThis solution is entirely based on 2 intuitions I got after sone observation:\\n\\n**INTIUTION #1: Only even no. of rows should be selected [EASY]**\\nIf we select 2 rows (i.e. subset length = 2), none of the total column values should exceed 1. And the same constraints applies for a subset of length 3. SO if we can find a subset of length `l1` where l1 is odd, we can definitely find a subset of length `l1-1`.\\n\\n**INTIUTION #2: Only 2 rows should be selected [TRICKY]**\\nNow if we were to use the same trick as before, can we extend our observation further? Let\\'s see an example:\\n\\nSay we have a subset of length 4 such that some columns have sum = 2 while others have sum 1 and 0. **If no completely null row is present, is this configuration possible without meaning that if we take any 2 rows of these 4, that won\\'t satisfy the given constraints?**\\n\\nLet\\'s try to think of one such example where n = 4\\n\\n```\\nFor 4 rows, say the sum is: 2|2|2|2\\nThe edge case for not choosing 2 rows would be:\\n-> at least one of the columns had 2 as sum.\\nSay after three rows this was te sum: 0|0|2|0\\nthis would mean taking these two is not possible and the last two rows could be:\\n1|1|0|1 and 1|1|0|1 making final = 2|2|2|2 [ACCEPTED]\\nBut, if first two give 0|0|2|0 that only means the rows were:\\n0|0|1|0 and 0|0|1|0\\nwe can see in that case, row {1,3} or {1,4} or {2,3} or {2,4} \\nwill suffice the conditions [ACCEPTED].\\n```\\n\\nYou can try to think more examples as well.\\n\\n\\n# Complexity\\n- Time complexity: O(m^2*n)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nvector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int> temp(grid[0].size(),0);\\n        for(int i = 0; i<grid.size(); i++){\\n            if(grid[i]==temp)return {i}; //if a completely empty row is present that is the answer.\\n        }\\n        for(int i = 0; i<grid.size(); i++){\\n            temp = grid[i];\\n            for(int j = i+1; j<grid.size(); j++){\\n                bool flag = true;\\n                for(int k = 0; k<temp.size(); k++){\\n                    if(temp[k]+grid[j][k]>1){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(flag)return {i,j};\\n            }\\n        }\\n        return {};\\n    }\\n```\\n\\nFeel free to ask for further explanations. Upvote if you thought the solution was creative :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nFor 4 rows, say the sum is: 2|2|2|2\\nThe edge case for not choosing 2 rows would be:\\n-> at least one of the columns had 2 as sum.\\nSay after three rows this was te sum: 0|0|2|0\\nthis would mean taking these two is not possible and the last two rows could be:\\n1|1|0|1 and 1|1|0|1 making final = 2|2|2|2 [ACCEPTED]\\nBut, if first two give 0|0|2|0 that only means the rows were:\\n0|0|1|0 and 0|0|1|0\\nwe can see in that case, row {1,3} or {1,4} or {2,3} or {2,4} \\nwill suffice the conditions [ACCEPTED].\\n```\n```\\nvector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int> temp(grid[0].size(),0);\\n        for(int i = 0; i<grid.size(); i++){\\n            if(grid[i]==temp)return {i}; //if a completely empty row is present that is the answer.\\n        }\\n        for(int i = 0; i<grid.size(); i++){\\n            temp = grid[i];\\n            for(int j = i+1; j<grid.size(); j++){\\n                bool flag = true;\\n                for(int k = 0; k<temp.size(); k++){\\n                    if(temp[k]+grid[j][k]>1){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(flag)return {i,j};\\n            }\\n        }\\n        return {};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3622292,
                "title": "c-java-only-check-the-subsets-with-size-1-or-2-w-explanation",
                "content": "For `n >= 4`, `n choose 2` is larger than `5`.\\nHence, if we choose a subset A with size >= `4`, we can always choose a subset B with size equal to `2`.\\nFor example, for a subset size of 4, we have 6 choices: `(1,2) (1,3),(1,4) (2,3) (2,4) (3,4)` . \\n```\\n1 1 1 0 0 0\\n1 0 0 1 1 0\\n0 1 0 1 0 1\\n0 0 1 0 1 1\\n```\\nHowever, `n <= 5`. We will always have at least one choice left to choose 2 rows.\\n\\nThen we only need to check subset with size 1 or 2.\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int> res;\\n        int m = grid.size(), n = grid[0].size();\\n        for (int i = 0; i < m; i++) {\\n            bool all_zero = true;\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) {\\n                    all_zero = false;\\n                    break;\\n                }\\n            }\\n            if (all_zero) {\\n                res.push_back(i);\\n                return res;\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int ii = i + 1; ii < m; ii++) {\\n                bool all_zero = true;\\n                for (int j = 0; j < n; j++) {\\n                    if ((grid[i][j] & grid[ii][j]) > 0) {\\n                        all_zero = false;\\n                        break;\\n                    }\\n                }\\n                if (all_zero) {\\n                    res.push_back(i);\\n                    res.push_back(ii);\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        int m = grid.length, n = grid[0].length;\\n        for (int i = 0; i < m; i++) {\\n            boolean allZero = true;\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) {\\n                    allZero = false;\\n                    break;\\n                }\\n            }\\n            if (allZero) {\\n                res.add(i);\\n                return res;\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int ii = i + 1; ii < m; ii++) {\\n                boolean allZero = true;\\n                for (int j = 0; j < n; j++) {\\n                    if ((grid[i][j] & grid[ii][j]) > 0) {\\n                        allZero = false;\\n                        break;\\n                    }\\n                }\\n                if (allZero) {\\n                    res.add(i);\\n                    res.add(ii);\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n1 1 1 0 0 0\\n1 0 0 1 1 0\\n0 1 0 1 0 1\\n0 0 1 0 1 1\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int> res;\\n        int m = grid.size(), n = grid[0].size();\\n        for (int i = 0; i < m; i++) {\\n            bool all_zero = true;\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) {\\n                    all_zero = false;\\n                    break;\\n                }\\n            }\\n            if (all_zero) {\\n                res.push_back(i);\\n                return res;\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int ii = i + 1; ii < m; ii++) {\\n                bool all_zero = true;\\n                for (int j = 0; j < n; j++) {\\n                    if ((grid[i][j] & grid[ii][j]) > 0) {\\n                        all_zero = false;\\n                        break;\\n                    }\\n                }\\n                if (all_zero) {\\n                    res.push_back(i);\\n                    res.push_back(ii);\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        int m = grid.length, n = grid[0].length;\\n        for (int i = 0; i < m; i++) {\\n            boolean allZero = true;\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) {\\n                    allZero = false;\\n                    break;\\n                }\\n            }\\n            if (allZero) {\\n                res.add(i);\\n                return res;\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int ii = i + 1; ii < m; ii++) {\\n                boolean allZero = true;\\n                for (int j = 0; j < n; j++) {\\n                    if ((grid[i][j] & grid[ii][j]) > 0) {\\n                        allZero = false;\\n                        break;\\n                    }\\n                }\\n                if (allZero) {\\n                    res.add(i);\\n                    res.add(ii);\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622272,
                "title": "answer-is-always-1-or-2-rows-o-m-log-m-2-n",
                "content": "Edit: might be hacked, need to reexamine\\n\\nHonestly this problem was very sneaky, I only arrived at the correct solution because I felt like the DP time complexity would be too impossible anyways. Here is a quick proof: For every 1 in a row, we will always need at least 1 \\'0\\' in another row to cancel it out. So every additional row with 1\\'s must have some \"complement\" row that will make it good again. So why not just choose any two complement rows? In turns out this approach does in fact work. So let us define a complement row as some row R\\' where R\\' has a 0 wherever R has a 1, and R\\' has a 1 OR 0 wherever R has a 0. Since n = 5, there are at most 32 complement R\\' for each R, so we can generate all 32 R\\' and look in a map to see if R\\' exists. Then we just return the indices of said rows. The other case is when a row contains all 0\\'s. Then you can just return this singular row.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        map<vector<int>, int> idx;\\n        for(int i = 0; i < grid.size(); i++){\\n            mp[grid[i]]++;\\n            idx[grid[i]] = i;\\n        }\\n        for(auto  i : grid){\\n            int z = 0;\\n            for(auto j : i) if(j == 1) z++; // if all 0s, return this row\\n            if(z == 0) return {idx[i]};\\n            mp[i]--;\\n            vector<vector<int>> comps; // a little inefficient but straight forward way to generate all complements, just copy and append for each number, max 2^5 times \\n            if(i[0] == 0) comps.push_back({1});\\n            comps.push_back({0});\\n            bool skip = true;\\n            for(auto j : i){\\n                if(skip){\\n                    skip  = false;\\n                    continue;\\n                }\\n                vector<vector<int>> nu;\\n                if(j == 0){\\n                    for(auto k : comps){\\n                        k.push_back(1);\\n                        nu.push_back(k);\\n                    }\\n                }\\n                for(auto k : comps){       \\n                    k.push_back(0);\\n                    nu.push_back(k);\\n                }\\n                swap(comps, nu);\\n            }\\n            for(auto k : comps) if(mp[k]){ // look for any complements in the map\\n                int mx = max(idx[i], idx[k]);\\n                int mn = min(idx[i], idx[k]);\\n                return {mn, mx};\\n            }\\n        }\\n        return {};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        map<vector<int>, int> idx;\\n        for(int i = 0; i < grid.size(); i++){\\n            mp[grid[i]]++;\\n            idx[grid[i]] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3669262,
                "title": "cpp-storing-duplicates-bitmasking-simple-implementation-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first look, I considered sorting the array based on the number of zeros each column contains.\\nIt looked like a greedy approach, but as I proceeded, gradually, it became clear that we had to check every possible pair and output the result.\\n\\nA few things I noticed were...\\n1) Small value of n ( generally n < 25,  Indicates the Question utilizes the concept of Bitmasking )\\n\\n2) Storing 5 binary numbers in a vector for each row looked inefficient. We could have done the same task using bitmask by storing binary numbers as bits of an integer.\\n\\n3) I noticed that binary number patterns will eventually repeat as m >>> 2^n.\\n\\n4) As we are searching for subset of size 2, we will only check if corresponding bits in two mask never becomes 1 simultaniouly.\\nelse our answer doesn\\'t exists;\\nthat way sum of columns( here sum of corresponding bit ) never exceed 1;\\nto find such mask we can take bitwise and of two masks; \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, I Tried a Brute Force solution, which barely passed all the tests.\\n\\nThen to avoid the visiting duplicates again and again, I tried to store them as a mask and mark them visited in a 2D vector,\\n When I have visited both covers previously, Then don\\'t revisit them; \\nthis made a slight improvement.\\n\\nThen instead of checking if I have visited both masks, can I actually check whether the answer for one mask exists or not? If that exists and is present in the array, then I found my Good pair.\\n\\nThis will reduce my Time complexity to O(n);\\n\\n# Brute Force O(n^2) solution runtime ~2180 ms\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid){\\n    \\n        int m = grid.size();\\n        vector<int> ans;\\n        if(m<= 0 ) return ans;\\n        vector<int> mask(m , 0);\\n        int n = grid[0].size();\\n   \\n        for( int i = 0; i < m; i++)\\n        {\\n            int x =0;\\n            for( int j = 0 ; j < n; j++ )\\n             {\\n                 if( grid[i][j] == 1 ) {x = (x|(1<<j));}\\n             }\\n            if(x == 0) { ans.push_back(i); return ans;}\\n            mask[i] = x;\\n            cout<<x;\\n        }\\n            for( int i =0 ; i < m; i++)\\n        {\\n            for( int j =i+1 ; j < m; j++)\\n            {   \\n                int flg = 0;\\n                for( int k = 0; k < n; k++)\\n              {  \\n                  int x = (1<<k);\\n                  if(   ( mask[i]&x ) && ( mask[j]&x )){\\n                      flg = 1;\\n                    break;\\n                }\\n                }\\n                if(flg)continue;\\n                else{\\n                    ans.push_back(i);\\n                    ans.push_back(j);\\n                    return ans;\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```\\n## Slightly Optimized version runtime ~ 1600 ms\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid){\\n        \\n        int m = grid.size();\\n        if(m<= 0 ) return {};\\n        vector<int> mask(m , -1);\\n        vector<vector<int>> vis(33, vector<int> (33, 0));\\n        int n = grid[0].size();\\n   \\n        for( int i = 0; i < m; i++)\\n        {\\n            int x =0;\\n            for( int j = 0 ; j < n; j++ )\\n             {\\n                 if( grid[i][j] == 1 ) {x = (x|(1<<j));}\\n             }\\n            if(x == 0) { return {i}; }\\n            mask[i] = x;\\n        }\\n          \\n        for( int i =0 ; i < m; i++)\\n        {\\n              if( mask[i] == (1<<n ) -1)continue;\\n            for( int j =i+1 ; j < m; j++)\\n            {   \\n                if( vis[mask[i]][mask[j]])continue;\\n                int flg = 0;\\n                for( int k = 0; k < n; k++)\\n                {  \\n                     int x = (1<<k);\\n                     if(   ( mask[i]&x ) && ( mask[j]&x )){\\n                         flg = 1;\\n                       break;\\n                    }\\n                }\\n                if(flg){ vis[mask[i]][mask[j]] = 1; continue;    }\\n                else{\\n                  return {i , j};\\n                }  \\n            }\\n        }\\n    \\n    return {};\\n    }\\n};\\n```\\n# Optimized O(n) solution runtime ~ 500 ms\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid){\\n        \\n        int m = grid.size();\\n      \\n        if(m<= 0 ) return {};\\n        vector<int> mask(33 , -1);\\n        int n = grid[0].size();\\n        int limit = (1<<n ) -1;\\n        // maximum limit of our mask\\n   \\n        for( int i = 0; i < m; i++)\\n        {\\n            int x =0;\\n            for( int j = 0 ; j < n; j++ )\\n             {\\n                 if( grid[i][j] == 1 ) {x = (x|(1<<j));}\\n             }\\n            if(x == 0) { return {i}; }\\n            if( x == limit ) continue;\\n\\n            // if all bits are set then it can not be our answer;\\n\\n            for(int k = 1; k <(limit +1); k++)\\n            {\\n              if( mask[k] != -1 && (  x&k ) == 0 )\\n                 {\\n                     return { mask[k], i};\\n                 }\\n            }\\n            mask[x] = i;\\n        }\\n    return {};\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid){\\n    \\n        int m = grid.size();\\n        vector<int> ans;\\n        if(m<= 0 ) return ans;\\n        vector<int> mask(m , 0);\\n        int n = grid[0].size();\\n   \\n        for( int i = 0; i < m; i++)\\n        {\\n            int x =0;\\n            for( int j = 0 ; j < n; j++ )\\n             {\\n                 if( grid[i][j] == 1 ) {x = (x|(1<<j));}\\n             }\\n            if(x == 0) { ans.push_back(i); return ans;}\\n            mask[i] = x;\\n            cout<<x;\\n        }\\n            for( int i =0 ; i < m; i++)\\n        {\\n            for( int j =i+1 ; j < m; j++)\\n            {   \\n                int flg = 0;\\n                for( int k = 0; k < n; k++)\\n              {  \\n                  int x = (1<<k);\\n                  if(   ( mask[i]&x ) && ( mask[j]&x )){\\n                      flg = 1;\\n                    break;\\n                }\\n                }\\n                if(flg)continue;\\n                else{\\n                    ans.push_back(i);\\n                    ans.push_back(j);\\n                    return ans;\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid){\\n        \\n        int m = grid.size();\\n        if(m<= 0 ) return {};\\n        vector<int> mask(m , -1);\\n        vector<vector<int>> vis(33, vector<int> (33, 0));\\n        int n = grid[0].size();\\n   \\n        for( int i = 0; i < m; i++)\\n        {\\n            int x =0;\\n            for( int j = 0 ; j < n; j++ )\\n             {\\n                 if( grid[i][j] == 1 ) {x = (x|(1<<j));}\\n             }\\n            if(x == 0) { return {i}; }\\n            mask[i] = x;\\n        }\\n          \\n        for( int i =0 ; i < m; i++)\\n        {\\n              if( mask[i] == (1<<n ) -1)continue;\\n            for( int j =i+1 ; j < m; j++)\\n            {   \\n                if( vis[mask[i]][mask[j]])continue;\\n                int flg = 0;\\n                for( int k = 0; k < n; k++)\\n                {  \\n                     int x = (1<<k);\\n                     if(   ( mask[i]&x ) && ( mask[j]&x )){\\n                         flg = 1;\\n                       break;\\n                    }\\n                }\\n                if(flg){ vis[mask[i]][mask[j]] = 1; continue;    }\\n                else{\\n                  return {i , j};\\n                }  \\n            }\\n        }\\n    \\n    return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid){\\n        \\n        int m = grid.size();\\n      \\n        if(m<= 0 ) return {};\\n        vector<int> mask(33 , -1);\\n        int n = grid[0].size();\\n        int limit = (1<<n ) -1;\\n        // maximum limit of our mask\\n   \\n        for( int i = 0; i < m; i++)\\n        {\\n            int x =0;\\n            for( int j = 0 ; j < n; j++ )\\n             {\\n                 if( grid[i][j] == 1 ) {x = (x|(1<<j));}\\n             }\\n            if(x == 0) { return {i}; }\\n            if( x == limit ) continue;\\n\\n            // if all bits are set then it can not be our answer;\\n\\n            for(int k = 1; k <(limit +1); k++)\\n            {\\n              if( mask[k] != -1 && (  x&k ) == 0 )\\n                 {\\n                     return { mask[k], i};\\n                 }\\n            }\\n            mask[x] = i;\\n        }\\n    return {};\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3645520,
                "title": "brute-force-to-optimal-c",
                "content": "# O(N * N * M)\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        for(int i=0; i<n; i++) {\\n            int cnt = 0;\\n            for(int j=0; j<m; j++) cnt += grid[i][j];\\n            if(!cnt) return {i};\\n            \\n            for(int j=0; j<n; j++) {\\n                int f = 0;\\n                for(int k=0; k<m; k++) {\\n                    if(grid[j][k] + grid[i][k] > 1) {\\n                        f = 1;\\n                        break;\\n                    }\\n                }\\n                if(!f) return {i, j};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\\n\\n# O(N * 2 ^ M)\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        unordered_map<int, int> seen;\\n\\n        for(int i=0; i<n; i++) {\\n            int a = 0;\\n            for(int j=0; j<m; j++) a += grid[i][j] << j;\\n            if(!a) return {i};\\n\\n            for(int j=0; j<(1<<m); j++) {\\n                if(!(j & a) && seen.find(j) != seen.end()) return {seen[j], i};\\n            }\\n            seen[a] = i;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        for(int i=0; i<n; i++) {\\n            int cnt = 0;\\n            for(int j=0; j<m; j++) cnt += grid[i][j];\\n            if(!cnt) return {i};\\n            \\n            for(int j=0; j<n; j++) {\\n                int f = 0;\\n                for(int k=0; k<m; k++) {\\n                    if(grid[j][k] + grid[i][k] > 1) {\\n                        f = 1;\\n                        break;\\n                    }\\n                }\\n                if(!f) return {i, j};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        unordered_map<int, int> seen;\\n\\n        for(int i=0; i<n; i++) {\\n            int a = 0;\\n            for(int j=0; j<m; j++) a += grid[i][j] << j;\\n            if(!a) return {i};\\n\\n            for(int j=0; j<(1<<m); j++) {\\n                if(!(j & a) && seen.find(j) != seen.end()) return {seen[j], i};\\n            }\\n            seen[a] = i;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645172,
                "title": "c-beginner-level-time-o-n-space-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert the binary number to decimal.\\n\\n2. Check if the ```&``` of two numbers is zero or not.\\n```\\n    0 1 0 1 \\n  & 0 0 1 0\\n   ----------\\n    0 0 0 0 \\n```\\n\\n\\n# Complexity\\n- Time complexity: ```O(N)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(N)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& v) {\\n        int n = v.size();\\n        int m = v[0].size();\\n\\n        vector<int> res;\\n\\n        for(int i=0;i<n;i++){\\n            int c = m-1;\\n            int s = 0;\\n            for(int j=m-1;j>=0;j--){\\n                s += (v[i][j] * pow(2,c));\\n                c--;\\n            }\\n            res.push_back(s);\\n        }\\n\\n        if(res[0] == 0) return {0};\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if((res[j] & res[i]) == 0){\\n                    return {i,j};\\n                }\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```&```\n```\\n    0 1 0 1 \\n  & 0 0 1 0\\n   ----------\\n    0 0 0 0 \\n```\n```O(N)```\n```O(N)```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& v) {\\n        int n = v.size();\\n        int m = v[0].size();\\n\\n        vector<int> res;\\n\\n        for(int i=0;i<n;i++){\\n            int c = m-1;\\n            int s = 0;\\n            for(int j=m-1;j>=0;j--){\\n                s += (v[i][j] * pow(2,c));\\n                c--;\\n            }\\n            res.push_back(s);\\n        }\\n\\n        if(res[0] == 0) return {0};\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if((res[j] & res[i]) == 0){\\n                    return {i,j};\\n                }\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642012,
                "title": "easy-o-32-32-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n        int m=grid[0].size();\\n        set<pair<int,int>>s;\\n        for(int i=0;i<n;i++){\\n            int ans=0;\\n            int k=4;\\n            int cnt=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j])ans+=pow(2,k);\\n                if(grid[i][j]==0)cnt++;\\n                k--;\\n            }\\n           s.insert({ans,i});\\n            if(cnt==m)return {i};\\n            \\n        }\\n        \\n        for(auto l:s){\\n            for(auto k:s){\\n                if(l.second!=k.second && (l.first & k.first)==0){\\n                   if(l.second<k.second)return {l.second,k.second};\\n                    else return {k.second,l.second};\\n                 }\\n            }\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n        int m=grid[0].size();\\n        set<pair<int,int>>s;\\n        for(int i=0;i<n;i++){\\n            int ans=0;\\n            int k=4;\\n            int cnt=0;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j])ans+=pow(2,k);\\n                if(grid[i][j]==0)cnt++;\\n                k--;\\n            }\\n           s.insert({ans,i});\\n            if(cnt==m)return {i};\\n            \\n        }\\n        \\n        for(auto l:s){\\n            for(auto k:s){\\n                if(l.second!=k.second && (l.first & k.first)==0){\\n                   if(l.second<k.second)return {l.second,k.second};\\n                    else return {k.second,l.second};\\n                 }\\n            }\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633026,
                "title": "c-easy-bit-manipulation-with-explanation",
                "content": "So Firstly look at the constrains the number of columns are at max 5. Now the idea to return the minimum no of of rows once we get it .We can clearly see if our ans has to contain only one row then all the elements will have to be zero because floor of (1/2) is zero. If we want two rows the sum of col of both rows can be at max 1 because floor of(2/2) is 1. so we have to find the two rows whose & will be zero. For this we create 5 bit integer and store every row.Now 5 bit can atmost be equal to 32.So firstly we iterate from 0 to 31 and then for next loop start from next integer.We check the map we created previously for row values if both are present and & of both rows is zero we add that rows to ans ,sort it and return it.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int>ans;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        map<int,vector<int>>mp;\\n        for(int i=0; i<n; i++){\\n            int curr=0;\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    curr|=1<<j;\\n                }\\n            }\\n            if(curr==0){\\n                cout<<\"2\"<<endl;\\n                ans.push_back(i);\\n                return ans;\\n            }\\n            mp[curr].push_back(i);\\n            \\n        }\\n        for(int i=1; i<32; i++){\\n            for(int j=i+1; j<32; j++){\\n                if((i&j)==0 && mp.find(i)!=mp.end() && mp.find(j)!=mp.end()){\\n                    ans.push_back(mp[i][0]);\\n                    ans.push_back(mp[j][0]);\\n                    sort(ans.begin(),ans.end());\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int>ans;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        map<int,vector<int>>mp;\\n        for(int i=0; i<n; i++){\\n            int curr=0;\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    curr|=1<<j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3623602,
                "title": "c-bitmask-proof",
                "content": "![f3da718b55ccc1ed3494e6615f1db496fd70b0ad.png](https://assets.leetcode.com/users/images/89d4fb3a-8d0f-453b-9f71-7390945c4bb1_1686446600.0925484.png){:width = 500; align=center}\\n\\n\\n\\n# Intuition\\nThe very first intuition is that when we are considering about this question, it is $$\\\\sout{obvious}$$ that every valid solution is built from 0 row to 1 row, then from 1 row to 2 rows and so on, which after some tries we could find that every valid solution satisfies a two-rows approach, or in other words if and only if there are two rows that could satisfies what the question said, then there will be a solution.\\n\\n# Proof\\n1. There is no row with 0 and 1\\nProof: If it exists, it is not handed in to find another\\n\\n2. There is no row with 1\\nProof: If it exists, since any two are intersected, this column is all 1, obviously there is no solution\\n\\n2. There are no rows with 2 1s\\nProof: Suppose the length of this line is like this: 11000, then the other lines are either 10xxx, 01xxx, or 11xxx. It is easy to see that no matter how you choose, the first two columns cannot meet the requirements\\n\\nThen all rows have at least 3 1s.\\n\\nAs the question said, every column can have at most $$\\\\frac{m}{2}$$ 1s, so $$\\\\sum_{m}^{i=0} column_i$$ = 2.5m 1s, but as we initially got 3 1s, it is contradictory.\\n\\nQ.E.D\\n\\n# Complexity\\n$$O(n + m^5)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> GoodSubsetofBinaryMatrix(int[][] grid) {\\n        int n = grid.Length, m = grid[0].Length;\\n        Dictionary<string, int> map = new();\\n        string str = \"\";\\n        for(int i = 0; i < m; i++) str += 0;\\n        for(int i = 0; i < n; i++){\\n            string s = \"\";\\n            for(int j = 0; j < m; j++) s += grid[i][j];\\n            map[s] = i; //pre-process and store the value of each row in a string, and put it into a map\\n        }\\n        if(map.ContainsKey(str)) return new List<int>(new int[]{map[str]}); //pre-process corner case all 0s\\n\\n        //three for loops below is to iterate over all the possible combinations of valid strings\\n        //if m == 1, then only \"0\" satisfies\\n        //if m == 2, it can be (\"00\", \"01\"), (\"00\", \"10\") or so, which when they add up they will form \"01\" and \"10\" respectively, still, the sum of each column is less then 2 / 2 = 1\\n        //if m == 3, it can be (\"001\", \"110\"), (\"010\", \"100\"), (\"001\", \"100\") or so,  as i != 0 && (i ^ j) != 0 (every column sum in a good subset does not exceed 1) then the question will be satisfied\\n        //if m == 4, it can be(\"0100\", \"0010\"), (\"1100\", \"0011\"), (\"1000\", \"0001\") and so on\\n        //if m == 5, if can be(\"00100\", \"11000\"), (\"01100\", \"00001\"), (\"11010\", \"00101\") and so on\\n\\n        for(int i = 0; i < 1 << m; i++){ //bitmask, it will cover all the possible combinations for each string\\n            for(int j = 0; j < 1 << m; j++){\\n                int bit = 0;\\n                for(int k = 0; k < m; k++){\\n                    if(((i >> k) & 1) == 1 && (((j >> k) & 1) == 1)) bit += 114514; //two 1\\'s in the same column, just add some random numbers to eliminate this combination in the next conditional\\n                    else bit += 1;\\n                } //if there are two 1\\'s in the same column, condition does not match\\n                if(bit <= m){ //if the combination satisfies that the sum of each column is satisfied, then check whether the map contains these two strings or not\\n                    string s1 = Convert.ToString(i, 2), s2 = Convert.ToString(j, 2);\\n                    while(s1.Length != m) s1 = \"0\" + s1;\\n                    while(s2.Length != m) s2 = \"0\" + s2; //fill the 0s until it has the same length as m\\n                    if(map.ContainsKey(s1) && map.ContainsKey(s2)){ //if it does, then return (remember to sort it)\\n                        List<int> ysy = new(new int[]{map[s1], map[s2]});\\n                        ysy.Sort();\\n                        return ysy;\\n                    }\\n                }\\n            }\\n        }\\n        return new List<int>();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> GoodSubsetofBinaryMatrix(int[][] grid) {\\n        int n = grid.Length, m = grid[0].Length;\\n        Dictionary<string, int> map = new();\\n        string str = \"\";\\n        for(int i = 0; i < m; i++) str += 0;\\n        for(int i = 0; i < n; i++){\\n            string s = \"\";\\n            for(int j = 0; j < m; j++) s += grid[i][j];\\n            map[s] = i; //pre-process and store the value of each row in a string, and put it into a map\\n        }\\n        if(map.ContainsKey(str)) return new List<int>(new int[]{map[str]}); //pre-process corner case all 0s\\n\\n        //three for loops below is to iterate over all the possible combinations of valid strings\\n        //if m == 1, then only \"0\" satisfies\\n        //if m == 2, it can be (\"00\", \"01\"), (\"00\", \"10\") or so, which when they add up they will form \"01\" and \"10\" respectively, still, the sum of each column is less then 2 / 2 = 1\\n        //if m == 3, it can be (\"001\", \"110\"), (\"010\", \"100\"), (\"001\", \"100\") or so,  as i != 0 && (i ^ j) != 0 (every column sum in a good subset does not exceed 1) then the question will be satisfied\\n        //if m == 4, it can be(\"0100\", \"0010\"), (\"1100\", \"0011\"), (\"1000\", \"0001\") and so on\\n        //if m == 5, if can be(\"00100\", \"11000\"), (\"01100\", \"00001\"), (\"11010\", \"00101\") and so on\\n\\n        for(int i = 0; i < 1 << m; i++){ //bitmask, it will cover all the possible combinations for each string\\n            for(int j = 0; j < 1 << m; j++){\\n                int bit = 0;\\n                for(int k = 0; k < m; k++){\\n                    if(((i >> k) & 1) == 1 && (((j >> k) & 1) == 1)) bit += 114514; //two 1\\'s in the same column, just add some random numbers to eliminate this combination in the next conditional\\n                    else bit += 1;\\n                } //if there are two 1\\'s in the same column, condition does not match\\n                if(bit <= m){ //if the combination satisfies that the sum of each column is satisfied, then check whether the map contains these two strings or not\\n                    string s1 = Convert.ToString(i, 2), s2 = Convert.ToString(j, 2);\\n                    while(s1.Length != m) s1 = \"0\" + s1;\\n                    while(s2.Length != m) s2 = \"0\" + s2; //fill the 0s until it has the same length as m\\n                    if(map.ContainsKey(s1) && map.ContainsKey(s2)){ //if it does, then return (remember to sort it)\\n                        List<int> ysy = new(new int[]{map[s1], map[s2]});\\n                        ysy.Sort();\\n                        return ysy;\\n                    }\\n                }\\n            }\\n        }\\n        return new List<int>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623335,
                "title": "python-3-o-m-2-n-o-32m",
                "content": "Key observations:\\n1. There are only 2^n <= 2^5 = 32 possible values for the rows.\\n2. If there are more than 2 good rows, then there are 2 good rows.  This is easy to see, if `2k` or `2k+1` rows sum to k or less, then some subset of `2k-2` of them sum to `k-1` or less.  Inductively reduce until there are 1-2 rows left.  \\n3. If one row is a good subset itself then it sums to 0.  \\n  \\n  So we proceed by converting each row to a bitmap sum bm.\\nIf the sum is 0 return that row itself.\\nIf not then look for another row which is bitmap disjoint from bm.\\nThere are at most 32 keys to check so complexity is `O(m*32)`, or technically `O(m*2^n)` with `n<=5`.\\n\\n```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        G = {}\\n        \\n        for ind,g in enumerate(grid):\\n            bm = sum(1<<i for i,x in enumerate(grid[ind]) if grid[ind][i])\\n            if bm==0: return [ind]\\n            \\n            for k in G:\\n                if bm&k==0: return [G[k],ind]\\n                \\n            G[x]=ind\\n\\n        return []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        G = {}\\n        \\n        for ind,g in enumerate(grid):\\n            bm = sum(1<<i for i,x in enumerate(grid[ind]) if grid[ind][i])\\n            if bm==0: return [ind]\\n            \\n            for k in G:\\n                if bm&k==0: return [G[k],ind]\\n                \\n            G[x]=ind\\n\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622509,
                "title": "bitmask-o-m-2-4-i-e-only-16-searches-for-each-row",
                "content": "Its hard to explain but you have to observe that if Good Subset is possible in a matrix, then it can be formed by just 2 rows. Its a difficult observation, and requires **inductive proof starting from 2 columns**.\\nOnce, you know this fact, then for any current row you can try searching a hashmap with all different combinations which has 0 atleast at places where current row doesn\\'t have. If found, Voila!\\nThe key was that **n is very small** so different combination is also **max 2^4**(not even 2^5 as you won\\'t initiate search for all 1 row, and make sure if you encounter all 0 row, just return that row). And you always **only need max 2 rows**, if solution exists.\\nI used string instead of int for bitmasking as I was hurry during the contest, so didn\\'t realize that n = 5 will fit int.\\n```\\nclass Solution {\\n    vector<int> ans;\\n    void find(string y, unordered_map<string, int> &ump, int i, int tar){\\n        for(int k = i; k <y.size(); k++){\\n            if(y[k] == \\'1\\'){\\n                y[k] = \\'0\\';\\n                if(ump.find(y) != ump.end()){\\n                    ans = {ump[y], tar};\\n                    return;\\n                }\\n                find(y, ump, k + 1, tar);\\n                if(ans.size() != 0) return;\\n                y[k] = \\'1\\';\\n            }\\n        }\\n    }\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        ans = {};\\n        string x, y;\\n        unordered_map<string, int> ump;\\n        int flag;\\n        for(int i = 0; i < grid.size(); i++){\\n            x = \"\";\\n            y = \"\";\\n            flag = 0;\\n            for(int j = 0; j < grid[0].size(); j++){\\n                x.push_back(\\'0\\' + grid[i][j]);\\n                y.push_back(\\'0\\' + grid[i][j]^1);\\n                flag += grid[i][j];\\n            }\\n            if(flag == 0) return {i};\\n            if(flag == grid[0].size()) continue;\\n            if(ump.find(y) != ump.end()) return {ump[y], i};\\n            find(y, ump, 0, i);\\n            if(ans.size() != 0) break;\\n            ump[x] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> ans;\\n    void find(string y, unordered_map<string, int> &ump, int i, int tar){\\n        for(int k = i; k <y.size(); k++){\\n            if(y[k] == \\'1\\'){\\n                y[k] = \\'0\\';\\n                if(ump.find(y) != ump.end()){\\n                    ans = {ump[y], tar};\\n                    return;\\n                }\\n                find(y, ump, k + 1, tar);\\n                if(ans.size() != 0) return;\\n                y[k] = \\'1\\';\\n            }\\n        }\\n    }\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        ans = {};\\n        string x, y;\\n        unordered_map<string, int> ump;\\n        int flag;\\n        for(int i = 0; i < grid.size(); i++){\\n            x = \"\";\\n            y = \"\";\\n            flag = 0;\\n            for(int j = 0; j < grid[0].size(); j++){\\n                x.push_back(\\'0\\' + grid[i][j]);\\n                y.push_back(\\'0\\' + grid[i][j]^1);\\n                flag += grid[i][j];\\n            }\\n            if(flag == 0) return {i};\\n            if(flag == grid[0].size()) continue;\\n            if(ump.find(y) != ump.end()) return {ump[y], i};\\n            find(y, ump, 0, i);\\n            if(ans.size() != 0) break;\\n            ump[x] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622500,
                "title": "simple-solution-using-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs there are m columns only there are 2^m possible rows possible\\nand 1<=m<=5  so there are at most 32 possible combinations.\\n\\nThere is only need for either one row or two row;\\ncase of only one row when all the elements are 0 -> hash is 0;\\n\\nThe case of choosing two possible:\\nWe choose the two which has bitwise and of hash equal to 0 only then it is possible.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        map<int,int>ans;//hash,index\\n        //I store only one index corresponding to one hash value\\n        int n = grid.size(),m = grid[0].size();\\n        for(int i = 0;i<n;i++){\\n            int curr = 0;\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    int num = pow(2,j);\\n                    curr = (curr|num);\\n                }\\n            }\\n            if(curr == 0){\\n                //index with hash = 0\\n                return {i};\\n            }\\n            ans[curr] = i;\\n        }\\n        vector<int>pos;\\n        for(auto e:ans)pos.push_back(e.first);\\n        //for generating pairs to two i push them in vector and apply brute force;\\n        vector<int>anss;\\n        for(int i = 0;i<pos.size();i++){\\n            for(int j = i + 1;j<pos.size();j++){\\n                if((pos[i] & pos[j]) == 0){\\n                    //and is 0 and is one possible solution;\\n                    anss.push_back(ans[pos[i]]);\\n                    anss.push_back(ans[pos[j]]);\\n                    sort(anss.begin(),anss.end());\\n                    return anss;\\n                }\\n            }\\n        }\\n        return anss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        map<int,int>ans;//hash,index\\n        //I store only one index corresponding to one hash value\\n        int n = grid.size(),m = grid[0].size();\\n        for(int i = 0;i<n;i++){\\n            int curr = 0;\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    int num = pow(2,j);\\n                    curr = (curr|num);\\n                }\\n            }\\n            if(curr == 0){\\n                //index with hash = 0\\n                return {i};\\n            }\\n            ans[curr] = i;\\n        }\\n        vector<int>pos;\\n        for(auto e:ans)pos.push_back(e.first);\\n        //for generating pairs to two i push them in vector and apply brute force;\\n        vector<int>anss;\\n        for(int i = 0;i<pos.size();i++){\\n            for(int j = i + 1;j<pos.size();j++){\\n                if((pos[i] & pos[j]) == 0){\\n                    //and is 0 and is one possible solution;\\n                    anss.push_back(ans[pos[i]]);\\n                    anss.push_back(ans[pos[j]]);\\n                    sort(anss.begin(),anss.end());\\n                    return anss;\\n                }\\n            }\\n        }\\n        return anss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622398,
                "title": "o-mlogm-2-2-n-c-easy-solution-brute-on-unique-rows",
                "content": "As n<=5 we can convert each row as binary number and can convert it to decimal number. There will be only few number as n<=5.\\nCase 1. If any rows is complete zero then we can return it as our answer.\\nCase 2. We Consider only unqiue rows and try to find such pairs of rows such that no to rows have one at the same location.\\n```\\nvector<int> goodSubsetofBinaryMatrix(vector<vector<int>> &grid)\\n{\\n    set<int> nums;\\n    int n = grid.size(), m = grid[0].size();\\n    vector<vector<int>> helper;\\n    vector<int> indx;\\n    for (int i = 0; i < n; i++)\\n    {\\n        int num = 0;\\n        for (int j = 0; j < m; j++)\\n        {\\n            if (grid[i][j])\\n                num |= (1 << (m - j - 1));\\n        }\\n        if (num == 0)\\n            return {i};\\n\\t\\t// unique rows to new helper grid\\n        if (!nums.count(num))\\n        {\\n            helper.push_back(grid[i]);\\n            indx.push_back(i);\\n        }\\n        nums.insert(num);\\n    }\\n\\t// finding the pairs that satisfies the condition\\n    for (int i = 0; i < helper.size(); i++)\\n    {\\n        for (int j = i + 1; j < helper.size(); j++)\\n        {\\n            int cntr = 0;\\n            for (int k = 0; k < m; k++)\\n            {\\n                if (helper[i][k] == 1 && helper[j][k] == 1)\\n                    continue;\\n                cntr++;\\n            }\\n            if (cntr == m)\\n                return {indx[i], indx[j]};\\n        }\\n    }\\n    return {};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> goodSubsetofBinaryMatrix(vector<vector<int>> &grid)\\n{\\n    set<int> nums;\\n    int n = grid.size(), m = grid[0].size();\\n    vector<vector<int>> helper;\\n    vector<int> indx;\\n    for (int i = 0; i < n; i++)\\n    {\\n        int num = 0;\\n        for (int j = 0; j < m; j++)\\n        {\\n            if (grid[i][j])\\n                num |= (1 << (m - j - 1));\\n        }\\n        if (num == 0)\\n            return {i};\\n\\t\\t// unique rows to new helper grid\\n        if (!nums.count(num))\\n        {\\n            helper.push_back(grid[i]);\\n            indx.push_back(i);\\n        }\\n        nums.insert(num);\\n    }\\n\\t// finding the pairs that satisfies the condition\\n    for (int i = 0; i < helper.size(); i++)\\n    {\\n        for (int j = i + 1; j < helper.size(); j++)\\n        {\\n            int cntr = 0;\\n            for (int k = 0; k < m; k++)\\n            {\\n                if (helper[i][k] == 1 && helper[j][k] == 1)\\n                    continue;\\n                cntr++;\\n            }\\n            if (cntr == m)\\n                return {indx[i], indx[j]};\\n        }\\n    }\\n    return {};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979936,
                "title": "clean-submask-dp-greedy",
                "content": "approach is bit logical, you\\'ll get if you think about it for some time, but implimentation is standarad submasking\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        map<int,int> m;\\n        auto convert_to_int=[](vector<int> &g){\\n            int r=0;\\n            for(int x=0;x<g.size();x++){\\n                if(g[x])\\n                    r|=(1<<x);\\n            }\\n            return r;\\n        };\\n        for(int x=0;x<grid.size();x++){\\n            int r=convert_to_int(grid[x]);\\n            if(r==0)\\n                return {x};\\n            int inv=r^((1<<grid[0].size())-1);\\n            for(int s=inv;s;s=inv&(s-1)){\\n                if(m[s]>0){\\n                    return {m[s]-1,x};\\n                }\\n            }\\n            m[r]=x+1;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        map<int,int> m;\\n        auto convert_to_int=[](vector<int> &g){\\n            int r=0;\\n            for(int x=0;x<g.size();x++){\\n                if(g[x])\\n                    r|=(1<<x);\\n            }\\n            return r;\\n        };\\n        for(int x=0;x<grid.size();x++){\\n            int r=convert_to_int(grid[x]);\\n            if(r==0)\\n                return {x};\\n            int inv=r^((1<<grid[0].size())-1);\\n            for(int s=inv;s;s=inv&(s-1)){\\n                if(m[s]>0){\\n                    return {m[s]-1,x};\\n                }\\n            }\\n            m[r]=x+1;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863078,
                "title": "python-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**since we just need to find good subset therefore**\\n    **2 possibilities:-**\\n        i)  ***good subset of length 1 (case1):-***  ie row with every element equal to 0.\\n        ii)***good subset of length 2 (case2):-*** \\n            if we find inverted_row for current row i.e elements in current_row[i]=1^inverted_row[i] . this condition need to be true only for elements equal to 1 \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will use trie structure to optimize the bruteforce.\\n# Code\\n```\\nclass node:\\n    def __init__(self):\\n        self.next=defaultdict(node)\\n        self.end=[]\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        def bt(cur,pt,i=0):\\n            if(i>=len(pt)):return cur.end\\n            if(pt[i]==1):\\n                ps=[]\\n                # will give us all the possiblities \\n                if(1 in cur.next):ps.extend(bt(cur.next[1],pt,i+1))\\n                if(0 in cur.next):ps.extend(bt(cur.next[0],pt,i+1))\\n                return ps\\n            else:\\n                return bt(cur.next[0],pt,i+1)\\n        d=defaultdict(node)\\n        d[-1]=node()\\n        #case:-2\\n        for i in range(len(grid)):\\n            cur=d[-1]\\n            atf=[]\\n            for j in grid[i]:\\n                atf.append(1^j)\\n                cur=cur.next[j]\\n            pt=bt(d[-1],atf)\\n            if(pt):\\n                for j in pt:\\n                    if(i!=j):return [j,i]\\n            cur.end.append(i)\\n        # case:-1\\n        cur=d[-1]\\n        for j in range(0,len(grid[0])):\\n            if(0 in cur.next):cur=cur.next[0]\\n        return cur.end\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass node:\\n    def __init__(self):\\n        self.next=defaultdict(node)\\n        self.end=[]\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        def bt(cur,pt,i=0):\\n            if(i>=len(pt)):return cur.end\\n            if(pt[i]==1):\\n                ps=[]\\n                # will give us all the possiblities \\n                if(1 in cur.next):ps.extend(bt(cur.next[1],pt,i+1))\\n                if(0 in cur.next):ps.extend(bt(cur.next[0],pt,i+1))\\n                return ps\\n            else:\\n                return bt(cur.next[0],pt,i+1)\\n        d=defaultdict(node)\\n        d[-1]=node()\\n        #case:-2\\n        for i in range(len(grid)):\\n            cur=d[-1]\\n            atf=[]\\n            for j in grid[i]:\\n                atf.append(1^j)\\n                cur=cur.next[j]\\n            pt=bt(d[-1],atf)\\n            if(pt):\\n                for j in pt:\\n                    if(i!=j):return [j,i]\\n            cur.end.append(i)\\n        # case:-1\\n        cur=d[-1]\\n        for j in range(0,len(grid[0])):\\n            if(0 in cur.next):cur=cur.next[0]\\n        return cur.end\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803201,
                "title": "python-o-h-2-w",
                "content": "# Complexity\\n$$ O(h * 2^w) $$ where h is height of the matrix while w is width of the matrix, 2^w is at most 32 because w <= 5\\n\\n# Code\\n```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        h, w = len(grid), len(grid[0])\\n        idx_of_pattern = defaultdict(int)\\n        for row_idx in range(len(grid)):\\n            num = 0\\n            p = 1\\n            for x in reversed(grid[row_idx]):\\n                num += x * p\\n                p *= 2\\n            if num == 0:\\n                return [row_idx]\\n            for pattern in range(2 ** w):\\n                if (num & pattern == 0) and pattern in idx_of_pattern:\\n                    return [idx_of_pattern[pattern], row_idx]\\n            idx_of_pattern[num] = row_idx\\n        return []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        h, w = len(grid), len(grid[0])\\n        idx_of_pattern = defaultdict(int)\\n        for row_idx in range(len(grid)):\\n            num = 0\\n            p = 1\\n            for x in reversed(grid[row_idx]):\\n                num += x * p\\n                p *= 2\\n            if num == 0:\\n                return [row_idx]\\n            for pattern in range(2 ** w):\\n                if (num & pattern == 0) and pattern in idx_of_pattern:\\n                    return [idx_of_pattern[pattern], row_idx]\\n            idx_of_pattern[num] = row_idx\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800787,
                "title": "py-striving-for-the-shortest-4-lines",
                "content": "# Approach\\nAssume each row is a binary number, then find two rows r1, r2 such that dec(r1) & dec(r2) = 0\\n\\n# Code\\n```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        d = dict()\\n        for (i, r) in enumerate(grid): d[functools.reduce(lambda t, v: t + (v[1]<<v[0]), enumerate(reversed(r)), 0)] = i\\n        return ([[d[0]] if 0 in d else []]+[sorted([d[i], d[j]]) for j in d for i in d if i & j == 0 and i != j])[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        d = dict()\\n        for (i, r) in enumerate(grid): d[functools.reduce(lambda t, v: t + (v[1]<<v[0]), enumerate(reversed(r)), 0)] = i\\n        return ([[d[0]] if 0 in d else []]+[sorted([d[i], d[j]]) for j in d for i in d if i & j == 0 and i != j])[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665459,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid):\\n        m, dict1, dict2 = len(grid), defaultdict(list), defaultdict(list)\\n\\n        for i in range(32):\\n            for j in range(32):\\n                if i&j == 0:\\n                    dict1[i].append(j)\\n\\n        for i in range(m):\\n            val = int(\"\".join([str(j) for j in grid[i]]),2)\\n            if val == 0: return [i]\\n            for c in dict1[val]:\\n                if c in dict2:\\n                    return sorted([dict2[c][0],i])\\n                dict2[val].append(i)\\n\\n        return []\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid):\\n        m, dict1, dict2 = len(grid), defaultdict(list), defaultdict(list)\\n\\n        for i in range(32):\\n            for j in range(32):\\n                if i&j == 0:\\n                    dict1[i].append(j)\\n\\n        for i in range(m):\\n            val = int(\"\".join([str(j) for j in grid[i]]),2)\\n            if val == 0: return [i]\\n            for c in dict1[val]:\\n                if c in dict2:\\n                    return sorted([dict2[c][0],i])\\n                dict2[val].append(i)\\n\\n        return []\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664651,
                "title": "c-bit-manipulation-solution-o-m-2-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<int>record(32,-1);\\n        for(int i=0;i<m;i++)\\n        {\\n            int tot=0;\\n            for(int j=0;j<n;j++)if(grid[i][j])tot+=(1<<j);\\n            record[tot]=i;\\n        }\\n        if(record[0]!=-1)return {record[0]};\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            if(record[i]==-1)continue;\\n            for(int j=0;j<(1<<n);j++)\\n            {\\n                if((i+j)!=(i|j))continue;\\n                if(record[j]==-1)continue;\\n                int idx1=min(record[j],record[i]);\\n                int idx2=max(record[j],record[i]);\\n                return {idx1,idx2};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<int>record(32,-1);\\n        for(int i=0;i<m;i++)\\n        {\\n            int tot=0;\\n            for(int j=0;j<n;j++)if(grid[i][j])tot+=(1<<j);\\n            record[tot]=i;\\n        }\\n        if(record[0]!=-1)return {record[0]};\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            if(record[i]==-1)continue;\\n            for(int j=0;j<(1<<n);j++)\\n            {\\n                if((i+j)!=(i|j))continue;\\n                if(record[j]==-1)continue;\\n                int idx1=min(record[j],record[i]);\\n                int idx2=max(record[j],record[i]);\\n                return {idx1,idx2};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657991,
                "title": "solution-in-kotlin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun goodSubsetofBinaryMatrix(grid: Array<IntArray>): List<Int> {\\n        val m = grid.size\\n        val n = grid[0].size\\n\\n        if (m == 1 && grid[0].sum() == 0) {\\n            return listOf(0)\\n        }\\n\\n        val pos = mutableMapOf<Int, Int>()\\n\\n        for (i in grid.indices) {\\n            for (mask in 0 until (1 shl n)) {\\n                var valid = true\\n                for (j in 0 until n) {\\n                    if ((mask and (1 shl j)) != 0 && grid[i][j] + 1 > 1) {\\n                        valid = false\\n                        break\\n                    }\\n                }\\n                if (valid && mask in pos) {\\n                    return listOf(pos[mask]!!, i)\\n                }\\n            }\\n\\n            var curr = 0\\n            for (j in 0 until n) {\\n                if (grid[i][j] == 1) {\\n                    curr = curr or (1 shl j)\\n                }\\n            }\\n            pos[curr] = i\\n        }\\n\\n        return emptyList()\\n    }\\n}\\n\\nfun main() {\\n    val solution = Solution()\\n    val grid = arrayOf(\\n        intArrayOf(0, 1, 1, 0),\\n        intArrayOf(0, 0, 0, 1),\\n        intArrayOf(1, 1, 1, 1)\\n    )\\n    val result = solution.goodSubsetofBinaryMatrix(grid)\\n    println(result)\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun goodSubsetofBinaryMatrix(grid: Array<IntArray>): List<Int> {\\n        val m = grid.size\\n        val n = grid[0].size\\n\\n        if (m == 1 && grid[0].sum() == 0) {\\n            return listOf(0)\\n        }\\n\\n        val pos = mutableMapOf<Int, Int>()\\n\\n        for (i in grid.indices) {\\n            for (mask in 0 until (1 shl n)) {\\n                var valid = true\\n                for (j in 0 until n) {\\n                    if ((mask and (1 shl j)) != 0 && grid[i][j] + 1 > 1) {\\n                        valid = false\\n                        break\\n                    }\\n                }\\n                if (valid && mask in pos) {\\n                    return listOf(pos[mask]!!, i)\\n                }\\n            }\\n\\n            var curr = 0\\n            for (j in 0 until n) {\\n                if (grid[i][j] == 1) {\\n                    curr = curr or (1 shl j)\\n                }\\n            }\\n            pos[curr] = i\\n        }\\n\\n        return emptyList()\\n    }\\n}\\n\\nfun main() {\\n    val solution = Solution()\\n    val grid = arrayOf(\\n        intArrayOf(0, 1, 1, 0),\\n        intArrayOf(0, 0, 0, 1),\\n        intArrayOf(1, 1, 1, 1)\\n    )\\n    val result = solution.goodSubsetofBinaryMatrix(grid)\\n    println(result)\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656151,
                "title": "c-easy-solution-you-know-this-already-they-just-have-played-with-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntreat a particular row as numbers and they are given in binary format\\nfirst make them, their original decimal value numbers, and mark every number as visited ,fine right?? second step ,\\n\\n **you have to observe that is any value is 0 , in all those numbers just return its index; second -> if you have a subset ans of size >= 2 , then it is always possible that you have subset of size == 2 as your answer: trust me or just prove yourself :)** \\n\\nso just select a row , lets say its binary representation is 10001 , as max this size can be 5 right , so generate all those strings which have 0 where my orginal string have 1 and 0 or 1 where my original string have 0 , got it right? let me show;\\n\\nlet say my current binary string is 100 so i will generate \\n\\n010\\n000\\n011\\n001\\n\\nand for all these generated string just see, if their decimal representation is already present in your hash map , is yes then return currrow and the index of this ansstring which you find in your hash map\\n\\n**read the code you will understand everything**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int bin(string n)\\n{\\n    string num = n;\\n    int dec_value = 0;\\n \\n    // Initializing base value to 1, i.e 2^0\\n    int base = 1;\\n \\n    int len = num.length();\\n    for (int i = len - 1; i >= 0; i--) {\\n        if (num[i] == \\'1\\')\\n            dec_value += base;\\n        base = base * 2;\\n    }\\n \\n    return dec_value;\\n}\\n    \\n void generateStrings(string& original,string current, int index, set<string>& result) {\\n    if (index == original.length()) {\\n        result.insert(current);\\n        return;\\n    }\\n\\n    if (original[index] == \\'1\\')\\n    {\\n        generateStrings(original, current + \\'0\\', index + 1, result);\\n    }\\nelse { \\n    generateStrings(original, current + \\'1\\', index + 1, result);\\n     generateStrings(original, current + \\'0\\', index + 1, result);\\n}\\n     \\n}\\n    \\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        map<int,int>m1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i =0 ; i <n;i++){\\n            string s = \"\";\\n            for(int j =0 ; j<m;j++){\\n                char d = \\'0\\' + grid[i][j];\\n                s += d;\\n            }\\n            int val = bin(s);\\n            m1[val]  = i;\\n        }\\n        vector<int>ans;\\n       \\n         for(int i = 0 ; i <n;i++)\\n         {\\n            string s = \"\";\\n            for(int j =0 ; j<m;j++)\\n            {\\n                char d = \\'0\\' + grid[i][j];\\n                s += d;\\n            }\\n             \\n             set<string>res;\\n             int val= bin(s);\\n             \\n             if(val==0){\\n                 ans.push_back(i);\\n                 return ans;\\n             }\\n             \\n             generateStrings(s,\"\",0,res);\\n            \\n             for(auto &k:res)\\n             {\\n                 int val = bin(k);\\n                 cout<<k<<\" \";\\n                 if(m1.find(val)!=m1.end())\\n                 {\\n                     ans.push_back(i);\\n                     ans.push_back(m1[val]);\\n                     sort(ans.begin(),ans.end());\\n                     return ans;\\n                 }\\n                 \\n             }\\n             cout<<endl;\\n             \\n        }\\n        \\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int bin(string n)\\n{\\n    string num = n;\\n    int dec_value = 0;\\n \\n    // Initializing base value to 1, i.e 2^0\\n    int base = 1;\\n \\n    int len = num.length();\\n    for (int i = len - 1; i >= 0; i--) {\\n        if (num[i] == \\'1\\')\\n            dec_value += base;\\n        base = base * 2;\\n    }\\n \\n    return dec_value;\\n}\\n    \\n void generateStrings(string& original,string current, int index, set<string>& result) {\\n    if (index == original.length()) {\\n        result.insert(current);\\n        return;\\n    }\\n\\n    if (original[index] == \\'1\\')\\n    {\\n        generateStrings(original, current + \\'0\\', index + 1, result);\\n    }\\nelse { \\n    generateStrings(original, current + \\'1\\', index + 1, result);\\n     generateStrings(original, current + \\'0\\', index + 1, result);\\n}\\n     \\n}\\n    \\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        map<int,int>m1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i =0 ; i <n;i++){\\n            string s = \"\";\\n            for(int j =0 ; j<m;j++){\\n                char d = \\'0\\' + grid[i][j];\\n                s += d;\\n            }\\n            int val = bin(s);\\n            m1[val]  = i;\\n        }\\n        vector<int>ans;\\n       \\n         for(int i = 0 ; i <n;i++)\\n         {\\n            string s = \"\";\\n            for(int j =0 ; j<m;j++)\\n            {\\n                char d = \\'0\\' + grid[i][j];\\n                s += d;\\n            }\\n             \\n             set<string>res;\\n             int val= bin(s);\\n             \\n             if(val==0){\\n                 ans.push_back(i);\\n                 return ans;\\n             }\\n             \\n             generateStrings(s,\"\",0,res);\\n            \\n             for(auto &k:res)\\n             {\\n                 int val = bin(k);\\n                 cout<<k<<\" \";\\n                 if(m1.find(val)!=m1.end())\\n                 {\\n                     ans.push_back(i);\\n                     ans.push_back(m1[val]);\\n                     sort(ans.begin(),ans.end());\\n                     return ans;\\n                 }\\n                 \\n             }\\n             cout<<endl;\\n             \\n        }\\n        \\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3636437,
                "title": "c-solution-bit-manipulation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> ans, temp;\\n        \\n        for(auto i: grid) {\\n            int Or = 0;\\n            for(int j = 0; j < m; j++)  \\n                Or |= (i[j] << j);\\n            temp.push_back(Or);\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            if(temp[i] == 0) // means or is zero and it is a good subset\\n                return {i};\\n            \\n            for(int j = i + 1; j < n; j++) {\\n                // if and of temp[i] and temp[j] == 0 then it is a good subset means sum of every column if less than i + 1 / 2;\\n                if((temp[i] & temp[j]) == 0) \\n                    return {i, j};\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> ans, temp;\\n        \\n        for(auto i: grid) {\\n            int Or = 0;\\n            for(int j = 0; j < m; j++)  \\n                Or |= (i[j] << j);\\n            temp.push_back(Or);\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            if(temp[i] == 0) // means or is zero and it is a good subset\\n                return {i};\\n            \\n            for(int j = i + 1; j < n; j++) {\\n                // if and of temp[i] and temp[j] == 0 then it is a good subset means sum of every column if less than i + 1 / 2;\\n                if((temp[i] & temp[j]) == 0) \\n                    return {i, j};\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636242,
                "title": "most-different-way-o-m-x-n-bit-form-easy-explaination-optimal-approach",
                "content": "# Intuition\\n INTUITION : we see by question that subset of rows can be anything [0,1],[0,3] , [0,1,2] ..\\n\\n anything .... so by going on for one row to every other row and calculate the sum of there columns and then check they are less than floor(k/2) or not ____> is very time comsuming \\n     \\n* so we take a scenerio where we check that instead of taking 3,4 rows as subset \\n\\n * we take 2 rows to check if they have condition to match or not\\n\\n * we see that two rows are enough by these constraints (col == 5)\\nnow to use different method to sum columns ---> we see they are binary no so\\n\\n* if one is 0 other can be anything (1,0)  : \\n\\n* if one no is 1 other must be 0  --> but sum not greater than 1 for subset length = 3\\n\\n# Approach\\n\\n## now we see add them is tough so we take \" and \" operation to get the no is giving 0 because of presenting one zero in both digits to satisfy the condition\\n\\n# now to make time less we see columns are just 5 so decimal representation of one row is just in bet\\n\\n* ---------> (0,31)  and \\nused map to contain the values used after....\\nwe calculate no from each row and if no itself == 0 return index of that no if that  no is not zero  we go to check that (no & j ) ==0  if giving zero  and that j is encountered before cotained in map \\n    -----> then i got ans and move both index in array and return    \\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m x n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        unordered_map<int,int> mp;\\n\\n        for(int i =0 ;i < m ;i++)\\n        {\\n            int val =0;\\n            for(int j=0 ; j< n ;j++)\\n            {\\n                if(grid[i][j])\\n                    val += (1 << j);\\n            } \\n\\n            if(val == 0)\\n                return {i};\\n        \\n            for(int j=1 ; j < 32; j++)\\n            {\\n                if((val & j)== 0 and mp.count(j))\\n                    return {mp[j],i};\\n            }\\n            \\n            mp[val] = i ;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        unordered_map<int,int> mp;\\n\\n        for(int i =0 ;i < m ;i++)\\n        {\\n            int val =0;\\n            for(int j=0 ; j< n ;j++)\\n            {\\n                if(grid[i][j])\\n                    val += (1 << j);\\n            } \\n\\n            if(val == 0)\\n                return {i};\\n        \\n            for(int j=1 ; j < 32; j++)\\n            {\\n                if((val & j)== 0 and mp.count(j))\\n                    return {mp[j],i};\\n            }\\n            \\n            mp[val] = i ;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634996,
                "title": "simple-python-solution-o-n-time-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the matrix consists on binary values we can convert each row into an integer and find a complement row such that their bitwise \\'&\\' operation will be 0\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore a map for all complements for numbers 1 to 32 (As max number of cols is 5 and 2^5 = 32)\\nFor each row, convert to integer return [index] if value is zero\\nElse find any of its and complement and return the pair\\n\\nThis will suffice since we have to find any valid set\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) N=num of rows, as max cols is 5 not considered into time comp\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        rows = defaultdict(list)\\n        and_0 = defaultdict(list)\\n        for i in range(32):\\n            for j in range(32):\\n                if i&j==0:\\n                    and_0[i].append(j)\\n        for i in range(len(grid)):\\n            bin_ = \\'\\'.join(map(str,grid[i]))\\n            val = int(bin_,2)\\n            if val==0: return [i]\\n            for c in and_0[val]:\\n                if c in rows:\\n                    return sorted([rows[c][0],i])\\n            rows[val].append(i)\\n        return []\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        rows = defaultdict(list)\\n        and_0 = defaultdict(list)\\n        for i in range(32):\\n            for j in range(32):\\n                if i&j==0:\\n                    and_0[i].append(j)\\n        for i in range(len(grid)):\\n            bin_ = \\'\\'.join(map(str,grid[i]))\\n            val = int(bin_,2)\\n            if val==0: return [i]\\n            for c in and_0[val]:\\n                if c in rows:\\n                    return sorted([rows[c][0],i])\\n            rows[val].append(i)\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633312,
                "title": "c-bitmask-clean-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        map<int,int> nums;\\n        for (int i=0; i< grid.size();i++){\\n            int cur = 0;\\n            for (int j=0; j< grid[0].size();j++){\\n                cur = cur | (grid[i][j]<< j);\\n            }\\n            if (cur ==0) return {i};\\n            nums.emplace(cur,i);\\n        }\\n        vector<pair<int,int>> v;\\n        for (auto &e:nums) v.push_back({e.first,e.second});\\n        for (int i=0; i< v.size();i++){\\n            for (int j=i+1; j< v.size();j++){\\n                if ((v[i].first & v[j].first)==0){\\n                    vector<int> ans = {v[i].second,v[j].second};\\n                    sort(ans.begin(),ans.end());\\n                    return ans;\\n                } \\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        map<int,int> nums;\\n        for (int i=0; i< grid.size();i++){\\n            int cur = 0;\\n            for (int j=0; j< grid[0].size();j++){\\n                cur = cur | (grid[i][j]<< j);\\n            }\\n            if (cur ==0) return {i};\\n            nums.emplace(cur,i);\\n        }\\n        vector<pair<int,int>> v;\\n        for (auto &e:nums) v.push_back({e.first,e.second});\\n        for (int i=0; i< v.size();i++){\\n            for (int j=i+1; j< v.size();j++){\\n                if ((v[i].first & v[j].first)==0){\\n                    vector<int> ans = {v[i].second,v[j].second};\\n                    sort(ans.begin(),ans.end());\\n                    return ans;\\n                } \\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632276,
                "title": "c-simple-and-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            int num = 0;\\n            for(int j=0; j<grid[0].size(); j++)\\n                if(grid[i][j])\\n                    num |= (1<<j);\\n            if(num==0)\\n                return{i};\\n            for(int j=0; j<pow(2, grid[0].size()); j++)\\n                if((num&j)==0 && mp[j]>0)\\n                    return {mp[j]-1, i};\\n            mp[num]=i+1;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            int num = 0;\\n            for(int j=0; j<grid[0].size(); j++)\\n                if(grid[i][j])\\n                    num |= (1<<j);\\n            if(num==0)\\n                return{i};\\n            for(int j=0; j<pow(2, grid[0].size()); j++)\\n                if((num&j)==0 && mp[j]>0)\\n                    return {mp[j]-1, i};\\n            mp[num]=i+1;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630705,
                "title": "c-bitmask-pairing-403ms-133-1mb",
                "content": "Tricky one, but not really so much for a hard - as long as we figure out that any subset works, not the longest (that would have been way tougher!).\\n\\nWe can then go greedy and figure out that we can have two basic scenarios:\\n* we either get a row with all `0`s;\\n* we get a pair of rows without matching `1`s.\\n\\nThere is no way we can get three matching rows if they have matching `1`s and in order to get four or more rows, given the constraints.\\n\\nFor example, let\\'s consider this four rows that together would actually be valid, since no columns has more than two `1`s:\\n\\n```cpp\\n11000\\n01101\\n10110\\n00011\\n```\\n\\nWe can see that the first and the last would be a good pair on their own, so we might stop there; more in general, we would need at least three `1`s to cross-block four rows, but that would make impossible to get a \"good\" quartet if all four rows had them.\\n\\nNow, with that in mind, we need to figure out a quick way to compare rows; possibly in linear time.\\n\\nAnd we can confidently do so by \"hashing\" each row as a separate number, basically reading it as a binary representation of any integer.\\n\\nWe will go then hunting for pairs, storing where we found a specific value last; exception: if we find a row with all `0`s, that would match our condition alone (or, to be fair, with any other row on its own), so we can just `return` that.\\n\\nNow, let\\'s start with our support variables first:\\n* `found` is where we will store the last position of each row \"hash\" (ie: its decimal value if read like a binary) and with maximum `5` columns we need only `31` cells since we will only check for values up to `30` (`31` in binary is just `11111`, so it would go well only with `0`, but, as we said, as soon as we find one, we `return` that);\\n* `lmt` is the limit for this specific run, computed as $$2^c - 1$$ (with `c` being the number of columns): it will be `1` for `1` column, `3` for `2` columns, `7` for `3` columns, `15` for `4` coluns and finally `31` for the maximum range of `5` columns.\\n\\nNext we are going to prefill `found` with `-1`, to mark the values we did not find yet. I considered optimising the call to memset to only fill the first `lmt` cells, but I am not even sure if it would be cheaper to even compute `lmt * sizeof(int)` instead of just filling it everything. Peanuts, anyway.\\n\\nNext we will go parsing each row with the index `i` and:\\n* store the current row (ie: `grid[i]`) in `row`;\\n* set `tmp` to the initial value of `0`;\\n* for each digit in row, we will compute its decimal hash by:\\n    * right-shifting `tmp` by `1` slot;\\n    * adding `n` to it;\\n* if we are lucky, with `tmp == 0` we can just `return` the sole index `i`;\\n* conversely if `tmp == lmt`, this is our worst case (`row` was filled only with `1`s) and we can just `continue` with the next one;\\n* if all the other cases, we will run with `j` from `1` (again, no point in looking for `0` here) up to `lmt` (excluded) and, if `j` does not have any bit in common with `tmp` (ie: `!(tmp & j)`) and we found that value before (ie: `found[j] != -1`), then we will `return` the pair (`{found[j], i}`);\\n* if no match was found, we will store `i` as the last position in which we spotted `tmp` (ie: in `found[tmp]`).\\n\\nIf we ever reach the end of the loop, then no valid pairs were found and we can just `return` `{}`.\\n\\n# Complexity\\n- Time complexity: $$O(r * c * 2^c)$$\\n- Space complexity: $$O(2^c)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>> &grid) {\\n        // support variables\\n        int found[31], tmp, lmt = (1 << grid[0].size()) - 1;\\n        // preparing found\\n        memset(found, -1, sizeof(found));\\n        // parsing grid\\n        for (int i = 0, len = grid.size(); i < len; i++) {\\n            // computing tmp\\n            auto &row = grid[i];\\n            tmp = 0;\\n            for (int n: row) tmp = (tmp << 1) + n;\\n            // edge cases: tmp can go alone\\n            if (!tmp) return {i};\\n            // and tmp is useless (ie: all 1s)\\n            if (tmp == lmt) continue;\\n            // looking for matches in previously spotted values\\n            for (int j = 1; j < lmt; j++) if (!(j & tmp) && found[j] != -1) return {found[j], i};\\n            // updating found\\n            found[tmp] = i;\\n        }\\n        return {};\\n    }\\n};\\n```\\nCan we do better?\\n\\nYes, if we pre-compute which matches might work with what number in `matches` and use that for the inner loop:\\n\\n```cpp\\nconstexpr int matches[31][15] = {\\n    {},\\n    {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30},\\n    {1, 4, 5, 8, 9, 12, 13, 16, 17, 20, 21, 24, 25, 28, 29},\\n    {4, 8, 12, 16, 20, 24, 28},\\n    {1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27},\\n    {2, 8, 10, 16, 18, 24, 26},\\n    {1, 8, 9, 16, 17, 24, 25},\\n    {8, 16, 24},\\n    {1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23},\\n    {2, 4, 6, 16, 18, 20, 22},\\n    {1, 4, 5, 16, 17, 20, 21},\\n    {4, 16, 20},\\n    {1, 2, 3, 16, 17, 18, 19},\\n    {2, 16, 18},\\n    {1, 16, 17},\\n    {16},\\n    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\\n    {2, 4, 6, 8, 10, 12, 14},\\n    {1, 4, 5, 8, 9, 12, 13},\\n    {4, 8, 12},\\n    {1, 2, 3, 8, 9, 10, 11},\\n    {2, 8, 10},\\n    {1, 8, 9},\\n    {8},\\n    {1, 2, 3, 4, 5, 6, 7},\\n    {2, 4, 6},\\n    {1, 4, 5},\\n    {4},\\n    {1, 2, 3},\\n    {2},\\n    {1}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>> &grid) {\\n        // support variables\\n        int found[31], tmp, lmt = (1 << grid[0].size()) - 1;\\n        // preparing found\\n        memset(found, -1, sizeof(found));\\n        // parsing grid\\n        for (int i = 0, len = grid.size(); i < len; i++) {\\n            // computing tmp\\n            auto &row = grid[i];\\n            tmp = 0;\\n            for (int n: row) tmp = (tmp << 1) + n;\\n            // edge cases: tmp can go alone\\n            if (!tmp) return {i};\\n            // and tmp is useless (ie: all 1s)\\n            if (tmp == lmt) continue;\\n            // looking for matches in previously spotted values\\n            for (int n: matches[tmp]) {\\n                if (found[n] != -1) return {found[n], i};\\n                if (n > lmt) break;\\n            }\\n            // updating found\\n            found[tmp] = i;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Matrix",
                    "Bitmask"
                ],
                "code": "```cpp\\n11000\\n01101\\n10110\\n00011\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>> &grid) {\\n        // support variables\\n        int found[31], tmp, lmt = (1 << grid[0].size()) - 1;\\n        // preparing found\\n        memset(found, -1, sizeof(found));\\n        // parsing grid\\n        for (int i = 0, len = grid.size(); i < len; i++) {\\n            // computing tmp\\n            auto &row = grid[i];\\n            tmp = 0;\\n            for (int n: row) tmp = (tmp << 1) + n;\\n            // edge cases: tmp can go alone\\n            if (!tmp) return {i};\\n            // and tmp is useless (ie: all 1s)\\n            if (tmp == lmt) continue;\\n            // looking for matches in previously spotted values\\n            for (int j = 1; j < lmt; j++) if (!(j & tmp) && found[j] != -1) return {found[j], i};\\n            // updating found\\n            found[tmp] = i;\\n        }\\n        return {};\\n    }\\n};\\n```\n```cpp\\nconstexpr int matches[31][15] = {\\n    {},\\n    {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30},\\n    {1, 4, 5, 8, 9, 12, 13, 16, 17, 20, 21, 24, 25, 28, 29},\\n    {4, 8, 12, 16, 20, 24, 28},\\n    {1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27},\\n    {2, 8, 10, 16, 18, 24, 26},\\n    {1, 8, 9, 16, 17, 24, 25},\\n    {8, 16, 24},\\n    {1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23},\\n    {2, 4, 6, 16, 18, 20, 22},\\n    {1, 4, 5, 16, 17, 20, 21},\\n    {4, 16, 20},\\n    {1, 2, 3, 16, 17, 18, 19},\\n    {2, 16, 18},\\n    {1, 16, 17},\\n    {16},\\n    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\\n    {2, 4, 6, 8, 10, 12, 14},\\n    {1, 4, 5, 8, 9, 12, 13},\\n    {4, 8, 12},\\n    {1, 2, 3, 8, 9, 10, 11},\\n    {2, 8, 10},\\n    {1, 8, 9},\\n    {8},\\n    {1, 2, 3, 4, 5, 6, 7},\\n    {2, 4, 6},\\n    {1, 4, 5},\\n    {4},\\n    {1, 2, 3},\\n    {2},\\n    {1}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>> &grid) {\\n        // support variables\\n        int found[31], tmp, lmt = (1 << grid[0].size()) - 1;\\n        // preparing found\\n        memset(found, -1, sizeof(found));\\n        // parsing grid\\n        for (int i = 0, len = grid.size(); i < len; i++) {\\n            // computing tmp\\n            auto &row = grid[i];\\n            tmp = 0;\\n            for (int n: row) tmp = (tmp << 1) + n;\\n            // edge cases: tmp can go alone\\n            if (!tmp) return {i};\\n            // and tmp is useless (ie: all 1s)\\n            if (tmp == lmt) continue;\\n            // looking for matches in previously spotted values\\n            for (int n: matches[tmp]) {\\n                if (found[n] != -1) return {found[n], i};\\n                if (n > lmt) break;\\n            }\\n            // updating found\\n            found[tmp] = i;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630156,
                "title": "c-greedy-detailed-explaination-intuition-approach-beginner",
                "content": "# Intuition\\nIn the question we were asked to find subset and we know subset can be anything   it is may be of single row, 2 rows, 3 rows, 4 rows ....\\n\\nBut we were asked the subset which have atmost (k/2) sum in all columns then think If any subset of 3rows, 4 rows, 5 rows,..... forming the subset with atmost (k/2) sum then It is confirmed that all the subset have atleast 2 rows  which satisfid the atmost(k/2) sum.\\n\\nso, we will only have to search that pair of rows.\\n\\n# Approach\\nCase 1 : If any one row have all columns values are 0. then this is our Answer.\\nCase 2 :  \\n    (a) :-  We will form new grid which have rows (that doesn\\'t have all columns value 1) if any row have all columns values 1 then we will exclude that row.\\n   (b) :- Run 2 loops for searching pair which have all columns value atmost (k/2)\\n\\n# Complexity\\n- Time complexity:\\nless than O(N^2)  for large test cases.\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>arr;\\n        vector<int>index;\\n        for(int i =0;i<n;i++){\\n            int c = 0;\\n            for(int j =0;j<m;j++){\\n                if(grid[i][j] ==0){\\n                    c++;\\n                }\\n            }\\n            if(c == m){\\n                return {i};\\n            }\\n            if(c != 0){\\n                arr.push_back(grid[i]);\\n                index.push_back(i);\\n            }\\n        }\\n \\n        \\n        for(int i =0;i<arr.size();i++){\\n            \\n            for(int j = i+1;j<arr.size();j++){\\n                  bool flag = true;\\n                 vector<int>temp = arr[i];\\n                for(int k = 0;k<m;k++){\\n                    temp[k] += arr[j][k];\\n                    if(temp[k]>=2){\\n                        cout<<temp[k]<<\" \";\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag){\\n                    return {index[i],index[j]};\\n                }\\n            }\\n        }\\n   \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>arr;\\n        vector<int>index;\\n        for(int i =0;i<n;i++){\\n            int c = 0;\\n            for(int j =0;j<m;j++){\\n                if(grid[i][j] ==0){\\n                    c++;\\n                }\\n            }\\n            if(c == m){\\n                return {i};\\n            }\\n            if(c != 0){\\n                arr.push_back(grid[i]);\\n                index.push_back(i);\\n            }\\n        }\\n \\n        \\n        for(int i =0;i<arr.size();i++){\\n            \\n            for(int j = i+1;j<arr.size();j++){\\n                  bool flag = true;\\n                 vector<int>temp = arr[i];\\n                for(int k = 0;k<m;k++){\\n                    temp[k] += arr[j][k];\\n                    if(temp[k]>=2){\\n                        cout<<temp[k]<<\" \";\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag){\\n                    return {index[i],index[j]};\\n                }\\n            }\\n        }\\n   \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3630020,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> list = new ArrayList<>();\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        for(int i = 0; i < row; i++){\\n            for(int j = i + 1; j < row; j++){\\n                if(check(grid, i, j, col)){\\n                    list.add(i);\\n                    list.add(j);\\n                    return list;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i < row; i++){\\n            boolean flag = false;\\n            for(int j = 0; j < col; j++){\\n                if(grid[i][j] > 0){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n\\n            if(!flag){\\n                list.add(i);\\n                return list;\\n            }\\n        }\\n\\n        return list;\\n    }\\n\\n    public static boolean check(int[][] grid, int i, int j, int col){\\n        int val = 0;\\n\\n        for(int c = 0; c < col; c++){\\n            val = grid[i][c] + grid[j][c];\\n            if(val > 1){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> list = new ArrayList<>();\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        for(int i = 0; i < row; i++){\\n            for(int j = i + 1; j < row; j++){\\n                if(check(grid, i, j, col)){\\n                    list.add(i);\\n                    list.add(j);\\n                    return list;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i < row; i++){\\n            boolean flag = false;\\n            for(int j = 0; j < col; j++){\\n                if(grid[i][j] > 0){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n\\n            if(!flag){\\n                list.add(i);\\n                return list;\\n            }\\n        }\\n\\n        return list;\\n    }\\n\\n    public static boolean check(int[][] grid, int i, int j, int col){\\n        int val = 0;\\n\\n        for(int c = 0; c < col; c++){\\n            val = grid[i][c] + grid[j][c];\\n            if(val > 1){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629951,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        vector<int>ans;\\n        map<int,int> m;\\n        for(int i=0;i<row;i++)\\n        {\\n            int s=0;\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1)\\n                s=s|1<<j;\\n            }\\n            if(s==0)\\n            {\\n                ans.push_back(i);\\n                return ans;\\n            }\\n            m[s]=i+1;\\n        }\\n        for(int i=1;i<32;i++)\\n        {\\n            for(int j=i+1;j<32;j++)\\n            {\\n                if((i&j)==0 && m[i]!=0 && m[j]!=0)\\n                {\\n                    ans.push_back(m[i]-1);\\n                    ans.push_back(m[j]-1);\\n                    sort(ans.begin(),ans.end());\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        vector<int>ans;\\n        map<int,int> m;\\n        for(int i=0;i<row;i++)\\n        {\\n            int s=0;\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1)\\n                s=s|1<<j;\\n            }\\n            if(s==0)\\n            {\\n                ans.push_back(i);\\n                return ans;\\n            }\\n            m[s]=i+1;\\n        }\\n        for(int i=1;i<32;i++)\\n        {\\n            for(int j=i+1;j<32;j++)\\n            {\\n                if((i&j)==0 && m[i]!=0 && m[j]!=0)\\n                {\\n                    ans.push_back(m[i]-1);\\n                    ans.push_back(m[j]-1);\\n                    sort(ans.begin(),ans.end());\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628627,
                "title": "c-simple-intuition-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mn + m^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&a,vector<int>&b)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            ans+=a[i] && b[i];\\n        }\\n        if(ans==0)return true;\\n        return false;\\n    }\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int s = 0;\\n            for(int j = 0; j < n; j++)\\n            {\\n                s+=grid[i][j];\\n            }\\n            if(s==0)\\n            {\\n                return {i};\\n            }\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < m && j!=i; j++)\\n            {\\n                if(check(grid[i],grid[j]))\\n                    return {min(i,j),max(i,j)};\\n            }\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&a,vector<int>&b)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            ans+=a[i] && b[i];\\n        }\\n        if(ans==0)return true;\\n        return false;\\n    }\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int s = 0;\\n            for(int j = 0; j < n; j++)\\n            {\\n                s+=grid[i][j];\\n            }\\n            if(s==0)\\n            {\\n                return {i};\\n            }\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < m && j!=i; j++)\\n            {\\n                if(check(grid[i],grid[j]))\\n                    return {min(i,j),max(i,j)};\\n            }\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628586,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> GoodSubsetofBinaryMatrix(int[][] grid) {\\n        if (grid.Length == 1)\\n        {\\n            if (grid[0].All(num => num == 0))\\n                return new List<int> { 0 };\\n            else\\n                return new List<int>();\\n        }\\n\\n        Dictionary<int, int> d = new Dictionary<int, int>();\\n\\n        for (int r = 0; r < grid.Length; r++)\\n        {\\n            int num = 0;\\n            for (int c = 0; c < grid[r].Length; c++)\\n            {\\n                num += grid[r][c] << c;\\n            }\\n\\n            for (int i = 0; i < 32; i++)\\n            {\\n                if ((i & num) == 0 && d.ContainsKey(i))\\n                {\\n                    return new List<int> { d[i], r };\\n                }\\n            }\\n\\n            if (!d.ContainsKey(num))\\n            {\\n                d[num] = r;\\n            }\\n        }\\n\\n        return new List<int>();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> GoodSubsetofBinaryMatrix(int[][] grid) {\\n        if (grid.Length == 1)\\n        {\\n            if (grid[0].All(num => num == 0))\\n                return new List<int> { 0 };\\n            else\\n                return new List<int>();\\n        }\\n\\n        Dictionary<int, int> d = new Dictionary<int, int>();\\n\\n        for (int r = 0; r < grid.Length; r++)\\n        {\\n            int num = 0;\\n            for (int c = 0; c < grid[r].Length; c++)\\n            {\\n                num += grid[r][c] << c;\\n            }\\n\\n            for (int i = 0; i < 32; i++)\\n            {\\n                if ((i & num) == 0 && d.ContainsKey(i))\\n                {\\n                    return new List<int> { d[i], r };\\n                }\\n            }\\n\\n            if (!d.ContainsKey(num))\\n            {\\n                d[num] = r;\\n            }\\n        }\\n\\n        return new List<int>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628244,
                "title": "c-easy-solution-using-greedy-approach-with-bitmask",
                "content": "Please upvote if you like the solution!\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be proven, that if there exists a good subset of rows then there exists a good subset of rows with the size of either 1 or 2.\\n\\nSince size of each row is 5. So, in total 2^5=32 subsets can be formed.\\nSo, I create mask for each row and store in a set. Then we check whatever required.\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n- Since set/map only stores at most 32 numbers, So, linear space complexity\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        unordered_set<int> S;\\n        unordered_map<int, int> M;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        for(int i=0; i<m; i++) {\\n            int num = 0;\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j])\\n                    num = num | (1<<j);\\n            }\\n            S.insert(num);\\n            M[num] = i;\\n        }\\n\\n        for(auto &num1 : S) {\\n            for(auto &num2 : S) {\\n                if((num1 & num2) == 0) {\\n                    int i = M[num1];\\n                    int j = M[num2];\\n                    if(i == j) return {i};\\n                    return {min(i, j), max(i, j)};\\n                }\\n            }   \\n        }\\n\\n        return {};\\n    }\\n};\\n```\\n\\nPlease upvote if you like the solution!\\uD83D\\uDE4F\\uD83D\\uDE4F",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        unordered_set<int> S;\\n        unordered_map<int, int> M;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        for(int i=0; i<m; i++) {\\n            int num = 0;\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j])\\n                    num = num | (1<<j);\\n            }\\n            S.insert(num);\\n            M[num] = i;\\n        }\\n\\n        for(auto &num1 : S) {\\n            for(auto &num2 : S) {\\n                if((num1 & num2) == 0) {\\n                    int i = M[num1];\\n                    int j = M[num2];\\n                    if(i == j) return {i};\\n                    return {min(i, j), max(i, j)};\\n                }\\n            }   \\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628204,
                "title": "c",
                "content": "```C []\\nint* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n\\tconst int colLen = *gridColSize, rowLen = gridSize;\\n\\n\\tfor (int row = 0; row < rowLen; row += 1){\\n\\t\\tbool allZero = true;\\n\\t\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\t\\tif (grid[row][col] != 0){\\n\\t\\t\\t\\tallZero = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (allZero){\\n\\t\\t\\t*returnSize = 1;\\n\\t\\t\\tint * rets = (int *)malloc(sizeof (int) * 1);\\n\\t\\t\\trets[0] = row;\\n\\t\\t\\treturn rets;\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int row1 = 0; row1 < rowLen - 2 + 1; row1 += 1){\\n\\t\\tfor (int row2 = row1 + 1; row2 < rowLen; row2 += 1){\\n\\t\\t\\tbool matched = true;\\n\\t\\t\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\t\\t\\tif (!( grid[row1][col] + grid[row2][col] <= 2 / 2 )){\\n\\t\\t\\t\\t\\tmatched = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (matched){\\n\\t\\t\\t\\t*returnSize = 2;\\n\\t\\t\\t\\tint * rets = (int *)malloc(sizeof (int) * 2);\\n\\t\\t\\t\\trets[0] = row1;\\n\\t\\t\\t\\trets[1] = row2;\\n\\t\\t\\t\\treturn rets;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t*returnSize = 0;\\n\\treturn NULL;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nint* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n\\tconst int colLen = *gridColSize, rowLen = gridSize;\\n\\n\\tfor (int row = 0; row < rowLen; row += 1){\\n\\t\\tbool allZero = true;\\n\\t\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\t\\tif (grid[row][col] != 0){\\n\\t\\t\\t\\tallZero = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (allZero){\\n\\t\\t\\t*returnSize = 1;\\n\\t\\t\\tint * rets = (int *)malloc(sizeof (int) * 1);\\n\\t\\t\\trets[0] = row;\\n\\t\\t\\treturn rets;\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int row1 = 0; row1 < rowLen - 2 + 1; row1 += 1){\\n\\t\\tfor (int row2 = row1 + 1; row2 < rowLen; row2 += 1){\\n\\t\\t\\tbool matched = true;\\n\\t\\t\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\t\\t\\tif (!( grid[row1][col] + grid[row2][col] <= 2 / 2 )){\\n\\t\\t\\t\\t\\tmatched = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (matched){\\n\\t\\t\\t\\t*returnSize = 2;\\n\\t\\t\\t\\tint * rets = (int *)malloc(sizeof (int) * 2);\\n\\t\\t\\t\\trets[0] = row1;\\n\\t\\t\\t\\trets[1] = row2;\\n\\t\\t\\t\\treturn rets;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t*returnSize = 0;\\n\\treturn NULL;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3627396,
                "title": "clear-solution-with-the-help-of-bits-masking-o-n-2",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int>bit;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=0;i<n;i++){\\n            int num = 0;\\n            int mul = 1;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]){\\n                    num += mul;\\n                }\\n                mul *= 2;\\n            }\\n            if(num==0)return {i};\\n            bit.push_back(num);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n\\n                if((bit[i]&bit[j])==0){\\n                    return {i,j};\\n                }\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int>bit;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=0;i<n;i++){\\n            int num = 0;\\n            int mul = 1;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]){\\n                    num += mul;\\n                }\\n                mul *= 2;\\n            }\\n            if(num==0)return {i};\\n            bit.push_back(num);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n\\n                if((bit[i]&bit[j])==0){\\n                    return {i,j};\\n                }\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626733,
                "title": "c-bit-manipulation-hashing-fully-explained-and-easy-code",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere can be at max 2 rows with sum of each column less than or equal to k/2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt can be proved by basic hit and trial that the maximum good rows can be two. So, our task if to find such two rows. The values in each column can be either both 0 or (1, 0) or (0, 1) i.e. the AND of them should be zero.\\n\\nThis can be calculated by converting each row into an number and by using hashing check if there is a number present such that the AND between them will be 0.\\n# Complexity\\n- Time complexity: O(n * (m + 2^m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> v(32, -1);\\n        for(int row=0; row<n; row++) {\\n            int val = 0;\\n            for(int col=0; col<m; col++) {\\n                if(grid[row][col] == 1) val += 1 << col;\\n            }\\n            \\n            if(val == 0) return {row};\\n            \\n            for(int num=0; num<32; num++) {\\n                if(v[num] != -1 and (val & num) == 0)\\n                     return {v[num], row};\\n            }\\n            v[val] = row;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> v(32, -1);\\n        for(int row=0; row<n; row++) {\\n            int val = 0;\\n            for(int col=0; col<m; col++) {\\n                if(grid[row][col] == 1) val += 1 << col;\\n            }\\n            \\n            if(val == 0) return {row};\\n            \\n            for(int num=0; num<32; num++) {\\n                if(v[num] != -1 and (val & num) == 0)\\n                     return {v[num], row};\\n            }\\n            v[val] = row;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625921,
                "title": "c-solution",
                "content": "# Intuition\\nNot a proof but based on an observation. If for size=2, no solution exists then atleast at one position the digit is 1 for any two rows. If so, for any 3 rows, the third row will have atleast one column with sum 2. Now for 4 rows, if a solution exits, there will exits 2 rows with 3 1\\'s. Thus, for any solution to exits there must be a solution for two rows.\\n\\nFor any two rows satisfying the solution, there \"AND\" must be 0 as there can\\'t be 2 ones to be < floor(2/2) = 1\\n\\nTraversing the map for each element will give O(N^2) running time, so since the column size is at max 5, we can just check for 2^5 values and if any two values whose AND is 0 and are present in array return the indexes stored. \\n\\n# Complexity\\n- Time complexity:\\nO(M)\\n\\n- Space complexity:\\nO(2^N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int> res;\\n        int m = grid.size();\\n        if (m==0) {\\n            return res;\\n        }\\n        int n = grid[0].size();\\n        int prev = 0;\\n        unordered_map<int, int> mp;\\n        for (int i=0;i<m;i++) {\\n            int cur = 0;\\n            for (int j=0;j<n;j++) {\\n                cur = (cur<<1) + grid[i][j];\\n            }\\n            if (cur == 0) {\\n                res.push_back(i); \\n                return res;\\n            }\\n            mp.insert({cur, i});\\n        }\\n        int max_val = pow(2, 5);\\n        for (int i=0;i<max_val;i++) {\\n            for (int j=i+1;j<max_val;j++) {\\n                if ((i&j) != 0) {\\n                    continue;\\n                }\\n                if (mp.find(i) != mp.end() && mp.find(j) != mp.end()) {\\n                    int in1 = mp[i];\\n                    int in2 = mp[j];\\n                    if (in1 > in2) {\\n                        swap(in1, in2);\\n                    } \\n                    res.push_back(in1);\\n                    res.push_back(in2);\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int> res;\\n        int m = grid.size();\\n        if (m==0) {\\n            return res;\\n        }\\n        int n = grid[0].size();\\n        int prev = 0;\\n        unordered_map<int, int> mp;\\n        for (int i=0;i<m;i++) {\\n            int cur = 0;\\n            for (int j=0;j<n;j++) {\\n                cur = (cur<<1) + grid[i][j];\\n            }\\n            if (cur == 0) {\\n                res.push_back(i); \\n                return res;\\n            }\\n            mp.insert({cur, i});\\n        }\\n        int max_val = pow(2, 5);\\n        for (int i=0;i<max_val;i++) {\\n            for (int j=i+1;j<max_val;j++) {\\n                if ((i&j) != 0) {\\n                    continue;\\n                }\\n                if (mp.find(i) != mp.end() && mp.find(j) != mp.end()) {\\n                    int in1 = mp[i];\\n                    int in2 = mp[j];\\n                    if (in1 > in2) {\\n                        swap(in1, in2);\\n                    } \\n                    res.push_back(in1);\\n                    res.push_back(in2);\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625121,
                "title": "python-pair-of-indices-o-mn-2-10",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        index = defaultdict(lambda:-1)\\n        for i in range(m):\\n            mask = 0\\n            for j in range(n):\\n                if grid[i][j]:\\n                    mask |= 1<<j\\n            index[mask] = i\\n        if 0 in index:\\n            return [index[0]]\\n        for mask1 in index:\\n            for mask2 in index:\\n                if mask1 & mask2 == 0:\\n                    return [min(index[mask1], index[mask2]), max(index[mask1],index[mask2])]\\n        return []\\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        index = defaultdict(lambda:-1)\\n        for i in range(m):\\n            mask = 0\\n            for j in range(n):\\n                if grid[i][j]:\\n                    mask |= 1<<j\\n            index[mask] = i\\n        if 0 in index:\\n            return [index[0]]\\n        for mask1 in index:\\n            for mask2 in index:\\n                if mask1 & mask2 == 0:\\n                    return [min(index[mask1], index[mask2]), max(index[mask1],index[mask2])]\\n        return []\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625001,
                "title": "c-time-o-n-m-space-o-1-bitmask-and-reduced-subsets",
                "content": "# Intuition\\nTwo prerequisites to solve these problem:\\n1. The answer has only one or two rows. If there is a subset of more than two rows that satisfies the requirement, .e.g. [1,0], [1, 0], we need two more rows [0, 1] and [0, 1] to form an answer, but [1, 0] and [0, 1] can already make the answer.\\n2. 1 <= n <= 5, which means if we put the 1 and 0s into bits, the number range is [0 - 2^5) i.e. [0 - 32), so there are only at most 32 non-repeat subsets, which reduces the complexity of comparing subsets to 32 ^ 2.\\n\\n# Approach\\n- Transfer the 1 and 0 into numbers using bitmask and save the mask result with indices into a 32-length array;\\n- Company every element in the array, to find the answer.\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int> maskIndices(32, -1);// Use the masked numbers to save indices.\\n        for(int i = 0; i < grid.size(); ++i){\\n            uint mask = 0;\\n            for(int j = 0; j < grid[i].size(); ++j){\\n                if(!grid[i][j]) continue;\\n                mask |= (1 << j);\\n            }\\n            \\n            maskIndices[mask] = i;\\n        }\\n        \\n        if(maskIndices[0] != -1) return {maskIndices[0]};\\n        // Now the compplexity becomes 32 ^ 2!\\n        for(int i = 0; i < maskIndices.size(); ++i){\\n            if(maskIndices[i] == -1) continue; // no such mask.\\n            \\n            for(int j = i + 1; j < maskIndices.size(); ++j){\\n                if(i & j || maskIndices[j] == -1) continue; // The masks have overlaps.\\n                if(maskIndices[i] < maskIndices[j]) {\\n                    return {maskIndices[i], maskIndices[j]};\\n                }\\n                \\n                return {maskIndices[j], maskIndices[i]};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<int> maskIndices(32, -1);// Use the masked numbers to save indices.\\n        for(int i = 0; i < grid.size(); ++i){\\n            uint mask = 0;\\n            for(int j = 0; j < grid[i].size(); ++j){\\n                if(!grid[i][j]) continue;\\n                mask |= (1 << j);\\n            }\\n            \\n            maskIndices[mask] = i;\\n        }\\n        \\n        if(maskIndices[0] != -1) return {maskIndices[0]};\\n        // Now the compplexity becomes 32 ^ 2!\\n        for(int i = 0; i < maskIndices.size(); ++i){\\n            if(maskIndices[i] == -1) continue; // no such mask.\\n            \\n            for(int j = i + 1; j < maskIndices.size(); ++j){\\n                if(i & j || maskIndices[j] == -1) continue; // The masks have overlaps.\\n                if(maskIndices[i] < maskIndices[j]) {\\n                    return {maskIndices[i], maskIndices[j]};\\n                }\\n                \\n                return {maskIndices[j], maskIndices[i]};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624838,
                "title": "c-intuitive-approach-o-m-2-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the answer exists, then it will consist either of one or two rows. This can be proven using contradiction. So we need to find some pair of rows whose AND is 0. This will ensure that there is atmost one 1 in all the columns. If the matrix contains a row with all 0s, then that\\'s the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert the rows to decimal representation to use & operator.\\nallowedVals represents that which all numbers will make AND with current number 0. More formally:\\nallowedVals[i] stores the row index of grid which will have AND with integer i as 0.\\n\\nThen it boils down to finding some row from grid whose complement exists which can make AND as 0.\\n\\nPlease upvote if you found it useful.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m * 2^n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(2^n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> allowedVals((1<<n) + 1, -1);\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < 1 << n; j++) {\\n                if ((j & toDecimal(grid[i])) == 0) {\\n                    allowedVals[j] = i;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < grid.size(); i++) {\\n            if (toDecimal(grid[i]) == 0) {\\n                ans.push_back(i);\\n                return ans;\\n            } else if (allowedVals[toDecimal(grid[i])] >= 0) {\\n                ans.push_back(i);\\n                ans.push_back(allowedVals[toDecimal(grid[i])]);\\n                break;\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n    int toDecimal(vector<int> binaryArray) {\\n        int ans = 0;\\n        int n = binaryArray.size();\\n        for (int i = 0; i < n; i++) {\\n            ans += binaryArray[i] << n-1-i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> allowedVals((1<<n) + 1, -1);\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < 1 << n; j++) {\\n                if ((j & toDecimal(grid[i])) == 0) {\\n                    allowedVals[j] = i;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < grid.size(); i++) {\\n            if (toDecimal(grid[i]) == 0) {\\n                ans.push_back(i);\\n                return ans;\\n            } else if (allowedVals[toDecimal(grid[i])] >= 0) {\\n                ans.push_back(i);\\n                ans.push_back(allowedVals[toDecimal(grid[i])]);\\n                break;\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\n    int toDecimal(vector<int> binaryArray) {\\n        int ans = 0;\\n        int n = binaryArray.size();\\n        for (int i = 0; i < n; i++) {\\n            ans += binaryArray[i] << n-1-i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624483,
                "title": "2-approaches-4ms-java-solution-easy-to-understand",
                "content": "# Code (BRUTE FORCE --> 250 ms)\\n```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        int m = grid.length, n = grid[0].length;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < m;j++){\\n                boolean wrong = false;\\n                for(int k = 0;k < n;k++){\\n                    int num = grid[i][k] + grid[j][k];\\n                    if(num > 1) {\\n                        wrong = true;break;\\n                    }\\n                }\\n                if(!wrong){\\n                    res.add(i);\\n                    if(i != j) res.add(j);\\n                    return res;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n# Code (OPTIMAL --> 4 ms)\\n```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        boolean[] bin = new boolean[32];\\n        ArrayList<Integer> ret = new ArrayList<>();\\n        ArrayList<int[]> list = new ArrayList<>();\\n        int num = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            num = 0;\\n\\n            for (int j = 0; j < grid[0].length; j++) {\\n                num = (num << 1);\\n                if (grid[i][j] == 1) {\\n                    num = num | 1;\\n                }\\n            }\\n            //special case\\n            if (num == 0) {\\n                // If the binary representation of the row is 0,\\n                // the row satisfies the condition on its own\\n                ret.add(i); // Add the row index to the result list\\n                return ret; // Return the result immediately\\n            }\\n            //To counter repeating rows\\n            if (!bin[num]) {\\n                list.add(new int[]{num, i});\\n                bin[num] = true;\\n            }\\n        }\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            for (int j = 0; j < list.size(); j++) {\\n                if (i != j && (list.get(i)[0] & list.get(j)[0]) == 0) {\\n                    // Check if the pair of rows is compatible:\\n                    // By checking If the bitwise AND of their binary representations is 0\\n                    // Add the row indices to the result list\\n                    ret.add(list.get(i)[1]); \\n                    ret.add(list.get(j)[1]); \\n                    return ret; // Return the result\\n                }\\n            }\\n        }\\n\\n        return ret; // Return the empty result list if no compatible pair is found\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        int m = grid.length, n = grid[0].length;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < m;j++){\\n                boolean wrong = false;\\n                for(int k = 0;k < n;k++){\\n                    int num = grid[i][k] + grid[j][k];\\n                    if(num > 1) {\\n                        wrong = true;break;\\n                    }\\n                }\\n                if(!wrong){\\n                    res.add(i);\\n                    if(i != j) res.add(j);\\n                    return res;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        boolean[] bin = new boolean[32];\\n        ArrayList<Integer> ret = new ArrayList<>();\\n        ArrayList<int[]> list = new ArrayList<>();\\n        int num = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            num = 0;\\n\\n            for (int j = 0; j < grid[0].length; j++) {\\n                num = (num << 1);\\n                if (grid[i][j] == 1) {\\n                    num = num | 1;\\n                }\\n            }\\n            //special case\\n            if (num == 0) {\\n                // If the binary representation of the row is 0,\\n                // the row satisfies the condition on its own\\n                ret.add(i); // Add the row index to the result list\\n                return ret; // Return the result immediately\\n            }\\n            //To counter repeating rows\\n            if (!bin[num]) {\\n                list.add(new int[]{num, i});\\n                bin[num] = true;\\n            }\\n        }\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            for (int j = 0; j < list.size(); j++) {\\n                if (i != j && (list.get(i)[0] & list.get(j)[0]) == 0) {\\n                    // Check if the pair of rows is compatible:\\n                    // By checking If the bitwise AND of their binary representations is 0\\n                    // Add the row indices to the result list\\n                    ret.add(list.get(i)[1]); \\n                    ret.add(list.get(j)[1]); \\n                    return ret; // Return the result\\n                }\\n            }\\n        }\\n\\n        return ret; // Return the empty result list if no compatible pair is found\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623935,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        map<vector<int>,int> mp;\\n        for(int i=0;i<n;i++)\\n            mp[grid[i]]=i;\\n        \\n        for(auto &[vec,a] : mp)\\n        {\\n            for(auto &[vec1,b] : mp)\\n            {\\n                bool ok=true;\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(vec[j]==vec1[j] && vec[j]==1)\\n                        ok=false;\\n                }\\n                \\n                if(a==b && ok)\\n                    return {a};\\n                if(ok)\\n                    return {min(a,b),max(a,b)};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        map<vector<int>,int> mp;\\n        for(int i=0;i<n;i++)\\n            mp[grid[i]]=i;\\n        \\n        for(auto &[vec,a] : mp)\\n        {\\n            for(auto &[vec1,b] : mp)\\n            {\\n                bool ok=true;\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(vec[j]==vec1[j] && vec[j]==1)\\n                        ok=false;\\n                }\\n                \\n                if(a==b && ok)\\n                    return {a};\\n                if(ok)\\n                    return {min(a,b),max(a,b)};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623653,
                "title": "subset-should-be-of-length-2-if-possible",
                "content": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        if m == 1 and sum(grid[0]) == 0:\\n            return [0]\\n        pos = {}\\n        for i in range(m):\\n            for mask in range(1 << n):\\n                valid = True\\n                for j in range(n):\\n                    if mask & (1 << j) and grid[i][j] + 1 > 1:\\n                        valid = False\\n                        break\\n                if valid and mask in pos:\\n                    return [pos[mask], i]\\n            curr = 0\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    curr |= 1 << j\\n            pos[curr] = i\\n        return []\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        if m == 1 and sum(grid[0]) == 0:\\n            return [0]\\n        pos = {}\\n        for i in range(m):\\n            for mask in range(1 << n):\\n                valid = True\\n                for j in range(n):\\n                    if mask & (1 << j) and grid[i][j] + 1 > 1:\\n                        valid = False\\n                        break\\n                if valid and mask in pos:\\n                    return [pos[mask], i]\\n            curr = 0\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    curr |= 1 << j\\n            pos[curr] = i\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623537,
                "title": "c-short-iterative-solution",
                "content": "Idea is to realize that we only need some subset, so we would just pick 1 row or 2 rows, since if we have valid subset of 3 rows then two of the three rows must also be a valid subset, so there is no point going pass 2. \\n\\nWith 1 row, we can only have row of zeroes. With 2 rows, we need to check such that the two rows do not have a `1` bit at the same place. We can do this using bit operation. \\n\\nAlgorithm is for each row to search for a possible complement (`row[i] & row[j] = 0`). Since there are max `5` columns, possible hash is limited to `2^6 = 64`. So we can just iterate over all the hashes looking for ones that already exist and complement the current hash for a solution.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(const vector<vector<int>>& grid) {\\n        std::vector<int> hash((1<<6), -1);\\n        int new_hash;\\n        int max_hash = (1<<6);\\n        for (int i(0); i < grid.size(); ++i) {\\n            new_hash = 0;\\n            for (int j(0); j < grid[i].size(); ++j) {\\n                if (grid[i][j] == 1) new_hash |= (1<<j);\\n            }\\n\\n            /* if row of zeroes we can just use this one row */\\n            if (new_hash == 0) return {i};\\n\\n            /* search for a complement from previous rows */\\n            for (int other_hash(0); other_hash < max_hash; ++other_hash) {\\n                if ((new_hash & other_hash) == 0) {\\n                    if (hash[other_hash] != -1) {\\n                        return {hash[other_hash], i};\\n                    }\\n                }\\n            }\\n            \\n            if (hash[new_hash] == -1) hash[new_hash] = i;\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(const vector<vector<int>>& grid) {\\n        std::vector<int> hash((1<<6), -1);\\n        int new_hash;\\n        int max_hash = (1<<6);\\n        for (int i(0); i < grid.size(); ++i) {\\n            new_hash = 0;\\n            for (int j(0); j < grid[i].size(); ++j) {\\n                if (grid[i][j] == 1) new_hash |= (1<<j);\\n            }\\n\\n            /* if row of zeroes we can just use this one row */\\n            if (new_hash == 0) return {i};\\n\\n            /* search for a complement from previous rows */\\n            for (int other_hash(0); other_hash < max_hash; ++other_hash) {\\n                if ((new_hash & other_hash) == 0) {\\n                    if (hash[other_hash] != -1) {\\n                        return {hash[other_hash], i};\\n                    }\\n                }\\n            }\\n            \\n            if (hash[new_hash] == -1) hash[new_hash] = i;\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623311,
                "title": "constant-space-time-simple-w-full-explanation-java",
                "content": "# Intuition\\nThe problem requires finding a subset of rows from a given binary matrix. The subset should satisfy a specific condition: the sum of each column in the subset should be at most half the length of the subset.\\n\\nUpon analyzing the problem, I noticed an interesting observation. We don\\'t actually need to find an entire subset, we only need to identify a pair of rows that meet the given criteria. This realization simplifies the problem significantly.\\n\\nConsidering that there can be at most 5 columns in each row, which gives us a maximum of 32 possible combinations, we can solve the problem efficiently with linear time complexity.\\n\\n# Approach\\nTo determine which two rows are compatible and satisfy the criteria, we need to find a row that has a 0 in the column where the other row has a 1, and any value (0 or 1) in the column where the other row has a 0. And for that i used & operator.\\n\\nTo achieve this efficiently, I utilized bitwise manipulation. I represented each row as a `number`, where the row itself corresponds to the binary representation of that `number`. Since the maximum number of columns is 5, the row can be represented by a number ranging from 0 to 31.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n   Time complexity: The time complexity of this solution is `O(32^2)`, which simplifies to `O(1)`. Since the number of rows, `m`, and columns, `n`, is limited to small values `(m \\u2264 10^4, n \\u2264 5)`, the maximum number of combinations is 32. Therefore, the algorithm runs in constant time.\\n\\n- Space complexity:\\n    The space complexity is also `O(1)`. Although we use an ArrayList and a boolean array, the maximum number of elements they can store is fixed at 32.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        boolean[] bin = new boolean[32];\\n        ArrayList<Integer> ret = new ArrayList<>();\\n        ArrayList<int[]> list = new ArrayList<>();\\n        int num = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            num = 0;\\n\\n            for (int j = 0; j < grid[0].length; j++) {\\n                num = (num << 1);\\n                if (grid[i][j] == 1) {\\n                    num = num | 1;\\n                }\\n            }\\n            //special case\\n            if (num == 0) {\\n                // If the binary representation of the row is 0,\\n                // the row satisfies the condition on its own\\n                ret.add(i); // Add the row index to the result list\\n                return ret; // Return the result immediately\\n            }\\n            //To counter repeating rows\\n            if (!bin[num]) {\\n                list.add(new int[]{num, i});\\n                bin[num] = true;\\n            }\\n        }\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            for (int j = 0; j < list.size(); j++) {\\n                if (i != j && (list.get(i)[0] & list.get(j)[0]) == 0) {\\n                    // Check if the pair of rows is compatible:\\n                    // By checking If the bitwise AND of their binary representations is 0\\n                    // Add the row indices to the result list\\n                    ret.add(list.get(i)[1]); \\n                    ret.add(list.get(j)[1]); \\n                    return ret; // Return the result\\n                }\\n            }\\n        }\\n\\n        return ret; // Return the empty result list if no compatible pair is found\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        boolean[] bin = new boolean[32];\\n        ArrayList<Integer> ret = new ArrayList<>();\\n        ArrayList<int[]> list = new ArrayList<>();\\n        int num = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            num = 0;\\n\\n            for (int j = 0; j < grid[0].length; j++) {\\n                num = (num << 1);\\n                if (grid[i][j] == 1) {\\n                    num = num | 1;\\n                }\\n            }\\n            //special case\\n            if (num == 0) {\\n                // If the binary representation of the row is 0,\\n                // the row satisfies the condition on its own\\n                ret.add(i); // Add the row index to the result list\\n                return ret; // Return the result immediately\\n            }\\n            //To counter repeating rows\\n            if (!bin[num]) {\\n                list.add(new int[]{num, i});\\n                bin[num] = true;\\n            }\\n        }\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            for (int j = 0; j < list.size(); j++) {\\n                if (i != j && (list.get(i)[0] & list.get(j)[0]) == 0) {\\n                    // Check if the pair of rows is compatible:\\n                    // By checking If the bitwise AND of their binary representations is 0\\n                    // Add the row indices to the result list\\n                    ret.add(list.get(i)[1]); \\n                    ret.add(list.get(j)[1]); \\n                    return ret; // Return the result\\n                }\\n            }\\n        }\\n\\n        return ret; // Return the empty result list if no compatible pair is found\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623241,
                "title": "c-clear-and-simple-full-explaination-with-comments-in-code-o-rows-cols-2",
                "content": "# Intuition\\nFirst it is clear that for a given \"good\" set, each 1 that exists in a column must be paired with a 0 in that same column from another row or else we would go over the allowed limit of 1s.\\n\\nNext, we know there are at most 5 columns. If *all* the rows have at least 3 1s in their columns, then it will be impossible to find a good set. As we first said, each 1 in our set must match with at least one other 0 and therefore in total, the subset grid can be at most half 1s. But with all of the rows having at least 3 1s, k\\\\*3 will always be greater than (k\\\\*5)/2 = k*2.5.\\n\\nNow, we will see that we only have to consider pairs of rows forming a good set (or the trival case where a row is all zeros). It clearly doesn\\'t make sense to have an odd sized set as that is more restrictive. So consider a set of size 4. If each pair of rows does not form a \"good\" set on it\\'s own, then each of those pairs must share a 1 in a column with each other set. This cannot be the same column as with another set or else that column will have too many 1s in it to be \"good\" (3 rows out of 4). Therefore, a row would have to have 3 1s pairing with each of the other 3 rows. For illustration purpose, here is what it would look like if there could be 6 columns:\\n`1 1 1 0 0 0`\\n`1 0 0 1 1 0`\\n`0 1 0 1 0 1`\\n`0 0 1 0 1 1`\\nHowever, this would mean every row has at least 3 1s, and since we are limited to only 5 columns, we know from the earlier point that this cannot form a \"good\" set. With sets with even more rows it becomes even more restrictive and therefore easier to find a \"good\" pair within that set.\\n\\nTherefore, we only need to check pairs of rows. And even then, when checking pairs of rows, we can ignore ones with more than 2 1s (specifically as the first in the pair - it may still be involved in a pair with a differnt row with less than 3 1s, but we will be checking that other row against all the others and so will still see this pairing).\\n\\n# Approach\\nWe can check each row, if it has less than 3 1s, we can look for the existance of a row which has 0s where it has 1s. We just need to preprocess sets of rows which cover every possible option so that we can do this in constant time. Given that we are only looking at rows with at most 2 1s, there are 5 choose 2 = 10 possiblities, plus the 5 possibilities where there is only 1 one.\\n\\nWe can build a set for each column of all the rows with a 0 in that column and then in a second pass we can combine those sets in c^2*r time.\\n\\n# Complexity\\n- Time complexity: O(c^2 * r)\\n\\n- Space complexity: O(c^2 * r)\\n\\n# Code\\n```\\nclass Solution\\n{\\n  public:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>> &grid)\\n    {\\n        int rows = grid.size();\\n        int columns = grid[0].size();\\n\\n        // Create a set of all the rows which have a 0 in each column\\n        vector<unordered_set<int>> singleZeros(columns);\\n        for (int c = 0; c < columns; ++c)\\n        {\\n            for (int r = 0; r < rows; ++r)\\n            {\\n                if (grid[r][c] == 0)\\n                {\\n                    singleZeros[c].insert(r);\\n                }\\n            }\\n        }\\n\\n        // Then combine the previous sets for each pair of columns (for a max number of columns of 5, there will only be 10 pairs)\\n        vector<vector<unordered_set<int>>> doubleZeros(columns, vector<unordered_set<int>>(columns));\\n        for (int c1 = 0; c1 < columns; ++c1)\\n        {\\n            for (int c2 = c1 + 1; c2 < columns; ++c2)\\n            {\\n                auto &set1 = singleZeros[c1];\\n                auto &set2 = singleZeros[c2];\\n                for (int r : set1)\\n                {\\n                    if (set2.find(r) != set2.end())\\n                    {\\n                        doubleZeros[c1][c2].insert(r);\\n                        doubleZeros[c2][c1].insert(r);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Check for each row if there exists another row that can be paired with it to create a \"good\" set\\n        for (int r = 0; r < rows; ++r)\\n        {\\n            // First find out how many 1s there are and at which columns\\n            int count = 0;\\n            int c1 = -1;\\n            int c2 = -1;\\n            for (int c = 0; c < columns; ++c)\\n            {\\n                if (grid[r][c] == 1)\\n                {\\n                    if (c1 < 0)\\n                    {\\n                        c1 = c;\\n                    }\\n                    else if (c2 < 0)\\n                    {\\n                        c2 = c;\\n                    }\\n                    ++count;\\n                }\\n            }\\n\\n            if (count == 0)\\n            {\\n                // All zeros is a set on its own\\n                return {r};\\n            }\\n            else if (count == 1)\\n            {\\n                // Check if there is another row with a zero in the one column that this row has a 1 in\\n                if (!singleZeros[c1].empty())\\n                {\\n                    int otherRow = *singleZeros[c1].begin();\\n                    if (r > otherRow)\\n                    {\\n                        return {otherRow, r};\\n                    }\\n                    return {r, otherRow};\\n                }\\n            }\\n            else if (count == 2)\\n            {\\n                // Check if there is another row with a zero in both of the columns this row has a 1 in\\n                if (!doubleZeros[c1][c2].empty())\\n                {\\n                    int otherRow = *doubleZeros[c1][c2].begin();\\n                    if (r > otherRow)\\n                    {\\n                        return {otherRow, r};\\n                    }\\n                    return {r, otherRow};\\n                }\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\n  public:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>> &grid)\\n    {\\n        int rows = grid.size();\\n        int columns = grid[0].size();\\n\\n        // Create a set of all the rows which have a 0 in each column\\n        vector<unordered_set<int>> singleZeros(columns);\\n        for (int c = 0; c < columns; ++c)\\n        {\\n            for (int r = 0; r < rows; ++r)\\n            {\\n                if (grid[r][c] == 0)\\n                {\\n                    singleZeros[c].insert(r);\\n                }\\n            }\\n        }\\n\\n        // Then combine the previous sets for each pair of columns (for a max number of columns of 5, there will only be 10 pairs)\\n        vector<vector<unordered_set<int>>> doubleZeros(columns, vector<unordered_set<int>>(columns));\\n        for (int c1 = 0; c1 < columns; ++c1)\\n        {\\n            for (int c2 = c1 + 1; c2 < columns; ++c2)\\n            {\\n                auto &set1 = singleZeros[c1];\\n                auto &set2 = singleZeros[c2];\\n                for (int r : set1)\\n                {\\n                    if (set2.find(r) != set2.end())\\n                    {\\n                        doubleZeros[c1][c2].insert(r);\\n                        doubleZeros[c2][c1].insert(r);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Check for each row if there exists another row that can be paired with it to create a \"good\" set\\n        for (int r = 0; r < rows; ++r)\\n        {\\n            // First find out how many 1s there are and at which columns\\n            int count = 0;\\n            int c1 = -1;\\n            int c2 = -1;\\n            for (int c = 0; c < columns; ++c)\\n            {\\n                if (grid[r][c] == 1)\\n                {\\n                    if (c1 < 0)\\n                    {\\n                        c1 = c;\\n                    }\\n                    else if (c2 < 0)\\n                    {\\n                        c2 = c;\\n                    }\\n                    ++count;\\n                }\\n            }\\n\\n            if (count == 0)\\n            {\\n                // All zeros is a set on its own\\n                return {r};\\n            }\\n            else if (count == 1)\\n            {\\n                // Check if there is another row with a zero in the one column that this row has a 1 in\\n                if (!singleZeros[c1].empty())\\n                {\\n                    int otherRow = *singleZeros[c1].begin();\\n                    if (r > otherRow)\\n                    {\\n                        return {otherRow, r};\\n                    }\\n                    return {r, otherRow};\\n                }\\n            }\\n            else if (count == 2)\\n            {\\n                // Check if there is another row with a zero in both of the columns this row has a 1 in\\n                if (!doubleZeros[c1][c2].empty())\\n                {\\n                    int otherRow = *doubleZeros[c1][c2].begin();\\n                    if (r > otherRow)\\n                    {\\n                        return {otherRow, r};\\n                    }\\n                    return {r, otherRow};\\n                }\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623231,
                "title": "simple-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple use of Maps. for finding the unique keys and iterating over the keys to find a pair of keys which can be over potential solution.\\nCheck solution by simple logic if any column is having sum at most one.\\nHandle the case where map has only one key that is all column values are equal for all rows. in that case all values should be 0 else fail.\\n\\n# Complexity\\n- Time complexity:\\nO(n * m)\\n\\n- Additional Space complexity:\\nConstant [as there are no more than (2^5 keys)]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        int i = 0;\\n        for(auto it: grid) {\\n            mp[it] = i ++;\\n        }\\n        \\n        \\n        \\n        if(mp.size() == 1) {\\n            int k = 0;\\n            for(int j = 0; j < grid[0].size(); j ++) {\\n                k = max(k, grid[0][j]);\\n            }\\n            if(k == 1) {\\n                return {};\\n            } else {\\n                return {0};\\n            }\\n        }\\n        \\n        vector<int> ans = {};\\n        for(auto i: mp) {\\n            for( auto j: mp) {\\n                if(i.second != j.second) {\\n                    vector<int> v1 = i.first;\\n                    vector<int> v2 = j.first;\\n                    int s = 0;\\n                    for(int i = 0; i < v1.size(); i ++) {\\n                        if(v1[i] + v2[i] > 1) {\\n                            s = 1;\\n                        }\\n                    }\\n                    \\n                    if(s == 0) {\\n                        ans = {i.second, j.second};\\n                    }\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        int i = 0;\\n        for(auto it: grid) {\\n            mp[it] = i ++;\\n        }\\n        \\n        \\n        \\n        if(mp.size() == 1) {\\n            int k = 0;\\n            for(int j = 0; j < grid[0].size(); j ++) {\\n                k = max(k, grid[0][j]);\\n            }\\n            if(k == 1) {\\n                return {};\\n            } else {\\n                return {0};\\n            }\\n        }\\n        \\n        vector<int> ans = {};\\n        for(auto i: mp) {\\n            for( auto j: mp) {\\n                if(i.second != j.second) {\\n                    vector<int> v1 = i.first;\\n                    vector<int> v2 = j.first;\\n                    int s = 0;\\n                    for(int i = 0; i < v1.size(); i ++) {\\n                        if(v1[i] + v2[i] > 1) {\\n                            s = 1;\\n                        }\\n                    }\\n                    \\n                    if(s == 0) {\\n                        ans = {i.second, j.second};\\n                    }\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623206,
                "title": "c-easy-intutive-dp-solution",
                "content": "# Intuition\\nSimilar to normal dp.\\n\\n# Approach\\ncheck if a particular vector can be taken or not.\\n\\n# Complexity\\n- Time complexity:\\nO(N*32)\\ntime limit is too strict in this question\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,int>mp;\\n     void func(int idx,vector<int>&vec,int len,vector<int>&temp,vector<vector<int>>&grid){\\n         int m=grid.size();\\n         if(idx==m) return;\\n         // choosing i\\n         // if(dp[idx][len]!=-1) return dp[idx][len];\\n         int n=vec.size();\\n         for(int k=0;k<n;k++){\\n             if(grid[idx][k]==0) continue;\\n             else{\\n                 vec[k]+=1;\\n             }\\n         }\\n         \\n           string s=to_string(idx+1)+\\'*\\'+to_string(len+1);\\n        for(int k=0;k<n;k++){\\n            s=s+\\'*\\'+to_string(vec[k]);\\n        }\\n       if(mp[s]){\\n           int value=grid[idx][n];\\n           temp.push_back(value);\\n           func(idx+1,vec,len+1,temp,grid);\\n       }\\n         else{\\n             for(int k=0;k<n;k++){\\n             if(grid[idx][k]==0) continue;\\n             else{\\n                 vec[k]-=1;\\n             }  \\n         }\\n              func(idx+1,vec,len,temp,grid);\\n                 \\n    }\\n       \\n         // func(idx+1,vec,len+1,m,temp,grid,dp);\\n        \\n         \\n         \\n         \\n         \\n     }\\n  \\n    bool check(int idx,vector<int>&vec,int len,vector<vector<int>>&grid){\\n        if(len>3) return 0;\\n        if(idx>32) return 0;\\n        int m=grid.size();\\n         if(idx==m){\\n             bool flag=0;\\n             if(len>=1){\\n                 int k;\\n               for( k=0;k<vec.size();k++){\\n                   if(vec[k]<=(len/2)) continue;\\n                   else break;\\n               }\\n                 if(k==(int)vec.size()){\\n                   flag=true;\\n                     // return;\\n                 }\\n                \\n                 \\n             }\\n             int n=vec.size();\\n              string s=to_string(idx)+\\'*\\'+to_string(len);\\n        for(int k=0;k<n;k++){\\n            s=s+\\'*\\'+to_string(vec[k]);\\n        }\\n            return mp[s]=flag;\\n           \\n             // return;\\n         }\\n         \\n         // choosing i\\n          int n=vec.size();\\n        string s=to_string(idx)+\\'*\\'+to_string(len);\\n        for(int k=0;k<n;k++){\\n            s=s+\\'*\\'+to_string(vec[k]);\\n        }\\n        if(mp.count(s)) return mp[s];\\n       \\n         bool flag=false;\\n      \\n         for(int k=0;k<n;k++){\\n             if(grid[idx][k]==0) continue;\\n             else{\\n                 vec[k]+=1;\\n             }\\n         }\\n        \\n         flag|=check(idx+1,vec,len+1,grid);\\n           for(int k=0;k<n;k++){\\n             if(grid[idx][k]==0) continue;\\n             else{\\n                 vec[k]-=1;\\n             }\\n         }\\n           // not choosing i\\n         flag|=check(idx+1,vec,len,grid);\\n          return mp[s]=flag;\\n     }\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        mp.clear();\\n        int n=grid[0].size();\\n        int m=grid.size();\\n        vector<int>vec(n,0);\\n        vector<int>temp;\\n        map<vector<int>,int>mp2;\\n     vector<vector<int>>grid2;\\n        for(int i=0;i<grid.size();i++){\\n           if(!mp2[grid[i]]){\\n               vector<int>temp=grid[i];\\n               temp.push_back(i);\\n            grid2.push_back(temp);\\n               mp2[grid[i]]++;\\n           }\\n        }\\n        // for(auto ele:grid2){\\n        //     for(auto ele2:ele){\\n        //         cout<<ele2<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        // return temp;\\n          // cout<<check(0,vec,0,grid2)<<endl;\\n        // cout<<grid2.size()<<endl;\\n       if(!check(0,vec,0,grid2)){\\n           return temp;\\n       }\\n        \\n        \\n        for(int i=0;i<n;i++) vec[i]=0;\\n         func(0,vec,0,temp,grid2);\\n         return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,int>mp;\\n     void func(int idx,vector<int>&vec,int len,vector<int>&temp,vector<vector<int>>&grid){\\n         int m=grid.size();\\n         if(idx==m) return;\\n         // choosing i\\n         // if(dp[idx][len]!=-1) return dp[idx][len];\\n         int n=vec.size();\\n         for(int k=0;k<n;k++){\\n             if(grid[idx][k]==0) continue;\\n             else{\\n                 vec[k]+=1;\\n             }\\n         }\\n         \\n           string s=to_string(idx+1)+\\'*\\'+to_string(len+1);\\n        for(int k=0;k<n;k++){\\n            s=s+\\'*\\'+to_string(vec[k]);\\n        }\\n       if(mp[s]){\\n           int value=grid[idx][n];\\n           temp.push_back(value);\\n           func(idx+1,vec,len+1,temp,grid);\\n       }\\n         else{\\n             for(int k=0;k<n;k++){\\n             if(grid[idx][k]==0) continue;\\n             else{\\n                 vec[k]-=1;\\n             }  \\n         }\\n              func(idx+1,vec,len,temp,grid);\\n                 \\n    }\\n       \\n         // func(idx+1,vec,len+1,m,temp,grid,dp);\\n        \\n         \\n         \\n         \\n         \\n     }\\n  \\n    bool check(int idx,vector<int>&vec,int len,vector<vector<int>>&grid){\\n        if(len>3) return 0;\\n        if(idx>32) return 0;\\n        int m=grid.size();\\n         if(idx==m){\\n             bool flag=0;\\n             if(len>=1){\\n                 int k;\\n               for( k=0;k<vec.size();k++){\\n                   if(vec[k]<=(len/2)) continue;\\n                   else break;\\n               }\\n                 if(k==(int)vec.size()){\\n                   flag=true;\\n                     // return;\\n                 }\\n                \\n                 \\n             }\\n             int n=vec.size();\\n              string s=to_string(idx)+\\'*\\'+to_string(len);\\n        for(int k=0;k<n;k++){\\n            s=s+\\'*\\'+to_string(vec[k]);\\n        }\\n            return mp[s]=flag;\\n           \\n             // return;\\n         }\\n         \\n         // choosing i\\n          int n=vec.size();\\n        string s=to_string(idx)+\\'*\\'+to_string(len);\\n        for(int k=0;k<n;k++){\\n            s=s+\\'*\\'+to_string(vec[k]);\\n        }\\n        if(mp.count(s)) return mp[s];\\n       \\n         bool flag=false;\\n      \\n         for(int k=0;k<n;k++){\\n             if(grid[idx][k]==0) continue;\\n             else{\\n                 vec[k]+=1;\\n             }\\n         }\\n        \\n         flag|=check(idx+1,vec,len+1,grid);\\n           for(int k=0;k<n;k++){\\n             if(grid[idx][k]==0) continue;\\n             else{\\n                 vec[k]-=1;\\n             }\\n         }\\n           // not choosing i\\n         flag|=check(idx+1,vec,len,grid);\\n          return mp[s]=flag;\\n     }\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        mp.clear();\\n        int n=grid[0].size();\\n        int m=grid.size();\\n        vector<int>vec(n,0);\\n        vector<int>temp;\\n        map<vector<int>,int>mp2;\\n     vector<vector<int>>grid2;\\n        for(int i=0;i<grid.size();i++){\\n           if(!mp2[grid[i]]){\\n               vector<int>temp=grid[i];\\n               temp.push_back(i);\\n            grid2.push_back(temp);\\n               mp2[grid[i]]++;\\n           }\\n        }\\n        // for(auto ele:grid2){\\n        //     for(auto ele2:ele){\\n        //         cout<<ele2<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        // return temp;\\n          // cout<<check(0,vec,0,grid2)<<endl;\\n        // cout<<grid2.size()<<endl;\\n       if(!check(0,vec,0,grid2)){\\n           return temp;\\n       }\\n        \\n        \\n        for(int i=0;i<n;i++) vec[i]=0;\\n         func(0,vec,0,temp,grid2);\\n         return temp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3623196,
                "title": "efficient-ruby-solution-with-explanation-100-100",
                "content": "# Intuition\\nHaving repeat rows doesn\\'t affect if this is true or false, and any valid solution can be done in two or fewer rows.\\n\\n# Approach\\n1. Create an indices hash, and assign an index to each unique element in the array.  (The purpose of this is to ignore repeat elements.  We need to have an index from the original array, though, so we can\\'t just do grid.uniq!)\\n2. If we have an array of all zeroes in the grid, that\\'s a solution -- return its index in an array.\\n3. Otherwise, check each pair of distinct rows.  (This loop checks each element with itself, and checks each pair both ways.  It could be improved, but it doesn\\'t need to be, since there are at most 31 distinct rows.)  Use a helper function.\\n4. Return an empty array if there are no pairs.\\n\\nHelper function:\\n(This was written to check any number of rows, but in practice, it would only be two.  Feel free to improve this.)\\n1. Create an array of all zeroes (of the appropriate length).\\n2. For each row, add the values of its elements to your array.\\n3. Check if all values in your array are at most half the number of rows.  (Since there are always two rows, all values must be less than 2.)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, because we have to iterate through the array.  The part checking pairs is $$O(1)$$.\\n\\n- Space complexity:\\n$$O(1)$$, since there are at most 32 distinct rows.\\n\\n# Code\\n```\\ndef good_subsetof_binary_matrix(grid)\\n    indices = Hash.new\\n    grid.each_with_index { |row,i| indices[row] = i }\\n    @n = grid[0].length\\n    \\n    return [indices[Array.new(@n,0)]] if indices[Array.new(@n,0)]\\n    \\n    rows = indices.keys\\n    \\n    rows.each do |row|\\n        rows.each do |row2|\\n            return [indices[row],indices[row2]].sort if valid?([row,row2])\\n        end\\n    end\\n    \\n    []\\nend\\n\\ndef valid?(rows)\\n    arr = Array.new(@n,0)\\n    rows.each do |row|\\n        (0...@n).each { |i| arr[i] += row[i] }\\n    end\\n    \\n    arr.all? { |n| n <= rows.length / 2 }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef good_subsetof_binary_matrix(grid)\\n    indices = Hash.new\\n    grid.each_with_index { |row,i| indices[row] = i }\\n    @n = grid[0].length\\n    \\n    return [indices[Array.new(@n,0)]] if indices[Array.new(@n,0)]\\n    \\n    rows = indices.keys\\n    \\n    rows.each do |row|\\n        rows.each do |row2|\\n            return [indices[row],indices[row2]].sort if valid?([row,row2])\\n        end\\n    end\\n    \\n    []\\nend\\n\\ndef valid?(rows)\\n    arr = Array.new(@n,0)\\n    rows.each do |row|\\n        (0...@n).each { |i| arr[i] += row[i] }\\n    end\\n    \\n    arr.all? { |n| n <= rows.length / 2 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3623127,
                "title": "swift-solution-using-bit-operations-o-n-2",
                "content": "# Code\\n```\\nclass Solution {\\n    func goodSubsetofBinaryMatrix(_ grid: [[Int]]) -> [Int] {\\n\\n        var nums: [Int] = []\\n        nums.reserveCapacity(grid.count)\\n\\n        for i in grid.indices {\\n            var num = 0\\n            for j in grid[i].indices {\\n                num |= (grid[i][j] << j)\\n            }\\n\\n            if num == 0 {\\n                return [i]\\n            } else {\\n                nums.append(num)\\n            }\\n        }\\n\\n        for i in nums.indices.dropLast() {\\n            for j in i+1..<nums.count where nums[i] & nums[j] == 0 {\\n                return [i, j]\\n            }\\n        }\\n\\n        return []\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func goodSubsetofBinaryMatrix(_ grid: [[Int]]) -> [Int] {\\n\\n        var nums: [Int] = []\\n        nums.reserveCapacity(grid.count)\\n\\n        for i in grid.indices {\\n            var num = 0\\n            for j in grid[i].indices {\\n                num |= (grid[i][j] << j)\\n            }\\n\\n            if num == 0 {\\n                return [i]\\n            } else {\\n                nums.append(num)\\n            }\\n        }\\n\\n        for i in nums.indices.dropLast() {\\n            for j in i+1..<nums.count where nums[i] & nums[j] == 0 {\\n                return [i, j]\\n            }\\n        }\\n\\n        return []\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623095,
                "title": "enumerating-all-sub-mask-to-have-3-n-solution-complexity-explained-c",
                "content": "# Approach\\nFirst note that we only need at most two rows (this is only valid with $n\\\\leq5$) in order to have a good subset. Now let\\'s concentrate on the case where we need exactly two, i.e. there is no row with only zeros (trivial case).\\n\\nFrom here we will treat the rows as numbers and this number will be obtained from the binary representation that form their values, in this way we can see that there are at most $2^5$ different rows, so we are going to work with unique values. \\n\\nTo try to get two rows that are valid we can check for each concrete unique row (let\\'s call it $row_i$) if there is another one that can be matched, (we call that pair as valid pair $row_j$), we know that two rows can be matched, if in their binary representation they do not share any one, in a more formal way $row_i \\\\; \\\\& \\\\; row_j = 0$ now the question is how to find for a $row_i$ some $row_j$ , let\\'s change the expression to enumerate all valid $row_j$ \\n\\nFor some $row_i$ a valid $row_j$ and specifically the one with the most bits on is $row_j = row_i \\\\oplus mask$ with $mask=2^n-1$ this operation will put (for the first $n$ bits) ones where there are zeros in $row_1$ and vice versa , it can be seen as if we flip the first $n$ bits\\n> Example. \\nImagine we try to find a valid pair for $row= 9$ with binary representation $01001$ , a valid $row_j$ with the maximum number of bits on is: \\n$row_j = mask , row_i = 22$ in this case $mask=31\\\\; , 11111\\\\; \\\\text{in binary}$. \\nViewing in binary: \\n$row_j = 11111 \\\\oplus 01001 = 10110$.\\n\\nNow we can check if that $row_j$ exists in our matrix and if it exists we will have a solution, but if it does not exist we still have other possible valid pairs for our same $row_i$ these values (in binary) are: \\n\\n$S = {10110,10100,10000,10010, 00110,00100,00000,00010}$\\n\\nAnd you can see that these values are all submasks of $row_j$ this means that for any $S_i$ the following is satisfied $S_i \\\\& row_j = S_i$ now knowing this let\\'s first look at a solution in $O(2^n \\\\times 2^n) = O(2^{2n})$ , just store the index of the rows representing the number $row_i$ and iterate over all possible values for both $row_i,row_j$, check the submask condition and the existence condition as shown in the following pseudocode.\\n\\n##### Pseudocode\\n```cpp\\n    int mask = (1<<n)-1;\\n    for(int row_i = 0;row_i<(1<<n);row_i++){\\n        for(int row_j = 0;row_j<(1<<n);row_j++){\\n            if(row_j is submask of(row_i^mask) && exists(row_i) && exists(row_j)) {\\n            return {ID[row_i], ID[row_j]}\\n            }\\n        }       \\n    }\\n```\\nexist is some function or way to get if we have in our matrix some row that represents that number. \\n\\nBut we can do better, what if for $row_j $ instead of seeing all the possible values and then doing the validation we only iterate through the submasks in such a way that we are sure that it is indeed a valid pair, so we need to build the maximum $row_j$ (the one with the largest number of ones) and then iterate over its submasks, in this way the only thing missing is checking that these rows exist in our matrix.\\nWe can enumerate the submasks of a mask with the following trick\\n```\\nfor (int s=m; s; s=(s-1)&m)\\n```\\n> **Example** \\n$m =10110$ \\n$s_1 = m = 10110$\\n$s_2 = s_1 -1 &m = 10101 & 10110 = 10100$ \\n$s_3 = s_2 -1 &m = 10100 & 10011 = 10010$\\nAnd so on, make your own examples to convince yourself of the operation.\\n\\nSo we can change the past code with:\\n```cppp\\n    int mask = (1<<n-1);\\n    for(int row_i = 0;row_i<(1<<n);row_i++){\\n        int maxS = row_i ^ mask;\\n        for(int row_j = maxS;row_j;row_j=(row_j-1)&mask){\\n            if(exist(row_i) && exist(row_j)) return {ID[row_i], ID[row_j]}\\n        }           \\n    }\\n```\\n## Complexity\\nNow the last question is what is the complexity?\\n\\nLet\\'s see how many submasks have some specific mask for example the mask $10010$ will have only $4, 10010, 10000, 00010, 0000$\\nand we see that we can only change the ones to zeros or leave them unchanged, since we cannot flip the zeros because the condition $s & mask = s$ will not be valid, so if we can flip only the ones we can say that the number of submasks for some mask it is $2^{#ones}$\\n\\nNow, if the number of submasks depends on the number of ones, it is a good idea to express our total number of submasks with the number of ones, for that we can know how many masks will have a specific number of ones $k$, so the expression for the total number of submasks visited can be written like this:\\n\\n$\\\\Sigma_{k=0}^n \\\\binom{n}{k} \\\\times 2^{k}$ \\nAnd for the [binomial theorem](https://en.wikipedia.org/wiki/Binomial_theorem) we  we know that \\n\\n$(x+y)^n$ = $\\\\Sigma_{k=0}^n \\\\binom{n}{k} x^{n-k} y^k$ \\nreplacing $x=1,y=2$ we have\\n\\n$(1+2)^n$ = $\\\\Sigma_{k=0}^n \\\\binom{n}{k} 1^{n-k} 2^k$ \\n= $(1+2)^n$ = $\\\\Sigma_{k=0}^n \\\\binom{n}{k}  2^k$ \\n\\nThat is exactly our expression for all submask so we conclude that our complexity is exactly $3^n$\\n\\n# Complexity\\n- Time complexity:\\n- $O(n\\\\times m + 3^n)$ assuming constant time of the unordered map/hash table (can still be removed)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        unordered_map<int,int> mp;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i = 0;i<n;i++){\\n            int x = 0;\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j])x|=(1<<j);\\n            }\\n            mp[x] = i;\\n        }\\n        \\n        int mask = (1<<m)-1;\\n        \\n        if(mp.count(0)){\\n            return {mp[0]};\\n        }\\n        for(int i = 0;i<(1<<m);i++){\\n            int M = i^mask;\\n            for(int s = M;s;s = (s-1)&M){\\n                if(mp.count(i) && mp.count(s)){\\n                    return {min(mp[i],mp[s]),max(mp[i],mp[s])};\\n                }\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n    int mask = (1<<n)-1;\\n    for(int row_i = 0;row_i<(1<<n);row_i++){\\n        for(int row_j = 0;row_j<(1<<n);row_j++){\\n            if(row_j is submask of(row_i^mask) && exists(row_i) && exists(row_j)) {\\n            return {ID[row_i], ID[row_j]}\\n            }\\n        }       \\n    }\\n```\n```\\nfor (int s=m; s; s=(s-1)&m)\\n```\n```cppp\\n    int mask = (1<<n-1);\\n    for(int row_i = 0;row_i<(1<<n);row_i++){\\n        int maxS = row_i ^ mask;\\n        for(int row_j = maxS;row_j;row_j=(row_j-1)&mask){\\n            if(exist(row_i) && exist(row_j)) return {ID[row_i], ID[row_j]}\\n        }           \\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        unordered_map<int,int> mp;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i = 0;i<n;i++){\\n            int x = 0;\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j])x|=(1<<j);\\n            }\\n            mp[x] = i;\\n        }\\n        \\n        int mask = (1<<m)-1;\\n        \\n        if(mp.count(0)){\\n            return {mp[0]};\\n        }\\n        for(int i = 0;i<(1<<m);i++){\\n            int M = i^mask;\\n            for(int s = M;s;s = (s-1)&M){\\n                if(mp.count(i) && mp.count(s)){\\n                    return {min(mp[i],mp[s]),max(mp[i],mp[s])};\\n                }\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623066,
                "title": "video-explanation-with-all-the-proof",
                "content": "# Explanation\\n\\n[Click here for the video](https://youtu.be/8X9FVuyBtWg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        vector<int> row_with_val(32, -1);\\n        for (int r = 0; r < rows; r ++) {\\n            int val = 0;\\n            for (int c = 0; c < cols; c ++) \\n                if (grid[r][c] == 1) val += (1 << c);\\n            \\n            row_with_val[val] = r;\\n        }\\n        \\n        for (int v1 = 0; v1 < 32; v1 ++) {\\n            if (row_with_val[v1] == -1) continue;\\n            if (v1 == 0) return { row_with_val[v1] };\\n            \\n            for (int v2 = v1+1; v2 < 32; v2 ++) {\\n                if (row_with_val[v2] == -1 || (v1 & v2) != 0) continue;\\n                \\n                int r1 = row_with_val[v1];\\n                int r2 = row_with_val[v2];\\n                return {min(r1, r2), max(r1, r2)};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        vector<int> row_with_val(32, -1);\\n        for (int r = 0; r < rows; r ++) {\\n            int val = 0;\\n            for (int c = 0; c < cols; c ++) \\n                if (grid[r][c] == 1) val += (1 << c);\\n            \\n            row_with_val[val] = r;\\n        }\\n        \\n        for (int v1 = 0; v1 < 32; v1 ++) {\\n            if (row_with_val[v1] == -1) continue;\\n            if (v1 == 0) return { row_with_val[v1] };\\n            \\n            for (int v2 = v1+1; v2 < 32; v2 ++) {\\n                if (row_with_val[v2] == -1 || (v1 & v2) != 0) continue;\\n                \\n                int r1 = row_with_val[v1];\\n                int r2 = row_with_val[v2];\\n                return {min(r1, r2), max(r1, r2)};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623032,
                "title": "brute-force-with-comments",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> goodSubsetofBinaryMatrix(vector<vector < int>> &grid)\\n        {\\n            int n = grid.size(), m = grid[0].size();\\n\\n            map<int, int> mpp;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                int val = 0;\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j] == 1)\\n                        val += (1 << j);\\n                }\\n\\n               \\t// edge case : 0 0 0 0 0\\n                if (val == 0)\\n                    return {\\n                        i\\n                    };\\n\\n                for (int j = 1; j <= 31; j++)\\n                {\\n                    if ((val & j) == 0 && mpp.find(j) != mpp.end())\\n                    {\\n                       \\t// since the value is already present its row number must have been smaller\\n                        return {mpp[j] , i};\\n                    }\\n                    mpp[val] = i;\\n                }\\n            }\\n            return {};\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> goodSubsetofBinaryMatrix(vector<vector < int>> &grid)\\n        {\\n            int n = grid.size(), m = grid[0].size();\\n\\n            map<int, int> mpp;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                int val = 0;\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j] == 1)\\n                        val += (1 << j);\\n                }\\n\\n               \\t// edge case : 0 0 0 0 0\\n                if (val == 0)\\n                    return {\\n                        i\\n                    };\\n\\n                for (int j = 1; j <= 31; j++)\\n                {\\n                    if ((val & j) == 0 && mpp.find(j) != mpp.end())\\n                    {\\n                       \\t// since the value is already present its row number must have been smaller\\n                        return {mpp[j] , i};\\n                    }\\n                    mpp[val] = i;\\n                }\\n            }\\n            return {};\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622827,
                "title": "easy-to-understand-c-hashmap-backtracking",
                "content": "# Complexity\\n- Time complexity:O((2^N)*M*N)\\n\\n- Space complexity: O(M*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>a,b;\\n    map<vector<int>,int>m;\\n    vector<int>ans;\\n    void helper(int n, int ind,vector<vector<int>>&grid){\\n        if(ans.size()) return;\\n        if(ind==n){\\n            if(m[a]>0 && ans.size()==0){\\n                ans.push_back(m[a]-1);\\n                for(int i=0; i<grid.size(); i++){\\n                    bool ok=1;\\n                    for(int j=0; j<grid[0].size(); j++){\\n                        if(a[j]==1 && grid[i][j]==1){\\n                            ok=0;\\n                            break;\\n                        }\\n                    }\\n                    if(ok){\\n                        ans.push_back(m[grid[i]]-1);\\n                        break;\\n                    }\\n                }\\n                if(ans.size()==1) ans.pop_back();\\n            }\\n            return;\\n        }\\n        a[ind]=0;\\n        b[ind]=1;\\n        helper(n,ind+1,grid);\\n        a[ind]=1;\\n        b[ind]=0;\\n        helper(n,ind+1,grid);\\n    }\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        for(int i=0; i<grid.size(); i++){\\n            m[grid[i]]=i+1;\\n        }\\n        for(int i=0; i<grid.size(); i++){\\n            bool ok=0;\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]==1) ok=1;\\n            }\\n            if(ok==0){\\n                return {i};\\n            }\\n        }\\n        for(auto it:grid[0]) {a.push_back(0);b.push_back(0);}\\n        helper(grid[0].size(),0,grid);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>a,b;\\n    map<vector<int>,int>m;\\n    vector<int>ans;\\n    void helper(int n, int ind,vector<vector<int>>&grid){\\n        if(ans.size()) return;\\n        if(ind==n){\\n            if(m[a]>0 && ans.size()==0){\\n                ans.push_back(m[a]-1);\\n                for(int i=0; i<grid.size(); i++){\\n                    bool ok=1;\\n                    for(int j=0; j<grid[0].size(); j++){\\n                        if(a[j]==1 && grid[i][j]==1){\\n                            ok=0;\\n                            break;\\n                        }\\n                    }\\n                    if(ok){\\n                        ans.push_back(m[grid[i]]-1);\\n                        break;\\n                    }\\n                }\\n                if(ans.size()==1) ans.pop_back();\\n            }\\n            return;\\n        }\\n        a[ind]=0;\\n        b[ind]=1;\\n        helper(n,ind+1,grid);\\n        a[ind]=1;\\n        b[ind]=0;\\n        helper(n,ind+1,grid);\\n    }\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        for(int i=0; i<grid.size(); i++){\\n            m[grid[i]]=i+1;\\n        }\\n        for(int i=0; i<grid.size(); i++){\\n            bool ok=0;\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]==1) ok=1;\\n            }\\n            if(ok==0){\\n                return {i};\\n            }\\n        }\\n        for(auto it:grid[0]) {a.push_back(0);b.push_back(0);}\\n        helper(grid[0].size(),0,grid);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622781,
                "title": "finding-good-subsets-of-a-binary-matrix-using-binary-value-comparison-approach-in-c-java-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem is to find a \"good subset\" of a binary matrix. A \"good subset\" is defined as a pair of rows in the matrix such that their bitwise OR operation results in zero. In other words, we need to find two rows that have no overlapping set bits. To solve this, we can convert each row of the matrix into an integer by treating it as a binary number. Then, we can check if any two rows have a common bit position (represented by \\'j\\') where the bitwise AND of their values is zero.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize variables \\'n\\' and \\'m\\' to store the number of rows and columns in the matrix, respectively.\\n2. Create an unordered map \\'hsh\\' to store the values encountered during traversal.\\n3. Iterate through each row \\'i\\' from 0 to \\'n-1\\'.\\n4. Initialize \\'val\\' as zero to store the converted integer value for the current row.\\n5. Iterate through each column \\'j\\' from 0 to \\'m-1\\'.\\n    1. If the element in the current row and column is 1, set the corresponding bit in \\'val\\' to 1.\\n6. Check if \\'val\\' is equal to zero. If true, return the vector {i}, as this row is a good subset on its own.\\n7. Iterate through \\'j\\' from 1 to 31 (32 bits in an integer).\\n    1. Check if the bitwise AND of \\'val\\' and \\'j\\' is zero and \\'j\\' exists in the \\'hsh\\' map.\\n    2. If true, return the vector {hsh[j], i}, as we have found a pair of rows with no overlapping set bits.\\n8. Add the current \\'val\\' and its corresponding row \\'i\\' to the \\'hsh\\' map.\\n9. If no good subset is found, return an empty vector {}.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(n * m), where \\'n\\' is the number of rows and \\'m\\' is the number of columns in the matrix. This is because we iterate through each element in the matrix once to calculate the integer value for each row and check for common bit positions.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n), where \\'n\\' is the number of rows in the matrix. This is because we store the converted values and their corresponding rows in the \\'hsh\\' unordered map, which can contain at most \\'n\\' entries.\\n\\n\\n# Code PYTHON3\\n```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid) # Number of rows in the matrix\\n        m = len(grid[0]) # Number of columns in the matrix\\n        hsh = {} # Dictionary to store converted values and their corresponding rows\\n\\n        for i in range(n):\\n            val = 0 # Integer value for the current row\\n\\n            for j in range(m):\\n                if grid[i][j] == 1:\\n                    val += (1 << j) # Convert binary value to decimal and add it to \\'val\\'\\n\\n            if val == 0:\\n                return [i] # Return [i] if the row itself is a good subset\\n\\n            for j in range(1, 32):\\n                if (val & j) == 0 and j in hsh:\\n                    return [hsh[j], i] # Return the pair of rows with no overlapping set bits\\n\\n            hsh[val] = i # Store the value and its corresponding row in the dictionary\\n\\n        return [] # Return an empty list if no good subset is found\\n\\n```\\n\\n# Code C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(); // Number of rows in the matrix\\n        int m = grid[0].size(); // Number of columns in the matrix\\n        unordered_map<int, int> hsh; // Map to store converted values and their corresponding rows\\n\\n        for (int i = 0; i < n; i++) {\\n            int val = 0; // Integer value for the current row\\n\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j]) {\\n                    val += (1 << j); // Convert binary value to decimal and add it to \\'val\\'\\n                }\\n            }\\n\\n            if (val == 0) {\\n                return {i}; // Return {i} if the row itself is a good subset\\n            }\\n\\n            for (int j = 1; j < 32; j++) {\\n                if ((val & j) == 0 && hsh.count(j)) {\\n                    return {hsh[j], i}; // Return the pair of rows with no overlapping set bits\\n                }\\n            }\\n\\n            hsh[val] = i; // Store the value and its corresponding row in the map\\n        }\\n\\n        return {}; // Return an empty vector if no good subset is found\\n    }\\n};\\n\\n```\\n\\n# Code JAVA\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[] goodSubsetofBinaryMatrix(int[][] grid) {\\n        int n = grid.length; // Number of rows in the matrix\\n        int m = grid[0].length; // Number of columns in the matrix\\n        Map<Integer, Integer> hsh = new HashMap<>(); // Map to store converted values and their corresponding rows\\n\\n        for (int i = 0; i < n; i++) {\\n            int val = 0; // Integer value for the current row\\n\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    val += (1 << j); // Convert binary value to decimal and add it to \\'val\\'\\n                }\\n            }\\n\\n            if (val == 0) {\\n                return new int[]{i}; // Return [i] if the row itself is a good subset\\n            }\\n\\n            for (int j = 1; j < 32; j++) {\\n                if ((val & j) == 0 && hsh.containsKey(j)) {\\n                    return new int[]{hsh.get(j), i}; // Return the pair of rows with no overlapping set bits\\n                }\\n            }\\n\\n            hsh.put(val, i); // Store the value and its corresponding row in the map\\n        }\\n\\n        return new int[0]; // Return an empty array if no good subset is found\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid) # Number of rows in the matrix\\n        m = len(grid[0]) # Number of columns in the matrix\\n        hsh = {} # Dictionary to store converted values and their corresponding rows\\n\\n        for i in range(n):\\n            val = 0 # Integer value for the current row\\n\\n            for j in range(m):\\n                if grid[i][j] == 1:\\n                    val += (1 << j) # Convert binary value to decimal and add it to \\'val\\'\\n\\n            if val == 0:\\n                return [i] # Return [i] if the row itself is a good subset\\n\\n            for j in range(1, 32):\\n                if (val & j) == 0 and j in hsh:\\n                    return [hsh[j], i] # Return the pair of rows with no overlapping set bits\\n\\n            hsh[val] = i # Store the value and its corresponding row in the dictionary\\n\\n        return [] # Return an empty list if no good subset is found\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(); // Number of rows in the matrix\\n        int m = grid[0].size(); // Number of columns in the matrix\\n        unordered_map<int, int> hsh; // Map to store converted values and their corresponding rows\\n\\n        for (int i = 0; i < n; i++) {\\n            int val = 0; // Integer value for the current row\\n\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j]) {\\n                    val += (1 << j); // Convert binary value to decimal and add it to \\'val\\'\\n                }\\n            }\\n\\n            if (val == 0) {\\n                return {i}; // Return {i} if the row itself is a good subset\\n            }\\n\\n            for (int j = 1; j < 32; j++) {\\n                if ((val & j) == 0 && hsh.count(j)) {\\n                    return {hsh[j], i}; // Return the pair of rows with no overlapping set bits\\n                }\\n            }\\n\\n            hsh[val] = i; // Store the value and its corresponding row in the map\\n        }\\n\\n        return {}; // Return an empty vector if no good subset is found\\n    }\\n};\\n\\n```\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[] goodSubsetofBinaryMatrix(int[][] grid) {\\n        int n = grid.length; // Number of rows in the matrix\\n        int m = grid[0].length; // Number of columns in the matrix\\n        Map<Integer, Integer> hsh = new HashMap<>(); // Map to store converted values and their corresponding rows\\n\\n        for (int i = 0; i < n; i++) {\\n            int val = 0; // Integer value for the current row\\n\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    val += (1 << j); // Convert binary value to decimal and add it to \\'val\\'\\n                }\\n            }\\n\\n            if (val == 0) {\\n                return new int[]{i}; // Return [i] if the row itself is a good subset\\n            }\\n\\n            for (int j = 1; j < 32; j++) {\\n                if ((val & j) == 0 && hsh.containsKey(j)) {\\n                    return new int[]{hsh.get(j), i}; // Return the pair of rows with no overlapping set bits\\n                }\\n            }\\n\\n            hsh.put(val, i); // Store the value and its corresponding row in the map\\n        }\\n\\n        return new int[0]; // Return an empty array if no good subset is found\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622768,
                "title": "python-detailed-explanation-using-bit-manipulation",
                "content": "# Intuition\\nA valid solution is made of a single row or a pair:\\n- if a row is full of zeros, the answer is that single row;\\n- otherwise, we need to find a \"mirrored\" one in the grid, where all the ones are zero.\\n\\n# Approach\\nWe start by transforming all the rows in their integer representation such as: \\n- $[1, 0, 0, 0] \\\\rightarrow 1000 \\\\rightarrow 8$\\n- $[0, 0, 1, 0] \\\\rightarrow 10 \\\\rightarrow 2$\\n\\n```\\nN = len(grid[0])\\ndef row_to_int(row):\\n    i = N - 1\\n    ans = 0\\n    for e in row:\\n        ans |= e << i\\n        i -= 1\\n    return ans\\n```\\n\\nThen, for each number, we compute the valid mirrored ones, more formally, all the numbers that paired with the initial one result in a good subset of the grid.\\n\\nFor instance, given the number $10$ and its binary representation $1010$, the following are all valid mirrored numbers when $4$ is the row length: $[0000, 0001, 0100, 0101]$.\\n\\nIn other words, let $n$ be the row length: fixed an initial bitmask, we find all the possible combinations of $n$ bits, such that the original ones are flipped with zeros.\\n\\nThis leads us to a list of integers, called candidates, that paired with the initial number, give valid combinations.\\n\\n```\\ndef candidates(s):\\n    res = []\\n\\n    def aux(mask, tmp, i):\\n        if i >= N:\\n            res.append(tmp)\\n            return\\n        aux(mask << 1, tmp, i + 1)\\n        if (mask & s) == 0:\\n            aux(mask << 1, (1 << i) | tmp, i + 1)\\n\\n    aux(1, 0, 0)\\n    return res\\n```\\nWe can use recursion to explore all possible combinations, keeping in mind we need to invert all the original ones with zero.\\n\\nAn equivalent approach would be to store strings instead of numbers, where we build a string instead of an integer via bit manipulation.\\n\\nFinally, we find a valid pair, keeping seen integers in a dictionary.\\n\\n# Complexity\\nTime complexity:\\n- transforming all rows to integers is constant, as the max length of a row is $5$;\\n- given an integer, the number of candidates is bounded by $2^5 = 32$, hence a constant factor;\\n- the final scan to find a valid pair is linear in the number of rows, as we use a hash table. \\n\\nTherefore, the algorithm runs in $O(n)$. \\n\\nSpace complexity:\\n- the candidate function uses constant space, as the recursion stack grows to size $5$;\\n- the final hashtable can potentially contain all the rows in the input.\\n\\nThe final space complexity is $O(n)$.\\n\\n# Code\\n```\\ndef goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n\\n    N = len(grid[0])\\n    M = len(grid)\\n\\n    def candidates(s):\\n        res = []\\n\\n        def aux(mask, tmp, i):\\n            if i >= N:\\n                res.append(tmp)\\n                return\\n            aux(mask << 1, tmp, i + 1)\\n            if (mask & s) == 0:\\n                aux(mask << 1, (1 << i) | tmp, i + 1)\\n\\n        aux(1, 0, 0)\\n        return res\\n\\n    def row_to_int(row):\\n        i = N - 1\\n        ans = 0\\n        for e in row:\\n            ans |= e << i\\n            i -= 1\\n        return ans\\n\\n    seen = {}\\n    for i, e in enumerate(map(row_to_int, grid)):\\n        if e == 0:\\n            return [i]\\n        for c in candidates(e):\\n            if c in seen:\\n                return [seen[c], i]\\n        seen[e] = i\\n\\n    return []\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nN = len(grid[0])\\ndef row_to_int(row):\\n    i = N - 1\\n    ans = 0\\n    for e in row:\\n        ans |= e << i\\n        i -= 1\\n    return ans\\n```\n```\\ndef candidates(s):\\n    res = []\\n\\n    def aux(mask, tmp, i):\\n        if i >= N:\\n            res.append(tmp)\\n            return\\n        aux(mask << 1, tmp, i + 1)\\n        if (mask & s) == 0:\\n            aux(mask << 1, (1 << i) | tmp, i + 1)\\n\\n    aux(1, 0, 0)\\n    return res\\n```\n```\\ndef goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n\\n    N = len(grid[0])\\n    M = len(grid)\\n\\n    def candidates(s):\\n        res = []\\n\\n        def aux(mask, tmp, i):\\n            if i >= N:\\n                res.append(tmp)\\n                return\\n            aux(mask << 1, tmp, i + 1)\\n            if (mask & s) == 0:\\n                aux(mask << 1, (1 << i) | tmp, i + 1)\\n\\n        aux(1, 0, 0)\\n        return res\\n\\n    def row_to_int(row):\\n        i = N - 1\\n        ans = 0\\n        for e in row:\\n            ans |= e << i\\n            i -= 1\\n        return ans\\n\\n    seen = {}\\n    for i, e in enumerate(map(row_to_int, grid)):\\n        if e == 0:\\n            return [i]\\n        for c in candidates(e):\\n            if c in seen:\\n                return [seen[c], i]\\n        seen[e] = i\\n\\n    return []\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3622753,
                "title": "just-check-1-or-2-rows-brute-force-easy-to-understand-with-video-solution",
                "content": "# Video solution\\n\\nfor video solution please click here [click here](https://youtu.be/EcVS9jyfKZY)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust check for 1 or 2 rows | brute force method\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![part - 1.jpeg](https://assets.leetcode.com/users/images/b2cdfabc-ab86-4b2b-89ba-03ca21dd0752_1686417829.4625237.jpeg)\\n\\n\\n![part- 2.jpeg](https://assets.leetcode.com/users/images/c5ecf7db-f29d-481e-a9c6-604219fa3a9c_1686417842.8651576.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m^2 * n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\nRes Array will have size 0,1 or 2\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        int m = grid.length, n = grid[0].length;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < m;j++){\\n                boolean wrong = false;\\n                for(int k = 0;k < n;k++){\\n                    int num = grid[i][k] + grid[j][k];\\n                    if(num > 1) {\\n                        wrong = true;break;\\n                    }\\n                }\\n                if(!wrong){\\n                    res.add(i);\\n                    if(i != j) res.add(j);\\n                    return res;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        int m = grid.length, n = grid[0].length;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < m;j++){\\n                boolean wrong = false;\\n                for(int k = 0;k < n;k++){\\n                    int num = grid[i][k] + grid[j][k];\\n                    if(num > 1) {\\n                        wrong = true;break;\\n                    }\\n                }\\n                if(!wrong){\\n                    res.add(i);\\n                    if(i != j) res.add(j);\\n                    return res;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622752,
                "title": "go-python-o-n-2-n-m-time-o-n-space",
                "content": "# Complexity\\n- Time complexity: $$O(n^2+n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc goodSubsetofBinaryMatrix(grid [][]int) []int {\\n    n := len(grid)\\n    nums := make([]int,n)\\n    for i,block := range(grid){\\n        num := 0\\n        power := 1\\n        for _,item := range(block){\\n            num+=item*power\\n            power*=2\\n        }\\n        nums[i] = num\\n    }\\n    if n == 1 && nums[0] == 0{\\n        return []int{0}\\n    }\\n    for i:=0;i<n;i++{\\n        for j:=i+1;j<n;j++{\\n            if nums[i] & nums[j] == 0{\\n                return []int{i,j}\\n            }\\n        }\\n    }       \\n    return []int{}\\n}\\n```\\n```python []\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid)\\n        nums = [0 for _ in range(n)]\\n        for i,block in enumerate(grid):\\n            num = 0\\n            power = 1\\n            for _,item in enumerate(block):\\n                num+=item*power\\n                power*=2\\n            nums[i] = num\\n        if n == 1 and nums[0] == 0:\\n            return [0]\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i] & nums[j] == 0:\\n                    return [i,j]\\n        return []\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```golang []\\nfunc goodSubsetofBinaryMatrix(grid [][]int) []int {\\n    n := len(grid)\\n    nums := make([]int,n)\\n    for i,block := range(grid){\\n        num := 0\\n        power := 1\\n        for _,item := range(block){\\n            num+=item*power\\n            power*=2\\n        }\\n        nums[i] = num\\n    }\\n    if n == 1 && nums[0] == 0{\\n        return []int{0}\\n    }\\n    for i:=0;i<n;i++{\\n        for j:=i+1;j<n;j++{\\n            if nums[i] & nums[j] == 0{\\n                return []int{i,j}\\n            }\\n        }\\n    }       \\n    return []int{}\\n}\\n```\n```python []\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid)\\n        nums = [0 for _ in range(n)]\\n        for i,block in enumerate(grid):\\n            num = 0\\n            power = 1\\n            for _,item in enumerate(block):\\n                num+=item*power\\n                power*=2\\n            nums[i] = num\\n        if n == 1 and nums[0] == 0:\\n            return [0]\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i] & nums[j] == 0:\\n                    return [i,j]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622693,
                "title": "c-o-m-n-log-n-m-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        map<int, map<int, vector<int>>> binMap;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                binMap[j][grid[i][j]].push_back(i);\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++) {\\n            set<int> npossRows;\\n            bool bad = false;\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1){\\n                    if(binMap[j][1].size() == m) {\\n                        bad = true;\\n                        break;\\n                    }\\n                    for(auto rw:binMap[j][1]) {\\n                        npossRows.insert(rw);\\n                    }   \\n                }\\n                \\n                if(npossRows.size() >= m) {\\n                    break;\\n                }\\n            }\\n            // for(auto rw:npossRows)cout<<rw<<\" \";\\n            // cout<<endl;\\n            if(!bad && npossRows.size() <= m-1){\\n                vector<int> ans;\\n                for(int k=0; k<m; k++) {\\n                    if(k==i) {\\n                        ans.push_back(k);\\n                    }else if(!npossRows.count(k)) {\\n                        ans.push_back(k);\\n                    }\\n                    if(ans.size() == 2){\\n                        return ans;\\n                    }\\n                }\\n                return ans;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```\\n\\nThe above one can get into TLE for some corner case. Till now it passed.\\nBut the better soln will be\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        map<int,int> binMap;\\n        \\n        for(int i=0; i<m; i++) {\\n            int num = 0;\\n            for(int j=0; j<n; j++) {\\n                num <<= 1;\\n                num |= grid[i][j];\\n            }\\n            binMap[num] = i;\\n            for(int k=1; k<32; k++) {\\n                if(!(k&num)) {\\n                   if(binMap.count(k)) {\\n                        return {binMap[k], i};\\n                    } \\n                }\\n            }\\n            \\n            if(num == 0) {\\n                return {i};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        map<int, map<int, vector<int>>> binMap;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                binMap[j][grid[i][j]].push_back(i);\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++) {\\n            set<int> npossRows;\\n            bool bad = false;\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1){\\n                    if(binMap[j][1].size() == m) {\\n                        bad = true;\\n                        break;\\n                    }\\n                    for(auto rw:binMap[j][1]) {\\n                        npossRows.insert(rw);\\n                    }   \\n                }\\n                \\n                if(npossRows.size() >= m) {\\n                    break;\\n                }\\n            }\\n            // for(auto rw:npossRows)cout<<rw<<\" \";\\n            // cout<<endl;\\n            if(!bad && npossRows.size() <= m-1){\\n                vector<int> ans;\\n                for(int k=0; k<m; k++) {\\n                    if(k==i) {\\n                        ans.push_back(k);\\n                    }else if(!npossRows.count(k)) {\\n                        ans.push_back(k);\\n                    }\\n                    if(ans.size() == 2){\\n                        return ans;\\n                    }\\n                }\\n                return ans;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        map<int,int> binMap;\\n        \\n        for(int i=0; i<m; i++) {\\n            int num = 0;\\n            for(int j=0; j<n; j++) {\\n                num <<= 1;\\n                num |= grid[i][j];\\n            }\\n            binMap[num] = i;\\n            for(int k=1; k<32; k++) {\\n                if(!(k&num)) {\\n                   if(binMap.count(k)) {\\n                        return {binMap[k], i};\\n                    } \\n                }\\n            }\\n            \\n            if(num == 0) {\\n                return {i};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3622585,
                "title": "any-good-mathematical-proof-to-why-k-is-2",
                "content": "There are many solutions that use this assumption, some try to explain in a very approximative intuitive way, but is there a rigorous proof ?\\n\\nI\\'ve browsed all the top-voted solutions and I didn\\'t find one",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3622560,
                "title": "my-solution",
                "content": "```\\n/**\\n * some conclusions\\n * if there exists a good subset, it should contain 1 row or 2 rows\\n * 1. if a good subset contains just 1 row, every element of this row should be `0`\\n *    if such a one-row subset exists, return it\\n * 2. if there exist no such one-row good subsets,\\n *    try to find a good subset which contains two rows\\n *    if there exist such two-row subset, then every column of these two rows can be both `1`\\n *    if such a two-row subset exists, return it\\n * 3. if there exist no such two-row good subsets,\\n *    try to find a good subset which contains three row\\n *    however, if there exist such a three-row good subset,\\n *             every column of this three-row subset has sum less than or equal to `1`\\n *             pick any row from these three rows and remove it,\\n *             the remained two-row subset should be good.\\n *             it\\'s a contradiction with the fact that there doesn\\'t exist a two-row good subset.\\n *    the conclusion is that it\\'s unnecessary to consider any odd-row subset,\\n *                           which has more than or equal to 3 rows\\n * 4. try to find a good subset which contains four rows\\n * 4.1 there exist 6 (`C(4, 2)`, that is `4 * 3 / 2`) options to pick two rows from four rows\\n *     i) in every two-row option, there exist at least one column which has the sum of `2`\\n *     ii) there exist at most 5 columns\\n *     so there exist at least one column which has the sum of `4` for any four-row subset,\\n *     that is no good four-row subsets exist.\\n * 5. the same conclusions can be drawn for any even-row subsets,\\n *    which has more than 4 rows\\n *\\n * Time Complexity: O(rows * cols + (2 ^ cols) * (2 ^ cols))\\n * Space Complexity: O(2 ^ cols)\\n * where `rows` the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n private:\\n  static constexpr int invalid_row = -1;\\n  \\n public:\\n  vector<int> goodSubsetofBinaryMatrix(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    int layouts = 1 << cols;\\n    int layout_to_row[layouts];\\n    memset(layout_to_row, invalid_row, sizeof(layout_to_row));\\n    for (int r = 0; r < rows; ++r) {\\n      int layout = 0;\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == 1) {\\n          layout |= 1 << c;\\n        }\\n      }\\n      layout_to_row[layout] = r;\\n    }\\n    \\n    if (layout_to_row[0] != invalid_row) {\\n      return vector<int>{layout_to_row[0]};\\n    }\\n    \\n    for (int layout1 = 0; layout1 < layouts; ++layout1) {\\n      if (layout_to_row[layout1] == invalid_row) {\\n        continue;\\n      }\\n      for (int layout2 = 0; layout2 < layouts; ++layout2) {\\n        if (layout_to_row[layout2] == invalid_row ||\\n            layout_to_row[layout1] > layout_to_row[layout2] ||\\n            (layout1 & layout2) != 0) {\\n          continue;\\n        }\\n        \\n        return vector<int>{layout_to_row[layout1], layout_to_row[layout2]};\\n      }\\n    }\\n    return {};\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * some conclusions\\n * if there exists a good subset, it should contain 1 row or 2 rows\\n * 1. if a good subset contains just 1 row, every element of this row should be `0`\\n *    if such a one-row subset exists, return it\\n * 2. if there exist no such one-row good subsets,\\n *    try to find a good subset which contains two rows\\n *    if there exist such two-row subset, then every column of these two rows can be both `1`\\n *    if such a two-row subset exists, return it\\n * 3. if there exist no such two-row good subsets,\\n *    try to find a good subset which contains three row\\n *    however, if there exist such a three-row good subset,\\n *             every column of this three-row subset has sum less than or equal to `1`\\n *             pick any row from these three rows and remove it,\\n *             the remained two-row subset should be good.\\n *             it\\'s a contradiction with the fact that there doesn\\'t exist a two-row good subset.\\n *    the conclusion is that it\\'s unnecessary to consider any odd-row subset,\\n *                           which has more than or equal to 3 rows\\n * 4. try to find a good subset which contains four rows\\n * 4.1 there exist 6 (`C(4, 2)`, that is `4 * 3 / 2`) options to pick two rows from four rows\\n *     i) in every two-row option, there exist at least one column which has the sum of `2`\\n *     ii) there exist at most 5 columns\\n *     so there exist at least one column which has the sum of `4` for any four-row subset,\\n *     that is no good four-row subsets exist.\\n * 5. the same conclusions can be drawn for any even-row subsets,\\n *    which has more than 4 rows\\n *\\n * Time Complexity: O(rows * cols + (2 ^ cols) * (2 ^ cols))\\n * Space Complexity: O(2 ^ cols)\\n * where `rows` the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n private:\\n  static constexpr int invalid_row = -1;\\n  \\n public:\\n  vector<int> goodSubsetofBinaryMatrix(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    int layouts = 1 << cols;\\n    int layout_to_row[layouts];\\n    memset(layout_to_row, invalid_row, sizeof(layout_to_row));\\n    for (int r = 0; r < rows; ++r) {\\n      int layout = 0;\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == 1) {\\n          layout |= 1 << c;\\n        }\\n      }\\n      layout_to_row[layout] = r;\\n    }\\n    \\n    if (layout_to_row[0] != invalid_row) {\\n      return vector<int>{layout_to_row[0]};\\n    }\\n    \\n    for (int layout1 = 0; layout1 < layouts; ++layout1) {\\n      if (layout_to_row[layout1] == invalid_row) {\\n        continue;\\n      }\\n      for (int layout2 = 0; layout2 < layouts; ++layout2) {\\n        if (layout_to_row[layout2] == invalid_row ||\\n            layout_to_row[layout1] > layout_to_row[layout2] ||\\n            (layout1 & layout2) != 0) {\\n          continue;\\n        }\\n        \\n        return vector<int>{layout_to_row[layout1], layout_to_row[layout2]};\\n      }\\n    }\\n    return {};\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622549,
                "title": "python3-written-explanation",
                "content": "# Intuition\\nThe only solutions we are interested in are set containing 1 or 2 rows. if 1 row all elements should be 0 , if 2 rows then & of each column should be 0. for more than 2 row good sets there is always a subset of 2 rows that satisfies the condition.\\n# Approach\\nFirst we get all the unique rows by converting each row into decimal x and adding it to a set. We add orignal index of decimal x into a hashmap.\\nThen we loop over our set to see if any element is 0 , if it is 0 the solution is set with single row.\\nWe use a 2d loop to check if any combination of elements have bitwise and 0. which means sum at each column is atmost 1 but size of set is 2 so its valid solution.\\nWe retrieve the indexes of our row using the hashmap.\\n# Complexity\\nTime complexity:\\n- O(N*M)to get unique rows.\\n- if there are X unique rows the rest of code is O(X^2) but X can be max 2^M.\\n\\noverall O(N*M+2^(2M))\\n\\n# Code\\n```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid)\\n        s = set()\\n        ind={}\\n        for i in range(n):\\n            x = 0\\n            for j in grid[i]:\\n                x = (x << 1) | j\\n            s.add((x))\\n            ind[x]=i\\n        gr = list(s)\\n        n = len(gr)\\n        for i in range(n):\\n            x=gr[i]\\n            if x == 0:\\n                return [ind[x]]\\n        for i in range(n):\\n            x=gr[i]\\n            for j in range(i + 1, n):\\n                y=gr[j]\\n                if x&y == 0:\\n                    return sorted([ind[x], ind[y]])\\n        return []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid)\\n        s = set()\\n        ind={}\\n        for i in range(n):\\n            x = 0\\n            for j in grid[i]:\\n                x = (x << 1) | j\\n            s.add((x))\\n            ind[x]=i\\n        gr = list(s)\\n        n = len(gr)\\n        for i in range(n):\\n            x=gr[i]\\n            if x == 0:\\n                return [ind[x]]\\n        for i in range(n):\\n            x=gr[i]\\n            for j in range(i + 1, n):\\n                y=gr[j]\\n                if x&y == 0:\\n                    return sorted([ind[x], ind[y]])\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622516,
                "title": "javascript-magic-solution-time-o-m-n-space-o-m",
                "content": "# Intuition\\nI think, if we have binary something we must use something bitwise. For instance, <&> here and looking for pairs with 0 between all digits\\n\\n# Approach\\nLet\\'s separate rows with all zeroes and return them if we do not have any pairs.\\nIterating and looking for valid pair, but why only one pair, why not bigger, I still do not understand o_O\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar goodSubsetofBinaryMatrix = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const zeroIndexes = new Set();\\n    for (let i = 0 ; i < m ; i++) {\\n        let isOnlyZeroes = true;\\n        for (const num of grid[i]) {\\n            if (num !== 0) {\\n                isOnlyZeroes = false;\\n            }\\n        }\\n        if (isOnlyZeroes) {\\n            zeroIndexes.add(i);\\n        }\\n    }\\n    for (let i = 0 ; i < m; i++) {\\n        if (zeroIndexes.has(i)) {\\n            continue;\\n        }\\n        for (let j = i+1; j < m; j++) {\\n            if (zeroIndexes.has(j)) {\\n                continue\\n            }\\n            let validPair = true;\\n            for (let k = 0; k < n; k++) {\\n                if (grid[i][k] & grid[j][k] !== 0) {\\n                    validPair = false\\n                }\\n            }\\n            if (validPair) {\\n                return [i, j]\\n            }\\n        }\\n    }\\n    return [...zeroIndexes].sort((a, b) => a - b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar goodSubsetofBinaryMatrix = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const zeroIndexes = new Set();\\n    for (let i = 0 ; i < m ; i++) {\\n        let isOnlyZeroes = true;\\n        for (const num of grid[i]) {\\n            if (num !== 0) {\\n                isOnlyZeroes = false;\\n            }\\n        }\\n        if (isOnlyZeroes) {\\n            zeroIndexes.add(i);\\n        }\\n    }\\n    for (let i = 0 ; i < m; i++) {\\n        if (zeroIndexes.has(i)) {\\n            continue;\\n        }\\n        for (let j = i+1; j < m; j++) {\\n            if (zeroIndexes.has(j)) {\\n                continue\\n            }\\n            let validPair = true;\\n            for (let k = 0; k < n; k++) {\\n                if (grid[i][k] & grid[j][k] !== 0) {\\n                    validPair = false\\n                }\\n            }\\n            if (validPair) {\\n                return [i, j]\\n            }\\n        }\\n    }\\n    return [...zeroIndexes].sort((a, b) => a - b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3622487,
                "title": "bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     static int idx;\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        HashMap<Integer, Integer> fre = new HashMap<>();\\n        ll:\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    continue ll;\\n                }\\n            }\\n            res.add(i);\\n            return res;\\n        }\\n        for (int i = 0; i < grid.length; i++) {\\n            int c = 0;\\n            for (int j = 0; j < grid[0].length; j++) {\\n                c += (1 << j) * grid[i][j];\\n            }\\n            idx = -1;\\n            int v = 1<<(grid[0].length-1);\\n            sol(0,fre,v,c);\\n            if(idx!=-1){\\n                res.add(idx);\\n                res.add(i);\\n                return res;\\n            }\\n            fre.put(c,i);\\n        }\\n        return res;\\n    }\\n\\n    static void sol(int v, HashMap<Integer, Integer> fre, int e, int val) {\\n        if (e == 0) {\\n            if (fre.get(v) != null) {\\n                idx = fre.get(v);\\n            }\\n            return;\\n        }\\n        if ((val & e) > 0) {\\n            e >>= 1;\\n            sol(v, fre, e, val);\\n        } else {\\n            int c = e >> 1;\\n            sol(v + e, fre, c, val);\\n            sol(v, fre, c, val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     static int idx;\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        HashMap<Integer, Integer> fre = new HashMap<>();\\n        ll:\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    continue ll;\\n                }\\n            }\\n            res.add(i);\\n            return res;\\n        }\\n        for (int i = 0; i < grid.length; i++) {\\n            int c = 0;\\n            for (int j = 0; j < grid[0].length; j++) {\\n                c += (1 << j) * grid[i][j];\\n            }\\n            idx = -1;\\n            int v = 1<<(grid[0].length-1);\\n            sol(0,fre,v,c);\\n            if(idx!=-1){\\n                res.add(idx);\\n                res.add(i);\\n                return res;\\n            }\\n            fre.put(c,i);\\n        }\\n        return res;\\n    }\\n\\n    static void sol(int v, HashMap<Integer, Integer> fre, int e, int val) {\\n        if (e == 0) {\\n            if (fre.get(v) != null) {\\n                idx = fre.get(v);\\n            }\\n            return;\\n        }\\n        if ((val & e) > 0) {\\n            e >>= 1;\\n            sol(v, fre, e, val);\\n        } else {\\n            int c = e >> 1;\\n            sol(v + e, fre, c, val);\\n            sol(v, fre, c, val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622480,
                "title": "c-very-simple-solution-only-32-possible-states",
                "content": "1. Max columns is 5. Therefore, 2^5 = 32 states.\\n2. If there is a row with all zeros, it will be the answer.\\n3. Else, Optimal answer only has 2 rows.\\n4. Therefore, if `row_a & row_b == 0`, it will be good subset. \\n\\nProof for point 3 by contradiction:\\nIf optimal answer has 3 rows: `floor(3/2) == 1`\\nTherefore, for answer to fulfil good subset criteria\\n`row_a & row_b & row_c == 0`. Hence `row_a & row_b == 0`. Third row is redundant.  \\n\\nIf optimal answer has 4 rows: `floor(4/2) == 2`\\nYou can split into 2 pairs, where at least one of the pair fulfils good subset criteria.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<vector<int>> count(32);\\n        for (int i = 0; i < grid.size(); ++i) {\\n            int curr = 0;\\n            for (int j = 0; j < grid[i].size(); ++j) {\\n                curr += grid[i][j] << j;\\n            }\\n            count[curr].push_back(i);\\n        }\\n        if (count[0].size() > 0) return {count[0][0]};\\n        \\n        for (int i = 0; i < count.size(); ++i) {\\n            for (int j = 0; j < count.size(); j++) {\\n                if (i != j && (i & j) == 0 && count[i].size() > 0 && count[j].size() > 0) {\\n                    vector<int> ans{count[i][0], count[j][0]};\\n                    sort(ans.begin(), ans.end());\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<vector<int>> count(32);\\n        for (int i = 0; i < grid.size(); ++i) {\\n            int curr = 0;\\n            for (int j = 0; j < grid[i].size(); ++j) {\\n                curr += grid[i][j] << j;\\n            }\\n            count[curr].push_back(i);\\n        }\\n        if (count[0].size() > 0) return {count[0][0]};\\n        \\n        for (int i = 0; i < count.size(); ++i) {\\n            for (int j = 0; j < count.size(); j++) {\\n                if (i != j && (i & j) == 0 && count[i].size() > 0 && count[j].size() > 0) {\\n                    vector<int> ans{count[i][0], count[j][0]};\\n                    sort(ans.begin(), ans.end());\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622473,
                "title": "c-iterate-through-all-possible-subsets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere can be at most 2^5 possible vectors.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every vector we can find its pair, such that sum of each coloum of both vectors is less than equal to 1. If there is no such vector than the ans is empty.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int> id, ans;\\n    map<vector<int>,vector<int>> mp;\\n    bool found = 0;\\n\\n    // v is original vector given.\\n    // id is the one we require to form pair with v.\\n    void call(int i, vector<int> &v){\\n        if(found) return;\\n        if(i == m){\\n            // check if required coloumn exists.\\n            if(mp.find(id) != mp.end()){\\n                // if yes than we have found answer\\n                found = 1;\\n                ans.push_back(mp[id][0]);\\n\\n                // this checks if array is same.\\n                if(v == id) return;\\n\\n                // else push index of both the vector.\\n                ans.push_back(mp[v][0]);\\n            }\\n            return;\\n        }\\n\\n        if(v[i] == 1){\\n            // has to be zero since sum cannot be greater than 1 and \\n            // our vector already has 1.\\n            id[i] = 0;\\n            call(i + 1, v);\\n        }\\n        else{\\n            // can be either 0 or 1.\\n            id[i] = 1;\\n            call(i + 1, v);\\n            id[i] = 0;\\n            call(i + 1, v);\\n        }\\n        return;\\n    }\\n\\n\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        id.resize(m,0);\\n        found = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            mp[grid[i]].push_back(i);\\n        }\\n\\n        for(auto &[vec, x] : mp){\\n            vector<int> temp = vec;\\n            // find if its pair exists.\\n            call(0,temp);\\n            // if yes it exists break.\\n            if(found) break;\\n        }\\n        sort(ans.begin(),ans.end());\\n        mp.clear();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int> id, ans;\\n    map<vector<int>,vector<int>> mp;\\n    bool found = 0;\\n\\n    // v is original vector given.\\n    // id is the one we require to form pair with v.\\n    void call(int i, vector<int> &v){\\n        if(found) return;\\n        if(i == m){\\n            // check if required coloumn exists.\\n            if(mp.find(id) != mp.end()){\\n                // if yes than we have found answer\\n                found = 1;\\n                ans.push_back(mp[id][0]);\\n\\n                // this checks if array is same.\\n                if(v == id) return;\\n\\n                // else push index of both the vector.\\n                ans.push_back(mp[v][0]);\\n            }\\n            return;\\n        }\\n\\n        if(v[i] == 1){\\n            // has to be zero since sum cannot be greater than 1 and \\n            // our vector already has 1.\\n            id[i] = 0;\\n            call(i + 1, v);\\n        }\\n        else{\\n            // can be either 0 or 1.\\n            id[i] = 1;\\n            call(i + 1, v);\\n            id[i] = 0;\\n            call(i + 1, v);\\n        }\\n        return;\\n    }\\n\\n\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        id.resize(m,0);\\n        found = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            mp[grid[i]].push_back(i);\\n        }\\n\\n        for(auto &[vec, x] : mp){\\n            vector<int> temp = vec;\\n            // find if its pair exists.\\n            call(0,temp);\\n            // if yes it exists break.\\n            if(found) break;\\n        }\\n        sort(ans.begin(),ans.end());\\n        mp.clear();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622465,
                "title": "very-dumb-brute-force-solution",
                "content": "# Intuition\\nI just assumed that in all cases we will need at most n sets and we never should include 2 same sets in solution. It turned out to be true. \\n\\nI think considering n=2 and n=3 in my mind helped me to find it.\\n\\n# Approach\\nLet\\'s find which sets we have and save them, we will have at most 2^n sets. Now let\\'s pick at most n sets and see if it works. If yes, return, if no continue until we tried all combination of sets.\\n\\nIt should be done using recursion or something but I did it in the dumb copy-paste way.\\n\\n# Complexity\\n- Time complexity:\\nO(m + (2^n)^n)\\n\\n- Space complexity:\\nI dunno,not much.\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\ndef add_bits(numbers):\\n    # Initialize counters for each bit\\n    counters = [0] * 5\\n    \\n    for num in numbers:\\n        for i in range(5):\\n            counters[i] += (num >> i) & 1\\n            \\n    result = \\'\\'.join(str(counters[i]) for i in range(4, -1, -1))\\n    \\n    return [int(result)]\\n\\nclass Solution:\\n    \\n    def solve5(self, grid, n, l, dd):\\n        for a in range(l):\\n            if dd[a] < 0:\\n                continue\\n            for b in range(a+1, l):\\n                if dd[b] < 0:\\n                    continue\\n                for c in range(b+1, l):\\n                    if dd[c] < 0:\\n                        continue\\n                    for d in range(c+1, l):\\n                        if dd[d] < 0:\\n                            continue\\n                        for e in range(d+1, l):\\n                            if dd[e] < 0:\\n                                continue\\n                            counters = [0] * n\\n                            for num in [a, b, c, d, e]:\\n                                for i in range(n):\\n                                    counters[i] += (num >> i) & 1\\n                            good = True\\n                            for i in counters:\\n                                if i * 2 > 5:\\n                                    good = False\\n                                    break\\n                            if good:\\n                                return sorted([dd[a], dd[b], dd[c], dd[d], dd[e]])\\n        return []\\n                            \\n    def solve4(self, grid, n, l, dd):\\n        for a in range(l):\\n            if dd[a] < 0:\\n                continue\\n            for b in range(a+1, l):\\n                if dd[b] < 0:\\n                    continue\\n                for c in range(b+1, l):\\n                    if dd[c] < 0:\\n                        continue\\n                    for d in range(c+1, l):\\n                        if dd[d] < 0:\\n                            continue\\n                        print([a, b, c, d])\\n                        counters = [0] * n\\n                        for num in [a, b, c, d]:\\n                            for i in range(n):\\n                                counters[i] += (num >> i) & 1\\n                        good = True\\n                        for i in counters:\\n                            if i * 2 > 4:\\n                                good = False\\n                                break\\n                        if good:\\n                            return sorted([dd[a], dd[b], dd[c], dd[d]])\\n        return []\\n    def solve3(self, grid, n, l, dd):\\n        for a in range(l):\\n            if dd[a] < 0:\\n                continue\\n            for b in range(a+1, l):\\n                if dd[b] < 0:\\n                    continue\\n                for c in range(b+1, l):\\n                    if dd[c] < 0:\\n                        continue\\n                    counters = [0] * n\\n                    for num in [a, b, c]:\\n                        for i in range(n):\\n                            counters[i] += (num >> i) & 1\\n                    good = True\\n                    for i in counters:\\n                        if i * 2 > 3:\\n                            good = False\\n                            break\\n                    if good:\\n                        return sorted([dd[a], dd[b], dd[c]])\\n        return []\\n    def solve2(self, grid, n, l, dd):\\n        for a in range(l):\\n            if dd[a] < 0:\\n                continue\\n            for b in range(a+1, l):\\n                if dd[b] < 0:\\n                    continue\\n                counters = [0] * n\\n                for num in [a, b]:\\n                    for i in range(n):\\n                        counters[i] += (num >> i) & 1\\n                good = True\\n                for i in counters:\\n                    if i * 2 > 2:\\n                        good = False\\n                        break\\n                if good:\\n                    return sorted([dd[a], dd[b]])\\n        return []\\n   \\n    def solve1(self, grid, m, l, dd):\\n            for i in range(m):\\n                if sum(grid[i]) == 0:\\n                    return [i]\\n            return []\\n        \\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        #print(m, n)\\n        \\n        dd = [-1] * (2 ** n)\\n        \\n        for i in range(m):\\n            deg = 1\\n            val = 0\\n            for j in range(n):\\n                if grid[i][j]:\\n                    val += deg\\n                deg *= 2\\n            dd[val] = i\\n        \\n        l = 2 ** n\\n\\n        a = self.solve1(grid, m, l, dd) # DIFF\\n        b = self.solve2(grid, n, l, dd)\\n        c = self.solve3(grid, n, l, dd)\\n        d = self.solve4(grid, n, l, dd)\\n        e = self.solve5(grid, n, l, dd)\\n          \\n        for x in [a, b, c, d, e]:\\n            if len(x) > 0:\\n                return x\\n        return []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\ndef add_bits(numbers):\\n    # Initialize counters for each bit\\n    counters = [0] * 5\\n    \\n    for num in numbers:\\n        for i in range(5):\\n            counters[i] += (num >> i) & 1\\n            \\n    result = \\'\\'.join(str(counters[i]) for i in range(4, -1, -1))\\n    \\n    return [int(result)]\\n\\nclass Solution:\\n    \\n    def solve5(self, grid, n, l, dd):\\n        for a in range(l):\\n            if dd[a] < 0:\\n                continue\\n            for b in range(a+1, l):\\n                if dd[b] < 0:\\n                    continue\\n                for c in range(b+1, l):\\n                    if dd[c] < 0:\\n                        continue\\n                    for d in range(c+1, l):\\n                        if dd[d] < 0:\\n                            continue\\n                        for e in range(d+1, l):\\n                            if dd[e] < 0:\\n                                continue\\n                            counters = [0] * n\\n                            for num in [a, b, c, d, e]:\\n                                for i in range(n):\\n                                    counters[i] += (num >> i) & 1\\n                            good = True\\n                            for i in counters:\\n                                if i * 2 > 5:\\n                                    good = False\\n                                    break\\n                            if good:\\n                                return sorted([dd[a], dd[b], dd[c], dd[d], dd[e]])\\n        return []\\n                            \\n    def solve4(self, grid, n, l, dd):\\n        for a in range(l):\\n            if dd[a] < 0:\\n                continue\\n            for b in range(a+1, l):\\n                if dd[b] < 0:\\n                    continue\\n                for c in range(b+1, l):\\n                    if dd[c] < 0:\\n                        continue\\n                    for d in range(c+1, l):\\n                        if dd[d] < 0:\\n                            continue\\n                        print([a, b, c, d])\\n                        counters = [0] * n\\n                        for num in [a, b, c, d]:\\n                            for i in range(n):\\n                                counters[i] += (num >> i) & 1\\n                        good = True\\n                        for i in counters:\\n                            if i * 2 > 4:\\n                                good = False\\n                                break\\n                        if good:\\n                            return sorted([dd[a], dd[b], dd[c], dd[d]])\\n        return []\\n    def solve3(self, grid, n, l, dd):\\n        for a in range(l):\\n            if dd[a] < 0:\\n                continue\\n            for b in range(a+1, l):\\n                if dd[b] < 0:\\n                    continue\\n                for c in range(b+1, l):\\n                    if dd[c] < 0:\\n                        continue\\n                    counters = [0] * n\\n                    for num in [a, b, c]:\\n                        for i in range(n):\\n                            counters[i] += (num >> i) & 1\\n                    good = True\\n                    for i in counters:\\n                        if i * 2 > 3:\\n                            good = False\\n                            break\\n                    if good:\\n                        return sorted([dd[a], dd[b], dd[c]])\\n        return []\\n    def solve2(self, grid, n, l, dd):\\n        for a in range(l):\\n            if dd[a] < 0:\\n                continue\\n            for b in range(a+1, l):\\n                if dd[b] < 0:\\n                    continue\\n                counters = [0] * n\\n                for num in [a, b]:\\n                    for i in range(n):\\n                        counters[i] += (num >> i) & 1\\n                good = True\\n                for i in counters:\\n                    if i * 2 > 2:\\n                        good = False\\n                        break\\n                if good:\\n                    return sorted([dd[a], dd[b]])\\n        return []\\n   \\n    def solve1(self, grid, m, l, dd):\\n            for i in range(m):\\n                if sum(grid[i]) == 0:\\n                    return [i]\\n            return []\\n        \\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        #print(m, n)\\n        \\n        dd = [-1] * (2 ** n)\\n        \\n        for i in range(m):\\n            deg = 1\\n            val = 0\\n            for j in range(n):\\n                if grid[i][j]:\\n                    val += deg\\n                deg *= 2\\n            dd[val] = i\\n        \\n        l = 2 ** n\\n\\n        a = self.solve1(grid, m, l, dd) # DIFF\\n        b = self.solve2(grid, n, l, dd)\\n        c = self.solve3(grid, n, l, dd)\\n        d = self.solve4(grid, n, l, dd)\\n        e = self.solve5(grid, n, l, dd)\\n          \\n        for x in [a, b, c, d, e]:\\n            if len(x) > 0:\\n                return x\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622444,
                "title": "easy-c-solution-intuition-from-n-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAnswer will be always -> 1. 1 Row OR 2. 2 Rows \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n*5)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        cout << m << \" \" << n << endl;\\n\\n        // 1. Check 0 row -> {0, 0, 0, ...}\\n        for (int i = 0; i < m; i++)\\n        {\\n            bool a0 = true;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                    a0 = false;\\n            }\\n            if (a0 == true)\\n                return {i};\\n        }\\n\\n        // 2. Check alternate or 0 rows -> {0, 1, 1, 0} & {0, 0, 0, 1}\\n        for (int i = 0; i < m - 1; i++)\\n        {\\n            for (int j = i + 1; j < m; j++)\\n            {\\n                int sum = 0;\\n                for (int k = 0; k < n; k++)\\n                    sum += (grid[i][k] && grid[j][k]);\\n                \\n                if (sum == 0)\\n                    return {i, j};\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        cout << m << \" \" << n << endl;\\n\\n        // 1. Check 0 row -> {0, 0, 0, ...}\\n        for (int i = 0; i < m; i++)\\n        {\\n            bool a0 = true;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                    a0 = false;\\n            }\\n            if (a0 == true)\\n                return {i};\\n        }\\n\\n        // 2. Check alternate or 0 rows -> {0, 1, 1, 0} & {0, 0, 0, 1}\\n        for (int i = 0; i < m - 1; i++)\\n        {\\n            for (int j = i + 1; j < m; j++)\\n            {\\n                int sum = 0;\\n                for (int k = 0; k < n; k++)\\n                    sum += (grid[i][k] && grid[j][k]);\\n                \\n                if (sum == 0)\\n                    return {i, j};\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3622428,
                "title": "simple-bitmasking-intutive-solution-very-easy-c-explained-solution-o-32-32",
                "content": "# Intuition\\nI observed that size of good subset can be 1 or 2. So, If we have a good subset of size of 2, then we can generate a good subset of further size(if possible).\\nHere, firstly I observed that constraints on column is very small (<=5). So, I converted each row into number (or mask) and stored in the set. So, Maximum number which can be formed will be less than 32. then, we can run a loop of O(32*32) to check whether two numbers\\' BITWISE AND is 0. If both number\\'s mask is present, then I returned their indices in ascending order\\n\\n# Approach\\nHow to observe that atmost size of 2 is needed for a good subset? Since, sum of each column should be atmost floor(len/2) that means number of 1 present should be atmost half of len. Now, take any example of good subset of rows of size>2, you will observe that if we take take only two rows optimally, then we can also create good subset of rows.\\n\\n# Complexity\\n- Time complexity:\\nO(M*N + 32*32)\\n\\n- Space complexity:\\nO(32*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& a) {\\n        vector<int>v;\\n        map<int,set<int>>mp;\\n        int m=a.size();\\n        int n=a[0].size();\\n        for(int i=0;i<m;i++){\\n            //Converting the row into mask or decimal number\\n            int tmp=0;\\n            for(int j=0;j<n;j++){\\n                if(a[i][j]==1){\\n                    tmp=tmp|(1<<j);\\n                }\\n            }\\n            //If we found 0 number, then it will definitely good, hence returned\\n            if(tmp==0) return {i};\\n            mp[tmp].insert(i); //Insert into map of that number\\n        }\\n\\n        //now running a loop of 32*32 to check if their AND is ZERO\\n        for(int i=1;i<32;i++){\\n            if(mp.find(i)==mp.end())continue;\\n            for(int j=i+1;j<32;j++){\\n                //If both number are present as some row in matrix and their AND is zero\\n                if((i&j)==0 && mp.find(i)!=mp.end() && mp.find(j)!=mp.end()){\\n                    int x=*mp[i].begin();\\n                    int y=*mp[j].begin();\\n                    if(x>y) swap(x,y);\\n                    return {x,y};\\n                }\\n            }\\n        }\\n        return {}; //If not found any such pair, return empty vector\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& a) {\\n        vector<int>v;\\n        map<int,set<int>>mp;\\n        int m=a.size();\\n        int n=a[0].size();\\n        for(int i=0;i<m;i++){\\n            //Converting the row into mask or decimal number\\n            int tmp=0;\\n            for(int j=0;j<n;j++){\\n                if(a[i][j]==1){\\n                    tmp=tmp|(1<<j);\\n                }\\n            }\\n            //If we found 0 number, then it will definitely good, hence returned\\n            if(tmp==0) return {i};\\n            mp[tmp].insert(i); //Insert into map of that number\\n        }\\n\\n        //now running a loop of 32*32 to check if their AND is ZERO\\n        for(int i=1;i<32;i++){\\n            if(mp.find(i)==mp.end())continue;\\n            for(int j=i+1;j<32;j++){\\n                //If both number are present as some row in matrix and their AND is zero\\n                if((i&j)==0 && mp.find(i)!=mp.end() && mp.find(j)!=mp.end()){\\n                    int x=*mp[i].begin();\\n                    int y=*mp[j].begin();\\n                    if(x>y) swap(x,y);\\n                    return {x,y};\\n                }\\n            }\\n        }\\n        return {}; //If not found any such pair, return empty vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622403,
                "title": "very-simple-and-iterative-and-brute-force-with-explanations-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif the sum of columns of k subsets of rows should be less than or equal to k/2 then this means there either there is a row full of 0\\'s or there exists a 2 rows (i, j) where sum of each columns is less than 1 or bitwise AND of the row j & i is 0.\\n\\n# Complexity\\n- Time complexity: `O(N^2)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& arr) {\\n        int m = arr.size(), n = arr[0].size();\\n        for(int i = 0; i < m; i++)if(accumulate(arr[i].begin(), arr[i].end(), 0LL) == 0)return {i};\\n        for(int i = 0; i < m; i++){\\n            for(int j = i + 1; j < m; j++){\\n                int s = 0;\\n                for(int k = 0; k < n; k++){\\n                    s += (arr[i][k] & arr[j][k]);\\n                }\\n                // cout<<i<<\" \"<<j<<\" \"<<s<<endl;\\n                if(s == 0)return {i, j};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bitmask"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& arr) {\\n        int m = arr.size(), n = arr[0].size();\\n        for(int i = 0; i < m; i++)if(accumulate(arr[i].begin(), arr[i].end(), 0LL) == 0)return {i};\\n        for(int i = 0; i < m; i++){\\n            for(int j = i + 1; j < m; j++){\\n                int s = 0;\\n                for(int k = 0; k < n; k++){\\n                    s += (arr[i][k] & arr[j][k]);\\n                }\\n                // cout<<i<<\" \"<<j<<\" \"<<s<<endl;\\n                if(s == 0)return {i, j};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3622397,
                "title": "linear-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        //there are two options: \\n        //1) either all zero row\\n        //2) or complementary row\\n        int cnt_rows[32];\\n        int row_id[32];\\n        for(int i = 0; i < 32; i++){\\n            cnt_rows[i] = 0;\\n            row_id[i] = -1;\\n        }\\n        for(int i = 0; i < grid.size(); i++){\\n            int cnt = 0;\\n            for(int j = 0; j < grid[i].size(); j++){\\n                cnt = (cnt << 1) + grid[i][j];\\n            }\\n            if(cnt == 0)\\n                return {i};\\n            cnt_rows[cnt] = 1;\\n            row_id[cnt] = i;\\n        }\\n        for(int i = 0; i < 32; i++)\\n            for(int j = i+1; j < 32; j++){\\n                if((i & j) == 0 && cnt_rows[i] > 0 && cnt_rows[j] > 0){\\n                    return {min(row_id[i], row_id[j]), max(row_id[j], row_id[i])};\\n                }\\n            }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        //there are two options: \\n        //1) either all zero row\\n        //2) or complementary row\\n        int cnt_rows[32];\\n        int row_id[32];\\n        for(int i = 0; i < 32; i++){\\n            cnt_rows[i] = 0;\\n            row_id[i] = -1;\\n        }\\n        for(int i = 0; i < grid.size(); i++){\\n            int cnt = 0;\\n            for(int j = 0; j < grid[i].size(); j++){\\n                cnt = (cnt << 1) + grid[i][j];\\n            }\\n            if(cnt == 0)\\n                return {i};\\n            cnt_rows[cnt] = 1;\\n            row_id[cnt] = i;\\n        }\\n        for(int i = 0; i < 32; i++)\\n            for(int j = i+1; j < 32; j++){\\n                if((i & j) == 0 && cnt_rows[i] > 0 && cnt_rows[j] > 0){\\n                    return {min(row_id[i], row_id[j]), max(row_id[j], row_id[i])};\\n                }\\n            }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622338,
                "title": "python-3-hash-table-no-more-than-2-rows",
                "content": "# Intuition\\nIf there is an all-0 row, return it. Otherwise, find two rows without 1 occuring at the same column index.\\n\\n# Code\\n```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        # 1 <= n <= 5\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        dc = defaultdict(int)\\n        for i in range(m):\\n            s = sum(grid[i])\\n            if not s:\\n                return [i]\\n            if s < n and tuple(grid[i]) not in dc:\\n                dc[tuple(grid[i])] = i\\n        \\n        def find(tp):\\n            ones = []\\n            for i in range(n):\\n                if not tp[i]:\\n                    ones.append(i)\\n            for cnt in range(1, len(ones) + 1):\\n                for c in (combinations(ones, cnt)):\\n                    arr = [0] * n\\n                    for idx in c:\\n                        arr[idx] = 1\\n                    tp_tar = tuple(arr)\\n                    if tp_tar in dc:\\n                        return sorted([dc[tp], dc[tp_tar]])\\n            return []\\n            \\n        keys = list(dc.keys())\\n        keys.sort(key = lambda x: sum(x))\\n        \\n        for tp in keys:\\n            res = find(tp)\\n            if res:\\n                return res\\n        return []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        # 1 <= n <= 5\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        dc = defaultdict(int)\\n        for i in range(m):\\n            s = sum(grid[i])\\n            if not s:\\n                return [i]\\n            if s < n and tuple(grid[i]) not in dc:\\n                dc[tuple(grid[i])] = i\\n        \\n        def find(tp):\\n            ones = []\\n            for i in range(n):\\n                if not tp[i]:\\n                    ones.append(i)\\n            for cnt in range(1, len(ones) + 1):\\n                for c in (combinations(ones, cnt)):\\n                    arr = [0] * n\\n                    for idx in c:\\n                        arr[idx] = 1\\n                    tp_tar = tuple(arr)\\n                    if tp_tar in dc:\\n                        return sorted([dc[tp], dc[tp_tar]])\\n            return []\\n            \\n        keys = list(dc.keys())\\n        keys.sort(key = lambda x: sum(x))\\n        \\n        for tp in keys:\\n            res = find(tp)\\n            if res:\\n                return res\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622326,
                "title": "the-result-won-t-have-more-than-2-rows",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        \\n        for (int r = 0; r < m; ++r) {\\n            int x = 0;\\n            for (int c = 0; c < n; ++c) {\\n                if (grid[r][c] != 0) {\\n                    x |= (1 << c);\\n                }\\n            }\\n            \\n            if (x == 0) {\\n                res.add(r);\\n                return res;\\n            }\\n            \\n            for (int i = 0; i < (1 << n); ++i) {\\n                if ((i & x) == 0 && seen.containsKey(i)) {\\n                    res.add(seen.get(i));\\n                    res.add(r);\\n                    return res;\\n                }\\n            }\\n            seen.put(x, r);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        \\n        for (int r = 0; r < m; ++r) {\\n            int x = 0;\\n            for (int c = 0; c < n; ++c) {\\n                if (grid[r][c] != 0) {\\n                    x |= (1 << c);\\n                }\\n            }\\n            \\n            if (x == 0) {\\n                res.add(r);\\n                return res;\\n            }\\n            \\n            for (int i = 0; i < (1 << n); ++i) {\\n                if ((i & x) == 0 && seen.containsKey(i)) {\\n                    res.add(seen.get(i));\\n                    res.add(r);\\n                    return res;\\n                }\\n            }\\n            seen.put(x, r);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622308,
                "title": "atmost-32-distinct-rows-select-rows-with-bitwise-and-equal-to-0",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int bits(vector<int>& arr) {\\n        int num = 0;\\n        \\n        for(int i=0; i<arr.size(); i++) {\\n            num |= arr[i];\\n            num <<= 1;\\n        }\\n        \\n        num >>= 1;\\n        \\n        return num;\\n    }\\n    \\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        unordered_map<int,int> mp;\\n        \\n        for(int i = 0; i<grid.size(); i++) {\\n            if(mp.count(bits(grid[i]))) continue;\\n            mp[bits(grid[i])] = i;\\n        }\\n        \\n        int m = (1<<grid[0].size()) - 1;\\n        \\n        for(int mask1=0; mask1<=m; mask1++) {\\n            if(not mp.count(mask1)) continue;\\n            \\n            for(int mask2=0; mask2<=m; mask2++) {\\n                if(not mp.count(mask2)) continue;\\n                \\n                if((mask1 & mask2) == 0) {\\n                    if(mask1 == mask2) return {mp[mask1]};\\n                    return {min(mp[mask1], mp[mask2]),max(mp[mask1], mp[mask2])};\\n                }\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int bits(vector<int>& arr) {\\n        int num = 0;\\n        \\n        for(int i=0; i<arr.size(); i++) {\\n            num |= arr[i];\\n            num <<= 1;\\n        }\\n        \\n        num >>= 1;\\n        \\n        return num;\\n    }\\n    \\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\\n        unordered_map<int,int> mp;\\n        \\n        for(int i = 0; i<grid.size(); i++) {\\n            if(mp.count(bits(grid[i]))) continue;\\n            mp[bits(grid[i])] = i;\\n        }\\n        \\n        int m = (1<<grid[0].size()) - 1;\\n        \\n        for(int mask1=0; mask1<=m; mask1++) {\\n            if(not mp.count(mask1)) continue;\\n            \\n            for(int mask2=0; mask2<=m; mask2++) {\\n                if(not mp.count(mask2)) continue;\\n                \\n                if((mask1 & mask2) == 0) {\\n                    if(mask1 == mask2) return {mp[mask1]};\\n                    return {min(mp[mask1], mp[mask2]),max(mp[mask1], mp[mask2])};\\n                }\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622306,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getRowSum(const std::vector<int>& row) {\\n        int sum = 0;\\n        for (int element : row) {\\n            sum += element;\\n        }\\n        return sum;\\n    }\\n    \\n    int getColumnSum(const std::vector<int>& row1, const std::vector<int>& row2) {\\n        int sum = 0;\\n        for (int i = 0; i < row1.size(); i++) {\\n            sum += (row1[i] && row2[i])?1:0;\\n        }\\n        return sum;}\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid){ \\n\\n       \\n        for (int i = 0; i < grid.size(); i++) {\\n            if (getRowSum(grid[i]) == 0) {\\n                return {i};\\n            }\\n            else\\n                continue;\\n        }\\n        \\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = i + 1; j < grid.size(); j++) {\\n                if (getColumnSum(grid[i], grid[j]) == 0) {\\n                    return {i, j};\\n                }\\n                else\\n                    continue;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n    \\n    private:\\n    \\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getRowSum(const std::vector<int>& row) {\\n        int sum = 0;\\n        for (int element : row) {\\n            sum += element;\\n        }\\n        return sum;\\n    }\\n    \\n    int getColumnSum(const std::vector<int>& row1, const std::vector<int>& row2) {\\n        int sum = 0;\\n        for (int i = 0; i < row1.size(); i++) {\\n            sum += (row1[i] && row2[i])?1:0;\\n        }\\n        return sum;}\\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid){ \\n\\n       \\n        for (int i = 0; i < grid.size(); i++) {\\n            if (getRowSum(grid[i]) == 0) {\\n                return {i};\\n            }\\n            else\\n                continue;\\n        }\\n        \\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = i + 1; j < grid.size(); j++) {\\n                if (getColumnSum(grid[i], grid[j]) == 0) {\\n                    return {i, j};\\n                }\\n                else\\n                    continue;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n    \\n    private:\\n    \\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622300,
                "title": "python-easy-to-understand-explained-two-sum-solution",
                "content": "# Approach\\nThis problem is very similar to TWO SUM. We are searching for a row full of 0 or two rows where the sum of the cols is at most 1. We don\\'t need to search for any other combinations.\\n\\nThe other point is to figure out that we can have at most 2^5 combinations as we can have at most 5 binary columns.\\n\\nFirst, I generate for each value from 0 so 2^n (n being the number of columns) all the good combinations it could have. \\n\\nThen I go through each row, converting that row to an integer and putting all the good combinations for that number in positions, the same as the solution to TWO SUM; if we find a row already in position, we find the solution.\\n\\n# Code\\n```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        goodComb = dict()\\n        \\n        maxComb = 2**n\\n        \\n        for i in range(maxComb):\\n            goodComb[i] = set()\\n            for j in range(maxComb):\\n                if i & j == 0:\\n                    goodComb[i].add(j)\\n\\n        positions = dict()\\n        \\n        for i,row in enumerate(grid):\\n            intRow = int(\\'\\'.join([ str(val) for val in row ]), 2)\\n            \\n            if intRow in positions:\\n                return [positions[intRow], i]\\n            \\n            for good in goodComb[intRow]:\\n                positions[good] = i\\n            \\n            if intRow in positions:\\n                return [i]\\n            \\n        return []\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        goodComb = dict()\\n        \\n        maxComb = 2**n\\n        \\n        for i in range(maxComb):\\n            goodComb[i] = set()\\n            for j in range(maxComb):\\n                if i & j == 0:\\n                    goodComb[i].add(j)\\n\\n        positions = dict()\\n        \\n        for i,row in enumerate(grid):\\n            intRow = int(\\'\\'.join([ str(val) for val in row ]), 2)\\n            \\n            if intRow in positions:\\n                return [positions[intRow], i]\\n            \\n            for good in goodComb[intRow]:\\n                positions[good] = i\\n            \\n            if intRow in positions:\\n                return [i]\\n            \\n        return []\\n                \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1923696,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "The KEY point is that, if there exists a good subset with row number > 2, you can always find 2 rows being a good subset.\\n\\nThen it is an easy bit operation question."
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem becomes much harder if $n = 6$."
                    },
                    {
                        "username": "brinuke",
                        "content": "[@dmitrii_bokovikov](/dmitrii_bokovikov) No. Consider the following `4 x 6` matrix:\n`grid = [[1,1,1,0,0,0],[1,0,0,1,1,0],[0,1,0,1,0,1],[0,0,1,0,1,1]].`\nYou cannot choose 1 or 2 rows in it to satisfy the condition. You cannot even choose 3. The minimum is the whole set of 4 rows. But for the general case of `m x 6` matrix, it requires $O(m ^ 4)$ operations to search through the all fours in it, which is too high given $1 \\le m \\le 10^4$."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "Why? you can apply the same logic to find two bit masks which don\\'t overlap"
                    },
                    {
                        "username": "Bijay293",
                        "content": "agreed "
                    },
                    {
                        "username": "ayushabg",
                        "content": "Better call it subsequence of rows, subset of rows (like subarray) feels like a continous set of rows"
                    },
                    {
                        "username": "hero080",
                        "content": "Simple Greedy:\\nhttps://leetcode.com/problems/find-a-good-subset-of-the-matrix/solutions/3622824/easy-o-n-simple-greedy-with-math-proof/"
                    },
                    {
                        "username": "karanaggarwal05",
                        "content": "Thanks for sharing this."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "how is this working time complex - (1e4*1e4) ?????"
                    },
                    {
                        "username": "itsharshbhargava",
                        "content": "Tell me one thing\\nLet\\'s take a testcase [[0,0,0,0],[0,0,0,0],[0,0,0,0]]\\nIt\\'s answer should be [0,1,2].\\nthen why it is just [0] ??"
                    },
                    {
                        "username": "HiMAnSU_18",
                        "content": "just [0] is one of the answer you can return any subset its upto you :)"
                    },
                    {
                        "username": "AjayVarshney2117",
                        "content": "Can somebody explain me this question?"
                    },
                    {
                        "username": "locke_lost",
                        "content": "So, by 'the length of the chosen subset of rows', actually it meant the 'count of rows'. Not the length of successive or subset of columns. right?\n\nAnd don't it clearly say we need to return maximum 2 rows, or the minimum number of rows? If not, in the following case, we can take all 6 rows, isn't it?\n[[0],[0],[0],[0],[0],[0]]\n\nI think some of the contest attenders missed the chance to solve this because of unclear description."
                    }
                ]
            },
            {
                "id": 1924385,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "The KEY point is that, if there exists a good subset with row number > 2, you can always find 2 rows being a good subset.\\n\\nThen it is an easy bit operation question."
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem becomes much harder if $n = 6$."
                    },
                    {
                        "username": "brinuke",
                        "content": "[@dmitrii_bokovikov](/dmitrii_bokovikov) No. Consider the following `4 x 6` matrix:\n`grid = [[1,1,1,0,0,0],[1,0,0,1,1,0],[0,1,0,1,0,1],[0,0,1,0,1,1]].`\nYou cannot choose 1 or 2 rows in it to satisfy the condition. You cannot even choose 3. The minimum is the whole set of 4 rows. But for the general case of `m x 6` matrix, it requires $O(m ^ 4)$ operations to search through the all fours in it, which is too high given $1 \\le m \\le 10^4$."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "Why? you can apply the same logic to find two bit masks which don\\'t overlap"
                    },
                    {
                        "username": "Bijay293",
                        "content": "agreed "
                    },
                    {
                        "username": "ayushabg",
                        "content": "Better call it subsequence of rows, subset of rows (like subarray) feels like a continous set of rows"
                    },
                    {
                        "username": "hero080",
                        "content": "Simple Greedy:\\nhttps://leetcode.com/problems/find-a-good-subset-of-the-matrix/solutions/3622824/easy-o-n-simple-greedy-with-math-proof/"
                    },
                    {
                        "username": "karanaggarwal05",
                        "content": "Thanks for sharing this."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "how is this working time complex - (1e4*1e4) ?????"
                    },
                    {
                        "username": "itsharshbhargava",
                        "content": "Tell me one thing\\nLet\\'s take a testcase [[0,0,0,0],[0,0,0,0],[0,0,0,0]]\\nIt\\'s answer should be [0,1,2].\\nthen why it is just [0] ??"
                    },
                    {
                        "username": "HiMAnSU_18",
                        "content": "just [0] is one of the answer you can return any subset its upto you :)"
                    },
                    {
                        "username": "AjayVarshney2117",
                        "content": "Can somebody explain me this question?"
                    },
                    {
                        "username": "locke_lost",
                        "content": "So, by 'the length of the chosen subset of rows', actually it meant the 'count of rows'. Not the length of successive or subset of columns. right?\n\nAnd don't it clearly say we need to return maximum 2 rows, or the minimum number of rows? If not, in the following case, we can take all 6 rows, isn't it?\n[[0],[0],[0],[0],[0],[0]]\n\nI think some of the contest attenders missed the chance to solve this because of unclear description."
                    }
                ]
            },
            {
                "id": 1929033,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "The KEY point is that, if there exists a good subset with row number > 2, you can always find 2 rows being a good subset.\\n\\nThen it is an easy bit operation question."
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem becomes much harder if $n = 6$."
                    },
                    {
                        "username": "brinuke",
                        "content": "[@dmitrii_bokovikov](/dmitrii_bokovikov) No. Consider the following `4 x 6` matrix:\n`grid = [[1,1,1,0,0,0],[1,0,0,1,1,0],[0,1,0,1,0,1],[0,0,1,0,1,1]].`\nYou cannot choose 1 or 2 rows in it to satisfy the condition. You cannot even choose 3. The minimum is the whole set of 4 rows. But for the general case of `m x 6` matrix, it requires $O(m ^ 4)$ operations to search through the all fours in it, which is too high given $1 \\le m \\le 10^4$."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "Why? you can apply the same logic to find two bit masks which don\\'t overlap"
                    },
                    {
                        "username": "Bijay293",
                        "content": "agreed "
                    },
                    {
                        "username": "ayushabg",
                        "content": "Better call it subsequence of rows, subset of rows (like subarray) feels like a continous set of rows"
                    },
                    {
                        "username": "hero080",
                        "content": "Simple Greedy:\\nhttps://leetcode.com/problems/find-a-good-subset-of-the-matrix/solutions/3622824/easy-o-n-simple-greedy-with-math-proof/"
                    },
                    {
                        "username": "karanaggarwal05",
                        "content": "Thanks for sharing this."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "how is this working time complex - (1e4*1e4) ?????"
                    },
                    {
                        "username": "itsharshbhargava",
                        "content": "Tell me one thing\\nLet\\'s take a testcase [[0,0,0,0],[0,0,0,0],[0,0,0,0]]\\nIt\\'s answer should be [0,1,2].\\nthen why it is just [0] ??"
                    },
                    {
                        "username": "HiMAnSU_18",
                        "content": "just [0] is one of the answer you can return any subset its upto you :)"
                    },
                    {
                        "username": "AjayVarshney2117",
                        "content": "Can somebody explain me this question?"
                    },
                    {
                        "username": "locke_lost",
                        "content": "So, by 'the length of the chosen subset of rows', actually it meant the 'count of rows'. Not the length of successive or subset of columns. right?\n\nAnd don't it clearly say we need to return maximum 2 rows, or the minimum number of rows? If not, in the following case, we can take all 6 rows, isn't it?\n[[0],[0],[0],[0],[0],[0]]\n\nI think some of the contest attenders missed the chance to solve this because of unclear description."
                    }
                ]
            },
            {
                "id": 1924048,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "The KEY point is that, if there exists a good subset with row number > 2, you can always find 2 rows being a good subset.\\n\\nThen it is an easy bit operation question."
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem becomes much harder if $n = 6$."
                    },
                    {
                        "username": "brinuke",
                        "content": "[@dmitrii_bokovikov](/dmitrii_bokovikov) No. Consider the following `4 x 6` matrix:\n`grid = [[1,1,1,0,0,0],[1,0,0,1,1,0],[0,1,0,1,0,1],[0,0,1,0,1,1]].`\nYou cannot choose 1 or 2 rows in it to satisfy the condition. You cannot even choose 3. The minimum is the whole set of 4 rows. But for the general case of `m x 6` matrix, it requires $O(m ^ 4)$ operations to search through the all fours in it, which is too high given $1 \\le m \\le 10^4$."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "Why? you can apply the same logic to find two bit masks which don\\'t overlap"
                    },
                    {
                        "username": "Bijay293",
                        "content": "agreed "
                    },
                    {
                        "username": "ayushabg",
                        "content": "Better call it subsequence of rows, subset of rows (like subarray) feels like a continous set of rows"
                    },
                    {
                        "username": "hero080",
                        "content": "Simple Greedy:\\nhttps://leetcode.com/problems/find-a-good-subset-of-the-matrix/solutions/3622824/easy-o-n-simple-greedy-with-math-proof/"
                    },
                    {
                        "username": "karanaggarwal05",
                        "content": "Thanks for sharing this."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "how is this working time complex - (1e4*1e4) ?????"
                    },
                    {
                        "username": "itsharshbhargava",
                        "content": "Tell me one thing\\nLet\\'s take a testcase [[0,0,0,0],[0,0,0,0],[0,0,0,0]]\\nIt\\'s answer should be [0,1,2].\\nthen why it is just [0] ??"
                    },
                    {
                        "username": "HiMAnSU_18",
                        "content": "just [0] is one of the answer you can return any subset its upto you :)"
                    },
                    {
                        "username": "AjayVarshney2117",
                        "content": "Can somebody explain me this question?"
                    },
                    {
                        "username": "locke_lost",
                        "content": "So, by 'the length of the chosen subset of rows', actually it meant the 'count of rows'. Not the length of successive or subset of columns. right?\n\nAnd don't it clearly say we need to return maximum 2 rows, or the minimum number of rows? If not, in the following case, we can take all 6 rows, isn't it?\n[[0],[0],[0],[0],[0],[0]]\n\nI think some of the contest attenders missed the chance to solve this because of unclear description."
                    }
                ]
            },
            {
                "id": 1926978,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "The KEY point is that, if there exists a good subset with row number > 2, you can always find 2 rows being a good subset.\\n\\nThen it is an easy bit operation question."
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem becomes much harder if $n = 6$."
                    },
                    {
                        "username": "brinuke",
                        "content": "[@dmitrii_bokovikov](/dmitrii_bokovikov) No. Consider the following `4 x 6` matrix:\n`grid = [[1,1,1,0,0,0],[1,0,0,1,1,0],[0,1,0,1,0,1],[0,0,1,0,1,1]].`\nYou cannot choose 1 or 2 rows in it to satisfy the condition. You cannot even choose 3. The minimum is the whole set of 4 rows. But for the general case of `m x 6` matrix, it requires $O(m ^ 4)$ operations to search through the all fours in it, which is too high given $1 \\le m \\le 10^4$."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "Why? you can apply the same logic to find two bit masks which don\\'t overlap"
                    },
                    {
                        "username": "Bijay293",
                        "content": "agreed "
                    },
                    {
                        "username": "ayushabg",
                        "content": "Better call it subsequence of rows, subset of rows (like subarray) feels like a continous set of rows"
                    },
                    {
                        "username": "hero080",
                        "content": "Simple Greedy:\\nhttps://leetcode.com/problems/find-a-good-subset-of-the-matrix/solutions/3622824/easy-o-n-simple-greedy-with-math-proof/"
                    },
                    {
                        "username": "karanaggarwal05",
                        "content": "Thanks for sharing this."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "how is this working time complex - (1e4*1e4) ?????"
                    },
                    {
                        "username": "itsharshbhargava",
                        "content": "Tell me one thing\\nLet\\'s take a testcase [[0,0,0,0],[0,0,0,0],[0,0,0,0]]\\nIt\\'s answer should be [0,1,2].\\nthen why it is just [0] ??"
                    },
                    {
                        "username": "HiMAnSU_18",
                        "content": "just [0] is one of the answer you can return any subset its upto you :)"
                    },
                    {
                        "username": "AjayVarshney2117",
                        "content": "Can somebody explain me this question?"
                    },
                    {
                        "username": "locke_lost",
                        "content": "So, by 'the length of the chosen subset of rows', actually it meant the 'count of rows'. Not the length of successive or subset of columns. right?\n\nAnd don't it clearly say we need to return maximum 2 rows, or the minimum number of rows? If not, in the following case, we can take all 6 rows, isn't it?\n[[0],[0],[0],[0],[0],[0]]\n\nI think some of the contest attenders missed the chance to solve this because of unclear description."
                    }
                ]
            },
            {
                "id": 1925881,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "The KEY point is that, if there exists a good subset with row number > 2, you can always find 2 rows being a good subset.\\n\\nThen it is an easy bit operation question."
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem becomes much harder if $n = 6$."
                    },
                    {
                        "username": "brinuke",
                        "content": "[@dmitrii_bokovikov](/dmitrii_bokovikov) No. Consider the following `4 x 6` matrix:\n`grid = [[1,1,1,0,0,0],[1,0,0,1,1,0],[0,1,0,1,0,1],[0,0,1,0,1,1]].`\nYou cannot choose 1 or 2 rows in it to satisfy the condition. You cannot even choose 3. The minimum is the whole set of 4 rows. But for the general case of `m x 6` matrix, it requires $O(m ^ 4)$ operations to search through the all fours in it, which is too high given $1 \\le m \\le 10^4$."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "Why? you can apply the same logic to find two bit masks which don\\'t overlap"
                    },
                    {
                        "username": "Bijay293",
                        "content": "agreed "
                    },
                    {
                        "username": "ayushabg",
                        "content": "Better call it subsequence of rows, subset of rows (like subarray) feels like a continous set of rows"
                    },
                    {
                        "username": "hero080",
                        "content": "Simple Greedy:\\nhttps://leetcode.com/problems/find-a-good-subset-of-the-matrix/solutions/3622824/easy-o-n-simple-greedy-with-math-proof/"
                    },
                    {
                        "username": "karanaggarwal05",
                        "content": "Thanks for sharing this."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "how is this working time complex - (1e4*1e4) ?????"
                    },
                    {
                        "username": "itsharshbhargava",
                        "content": "Tell me one thing\\nLet\\'s take a testcase [[0,0,0,0],[0,0,0,0],[0,0,0,0]]\\nIt\\'s answer should be [0,1,2].\\nthen why it is just [0] ??"
                    },
                    {
                        "username": "HiMAnSU_18",
                        "content": "just [0] is one of the answer you can return any subset its upto you :)"
                    },
                    {
                        "username": "AjayVarshney2117",
                        "content": "Can somebody explain me this question?"
                    },
                    {
                        "username": "locke_lost",
                        "content": "So, by 'the length of the chosen subset of rows', actually it meant the 'count of rows'. Not the length of successive or subset of columns. right?\n\nAnd don't it clearly say we need to return maximum 2 rows, or the minimum number of rows? If not, in the following case, we can take all 6 rows, isn't it?\n[[0],[0],[0],[0],[0],[0]]\n\nI think some of the contest attenders missed the chance to solve this because of unclear description."
                    }
                ]
            },
            {
                "id": 1925429,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "The KEY point is that, if there exists a good subset with row number > 2, you can always find 2 rows being a good subset.\\n\\nThen it is an easy bit operation question."
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem becomes much harder if $n = 6$."
                    },
                    {
                        "username": "brinuke",
                        "content": "[@dmitrii_bokovikov](/dmitrii_bokovikov) No. Consider the following `4 x 6` matrix:\n`grid = [[1,1,1,0,0,0],[1,0,0,1,1,0],[0,1,0,1,0,1],[0,0,1,0,1,1]].`\nYou cannot choose 1 or 2 rows in it to satisfy the condition. You cannot even choose 3. The minimum is the whole set of 4 rows. But for the general case of `m x 6` matrix, it requires $O(m ^ 4)$ operations to search through the all fours in it, which is too high given $1 \\le m \\le 10^4$."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "Why? you can apply the same logic to find two bit masks which don\\'t overlap"
                    },
                    {
                        "username": "Bijay293",
                        "content": "agreed "
                    },
                    {
                        "username": "ayushabg",
                        "content": "Better call it subsequence of rows, subset of rows (like subarray) feels like a continous set of rows"
                    },
                    {
                        "username": "hero080",
                        "content": "Simple Greedy:\\nhttps://leetcode.com/problems/find-a-good-subset-of-the-matrix/solutions/3622824/easy-o-n-simple-greedy-with-math-proof/"
                    },
                    {
                        "username": "karanaggarwal05",
                        "content": "Thanks for sharing this."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "how is this working time complex - (1e4*1e4) ?????"
                    },
                    {
                        "username": "itsharshbhargava",
                        "content": "Tell me one thing\\nLet\\'s take a testcase [[0,0,0,0],[0,0,0,0],[0,0,0,0]]\\nIt\\'s answer should be [0,1,2].\\nthen why it is just [0] ??"
                    },
                    {
                        "username": "HiMAnSU_18",
                        "content": "just [0] is one of the answer you can return any subset its upto you :)"
                    },
                    {
                        "username": "AjayVarshney2117",
                        "content": "Can somebody explain me this question?"
                    },
                    {
                        "username": "locke_lost",
                        "content": "So, by 'the length of the chosen subset of rows', actually it meant the 'count of rows'. Not the length of successive or subset of columns. right?\n\nAnd don't it clearly say we need to return maximum 2 rows, or the minimum number of rows? If not, in the following case, we can take all 6 rows, isn't it?\n[[0],[0],[0],[0],[0],[0]]\n\nI think some of the contest attenders missed the chance to solve this because of unclear description."
                    }
                ]
            },
            {
                "id": 1924336,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "The KEY point is that, if there exists a good subset with row number > 2, you can always find 2 rows being a good subset.\\n\\nThen it is an easy bit operation question."
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem becomes much harder if $n = 6$."
                    },
                    {
                        "username": "brinuke",
                        "content": "[@dmitrii_bokovikov](/dmitrii_bokovikov) No. Consider the following `4 x 6` matrix:\n`grid = [[1,1,1,0,0,0],[1,0,0,1,1,0],[0,1,0,1,0,1],[0,0,1,0,1,1]].`\nYou cannot choose 1 or 2 rows in it to satisfy the condition. You cannot even choose 3. The minimum is the whole set of 4 rows. But for the general case of `m x 6` matrix, it requires $O(m ^ 4)$ operations to search through the all fours in it, which is too high given $1 \\le m \\le 10^4$."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "Why? you can apply the same logic to find two bit masks which don\\'t overlap"
                    },
                    {
                        "username": "Bijay293",
                        "content": "agreed "
                    },
                    {
                        "username": "ayushabg",
                        "content": "Better call it subsequence of rows, subset of rows (like subarray) feels like a continous set of rows"
                    },
                    {
                        "username": "hero080",
                        "content": "Simple Greedy:\\nhttps://leetcode.com/problems/find-a-good-subset-of-the-matrix/solutions/3622824/easy-o-n-simple-greedy-with-math-proof/"
                    },
                    {
                        "username": "karanaggarwal05",
                        "content": "Thanks for sharing this."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "how is this working time complex - (1e4*1e4) ?????"
                    },
                    {
                        "username": "itsharshbhargava",
                        "content": "Tell me one thing\\nLet\\'s take a testcase [[0,0,0,0],[0,0,0,0],[0,0,0,0]]\\nIt\\'s answer should be [0,1,2].\\nthen why it is just [0] ??"
                    },
                    {
                        "username": "HiMAnSU_18",
                        "content": "just [0] is one of the answer you can return any subset its upto you :)"
                    },
                    {
                        "username": "AjayVarshney2117",
                        "content": "Can somebody explain me this question?"
                    },
                    {
                        "username": "locke_lost",
                        "content": "So, by 'the length of the chosen subset of rows', actually it meant the 'count of rows'. Not the length of successive or subset of columns. right?\n\nAnd don't it clearly say we need to return maximum 2 rows, or the minimum number of rows? If not, in the following case, we can take all 6 rows, isn't it?\n[[0],[0],[0],[0],[0],[0]]\n\nI think some of the contest attenders missed the chance to solve this because of unclear description."
                    }
                ]
            }
        ]
    },
    {
        "title": "Painting the Walls",
        "question_content": "<p>You are given two <strong>0-indexed</strong> integer arrays,&nbsp;<code>cost</code> and <code>time</code>, of size <code>n</code> representing the costs and the time taken to paint <code>n</code> different walls respectively. There are two painters available:</p>\n\n<ul>\n\t<li>A<strong>&nbsp;paid painter</strong>&nbsp;that paints the <code>i<sup>th</sup></code> wall in <code>time[i]</code> units of time and takes <code>cost[i]</code> units of money.</li>\n\t<li>A<strong>&nbsp;free painter</strong> that paints&nbsp;<strong>any</strong> wall in <code>1</code> unit of time at a cost of <code>0</code>. But the&nbsp;free painter can only be used if the paid painter is already <strong>occupied</strong>.</li>\n</ul>\n\n<p>Return <em>the minimum amount of money required to paint the </em><code>n</code><em>&nbsp;walls.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> cost = [1,2,3,2], time = [1,2,3,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The walls at index 0 and 1 will be painted by the paid painter, and it will take 3 units of time; meanwhile, the free painter will paint the walls at index 2 and 3, free of cost in 2 units of time. Thus, the total cost is 1 + 2 = 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> cost = [2,3,4,2], time = [1,1,1,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The walls at index 0 and 3 will be painted by the paid painter, and it will take 2 units of time; meanwhile, the free painter will paint the walls at index 1 and 2, free of cost in 2 units of time. Thus, the total cost is 2 + 2 = 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cost.length &lt;= 500</code></li>\n\t<li><code>cost.length == time.length</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= time[i] &lt;= 500</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3650707,
                "title": "java-c-python-7-lines-knapsack-dp",
                "content": "# **Intuition**\\nThere is a sense to use small `cost` to buy more `time`\\n\\nSo we can find that this is a Knapsack problem,\\ninstead of value of items,\\nwe calculate the minimum cost to buy enough time to finish `n` walls,\\n(time is also valuable)\\n<br>\\n\\n\\n# **Explanation**\\nWith cost `cost[i]`,\\nwe buy `time[i]`,\\nand we can additionally finish `time[i]` walls,\\nso actually can finish `time[i] + 1` walls.\\n\\nSo `cost[i]` to finish `time[i] + 1` walls,\\nwe need the minimum total `cost` to finish `n` walls.\\n\\n\\n`dp[t] = c` means the minimum cost to finish `t` walls is `c`.\\n\\nInitially `dp[0] = 0` and `dp[i > 0] = inf`\\n\\nIterate each `cost[i], time[i]`,\\nupdate `dp[j]` with this dp equation\\n`dp[j] = min(dp[j], dp[max(j - time[i] - 1, 0)] + cost[i])`\\n\\n\\nFinally return result `dp[n]`\\n<br>\\n\\n# **Complexity**\\nTime `O(n^2)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length, dp[] = new int[n + 1];\\n        Arrays.fill(dp, (int)1e9);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (int j = n; j > 0; --j)\\n                dp[j] = Math.min(dp[j], dp[Math.max(j - time[i] - 1, 0)] + cost[i]);\\n        return dp[n];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<int> dp(n + 1, 1e9);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (int j = n; j > 0; --j)\\n                dp[j] = min(dp[j], dp[max(j - time[i] - 1, 0)] + cost[i]);\\n        return dp[n];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        dp = [0] + [inf] * n\\n        for c, t in zip(cost, time):\\n            for j in range(n, 0, -1):\\n                dp[j] = min(dp[j], dp[max(j - t - 1, 0)] + c)\\n        return dp[n]\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```java\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length, dp[] = new int[n + 1];\\n        Arrays.fill(dp, (int)1e9);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (int j = n; j > 0; --j)\\n                dp[j] = Math.min(dp[j], dp[Math.max(j - time[i] - 1, 0)] + cost[i]);\\n        return dp[n];\\n    }\\n```\n```cpp\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<int> dp(n + 1, 1e9);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (int j = n; j > 0; --j)\\n                dp[j] = min(dp[j], dp[max(j - time[i] - 1, 0)] + cost[i]);\\n        return dp[n];\\n    }\\n```\n```py\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        dp = [0] + [inf] * n\\n        for c, t in zip(cost, time):\\n            for j in range(n, 0, -1):\\n                dp[j] = min(dp[j], dp[max(j - t - 1, 0)] + c)\\n        return dp[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3650635,
                "title": "explained-0-1-knapsack-dp-very-simple-and-easy-to-understand-solution",
                "content": "#### Up vote if you like the solution\\n# Intuition\\n##### Typical take not to take DP problem\\nHere we can simply think of the problem as, when we paint a wall by the painter1 then we can skip time[i] walls (basically this time[i] no. of walls will be painted by the painter2 with zero cost).\\n\\nSo we can re-think the problem as select n walls from the given one so that the sum of the times to pain the wall(painded by painter 2) + the number of wall taken (painted by painter 1) > total no. of walls to paint.\\n\\nThis is similar to the 0/1 Knapsack where the cost is same as weight and our bag size is wall count. But in Knapsack we reduce the bag size by the stone size here we reduce the wall count by the time[i] and additional -1 to reduced currently painted wall.\\n\\n# Approach\\nThis can be solved by considering each wall and we have two option to take or not to take. If we take then wallRemaining will become  = wallRemining - time[i] - 1;\\n\\nTake the min of take & not taken case as the answer.\\n\\nIf you still do not understand above explaination, then first revise 0/1 Knapsack & DP here ( Great explaination of this by Aditya verma DP series ) :\\nhttps://www.youtube.com/watch?v=kvyShbFVaY8&list=RDCMUC5WO7o71wvxMxEtLRkPhiQQ&start_radio=1&rv=kvyShbFVaY8&t=13\\n\\n# Code\\n```\\nint dp[501][501] = {};\\n\\nint solve(vector<int>& cost, vector<int>& time, int i, int wallReamining){\\n    if(wallReamining <= 0) return 0;\\n    if(i >= cost.size()) return 1000000000;\\n    if(dp[i][wallReamining] != 0) return dp[i][wallReamining];\\n    int notTake = solve(cost, time, i+1, wallReamining);\\n    int take = cost[i] + solve(cost, time, i+1, wallReamining -  time[i] -1); \\n    return dp[i][wallReamining] = min(notTake, take);      \\n}\\n\\nint paintWalls(vector<int>& cost, vector<int>& time) {\\n    return solve(cost, time, 0, time.size());\\n}\\n```\\n\\n<b> Here is an article of my recent interview experience at Amazon, you may like :\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dp[501][501] = {};\\n\\nint solve(vector<int>& cost, vector<int>& time, int i, int wallReamining){\\n    if(wallReamining <= 0) return 0;\\n    if(i >= cost.size()) return 1000000000;\\n    if(dp[i][wallReamining] != 0) return dp[i][wallReamining];\\n    int notTake = solve(cost, time, i+1, wallReamining);\\n    int take = cost[i] + solve(cost, time, i+1, wallReamining -  time[i] -1); \\n    return dp[i][wallReamining] = min(notTake, take);      \\n}\\n\\nint paintWalls(vector<int>& cost, vector<int>& time) {\\n    return solve(cost, time, 0, time.size());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650923,
                "title": "most-simplified-explanation-0-1-knapsack",
                "content": "# APPROACH\\nBasically let us at first reframe the problem. Here we are given 2 painters. Painter 1 takes cost[i] amount and time[i] time to paint i th wall. When the painter 1 is busy painting a wall, Painter 2 can paint other walls in 0 cost and 1 unit time. So what do you understand ? Whether Painter 2 will be able to paint a wall depends on Painter 1. Thus let us eliminate the story of painter 2 for the time being. Focus on Painter 1. So the problem boils down to the conclusion of take and nottake case of painter 1, When painter 1 will be busy, we will simply nottake any wall. Why? Because when painter 1 will be busy we will change the number of wall remaining to : walls - time[i] - 1(-1 for current wall and time[i] are the walls painted by free painter or painter 2). Thus this compensates for the painter 2. Therefore the problem boils down to the classical 0/1 knapsack. You can refer to some videos on youtube to get clarification of 0/1 knapsack. If you find the explanation helpful, kindly **DO UPVOTE**. In case you need Tabulation code refer https://leetcode.com/problems/painting-the-walls/solutions/3650923/most-simplified-explanation-0-1-knapsack/comments/1935477 \\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int memo(vector<int>&cost, vector<int> &time, int index, int walls, vector<vector<int>> &dp) {\\n        if(walls <= 0) return 0;//can be one of the possible way\\n        if(index < 0 ) return 1e9;//Neglect this by returning unusually large value\\n        if(dp[index][walls] != -1) return dp[index][walls];\\n\\n        int notTake = 0 + memo(cost, time, index - 1, walls, dp);\\n        int take = cost[index] + memo(cost, time, index - 1, walls- time[index] - 1, dp);\\n        return dp[index][walls] = min(notTake, take);\\n    }\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        return memo(cost, time, n-1, n, dp);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int memo(vector<int>&cost, vector<int> &time, int index, int walls, vector<vector<int>> &dp) {\\n        if(walls <= 0) return 0;//can be one of the possible way\\n        if(index < 0 ) return 1e9;//Neglect this by returning unusually large value\\n        if(dp[index][walls] != -1) return dp[index][walls];\\n\\n        int notTake = 0 + memo(cost, time, index - 1, walls, dp);\\n        int take = cost[index] + memo(cost, time, index - 1, walls- time[index] - 1, dp);\\n        return dp[index][walls] = min(notTake, take);\\n    }\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        return memo(cost, time, n-1, n, dp);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650446,
                "title": "c-java-python3-top-down-dp",
                "content": "\\n\\n# Intuition\\nGiven the constraints we can try a dp approach. Each state of the dp will be defined by current index and time to paint walls\\n\\n# Approach\\nEach dp state will cache the total time to complete existing walls where we used a paid painter and the index.\\nIn java and c++ solutions we add an extra `n` to `t` when caching `t` because `t` can also be negative\\n\\n* We track total time it\\'ll take for the existing walls where a paid painter is working\\n* When this time is positive it means we can have an unpaid painter, paint any wall free of cost in 1 unit of time\\n* If at the end of the recursion total time to complete walls is negative it means we used too many unpaid painters\\n* `dp(i + 1, t - 1)` is the case where we used a free painter for `i`th wall\\n*  `dp(i + 1, min(t + time[i], len(cost)))` is the case where we used a paid painter. We can limit this to `len(cost)` because if it is greater than `len(cost)`, time can not be negative now even if we use an unpaid painter for the rest of the walls. Remember, time can only be negative if we use too many unpaid painters. The minimum value of time can be `-len(cost)`, the case where we use all unpaid painters. \\n\\n# Complexity\\n- Time complexity: `O(n * n)`\\n\\n- Space complexity: `O(n * n)`\\n\\n# Code\\n**Python3**:\\n```\\ndef paintWalls(self, cost, time):        \\n    @cache\\n    def dp(i, t):\\n        if i == len(cost): return 0 if t >= 0 else inf\\n        return min(dp(i + 1, t - 1), cost[i] + dp(i + 1, min(t + time[i], len(cost))))\\n    return dp(0, 0)\\n```\\n\\n**C++**:\\n```\\nint paintWalls(vector<int>& cost, vector<int>& time) {\\n    int n = cost.size();\\n    vector<vector<int>> cache(n, vector<int>(2 * n + 1, -1));\\n    function<int(int, int)> dp = [&](int i, int t) -> int {\\n        if (i == n) return (t >= 0) ? 0 : 1e9;\\n        if (cache[i][t + n] != -1) return cache[i][t + n];\\n        return cache[i][t + n] = min(dp(i + 1, t - 1), \\n                            cost[i] + dp(i + 1, min(t + time[i], n)));\\n    };\\n    return dp(0, 0);\\n}\\n```\\n\\n**Java**:\\n```\\nint cache[][], n; \\npublic int paintWalls(int[] cost, int[] time) {\\n    n = cost.length;\\n    cache = new int[n][2 * n + 1];\\n    for (int[] row : cache) Arrays.fill(row, -1);\\n    return dp(cost, time, 0, 0);\\n}\\nprivate int dp(int[] cost, int[] time, int i, int t) {\\n    if (i == n) return (t >= 0) ? 0 : (int) 1e9;\\n    if (cache[i][t + n] != -1) return cache[i][t + n];\\n    return cache[i][t + n] = Math.min(dp(cost, time, i + 1, t - 1),\\n                    cost[i] + dp(cost, time, i + 1, Math.min(t + time[i], n)));\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef paintWalls(self, cost, time):        \\n    @cache\\n    def dp(i, t):\\n        if i == len(cost): return 0 if t >= 0 else inf\\n        return min(dp(i + 1, t - 1), cost[i] + dp(i + 1, min(t + time[i], len(cost))))\\n    return dp(0, 0)\\n```\n```\\nint paintWalls(vector<int>& cost, vector<int>& time) {\\n    int n = cost.size();\\n    vector<vector<int>> cache(n, vector<int>(2 * n + 1, -1));\\n    function<int(int, int)> dp = [&](int i, int t) -> int {\\n        if (i == n) return (t >= 0) ? 0 : 1e9;\\n        if (cache[i][t + n] != -1) return cache[i][t + n];\\n        return cache[i][t + n] = min(dp(i + 1, t - 1), \\n                            cost[i] + dp(i + 1, min(t + time[i], n)));\\n    };\\n    return dp(0, 0);\\n}\\n```\n```\\nint cache[][], n; \\npublic int paintWalls(int[] cost, int[] time) {\\n    n = cost.length;\\n    cache = new int[n][2 * n + 1];\\n    for (int[] row : cache) Arrays.fill(row, -1);\\n    return dp(cost, time, 0, 0);\\n}\\nprivate int dp(int[] cost, int[] time, int i, int t) {\\n    if (i == n) return (t >= 0) ? 0 : (int) 1e9;\\n    if (cache[i][t + n] != -1) return cache[i][t + n];\\n    return cache[i][t + n] = Math.min(dp(cost, time, i + 1, t - 1),\\n                    cost[i] + dp(cost, time, i + 1, Math.min(t + time[i], n)));\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3650515,
                "title": "c-java-python-01-knapsack-problem-solve-in-dp",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\n# Intuition\\n1. Translate this problem to math language:\\n    Find $$m$$ elements such that $$\\\\sum_i t_i \\\\geq n - m $$, minimize $$\\\\sum_i c_i$$.\\n2. Immediately think of shifting m to the left of the inequality sign, the constraint turns to:\\n    $$\\\\sum_i (t_i + 1) \\\\geq n $$\\n3. Therefore, the problem is actually:\\n    **Find $$m$$ elements such that $$\\\\sum_i (t_i + 1) \\\\geq n $$, minimize $$\\\\sum_i c_i$$.**\\n4. This is a typical [knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem), easily solve this problem by dynamic programming.\\n\\n# Approach\\nThe core of dynamic programming has 3 points:\\n- Define states\\n- Write the state transition equation\\n- Clarify boundary conditions\\n\\nLet\\'s solve these 3 points:\\n- For knapsack problem, **a state component is usually defined as \"until $$i$$\".** \\n    And in this problem, notice that we only need the sum of $$t$$ to be $$\\\\geq n$$. **Therefore, the $$\\\\sum_i t_i$$ can be defined as the second state.**\\n    In particular, if the sum is greater than $$n$$, easily update to $$n$$. I also mentioned this skill in [LeetCode 2518](https://leetcode.com/problems/number-of-great-partitions/solutions/2994639/c-java-python-direct-approach-to-solve-a-deformed-01-knapsack-problem/).\\n- In order to facilitate the update, you may wish to use the old state to launch the new state.\\n**When updating to $$i$$-th element, there are two options: \"$$i$$ will be included\" and \"i will not be included\".**\\n    So the transfer equation is:\\n    $$dp[i+1][j+t_i] = \\\\min (dp[i+1][j+t_i], dp[i][j] + c_i)$$, if included.\\n    $$dp[i+1][j] = \\\\min (dp[i+1][j], dp[i][j])$$, if not included.\\n- Obviously, the only boundary condition is:\\n    $$dp[0][0] = 0$$\\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n- Space complexity: $O(n^2)$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = time.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 1000000000));\\n        dp[0][0] = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                int t = min(n, j + time[i] + 1);\\n                dp[i+1][t] = min(dp[i+1][t], dp[i][j] + cost[i]);\\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j]);\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = time.length;\\n        int [][]dp = new int[n+1][n+1];\\n        for (int i = 0; i <= n; ++i) \\n            for (int j = 0; j <= n; ++j) \\n                dp[i][j] = 0x3f3f3f3f;\\n        dp[0][0] = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                int t = Math.min(n, j + time[i] + 1);\\n                dp[i+1][t] = Math.min(dp[i+1][t], dp[i][j] + cost[i]);\\n                dp[i+1][j] = Math.min(dp[i+1][j], dp[i][j]);\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n}\\n```\\n``` Python3 []\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        dp = [[0x3f3f3f3f3f3f for i in range(n+1)] for j in range(n+1)]\\n        dp[0][0] = 0\\n        for i in range(n):\\n            for j in range(n+1):\\n                t = min(n, j + time[i] + 1)\\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j])\\n                dp[i+1][t] = min(dp[i+1][t], dp[i][j] + cost[i])\\n        return dp[n][n]\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = time.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 1000000000));\\n        dp[0][0] = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                int t = min(n, j + time[i] + 1);\\n                dp[i+1][t] = min(dp[i+1][t], dp[i][j] + cost[i]);\\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j]);\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = time.length;\\n        int [][]dp = new int[n+1][n+1];\\n        for (int i = 0; i <= n; ++i) \\n            for (int j = 0; j <= n; ++j) \\n                dp[i][j] = 0x3f3f3f3f;\\n        dp[0][0] = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                int t = Math.min(n, j + time[i] + 1);\\n                dp[i+1][t] = Math.min(dp[i+1][t], dp[i][j] + cost[i]);\\n                dp[i+1][j] = Math.min(dp[i+1][j], dp[i][j]);\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n}\\n```\n``` Python3 []\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        dp = [[0x3f3f3f3f3f3f for i in range(n+1)] for j in range(n+1)]\\n        dp[0][0] = 0\\n        for i in range(n):\\n            for j in range(n+1):\\n                t = min(n, j + time[i] + 1)\\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j])\\n                dp[i+1][t] = min(dp[i+1][t], dp[i][j] + cost[i])\\n        return dp[n][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650465,
                "title": "0-1-knapsack",
                "content": "We need to pick `m` walls, such as `sum(time) + m >= n`, and `sum(cost)` is minimal.\\n\\nFor that, we use 0-1 Knapsack DP.\\n\\n> Note that we globally reserve memory once, to be reused by all tests.\\n> This is just a runtime boost for OJ, not something you would do in production.\\n\\n## Top-Down\\n**C++**\\n```cpp\\nint dp[501][501];\\nclass Solution {\\npublic:\\nint dfs(int i, int walls, vector<int>& cost, vector<int>& time) {\\n    if (walls <= 0)\\n        return 0;\\n    if (i == cost.size())\\n        return 1000000000;\\n    if (dp[i][walls] == -1)\\n        dp[i][walls] = min(dfs(i + 1, walls, cost, time),\\n            cost[i] + dfs(i + 1, walls - time[i] - 1, cost, time));\\n    return dp[i][walls];\\n}\\nint paintWalls(vector<int>& cost, vector<int>& time) {\\n    memset(dp, -1, cost.size() * sizeof(dp[0]));\\n    return dfs(0, time.size(), cost, time);        \\n}\\n```\\n## Bottom-Up\\n`dp[i][j]` denotes the minimum cost to occupy the paid painter for `j` minutes after considering `i` walls.\\n\\n**C++**\\n```cpp\\nint dp[501][501];\\nclass Solution {\\npublic:\\nint paintWalls(vector<int>& cost, vector<int>& time) {  \\n    fill_n(begin(dp[0]), cost.size() + 1, 1e9);\\n    dp[0][0] = 0;\\n    for (int i = 1; i <= cost.size(); ++i)\\n        for (int j = 0; j <= cost.size(); ++j)\\n            dp[i][j] = min(dp[i - 1][j], dp[i - 1][max(0, j - time[i - 1] - 1)] + cost[i - 1]);\\n    return dp[cost.size()][cost.size()];\\n}\\n```\\n\\n## Bottom-Up O(n) Memory\\nWith bottom-up DP, we can optimize tabulation to use only O(n) memory.\\n\\nWe drop the first dimension and we fill `dp[j]` it right-to-left so we do not have to store the previous state.\\n\\n**C++**\\n```cpp\\nint dp[501];\\nclass Solution {\\npublic:\\nint paintWalls(vector<int>& cost, vector<int>& time) {\\n    fill_n(begin(dp), cost.size() + 1, 1e9);\\n    dp[0] = 0;\\n    for (int i = 0; i < cost.size(); ++i)\\n        for (int j = cost.size(); j > 0; --j)\\n            dp[j] = min(dp[j], dp[max(0, j - time[i] - 1)] + cost[i]);\\n    return dp[cost.size()];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[501][501];\\nclass Solution {\\npublic:\\nint dfs(int i, int walls, vector<int>& cost, vector<int>& time) {\\n    if (walls <= 0)\\n        return 0;\\n    if (i == cost.size())\\n        return 1000000000;\\n    if (dp[i][walls] == -1)\\n        dp[i][walls] = min(dfs(i + 1, walls, cost, time),\\n            cost[i] + dfs(i + 1, walls - time[i] - 1, cost, time));\\n    return dp[i][walls];\\n}\\nint paintWalls(vector<int>& cost, vector<int>& time) {\\n    memset(dp, -1, cost.size() * sizeof(dp[0]));\\n    return dfs(0, time.size(), cost, time);        \\n}\\n```\n```cpp\\nint dp[501][501];\\nclass Solution {\\npublic:\\nint paintWalls(vector<int>& cost, vector<int>& time) {  \\n    fill_n(begin(dp[0]), cost.size() + 1, 1e9);\\n    dp[0][0] = 0;\\n    for (int i = 1; i <= cost.size(); ++i)\\n        for (int j = 0; j <= cost.size(); ++j)\\n            dp[i][j] = min(dp[i - 1][j], dp[i - 1][max(0, j - time[i - 1] - 1)] + cost[i - 1]);\\n    return dp[cost.size()][cost.size()];\\n}\\n```\n```cpp\\nint dp[501];\\nclass Solution {\\npublic:\\nint paintWalls(vector<int>& cost, vector<int>& time) {\\n    fill_n(begin(dp), cost.size() + 1, 1e9);\\n    dp[0] = 0;\\n    for (int i = 0; i < cost.size(); ++i)\\n        for (int j = cost.size(); j > 0; --j)\\n            dp[j] = min(dp[j], dp[max(0, j - time[i] - 1)] + cost[i]);\\n    return dp[cost.size()];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650426,
                "title": "detailed-dp-in-c-java-python",
                "content": "# Intuition\\nDP.\\nWe don\\'t need the concrete time units to use paid and free painters, only the difference of time units matters.\\n\\n\\n# Approach\\nLet dp[i][j] be the minimum cost to paint the first i walls and we use the paid painter j time units more than the free panter.\\n\\nWe have\\ndp[0][0] = 0\\ndp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j + time[i - 1]] + cost[i - 1])\\ndp[i - 1][j - 1] means we use the free painter for this wall.\\ndp[i - 1][j + times[i - 1]] + cost[i - 1] means we use the paid painter for this wall.\\n\\nThe answer is min(dp[n][j >= 0]).\\n\\nSome details:\\n1. Though j should be non-negative finally, it\\'s possible that it becomes neagtive temporally and becomes non-negatvie fianlly.\\n2. Since it only costs 1 time unit for the free painter to paint each wall, and we only care about j >= 0.\\n\\n\\nFor 1, note the \"smallest\" j is at most j - n, so we can plus n as an offset for j. So j\\' = j + n, then everything will be non negative. (Or we can simply use a map instead of array).\\n\\nFor 2, for all j >= n, we just set j = n, namely j = min(j, n). \\n\\nSo j\\' = j + n is in the range of [0, 2 * n].\\n\\n# Complexity\\n- Time complexity:\\nO(n ^ 2)\\n\\n- Space complexity:\\nO(n) if we use rolling array\\n\\n# Code\\n\\nC++\\n```\\nclass Solution {\\n    void better(int &x, int y) {\\n        if (y >= 0 && (x < 0 || x > y)) {\\n            x = y;\\n        }\\n    }\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        const int n = cost.size(), limit = n << 1, m = limit | 1;\\n        vector<vector<int>> dp(2, vector<int>(m, -1));\\n        dp[0][n] = 0;\\n        int last = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int now = last ^ 1;\\n            dp[now] = vector<int>(m, -1);\\n            for (int j = 0; j <= limit; ++j) {\\n                if (dp[last][j] >= 0) {\\n                    better(dp[now][min(limit, j + time[i])], dp[last][j] + cost[i]);\\n                    if (j) {\\n                        better(dp[now][j - 1], dp[last][j]);\\n                    }\\n                }\\n            }\\n            last ^= 1;\\n        }\\n        int r = -1;\\n        for (int i = n; i <= limit; ++i) {\\n            better(r, dp[last][i]);\\n        }\\n        return r;\\n    }\\n};       \\n```\\n\\nJava\\n```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        final int n = cost.length;\\n        final int limit = n << 1;\\n        final int m = limit | 1;\\n        int[][] dp = new int[2][m];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        dp[0][n] = 0;\\n        int last = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            int now = last ^ 1;\\n            Arrays.fill(dp[now], -1);\\n\\n            for (int j = 0; j <= limit; ++j) {\\n                if (dp[last][j] >= 0) {\\n                    better(dp[now], Math.min(limit, j + time[i]), dp[last][j] + cost[i]);\\n\\n                    if (j > 0) {\\n                        better(dp[now], j - 1, dp[last][j]);\\n                    }\\n                }\\n            }\\n\\n            last ^= 1;\\n        }\\n\\n        int[] r = new int[]{-1};\\n        for (int i = n; i <= limit; ++i) {\\n            better(r, 0, dp[last][i]);\\n        }\\n\\n        return r[0];\\n    }\\n\\n    private void better(int[] x, int index, int value) {\\n        if (value >= 0 && (x[index] < 0 || x[index] > value)) {\\n            x[index] = value;\\n        }\\n    }\\n}\\n```\\n\\nPython\\n```\\n\\nclass Solution:\\n    def better(self, x: int, y: int) -> int:\\n        return y if y >= 0 and (x < 0 or x > y) else x\\n\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        limit = n << 1\\n        m = limit | 1\\n        dp = [[-1] * m for _ in range(2)]\\n        dp[0][n] = 0\\n        last = 0\\n        for i in range(n):\\n            now = last ^ 1\\n            dp[now] = [-1] * m\\n            for j in range(limit + 1):\\n                if dp[last][j] >= 0:\\n                    dp[now][min(limit, j + time[i])] = self.better(dp[now][min(limit, j + time[i])], dp[last][j] + cost[i])\\n                    if j:\\n                        dp[now][j - 1] = self.better(dp[now][j - 1], dp[last][j])\\n            last ^= 1\\n        r = -1\\n        for i in range(n, limit + 1):\\n            r = self.better(r, dp[last][i])\\n        return r\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    void better(int &x, int y) {\\n        if (y >= 0 && (x < 0 || x > y)) {\\n            x = y;\\n        }\\n    }\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        const int n = cost.size(), limit = n << 1, m = limit | 1;\\n        vector<vector<int>> dp(2, vector<int>(m, -1));\\n        dp[0][n] = 0;\\n        int last = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int now = last ^ 1;\\n            dp[now] = vector<int>(m, -1);\\n            for (int j = 0; j <= limit; ++j) {\\n                if (dp[last][j] >= 0) {\\n                    better(dp[now][min(limit, j + time[i])], dp[last][j] + cost[i]);\\n                    if (j) {\\n                        better(dp[now][j - 1], dp[last][j]);\\n                    }\\n                }\\n            }\\n            last ^= 1;\\n        }\\n        int r = -1;\\n        for (int i = n; i <= limit; ++i) {\\n            better(r, dp[last][i]);\\n        }\\n        return r;\\n    }\\n};       \\n```\n```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        final int n = cost.length;\\n        final int limit = n << 1;\\n        final int m = limit | 1;\\n        int[][] dp = new int[2][m];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        dp[0][n] = 0;\\n        int last = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            int now = last ^ 1;\\n            Arrays.fill(dp[now], -1);\\n\\n            for (int j = 0; j <= limit; ++j) {\\n                if (dp[last][j] >= 0) {\\n                    better(dp[now], Math.min(limit, j + time[i]), dp[last][j] + cost[i]);\\n\\n                    if (j > 0) {\\n                        better(dp[now], j - 1, dp[last][j]);\\n                    }\\n                }\\n            }\\n\\n            last ^= 1;\\n        }\\n\\n        int[] r = new int[]{-1};\\n        for (int i = n; i <= limit; ++i) {\\n            better(r, 0, dp[last][i]);\\n        }\\n\\n        return r[0];\\n    }\\n\\n    private void better(int[] x, int index, int value) {\\n        if (value >= 0 && (x[index] < 0 || x[index] > value)) {\\n            x[index] = value;\\n        }\\n    }\\n}\\n```\n```\\n\\nclass Solution:\\n    def better(self, x: int, y: int) -> int:\\n        return y if y >= 0 and (x < 0 or x > y) else x\\n\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        limit = n << 1\\n        m = limit | 1\\n        dp = [[-1] * m for _ in range(2)]\\n        dp[0][n] = 0\\n        last = 0\\n        for i in range(n):\\n            now = last ^ 1\\n            dp[now] = [-1] * m\\n            for j in range(limit + 1):\\n                if dp[last][j] >= 0:\\n                    dp[now][min(limit, j + time[i])] = self.better(dp[now][min(limit, j + time[i])], dp[last][j] + cost[i])\\n                    if j:\\n                        dp[now][j - 1] = self.better(dp[now][j - 1], dp[last][j])\\n            last ^= 1\\n        r = -1\\n        for i in range(n, limit + 1):\\n            r = self.better(r, dp[last][i])\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653414,
                "title": "c-100-dp-with-drawing-of-example-clearly-explained",
                "content": "# Intuition\\n- Let the horizonal axis be `j walls remaining` and the vertical be `considering the first i walls`. Each `dp` cell represents the min cost needed.\\n- Below is a drawing of example 1:\\n\\n \\n![IMG_9340A6A5A01B-1.jpeg](https://assets.leetcode.com/users/images/c12d184e-299b-46ee-8b42-92559498284c_1687108830.0358267.jpeg)\\n\\n- Looping from the top left, at each cell we consider `take` (paint this wall with a cost) or `not_take` (don\\'t paint this wall). At each wall `i`:\\n    - If take, we incur a cost but gain some \"walls reduction\". For example, if the time for wall `i` is 2, we would gain \"2 walls reduction\" because we can utilize the free worker. \\n    - If not take, we look up the min cost of painting these number of walls in when considering only the `i-1` walls.\\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n\\n- Space complexity: $O(n^2)$\\n\\n# Code C++ (improved version)\\n```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        long long inf = 1e9;\\n        vector<vector<int>> dp(cost.size()+1, vector<int>(cost.size()+1, inf));\\n        for(int i = 0; i < dp.size(); i++){\\n            dp[i][0] = 0;\\n        }\\n\\n        for(int i = 1; i <= cost.size(); i ++){\\n            for(int j = 1; j <= cost.size(); j++){\\n                int not_take = dp[i-1][j];\\n                int take = dp[i-1][max(j-time[i-1]-1, 0)] + cost[i-1];\\n                dp[i][j] = min(take, not_take);\\n            }\\n        }\\n\\n        return dp[cost.size()][cost.size()];        \\n    }\\n};\\n```\\n\\n# Code (old version)\\n```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        long long inf = 1e9;\\n        vector<vector<int>> dp(cost.size()+1, vector<int>(cost.size()+1, inf));\\n        for(int i = 0; i < dp.size(); i++){\\n            dp[i][0] = 0;\\n        }\\n\\n        for(int i = 1; i <= cost.size(); i ++){\\n            for(int j = 1; j <= cost.size(); j++){\\n                /* Not take */\\n                long long not_take = dp[i-1][j];\\n                /* Take */\\n                long long take;\\n                if(j - time[i-1] - 1 < 0){\\n                    take = cost[i-1];\\n                }else{\\n                    take = (long long)dp[i-1][j-time[i-1]-1] + (long long)cost[i-1];\\n                }\\n                \\n                long long cur = min(take, not_take);\\n                dp[i][j] = min(inf, cur);\\n            }\\n        }\\n\\n        return dp[cost.size()][cost.size()];        \\n    }\\n};\\n```\\n\\nWelcome any suggestions!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        long long inf = 1e9;\\n        vector<vector<int>> dp(cost.size()+1, vector<int>(cost.size()+1, inf));\\n        for(int i = 0; i < dp.size(); i++){\\n            dp[i][0] = 0;\\n        }\\n\\n        for(int i = 1; i <= cost.size(); i ++){\\n            for(int j = 1; j <= cost.size(); j++){\\n                int not_take = dp[i-1][j];\\n                int take = dp[i-1][max(j-time[i-1]-1, 0)] + cost[i-1];\\n                dp[i][j] = min(take, not_take);\\n            }\\n        }\\n\\n        return dp[cost.size()][cost.size()];        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        long long inf = 1e9;\\n        vector<vector<int>> dp(cost.size()+1, vector<int>(cost.size()+1, inf));\\n        for(int i = 0; i < dp.size(); i++){\\n            dp[i][0] = 0;\\n        }\\n\\n        for(int i = 1; i <= cost.size(); i ++){\\n            for(int j = 1; j <= cost.size(); j++){\\n                /* Not take */\\n                long long not_take = dp[i-1][j];\\n                /* Take */\\n                long long take;\\n                if(j - time[i-1] - 1 < 0){\\n                    take = cost[i-1];\\n                }else{\\n                    take = (long long)dp[i-1][j-time[i-1]-1] + (long long)cost[i-1];\\n                }\\n                \\n                long long cur = min(take, not_take);\\n                dp[i][j] = min(inf, cur);\\n            }\\n        }\\n\\n        return dp[cost.size()][cost.size()];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651365,
                "title": "easy-knapsack-approach-c-dp",
                "content": "# Intuition\\n0/1 KnapSack Approach\\n\\n# Approach\\nIf we have already computed the pair of walls left with a particular index we will just send the computed result;\\n if (dp[i][walls] != -1) return dp[i][walls]; \\n\\nNow if we want to take a particular wall to be painted than we will assign that wall to the paid painter which will add cost[i] to our total cost and during the time the paid painter is painting the free painter will try to paint as many walls he want to paint so the remaining walls left will be totalwalls-time[i](during which the free painter will be painting as much  walls it can paint )-1(The wall alloted to the paid painter).\\n\\nint take = cost[i] + helper(i + 1, n, walls - time[i] - 1, cost, time, dp);\\n\\n\\nAnd if we dont take a wall then we just increment our index\\nint dontTake = helper(i + 1, n, walls, cost, time, dp)\\n\\nand in the end just storing the minimum in the dp[i][wall]\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(N^2)\\n- Space complexity:O(501*501)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(501, vector<int>(501, -1));\\n        return helper(0, n, n, cost, time, dp);\\n    }\\n\\n    int helper(int i, int n, int walls, vector<int>& cost, vector<int>& time, vector<vector<int>>& dp) {\\n        if (walls <= 0) {\\n            return 0;\\n        }\\n        if (i >= n) {\\n            return 2000000000;\\n        }\\n        if (dp[i][walls] != -1) {\\n            return dp[i][walls];\\n        }\\n        int take = cost[i] + helper(i + 1, n, walls - time[i] - 1, cost, time, dp);\\n        int dontTake = helper(i + 1, n, walls, cost, time, dp);\\n        return dp[i][walls] = min(take, dontTake);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(501, vector<int>(501, -1));\\n        return helper(0, n, n, cost, time, dp);\\n    }\\n\\n    int helper(int i, int n, int walls, vector<int>& cost, vector<int>& time, vector<vector<int>>& dp) {\\n        if (walls <= 0) {\\n            return 0;\\n        }\\n        if (i >= n) {\\n            return 2000000000;\\n        }\\n        if (dp[i][walls] != -1) {\\n            return dp[i][walls];\\n        }\\n        int take = cost[i] + helper(i + 1, n, walls - time[i] - 1, cost, time, dp);\\n        int dontTake = helper(i + 1, n, walls, cost, time, dp);\\n        return dp[i][walls] = min(take, dontTake);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651186,
                "title": "0-1-knapsack-dp-c-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to contradict greedy and start thinking in terms of 0/1 Knapsack.\\n\\nVideo Solution(Try solving the problem before going into the solution)\\n\\nhttps://youtu.be/Wk6_pAtSYow\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solve function is a recursive helper function that tries all possible choices for painting each wall and returns the minimum cost required to paint the remaining walls.\\n\\nIn the start we will think about 2 cases:\\n->Paid painter will not paint the wall\\n->Paid painter will paint the wall\\nHere, we require 3 variables\\n***int m=solve(i+1,s,c+1,n,v,t);\\nm=min(m,v[i]+solve(i+1,s+t[i],c+1,n,v,t));***\\nwhere \\'c\\' is the number of painters, here our dp array will exceed the time complexity.\\n\\nBut if you think it optimally you will get understand that while paid painter is painting the wall, 1 free painter work is also done so will increase ***s+t[i]+1, by this you can eliminate 1 variable.***\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int dp[501][1001];\\n    int solve(int i,int s,int n,vector<int>&v,vector<int>&t)\\n    {   \\n        if(s>=n)\\n            return 0;\\n        if(i>=n)\\n            return 1000000000;\\n        if(dp[i][s]!=-1)\\n            return dp[i][s];\\n        int m=solve(i+1,s,n,v,t);\\n        m=min(m,v[i]+solve(i+1,s+t[i]+1,n,v,t));\\n        return dp[i][s]=m;\\n    }\\n    int paintWalls(vector<int>& v, vector<int>& t) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=v.size();\\n        int ans=solve(0,0,n,v,t);\\n        return ans;\\n    }\\n};\\n```\\n```JAVA []\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\nclass Solution {\\n    int[][] dp;\\n\\n    int solve(int i, int s, int n, List<Integer> v, List<Integer> t) {\\n        if (s >= n)\\n            return 0;\\n        if (i >= n)\\n            return 1000000000;\\n        if (dp[i][s] != -1)\\n            return dp[i][s];\\n\\n        int m = solve(i + 1, s, n, v, t);\\n        m = Math.min(m, v.get(i) + solve(i + 1, s + t.get(i) + 1, n, v, t));\\n\\n        return dp[i][s] = m;\\n    }\\n\\n    int paintWalls(List<Integer> v, List<Integer> t) {\\n        int n = v.size();\\n        dp = new int[501][1001];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        int ans = solve(0, 0, n, v, t);\\n        return ans;\\n    }\\n\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = [[-1] * 1001 for _ in range(501)]\\n\\n    def solve(self, i, s, n, v, t):\\n        if s >= n:\\n            return 0\\n        if i >= n:\\n            return 1000000000\\n        if self.dp[i][s] != -1:\\n            return self.dp[i][s]\\n\\n        m = self.solve(i + 1, s, n, v, t)\\n        m = min(m, v[i] + self.solve(i + 1, s + t[i] + 1, n, v, t))\\n\\n        self.dp[i][s] = m\\n        return m\\n\\n    def paintWalls(self, v, t):\\n        n = len(v)\\n        ans = self.solve(0, 0, n, v, t)\\n        return ans\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dp[501][1001];\\n    int solve(int i,int s,int n,vector<int>&v,vector<int>&t)\\n    {   \\n        if(s>=n)\\n            return 0;\\n        if(i>=n)\\n            return 1000000000;\\n        if(dp[i][s]!=-1)\\n            return dp[i][s];\\n        int m=solve(i+1,s,n,v,t);\\n        m=min(m,v[i]+solve(i+1,s+t[i]+1,n,v,t));\\n        return dp[i][s]=m;\\n    }\\n    int paintWalls(vector<int>& v, vector<int>& t) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=v.size();\\n        int ans=solve(0,0,n,v,t);\\n        return ans;\\n    }\\n};\\n```\n```JAVA []\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\nclass Solution {\\n    int[][] dp;\\n\\n    int solve(int i, int s, int n, List<Integer> v, List<Integer> t) {\\n        if (s >= n)\\n            return 0;\\n        if (i >= n)\\n            return 1000000000;\\n        if (dp[i][s] != -1)\\n            return dp[i][s];\\n\\n        int m = solve(i + 1, s, n, v, t);\\n        m = Math.min(m, v.get(i) + solve(i + 1, s + t.get(i) + 1, n, v, t));\\n\\n        return dp[i][s] = m;\\n    }\\n\\n    int paintWalls(List<Integer> v, List<Integer> t) {\\n        int n = v.size();\\n        dp = new int[501][1001];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        int ans = solve(0, 0, n, v, t);\\n        return ans;\\n    }\\n\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = [[-1] * 1001 for _ in range(501)]\\n\\n    def solve(self, i, s, n, v, t):\\n        if s >= n:\\n            return 0\\n        if i >= n:\\n            return 1000000000\\n        if self.dp[i][s] != -1:\\n            return self.dp[i][s]\\n\\n        m = self.solve(i + 1, s, n, v, t)\\n        m = min(m, v[i] + self.solve(i + 1, s + t[i] + 1, n, v, t))\\n\\n        self.dp[i][s] = m\\n        return m\\n\\n    def paintWalls(self, v, t):\\n        n = len(v)\\n        ans = self.solve(0, 0, n, v, t)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650595,
                "title": "simple-c-dp-o-n-n-consise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we choose a wall to be painted by the paid painter then our walls to be painted now are  = remaining - time[curIndex] - 1 \\nBecause for time[curIndex] we can get the walls painted each in 1 unit of time and the 1 for current wall painted.\\n\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cal(int i, int rem,vector<int>& cost, vector<int>& time,vector<vector<int>>&dp)\\n    {\\n        if(rem<0)\\n            return 0;\\n        if(i==-1)\\n        {\\n            if(rem==0) return 0;\\n            return 1e9;\\n        }\\n        if(dp[i][rem]!=-1)\\n            return dp[i][rem];\\n        int ans = 1e9;\\n        ans = min(ans,cal(i-1,rem,cost,time,dp));\\n        ans = min(ans,cost[i] + cal(i-1,rem-time[i]-1,cost,time,dp));\\n        return dp[i][rem] = ans;\\n    }\\n  \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return cal(n-1,n,cost,time,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cal(int i, int rem,vector<int>& cost, vector<int>& time,vector<vector<int>>&dp)\\n    {\\n        if(rem<0)\\n            return 0;\\n        if(i==-1)\\n        {\\n            if(rem==0) return 0;\\n            return 1e9;\\n        }\\n        if(dp[i][rem]!=-1)\\n            return dp[i][rem];\\n        int ans = 1e9;\\n        ans = min(ans,cal(i-1,rem,cost,time,dp));\\n        ans = min(ans,cost[i] + cal(i-1,rem-time[i]-1,cost,time,dp));\\n        return dp[i][rem] = ans;\\n    }\\n  \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return cal(n-1,n,cost,time,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650505,
                "title": "python-top-down-dp-short-crispy",
                "content": "Surprized to see so less submissions on this Q. Constraints give a strong hint for dp.\\nThe Q can be rephrased as find min cost by assinging each index to any of the painter in such a way that total time taken by free painter is less than or equal to total time taken by paid painter. Which in turn means that the final time should be greater than or equal to 0 if we subtract time for free and add time for paid painter.\\nTime Complexity : O(n * max(time))\\n\\nCode:\\n\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n=len(cost)\\n        @cache\\n        def dp(idx,t):\\n            if idx==n: return 0 if t>=0 else sys.maxsize\\n            #this index painted by paid painter\\n            ans=cost[idx]+dp(idx+1,min(n+1,t+time[idx]))\\n            #free painter\\n            ans=min(ans,dp(idx+1,t-1))\\n            return ans\\n        return dp(0,0)\\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n=len(cost)\\n        @cache\\n        def dp(idx,t):\\n            if idx==n: return 0 if t>=0 else sys.maxsize\\n            #this index painted by paid painter\\n            ans=cost[idx]+dp(idx+1,min(n+1,t+time[idx]))\\n            #free painter\\n            ans=min(ans,dp(idx+1,t-1))\\n            return ans\\n        return dp(0,0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650989,
                "title": "java-highly-intuitive-top-down-approach-eliminate-the-constraint",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first sight this is a straight forward DP problem. You pick as less paid painters as possible to minimize the cost but with a condition.\\n\\nAssume you pick **`k`** paid painters, then remaining **`n-k`** will be free painters.\\n\\nLet\\'s call \"the time it takes for paid painter\" as paidPainterTime or  **ppt**. We know that **ppt** has to be greater or equal to number of free painters.\\n\\nThen your favourable break point in your recursion will be at **`ppt >= n-k`**\\nUnfavourable break point will be **`i >= n`** but when it\\'s still is **`ppt < n-k`** \\n\\nA straigtforward top down solution will look like this:\\n**i = 0\\nk = 0\\nppt = 0**\\n```\\nif(ppt >= n - k) return 0;\\nif(i >= n) return inf;\\n\\ntake = cost[i] + f(i+1, k+1, ppt + time[i]);\\nignore = f(i+1, k, ppt);\\nreturn min(take, ignore)\\n```\\n\\nThis is brute force so you try to memoize this. This would work in normal case but here the constraints won\\'t allow us to do **`memo[i][k][ppt]`**. The memory would be too large.\\n\\nHowever we can be smart and try to **eliminate** **`k`** out of the equation. \\n\\nTo do that we have to ask, why to use **`k`**? if all we are doing is incrementing it, unlike **`ppt`** where it is actually contributing in using **`time[i]`**. However the **`k`** is being used only for the sake of **`if(ppt >= n - k) return 0;`**. \\n\\nSo if we can remove the **`k`** somehow, our **`memo[i][k][ppt]`** will become much better which is **`memo[i][ppt]`**\\n\\nHow can we do that? Simple, **`ppt >= n - k`** can be written as **`ppt + k >= n`** and if you observe the value **`ppt + k`** can be again stored in **`ppt`** variable itself. During recursion we can just smuggle the **`k`** increments into the **`ppt`** parameter. So it will become **`ppt += k`**.\\n\\nNow the solution would look something like this:\\n**i = 0\\nppt = 0**\\n\\n```\\nif(ppt >= n) return 0;\\nif(i >= n) return inf;\\n\\ntake = cost[i] + f(i+1, ppt + time[i] + 1);\\nignore = f(i+1, ppt);\\nreturn min(take, ignore)\\n```\\n\\nNow memoization  is as simple as **`memo[i][ppt]`**\\n# Code\\n```\\npublic int paintWalls(int[] cost, int[] time) {\\n    int n = time.length;\\n    return solve(cost, time, 0, 0, new Integer[n+1][n+1], n);\\n}\\n\\nprivate int solve(int[] cost, int[] time, int i, int ppt, Integer[][] memo, int n){\\n    if(ppt >= n)\\n        return 0;\\n    \\n    if(i >= n)\\n        return 5 * (int)1e8 + 1;\\n    \\n    if(memo[i][ppt] != null)\\n        return memo[i][ppt];\\n    \\n    int take = cost[i] + solve(cost, time, i+1, ppt + time[i] + 1, memo, n);\\n    int ignore = solve(cost, time, i+1, ppt, memo, n);\\n    \\n    return memo[i][ppt] = Math.min(take, ignore);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nif(ppt >= n - k) return 0;\\nif(i >= n) return inf;\\n\\ntake = cost[i] + f(i+1, k+1, ppt + time[i]);\\nignore = f(i+1, k, ppt);\\nreturn min(take, ignore)\\n```\n```\\nif(ppt >= n) return 0;\\nif(i >= n) return inf;\\n\\ntake = cost[i] + f(i+1, ppt + time[i] + 1);\\nignore = f(i+1, ppt);\\nreturn min(take, ignore)\\n```\n```\\npublic int paintWalls(int[] cost, int[] time) {\\n    int n = time.length;\\n    return solve(cost, time, 0, 0, new Integer[n+1][n+1], n);\\n}\\n\\nprivate int solve(int[] cost, int[] time, int i, int ppt, Integer[][] memo, int n){\\n    if(ppt >= n)\\n        return 0;\\n    \\n    if(i >= n)\\n        return 5 * (int)1e8 + 1;\\n    \\n    if(memo[i][ppt] != null)\\n        return memo[i][ppt];\\n    \\n    int take = cost[i] + solve(cost, time, i+1, ppt + time[i] + 1, memo, n);\\n    int ignore = solve(cost, time, i+1, ppt, memo, n);\\n    \\n    return memo[i][ppt] = Math.min(take, ignore);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650421,
                "title": "basic-dp-reduce-walls-to-0",
                "content": "This problem is much easier if you realize you just need to reduce the walls needed to be painted to 0. When you buy a paid painter, you incur a cost of cost[pos] and reduce the walls needed to be painted by (1+time[pos]). We now just need to find the minimum cost to reduce the walls needed to be painted to <= 0. This is very easy to do with DP, as now we can memoize based on the position we are at in the array and the number of walls we need to paint. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int memo[501][501] = {};\\n    int dfs(vector<int>& cost, vector<int>& time, int pos, int paint){\\n        if(paint <= 0) return 0;\\n        if(pos >= cost.size()) return 1e9; // reached the end of the array without painting all the walls\\n        if(memo[pos][paint] != -1) return memo[pos][paint];\\n        int ans = dfs(cost, time, pos+1, paint-1 - time[pos])+cost[pos];\\n        ans = min(ans, dfs(cost, time, pos+1, paint));\\n        return memo[pos][paint] = ans;\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(memo, -1, sizeof memo);\\n        return dfs(cost, time, 0, cost.size());\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int memo[501][501] = {}",
                "codeTag": "Java"
            },
            {
                "id": 3663992,
                "title": "optimized-approach-minimum-cost-to-paint-walls",
                "content": "```\\nclass Solution {\\nprivate:\\n    // Function to calculate the minimum cost to paint the walls\\n    int memo(vector<int>& cost, vector<int>& time, int index, int walls, vector<vector<int>>& dp) {\\n        // If there are no walls to paint, return 0 (base case)\\n        if (walls <= 0) \\n            return 0;\\n        // If we have processed all walls but still have some remaining, return a large value (to be neglected later)\\n        if (index < 0) \\n            return 1e9;\\n        // If the result for the current index and walls is already calculated, return it\\n        if (dp[index][walls] != -1) \\n            return dp[index][walls];\\n\\n        // Calculate the minimum cost by either taking the current wall or not taking it\\n        int notTake = 0 + memo(cost, time, index - 1, walls, dp);  // Not taking the current wall\\n        int take = cost[index] + memo(cost, time, index - 1, walls - time[index] - 1, dp);  // Taking the current wall\\n\\n        // Store the minimum cost in the dp array for future use\\n        return dp[index][walls] = min(notTake, take);\\n    }\\n\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));  // Create a 2D vector for memoization\\n\\n        // Call the memoization function starting from the last wall (index = n-1)\\n        // and passing the total number of walls (n) and the dp array\\n        return memo(cost, time, n - 1, n, dp);\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Function to calculate the minimum cost to paint the walls\\n    int memo(vector<int>& cost, vector<int>& time, int index, int walls, vector<vector<int>>& dp) {\\n        // If there are no walls to paint, return 0 (base case)\\n        if (walls <= 0) \\n            return 0;\\n        // If we have processed all walls but still have some remaining, return a large value (to be neglected later)\\n        if (index < 0) \\n            return 1e9;\\n        // If the result for the current index and walls is already calculated, return it\\n        if (dp[index][walls] != -1) \\n            return dp[index][walls];\\n\\n        // Calculate the minimum cost by either taking the current wall or not taking it\\n        int notTake = 0 + memo(cost, time, index - 1, walls, dp);  // Not taking the current wall\\n        int take = cost[index] + memo(cost, time, index - 1, walls - time[index] - 1, dp);  // Taking the current wall\\n\\n        // Store the minimum cost in the dp array for future use\\n        return dp[index][walls] = min(notTake, take);\\n    }\\n\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));  // Create a 2D vector for memoization\\n\\n        // Call the memoization function starting from the last wall (index = n-1)\\n        // and passing the total number of walls (n) and the dp array\\n        return memo(cost, time, n - 1, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656781,
                "title": "knapsack-dp-with-transitions-explained",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\ndp[j] = minimum cost to paint j walls\\n\\ndp[0]=0;\\n\\nso , at each index we have two options either to paint it with paid painter or not paint it with paid painter\\n\\nso, if we paint it with paid painter then we use time[i] units of time , now this time can be used to paint time[i] amount of walls with free painter since time required by free painter is 1 and with zero cost and remaining walls are j-time[i]-1\\n\\nso dp[j] = min(dp[j],dp[j-time[i]-1]+cost[i]) \\n\\nnow, we can reduce space complexity by iterating in reverse and updating dp[j] like standard knapsack dp \\n\\nfinally , our answer is dp[n] \\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        \\n        int n=cost.size();\\n        \\n        // dp[i][j] = dp[i][j-times[i]-1];\\n        int inf=2e9;\\n        vector<int>dp(n+1,inf);\\n        dp[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int walls=n;walls>=0;walls--)\\n            {\\n                dp[walls]=min(dp[walls],dp[max(0,walls-time[i]-1)]+cost[i]);\\n            }\\n        }       \\n        return dp[n]; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        \\n        int n=cost.size();\\n        \\n        // dp[i][j] = dp[i][j-times[i]-1];\\n        int inf=2e9;\\n        vector<int>dp(n+1,inf);\\n        dp[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int walls=n;walls>=0;walls--)\\n            {\\n                dp[walls]=min(dp[walls],dp[max(0,walls-time[i]-1)]+cost[i]);\\n            }\\n        }       \\n        return dp[n]; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653018,
                "title": "java-dfs-memo-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int[] cost, time;\\n    int n;\\n    int[][] memo;\\n    public int paintWalls(int[] cost, int[] time) {\\n        this.n = cost.length;\\n        this.cost = cost;\\n        this.time = time;\\n        memo = new int[n][(n + 1) / 2 + 1000];\\n        for (int i = 0; i < n; i++)\\n            Arrays.fill(memo[i], -1);\\n        return dfs(0, 0, n);\\n    }\\n\\n    private int dfs(int index, int currTime, int remain) {\\n        if (currTime >= remain) return 0;\\n        if (index == n) return currTime < 0 ? Integer.MAX_VALUE / 2 : 0;\\n        if (memo[index][currTime + 500] != -1)\\n            return memo[index][currTime + 500];\\n        int paid = cost[index] + dfs(index + 1, currTime + time[index], n - 1);\\n        int free = dfs(index + 1, currTime - 1, n - 1);\\n        memo[index][currTime + 500] = Math.min(paid, free);\\n        return memo[index][currTime + 500];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] cost, time;\\n    int n;\\n    int[][] memo;\\n    public int paintWalls(int[] cost, int[] time) {\\n        this.n = cost.length;\\n        this.cost = cost;\\n        this.time = time;\\n        memo = new int[n][(n + 1) / 2 + 1000];\\n        for (int i = 0; i < n; i++)\\n            Arrays.fill(memo[i], -1);\\n        return dfs(0, 0, n);\\n    }\\n\\n    private int dfs(int index, int currTime, int remain) {\\n        if (currTime >= remain) return 0;\\n        if (index == n) return currTime < 0 ? Integer.MAX_VALUE / 2 : 0;\\n        if (memo[index][currTime + 500] != -1)\\n            return memo[index][currTime + 500];\\n        int paid = cost[index] + dfs(index + 1, currTime + time[index], n - 1);\\n        int free = dfs(index + 1, currTime - 1, n - 1);\\n        memo[index][currTime + 500] = Math.min(paid, free);\\n        return memo[index][currTime + 500];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652040,
                "title": "simple-take-and-non-take-condition-dp-recursion",
                "content": "**HOW TO THINK ABOUT DP** **?**  \\nbecause i have to think all the cases (i.e 2^n). that can be implemented by recursion.\\n\\nNow , \\nthere will be two cases :\\n```\\ncase 1 : if not painting (notTake condition)\\nthen simply go to next index\\n```\\n\\n```\\ncase 2: if painting (take condition)\\nthen we can paint that index + time[index] \\n```\\nand last return minimum of them. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int ind,vector<int> &cost,vector<int> &time,int count,vector<vector<int>>&dp)\\n    {\\n        if(ind>=cost.size())\\n        {\\n            if(count<=0) return 0;\\n            else return 1e9;\\n        }\\n        if(count<=0) return 0;\\n        \\n        if(dp[ind][count]!=-1) return dp[ind][count];\\n        int notTake=solve(ind+1,cost,time,count,dp);\\n        int take=cost[ind]+solve(ind+1,cost,time,count-1-time[ind],dp);\\n\\n        return dp[ind][count]= min(notTake,take);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        \\n        int n=cost.size();\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n       return solve(0,cost,time,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ncase 1 : if not painting (notTake condition)\\nthen simply go to next index\\n```\n```\\ncase 2: if painting (take condition)\\nthen we can paint that index + time[index] \\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int ind,vector<int> &cost,vector<int> &time,int count,vector<vector<int>>&dp)\\n    {\\n        if(ind>=cost.size())\\n        {\\n            if(count<=0) return 0;\\n            else return 1e9;\\n        }\\n        if(count<=0) return 0;\\n        \\n        if(dp[ind][count]!=-1) return dp[ind][count];\\n        int notTake=solve(ind+1,cost,time,count,dp);\\n        int take=cost[ind]+solve(ind+1,cost,time,count-1-time[ind],dp);\\n\\n        return dp[ind][count]= min(notTake,take);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        \\n        int n=cost.size();\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n       return solve(0,cost,time,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650491,
                "title": "c-o-n-n-easy-dp-solution-with-thought-process",
                "content": "Dynamic programming solution : \\n\\nFor every unit time paid painter is occupied in painting a wall, free painter can complete 1 wall for 0 cost, i.e. if paid painter takes t units time to paint a wall, t walls can be painted by free painter for 0 cost.\\n\\nBased on above statement we need to select a set of walls for paid painter to paint, while these walls are getting painted, free painter can paint the remaining walls for 0 cost.\\n\\nNow it can be treated as a DP problem where we need to find minimum cost by either selecting current wall(painted by paid painter) or by leaving it(assuming it will be painted by free painter).\\n\\nOptimal sub-structure :\\n\\n``` \\nSol(currIndex, remainingWalls) = min(ans1, ans2) where,\\n\\tans1 = Sol(currIndex+1, remainingWalls)\\n\\tans2 = cost[currIndex] + Sol(currIndex+1, remainingWalls-1-time[currIndex])\\n```\\n\\nTime Complexity : ```O(n*n)```, where n = number of walls\\nSpace Complexity : ```O(n*n)```\\n\\n```\\nint dp[510][510];\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp, -1, sizeof(dp));\\n        int n = cost.size();\\n        \\n        int ans = getans(0, n, cost, time);\\n        return ans;\\n    }\\n    \\n    int getans(int curr, int rem, vector<int>&cost, vector<int> &time) {\\n        if(rem <= 0)\\n            return 0;\\n        if(curr == cost.size())\\n            return 1e9;\\n        \\n        if(dp[curr][rem] != -1)\\n            return dp[curr][rem];\\n        \\n        int ans1 = getans(curr+1, rem, cost, time);\\n        int ans2 = cost[curr] + getans(curr+1, rem-1-time[curr], cost, time);\\n        \\n        dp[curr][rem] = min(ans1, ans2);\\n        return dp[curr][rem];\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\nSol(currIndex, remainingWalls) = min(ans1, ans2) where,\\n\\tans1 = Sol(currIndex+1, remainingWalls)\\n\\tans2 = cost[currIndex] + Sol(currIndex+1, remainingWalls-1-time[currIndex])\\n```\n```O(n*n)```\n```O(n*n)```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650438,
                "title": "straightforward-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        int memo[n][2*n+2];\\n        memset(memo, -1, sizeof memo);\\n        \\n        int INF = 1e9;\\n        \\n        function<int(int,int)> solve = [&](int i, int j) {\\n            // base cases\\n            if(i == n) {\\n                if(j < 0) return INF;\\n                return 0;\\n            }\\n            \\n            if(memo[i][n+j] != -1) return memo[i][n+j];\\n            \\n            int result = INF;\\n            \\n            // use paid painter\\n            result = min(result, cost[i] + solve(i+1, min(n-1,j+time[i])));\\n            \\n            // use free painter\\n            result = min(result, solve(i+1, j-1));\\n            \\n            return memo[i][n+j] = result;\\n        };\\n        \\n        return solve(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        int memo[n][2*n+2];\\n        memset(memo, -1, sizeof memo);\\n        \\n        int INF = 1e9;\\n        \\n        function<int(int,int)> solve = [&](int i, int j) {\\n            // base cases\\n            if(i == n) {\\n                if(j < 0) return INF;\\n                return 0;\\n            }\\n            \\n            if(memo[i][n+j] != -1) return memo[i][n+j];\\n            \\n            int result = INF;\\n            \\n            // use paid painter\\n            result = min(result, cost[i] + solve(i+1, min(n-1,j+time[i])));\\n            \\n            // use free painter\\n            result = min(result, solve(i+1, j-1));\\n            \\n            return memo[i][n+j] = result;\\n        };\\n        \\n        return solve(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657487,
                "title": "0-1-knapsack-dp-problem",
                "content": "# Intuition\\nThink of this problem as 0/1 Knapsack problem, but in place of getting maximum values in our bag this problem ask us to paint the entirity of wall using minimum coins.\\n\\n# Approach\\nIn 0/1 Knapsack type of problems we use pick not-pick technique i.e there will be two cases :\\n 1) We\\'ll pick paid painter to paint the wall, as the paid painter is busy we can use free painter to paint time[i] walls, so effectively the number of wall go down to wallsLeft - time[i] - 1. This operation will cost us cost[i] coins.\\n2) We\\'ll not use paid painter to paint this wall, we\\'ll just increase our index counter.\\n\\nReturn the minimum of pick and not-pick. \\n\\n\\n# Recursive Code\\n```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        return f(0,n,cost,time);\\n    }\\n\\n    int f(int i, int walls, vector<int>& cost, vector<int>& time) {\\n        if(walls <= 0) return 0;\\n\\n        if(i>=cost.size()) return 1e9;\\n\\n        int not_pick = f(i+1,walls,cost,time);\\n        int pick = cost[i] + f(i+1,walls-time[i]-1,cost,time);\\n        return min(pick,not_pick);\\n    }\\n};\\n```\\n\\n# Memoization Code\\n```\\nclass Solution {\\n    int dp[501][501];\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,n,cost,time);\\n    }\\n\\n    int f(int i, int walls, vector<int>& cost, vector<int>& time) {\\n        if(walls <= 0) return 0;\\n\\n        if(i>=cost.size()) return 1e9;\\n\\n        if(dp[i][walls]!=-1) return dp[i][walls];\\n\\n        int not_pick = f(i+1,walls,cost,time);\\n        int pick = cost[i] + f(i+1,walls-time[i]-1,cost,time);\\n        return dp[i][walls] = min(pick,not_pick);\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        return f(0,n,cost,time);\\n    }\\n\\n    int f(int i, int walls, vector<int>& cost, vector<int>& time) {\\n        if(walls <= 0) return 0;\\n\\n        if(i>=cost.size()) return 1e9;\\n\\n        int not_pick = f(i+1,walls,cost,time);\\n        int pick = cost[i] + f(i+1,walls-time[i]-1,cost,time);\\n        return min(pick,not_pick);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int dp[501][501];\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,n,cost,time);\\n    }\\n\\n    int f(int i, int walls, vector<int>& cost, vector<int>& time) {\\n        if(walls <= 0) return 0;\\n\\n        if(i>=cost.size()) return 1e9;\\n\\n        if(dp[i][walls]!=-1) return dp[i][walls];\\n\\n        int not_pick = f(i+1,walls,cost,time);\\n        int pick = cost[i] + f(i+1,walls-time[i]-1,cost,time);\\n        return dp[i][walls] = min(pick,not_pick);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652687,
                "title": "easy-c-0-1-knapsack-bottem-up-memoisation",
                "content": "# Intuition\\nHere we are given 2 painters. Painter 1 takes cost[i] amount and time[i] time to paint i th wall. When the painter 1 is busy painting a wall, Painter 2 can paint other walls in 0 cost and 1 unit time. So what do you understand ? Whether Painter 2 will be able to paint a wall depends on Painter 1. Thus let us eliminate the story of painter 2 for the time being. Focus on Painter 1. So the problem boils down to the conclusion of take and nottake case of painter 1, When painter 1 will be busy, we will simply nottake any wall. Why? Because when painter 1 will be busy we will change the number of wall remaining to : walls - time[i] - 1(-1 for current wall). Thus this compensates for the painter 2. \\n\\n# Approach\\nwallsRemaining - time[i] - 1  : If painter 1 paints one current wall, then how many walls will freePainter will paint in same time simultaneously?\\nfreePainter taking 1 unit of time to paint any wall.\\nif time is 3 , so he can paint 3 walls in 3 unit of time.\\n\\n- subtracting time[i] from currently Remaining Walls bcz simultaneously freePainter will paint total time[i] number of walls.\\n\\nsimilarly \\n- substacting -1 bcz painter 1 is painting current wall.\\n\\nif painter 1 choose i\\'th wall to paint then\\n```\\nRemaining Walls  =  walls - time[i] - 1;\\n```\\n \\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N*N)\\n\\n# Code\\n### ***Top Down***\\n\\n```\\nclass Solution {\\npublic :\\n    int dp[502][502] ;\\n    int solve(int index, int walls, vector<int>& cost,vector<int>& time)\\n    {\\n        if(walls <= 0)return 0;\\n        if(index == cost.size())return 1e9; //Neglect this by returning unusually large value\\n        \\n        if(dp[index][walls] != -1)return dp[index][walls] ;\\n        \\n        long long notTake = 0 + solve(index+1, walls, cost, time);\\n        long long take = cost[index] + solve(index+1, walls-time[index]-1, cost, time) ;\\n        \\n        return dp[index][walls] =  min(take, notTake) ;\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp, -1, sizeof(dp)) ;\\n        int walls = cost.size() ;           //capacity\\n        return solve(0 ,walls, cost, time) ;\\n    }\\n};\\n```\\n\\n### ***Bottem Up***\\n```\\n    int DPtab(vector<int>& cost, vector<int>& time)\\n    {\\n        int n = cost.size() ;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 1e9));\\n        for(int index = 0; index <= cost.size(); index++)\\n            dp[index][0] = 0;\\n        \\n        for(int index = cost.size()-1; index>=0; index--)\\n        {\\n            for(int walls=0; walls<=n; walls++)\\n            {\\n                long long notTake = 0 + dp[index+1][walls] ;\\n                long long take = cost[index] + dp[index+1][ max(walls-time[index]-1, 0)] ;\\n\\n                dp[index][walls] =  min(take, notTake) ;\\n            }\\n        }\\n        return dp[0][n] ;\\n    }\\n```\\n\\n\\n![upvote](https://assets.leetcode.com/users/images/6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nRemaining Walls  =  walls - time[i] - 1;\\n```\n```\\nclass Solution {\\npublic :\\n    int dp[502][502] ;\\n    int solve(int index, int walls, vector<int>& cost,vector<int>& time)\\n    {\\n        if(walls <= 0)return 0;\\n        if(index == cost.size())return 1e9; //Neglect this by returning unusually large value\\n        \\n        if(dp[index][walls] != -1)return dp[index][walls] ;\\n        \\n        long long notTake = 0 + solve(index+1, walls, cost, time);\\n        long long take = cost[index] + solve(index+1, walls-time[index]-1, cost, time) ;\\n        \\n        return dp[index][walls] =  min(take, notTake) ;\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp, -1, sizeof(dp)) ;\\n        int walls = cost.size() ;           //capacity\\n        return solve(0 ,walls, cost, time) ;\\n    }\\n};\\n```\n```\\n    int DPtab(vector<int>& cost, vector<int>& time)\\n    {\\n        int n = cost.size() ;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 1e9));\\n        for(int index = 0; index <= cost.size(); index++)\\n            dp[index][0] = 0;\\n        \\n        for(int index = cost.size()-1; index>=0; index--)\\n        {\\n            for(int walls=0; walls<=n; walls++)\\n            {\\n                long long notTake = 0 + dp[index+1][walls] ;\\n                long long take = cost[index] + dp[index+1][ max(walls-time[index]-1, 0)] ;\\n\\n                dp[index][walls] =  min(take, notTake) ;\\n            }\\n        }\\n        return dp[0][n] ;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650808,
                "title": "easy-short-efficient-clean-2-codes",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    unordered_map<int, vector<int>>dp;\\n    int func(const vector<int>&c, const vector<int>&t, int ind, int rem){\\n        if(ind==n){\\n            return (rem>-1 ? 0 : INT_MAX);\\n        }\\n        if(dp[rem].empty()){\\n            dp[rem].resize(n, -1);\\n        }\\n        if(dp[rem][ind]!=-1){\\n            return dp[rem][ind];\\n        }\\n        int dont = func(c, t, ind+1, rem-1);\\n        int take = func(c, t, ind+1, rem+t[ind]);\\n        if(take<INT_MAX){\\n            take+=c[ind];\\n        }\\n        return dp[rem][ind]=min(take, dont);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        n = cost.size();\\n        return func(cost, time, 0, 0);\\n    }\\n};\\n```\\n__Faster approach__\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>>dp;\\n    int func(const vector<int>&c, const vector<int>&t, int ind, int rem){\\n        if(rem<1){ // all walls painted\\n            return 0;\\n        }\\n        if(ind==n){ // walls remaining\\n            return INT_MAX;\\n        }\\n        if(dp[rem][ind]!=-1){\\n            return dp[rem][ind];\\n        }\\n        int dont = func(c, t, ind+1, rem); // assume this we got a free painting from the past\\n        int take = func(c, t, ind+1, rem-1-t[ind]); // lets pay and paint this wall ; rem = rem - 1 (panted) - t[ind] (will paint for free in future)\\n        if(take<INT_MAX){\\n            take+=c[ind];\\n        }\\n        return dp[rem][ind]=min(take, dont);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        n = cost.size();\\n        dp.resize(n+1, vector<int>(n+1, -1));\\n        return func(cost, time, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    unordered_map<int, vector<int>>dp;\\n    int func(const vector<int>&c, const vector<int>&t, int ind, int rem){\\n        if(ind==n){\\n            return (rem>-1 ? 0 : INT_MAX);\\n        }\\n        if(dp[rem].empty()){\\n            dp[rem].resize(n, -1);\\n        }\\n        if(dp[rem][ind]!=-1){\\n            return dp[rem][ind];\\n        }\\n        int dont = func(c, t, ind+1, rem-1);\\n        int take = func(c, t, ind+1, rem+t[ind]);\\n        if(take<INT_MAX){\\n            take+=c[ind];\\n        }\\n        return dp[rem][ind]=min(take, dont);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        n = cost.size();\\n        return func(cost, time, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>>dp;\\n    int func(const vector<int>&c, const vector<int>&t, int ind, int rem){\\n        if(rem<1){ // all walls painted\\n            return 0;\\n        }\\n        if(ind==n){ // walls remaining\\n            return INT_MAX;\\n        }\\n        if(dp[rem][ind]!=-1){\\n            return dp[rem][ind];\\n        }\\n        int dont = func(c, t, ind+1, rem); // assume this we got a free painting from the past\\n        int take = func(c, t, ind+1, rem-1-t[ind]); // lets pay and paint this wall ; rem = rem - 1 (panted) - t[ind] (will paint for free in future)\\n        if(take<INT_MAX){\\n            take+=c[ind];\\n        }\\n        return dp[rem][ind]=min(take, dont);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        n = cost.size();\\n        dp.resize(n+1, vector<int>(n+1, -1));\\n        return func(cost, time, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650688,
                "title": "simple-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> dp;\\n    int rec(int idx,int left,vector<int> &cost,vector<int> &time)\\n    {\\n        if(left<=0) return 0;\\n        if(idx==n) return 1e9;\\n       \\n        if(dp[idx][left]!=-1) return dp[idx][left];\\n        int take = cost[idx] + rec(idx+1,left-1-time[idx],cost,time);\\n        int not_take = rec(idx+1,left,cost,time);\\n        \\n        return dp[idx][left] = min(take,not_take);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time)\\n    {\\n        n = cost.size();\\n     \\n        dp = vector<vector<int>> (n+1,vector<int>(n+1,-1));\\n        \\n        return rec(0,n,cost,time);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> dp;\\n    int rec(int idx,int left,vector<int> &cost,vector<int> &time)\\n    {\\n        if(left<=0) return 0;\\n        if(idx==n) return 1e9;\\n       \\n        if(dp[idx][left]!=-1) return dp[idx][left];\\n        int take = cost[idx] + rec(idx+1,left-1-time[idx],cost,time);\\n        int not_take = rec(idx+1,left,cost,time);\\n        \\n        return dp[idx][left] = min(take,not_take);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time)\\n    {\\n        n = cost.size();\\n     \\n        dp = vector<vector<int>> (n+1,vector<int>(n+1,-1));\\n        \\n        return rec(0,n,cost,time);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667070,
                "title": "simplest-and-most-intuitive-solution-with-complete-explanation-and-solution-in-c",
                "content": "# Intuition\\nSimple intuition is to do that particular task or not, so think of 0/1 knapsack kind of thing but with some modification.\\n\\n# Approach\\nThink like that I will tell my function that I will provide you ind and number of walls to be painted from index 0 to that ind with minimum cost.\\nSo initially I will call with index as n - 1 and number of walls as n. \\nSo my function call looks like :- solve(n - 1, n, cost, time).\\nNow I have 2 choices either to paint current wall or not.\\n1. If i paint current wall then I will paint the current wall and I can use my free worker for the time time[ind], so again we will ask function to give the minimum cost to paint the walls from 0 to ind - 1 and now the number of walls to be painted are wallsToPaint - time[ind] - 1. So function call looks like cost[ind] + solve(ind - 1, tasks - time[ind] - 1, cost, time).\\n2. If I do not paint the current wall the simply I will ask my function to find the minimum cost from the array 0 to ind - 1 and number of walls tot be painted remains same only. So my function call will look like solve(ind - 1, tasks, cost, time).\\nBase cases can be like if there are no tasks to do means no walls to be painted then cost would be 0 and if I ended with array with some walls to be painted then we will return some huge value as this is not possible.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n ^ 2)$$ as ind and number of walls to be painted can be at max the size of the array.\\n\\n- Space complexity:\\n$$O(n ^ 2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int ind, int task, vector<int> &c, vector<int> &t, vector<vector<int>> &dp){\\n        if(task <= 0) return 0;\\n        if(ind == -1) return 1e9;\\n        if(dp[ind][task] != -1) return dp[ind][task];\\n        return dp[ind][task] = min(c[ind] + solve(ind - 1, task - t[ind] - 1, c, t, dp), solve(ind - 1, task, c, t, dp));\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        return solve(n - 1, n, cost, time, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(int ind, int task, vector<int> &c, vector<int> &t, vector<vector<int>> &dp){\\n        if(task <= 0) return 0;\\n        if(ind == -1) return 1e9;\\n        if(dp[ind][task] != -1) return dp[ind][task];\\n        return dp[ind][task] = min(c[ind] + solve(ind - 1, task - t[ind] - 1, c, t, dp), solve(ind - 1, task, c, t, dp));\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        return solve(n - 1, n, cost, time, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655845,
                "title": "an-easy-way-to-understand-the-recurrence-relation-a-time-bank",
                "content": "We can think of a bank of time `timeBank`\\nEvery unit if time in this time bank enables us to use one free worker\\nEvery time we choose a paid worker for the task at index `i`, we deposit `time[i]` into this time bank and incur a cost `cost[i]`\\nEvery time we choose a free worker for the task at index `i`, we take `1` time unit from the time bank and incur a cost of `0`\\n\\nTherefore, the recurrence relation becomes\\n```\\nminCost(i, timeBank) =\\n\\tmin(cost[i] + minCost(i + 1, timeBank + timeBank[i]),\\n\\t\\tminCost(i + 1, timeBank - 1))\\n```\\n\\nThen you can use caching to convert this to top-down DP",
                "solutionTags": [],
                "code": "```\\nminCost(i, timeBank) =\\n\\tmin(cost[i] + minCost(i + 1, timeBank + timeBank[i]),\\n\\t\\tminCost(i + 1, timeBank - 1))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653228,
                "title": "rust-dp",
                "content": "```\\nimpl Solution {\\n    pub fn paint_walls(cost: Vec<i32>, time: Vec<i32>) -> i32 {\\n        let mut dp = vec![vec![-1; cost.len() * 2 + 1]; cost.len() + 1];\\n        Self::dfs(0, cost.len(), &cost, &time, &mut dp)\\n    }\\n\\n    fn dfs(i: usize, skip: usize, cost: &[i32], time: &[i32], dp: &mut [Vec<i32>]) -> i32 {\\n        if cost.len() * 2 - i <= skip {\\n            return 0;\\n        }\\n\\n        if i == cost.len() {\\n            return 1_000_000_000;\\n        }\\n\\n        if dp[i][skip] == -1 {\\n            dp[i][skip] = Self::dfs(i + 1, skip - 1, cost, time, dp).min(\\n                cost[i] + Self::dfs(i + 1, skip + time[i] as usize, cost, time, dp)\\n            );\\n        }\\n        dp[i][skip]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn paint_walls(cost: Vec<i32>, time: Vec<i32>) -> i32 {\\n        let mut dp = vec![vec![-1; cost.len() * 2 + 1]; cost.len() + 1];\\n        Self::dfs(0, cost.len(), &cost, &time, &mut dp)\\n    }\\n\\n    fn dfs(i: usize, skip: usize, cost: &[i32], time: &[i32], dp: &mut [Vec<i32>]) -> i32 {\\n        if cost.len() * 2 - i <= skip {\\n            return 0;\\n        }\\n\\n        if i == cost.len() {\\n            return 1_000_000_000;\\n        }\\n\\n        if dp[i][skip] == -1 {\\n            dp[i][skip] = Self::dfs(i + 1, skip - 1, cost, time, dp).min(\\n                cost[i] + Self::dfs(i + 1, skip + time[i] as usize, cost, time, dp)\\n            );\\n        }\\n        dp[i][skip]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3652430,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int func(vector<int>&cost , vector<int>&time, int i ,int curr ,vector<vector<int>>&dp){\\n                if(i>=cost.size()){\\n                        if(curr>=0){\\n                                return 0;\\n                        }\\n                        else{\\n                                return 1e9;\\n                        }\\n                }\\n                if(dp[i][cost.size()+curr]!=-1) return dp[i][cost.size()+curr];\\n                \\n                int ans=1e9;\\n                ans=min(ans , cost[i]+func(cost , time , i+1 ,curr+time[i] ,dp ));\\n                ans=min(ans , func(cost , time , i+1 ,curr-1 ,dp));\\n                \\n                return dp[i][cost.size()+curr]=ans;\\n        }\\n        \\n        \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n       int total=0;\\n            int n=cost.size();\\n            for(int i=0;i<n;i++){\\n                    total+=time[i];\\n            }\\n            vector<vector<int>>dp(cost.size() , vector<int>(cost.size()+total+2,-1));\\n            return func(cost , time ,0 ,  0 ,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int func(vector<int>&cost , vector<int>&time, int i ,int curr ,vector<vector<int>>&dp){\\n                if(i>=cost.size()){\\n                        if(curr>=0){\\n                                return 0;\\n                        }\\n                        else{\\n                                return 1e9;\\n                        }\\n                }\\n                if(dp[i][cost.size()+curr]!=-1) return dp[i][cost.size()+curr];\\n                \\n                int ans=1e9;\\n                ans=min(ans , cost[i]+func(cost , time , i+1 ,curr+time[i] ,dp ));\\n                ans=min(ans , func(cost , time , i+1 ,curr-1 ,dp));\\n                \\n                return dp[i][cost.size()+curr]=ans;\\n        }\\n        \\n        \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n       int total=0;\\n            int n=cost.size();\\n            for(int i=0;i<n;i++){\\n                    total+=time[i];\\n            }\\n            vector<vector<int>>dp(cost.size() , vector<int>(cost.size()+total+2,-1));\\n            return func(cost , time ,0 ,  0 ,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651770,
                "title": "pick-or-notpick",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int f(vector<int>& cost,vector<int>& time,int i,int left){\\n        if(left<=0)return 0;\\n        if(i>=cost.size())return 1e9;\\n        if(dp[i][left]!=-1)return dp[i][left];\\n\\n        int pick=cost[i]+f(cost,time,i+1,left-1-time[i]);\\n        int notpick=f(cost,time,i+1,left);\\n        return dp[i][left]=min(pick,notpick);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(cost,time,0,cost.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int f(vector<int>& cost,vector<int>& time,int i,int left){\\n        if(left<=0)return 0;\\n        if(i>=cost.size())return 1e9;\\n        if(dp[i][left]!=-1)return dp[i][left];\\n\\n        int pick=cost[i]+f(cost,time,i+1,left-1-time[i]);\\n        int notpick=f(cost,time,i+1,left);\\n        return dp[i][left]=min(pick,notpick);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(cost,time,0,cost.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651147,
                "title": "100-faster-c-memoization-dp",
                "content": "\\nIts quite evident from the question one has to use 0/1-Knapsack, because it tells you clearly either you chose one to paint for some cost(pick that one) or you do it for free (that is you not pick that one).\\n\\nat start take a variable t=0 which tells us that what is the time we have for the main painter to paint and for every unit of that time we can use the free painter to paint  a wall ::) \\n\\nHere when we pick we increament t by time[index] , \\n\\nand when we dont pick we decrement it by 1 as at that time we can use the free painter to paint the wall ..\\n\\nHere i used size of dp as (N*N+500) as the max size of \"time\" array is 500 and if we all chose to be painted by free painter it would lead t=-500 and would make the dp go out of bounds::) \\n\\n\\n\\n    long long solve(vector<int>& cost, vector<int>& time, int index, int t, vector<vector<int>>& dp) {\\n        int left=time.size()-index;\\n        if(t>=left) return 0;//this tells us that we have enough time that we can do the rest for free\\n        if (index >= time.size()) {\\n            if (t >= 0)return 0; //this is the case where we have reached the end of the array and we have a positive time\\n            else return 1e9;\\n        }\\n        if (dp[index][t+500] != -1)\\n            return dp[index][t+500];\\n        return dp[index][t+500] = min((long long)cost[index] + solve(cost, time, index + 1, t + time[index], dp),\\n                                  solve(cost, time, index + 1, t - 1, dp));\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = time.size();\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 501, -1));\\n        return solve(cost, time, 0, 0, dp);\\n    }\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\nIts quite evident from the question one has to use 0/1-Knapsack, because it tells you clearly either you chose one to paint for some cost(pick that one) or you do it for free (that is you not pick that one).\\n\\nat start take a variable t=0 which tells us that what is the time we have for the main painter to paint and for every unit of that time we can use the free painter to paint  a wall ::) \\n\\nHere when we pick we increament t by time[index] , \\n\\nand when we dont pick we decrement it by 1 as at that time we can use the free painter to paint the wall ..\\n\\nHere i used size of dp as (N*N+500) as the max size of \"time\" array is 500 and if we all chose to be painted by free painter it would lead t=-500 and would make the dp go out of bounds::) \\n\\n\\n\\n    long long solve(vector<int>& cost, vector<int>& time, int index, int t, vector<vector<int>>& dp) {\\n        int left=time.size()-index;\\n        if(t>=left) return 0;//this tells us that we have enough time that we can do the rest for free\\n        if (index >= time.size()) {\\n            if (t >= 0)return 0; //this is the case where we have reached the end of the array and we have a positive time\\n            else return 1e9;\\n        }\\n        if (dp[index][t+500] != -1)\\n            return dp[index][t+500];\\n        return dp[index][t+500] = min((long long)cost[index] + solve(cost, time, index + 1, t + time[index], dp),\\n                                  solve(cost, time, index + 1, t - 1, dp));\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = time.size();\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 501, -1));\\n        return solve(cost, time, 0, 0, dp);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3650859,
                "title": "cpp-top-down-bottom-up-approach-optimized-o-n-2-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter few dry runs i realised that question can not be solved greedyly , as cost and time ar not interrelated quantity.\\nfor high cost you can have lower time and vice versa.\\n\\nat first i tried binary search but it didnt worked.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter a while, I came up with this recursive function, \\nwhere one recursive state represented index upto which i have looked so far and how many walls are remaining to paint.\\n \\n```\\nIf at any point of time i stample upon the state where i have no walls\\nto paint, that\\'s our targeted state, we have painted entire wall.\\nso we require 0 cost to paint remaining wall.\\n```\\nOtherwise if you have reached end of the index before painting entire wall thats invalid state and to avoid such state return a large number( greater than 500*10^6  will work , I have used 1e9 > 5e8)\\n\\nplease upvote the solution if you like it, do comment if you have any suggestions\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  O(n^2)\\n\\n```\\nvariables used\\npaint -> Number of walls remaining to paint\\ni     -> Current index we are visiting, all previous indices have been visited.\\n```\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n  \\n    long fun( int i , vector<int> &cost ,int paint,  vector<int>& time, vector<vector<int>> & dp)\\n    {\\n      //  we just painted entire wall, so cost to paint such wall will be 0;\\n        if( paint <= 0) return 0;\\n      // we reached end of index but couldn\\'t paint the wall, so its undesired state.\\n        if( i >= cost.size()) return 1e9;\\n\\n      // if we have already encountered the current state\\n      if( dp[i][paint] != -1) return dp[i][paint];\\n\\n      // typical knapsack take and not_take functioinal calls\\n      // we didn\\'t considered curent index so that we can have choose any other optimal solution in future if such solution exists.\\n        long  not_take= fun( i+1, cost, paint,time, dp);\\n\\n        long  take = 0;\\n      // check if current index provides us the desired optimal answer\\n            take = fun( i+1, cost, paint - time[i] -1, time, dp) + cost[i];\\n        \\n      //return most optimal choice\\n        return  dp[i][paint] = min( take , not_take);\\n    }\\n\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp( n+1, vector<int>( n+1, -1));\\n     return fun(0 , cost, n, time, dp );\\n    }\\n};\\n```\\n## Bottom-UP Dp code\\n```\\nclass Solution {\\n    \\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<int> dp( n+1, 1e9);\\n\\n        dp[0] = 0;\\n       // base case if zero walls are remaining cost occured will be zero \\n\\n        for( int i = n-1; i >= 0;i--)\\n        {\\n            vector<int> cur(n+1, 1e9);\\n            cur[0] = 0;\\n            for( int j = n ;  j>= 0 ; j--)\\n            {\\n                cur[j] = dp[j];\\n\\n                if(j - time[i] -1 >= 0  )\\n               dp[j ]  = min(dp[j - time[i] -1] + cost[i], dp[j]);\\n               else if(time[i] + 1 > j)\\n               {\\n                   dp[j] = min(cost[i] , dp[j]);\\n               }\\n            }\\n        }\\n     return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nIf at any point of time i stample upon the state where i have no walls\\nto paint, that\\'s our targeted state, we have painted entire wall.\\nso we require 0 cost to paint remaining wall.\\n```\n```\\nvariables used\\npaint -> Number of walls remaining to paint\\ni     -> Current index we are visiting, all previous indices have been visited.\\n```\n```\\nclass Solution {\\n    private:\\n  \\n    long fun( int i , vector<int> &cost ,int paint,  vector<int>& time, vector<vector<int>> & dp)\\n    {\\n      //  we just painted entire wall, so cost to paint such wall will be 0;\\n        if( paint <= 0) return 0;\\n      // we reached end of index but couldn\\'t paint the wall, so its undesired state.\\n        if( i >= cost.size()) return 1e9;\\n\\n      // if we have already encountered the current state\\n      if( dp[i][paint] != -1) return dp[i][paint];\\n\\n      // typical knapsack take and not_take functioinal calls\\n      // we didn\\'t considered curent index so that we can have choose any other optimal solution in future if such solution exists.\\n        long  not_take= fun( i+1, cost, paint,time, dp);\\n\\n        long  take = 0;\\n      // check if current index provides us the desired optimal answer\\n            take = fun( i+1, cost, paint - time[i] -1, time, dp) + cost[i];\\n        \\n      //return most optimal choice\\n        return  dp[i][paint] = min( take , not_take);\\n    }\\n\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp( n+1, vector<int>( n+1, -1));\\n     return fun(0 , cost, n, time, dp );\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<int> dp( n+1, 1e9);\\n\\n        dp[0] = 0;\\n       // base case if zero walls are remaining cost occured will be zero \\n\\n        for( int i = n-1; i >= 0;i--)\\n        {\\n            vector<int> cur(n+1, 1e9);\\n            cur[0] = 0;\\n            for( int j = n ;  j>= 0 ; j--)\\n            {\\n                cur[j] = dp[j];\\n\\n                if(j - time[i] -1 >= 0  )\\n               dp[j ]  = min(dp[j - time[i] -1] + cost[i], dp[j]);\\n               else if(time[i] + 1 > j)\\n               {\\n                   dp[j] = min(cost[i] , dp[j]);\\n               }\\n            }\\n        }\\n     return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650853,
                "title": "python3-solution",
                "content": "e\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        dp = [0] + [inf] * n\\n        for c, t in zip(cost, time):\\n            for j in range(n, 0, -1):\\n                dp[j] = min(dp[j], dp[max(j - t - 1, 0)] + c)\\n        return dp[n]  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        dp = [0] + [inf] * n\\n        for c, t in zip(cost, time):\\n            for j in range(n, 0, -1):\\n                dp[j] = min(dp[j], dp[max(j - t - 1, 0)] + c)\\n        return dp[n]  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650836,
                "title": "python-top-down-dp-with-early-termination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA regular top-down DP with memorization shows \"memory limit exceeded\".\\n\\nTerminate early if:\\n(1) remaining time gained from the previous jobs is enough for the jobs left. \\n(2) overall time is negative even all jobs left will be finished by the paid painter.\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        post_sum = time[:]\\n        for i in range(n-2, -1, -1):\\n            post_sum[i] += post_sum[i+1]\\n        @cache\\n        def helper(i, remain_t):\\n            if i == n:\\n                return 0 if remain_t >= 0 else float(\\'inf\\')\\n            # Termination condition 1\\n            if remain_t >= n - i:\\n                return 0\\n            # Termination condition 2\\n            if remain_t + post_sum[i] < 0:\\n                return float(\\'inf\\')\\n            cost_paid = cost[i] + helper(i + 1, remain_t + time[i])\\n            cost_free = helper(i + 1, remain_t - 1)\\n            return min(cost_free, cost_paid)\\n        return helper(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        post_sum = time[:]\\n        for i in range(n-2, -1, -1):\\n            post_sum[i] += post_sum[i+1]\\n        @cache\\n        def helper(i, remain_t):\\n            if i == n:\\n                return 0 if remain_t >= 0 else float(\\'inf\\')\\n            # Termination condition 1\\n            if remain_t >= n - i:\\n                return 0\\n            # Termination condition 2\\n            if remain_t + post_sum[i] < 0:\\n                return float(\\'inf\\')\\n            cost_paid = cost[i] + helper(i + 1, remain_t + time[i])\\n            cost_free = helper(i + 1, remain_t - 1)\\n            return min(cost_free, cost_paid)\\n        return helper(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650810,
                "title": "knapsack-c-recursion-memoization",
                "content": "# Intuition\\nIt\\'s a variant of knapsack problem wehere we need to pick all the element with minimum cost.\\n\\nwe will make 2 recursive call one for with painter and other wth free cost painter\\n\\nHere in memoization if we use map we will get TLE as it take extra O(Log(n)) so we have to use vector for that we can use dp[i][n+j] \\n(n+j) is to avoid -ve time.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n(O(n * 3*n)) - ((n^2))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    int f(int i, int j, vector<int> &cost, vector<int> &time, vector<vector<int>> &dp){\\n        if(i>=n){\\n            if(j<0) return 1e9;\\n            return 0;\\n        }\\n\\n        if(dp[i][j+n]!=-1) return dp[i][j+n];\\n        \\n        int take=1e9;\\n        // by taking printer\\n        take= min(take,cost[i] + f(i+1,min(n-1,j+time[i]),cost,time,dp));\\n        // by free one\\n        take= min(take, f(i+1,j-1,cost,time,dp));\\n        \\n        return dp[i][j+n] = take;\\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        n=cost.size();\\n        int m=n*3;\\n        vector<vector<int>> dp(n+1,vector<int> (m,-1));\\n        return f(0,0,cost,time,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    int f(int i, int j, vector<int> &cost, vector<int> &time, vector<vector<int>> &dp){\\n        if(i>=n){\\n            if(j<0) return 1e9;\\n            return 0;\\n        }\\n\\n        if(dp[i][j+n]!=-1) return dp[i][j+n];\\n        \\n        int take=1e9;\\n        // by taking printer\\n        take= min(take,cost[i] + f(i+1,min(n-1,j+time[i]),cost,time,dp));\\n        // by free one\\n        take= min(take, f(i+1,j-1,cost,time,dp));\\n        \\n        return dp[i][j+n] = take;\\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        n=cost.size();\\n        int m=n*3;\\n        vector<vector<int>> dp(n+1,vector<int> (m,-1));\\n        return f(0,0,cost,time,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650734,
                "title": "memoization-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int left, int n, vector<int> &cost, vector<int> &time, vector<vector<int>> &dp) {\\n        if(left <= 0) return 0;\\n        if(i == n) return 1e9;\\n        if(dp[i][left] != -1) return dp[i][left];\\n        \\n        int notpick = dfs(i + 1, left, n, cost, time, dp);\\n        int pick = cost[i] + dfs(i + 1, left - time[i] - 1, n, cost, time, dp);\\n        \\n        return dp[i][left] = min(pick, notpick);\\n    }\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n, vector<int>(n + 1, -1));\\n        return dfs(0, n, n, cost, time, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int left, int n, vector<int> &cost, vector<int> &time, vector<vector<int>> &dp) {\\n        if(left <= 0) return 0;\\n        if(i == n) return 1e9;\\n        if(dp[i][left] != -1) return dp[i][left];\\n        \\n        int notpick = dfs(i + 1, left, n, cost, time, dp);\\n        int pick = cost[i] + dfs(i + 1, left - time[i] - 1, n, cost, time, dp);\\n        \\n        return dp[i][left] = min(pick, notpick);\\n    }\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n, vector<int>(n + 1, -1));\\n        return dfs(0, n, n, cost, time, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650632,
                "title": "cpp-dp-top-down-easy-approach-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngreedy doesn\\'t work as there can be some max time with max cost like one paid painter may cover all other but cost let\\'s say x but instead there can be another 2 painter who do same thing but in less cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe start from index 0 and we have variable id and t, id repesents which index we are and t represet how much time we have left before paid painter finish work. \\n\\nso we can decide to give current wall to paid or free painter.\\nif we go with paid painter we have to add cost[id] and we have to increse t to t + time[id] ad we can use this time in future. \\n\\nwe can manage this t to up to 500 but as we have offset of 500 it should be at max as 500+500.\\n\\nwe are using offset because we can also give this wall to free painter and we have to minus 1 from t. \\n\\nbut we can do this in start also which makes out t -1 which we can\\'t store in array so we use offset of 500.\\n\\nwhy 500 ? because we have at max 500 walls and in our dp we can have case where we assign all wall to free in that case t will be -500 so setting offset 500 is enough as -500+500 = 0 which is fine.\\n\\nand at last at id = n we will check if we have t - 500 >= 0 or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    const int inf = 1e9;\\n    int dp[505][1010];\\n    \\n    int run(int id, int t, int n, vector<int> &cost, vector<int> &time) {\\n        if(id == n) return t >= 500 ? 0 : inf;\\n        int &res = dp[id][t];\\n        if(res != -1) return res;\\n        \\n        res = inf;\\n        if(t - 500 >= n - id) {\\n            res = 0;\\n            return res;\\n        }\\n        \\n        res = min(res, run(id + 1, min(t + time[id], 1000), n, cost, time));\\n        if(res != inf) res += cost[id];\\n        res = min(res, run(id + 1, t - 1, n, cost, time));\\n        \\n        return res;\\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        memset(dp, -1, sizeof(dp));\\n        int res = run(0, 500, n, cost, time);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    const int inf = 1e9;\\n    int dp[505][1010];\\n    \\n    int run(int id, int t, int n, vector<int> &cost, vector<int> &time) {\\n        if(id == n) return t >= 500 ? 0 : inf;\\n        int &res = dp[id][t];\\n        if(res != -1) return res;\\n        \\n        res = inf;\\n        if(t - 500 >= n - id) {\\n            res = 0;\\n            return res;\\n        }\\n        \\n        res = min(res, run(id + 1, min(t + time[id], 1000), n, cost, time));\\n        if(res != inf) res += cost[id];\\n        res = min(res, run(id + 1, t - 1, n, cost, time));\\n        \\n        return res;\\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        memset(dp, -1, sizeof(dp));\\n        int res = run(0, 500, n, cost, time);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650628,
                "title": "c-dp-solution",
                "content": "**It was a simple variation of knapsack dp , we just needed to take care of overflowing indices**\\n```\\nclass Solution {\\npublic:\\n    long long dp[510][1020];\\n    int solve(int cnt,int idx, vector <int> &cost, vector <int> &t){\\n        if(idx == cost.size()){\\n            if(cnt < 0) return 1e9;\\n            return 0;\\n        }\\n        int n = cost.size();\\n        if(cnt <-500 || cnt > 500) return 1e9;\\n        if(dp[idx][505+cnt]!=-1) return dp[idx][505+cnt];\\n        int c = 1e9;\\n        c = min(c,cost[idx] + solve(cnt+t[idx],idx+1,cost,t));\\n        c = min(c,solve(cnt-1,idx+1,cost,t));\\n        return dp[idx][505+cnt] = c;\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& t) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,0,cost,t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[510][1020];\\n    int solve(int cnt,int idx, vector <int> &cost, vector <int> &t){\\n        if(idx == cost.size()){\\n            if(cnt < 0) return 1e9;\\n            return 0;\\n        }\\n        int n = cost.size();\\n        if(cnt <-500 || cnt > 500) return 1e9;\\n        if(dp[idx][505+cnt]!=-1) return dp[idx][505+cnt];\\n        int c = 1e9;\\n        c = min(c,cost[idx] + solve(cnt+t[idx],idx+1,cost,t));\\n        c = min(c,solve(cnt-1,idx+1,cost,t));\\n        return dp[idx][505+cnt] = c;\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& t) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,0,cost,t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650617,
                "title": "easy-java-solution-very-intuitive-for-beginners-upvote",
                "content": "# Intuition\\nThis approach is very similar to 0/1 knapsack.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n=cost.length;\\n        return (int)solve(cost,time,0,0,n,new Long[n][501]);\\n    }\\n    \\n    private long solve(int[] cost, int[] time, int index, int sum, int target, Long[][] dp) {\\n        //Base\\n        if(index == cost.length)\\n            return sum >= target ? 0 : Integer.MAX_VALUE;\\n        if(sum >= target)\\n            return 0;\\n        \\n        if(dp[index][sum] != null)\\n            return dp[index][sum];\\n        \\n        long taken=Integer.MAX_VALUE, not_taken=Integer.MAX_VALUE;\\n        taken = cost[index] + solve(cost,time,index+1,sum+time[index]+1,target,dp);\\n        not_taken = solve(cost,time,index+1,sum,target,dp);\\n        return dp[index][sum] = Math.min(taken,not_taken);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n=cost.length;\\n        return (int)solve(cost,time,0,0,n,new Long[n][501]);\\n    }\\n    \\n    private long solve(int[] cost, int[] time, int index, int sum, int target, Long[][] dp) {\\n        //Base\\n        if(index == cost.length)\\n            return sum >= target ? 0 : Integer.MAX_VALUE;\\n        if(sum >= target)\\n            return 0;\\n        \\n        if(dp[index][sum] != null)\\n            return dp[index][sum];\\n        \\n        long taken=Integer.MAX_VALUE, not_taken=Integer.MAX_VALUE;\\n        taken = cost[index] + solve(cost,time,index+1,sum+time[index]+1,target,dp);\\n        not_taken = solve(cost,time,index+1,sum,target,dp);\\n        return dp[index][sum] = Math.min(taken,not_taken);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650567,
                "title": "include-exclude-dp-java",
                "content": "```\\n    public int paintWalls(int[] cost, int[] time) {\\n        Pair[]p = new Pair[cost.length];\\n        for(int i=0;i<cost.length;i++)p[i] = new Pair(cost[i], time[i]);\\n        // Arrays.sort(p);\\n        HashMap<Integer, Integer>[]dp = new HashMap[time.length];\\n        for(int i=0;i<dp.length;i++)dp[i] = new HashMap<>();\\n        return solve(0, 0, p, dp);\\n    }\\n    \\n    public int solve(int i, int t, Pair[]p, HashMap<Integer, Integer>[]dp) {\\n        if(i>=p.length)return t<0 ? (int)(1e9+1) : 0;\\n        if(t>p.length-i)return 0;\\n        if(dp[i].containsKey(t)) return dp[i].get(t);\\n        int f1 = p[i].c + solve(i+1, t+p[i].t, p, dp);\\n        int f2 = solve(i+1, t-1, p, dp);\\n        int c = Math.min(f1, f2);\\n        dp[i].put(t, c);\\n        return c;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int paintWalls(int[] cost, int[] time) {\\n        Pair[]p = new Pair[cost.length];\\n        for(int i=0;i<cost.length;i++)p[i] = new Pair(cost[i], time[i]);\\n        // Arrays.sort(p);\\n        HashMap<Integer, Integer>[]dp = new HashMap[time.length];\\n        for(int i=0;i<dp.length;i++)dp[i] = new HashMap<>();\\n        return solve(0, 0, p, dp);\\n    }\\n    \\n    public int solve(int i, int t, Pair[]p, HashMap<Integer, Integer>[]dp) {\\n        if(i>=p.length)return t<0 ? (int)(1e9+1) : 0;\\n        if(t>p.length-i)return 0;\\n        if(dp[i].containsKey(t)) return dp[i].get(t);\\n        int f1 = p[i].c + solve(i+1, t+p[i].t, p, dp);\\n        int f2 = solve(i+1, t-1, p, dp);\\n        int c = Math.min(f1, f2);\\n        dp[i].put(t, c);\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102246,
                "title": "python3-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuitively, we\\'d like to have the paid painter paint cheaper walls for a long amount of time, allowing the free painter to paint the more expensive walls. It\\'s difficult to determine which walls to have the paid painter paint, so we use a dynamic programming algorithm to test most possibilities.\\n\\nThis algorithm relies on the idea that we can paint time[i] + 1 walls for cost[i] if we have the paint painter paint wall i. Thus, the total cost to paint n walls can be broken into the least of the costs to paint n-time[i] walls for each of the i walls plus cost[i]. Our base case would then be having 0 walls remaining, which would cost 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create our dp array with cost 0 for 0 walls remaining, and infinity for the rest (for now). As we loop through each of the walls, we update our dp array to see if the current best is better than dp[i-t-1] + c. This simulates calculating the least cost for n-time[i] walls at each point in the array. Once we\\'ve looped through all the walls, we\\'ll have the least cost for i walls in each of dp[i], so we simply return dp[n].\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity here is O(n^2) as we update every value [1-n] of dp for every wall (Beats 78.55%).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity here is simply O(n) to store our dp array (Beats 88.12%)\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for c, t in zip(cost, time):\\n            for i in range(n, 0, -1):\\n                dp[i] = min(dp[i], dp[max(i - t - 1, 0)] + c)\\n        return dp[n]  \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for c, t in zip(cost, time):\\n            for i in range(n, 0, -1):\\n                dp[i] = min(dp[i], dp[max(i - t - 1, 0)] + c)\\n        return dp[n]  \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091329,
                "title": "explained-in-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        dp=[[0] * (n + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, n + 1):\\n            dp[n][i] = inf\\n\\n\\n        # for i in range(n - 1, -1, -1):\\n        #     for remain_time_unit in range(1, n + 1): # at each ith, we have a n-complement remaining time units\\n        #         dont_paint = dp[i + 1][remain_time_unit] # the free painter does paint\\n\\n        #         time_budget = max(0, remain_time_unit - time[i] - 1) # let them together do the jobs [i+1...n], with our time budget at the leve of either zero, or remain_time_unit - time[i] - 1\\n        #         paint = cost[i] + dp[i + 1][time_budget]\\n\\n        #         dp[i][remain_time_unit] = min(paint, dont_paint)\\n        for i in range (n-1, -1, -1):\\n            for remain in range(1, n+1):\\n                dont_paint = dp[i+1][remain]\\n                v = max(0, remain - time[i] -1)\\n                paint = cost[i] + dp[i+1][v]\\n                dp[i][remain] = min(dont_paint, paint)\\n        return dp[0][n]\\n            \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        dp=[[0] * (n + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, n + 1):\\n            dp[n][i] = inf\\n\\n\\n        # for i in range(n - 1, -1, -1):\\n        #     for remain_time_unit in range(1, n + 1): # at each ith, we have a n-complement remaining time units\\n        #         dont_paint = dp[i + 1][remain_time_unit] # the free painter does paint\\n\\n        #         time_budget = max(0, remain_time_unit - time[i] - 1) # let them together do the jobs [i+1...n], with our time budget at the leve of either zero, or remain_time_unit - time[i] - 1\\n        #         paint = cost[i] + dp[i + 1][time_budget]\\n\\n        #         dp[i][remain_time_unit] = min(paint, dont_paint)\\n        for i in range (n-1, -1, -1):\\n            for remain in range(1, n+1):\\n                dont_paint = dp[i+1][remain]\\n                v = max(0, remain - time[i] -1)\\n                paint = cost[i] + dp[i+1][v]\\n                dp[i][remain] = min(dont_paint, paint)\\n        return dp[0][n]\\n            \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082505,
                "title": "java-dp-knapsack-space-optimized",
                "content": "# Code\\n```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length;\\n        \\n        int[][] dp = new int[2][n+1];\\n        Arrays.fill(dp[0], (int) 1e9);\\n        dp[0][n] = 0;\\n\\n        int res = Integer.MAX_VALUE;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int ii = i % 2;\\n                int iprev = (i+1) % 2;\\n                int take = cost[i-1]+dp[iprev][Math.min(j+time[i-1]+1, n)];\\n                int nottake = dp[iprev][j];\\n                dp[ii][j] = Math.min(take, nottake);\\n                if (j == 0) {\\n                    res = Math.min(res, dp[ii][0]);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length;\\n        \\n        int[][] dp = new int[2][n+1];\\n        Arrays.fill(dp[0], (int) 1e9);\\n        dp[0][n] = 0;\\n\\n        int res = Integer.MAX_VALUE;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int ii = i % 2;\\n                int iprev = (i+1) % 2;\\n                int take = cost[i-1]+dp[iprev][Math.min(j+time[i-1]+1, n)];\\n                int nottake = dp[iprev][j];\\n                dp[ii][j] = Math.min(take, nottake);\\n                if (j == 0) {\\n                    res = Math.min(res, dp[ii][0]);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034910,
                "title": "simple-logic-recursion-memoisation",
                "content": "**SIMPLE LOGIC ..**\\nIf I am doing a given job, in that case I am busy for a given period of time. \\nAs I am busy for the time[job] period, I can do other time[job] jobs also 1 extra current job have completed. \\nWith this logic the top down dp is designed an memoisation is done \\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n) \\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp ; \\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length ; \\n        dp = new int[n+1][n+1] ; \\n        for( int[] pd : dp ) Arrays.fill( pd , -1 ) ; \\n        int ans = solve( time , cost, n , n-1 ) ; \\n        return ans ; \\n\\n    }\\n\\n    int solve( int time[], int cost[], int job , int ind  ){\\n        \\n        if( job <= 0 ) return 0 ; \\n        if( ind < 0 ) return Integer.MAX_VALUE  ; \\n        if( dp[job][ind] != -1 ) return dp[job][ind] ; \\n        int a = solve( time , cost, job - time[ind] -1, ind -1  ) ; \\n        if( a != Integer.MAX_VALUE ){\\n            a += cost[ind] ; \\n        }\\n        int b = solve( time, cost, job, ind -1 ) ; \\n\\n\\n        int c =  Math.min( a , b ) ; \\n        dp[job][ind] = c ; \\n        return c ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp ; \\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length ; \\n        dp = new int[n+1][n+1] ; \\n        for( int[] pd : dp ) Arrays.fill( pd , -1 ) ; \\n        int ans = solve( time , cost, n , n-1 ) ; \\n        return ans ; \\n\\n    }\\n\\n    int solve( int time[], int cost[], int job , int ind  ){\\n        \\n        if( job <= 0 ) return 0 ; \\n        if( ind < 0 ) return Integer.MAX_VALUE  ; \\n        if( dp[job][ind] != -1 ) return dp[job][ind] ; \\n        int a = solve( time , cost, job - time[ind] -1, ind -1  ) ; \\n        if( a != Integer.MAX_VALUE ){\\n            a += cost[ind] ; \\n        }\\n        int b = solve( time, cost, job, ind -1 ) ; \\n\\n\\n        int c =  Math.min( a , b ) ; \\n        dp[job][ind] = c ; \\n        return c ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022448,
                "title": "greedy-does-not-and-dynamic-programming-solves-it",
                "content": "# Intuition\\nCommented in the code.\\n\\n# Approach\\nCommented in the code.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2) but can be converted to O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        // Greedy does not work\\n        // For example, if we sort (small to high) based on\\n        // cost of painting and start using paid painter from\\n        // smallest cost and use free painter from higer ones\\n        // For example if paid painter pains 1st smallest wall\\n        // with time 5, we paint 5 largest cost walls from the\\n        // end of the sorted walls.\\n\\n        // This does not work, as there can be a case, were\\n        // (assume) only 1 walls is remaning at the sorted index i=10\\n        // with cost is 100. But we have spent more than 100 cost\\n        // while using paid painter, but the 10th wall time was so huge that\\n        // with that time the free painter could have painted all remaining\\n        // n - 1 walls. This case will be missed in this greedy approach.\\n\\n\\n        vector<vector<int>> dp(510,vector<int>(510,1000000000));\\n        int n = cost.size();\\n\\n        // dp[i][j] is equal to\\n        // The min cost of painting j walls while considering [0 .. i] walls\\n        // to make selection of walls to be painted by the paid painter.\\n        // \\n        // Example: dp[i=6][j=10] Lets, see what it means!\\n        //\\n        // i = 6    i.e. [0 ..... 6] walls\\n        // j = 10   i.e walls to paint\\n        //\\n        // (How come this combination is even valid ? only [0 ... 6] i.e. 7 \\n        // walls to choose from But we need to paint j (10) walls ?)\\n        //\\n        // It is actually a valid case, because assume you selected 3rd wall \\n        // (while doing dp take/not take approach) and time of 3rd wall is 12.\\n        // It means, that while the paid painter is working on 3rd wall, free\\n        // painter can complete rest of 9 walls. \\n        // ( out of 10, actually free painter can complete 12, but we dont need\\n        // 12, we need only 9).\\n        //\\n        // To stretch this point even further is i = 0 and j = 100,\\n        // i.e. dp[0][100] the possible answer for this combination is x where\\n        // x is the cost taken by the pain painter to paint 0th wall with time >= 99\\n\\n\\n        // Approach:\\n        //\\n        // We will choose ith wall to be painted by paid painter or leave it\\n        // for free painter\\n\\n        // If we use ith wall to be painted by the paid painter with time 5\\n        // Then with that time 5, we can also complete 5 more walls\\n        // So basically choosing ith wall to be painted by the paid painter\\n        // actually painted 6 walls, so we only need to paint j - 6 walls now.\\n\\n\\n        // If we no walls to paint then cost is always 0.\\n        for(int i = 0;i<=n;i++) {\\n            dp[i][0 /*No more walls to paint */] = 0;\\n        }\\n\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                \\n                // Do not use paid painter for the ith wall.\\n                // Therefore this ith wall will be painted by free painter.\\n                // But when ?\\n                // When some wall will be painted by pain painter and the time\\n                // for that will be used by free painter to paint this ith wall.\\n                // (I mean in some interation of this double for loop)\\n                dp[i][j] = dp[i-1][j];\\n\\n                // Paint ith wall by the pain painter\\n                // Paid painter will paint 1 wall with time time[i-1] \\n                // (i is using 1 based indexing)\\n                // In that time[i-1] time, free painter can paint time[i-1] walls\\n                // So overall 1 + time[j-1] walls can be painted by painting \\n                // ith wall by the paid painter.\\n\\n\\n                // Case where we will have some more walls remaining to be painted\\n                if(time[i-1] + 1 <= j) {\\n                    // We still need to paint (j - time[i-1] - 1) walls.\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j - time[i-1] - 1] + cost[i-1]);\\n                }else {\\n                    // Free painter can finish all remaining wall\\n                    // Therefore, dp[i-1][no more walls remaining = 0]\\n                    // This j = 0 base cases needs initialization\\n                    // and thats what we did above.\\n                    dp[i][j] = min(dp[i][j], dp[i-1][0] + cost[i-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n][n];\\n\\n        // Note that, while using dp[i][] only dp[i-1][] is getting used\\n        // However while using dp[][j] .. many other j\\'s can be used\\n        // It means, we can drop the ith dimension and use only 1D array\\n        // While iterating for i = 5 (for example) dp[j] can be\\n        // updated using previous dp[j]\\n        // Here dp[j] means min cost to paint j walls.\\n        // I mean, on every i value, this dp[j] value will be updated.\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        // Greedy does not work\\n        // For example, if we sort (small to high) based on\\n        // cost of painting and start using paid painter from\\n        // smallest cost and use free painter from higer ones\\n        // For example if paid painter pains 1st smallest wall\\n        // with time 5, we paint 5 largest cost walls from the\\n        // end of the sorted walls.\\n\\n        // This does not work, as there can be a case, were\\n        // (assume) only 1 walls is remaning at the sorted index i=10\\n        // with cost is 100. But we have spent more than 100 cost\\n        // while using paid painter, but the 10th wall time was so huge that\\n        // with that time the free painter could have painted all remaining\\n        // n - 1 walls. This case will be missed in this greedy approach.\\n\\n\\n        vector<vector<int>> dp(510,vector<int>(510,1000000000));\\n        int n = cost.size();\\n\\n        // dp[i][j] is equal to\\n        // The min cost of painting j walls while considering [0 .. i] walls\\n        // to make selection of walls to be painted by the paid painter.\\n        // \\n        // Example: dp[i=6][j=10] Lets, see what it means!\\n        //\\n        // i = 6    i.e. [0 ..... 6] walls\\n        // j = 10   i.e walls to paint\\n        //\\n        // (How come this combination is even valid ? only [0 ... 6] i.e. 7 \\n        // walls to choose from But we need to paint j (10) walls ?)\\n        //\\n        // It is actually a valid case, because assume you selected 3rd wall \\n        // (while doing dp take/not take approach) and time of 3rd wall is 12.\\n        // It means, that while the paid painter is working on 3rd wall, free\\n        // painter can complete rest of 9 walls. \\n        // ( out of 10, actually free painter can complete 12, but we dont need\\n        // 12, we need only 9).\\n        //\\n        // To stretch this point even further is i = 0 and j = 100,\\n        // i.e. dp[0][100] the possible answer for this combination is x where\\n        // x is the cost taken by the pain painter to paint 0th wall with time >= 99\\n\\n\\n        // Approach:\\n        //\\n        // We will choose ith wall to be painted by paid painter or leave it\\n        // for free painter\\n\\n        // If we use ith wall to be painted by the paid painter with time 5\\n        // Then with that time 5, we can also complete 5 more walls\\n        // So basically choosing ith wall to be painted by the paid painter\\n        // actually painted 6 walls, so we only need to paint j - 6 walls now.\\n\\n\\n        // If we no walls to paint then cost is always 0.\\n        for(int i = 0;i<=n;i++) {\\n            dp[i][0 /*No more walls to paint */] = 0;\\n        }\\n\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                \\n                // Do not use paid painter for the ith wall.\\n                // Therefore this ith wall will be painted by free painter.\\n                // But when ?\\n                // When some wall will be painted by pain painter and the time\\n                // for that will be used by free painter to paint this ith wall.\\n                // (I mean in some interation of this double for loop)\\n                dp[i][j] = dp[i-1][j];\\n\\n                // Paint ith wall by the pain painter\\n                // Paid painter will paint 1 wall with time time[i-1] \\n                // (i is using 1 based indexing)\\n                // In that time[i-1] time, free painter can paint time[i-1] walls\\n                // So overall 1 + time[j-1] walls can be painted by painting \\n                // ith wall by the paid painter.\\n\\n\\n                // Case where we will have some more walls remaining to be painted\\n                if(time[i-1] + 1 <= j) {\\n                    // We still need to paint (j - time[i-1] - 1) walls.\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j - time[i-1] - 1] + cost[i-1]);\\n                }else {\\n                    // Free painter can finish all remaining wall\\n                    // Therefore, dp[i-1][no more walls remaining = 0]\\n                    // This j = 0 base cases needs initialization\\n                    // and thats what we did above.\\n                    dp[i][j] = min(dp[i][j], dp[i-1][0] + cost[i-1]);\\n                }\\n            }\\n        }\\n\\n        return dp[n][n];\\n\\n        // Note that, while using dp[i][] only dp[i-1][] is getting used\\n        // However while using dp[][j] .. many other j\\'s can be used\\n        // It means, we can drop the ith dimension and use only 1D array\\n        // While iterating for i = 5 (for example) dp[j] can be\\n        // updated using previous dp[j]\\n        // Here dp[j] means min cost to paint j walls.\\n        // I mean, on every i value, this dp[j] value will be updated.\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006557,
                "title": "easy-c-solution-with-easy-explanation",
                "content": "# Intuition\\nIt is very simple question.It is modified version of coin change problem.You had to take the current painter or not.You need to keep in track total walls painted.It will always be eqaul to time[i]+1 for ith element of array.Why ...because suppose i is 3 so for i = 1 to 3 same painter will be doing it.Plus for 3 busy time unit free painter will paint wall.So total walls painted is 4 for time i = 3.\\n\\n# Approach\\nWe will use take nottake concepts same as coin change problem and will use dp to reduce time complexity.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ \\n\\n- Space complexity:\\n $$O(n^2)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& cost, vector<int>& time,int n,int i,int p, vector<vector<int>>&dp){\\n      //treat p as walls left i will moniter index and n is total number of walls to be painted which is same as array size.\\n        if(p<=0) return 0;\\n        if(i>=n) return 1e9;\\n        int t =  time[i]+1;\\n        if(dp[i][p]!=-1)return dp[i][p];\\n        long long take = cost[i]+solve(cost,time,n,i+1,p-t,dp);\\n        long long nottake = solve(cost,time,n,i+1,p,dp);\\n        return dp[i][p] = min(take,nottake);  \\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n         int n = cost.size();\\n        vector<vector<int>> dp(n, vector<int>(n + 1, -1));\\n        return solve(cost,time,cost.size(),0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& cost, vector<int>& time,int n,int i,int p, vector<vector<int>>&dp){\\n      //treat p as walls left i will moniter index and n is total number of walls to be painted which is same as array size.\\n        if(p<=0) return 0;\\n        if(i>=n) return 1e9;\\n        int t =  time[i]+1;\\n        if(dp[i][p]!=-1)return dp[i][p];\\n        long long take = cost[i]+solve(cost,time,n,i+1,p-t,dp);\\n        long long nottake = solve(cost,time,n,i+1,p,dp);\\n        return dp[i][p] = min(take,nottake);  \\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n         int n = cost.size();\\n        vector<vector<int>> dp(n, vector<int>(n + 1, -1));\\n        return solve(cost,time,cost.size(),0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954279,
                "title": "0-1-knapsack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(vector<int>& cost, vector<int>& time, int ind, int wall_remain,vector<vector<int>>& dp){\\n        //base case\\n        if(wall_remain <= 0) return 0;\\n        if(ind>=cost.size()){\\n            return 2000000000;\\n        }\\n\\n        if(dp[ind][wall_remain] != -1) return dp[ind][wall_remain];\\n\\n        int take = cost[ind] + f(cost,time,ind+1, wall_remain-time[ind]-1,dp);\\n        int not_take = f(cost,time,ind+1,wall_remain,dp);\\n\\n        return dp[ind][wall_remain] = min(take,not_take);\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<vector<int>> dp(501, vector<int>(501,-1));\\n        return f(cost,time,0,cost.size(),dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(vector<int>& cost, vector<int>& time, int ind, int wall_remain,vector<vector<int>>& dp){\\n        //base case\\n        if(wall_remain <= 0) return 0;\\n        if(ind>=cost.size()){\\n            return 2000000000;\\n        }\\n\\n        if(dp[ind][wall_remain] != -1) return dp[ind][wall_remain];\\n\\n        int take = cost[ind] + f(cost,time,ind+1, wall_remain-time[ind]-1,dp);\\n        int not_take = f(cost,time,ind+1,wall_remain,dp);\\n\\n        return dp[ind][wall_remain] = min(take,not_take);\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<vector<int>> dp(501, vector<int>(501,-1));\\n        return f(cost,time,0,cost.size(),dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935710,
                "title": "easy-knapsack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // // map<vector<int>,int>dp;\\n    vector<vector<int>> dp;\\nint func(vector<int> &cost,vector<int> &time,int ind,int rem){\\n        \\n   if(rem<=0)return 0;\\n\\n        if(ind==cost.size()){\\n            return 1e9+7;\\n        }\\n    \\n    // if(dp.count({ind,taken,busy}))return dp[{ind,taken,busy}];\\n    if(dp[ind][rem]!=-1)return dp[ind][rem];        \\n        int  res=INT_MAX;\\n        \\n        res=min(res,cost[ind]+func(cost,time,ind+1,rem-time[ind]-1));\\n        res=min(res,func(cost,time,ind+1,rem));\\n        \\n        return dp[ind][rem]=res;\\n        \\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        // dp.clear();\\n        dp.resize(cost.size()+1,vector<int> (cost.size()+1,-1));\\n        return func(cost,time,0,cost.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // // map<vector<int>,int>dp;\\n    vector<vector<int>> dp;\\nint func(vector<int> &cost,vector<int> &time,int ind,int rem){\\n        \\n   if(rem<=0)return 0;\\n\\n        if(ind==cost.size()){\\n            return 1e9+7;\\n        }\\n    \\n    // if(dp.count({ind,taken,busy}))return dp[{ind,taken,busy}];\\n    if(dp[ind][rem]!=-1)return dp[ind][rem];        \\n        int  res=INT_MAX;\\n        \\n        res=min(res,cost[ind]+func(cost,time,ind+1,rem-time[ind]-1));\\n        res=min(res,func(cost,time,ind+1,rem));\\n        \\n        return dp[ind][rem]=res;\\n        \\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        // dp.clear();\\n        dp.resize(cost.size()+1,vector<int> (cost.size()+1,-1));\\n        return func(cost,time,0,cost.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918714,
                "title": "easy-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int pos, vector<int>& cost, vector<int>& time, int walls, vector<vector<int>> &dp) {\\n        if(walls >= cost.size()) {\\n            return 0;\\n        }\\n        if(pos == cost.size()) {\\n            return 1000000000;\\n        }\\n        if(dp[pos][walls] != -1) return dp[pos][walls];\\n\\n        return dp[pos][walls] = min(solve(pos + 1, cost, time, walls, dp),\\n         cost[pos] + solve(pos + 1, cost, time, walls + 1 + time[pos], dp)\\n         );\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<vector<int>> dp(cost.size(), vector<int>(cost.size(), -1));\\n        return solve(0, cost, time, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int pos, vector<int>& cost, vector<int>& time, int walls, vector<vector<int>> &dp) {\\n        if(walls >= cost.size()) {\\n            return 0;\\n        }\\n        if(pos == cost.size()) {\\n            return 1000000000;\\n        }\\n        if(dp[pos][walls] != -1) return dp[pos][walls];\\n\\n        return dp[pos][walls] = min(solve(pos + 1, cost, time, walls, dp),\\n         cost[pos] + solve(pos + 1, cost, time, walls + 1 + time[pos], dp)\\n         );\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<vector<int>> dp(cost.size(), vector<int>(cost.size(), -1));\\n        return solve(0, cost, time, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905289,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(int ind,int walls,vector<int>&cost,vector<int>&time,vector<vector<int>>&dp)\\n    {\\n        if (walls<=0) return 0;\\n       if (ind==time.size()) return 1e9;\\n       if (dp[ind][walls]!=-1) return dp[ind][walls];\\n       int pick=cost[ind]+rec(ind+1,walls-time[ind]-1,cost,time,dp);\\n       int notPick=rec(ind+1,walls,cost,time,dp);\\n       return dp[ind][walls]=min(pick,notPick);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n        return rec(0,n,cost,time,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(int ind,int walls,vector<int>&cost,vector<int>&time,vector<vector<int>>&dp)\\n    {\\n        if (walls<=0) return 0;\\n       if (ind==time.size()) return 1e9;\\n       if (dp[ind][walls]!=-1) return dp[ind][walls];\\n       int pick=cost[ind]+rec(ind+1,walls-time[ind]-1,cost,time,dp);\\n       int notPick=rec(ind+1,walls,cost,time,dp);\\n       return dp[ind][walls]=min(pick,notPick);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n        return rec(0,n,cost,time,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899012,
                "title": "0-1-knapsap-in-java-2d-memo",
                "content": "# Intuition\\nSort the indexes of walls based on cost. Then implement simple knapsap solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n       \\n        int n = cost.length;\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return cost[0];\\n        }\\n        List<Integer> sortedIndices = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            sortedIndices.add(i);\\n        }\\n        sortedIndices.sort(Comparator.comparingInt(a -> cost[a]));\\n        int[][] dp = new int[n + 1][n];\\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = 999999999;\\n            }\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 int currentCostIndex = sortedIndices.get(i - 1);\\n                int currentCost = cost[currentCostIndex];\\n                int currentMaxWallsPaint = time[currentCostIndex] + 1;\\n                int minWallsToBePaintAfterIncludingCurrentWall = j - currentMaxWallsPaint + 1;\\n                int newCost = currentCost;\\n                if (minWallsToBePaintAfterIncludingCurrentWall < 0) {\\n                    minWallsToBePaintAfterIncludingCurrentWall = 0;\\n                }\\n                if (minWallsToBePaintAfterIncludingCurrentWall != 0) {\\n                    newCost = newCost + dp[i - 1][minWallsToBePaintAfterIncludingCurrentWall - 1];\\n                }\\n                dp[i][j] = Math.min(dp[i - 1][j], newCost);\\n            }\\n        }\\n\\n        return dp[n][n - 1]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n       \\n        int n = cost.length;\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return cost[0];\\n        }\\n        List<Integer> sortedIndices = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            sortedIndices.add(i);\\n        }\\n        sortedIndices.sort(Comparator.comparingInt(a -> cost[a]));\\n        int[][] dp = new int[n + 1][n];\\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = 999999999;\\n            }\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 int currentCostIndex = sortedIndices.get(i - 1);\\n                int currentCost = cost[currentCostIndex];\\n                int currentMaxWallsPaint = time[currentCostIndex] + 1;\\n                int minWallsToBePaintAfterIncludingCurrentWall = j - currentMaxWallsPaint + 1;\\n                int newCost = currentCost;\\n                if (minWallsToBePaintAfterIncludingCurrentWall < 0) {\\n                    minWallsToBePaintAfterIncludingCurrentWall = 0;\\n                }\\n                if (minWallsToBePaintAfterIncludingCurrentWall != 0) {\\n                    newCost = newCost + dp[i - 1][minWallsToBePaintAfterIncludingCurrentWall - 1];\\n                }\\n                dp[i][j] = Math.min(dp[i - 1][j], newCost);\\n            }\\n        }\\n\\n        return dp[n][n - 1]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865933,
                "title": "rust-top-down-dp",
                "content": "# Code\\n```rust\\npub struct DP {\\n    vec: Vec<(usize, usize)>,\\n    n: usize, m: usize,\\n\\n    memo: Vec<Vec<Option<Option<usize>>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(vec: Vec<(usize, usize)>) -> Self {\\n        let n = vec.len();\\n        let m = n * 2;\\n\\n        let memo = vec![vec![None; m + 1]; n + 1];\\n        \\n        Self { vec, n, m, memo }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, i: usize, j: usize) -> Option<usize> {\\n        if i > self.n { return None; }\\n        if j > self.m { return None; }\\n\\n        if let Some(ret) = self.memo[i][j] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(i, j);\\n        self.memo[i][j] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, i: usize, j: usize) -> Option<usize> {\\n        if i >= self.n {\\n            if j < self.n { return None; } // negative\\n            return Some(usize::MIN);\\n        } // no wall\\n\\n        if i + j >= self.n * 2 {\\n            return Some(usize::MIN);\\n        } // definitely enough\\n\\n        let (t, weight) = self.vec[i];\\n\\n        let mut ret = None;\\n        { // take current wall\\n            let j_next = (j + t).min(self.m);\\n            if let Some(_ret) = self.solve(i + 1, j_next) {\\n                ret = Some(ret.unwrap_or(usize::MAX).min(_ret + weight));\\n            }\\n        }\\n        { // skip current wall\\n            if let Some(_ret) = self.solve(i + 1, j - 1) {\\n                ret = Some(ret.unwrap_or(usize::MAX).min(_ret));\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn paint_walls(cost: Vec<i32>, time: Vec<i32>) -> i32 {\\n        // Why are we even using the paid painter??\\n        // Just hire the free painter, they are better at the job.\\n\\n        let vec = time.into_iter()\\n            .zip(cost.into_iter())\\n            .map(|(e0, e1)| (e0 as usize, e1 as usize))\\n            .collect::<Vec<_>>();\\n        let n = vec.len();\\n\\n        let mut dp = DP::new(vec);\\n        dp.solve(usize::MIN, n).unwrap() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\npub struct DP {\\n    vec: Vec<(usize, usize)>,\\n    n: usize, m: usize,\\n\\n    memo: Vec<Vec<Option<Option<usize>>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(vec: Vec<(usize, usize)>) -> Self {\\n        let n = vec.len();\\n        let m = n * 2;\\n\\n        let memo = vec![vec![None; m + 1]; n + 1];\\n        \\n        Self { vec, n, m, memo }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, i: usize, j: usize) -> Option<usize> {\\n        if i > self.n { return None; }\\n        if j > self.m { return None; }\\n\\n        if let Some(ret) = self.memo[i][j] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(i, j);\\n        self.memo[i][j] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, i: usize, j: usize) -> Option<usize> {\\n        if i >= self.n {\\n            if j < self.n { return None; } // negative\\n            return Some(usize::MIN);\\n        } // no wall\\n\\n        if i + j >= self.n * 2 {\\n            return Some(usize::MIN);\\n        } // definitely enough\\n\\n        let (t, weight) = self.vec[i];\\n\\n        let mut ret = None;\\n        { // take current wall\\n            let j_next = (j + t).min(self.m);\\n            if let Some(_ret) = self.solve(i + 1, j_next) {\\n                ret = Some(ret.unwrap_or(usize::MAX).min(_ret + weight));\\n            }\\n        }\\n        { // skip current wall\\n            if let Some(_ret) = self.solve(i + 1, j - 1) {\\n                ret = Some(ret.unwrap_or(usize::MAX).min(_ret));\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn paint_walls(cost: Vec<i32>, time: Vec<i32>) -> i32 {\\n        // Why are we even using the paid painter??\\n        // Just hire the free painter, they are better at the job.\\n\\n        let vec = time.into_iter()\\n            .zip(cost.into_iter())\\n            .map(|(e0, e1)| (e0 as usize, e1 as usize))\\n            .collect::<Vec<_>>();\\n        let n = vec.len();\\n\\n        let mut dp = DP::new(vec);\\n        dp.solve(usize::MIN, n).unwrap() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855511,
                "title": "python-a-straightforward-memoized-solution",
                "content": "# Intuition\\nThe choice to make at each wall is whether or not we place the paid painter on it. \\n\\nIf we do, then we can skip **time[i]** walls. Then we repeat the process, finding another wall to place a paid painter on, until all walls have been either covered or skipped.\\n\\n# Approach\\nThe recursive subproblem is therefore: how many walls do we still need to paint. We have a valid solution when the number of walls we need to paint becomes 0. If it is greater than zero, this is an incorrect placement and we must return infinity cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) since n is at most 500 and idx is at most 500\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        @lru_cache(None)\\n        def recurse(n, idx):\\n            if idx == len(time)-1 and n-time[idx]-1 > 0:\\n                return float(\\'inf\\')\\n            elif idx >= len(time) and n > 0:\\n                return float(\\'inf\\')\\n            if n <= 0:\\n                return 0\\n            \\n            res = min(recurse(n,idx+1), cost[idx] + recurse(n-time[idx]-1, idx+1))\\n\\n            return res\\n        return recurse(len(time), 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        @lru_cache(None)\\n        def recurse(n, idx):\\n            if idx == len(time)-1 and n-time[idx]-1 > 0:\\n                return float(\\'inf\\')\\n            elif idx >= len(time) and n > 0:\\n                return float(\\'inf\\')\\n            if n <= 0:\\n                return 0\\n            \\n            res = min(recurse(n,idx+1), cost[idx] + recurse(n-time[idx]-1, idx+1))\\n\\n            return res\\n        return recurse(len(time), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846771,
                "title": "simple-python-solution",
                "content": "# Intuition\\nDP with cache. Walls don\\'t need to be painted in order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n^2)\\n\\n- Space complexity:\\n- O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n\\n        @cache\\n        def dp(i, free_slots):\\n            if i == n and free_slots < 0:\\n                return inf\\n            \\n            res1 = cost[i] + (dp(free_slots + time[i], i + 1) if free_slots + time[i] + i + 1 < n else 0)\\n            res2 = dp(free_slots - 1, i + 1)\\n            return min(res1, res2)\\n        \\n        res = dp(0, 0)\\n        return res\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n\\n        @cache\\n        def dp(i, free_slots):\\n            if i == n and free_slots < 0:\\n                return inf\\n            \\n            res1 = cost[i] + (dp(free_slots + time[i], i + 1) if free_slots + time[i] + i + 1 < n else 0)\\n            res2 = dp(free_slots - 1, i + 1)\\n            return min(res1, res2)\\n        \\n        res = dp(0, 0)\\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789955,
                "title": "o-n-2-dp",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, costs: List[int], times: List[int]) -> int:\\n        n = len(costs)\\n        inf = int(1e9)\\n        @lru_cache(None)\\n        # Return the minimum cost to paint from idx-th wall to the end, assuming there are `freetime` times for the free painter to work\\n        def f(idx: int, freetime: int) -> int:\\n            if idx == n:\\n                return inf if freetime < 0 else 0\\n            remain = (n - 1) - (idx) + 1\\n            if freetime >= remain:\\n                return 0\\n            cost, time = costs[idx], times[idx]\\n            if_pay_to_paint = cost + f(idx + 1, freetime + time)\\n            if_nopay_to_paint = f(idx + 1, freetime - 1)\\n            return min(if_pay_to_paint, if_nopay_to_paint)\\n        return f(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, costs: List[int], times: List[int]) -> int:\\n        n = len(costs)\\n        inf = int(1e9)\\n        @lru_cache(None)\\n        # Return the minimum cost to paint from idx-th wall to the end, assuming there are `freetime` times for the free painter to work\\n        def f(idx: int, freetime: int) -> int:\\n            if idx == n:\\n                return inf if freetime < 0 else 0\\n            remain = (n - 1) - (idx) + 1\\n            if freetime >= remain:\\n                return 0\\n            cost, time = costs[idx], times[idx]\\n            if_pay_to_paint = cost + f(idx + 1, freetime + time)\\n            if_nopay_to_paint = f(idx + 1, freetime - 1)\\n            return min(if_pay_to_paint, if_nopay_to_paint)\\n        return f(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788576,
                "title": "two-line-o-n-2-dp-in-python-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first solution to this problem is to find the minimum cost to hire the paid painter to paint `k` walls that have a total time of `t`. \\nThe complexity of this algorithm is $$O(500 \\\\times N^3)$$ that cannot pass the testcases. As a result, a alternative idea, also a DP solution, comes to my brain. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem can be solved with DP by determining the painter of each wall. The DP is two dimensional. One dimension is the current wall, the other dimension is the time used so far. We assign `i`th wall to the free painter without cost but spending one time unit; we assign `i`th wall to the paid painter with the `cost[i]` but earning `time[i]` time units. When all the walls are painted, we need to check if the answer is valid. That is, the total used (earned) time should not be less than the time units spending for the free painter. \\n\\nThe total used (earned) time units can be as large as $$500^2$$. However, all the time can be spent to the free painter does not exceed $$N \\\\le 500$$. So the upper bound of earned time units is only $$N$$. This is the key to this problem that reduces a significant amount of solution space, resulting the complexity of $$O(N^2)$$. \\n\\nMy solution is implemented in the top-down manner (memoization) as simple as adding the magic `@cache` decorator.\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        @cache \\n        def dp(i, t):\\n            if i >= n: return 0 if t >= 0 else inf\\n            return min(dp(i+1, t-1), dp(i+1, min(n - i, t+time[i])) + cost[i])\\n        return dp(0, 0)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first solution to this problem is to find the minimum cost to hire the paid painter to paint `k` walls that have a total time of `t`. \\nThe complexity of this algorithm is $$O(500 \\\\times N^3)$$ that cannot pass the testcases. As a result, a alternative idea, also a DP solution, comes to my brain. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem can be solved with DP by determining the painter of each wall. The DP is two dimensional. One dimension is the current wall, the other dimension is the time used so far. We assign `i`th wall to the free painter without cost but spending one time unit; we assign `i`th wall to the paid painter with the `cost[i]` but earning `time[i]` time units. When all the walls are painted, we need to check if the answer is valid. That is, the total used (earned) time should not be less than the time units spending for the free painter. \\n\\nThe total used (earned) time units can be as large as $$500^2$$. However, all the time can be spent to the free painter does not exceed $$N \\\\le 500$$. So the upper bound of earned time units is only $$N$$. This is the key to this problem that reduces a significant amount of solution space, resulting the complexity of $$O(N^2)$$. \\n\\nMy solution is implemented in the top-down manner (memoization) as simple as adding the magic `@cache` decorator.\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        @cache \\n        def dp(i, t):\\n            if i >= n: return 0 if t >= 0 else inf\\n            return min(dp(i+1, t-1), dp(i+1, min(n - i, t+time[i])) + cost[i])\\n        return dp(0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 3768853,
                "title": "easy-c-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n      \\n  int helper(vector<int>&cost, vector<int>&time, int curr, int wallremaining, vector<vector<int>>&dp){\\n    if(wallremaining<=0) return 0;\\n    if(curr >= cost.size()) return 2000000000;\\n    \\n   \\n    \\n    if(dp[curr][wallremaining]!=-1) return dp[curr][wallremaining];\\n    \\n    int take = cost[curr]+helper(cost,time,curr+1,wallremaining-time[curr]-1,dp);\\n    int nottake = helper(cost,time,curr+1, wallremaining,dp);\\n    \\n    return dp[curr][wallremaining] = min(take,nottake);\\n  }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n    //memset(dp,-1,sizeof(dp));\\n      int n = cost.size();\\n   vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n      \\n      return helper(cost,time,0,cost.size(),dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n      \\n  int helper(vector<int>&cost, vector<int>&time, int curr, int wallremaining, vector<vector<int>>&dp){\\n    if(wallremaining<=0) return 0;\\n    if(curr >= cost.size()) return 2000000000;\\n    \\n   \\n    \\n    if(dp[curr][wallremaining]!=-1) return dp[curr][wallremaining];\\n    \\n    int take = cost[curr]+helper(cost,time,curr+1,wallremaining-time[curr]-1,dp);\\n    int nottake = helper(cost,time,curr+1, wallremaining,dp);\\n    \\n    return dp[curr][wallremaining] = min(take,nottake);\\n  }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n    //memset(dp,-1,sizeof(dp));\\n      int n = cost.size();\\n   vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n      \\n      return helper(cost,time,0,cost.size(),dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742428,
                "title": "dp-with-simple-eplanation-knap-sack-simple-approach-c",
                "content": "# Intuition\\nThe task was to find minimum cost to paint all the walls by observing all the possible combinations so my first thought was using Dynamic Programming\\n\\n# Approach\\nYou can observe one thing here that we are available with two kind of painters one takes cost[i] money and spends time[i] time to paint the i th wall , and other who takes 1 unit of time and 0 money to paint any wall and this 2nd painter can be used while 1st painter is busy.\\n\\nSo in other words if painter 1(P_1) paints a wall by taking 4 units of money and spending 12 units of time then in those 12 units our 2nd free painter, i.e. painter 2(P_2) can paint other 12 walls so again one can say that\\n\\nby spending 4 units of money you painted 12(by free painter) + 1(by paid painter) walls \\n\\nso by spending cost[i] you can paint time[i]+1 walls in that cost.\\n\\n\\nKeeping this in mind in my algorithm I am picking walls for paid painter (P_1) , and subtracting total walls I have painted by picking that particular wall so if I am picking i th wall then I am painting \\ntime[i]+1 walls and I am keeping count of total walls need to be painted through variable \"t\" in my recursive function. In this process and when \\nt==0 we have painted all walls\\n\\ni.e. when t==0 then all walls are painted return 0\\n\\nand if i==0 when we have finished picking walls for paid painter and still t>0 it means all walls are not painted therefore return INT_MAX (for not picking this case).\\n\\n# Complexity\\n- Time complexity:\\nO[n^2]\\n\\n- Space complexity:\\nO[(n)*(sum of time of all walls)]\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int min_cost(vector<int>& cost, vector<int>& time, int i, int n, vector<vector<int>>& dp)\\n    {\\n        if(n==0)\\n        {\\n            return dp[i][n]=0;\\n        }\\n        else if(i==0 && n>0)\\n        {\\n            return dp[i][n]=INT_MAX-2500000;\\n        }\\n\\n        if(dp[i][n]!=-1)\\n        {\\n            return dp[i][n];\\n        }\\n\\n        int val_sub=min(n, time[i-1]+1);\\n\\n        int ans1=cost[i-1]+min_cost(cost, time, i-1, n-val_sub, dp);\\n        int ans2=min_cost(cost, time, i-1, n, dp);\\n\\n        return dp[i][n]=min(ans1, ans2);\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) \\n    {\\n        vector<vector<int>> dp(cost.size()+2, vector<int>(cost.size()+2, -1));\\n        return min_cost(cost, time, cost.size(), cost.size(), dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int min_cost(vector<int>& cost, vector<int>& time, int i, int n, vector<vector<int>>& dp)\\n    {\\n        if(n==0)\\n        {\\n            return dp[i][n]=0;\\n        }\\n        else if(i==0 && n>0)\\n        {\\n            return dp[i][n]=INT_MAX-2500000;\\n        }\\n\\n        if(dp[i][n]!=-1)\\n        {\\n            return dp[i][n];\\n        }\\n\\n        int val_sub=min(n, time[i-1]+1);\\n\\n        int ans1=cost[i-1]+min_cost(cost, time, i-1, n-val_sub, dp);\\n        int ans2=min_cost(cost, time, i-1, n, dp);\\n\\n        return dp[i][n]=min(ans1, ans2);\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) \\n    {\\n        vector<vector<int>> dp(cost.size()+2, vector<int>(cost.size()+2, -1));\\n        return min_cost(cost, time, cost.size(), cost.size(), dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739477,
                "title": "dp-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt was initially challenging to determine the impact of hiring a paid painter. However, an idea came to me. For a paid painter, if the cost is 10 dollars and it takes 3 hours, it means that by paying 10 dollars, four walls can be painted. So, if we add 1 to the time, it represents the number of walls that can be painted. Based on this idea, we can use a straightforward dynamic programming (DP) approach with the following format: dp[i] = min(dp[i], dp[i - time - 1] + cost).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(time)\\n        for i in range(n):\\n            time[i] += 1\\n        ct = zip(cost, time)\\n        dp = [math.inf]*(n + 1)\\n        dp[0] = 0\\n        for ele in ct:\\n            next_dp = dp[:]\\n            for i in range(n + 1):\\n                if dp[i] != math.inf:\\n                    next_dp[min(n, i + ele[1])] = min(next_dp[min(n, i + ele[1])], dp[i] + ele[0])\\n            dp = next_dp\\n        return dp[n]\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(time)\\n        for i in range(n):\\n            time[i] += 1\\n        ct = zip(cost, time)\\n        dp = [math.inf]*(n + 1)\\n        dp[0] = 0\\n        for ele in ct:\\n            next_dp = dp[:]\\n            for i in range(n + 1):\\n                if dp[i] != math.inf:\\n                    next_dp[min(n, i + ele[1])] = min(next_dp[min(n, i + ele[1])], dp[i] + ele[0])\\n            dp = next_dp\\n        return dp[n]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699853,
                "title": "0-1-knapsack-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically a few things:\\n1) Instead of sorting the array greedily to find the min cost walls first for the paid painter to paint ,try to think which walls you should choose to get the min cost . \\nKeep in mind that when you choose to get the i wall painted by paid painter at cost cost[i], \\nNo. of remaining walls=n-time[i]-1;\\nn=total walls\\nWhile the paid painter is painting i wall , meanwhile free painter can paint time[i] walls at 0 cost .Minus one for the current wall.\\n2. At each wall, you have 2 options to paint it using paid painter or not. \\n3. Now skip it/take it dp approach with 2 arrays would work\\n4. At each index , walls remaining value changes so initialize dp with dimensions[n+1][n+1]\\n5. We return 1000000000 when i>=n as that means we have still some walls remaining which are not painted . Hence we return max value of cost[i].\\n\\n# Code\\n```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n=cost.length;\\n        int[][] dp=new int[n+1][n+1];\\n        return solve(n,cost,0,time,dp);\\n    }\\n    public int solve(int wallsrem,int[] cost,int idx,int[] time,int[][] dp){\\n        if(wallsrem<=0) return 0;\\n        if(idx>=cost.length) return 1000000000;\\n        if(dp[idx][wallsrem]!=0){\\n            return dp[idx][wallsrem];\\n        }\\n        int skip=solve(wallsrem,cost,idx+1,time,dp);\\n        int take=cost[idx]+solve(wallsrem-time[idx]-1,cost,idx+1,time,dp);\\n        dp[idx][wallsrem]=Math.min(skip,take);\\n        return dp[idx][wallsrem];\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/68577b4a-fc3d-4847-8d97-1f85517d63c7_1688117066.210075.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n=cost.length;\\n        int[][] dp=new int[n+1][n+1];\\n        return solve(n,cost,0,time,dp);\\n    }\\n    public int solve(int wallsrem,int[] cost,int idx,int[] time,int[][] dp){\\n        if(wallsrem<=0) return 0;\\n        if(idx>=cost.length) return 1000000000;\\n        if(dp[idx][wallsrem]!=0){\\n            return dp[idx][wallsrem];\\n        }\\n        int skip=solve(wallsrem,cost,idx+1,time,dp);\\n        int take=cost[idx]+solve(wallsrem-time[idx]-1,cost,idx+1,time,dp);\\n        dp[idx][wallsrem]=Math.min(skip,take);\\n        return dp[idx][wallsrem];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692820,
                "title": "c-dp-knap-sack",
                "content": "it\\'s little different than knap sack\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> c;\\n    vector<int> d;\\n    int sum=0;\\n    int n;\\n    vector<vector<int>> dp;\\n    \\n    int solve(int idx, int left)\\n    {\\n        \\n        if(left<=0) return 0;\\n        if(idx>=n) return INT_MAX-1000002; // can also return the sum\\n        \\n        \\n        //the only difference here than knap sack is their we needed to check how much weight (here left) we can take and we can only include \\n        //when left over weight is non negative but here their is no restrictions just \\n        // try To cover left amount of time even negative can be possible just try to minimise the weight\\n        if(dp[idx][left]!=-1) return dp[idx][left];\\n        int dont= solve(idx+1, left);\\n        int does= solve(idx+1,left-d[idx]-1)+c[idx];\\n        \\n        return dp[idx][left]=min(dont, does);\\n        \\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n       \\n        c=cost;\\n        d=time;\\n        n=c.size();\\n        dp.resize(n+1, vector<int>(n+1,-1));\\n        for(auto i:c) sum+=i;\\n\\n        return solve(0,n);\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> c;\\n    vector<int> d;\\n    int sum=0;\\n    int n;\\n    vector<vector<int>> dp;\\n    \\n    int solve(int idx, int left)\\n    {\\n        \\n        if(left<=0) return 0;\\n        if(idx>=n) return INT_MAX-1000002; // can also return the sum\\n        \\n        \\n        //the only difference here than knap sack is their we needed to check how much weight (here left) we can take and we can only include \\n        //when left over weight is non negative but here their is no restrictions just \\n        // try To cover left amount of time even negative can be possible just try to minimise the weight\\n        if(dp[idx][left]!=-1) return dp[idx][left];\\n        int dont= solve(idx+1, left);\\n        int does= solve(idx+1,left-d[idx]-1)+c[idx];\\n        \\n        return dp[idx][left]=min(dont, does);\\n        \\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n       \\n        c=cost;\\n        d=time;\\n        n=c.size();\\n        dp.resize(n+1, vector<int>(n+1,-1));\\n        for(auto i:c) sum+=i;\\n\\n        return solve(0,n);\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690548,
                "title": "c-dp-memoization",
                "content": "\\n    typedef long long ll;\\n    ll func( int idx, int wall_remain, vector<int>& v, vector<int>& t,vector<vector<ll>> &dp){\\n        if( wall_remain <= 0 ) return 0;\\n        if(idx>=v.size()) return INT_MAX; \\n            \\n        if(dp[idx][wall_remain]!=-1) return dp[idx][wall_remain];\\n        \\n        // take\\n        ll ans1 = func(idx+1,wall_remain - t[idx] - 1 , v, t ,dp) + v[idx];\\n        \\n        // not take\\n        ll ans2 = func(idx+1,wall_remain , v , t, dp);\\n        \\n        return dp[idx][wall_remain] = min(ans1,ans2);\\n        \\n    }\\n    int paintWalls(vector<int>& v, vector<int>& t) {\\n        int n = v.size();\\n        vector<vector<ll>> dp(n,vector<ll>(n+1,-1));\\n        return func(0,n,v,t,dp);\\n    }",
                "solutionTags": [],
                "code": "\\n    typedef long long ll;\\n    ll func( int idx, int wall_remain, vector<int>& v, vector<int>& t,vector<vector<ll>> &dp){\\n        if( wall_remain <= 0 ) return 0;\\n        if(idx>=v.size()) return INT_MAX; \\n            \\n        if(dp[idx][wall_remain]!=-1) return dp[idx][wall_remain];\\n        \\n        // take\\n        ll ans1 = func(idx+1,wall_remain - t[idx] - 1 , v, t ,dp) + v[idx];\\n        \\n        // not take\\n        ll ans2 = func(idx+1,wall_remain , v , t, dp);\\n        \\n        return dp[idx][wall_remain] = min(ans1,ans2);\\n        \\n    }\\n    int paintWalls(vector<int>& v, vector<int>& t) {\\n        int n = v.size();\\n        vector<vector<ll>> dp(n,vector<ll>(n+1,-1));\\n        return func(0,n,v,t,dp);\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 3674762,
                "title": "simple-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe catch here is that once the painter1 chooses a wall lets say ith wall then it doesn\\'t actually matter which walls are painted by the painter2 in time[i].\\nafter this it is plain 0/1 knapsack where the weight is time[i] with maximum capacity as n.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>c,t;\\n    long long f(int idx,int n,vector<vector<long long>>&dp){\\n        if(n<=0)return 0;\\n        if(idx==t.size())return 1e15;\\n        if(dp[idx][n] != -1)return dp[idx][n];\\n        \\n        long long op1 = f(idx+1,n,dp);\\n        long long op2 = c[idx] + f(idx+1,n - t[idx]-1,dp);\\n        return dp[idx][n] = min(op1,op2);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        c = cost;\\n        t = time;\\n        int n = cost.size();\\n        vector<vector<long long>>dp(501,vector<long long>(501,-1));\\n        return f(0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>c,t;\\n    long long f(int idx,int n,vector<vector<long long>>&dp){\\n        if(n<=0)return 0;\\n        if(idx==t.size())return 1e15;\\n        if(dp[idx][n] != -1)return dp[idx][n];\\n        \\n        long long op1 = f(idx+1,n,dp);\\n        long long op2 = c[idx] + f(idx+1,n - t[idx]-1,dp);\\n        return dp[idx][n] = min(op1,op2);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        c = cost;\\n        t = time;\\n        int n = cost.size();\\n        vector<vector<long long>>dp(501,vector<long long>(501,-1));\\n        return f(0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674172,
                "title": "java-c-python-knapsack-dp",
                "content": "**Explanation :**\\nThe base case is set where if there are no walls to paint (wallLeft = 0), the cost is zero (dp[i][0] = 0).\\nThen, for each wall (idx) and the number of walls left to paint (wallLeft), it calculates the minimum cost by considering two options:\\nnotTake: The cost of not taking the current wall (dp[idx-1][wallLeft]).\\ntake: The cost of taking the current wall, which is the sum of the cost of painting the current wall (cost[idx-1]) and the minimum cost obtained by considering the previous walls within the time constraint (dp[idx-1][max(wallLeft - 1 - time[idx-1], 0)]).\\nThe minimum cost is stored in dp[idx][wallLeft].\\nFinally, the minimum cost to paint all the walls is given by dp[n][n].\\n\\n\\n**Intution** \\n\\nThe code uses dynamic programming to build a table dp to store the minimum cost at each step.\\nBy considering all possible walls and the number of walls left to paint, it calculates the minimum cost by considering two options: either taking the current wall or not taking it.\\nThe table dp is filled in a bottom-up manner, starting from the base case of no walls to paint (wallLeft = 0) and gradually considering all walls.\\nAt each step, the minimum cost is calculated by choosing the option that leads to the lower cost.\\nFinally, the minimum cost to paint all the walls is returned.\\n\\n\\n**C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n   int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n        //TABULATION APPROACH\\n        int n = cost.size(); \\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 1e9));\\n        for(int i =0; i<=n; i++){\\n           dp[i][0] = 0;\\n        }\\n       for(int idx=1; idx<=n; idx++){\\n           for(int wallLeft = 1; wallLeft<=n; wallLeft++){\\n               int notTake = dp[idx-1][wallLeft];\\n               int take = cost[idx-1] + dp[idx-1][max(wallLeft - 1 - time[idx-1], 0)];\\n               dp[idx][wallLeft] = min(take, notTake);\\n           }\\n       }\\n        return dp[n][n];    \\n    }\\n};\\n```\\n\\n**Java Code**\\n\\n```\\nclass Solution {\\n    public int paintWalls(List<Integer> cost, List<Integer> time) {\\n        // TABULATION APPROACH\\n        int n = cost.size();\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 0;\\n        }\\n        for (int idx = 1; idx <= n; idx++) {\\n            for (int wallLeft = 1; wallLeft <= n; wallLeft++) {\\n                int notTake = dp[idx-1][wallLeft];\\n                int take = cost.get(idx-1) + dp[idx-1][Math.max(wallLeft - 1 - time.get(idx-1), 0)];\\n                dp[idx][wallLeft] = Math.min(take, notTake);\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n}\\n\\n```\\n\\n**Python Code**\\n\\n```\\nclass Solution:\\n    def paintWalls(self, cost, time):\\n        # TABULATION APPROACH\\n        n = len(cost)\\n        dp = [[float(\\'inf\\')] * (n+1) for _ in range(n+1)]\\n        \\n        for i in range(n+1):\\n            dp[i][0] = 0\\n        \\n        for idx in range(1, n+1):\\n            for wallLeft in range(1, n+1):\\n                notTake = dp[idx-1][wallLeft]\\n                take = cost[idx-1] + dp[idx-1][max(wallLeft - 1 - time[idx-1], 0)]\\n                dp[idx][wallLeft] = min(take, notTake)\\n        \\n        return dp[n][n]\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n        //TABULATION APPROACH\\n        int n = cost.size(); \\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 1e9));\\n        for(int i =0; i<=n; i++){\\n           dp[i][0] = 0;\\n        }\\n       for(int idx=1; idx<=n; idx++){\\n           for(int wallLeft = 1; wallLeft<=n; wallLeft++){\\n               int notTake = dp[idx-1][wallLeft];\\n               int take = cost[idx-1] + dp[idx-1][max(wallLeft - 1 - time[idx-1], 0)];\\n               dp[idx][wallLeft] = min(take, notTake);\\n           }\\n       }\\n        return dp[n][n];    \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int paintWalls(List<Integer> cost, List<Integer> time) {\\n        // TABULATION APPROACH\\n        int n = cost.size();\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 0;\\n        }\\n        for (int idx = 1; idx <= n; idx++) {\\n            for (int wallLeft = 1; wallLeft <= n; wallLeft++) {\\n                int notTake = dp[idx-1][wallLeft];\\n                int take = cost.get(idx-1) + dp[idx-1][Math.max(wallLeft - 1 - time.get(idx-1), 0)];\\n                dp[idx][wallLeft] = Math.min(take, notTake);\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def paintWalls(self, cost, time):\\n        # TABULATION APPROACH\\n        n = len(cost)\\n        dp = [[float(\\'inf\\')] * (n+1) for _ in range(n+1)]\\n        \\n        for i in range(n+1):\\n            dp[i][0] = 0\\n        \\n        for idx in range(1, n+1):\\n            for wallLeft in range(1, n+1):\\n                notTake = dp[idx-1][wallLeft]\\n                take = cost[idx-1] + dp[idx-1][max(wallLeft - 1 - time[idx-1], 0)]\\n                dp[idx][wallLeft] = min(take, notTake)\\n        \\n        return dp[n][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672919,
                "title": "simple-c-solution-2-dp-memoization",
                "content": "# Intuition\\nThis question can be done by memoization and choosing two option whether to paint wall by paid painter or not.\\n\\n# Approach\\n1. Take a 2D DP vector and initialize it with -1.\\n2. The first dimension of dp represent the ith wall and the second dimension represents number of walls left.\\n3. This vector will helf for memoization.\\n4. Taking a recursive function ```solve``` if ```wall_left<=0``` then simply we\\'ll return 0.\\n5. If index of wall reached to ```cost.size()``` which means all walls are done by paid painter then we will return the sum of all cost ```sum```.\\n6. If we have the repetitive case ie ind and wall_left are repeated then we will simply ```return dp[ind][wall_left];```\\n7. Otherwise we will have to choices ```dontpaint``` or ```paint```\\n8. If we choose dontpaint we will move to next index ie ```ind+1``` and the wall_left will not be changed. So answer corresponding to dontpaint will be ```solve(cost,time,ind+1,wall_left,dp,sum)```.\\n9. If we choose paint, number of wall left for painting will be decrease to ```wall_left-1-time[ind]```. This extra ```time[ind]``` because in this time free painter will paint the wall and he take 1 unit of time to paint it.\\n10. After that we will take minimum of both and ```dp[ind][wall_left]=min(dontpaint,paint)```. And this will be returned.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&cost,vector<int>&time,int ind,int wall_left,vector<vector<int>>&dp,int sum){\\n        if(wall_left<=0){\\n            return 0;\\n        }\\n        if(ind>=cost.size()){\\n            return sum;\\n        }\\n        if(dp[ind][wall_left]!=-1){\\n            return dp[ind][wall_left];\\n        }\\n        // if not take then it will be done by free painter...\\n        int dontpaint=solve(cost,time,ind+1,wall_left,dp,sum);\\n// Else the paid painter will charge cost[ind]...\\n        int paint=cost[ind]+solve(cost,time,ind+1,wall_left-time[ind]-1,dp,sum);\\n        return dp[ind][wall_left]=min(dontpaint,paint);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n       int ind=0;\\n       int sum=0;\\n       for(auto ele:cost){\\n           sum+=ele;\\n       }\\n       int wall_left=cost.size();\\n       int n=cost.size();\\n       vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n       int ans=solve(cost,time,ind,wall_left,dp,sum);\\n       return ans;\\n    }\\n        //<!-- Please upvote if you liked!!! -->\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```solve```\n```wall_left<=0```\n```cost.size()```\n```sum```\n```return dp[ind][wall_left];```\n```dontpaint```\n```paint```\n```ind+1```\n```solve(cost,time,ind+1,wall_left,dp,sum)```\n```wall_left-1-time[ind]```\n```time[ind]```\n```dp[ind][wall_left]=min(dontpaint,paint)```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&cost,vector<int>&time,int ind,int wall_left,vector<vector<int>>&dp,int sum){\\n        if(wall_left<=0){\\n            return 0;\\n        }\\n        if(ind>=cost.size()){\\n            return sum;\\n        }\\n        if(dp[ind][wall_left]!=-1){\\n            return dp[ind][wall_left];\\n        }\\n        // if not take then it will be done by free painter...\\n        int dontpaint=solve(cost,time,ind+1,wall_left,dp,sum);\\n// Else the paid painter will charge cost[ind]...\\n        int paint=cost[ind]+solve(cost,time,ind+1,wall_left-time[ind]-1,dp,sum);\\n        return dp[ind][wall_left]=min(dontpaint,paint);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n       int ind=0;\\n       int sum=0;\\n       for(auto ele:cost){\\n           sum+=ele;\\n       }\\n       int wall_left=cost.size();\\n       int n=cost.size();\\n       vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n       int ans=solve(cost,time,ind,wall_left,dp,sum);\\n       return ans;\\n    }\\n        //<!-- Please upvote if you liked!!! -->\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671251,
                "title": "2742-painting-the-walls-beats-100-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501] = {};\\n    int Rec(int idx,vector<int> &cost,vector<int> &time,int Total_walls){\\n    //  if(idx>=Total_walls){\\n    //     return 1e8;\\n    //  }\\n     if(Total_walls<=0) return 0;\\n     if(idx>=cost.size()){\\n        return 1e9;\\n     }\\n    if(dp[idx][Total_walls]!=0) return dp[idx][Total_walls];\\n    int Not_take=Rec(idx+1,cost,time,Total_walls);\\n    int take=cost[idx]+Rec(idx+1,cost,time,Total_walls-time[idx]-1);\\n    //int Not_take=Rec(idx+1,cost,time,Total_walls);\\n     return dp[idx][Total_walls]= min(take,Not_take);\\n  \\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int Total_walls=cost.size();\\n    \\n       // vector<vector<int>> dp(501,vector<int>(501,-1));\\n        return Rec(0,cost,time,Total_walls);\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501] = {};\\n    int Rec(int idx,vector<int> &cost,vector<int> &time,int Total_walls){\\n    //  if(idx>=Total_walls){\\n    //     return 1e8;\\n    //  }\\n     if(Total_walls<=0) return 0;\\n     if(idx>=cost.size()){\\n        return 1e9;\\n     }\\n    if(dp[idx][Total_walls]!=0) return dp[idx][Total_walls];\\n    int Not_take=Rec(idx+1,cost,time,Total_walls);\\n    int take=cost[idx]+Rec(idx+1,cost,time,Total_walls-time[idx]-1);\\n    //int Not_take=Rec(idx+1,cost,time,Total_walls);\\n     return dp[idx][Total_walls]= min(take,Not_take);\\n  \\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int Total_walls=cost.size();\\n    \\n       // vector<vector<int>> dp(501,vector<int>(501,-1));\\n        return Rec(0,cost,time,Total_walls);\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670650,
                "title": "c-dp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int index,vector<int>& cost, vector<int>& time,int wall_count,vector<vector<int>> &dp){\\n        if(index >= cost.size()){\\n            if(wall_count<=0){\\n                return 0;//No cost will incur if no walls to paint after index reached the end\\n            }  \\n            return 1e9;//Return large value, so that min is not affected\\n        }\\n\\n        //No cost will incur if no walls to paint, if the walls have been already \\n        //painted by the free painters before index reached the end\\n        if(wall_count <= 0){\\n            return 0;\\n        }\\n            \\n\\n        if(dp[index][wall_count] != -1){\\n            return dp[index][wall_count];\\n        }\\n\\n        //Not take(Not painting)\\n        //No cost will be incured\\n        int notTake = solve(index+1,cost,time,wall_count,dp);\\n\\n        //Take(Painting)\\n        //Cost will be incured w.r.t the paid painter\\n        /*wall_count-time[index]-1 :- (wall_count - time_taken_by_paid_painter - current_wall)\\n          time_taken_by_paid_painter == no. of wall painted by free painters\\n        */\\n        int take = cost[index] + solve(index+1,cost,time,wall_count-time[index]-1,dp);\\n\\n        return dp[index][wall_count] = min(take,notTake);\\n    }\\n\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(0,cost,time,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int index,vector<int>& cost, vector<int>& time,int wall_count,vector<vector<int>> &dp){\\n        if(index >= cost.size()){\\n            if(wall_count<=0){\\n                return 0;//No cost will incur if no walls to paint after index reached the end\\n            }  \\n            return 1e9;//Return large value, so that min is not affected\\n        }\\n\\n        //No cost will incur if no walls to paint, if the walls have been already \\n        //painted by the free painters before index reached the end\\n        if(wall_count <= 0){\\n            return 0;\\n        }\\n            \\n\\n        if(dp[index][wall_count] != -1){\\n            return dp[index][wall_count];\\n        }\\n\\n        //Not take(Not painting)\\n        //No cost will be incured\\n        int notTake = solve(index+1,cost,time,wall_count,dp);\\n\\n        //Take(Painting)\\n        //Cost will be incured w.r.t the paid painter\\n        /*wall_count-time[index]-1 :- (wall_count - time_taken_by_paid_painter - current_wall)\\n          time_taken_by_paid_painter == no. of wall painted by free painters\\n        */\\n        int take = cost[index] + solve(index+1,cost,time,wall_count-time[index]-1,dp);\\n\\n        return dp[index][wall_count] = min(take,notTake);\\n    }\\n\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(0,cost,time,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668776,
                "title": "c-dp-solution",
                "content": "class Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n        return min_cost(0,n,cost,time,dp);\\n    }\\n     \\n    int min_cost(int i,int task,vector<int>& c,vector<int>& t,vector<vector<int>>& dp){\\n        if(i==c.size()){\\n           if(task<=0){return 0;}\\n           return 1e9;\\n        }\\n        if(task<=0){return 0;}\\n        if(dp[i][task]!=-1){return dp[i][task];}\\n\\n        int nottake=0+min_cost(i+1,task,c,t,dp);\\n        int take=c[i]+min_cost(i+1,task-1-t[i],c,t,dp);\\n        return dp[i][task]=min(take,nottake);\\n    } \\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n        return min_cost(0,n,cost,time,dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3665561,
                "title": "simple-recursive-memoization",
                "content": "# Intuition\\nIn this problem you can see that for every wall we have two choices either we pay for painting that wall or by free painter. So just do simple recursion and memoise it.\\n\\n# Approach\\nIn this approach we will just make a paid variable for storing cost if that index is painted by paid painter and similarly free variable for free painter. Here we will store index against time because at every index time matters to take the future index in accroding to that and cost will be stored because we have to return that.\\n\\n# Constraint use:\\n- timee max limit is 1000 because max limit of time[i] is 500 and we have considered double of it for being in safe side\\n- timee + n is done to avoid negative indexing \\n- size of dp is 1500 because max limit is 1000 and adding the max value of n to it gives 1500\\n\\n# Complexity\\n- Time complexity:\\nO(n)*1500\\n\\n- Space complexity:\\nO(n)*1500\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int paint(int i, int timee , vector<int>& cost, vector<int>& time , vector<vector<int>>&dp){\\n        int n = cost.size();\\n        if(timee > 1000){\\n            return 1e5;\\n        }\\n        if(i >= n){\\n            if(timee < 0){\\n                return 1e9;\\n            }\\n            return 0;\\n        }\\n        if( dp[i][n + timee] != -1){\\n            return dp[i][n + timee];\\n        }\\n\\n        int paid = cost[i] + paint(i+1,timee + time[i]  ,cost,time,dp);\\n        int free = paint(i+1,timee - 1  ,cost,time,dp);\\n        return dp[i][n + timee] = min(free , paid);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>>dp(n+4, vector<int>(1501,-1));\\n        return paint( 0, 0, cost, time, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paint(int i, int timee , vector<int>& cost, vector<int>& time , vector<vector<int>>&dp){\\n        int n = cost.size();\\n        if(timee > 1000){\\n            return 1e5;\\n        }\\n        if(i >= n){\\n            if(timee < 0){\\n                return 1e9;\\n            }\\n            return 0;\\n        }\\n        if( dp[i][n + timee] != -1){\\n            return dp[i][n + timee];\\n        }\\n\\n        int paid = cost[i] + paint(i+1,timee + time[i]  ,cost,time,dp);\\n        int free = paint(i+1,timee - 1  ,cost,time,dp);\\n        return dp[i][n + timee] = min(free , paid);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>>dp(n+4, vector<int>(1501,-1));\\n        return paint( 0, 0, cost, time, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664969,
                "title": "c-dp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) \\n    {\\n        int n=cost.size();\\n        vector<int>f(n+1,INT_MAX);\\n        f[0]=0;\\n        f[min(n,time[0]+1)]=cost[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=n;j>=0;j--)\\n            {\\n                if(f[j]==INT_MAX)continue;\\n                int target=min(n,j+time[i]+1);\\n                f[target]=min(f[target],f[j]+cost[i]);\\n            }\\n        }\\n        return f[n];\\n    }\\n};\\n\\n// i = \\u8DD1\\u5230\\u7B2C\\u5E7E\\u500B\\n// j = \\u5DF2\\u7D93\\u53EF\\u4EE5\\u62B5\\u6D88\\u591A\\u5DE5\\u4F5C\\n// val = \\u5728\\u9019\\u6A23\\u7684\\u60C5\\u6CC1\\u4E0B\\u6240\\u6D88\\u8017\\u7684cost\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) \\n    {\\n        int n=cost.size();\\n        vector<int>f(n+1,INT_MAX);\\n        f[0]=0;\\n        f[min(n,time[0]+1)]=cost[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=n;j>=0;j--)\\n            {\\n                if(f[j]==INT_MAX)continue;\\n                int target=min(n,j+time[i]+1);\\n                f[target]=min(f[target],f[j]+cost[i]);\\n            }\\n        }\\n        return f[n];\\n    }\\n};\\n\\n// i = \\u8DD1\\u5230\\u7B2C\\u5E7E\\u500B\\n// j = \\u5DF2\\u7D93\\u53EF\\u4EE5\\u62B5\\u6D88\\u591A\\u5DE5\\u4F5C\\n// val = \\u5728\\u9019\\u6A23\\u7684\\u60C5\\u6CC1\\u4E0B\\u6240\\u6D88\\u8017\\u7684cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664688,
                "title": "easy-to-understand-15-lines-of-code-100-working",
                "content": "# Intuition\\nTo solve the \"paintWalls\" problem, we can use a dynamic programming approach. We maintain an array to store the minimum cost required to paint a certain number of walls. We iterate over each wall, updating the dynamic programming array based on the minimum cost of painting `j-1` walls and adding the cost of the current wall. The minimum cost to paint all walls is the final result stored in the dynamic programming array.\\n\\n# Approach\\nwe are using dynamic programming approach. We iterate over each wall and update the minimum cost based on whether the current wall is included or skipped. By storing and reusing previously calculated values, we can efficiently find the minimum cost to paint all the walls.\\n\\n# Complexity\\n\\n* The time complexity of this solution is O(n^2) due to the nested loops, where n is the number of walls. \\n* The space complexity is O(n) to store the dp array\\n\\n# Code\\n```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, (int) 1e9);\\n        dp[0] = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = n; j > 0; --j) {\\n                dp[j] = Math.min(dp[j], dp[Math.max(j - time[i] - 1, 0)] + cost[i]);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, (int) 1e9);\\n        dp[0] = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = n; j > 0; --j) {\\n                dp[j] = Math.min(dp[j], dp[Math.max(j - time[i] - 1, 0)] + cost[i]);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663476,
                "title": "c-dp-memoziation-pick-notpick-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint f(int index,int wallsleft,vector<int>& cost, vector<int>& time,int n, vector<vector<int>>&dp){  \\n    if(wallsleft<=0)return 0;\\n    if(index>=n){\\n        if(wallsleft>=1)return 1e9;\\n        else return 0;  \\n    }\\n    if(dp[index][wallsleft]!=-1)return dp[index][wallsleft];\\n     int nPick=f(index+1,wallsleft,cost,time,n,dp);\\n     int Pick=0;\\n     if(wallsleft>=1)Pick=cost[index]+f(index+1,wallsleft-1-time[index],cost,time,n,dp);\\n     return dp[index][wallsleft]=min(Pick,nPick);\\n }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n     int n=cost.size();\\n     vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n     return f(0,n,cost,time,n,dp); \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint f(int index,int wallsleft,vector<int>& cost, vector<int>& time,int n, vector<vector<int>>&dp){  \\n    if(wallsleft<=0)return 0;\\n    if(index>=n){\\n        if(wallsleft>=1)return 1e9;\\n        else return 0;  \\n    }\\n    if(dp[index][wallsleft]!=-1)return dp[index][wallsleft];\\n     int nPick=f(index+1,wallsleft,cost,time,n,dp);\\n     int Pick=0;\\n     if(wallsleft>=1)Pick=cost[index]+f(index+1,wallsleft-1-time[index],cost,time,n,dp);\\n     return dp[index][wallsleft]=min(Pick,nPick);\\n }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n     int n=cost.size();\\n     vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n     return f(0,n,cost,time,n,dp); \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663204,
                "title": "easy-c-explanation-simple-easy-0-1-knapsack-way-striver-s-approach-beginner-friendly",
                "content": "# Intuition\\nthink this for every index by take ,nottake case\\n\\n# Approach\\nIts totally dependent on paid painter\\'s work.So by 0/1 knapsack concept for every index we paid painter can do word or not do\\n1.Take= in take case id for a current index paid painter is painting the wall then at same time the unpaid painter can paint time[current index] number of walls,as it take 1 unit of time \\nso tatl number of walls remaining is=\\noriginial wall- time[current index]-1 (-1 is for paid painter completion of one wall)\\n\\n2.Not take:in this case only index has to be reduced we are not taking any cost\\n\\nand finally return minimum among them\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)+O(n)\\n\\nhere O(n) is auxiliary stack space which can be removed by tabulation code\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& cost,vector<int>&time,int index,\\n            int no_of_walls,vector<vector<int>>&dp)\\n            {\\n                if(no_of_walls<=0)return 0;\\n                if(index<0)return 1e9;\\n                if(dp[index][no_of_walls]!=-1)return dp[index][no_of_walls];\\n\\n                int nottake=0+fun(cost,time,index-1,no_of_walls,dp);\\n                int take=cost[index]+fun(cost,time,index-1,no_of_walls-time[index]-1,dp);\\n                //no_of_walls-time[index]-1==this is bcz in this perticular duration of time of paid\\n                // painter ,unpaid painter will finish the number of walls=time required by paid painter\\n                // for currrent wall\\n                // so total number of walls completed is time units of current index by free painter\\n                //  and + 1 by paid painter\\n                return dp[index][no_of_walls]=min(take,nottake);\\n            }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return fun(cost,time,n-1,n,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& cost,vector<int>&time,int index,\\n            int no_of_walls,vector<vector<int>>&dp)\\n            {\\n                if(no_of_walls<=0)return 0;\\n                if(index<0)return 1e9;\\n                if(dp[index][no_of_walls]!=-1)return dp[index][no_of_walls];\\n\\n                int nottake=0+fun(cost,time,index-1,no_of_walls,dp);\\n                int take=cost[index]+fun(cost,time,index-1,no_of_walls-time[index]-1,dp);\\n                //no_of_walls-time[index]-1==this is bcz in this perticular duration of time of paid\\n                // painter ,unpaid painter will finish the number of walls=time required by paid painter\\n                // for currrent wall\\n                // so total number of walls completed is time units of current index by free painter\\n                //  and + 1 by paid painter\\n                return dp[index][no_of_walls]=min(take,nottake);\\n            }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return fun(cost,time,n-1,n,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662936,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        \\n        long[][] dp = new long[cost.length + 1][2000];\\n        for(int i = 0 ; i <= cost.length ; i++){\\n            for(int j = 0 ; j < 2000 ; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        long ans =  get(0 , 500 ,  cost , time , dp);\\n        long sum = 0;\\n        for(int ele : cost){\\n            sum += ele;\\n        }\\n        return (int)ans;\\n    }\\n    private long get(int i ,  int t ,  int[] cost , int[] time ,long[][] dp){\\n        \\n        if(i >= cost.length){\\n            if(t-500 >= 0) return 0;\\n            return Integer.MAX_VALUE;\\n        } \\n        if(dp[i][t] != -1) return dp[i][t];\\n        int min = Integer.MAX_VALUE;\\n        return dp[i][t] = Math.min(cost[i] + get(i+1 , t + time[i] >= 1200 + 500 ? 1700 : t + time[i] , cost , time,dp) , get(i+1 , t-1 , cost , time,dp ));\\n        \\n    }\\n}\\n```\\n**Please UpVote if found helpful**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int paintWalls(int[] cost, int[] time) {\\n        \\n        long[][] dp = new long[cost.length + 1][2000];\\n        for(int i = 0 ; i <= cost.length ; i++){\\n            for(int j = 0 ; j < 2000 ; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        long ans =  get(0 , 500 ,  cost , time , dp);\\n        long sum = 0;\\n        for(int ele : cost){\\n            sum += ele;\\n        }\\n        return (int)ans;\\n    }\\n    private long get(int i ,  int t ,  int[] cost , int[] time ,long[][] dp){\\n        \\n        if(i >= cost.length){\\n            if(t-500 >= 0) return 0;\\n            return Integer.MAX_VALUE;\\n        } \\n        if(dp[i][t] != -1) return dp[i][t];\\n        int min = Integer.MAX_VALUE;\\n        return dp[i][t] = Math.min(cost[i] + get(i+1 , t + time[i] >= 1200 + 500 ? 1700 : t + time[i] , cost , time,dp) , get(i+1 , t-1 , cost , time,dp ));\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661514,
                "title": "c-simple-and-easy-to-understand-solution-with-detailed-explaining-and-pictures",
                "content": "# Intuition\\n![gg2.png](https://assets.leetcode.com/users/images/1c19d764-57cb-42ec-b31f-1a00c82a86ff_1687264496.4262738.png)\\n![gg.png](https://assets.leetcode.com/users/images/93fb4502-d60b-4e5c-91fb-3be476bcec5c_1687264414.4609964.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int walls_left, vector<int>& cost, vector<int>& time,vector<vector<int>>& dp)\\n    {\\n        if(walls_left<=0) return 0;\\n        if(i<0) return 1e9;\\n        if(dp[i][walls_left] !=-1) return dp[i][walls_left];\\n        int paid = cost[i] + solve(i-1, walls_left - 1 - time[i], cost, time,dp);\\n        int free = solve(i-1, walls_left, cost, time,dp);\\n        return dp[i][walls_left] = min(free, paid);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        return solve(n-1, n, cost, time,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int walls_left, vector<int>& cost, vector<int>& time,vector<vector<int>>& dp)\\n    {\\n        if(walls_left<=0) return 0;\\n        if(i<0) return 1e9;\\n        if(dp[i][walls_left] !=-1) return dp[i][walls_left];\\n        int paid = cost[i] + solve(i-1, walls_left - 1 - time[i], cost, time,dp);\\n        int free = solve(i-1, walls_left, cost, time,dp);\\n        return dp[i][walls_left] = min(free, paid);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        return solve(n-1, n, cost, time,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660937,
                "title": "c-easy-explanation-memo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlet we have to paint n walls. paid painter is painting a wall let take time t1 so right now we have t1 unit time we can use free painter if total walls is n and 1 wall that is currently painted and t1 unit free time so now we have to paint only n-1-t1 walls;\\nso in this way when out n<=0 we return 0. and when we will reach less than last index means i<0 means we traverse whole array still we didn\\'t find the way to use free painter so we return highest number which in recursion portion compare with minimum and never that ans.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- we are using 2 d array maximum time comlexity n^2;\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- auxilary stack space o(n)+o(n^2);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mn=INT_MAX;\\nint dp[501][501];\\nint solve(vector<int>&cost,vector<int>&time,int i,int n)\\n{\\n    if(n<=0)\\n    {\\n        return 0;\\n\\n    }\\n    if(i<0)\\n    { \\n       return 1000000007;\\n    }\\n    if(dp[i][n]!=-1)\\n    return dp[i][n];\\n        return  dp[i][n]=min(cost[i]+solve(cost,time,i-1,n-time[i]-1,p),solve(cost,time,i-1,n,p));\\n    \\n}\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=cost.size();\\n        return solve(cost,time,n-1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mn=INT_MAX;\\nint dp[501][501];\\nint solve(vector<int>&cost,vector<int>&time,int i,int n)\\n{\\n    if(n<=0)\\n    {\\n        return 0;\\n\\n    }\\n    if(i<0)\\n    { \\n       return 1000000007;\\n    }\\n    if(dp[i][n]!=-1)\\n    return dp[i][n];\\n        return  dp[i][n]=min(cost[i]+solve(cost,time,i-1,n-time[i]-1,p),solve(cost,time,i-1,n,p));\\n    \\n}\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=cost.size();\\n        return solve(cost,time,n-1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657259,
                "title": "c-clean-recursion-memorization-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int dfs(vector<int>& cost, vector<int>& time, int pos, int limit, int n, int paidtime){\\n        if (paidtime>n) return 1000000000;\\n        if (pos ==n){\\n            if (paidtime <0) return 1000000000;\\n            return 0;\\n        }\\n        if (memo[pos][paidtime+n] !=-1) return memo[pos][paidtime+n];\\n        int c1 = cost[pos] + dfs(cost,time,pos+1,limit,n,paidtime + time[pos]);\\n        int c2 = dfs(cost,time,pos+1,limit,n,paidtime-1);      \\n        memo[pos][paidtime+n] = min(c1,c2);\\n        return memo[pos][paidtime+n];\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        /*\\n        Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.\\n        */\\n        int n = time.size();\\n        int limit = n/2;\\n        if (n%2 ==1) limit ++;\\n        vector<int> v(2*n+1,-1);//deal with temp negative index\\n        for (int i=0; i<n;i++) memo.push_back(v);\\n        return dfs(cost,time,0,limit,n,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int dfs(vector<int>& cost, vector<int>& time, int pos, int limit, int n, int paidtime){\\n        if (paidtime>n) return 1000000000;\\n        if (pos ==n){\\n            if (paidtime <0) return 1000000000;\\n            return 0;\\n        }\\n        if (memo[pos][paidtime+n] !=-1) return memo[pos][paidtime+n];\\n        int c1 = cost[pos] + dfs(cost,time,pos+1,limit,n,paidtime + time[pos]);\\n        int c2 = dfs(cost,time,pos+1,limit,n,paidtime-1);      \\n        memo[pos][paidtime+n] = min(c1,c2);\\n        return memo[pos][paidtime+n];\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        /*\\n        Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.\\n        */\\n        int n = time.size();\\n        int limit = n/2;\\n        if (n%2 ==1) limit ++;\\n        vector<int> v(2*n+1,-1);//deal with temp negative index\\n        for (int i=0; i<n;i++) memo.push_back(v);\\n        return dfs(cost,time,0,limit,n,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656986,
                "title": "0-1-knapsack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int index, int curTime,int cost, vector<pair<int,int>>&vp,vector<vector<int>>&dp){\\n       if(curTime>=vp.size()){\\n           return 0;\\n       }\\n       if(index==vp.size()){\\n           if(curTime>=vp.size()){\\n               return 0;\\n\\n           }\\n           else{\\n            return 1e9;\\n           }\\n\\n       }\\n       if(dp[index][curTime]!=-1){\\n           return dp[index][curTime];\\n\\n       }\\n\\n\\n       long long not_pick=solve(index+1, curTime, cost, vp, dp);\\n       long long pick=vp[index].first+solve(index+1, curTime+vp[index].second, cost+vp[index].first, vp, dp);\\n       return  dp[index][curTime]=min(pick, not_pick);\\n\\n\\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        vector<pair<int,int>>vp;\\n        for(int i=0; i<n; i++){\\n            vp.push_back({cost[i], time[i]+1}); \\n        }\\n        vector<vector<int>>dp(n+1, vector<int>(n+1, -1));\\n        return solve(0 , 0,  0,vp, dp);\\n\\n\\n\\n\\n\\n\\n        \\n\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int index, int curTime,int cost, vector<pair<int,int>>&vp,vector<vector<int>>&dp){\\n       if(curTime>=vp.size()){\\n           return 0;\\n       }\\n       if(index==vp.size()){\\n           if(curTime>=vp.size()){\\n               return 0;\\n\\n           }\\n           else{\\n            return 1e9;\\n           }\\n\\n       }\\n       if(dp[index][curTime]!=-1){\\n           return dp[index][curTime];\\n\\n       }\\n\\n\\n       long long not_pick=solve(index+1, curTime, cost, vp, dp);\\n       long long pick=vp[index].first+solve(index+1, curTime+vp[index].second, cost+vp[index].first, vp, dp);\\n       return  dp[index][curTime]=min(pick, not_pick);\\n\\n\\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        vector<pair<int,int>>vp;\\n        for(int i=0; i<n; i++){\\n            vp.push_back({cost[i], time[i]+1}); \\n        }\\n        vector<vector<int>>dp(n+1, vector<int>(n+1, -1));\\n        return solve(0 , 0,  0,vp, dp);\\n\\n\\n\\n\\n\\n\\n        \\n\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656985,
                "title": "dp-knapsack-simple-understandable-code-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][1200];\\n    int helper(vector<int>& cost, vector<int>& time,int i,int tt)\\n    {\\n        int n=cost.size();\\n        if(i==n)\\n        {\\n            if(tt>=500)\\n                return 0;\\n            else\\n                return 1e9;\\n        }\\n        if(dp[i][tt]!=-1)\\n            return dp[i][tt];\\n        return   dp[i][tt]=min(helper(cost,time,i+1,tt-1),helper(cost,time,i+1,min(1100,tt+time[i]))+cost[i]);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp,-1,sizeof(dp));\\n     return helper(cost,time,0,500);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][1200];\\n    int helper(vector<int>& cost, vector<int>& time,int i,int tt)\\n    {\\n        int n=cost.size();\\n        if(i==n)\\n        {\\n            if(tt>=500)\\n                return 0;\\n            else\\n                return 1e9;\\n        }\\n        if(dp[i][tt]!=-1)\\n            return dp[i][tt];\\n        return   dp[i][tt]=min(helper(cost,time,i+1,tt-1),helper(cost,time,i+1,min(1100,tt+time[i]))+cost[i]);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp,-1,sizeof(dp));\\n     return helper(cost,time,0,500);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656771,
                "title": "paint-all-walls-using-dp-knapsack-0-1-memoization-variation-of-knapsack",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // this problem is very similiar to knapsack problem  \\n    //choice  --> 1 .take paid painter of curr  ,,,,,,,,,,,,  2. dont take \\n    // so that the ans is minimum cost  -----> optimal \\n    \\n    // we solve it using dp with \"curr\" index and remaining walls to be painted\\n    \\n    // approach  --> if we take any wall for paid painter then there time assume x time take by paid painter so x no of walls paint by free painter because free painter paint in one unit of time so -------> take those walls whose cost is less and time is more to acheive minimum cost \\n    // one painted by paid one and -----> (time[curr] + 1 total walls painted)\\n    \\n    \\n    vector<vector<int>> dp;\\n    \\n    int solve(vector<int>& cost, vector<int>& time , int curr , int wallRemaining)\\n    {\\n        if(wallRemaining <= 0)\\n            return 0;\\n        if(curr >= cost.size())\\n            return 2000000000;\\n        \\n        if(dp[curr][wallRemaining] != -1)\\n            return dp[curr][wallRemaining];\\n        \\n        int take = cost[curr] + solve(cost ,time ,curr + 1 , wallRemaining - time[curr] -1);\\n        int dontTake = solve(cost ,time , curr + 1, wallRemaining);\\n        \\n        return dp[curr][wallRemaining] = min(take,dontTake);\\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        dp.resize(cost.size()+1, vector<int>(cost.size() + 1, -1));\\n\\n        \\n        return solve(cost , time , 0 , cost.size());  // cost.size == wall remaining\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // this problem is very similiar to knapsack problem  \\n    //choice  --> 1 .take paid painter of curr  ,,,,,,,,,,,,  2. dont take \\n    // so that the ans is minimum cost  -----> optimal \\n    \\n    // we solve it using dp with \"curr\" index and remaining walls to be painted\\n    \\n    // approach  --> if we take any wall for paid painter then there time assume x time take by paid painter so x no of walls paint by free painter because free painter paint in one unit of time so -------> take those walls whose cost is less and time is more to acheive minimum cost \\n    // one painted by paid one and -----> (time[curr] + 1 total walls painted)\\n    \\n    \\n    vector<vector<int>> dp;\\n    \\n    int solve(vector<int>& cost, vector<int>& time , int curr , int wallRemaining)\\n    {\\n        if(wallRemaining <= 0)\\n            return 0;\\n        if(curr >= cost.size())\\n            return 2000000000;\\n        \\n        if(dp[curr][wallRemaining] != -1)\\n            return dp[curr][wallRemaining];\\n        \\n        int take = cost[curr] + solve(cost ,time ,curr + 1 , wallRemaining - time[curr] -1);\\n        int dontTake = solve(cost ,time , curr + 1, wallRemaining);\\n        \\n        return dp[curr][wallRemaining] = min(take,dontTake);\\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        dp.resize(cost.size()+1, vector<int>(cost.size() + 1, -1));\\n\\n        \\n        return solve(cost , time , 0 , cost.size());  // cost.size == wall remaining\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656299,
                "title": "recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int ind,int wallsRemaining,vector<int>& cost, vector<int>& time,\\n    vector<vector<int>> &dp){\\n        int n=cost.size();\\n        if(ind==0){\\n            if(wallsRemaining>0 && time[0]+1>=wallsRemaining){\\n                 return cost[0];\\n            }\\n            else if(wallsRemaining<=0) return 0;\\n            else return 1e9;\\n        }\\n       \\n        if(wallsRemaining<=0) return 0;\\n        if( dp[ind][wallsRemaining]!=-1) return  dp[ind][wallsRemaining];\\n        int take= cost[ind] + f(ind-1,wallsRemaining-time[ind]-1,cost,time,dp);\\n        int notTake= f(ind-1,wallsRemaining,cost,time,dp);\\n\\n        int mini=min(take,notTake);\\n        return dp[ind][wallsRemaining]=mini;\\n\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return f(n-1,n,cost,time,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind,int wallsRemaining,vector<int>& cost, vector<int>& time,\\n    vector<vector<int>> &dp){\\n        int n=cost.size();\\n        if(ind==0){\\n            if(wallsRemaining>0 && time[0]+1>=wallsRemaining){\\n                 return cost[0];\\n            }\\n            else if(wallsRemaining<=0) return 0;\\n            else return 1e9;\\n        }\\n       \\n        if(wallsRemaining<=0) return 0;\\n        if( dp[ind][wallsRemaining]!=-1) return  dp[ind][wallsRemaining];\\n        int take= cost[ind] + f(ind-1,wallsRemaining-time[ind]-1,cost,time,dp);\\n        int notTake= f(ind-1,wallsRemaining,cost,time,dp);\\n\\n        int mini=min(take,notTake);\\n        return dp[ind][wallsRemaining]=mini;\\n\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return f(n-1,n,cost,time,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655411,
                "title": "explanation-simpledp-tabulated-method-0-1-knapsack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to ignore the painter 2 and solve the problem for painter 1. This problem becomes similar to 0/1 knapsack.\\n\\nIn 0/1 Knapsack, we have **value** and **weights** and we have to maximize the total value keeping in mind the weights we are considering. The capacity of the sack is the maximum total weight we can afford.\\nvalue_arr  = [....]\\nweight_arr = [....]\\nmax_capacity of sack\\n\\nSimilarly here, we can minimize the **cost** keeping in mind the number of walls We can at max take **n** walls i.e painter 1 can at max paint **n** walls. It means **n** is the max capacity of the sack and weight of each wall is **1**.\\nHere \\n**value_array/cost_array(to_minimize) = [....]\\nweight_array/walls_to_consider = [1,1,1,1,...]\\nmax_capacity = n**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe approach here is a tabulated 0/1 knapsack solution.\\nHere **dp[i][j]** is the minimum cost to take **j** walls from first **i** walls.\\n\\n* Initialized all the dp[i][j] values to INT_MAX/2\\n* **dp[i][0]** would be 0 for all **i** from **0 to n**. Because to take **j=0** walls from first **i** walls, we would have 0 cost.\\n*  Now Either we can take a wall(for painter 1) or leave it as is(for painter 2). So\\n```\\ndp[i][j] = min(cost[i-1] + dp[i-1][max(0,j-time[i-1]-1) ] , dp[i-1][j] );\\n```\\nHere \\n- If we leave, we would take j walls from **i-1** walls.\\n```\\n    dp[i][j] = dp[i-1][j]\\n```\\n- If we take the wall, we take **j-time[i-1]-1** walls from **i-1** walls. We subtract time[i-1] since in the mean time these would be painted by painter 2. And the current wall is being painted by painter 1 so **subtracting 1**.\\n```\\n    dp[i][j] = cost[i-1] + dp[i-1][max(0,j-time[i-1]-1) ] \\n```\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n\\n        for (int i = 0; i < 505; i++) {\\n            for (int j = 0; j < 505; j++) {\\n                dp[i][j] = INT_MAX/2;\\n            }\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0] = 0;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++) {\\n                dp[i][j] = min(cost[i-1] + dp[i-1][max(0,j-time[i-1]-1) ] , dp[i-1][j] );\\n            }\\n        } \\n        return dp[n][n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][j] = min(cost[i-1] + dp[i-1][max(0,j-time[i-1]-1) ] , dp[i-1][j] );\\n```\n```\\n    dp[i][j] = dp[i-1][j]\\n```\n```\\n    dp[i][j] = cost[i-1] + dp[i-1][max(0,j-time[i-1]-1) ] \\n```\n```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n\\n        for (int i = 0; i < 505; i++) {\\n            for (int j = 0; j < 505; j++) {\\n                dp[i][j] = INT_MAX/2;\\n            }\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0] = 0;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++) {\\n                dp[i][j] = min(cost[i-1] + dp[i-1][max(0,j-time[i-1]-1) ] , dp[i-1][j] );\\n            }\\n        } \\n        return dp[n][n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655230,
                "title": "line-by-line-explanation-for-dummies-like-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind \"m\" walls which take time \"t\" to paint at cost \"c\" such that m+t>=n where n is the total number of walls. \\n\\nReason: In time \"t\", \"m\" walls are painted by the paid guy and \"t\" walls can be painted by the free guy. So t+m is the maximum number of walls that can be painted by both of them combined. This sum is expected to be greater or equal to the total number of walls to arrive at a solution.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nClassic Pick/ Dont Pick problem.\\n\\nPick wall = Paid guy\\nDon\\'t pick wall = Free guy\\n\\nGo through every single wall. Choose the best decision between painting it with the paid guy or free guy. \\n\\n# Complexity\\n- Time complexity: Very big\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Also very big\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n\\n        n = len(cost)\\n        dic = {}\\n\\n        # I am at index i with x walls remaining. What is the best decision i can make at this point?\\n\\n        def pickNoPick(i, c, w, path):\\n            if (i, w) in dic: return dic[(i, w)]+c\\n            # if no walls remain then we have a valid answer\\n            if w<=0: return c\\n            # we reached end of array without any answers\\n            if i==n: return inf\\n            # choose wall \"i\" to be painted by the paid guy\\n            pick = pickNoPick(i+1, c+cost[i], w-time[i]-1, path+[i])\\n            # ignore wall \"i\" to be painted by the free guy\\n            noPick = pickNoPick(i+1, c, w, path)\\n\\n            # best decision cost at index \"i\" with \"w\" walls remaining will be the total cost - cost taken for me to reach \"i\"\\n            dic[(i, w)] = min(pick, noPick)-c\\n            return dic[(i, w)]+c\\n        \\n        x = pickNoPick(0, 0, n, [])\\n\\n        return x\\n```\\n\\n// Inspired by a lot of solutions from the solutions tab, especially RealFan.",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n\\n        n = len(cost)\\n        dic = {}\\n\\n        # I am at index i with x walls remaining. What is the best decision i can make at this point?\\n\\n        def pickNoPick(i, c, w, path):\\n            if (i, w) in dic: return dic[(i, w)]+c\\n            # if no walls remain then we have a valid answer\\n            if w<=0: return c\\n            # we reached end of array without any answers\\n            if i==n: return inf\\n            # choose wall \"i\" to be painted by the paid guy\\n            pick = pickNoPick(i+1, c+cost[i], w-time[i]-1, path+[i])\\n            # ignore wall \"i\" to be painted by the free guy\\n            noPick = pickNoPick(i+1, c, w, path)\\n\\n            # best decision cost at index \"i\" with \"w\" walls remaining will be the total cost - cost taken for me to reach \"i\"\\n            dic[(i, w)] = min(pick, noPick)-c\\n            return dic[(i, w)]+c\\n        \\n        x = pickNoPick(0, 0, n, [])\\n\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654929,
                "title": "python-top-down-dp",
                "content": "# Code\\n```\\nfrom functools import cache\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        @cache\\n        def dfs(i, t):\\n            if t <= 0: return 0\\n            if i == n: return float(\\'inf\\')\\n            return min(dfs(i+1,t), dfs(i+1, t-time[i]-1) + cost[i])\\n        res = dfs(0, n)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        @cache\\n        def dfs(i, t):\\n            if t <= 0: return 0\\n            if i == n: return float(\\'inf\\')\\n            return min(dfs(i+1,t), dfs(i+1, t-time[i]-1) + cost[i])\\n        res = dfs(0, n)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654561,
                "title": "easy-explained-simple-recursive-javascript-solution",
                "content": "**Solution**:\\n    We want paitner1 to paint some walls so that the sum \\'painted walls count\\' and \\'taken time\\' is greater than equal to total walls count. \\n    So if paitner1 paints \\'x\\' walls in \\'t\\' time, then we want to have x+t>=\\'total walls\\'\\n    Because if painter1 paints \\'x\\' walls and takes \\'t\\' time then paitner2 will parallely paint another \\'t\\' walls as he paints 1 wall in 1 unit of time. \\n    So in that case total walls painted will be x+t as x(painted by paitner1)+t(painted by painter2). That\\'s why we want to have x+t>=\\'total walls\\'. And while doing this we want to have minimum cost for patiner1\\n```\\n/**\\n * @param {number[]} cost\\n * @param {number[]} time\\n * @return {number}\\n */\\nvar paintWalls = function(cost, time) {\\n    let memo = new Map();\\n    let ans = knapsack(0,0,0);\\n    return ans;\\n    function knapsack(pos,paintedCount,takenTime){\\n        let output,res1,res2;\\n        //Instead of considering paintedCount and takenTime as different parts, we are taking their sum as part of the key to reduce the dimentions in memoization \\n        let key = pos + \"_\" + (paintedCount + takenTime);\\n        \\n        if(memo.has(key)===true){\\n            return memo.get(key);\\n        }\\n        if((paintedCount+takenTime)>=cost.length){//We have painted enough walls by painter1\\n            output = 0;\\n        }else{\\n            if(pos===cost.length){//We haven\\'t painted enough walls by painter1 and we don\\'t have any more walls now\\n                output = -1;\\n            }else{\\n                //Paint current wall by paitner1\\n                res1 = knapsack(pos+1,paintedCount+1,takenTime+time[pos]);\\n                if(res1!==-1){\\n                    res1+=cost[pos]\\n                }\\n                //Don\\'t paint current wall by paitner1\\n                res2 = knapsack(pos+1,paintedCount,takenTime);\\n                if(res1===-1 && res2===-1){\\n                    output = -1;\\n                }else if(res1===-1){\\n                    output = res2;\\n                }else if(res2===-1){\\n                    output = res1;\\n                }else{\\n                    output = Math.min(res1,res2);\\n                }\\n            }    \\n        }\\n        memo.set(key,output);\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} cost\\n * @param {number[]} time\\n * @return {number}\\n */\\nvar paintWalls = function(cost, time) {\\n    let memo = new Map();\\n    let ans = knapsack(0,0,0);\\n    return ans;\\n    function knapsack(pos,paintedCount,takenTime){\\n        let output,res1,res2;\\n        //Instead of considering paintedCount and takenTime as different parts, we are taking their sum as part of the key to reduce the dimentions in memoization \\n        let key = pos + \"_\" + (paintedCount + takenTime);\\n        \\n        if(memo.has(key)===true){\\n            return memo.get(key);\\n        }\\n        if((paintedCount+takenTime)>=cost.length){//We have painted enough walls by painter1\\n            output = 0;\\n        }else{\\n            if(pos===cost.length){//We haven\\'t painted enough walls by painter1 and we don\\'t have any more walls now\\n                output = -1;\\n            }else{\\n                //Paint current wall by paitner1\\n                res1 = knapsack(pos+1,paintedCount+1,takenTime+time[pos]);\\n                if(res1!==-1){\\n                    res1+=cost[pos]\\n                }\\n                //Don\\'t paint current wall by paitner1\\n                res2 = knapsack(pos+1,paintedCount,takenTime);\\n                if(res1===-1 && res2===-1){\\n                    output = -1;\\n                }else if(res1===-1){\\n                    output = res2;\\n                }else if(res2===-1){\\n                    output = res1;\\n                }else{\\n                    output = Math.min(res1,res2);\\n                }\\n            }    \\n        }\\n        memo.set(key,output);\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3654432,
                "title": "python-hard",
                "content": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        N = len(cost)\\n        \\n        @cache\\n        def calc(t, index):\\n            if t >= N:\\n                return 0\\n\\n            if index >= N:\\n                return float(\"inf\")\\n\\n\\n            ans = float(\"inf\")\\n\\n\\n            ans = min(cost[index] + calc(t + time[index] + 1, index + 1), calc(t, index + 1))\\n\\n            return ans\\n\\n\\n\\n        \\n\\n\\n        return calc(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        N = len(cost)\\n        \\n        @cache\\n        def calc(t, index):\\n            if t >= N:\\n                return 0\\n\\n            if index >= N:\\n                return float(\"inf\")\\n\\n\\n            ans = float(\"inf\")\\n\\n\\n            ans = min(cost[index] + calc(t + time[index] + 1, index + 1), calc(t, index + 1))\\n\\n            return ans\\n\\n\\n\\n        \\n\\n\\n        return calc(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654357,
                "title": "c-dp-no-recursive-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp1[1001];\\n    int dp2[1001];\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        int k, i, j, nn = 2 * n;\\n        for(i = 0; i < n; ++i) {            \\n            if(time[i] > n) time[i] = n;            \\n        }\\n        for (i = 0; i <= nn; ++i) dp1[i] = 500000001, dp2[i] = 500000001;\\n\\n        dp1[n-1] = 0;\\n        dp1[n + time[0]] = cost[0];\\n        dp2[n-1] = 0;\\n        dp2[n + time[0]] = cost[0];\\n        int t;            \\n        for (k = 1; k < n; ++k) {            \\n            for (i = 0; i <= nn; ++i) dp2[i] = 500000001;            \\n            for (i = nn-1; i >= 0; --i) {                \\n                t = i + time[k];\\n                if(t > nn) t = nn;\\n                if(dp2[t] > dp1[i] + cost[k]) dp2[t] = dp1[i] + cost[k];                \\n            }\\n            for (i = 1; i <= nn; ++i) {\\n                if(dp2[i-1] > dp1[i]) dp2[i-1] = dp1[i];                \\n            }                \\n            for (i = 0; i <= nn; ++i) dp1[i] = dp2[i];            \\n        }\\n        \\n        int ans = 500000001;\\n        for (i = n; i <= nn; ++i) {\\n            if(ans > dp1[i]) ans = dp1[i];            \\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp1[1001];\\n    int dp2[1001];\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        int k, i, j, nn = 2 * n;\\n        for(i = 0; i < n; ++i) {            \\n            if(time[i] > n) time[i] = n;            \\n        }\\n        for (i = 0; i <= nn; ++i) dp1[i] = 500000001, dp2[i] = 500000001;\\n\\n        dp1[n-1] = 0;\\n        dp1[n + time[0]] = cost[0];\\n        dp2[n-1] = 0;\\n        dp2[n + time[0]] = cost[0];\\n        int t;            \\n        for (k = 1; k < n; ++k) {            \\n            for (i = 0; i <= nn; ++i) dp2[i] = 500000001;            \\n            for (i = nn-1; i >= 0; --i) {                \\n                t = i + time[k];\\n                if(t > nn) t = nn;\\n                if(dp2[t] > dp1[i] + cost[k]) dp2[t] = dp1[i] + cost[k];                \\n            }\\n            for (i = 1; i <= nn; ++i) {\\n                if(dp2[i-1] > dp1[i]) dp2[i-1] = dp1[i];                \\n            }                \\n            for (i = 0; i <= nn; ++i) dp1[i] = dp2[i];            \\n        }\\n        \\n        int ans = 500000001;\\n        for (i = n; i <= nn; ++i) {\\n            if(ans > dp1[i]) ans = dp1[i];            \\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654305,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    long[,] dp;\\n\\n    public int PaintWalls(int[] cost, int[] time) {\\n        dp = new long[cost.Length + 1, cost.Length + 1];\\n        for (int i = 0; i < dp.GetLength(0); i++) {\\n            for (int j = 0; j < dp.GetLength(1); j++) {\\n                dp[i, j] = -1;\\n            }\\n        }\\n\\n        long res = F(cost, time, 0, 0);\\n        return (int) res;\\n    }\\n\\n    public long F(int[] cost, int[] time, int i, int t) {\\n        if (t >= cost.Length) {\\n            return 0;\\n        }\\n        if (i == cost.Length) {\\n            return int.MaxValue;\\n        }\\n        if (dp[i, t] != -1) {\\n            return dp[i, t];\\n        }\\n\\n        dp[i, t] = Math.Min(cost[i] + F(cost, time, i + 1, t + 1 + time[i]), F(cost, time, i + 1, t));\\n        return dp[i, t];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    long[,] dp;\\n\\n    public int PaintWalls(int[] cost, int[] time) {\\n        dp = new long[cost.Length + 1, cost.Length + 1];\\n        for (int i = 0; i < dp.GetLength(0); i++) {\\n            for (int j = 0; j < dp.GetLength(1); j++) {\\n                dp[i, j] = -1;\\n            }\\n        }\\n\\n        long res = F(cost, time, 0, 0);\\n        return (int) res;\\n    }\\n\\n    public long F(int[] cost, int[] time, int i, int t) {\\n        if (t >= cost.Length) {\\n            return 0;\\n        }\\n        if (i == cost.Length) {\\n            return int.MaxValue;\\n        }\\n        if (dp[i, t] != -1) {\\n            return dp[i, t];\\n        }\\n\\n        dp[i, t] = Math.Min(cost[i] + F(cost, time, i + 1, t + 1 + time[i]), F(cost, time, i + 1, t));\\n        return dp[i, t];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654206,
                "title": "python-3-easy-to-understand-dp-knapsack-solution",
                "content": "\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        dp=[[-1]*(501) for i in range(501)]\\n\\n        def func(cur,remain):\\n            if remain<=0:\\n                return 0\\n\\n            if cur>=len(cost):\\n                return float(\"inf\")\\n            \\n            if dp[cur][remain]!=-1:\\n                return dp[cur][remain]\\n\\n            take=cost[cur]+func(cur+1,remain-time[cur]-1)\\n            notTake=func(cur+1,remain)\\n\\n            dp[cur][remain]=min(take,notTake)\\n\\n            return min(take,notTake)\\n        \\n        return func(0,len(cost))\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        dp=[[-1]*(501) for i in range(501)]\\n\\n        def func(cur,remain):\\n            if remain<=0:\\n                return 0\\n\\n            if cur>=len(cost):\\n                return float(\"inf\")\\n            \\n            if dp[cur][remain]!=-1:\\n                return dp[cur][remain]\\n\\n            take=cost[cur]+func(cur+1,remain-time[cur]-1)\\n            notTake=func(cur+1,remain)\\n\\n            dp[cur][remain]=min(take,notTake)\\n\\n            return min(take,notTake)\\n        \\n        return func(0,len(cost))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654141,
                "title": "c-dp-knapsack-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int rec (vector<int>& cost, vector<int>& time, int index, int walls_rem, int** dp) {\\n        if (walls_rem <= 0) {\\n            return 0;\\n        }\\n        if (index < 0) {\\n            return INT_MAX;\\n        }\\n        if (dp[index][walls_rem] != -1) {\\n            return dp[index][walls_rem];\\n        } \\n        int res1 = rec(cost,  time, index-1, walls_rem-1-time[index], dp);\\n        if (res1 != INT_MAX) {\\n            res1 = cost[index] + res1;\\n        }\\n        int res2 = rec(cost, time, index-1, walls_rem, dp);\\n        dp[index][walls_rem] = min (res1, res2);\\n        return dp[index][walls_rem];\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        int** dp = new int*[n];\\n        for (int i=0;i<n;i++) {\\n            dp[i] = new int[n+1];\\n        }\\n        for (int i=0;i<n;i++) {\\n            for (int j=0;j<=n;j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return rec(cost, time, n-1, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int rec (vector<int>& cost, vector<int>& time, int index, int walls_rem, int** dp) {\\n        if (walls_rem <= 0) {\\n            return 0;\\n        }\\n        if (index < 0) {\\n            return INT_MAX;\\n        }\\n        if (dp[index][walls_rem] != -1) {\\n            return dp[index][walls_rem];\\n        } \\n        int res1 = rec(cost,  time, index-1, walls_rem-1-time[index], dp);\\n        if (res1 != INT_MAX) {\\n            res1 = cost[index] + res1;\\n        }\\n        int res2 = rec(cost, time, index-1, walls_rem, dp);\\n        dp[index][walls_rem] = min (res1, res2);\\n        return dp[index][walls_rem];\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        int** dp = new int*[n];\\n        for (int i=0;i<n;i++) {\\n            dp[i] = new int[n+1];\\n        }\\n        for (int i=0;i<n;i++) {\\n            for (int j=0;j<=n;j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return rec(cost, time, n-1, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654091,
                "title": "100-beast-solution-c",
                "content": "0/1 knapsack based problem:\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &cost,vector<int> &time,int initial_time,int idx,vector<vector<int>> &dp){\\n        \\n         if(initial_time<=0){\\n            return 0;\\n        }\\n\\n        if(idx==cost.size()){\\n            return 1e9;\\n        }\\n        \\n        if(dp[idx][initial_time]!=-1){\\n            return dp[idx][initial_time];\\n        }\\n       \\n        \\n        \\n       int  taken = cost[idx]+solve(cost,time,initial_time-time[idx]-1,idx+1,dp);\\n       int nottaken = solve(cost,time,initial_time,idx+1,dp);\\n        \\n        return   dp[idx][initial_time] = min(taken,nottaken);\\n        \\n    }\\n    \\n    \\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time){\\n        int n = time.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(cost,time,n,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &cost,vector<int> &time,int initial_time,int idx,vector<vector<int>> &dp){\\n        \\n         if(initial_time<=0){\\n            return 0;\\n        }\\n\\n        if(idx==cost.size()){\\n            return 1e9;\\n        }\\n        \\n        if(dp[idx][initial_time]!=-1){\\n            return dp[idx][initial_time];\\n        }\\n       \\n        \\n        \\n       int  taken = cost[idx]+solve(cost,time,initial_time-time[idx]-1,idx+1,dp);\\n       int nottaken = solve(cost,time,initial_time,idx+1,dp);\\n        \\n        return   dp[idx][initial_time] = min(taken,nottaken);\\n        \\n    }\\n    \\n    \\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time){\\n        int n = time.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(cost,time,n,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653927,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long[][]dp;\\n    public int paintWalls(int[] cost, int[] time) {\\n        dp=new long[cost.length+1][cost.length+1];\\n        for(long i[]:dp)\\n            Arrays.fill(i,-1);\\n        long res=f(cost,time,0,0);\\n        return (int)res;\\n    }\\n    public long f(int[]cost, int[]time, int i, int t){\\n        if(t>=cost.length)\\n            return 0;\\n        if(i==cost.length)\\n            return Integer.MAX_VALUE;\\n        if(dp[i][t]!=-1)\\n            return dp[i][t];\\n        \\n        return dp[i][t]=Math.min(cost[i]+f(cost,time,i+1,t+1+time[i]),f(cost,time,i+1,t));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long[][]dp;\\n    public int paintWalls(int[] cost, int[] time) {\\n        dp=new long[cost.length+1][cost.length+1];\\n        for(long i[]:dp)\\n            Arrays.fill(i,-1);\\n        long res=f(cost,time,0,0);\\n        return (int)res;\\n    }\\n    public long f(int[]cost, int[]time, int i, int t){\\n        if(t>=cost.length)\\n            return 0;\\n        if(i==cost.length)\\n            return Integer.MAX_VALUE;\\n        if(dp[i][t]!=-1)\\n            return dp[i][t];\\n        \\n        return dp[i][t]=Math.min(cost[i]+f(cost,time,i+1,t+1+time[i]),f(cost,time,i+1,t));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653886,
                "title": "it-took-a-while-for-me-to-get-it-but-hopefully-it-makes-sense-to-you-100-space-and-time",
                "content": "The way you should go about this is try to think of it based on the number of walls remaining to paint. At the start, there are a total of `cost.length` walls to paint.\\nAt that instance I can start looping through and make a choice of either chosing Painter1 to paint a wall, or skip the wall hoping that I could get Painter 2 to pain it.\\n\\nThis is the key. It is always cheaper to have Painter2 paint a wall. So every time I chose Painter1 to paint, Painter2 paints as well!(He paints the # of walls that is the time it takes for Painter1 to paint a wall).\\n\\n**I\\'ll say that again. Every time Painter1 paints a wall, he will be occupied for `time[index]`. Meaning Painter2 can paint for `time[index]` time => meaning he can paint `time[index]` walls because it takes him 1 unit of time to paint any wall**\\n\\nExample Ignoring the cost for now: time = [3,2,1,1]. If I get Painter1 to paint wall 0, he will be busy for 3 units of time. In that time, I will hire Painter2 to paint 3 walls. Meaning that in 1 choice, I can paint all 4 walls. Painter1 paints 1 and Painter2 paints 3. Hence if I chose Painter1, the remainingWalls can be given by:\\n`numberOfWalls - 1(The house that Painter1 is painting) - time[index](The walls that Painter2 will paint while Painter1 paints the current wall)`\\n\\nHope that made sense. Once it does, the criteria for chosing and not chosing makes sense. \\nAs for notChosing Painter2, take a look at these:\\n\\n```\\nlet saveforP2 = 0 + minCost(index + 1, remWalls, cost, time, memo);\\nif(index == cost.length) return Infinity; // Given too much to P2 to paint\\n```\\n\\nYou will notice that when we don\\'t chose Painter1 to paint, we don\\'t decrement the remaining walls. This is because Painter2 cannot paint until Painter1 is occupied. So in a way you can think of skipping over the current index as saving a wall we think would be better for Painter2 to paint. If we somehow get to the end, it means we\\'ve assigned too many walls to Painter2 which should be impossible so we return infinity.\\n\\n\\n```\\nvar paintWalls = function(cost, time) {\\n  let memo = {};\\n  return minCost(0, cost.length, cost, time, memo);\\n};\\n\\nconst minCost = (index, remWalls, cost, time, memo) => {\\n  if(remWalls <= 0) return 0; // painted all walls\\n  if(index == cost.length) return Infinity; // Given too much to P2 to paint\\n  \\n  if(`${index}-${remWalls}` in memo) return memo[`${index}-${remWalls}`];\\n  \\n  let choseP1 = cost[index] + minCost(index + 1, remWalls - 1 - time[index], cost, time, memo);\\n  let saveforP2 = 0 + minCost(index + 1, remWalls, cost, time, memo);\\n  \\n  memo[`${index}-${remWalls}`] = Math.min(choseP1, saveforP2);\\n  return memo[`${index}-${remWalls}`];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlet saveforP2 = 0 + minCost(index + 1, remWalls, cost, time, memo);\\nif(index == cost.length) return Infinity; // Given too much to P2 to paint\\n```\n```\\nvar paintWalls = function(cost, time) {\\n  let memo = {};\\n  return minCost(0, cost.length, cost, time, memo);\\n};\\n\\nconst minCost = (index, remWalls, cost, time, memo) => {\\n  if(remWalls <= 0) return 0; // painted all walls\\n  if(index == cost.length) return Infinity; // Given too much to P2 to paint\\n  \\n  if(`${index}-${remWalls}` in memo) return memo[`${index}-${remWalls}`];\\n  \\n  let choseP1 = cost[index] + minCost(index + 1, remWalls - 1 - time[index], cost, time, memo);\\n  let saveforP2 = 0 + minCost(index + 1, remWalls, cost, time, memo);\\n  \\n  memo[`${index}-${remWalls}`] = Math.min(choseP1, saveforP2);\\n  return memo[`${index}-${remWalls}`];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653081,
                "title": "faster-than-100-of-the-c-solution-best-solution-possible-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif we take a subsequence whose summation of time[i] becomes greater than size of array then we can always do all the work in that particular time.so we just need to choose different elements such that summation of cost[i] becomes minimum while our total time is less than size of array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nfaster than 100% of the solution\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>&arr,vector<int>&time,int idx,int ct,int n,vector<vector<int>>&dp){\\n        if(ct>=n) return 0;\\n        if(idx==n){\\n            if(ct>=n) return 0;\\n            return INT_MAX/2;\\n        }\\n        if(dp[idx][ct]!=-1) return dp[idx][ct];\\n        int not_take=f(arr,time,idx+1,ct,n,dp);\\n        int val=ct+1+time[idx];\\n        if(val>=n) val=n;\\n        int take=arr[idx]+f(arr,time,idx+1,val,n,dp);\\n        return dp[idx][ct]=min(take,not_take);\\n    }\\n    int paintWalls(vector<int>&arr, vector<int>& time) {\\n        int n=arr.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans=f(arr,time,0,0,n,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int>&arr,vector<int>&time,int idx,int ct,int n,vector<vector<int>>&dp){\\n        if(ct>=n) return 0;\\n        if(idx==n){\\n            if(ct>=n) return 0;\\n            return INT_MAX/2;\\n        }\\n        if(dp[idx][ct]!=-1) return dp[idx][ct];\\n        int not_take=f(arr,time,idx+1,ct,n,dp);\\n        int val=ct+1+time[idx];\\n        if(val>=n) val=n;\\n        int take=arr[idx]+f(arr,time,idx+1,val,n,dp);\\n        return dp[idx][ct]=min(take,not_take);\\n    }\\n    int paintWalls(vector<int>&arr, vector<int>& time) {\\n        int n=arr.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans=f(arr,time,0,0,n,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652904,
                "title": "dfs-without-tricks",
                "content": "```cpp\\nclass Solution {\\n    int dfs(vector<int>& cost, vector<int>& time, int i, int r, vector<vector<int>>& dp)\\n    {\\n        // good end case: every wall is painted.\\n        if (r <= 0)\\n            return 0;\\n\\n        // bad end case: there are no more time slots.\\n        if (i < 0)\\n            return 1e9;\\n\\n        if (dp[i][r])\\n            return dp[i][r];\\n\\n        // case 1: we dont let paid painter paint this wall, \\n        int dont = dfs(cost, time, i - 1, r, dp);\\n\\n        // case 2: we do let paid painter paint this wall, \\n        //      the paid painter will paint 1 wall\\n        //      the free painter will paint time[i] walls\\n        int take = dfs(cost, time, i - 1, r - time[i] - 1, dp) + cost[i];\\n\\n        return dp[i][r] = min(take, dont);\\n    }\\n\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n, vector<int>(n + 1));\\n\\n        return dfs(cost, time, n - 1, n, dp);\\n    }\\n};\\n```\\n\\n## For those who might prefer button-up dp.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 1e9));\\n        dp[0][0] = 0;\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            dp[i + 1][0] = 0;\\n\\n            for (int r = 1; r <= n; ++r)\\n                dp[i + 1][r] = min(dp[i][r], dp[i][max(r - time[i] - 1, 0)] + cost[i]);\\n        }\\n\\n        return dp[n][n];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\n    int dfs(vector<int>& cost, vector<int>& time, int i, int r, vector<vector<int>>& dp)\\n    {\\n        // good end case: every wall is painted.\\n        if (r <= 0)\\n            return 0;\\n\\n        // bad end case: there are no more time slots.\\n        if (i < 0)\\n            return 1e9;\\n\\n        if (dp[i][r])\\n            return dp[i][r];\\n\\n        // case 1: we dont let paid painter paint this wall, \\n        int dont = dfs(cost, time, i - 1, r, dp);\\n\\n        // case 2: we do let paid painter paint this wall, \\n        //      the paid painter will paint 1 wall\\n        //      the free painter will paint time[i] walls\\n        int take = dfs(cost, time, i - 1, r - time[i] - 1, dp) + cost[i];\\n\\n        return dp[i][r] = min(take, dont);\\n    }\\n\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n, vector<int>(n + 1));\\n\\n        return dfs(cost, time, n - 1, n, dp);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 1e9));\\n        dp[0][0] = 0;\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            dp[i + 1][0] = 0;\\n\\n            for (int r = 1; r <= n; ++r)\\n                dp[i + 1][r] = min(dp[i][r], dp[i][max(r - time[i] - 1, 0)] + cost[i]);\\n        }\\n\\n        return dp[n][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652697,
                "title": "beats-100-0-1-knapsack",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n^2)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    int knapsack(int i, int remainingWalls, vector<int>& cost, vector<int>& time, vector<vector<int>>& dp)\\n    {\\n        if(remainingWalls <= 0) return 0;\\n        if(i >= cost.size()) return 1e9;\\n        if(dp[i][remainingWalls] != -1) return dp[i][remainingWalls];\\n\\n        int take = cost[i] + knapsack(i+1,remainingWalls - time[i] - 1,cost,time,dp);\\n        int notTake = knapsack(i+1,remainingWalls,cost,time,dp);\\n        return dp[i][remainingWalls] = min(take,notTake);\\n    }\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return knapsack(0,n,cost,time,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int knapsack(int i, int remainingWalls, vector<int>& cost, vector<int>& time, vector<vector<int>>& dp)\\n    {\\n        if(remainingWalls <= 0) return 0;\\n        if(i >= cost.size()) return 1e9;\\n        if(dp[i][remainingWalls] != -1) return dp[i][remainingWalls];\\n\\n        int take = cost[i] + knapsack(i+1,remainingWalls - time[i] - 1,cost,time,dp);\\n        int notTake = knapsack(i+1,remainingWalls,cost,time,dp);\\n        return dp[i][remainingWalls] = min(take,notTake);\\n    }\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return knapsack(0,n,cost,time,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652616,
                "title": "296ms-solution-c-dp-100-fast-short-lines-of-code-easy-to-understand",
                "content": "TC - O(n*n) \\nSC- O(n* n) \\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>v;\\n    vector<vector<int>>dp;\\n   \\n    int rec(int i, int t){\\n   \\n        t=min(t,(int)v.size());\\n     if(i==v.size()&&t>=(v.size()))\\n            \\n            return 0;\\n        if(i==v.size())\\n            return 1e9;\\n        if(dp[i][t]!=-1)\\n      return dp[i][t];\\n        int ans=rec(i+1,t);\\n        //cout<<ans<<\",\";\\n        ans=min(ans,rec(i+1,t+v[i].second+1)+v[i].first);\\n            \\n        //cout<<ans<<\" \";\\n        return dp[i][t]=ans;\\n     }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n       \\n        for(int i=0;i<cost.size();i++){\\n            \\n            v.push_back({cost[i],time[i]});\\n            \\n         }\\n     sort(v.begin(),v.end());\\n   \\n        dp.resize(v.size(), vector<int>(v.size()+2,-1));\\n        int ans=rec(0,0);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>v;\\n    vector<vector<int>>dp;\\n   \\n    int rec(int i, int t){\\n   \\n        t=min(t,(int)v.size());\\n     if(i==v.size()&&t>=(v.size()))\\n            \\n            return 0;\\n        if(i==v.size())\\n            return 1e9;\\n        if(dp[i][t]!=-1)\\n      return dp[i][t];\\n        int ans=rec(i+1,t);\\n        //cout<<ans<<\",\";\\n        ans=min(ans,rec(i+1,t+v[i].second+1)+v[i].first);\\n            \\n        //cout<<ans<<\" \";\\n        return dp[i][t]=ans;\\n     }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n       \\n        for(int i=0;i<cost.size();i++){\\n            \\n            v.push_back({cost[i],time[i]});\\n            \\n         }\\n     sort(v.begin(),v.end());\\n   \\n        dp.resize(v.size(), vector<int>(v.size()+2,-1));\\n        int ans=rec(0,0);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3652429,
                "title": "c-and-java-memoization-knapsack-problem-with-complete-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhe problem is simple if we assume it as a knapsack variation we have two choices for every wall whether to paint it using a paid painter incurring cost[ind] or not to paint the current wall assuming that free painter will do it if he will get some idle time .\\nNow if a apaid painter is busy in painting some walls taking t time (overall) then we can get atmost t more walls painted by free painter taking 1 unit of time to each wall.So if at the end of assigning walls to paid painters and free painters if time for which free painter is busy say(t_p) >= no of walls left for free painter(n_p) then that can be a possible way of painting the walls and contribute to a valid answer otherwse some INF positive cost can be returned indicating invalid distribution.\\nnow optimizations can be done by dp approach here a state dp[i][j]-> can be identified as i index till which the walls has been painted and j indicating the remaining idle walls which can not be painted by paid or free painter as well.(t_p-n_p)->these many no walls can also be painted by the free painter if assigned to him.\\nnow some how if t_p has reached >=500 which is the upperbound of n<=500 therefore all the remaining walls (if any) can definately be painted by free painter.Since we are interested in the min cost so we will assume other walls to be done by free painter and no more cost will be spent thus we can safely return 0.Now t_p->atmost 500 and n_p-> at most 500 case t_p->0 and n_p->500 not painting all the walls so our dp table must be able to hold the diff values from -500->500 for that the diff par can be shifted 500tow right like dp[ind][diff+500] with size as dp[500][1001]  to hold for every possible case and now we can eassily code it up. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n) at most->5 x 1e5\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n5 x 1e5\\n\\n\\n**PLS UPVOTE IF IT HELPED**\\n# c++\\n```\\nclass Solution {\\npublic:\\n    int dp[500][1001];\\n    int f(int ind,int n,vector<int>& cost, vector<int>& time,int n_p,int t_p){\\n        if(ind==n){\\n            if(t_p>=n_p) return 0;\\n            else return 1e9;\\n        }\\n        if(t_p>=n) return 0;\\n        if(dp[ind][t_p-n_p+500]!=-1) return dp[ind][t_p-n_p+500];\\n        \\n        return dp[ind][t_p-n_p+500]=min(cost[ind]+f(ind+1,n,cost,time,n_p,t_p+time[ind]),f(ind+1,n,cost,time,n_p+1,t_p));\\n            \\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,n,cost,time,0,0);\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    int dp[][]=new int[500][1001];\\n    public int f(int ind,int n,int[] cost,int[] time,int n_p,int t_p){\\n        if(ind==n){\\n            if(t_p>=n_p) return 0;\\n            else return 1000000000;\\n        }\\n        if(t_p>=n) return 0;\\n        if(dp[ind][t_p-n_p+500]>0) return dp[ind][t_p-n_p+500]-1;\\n        int ans=Math.min(cost[ind]+f(ind+1,n,cost,time,n_p,t_p+time[ind]),f(ind+1,n,cost,time,n_p+1,t_p));\\n        dp[ind][t_p-n_p+500]=ans+1;\\n        return ans;\\n            \\n    }\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n=cost.length;\\n        return f(0,n,cost,time,0,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500][1001];\\n    int f(int ind,int n,vector<int>& cost, vector<int>& time,int n_p,int t_p){\\n        if(ind==n){\\n            if(t_p>=n_p) return 0;\\n            else return 1e9;\\n        }\\n        if(t_p>=n) return 0;\\n        if(dp[ind][t_p-n_p+500]!=-1) return dp[ind][t_p-n_p+500];\\n        \\n        return dp[ind][t_p-n_p+500]=min(cost[ind]+f(ind+1,n,cost,time,n_p,t_p+time[ind]),f(ind+1,n,cost,time,n_p+1,t_p));\\n            \\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,n,cost,time,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int dp[][]=new int[500][1001];\\n    public int f(int ind,int n,int[] cost,int[] time,int n_p,int t_p){\\n        if(ind==n){\\n            if(t_p>=n_p) return 0;\\n            else return 1000000000;\\n        }\\n        if(t_p>=n) return 0;\\n        if(dp[ind][t_p-n_p+500]>0) return dp[ind][t_p-n_p+500]-1;\\n        int ans=Math.min(cost[ind]+f(ind+1,n,cost,time,n_p,t_p+time[ind]),f(ind+1,n,cost,time,n_p+1,t_p));\\n        dp[ind][t_p-n_p+500]=ans+1;\\n        return ans;\\n            \\n    }\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n=cost.length;\\n        return f(0,n,cost,time,0,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652366,
                "title": "python-dp",
                "content": "# Intuition\\nNo intuition at all, just guess with trial and error, problem statement failed to explain purpose of time.\\nProbably optimization problem with objective to minimize cost, not clear about purpose of time!\\n\\n# Complexity\\n- Time complexity:\\n$$O(NT)$$\\n\\n- Space complexity:\\n$$O(NT)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        @cache\\n        def dp(i, t):\\n            if t >= len(time): return 0\\n            if i == len(cost): return inf\\n            return min(dp(i + 1, t), dp(i + 1, t + time[i] + 1) + cost[i])\\n        return dp(0, 0)\\n```dyn",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        @cache\\n        def dp(i, t):\\n            if t >= len(time): return 0\\n            if i == len(cost): return inf\\n            return min(dp(i + 1, t), dp(i + 1, t + time[i] + 1) + cost[i])\\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652361,
                "title": "offset-based-knapsack-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy to understand Knapsack DP \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nchoose 500 as an offset for better clarity and apply normal knapsack dp of choosing or ignoring \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int> & cost, vector<vector<int>> & dp, vector<int> & time, int i, int curr) {\\n        if(i == cost.size()) {\\n            if(curr < 500) {\\n                return 1e9;\\n            }\\n            return 0;\\n        }\\n        \\n        if(dp[i][curr] != -1) {\\n            return dp[i][curr];\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        // donate for free.\\n        ans = min(ans, findMin(cost, dp, time, i + 1, curr - 1));\\n        // use paid one.\\n        ans = min(ans, cost[i] + findMin(cost, dp, time, i + 1, min(curr + time[i], 1000)));\\n        return dp[i][curr] = ans;\\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<vector<int>> dp(500, vector<int>(1001, -1));\\n        return findMin(cost, dp, time, 0, 500);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int> & cost, vector<vector<int>> & dp, vector<int> & time, int i, int curr) {\\n        if(i == cost.size()) {\\n            if(curr < 500) {\\n                return 1e9;\\n            }\\n            return 0;\\n        }\\n        \\n        if(dp[i][curr] != -1) {\\n            return dp[i][curr];\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        // donate for free.\\n        ans = min(ans, findMin(cost, dp, time, i + 1, curr - 1));\\n        // use paid one.\\n        ans = min(ans, cost[i] + findMin(cost, dp, time, i + 1, min(curr + time[i], 1000)));\\n        return dp[i][curr] = ans;\\n    }\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<vector<int>> dp(500, vector<int>(1001, -1));\\n        return findMin(cost, dp, time, 0, 500);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652343,
                "title": "java-0-1-knapsack-dp-simple-and-easy-to-understand-solution-recursive-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length;\\n        dp = new int[n+1][n+1];\\n        return solve(cost,time,0,n);\\n    }\\n\\n    public int solve(int[] cost, int[] time, int currWall, int noOfWallRemaining){ \\n        if(noOfWallRemaining<=0){\\n            return 0;\\n        }\\n        if(currWall>=cost.length){\\n            return 1000000000;\\n        }\\n        if(dp[currWall][noOfWallRemaining]!= 0) {\\n            return dp[currWall][noOfWallRemaining];\\n        }\\n        int notTake = solve(cost, time, currWall+1, noOfWallRemaining);\\n        int take = cost[currWall] + solve(cost, time,currWall+1, noOfWallRemaining - time[currWall]-1);\\n        return dp[currWall][noOfWallRemaining] = Math.min(take, notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length;\\n        dp = new int[n+1][n+1];\\n        return solve(cost,time,0,n);\\n    }\\n\\n    public int solve(int[] cost, int[] time, int currWall, int noOfWallRemaining){ \\n        if(noOfWallRemaining<=0){\\n            return 0;\\n        }\\n        if(currWall>=cost.length){\\n            return 1000000000;\\n        }\\n        if(dp[currWall][noOfWallRemaining]!= 0) {\\n            return dp[currWall][noOfWallRemaining];\\n        }\\n        int notTake = solve(cost, time, currWall+1, noOfWallRemaining);\\n        int take = cost[currWall] + solve(cost, time,currWall+1, noOfWallRemaining - time[currWall]-1);\\n        return dp[currWall][noOfWallRemaining] = Math.min(take, notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651934,
                "title": "easy-solution-similar-to-0-1-knapsack-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    \\n     int solve(vector<int>&cost,vector<int>&time,int currId,int remG,vector<vector<int>>&dp){\\n          //base case//////////*****************IMPortamt firdtly check if remaing <=0 then return 0 then check if at  reM>0 && currId at last return max value\\n           if(remG<=0)return 0;// no cost required for painting  as remaining walls are less than equal 0\\n          if(currId>=cost.size())return INT_MAX;\\n         \\n         \\n         \\n          //////already computed\\n         if(dp[currId][remG]!=-1){   // cout<<\"come again at \"<<currId<<\" \"<<remG;\\n             return dp[currId][remG];\\n          \\n         }\\n         \\n         //take it \\n         int take_cost=0;\\n         int curr_Cost=cost[currId];\\n         int afterTake_Cost = solve( cost,time,currId+1,remG-1-time[currId],dp);// time[currId ]_mein free painter paints the time[i] walls\\n         if(afterTake_Cost==INT_MAX){\\n             take_cost=INT_MAX;\\n         }\\n         else{\\n             take_cost = afterTake_Cost+curr_Cost;\\n         }\\n         //not take it\\n         int after_not_take_Cost=solve(cost ,time , currId+1,remG,dp);\\n         \\n         int totalCost=min(take_cost,after_not_take_Cost);\\n       //  cout<<\"MIN COst \"<<\" is \"<<\" for \"<<currId<<\" and remG is \"<<remG<<\" \"<<totalCost<<endl;\\n         return dp[currId][remG]=totalCost;\\n     }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        \\n       return solve(cost,time,0,n,dp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    \\n     int solve(vector<int>&cost,vector<int>&time,int currId,int remG,vector<vector<int>>&dp){\\n          //base case//////////*****************IMPortamt firdtly check if remaing <=0 then return 0 then check if at  reM>0 && currId at last return max value\\n           if(remG<=0)return 0;// no cost required for painting  as remaining walls are less than equal 0\\n          if(currId>=cost.size())return INT_MAX;\\n         \\n         \\n         \\n          //////already computed\\n         if(dp[currId][remG]!=-1){   // cout<<\"come again at \"<<currId<<\" \"<<remG;\\n             return dp[currId][remG];\\n          \\n         }\\n         \\n         //take it \\n         int take_cost=0;\\n         int curr_Cost=cost[currId];\\n         int afterTake_Cost = solve( cost,time,currId+1,remG-1-time[currId],dp);// time[currId ]_mein free painter paints the time[i] walls\\n         if(afterTake_Cost==INT_MAX){\\n             take_cost=INT_MAX;\\n         }\\n         else{\\n             take_cost = afterTake_Cost+curr_Cost;\\n         }\\n         //not take it\\n         int after_not_take_Cost=solve(cost ,time , currId+1,remG,dp);\\n         \\n         int totalCost=min(take_cost,after_not_take_Cost);\\n       //  cout<<\"MIN COst \"<<\" is \"<<\" for \"<<currId<<\" and remG is \"<<remG<<\" \"<<totalCost<<endl;\\n         return dp[currId][remG]=totalCost;\\n     }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n=cost.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        \\n       return solve(cost,time,0,n,dp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3651755,
                "title": "python-3-dp-super-clean-and-short-code",
                "content": "# Intuition\\nDP top down, by array index and rest time `t`.\\n\\n# Approach\\nLet\\'s check the constraint:\\n```\\n1 <= time[i] <= 500\\n```\\nWhich means `t` range could be really large if we always add them together. (500 * 500)\\nWe should handle `t` carefully otherwise we will get memory error. (n * 500 * 500 = 500 ** 3 ~= 125,000,000)\\n\\nBut remember, there are at most 500 free painters and free painters only spends 1 unit of time on painting the wall.\\n```\\n1 <= cost.length <= 500\\n```\\nSo we can set min(time, 500) to reduce the `t` complexity to 500\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n * n)\\n\\n- Space complexity:\\nO(n * 500)\\n\\n# Code\\n```py3\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        @cache\\n        def solve(index, t):\\n            # base case\\n            if index == n:\\n                # t >= 0, find a valid case\\n                # t < 0, invalid case\\n                return 0 if t >= 0 else inf\\n            # Prune the cases: if you have enough time, you can ask free painter to paint rest of the wall.\\n            if t >= n - index:\\n                return 0\\n            # option 1: Paid painter, set t + time[index] and add cost\\n            # option 2: Free painter, t - 1\\n            return min(\\n                # To reduce t complexity, we should set min(newT, 500)\\n                solve(index + 1, min(t + time[index], 500)) + cost[index],\\n                solve(index + 1, t - 1),\\n            )\\n        # From first index and default t is 0\\n        return solve(0, 0)\\n```\\n\\n\\u2B50\\uFE0F Hope this article can help you, Thanks. \\u2B50\\uFE0F",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n1 <= time[i] <= 500\\n```\n```\\n1 <= cost.length <= 500\\n```\n```py3\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        @cache\\n        def solve(index, t):\\n            # base case\\n            if index == n:\\n                # t >= 0, find a valid case\\n                # t < 0, invalid case\\n                return 0 if t >= 0 else inf\\n            # Prune the cases: if you have enough time, you can ask free painter to paint rest of the wall.\\n            if t >= n - index:\\n                return 0\\n            # option 1: Paid painter, set t + time[index] and add cost\\n            # option 2: Free painter, t - 1\\n            return min(\\n                # To reduce t complexity, we should set min(newT, 500)\\n                solve(index + 1, min(t + time[index], 500)) + cost[index],\\n                solve(index + 1, t - 1),\\n            )\\n        # From first index and default t is 0\\n        return solve(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651726,
                "title": "simple-explanation-in-hindi-top-down-dp-memoization-o-n-n",
                "content": "# Intuition\\n**Observation 1 :-**\\nPaid -> **X time -> 1 wall** paint krega\\nFree -> **X time -> X wall** paint (but free wala akele kabhi kam nhi karega usko paid wala sath me chahiye)\\nab jab ye paid wala paint kr rha hai apan free wale ko bhi lga denge kaam me exactly same time pe to jab\\ntak paid wala X time me 1 wall paint krega free wala X time me X wall paint kr dega\\n\\n**Free working time  <= Paid working time**\\nfree wala paid ke sath hi kaam krega to vo kabhi paid se jyada kaam kr hi nhi sakta\\n\\n**Observation 2 :-** Constraints on the length of input array\\n**1 <= cost.length <= 500 (10^3 ke range me jab input array ho tab ek baari dp sochne ka kosis kro)**\\ndekho dp agar fit ho rhi hai constraint me (to kya burai hai lga do dp) wrong answer ka lafda hi nhi bcoz dp\\nsabhi choices me se best choice leke aata hai tumhare liye.\\n\\n\\n# Approach\\nlength of the input array to **dp ki one of the state rhegi** (In most of the cases).\\napne paas 2 choices hai ya to wall free me paint hogi ya to phir paid\\npaid ke case me apne ko free time milega (increase hoga)\\nfree ke case me ye free time decrease hoga.\\n\\ndp(n , k) ->  minimum cost to paint n walls with k free walls paint.\\n\\n![image.png](https://assets.leetcode.com/users/images/000babe9-3121-479d-9040-69a322bc4d12_1687077615.3987541.png)\\n\\n\\n# Complexity\\n- Time complexity: O(n * free_walls) = O(n^2)\\n- 1 <= n <= 500\\n-n <= free_walls <= n (kyonki agar apne pass free_walls >= n hai to aap sedhe saare bache hue walls free me paint kr do)\\nnegative index se deal krne ke liye apan ek offset value add kr skte hai like +n before quering into the memo table (other wise runtime error)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][1010];\\n    int rec(int n , int free_walls , vector<int> & cost , vector<int> & time) {\\n        if(n <= free_walls) {\\n            return 0;\\n        }\\n        else if(n == 0) {\\n            if(free_walls >= 0) {\\n                return 0;\\n            }\\n            else {\\n                return 1e9;\\n            }\\n        }\\n        int &ans = dp[n][free_walls+500];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n\\n        return ans = min(rec(n-1 , free_walls - 1 , cost , time) , cost[n-1] + rec(n-1 , free_walls + time[n-1] , cost , time));\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = (int)cost.size();\\n        memset(dp , -1 , sizeof(dp));\\n        return rec(n , 0 , cost , time);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][1010];\\n    int rec(int n , int free_walls , vector<int> & cost , vector<int> & time) {\\n        if(n <= free_walls) {\\n            return 0;\\n        }\\n        else if(n == 0) {\\n            if(free_walls >= 0) {\\n                return 0;\\n            }\\n            else {\\n                return 1e9;\\n            }\\n        }\\n        int &ans = dp[n][free_walls+500];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n\\n        return ans = min(rec(n-1 , free_walls - 1 , cost , time) , cost[n-1] + rec(n-1 , free_walls + time[n-1] , cost , time));\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = (int)cost.size();\\n        memset(dp , -1 , sizeof(dp));\\n        return rec(n , 0 , cost , time);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651636,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost, time):\\n        n = len(cost)\\n\\n        @lru_cache(None)\\n        def dfs(i,t):\\n            if i == n:\\n                return 0 if t >= 0 else float(\"inf\")\\n\\n            min_val = cost[i] + dfs(i+1,min(n+1,t+time[i]))\\n\\n            min_val = min(min_val,dfs(i+1,t-1))\\n\\n            return min_val\\n\\n        return dfs(0,0)\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost, time):\\n        n = len(cost)\\n\\n        @lru_cache(None)\\n        def dfs(i,t):\\n            if i == n:\\n                return 0 if t >= 0 else float(\"inf\")\\n\\n            min_val = cost[i] + dfs(i+1,min(n+1,t+time[i]))\\n\\n            min_val = min(min_val,dfs(i+1,t-1))\\n\\n            return min_val\\n\\n        return dfs(0,0)\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651614,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int memo[501][501] ;\\n    vector<int> cost ;\\n    vector<int> time ;\\n    int n ;\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        this->n= cost.size() ;\\n        vector<vector<int>>memo(n, vector<int>(n+1, -1)) ;\\n        this->cost = cost ;\\n        this->time = time ;\\n        return dfs(0, n, memo) ;\\n    }\\n    int dfs(int cur, int leftWall, vector<vector<int>>&memo){\\n        if(leftWall <= 0)\\n            return 0 ;\\n        if(cur == n)\\n            return 1e9 ;\\n        if(memo[cur][leftWall] != -1)\\n            return memo[cur][leftWall] ;\\n        int paid = cost[cur] + dfs(cur+1, leftWall-1-time[cur], memo) ;\\n        int noPaid = dfs(cur+1, leftWall, memo) ;\\n        memo[cur][leftWall] = min(paid, noPaid) ;\\n        return memo[cur][leftWall] ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int memo[501][501] ;\\n    vector<int> cost ;\\n    vector<int> time ;\\n    int n ;\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        this->n= cost.size() ;\\n        vector<vector<int>>memo(n, vector<int>(n+1, -1)) ;\\n        this->cost = cost ;\\n        this->time = time ;\\n        return dfs(0, n, memo) ;\\n    }\\n    int dfs(int cur, int leftWall, vector<vector<int>>&memo){\\n        if(leftWall <= 0)\\n            return 0 ;\\n        if(cur == n)\\n            return 1e9 ;\\n        if(memo[cur][leftWall] != -1)\\n            return memo[cur][leftWall] ;\\n        int paid = cost[cur] + dfs(cur+1, leftWall-1-time[cur], memo) ;\\n        int noPaid = dfs(cur+1, leftWall, memo) ;\\n        memo[cur][leftWall] = min(paid, noPaid) ;\\n        return memo[cur][leftWall] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651573,
                "title": "c-simple-solution-using-recursion-memoization",
                "content": "# Intuition\\nThink in the direction of Knapsack problem. For each `i-th` index either paid painter will paint and it will cost us `cost[i]` and free painter will be `time[i]` number of walls or paid painter will skip `i-th` wall.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Video Explanation\\nWatch my youtube video to understand the intution, approach and solution.\\n[https://youtu.be/XnD_zbzrLkg]()\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(int walls,int idx,vector<int> &cost, vector<int> &time)\\n    {\\n        if(walls <= 0)\\n        {\\n            return 0;\\n        }\\n        if(idx == cost.size())\\n        {\\n            return 1e9;\\n        }\\n        if(dp[idx][walls] != -1)\\n        {\\n            return dp[idx][walls];\\n        }\\n        int a = solve(walls, idx+1, cost, time);\\n        int b = cost[idx] + solve(walls - time[idx] - 1, idx+1, cost, time);\\n        return dp[idx][walls] = min(a,b);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(cost.size(), 0, cost,time);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(int walls,int idx,vector<int> &cost, vector<int> &time)\\n    {\\n        if(walls <= 0)\\n        {\\n            return 0;\\n        }\\n        if(idx == cost.size())\\n        {\\n            return 1e9;\\n        }\\n        if(dp[idx][walls] != -1)\\n        {\\n            return dp[idx][walls];\\n        }\\n        int a = solve(walls, idx+1, cost, time);\\n        int b = cost[idx] + solve(walls - time[idx] - 1, idx+1, cost, time);\\n        return dp[idx][walls] = min(a,b);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(cost.size(), 0, cost,time);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651533,
                "title": "my-solutions",
                "content": "**1. Use the DP `i`**\\n```\\n/**\\n * dp solution is employed\\n * dp[i][j] stands for the minimum amount of money required when the paid painter\\n *                     have handled (paint or not paint) the walls\\n *                     from the index 0 to the index (`i` - 1), and\\n *                     at least `j` walls have been painted\\n * when the wall of the index `i` is handled by the paid painter, there exist two options,\\n * 1. don\\'t paint it\\n *    dp[i + 1][j] = dp[i][j]\\n * 2. paint it\\n *    dp[i + 1][j] = cost[i] + dp[i][j - time[i] - 1]\\n *\\n * initial:\\n * dp[0][0] = 0\\n *\\n * induction:\\n * dp[i][j] = min(dp[i - 1][j], cost[i - 1] + dp[i - 1][j - time[i - 1] - 1])\\n *\\n * target:\\n * dp[n][n]\\n *\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `cost`, that is the number of walls which need painting\\n */\\nclass Solution {\\n public:\\n  int paintWalls(const vector<int> &cost, const vector<int> &time) {\\n    constexpr uint32_t invalid_cost = -1;\\n    constexpr int range = 2;\\n    const int n = static_cast<int>(cost.size());\\n    uint32_t dp[range][n + 1];\\n    memset(dp, invalid_cost, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = 0;\\n    for (int i = 0; i < n; ++i) {\\n      for (int walls = 0; walls < n + 1; ++walls) {\\n        dp[current][walls] = min(dp[current][walls], dp[previous][walls]);\\n        if (dp[previous][max(0, walls - time[i] - 1)] != invalid_cost) {\\n          dp[current][walls] = min(dp[current][walls], cost[i] + dp[previous][max(0, walls - time[i] - 1)]);\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], invalid_cost, sizeof(dp[current]));\\n    }\\n    \\n    return static_cast<int>(dp[previous][n]);\\n  }\\n};\\n```\\n**2. Use the DP `ii`, the same idea with `1`**\\n```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `cost`, that is the number of walls which need painting\\n */\\nclass Solution {\\n public:\\n  int paintWalls(const vector<int> &cost, const vector<int> &time) {\\n    constexpr uint32_t invalid_cost = -1;\\n    constexpr int range = 2;\\n    const int n = static_cast<int>(cost.size());\\n    uint32_t dp[range][n + 1];\\n    memset(dp, invalid_cost, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = 0;\\n    for (int i = 0; i < n; ++i) {\\n      for (int walls = 0; walls < n + 1; ++walls) {\\n        if (dp[previous][walls] == invalid_cost) {\\n          continue;\\n        }\\n        \\n        // the paid painter doesn\\'t paint it\\n        dp[current][walls] = min(dp[current][walls], dp[previous][walls]);\\n        \\n        // the paid painter paints it\\n        const int next_walls = min(n, walls + time[i] + 1);\\n        dp[current][next_walls] = min(dp[current][next_walls], dp[previous][walls] + cost[i]);\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], -1, sizeof(dp[current]));\\n    }\\n    \\n    return static_cast<int>(dp[previous][n]);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * dp solution is employed\\n * dp[i][j] stands for the minimum amount of money required when the paid painter\\n *                     have handled (paint or not paint) the walls\\n *                     from the index 0 to the index (`i` - 1), and\\n *                     at least `j` walls have been painted\\n * when the wall of the index `i` is handled by the paid painter, there exist two options,\\n * 1. don\\'t paint it\\n *    dp[i + 1][j] = dp[i][j]\\n * 2. paint it\\n *    dp[i + 1][j] = cost[i] + dp[i][j - time[i] - 1]\\n *\\n * initial:\\n * dp[0][0] = 0\\n *\\n * induction:\\n * dp[i][j] = min(dp[i - 1][j], cost[i - 1] + dp[i - 1][j - time[i - 1] - 1])\\n *\\n * target:\\n * dp[n][n]\\n *\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `cost`, that is the number of walls which need painting\\n */\\nclass Solution {\\n public:\\n  int paintWalls(const vector<int> &cost, const vector<int> &time) {\\n    constexpr uint32_t invalid_cost = -1;\\n    constexpr int range = 2;\\n    const int n = static_cast<int>(cost.size());\\n    uint32_t dp[range][n + 1];\\n    memset(dp, invalid_cost, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = 0;\\n    for (int i = 0; i < n; ++i) {\\n      for (int walls = 0; walls < n + 1; ++walls) {\\n        dp[current][walls] = min(dp[current][walls], dp[previous][walls]);\\n        if (dp[previous][max(0, walls - time[i] - 1)] != invalid_cost) {\\n          dp[current][walls] = min(dp[current][walls], cost[i] + dp[previous][max(0, walls - time[i] - 1)]);\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], invalid_cost, sizeof(dp[current]));\\n    }\\n    \\n    return static_cast<int>(dp[previous][n]);\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `cost`, that is the number of walls which need painting\\n */\\nclass Solution {\\n public:\\n  int paintWalls(const vector<int> &cost, const vector<int> &time) {\\n    constexpr uint32_t invalid_cost = -1;\\n    constexpr int range = 2;\\n    const int n = static_cast<int>(cost.size());\\n    uint32_t dp[range][n + 1];\\n    memset(dp, invalid_cost, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = 0;\\n    for (int i = 0; i < n; ++i) {\\n      for (int walls = 0; walls < n + 1; ++walls) {\\n        if (dp[previous][walls] == invalid_cost) {\\n          continue;\\n        }\\n        \\n        // the paid painter doesn\\'t paint it\\n        dp[current][walls] = min(dp[current][walls], dp[previous][walls]);\\n        \\n        // the paid painter paints it\\n        const int next_walls = min(n, walls + time[i] + 1);\\n        dp[current][next_walls] = min(dp[current][next_walls], dp[previous][walls] + cost[i]);\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], -1, sizeof(dp[current]));\\n    }\\n    \\n    return static_cast<int>(dp[previous][n]);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651522,
                "title": "javascript-dynamic-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOptimizing over an exponential space of options usually requires dynamic programming. Here, we represent the cost array as $C$ and the time array as $T$.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet $P(i, j)$ be the minimum cost to paint walls from $\\\\{0, \\\\ldots, i\\\\}$ where we have $j$ hours available to spend on free painters. \\n\\nBase case 1: $P(-1, j)$ there are no houses to paint. Cost is zero if $j \\\\geq 0$, and infinite if $j < 0$ (since we have exceed the free painter budget).\\n\\nBase case 2: $0 = P(i, j)$ when $i < j$, since we can use $j \\\\geq i + 1$ free painter hours to paint all the $i + 1$ walls from $\\\\{0, \\\\ldots, i\\\\}$.\\n\\nOtherwise, $P(i, j)$ can be computed as the minimum of two choices:\\n\\n- Choice 1: Pay to paint wall $i$, costing $C[i] + P(i - 1, j + T[i])$\\n- Choice 2: Paint wall $i$ for free, costing $P(i - 1, j - 1)$\\n\\nThe solution to the problem is given by $P(n - 1, 0)$, the minimum cost to paint all the houses, starting without any free painter budget.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nHere we note that no recursive calls are made for subproblems with $j \\\\geq n$, so at most $O(n^2)$ subproblems are worked, with each subproblem taking $O(1)$ time.\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis is the size of the memo for the dynamic program, one for each subproblem.\\n\\n# Code\\n```\\nconst paintWalls = (C, T) => {\\n    const n = C.length;\\n    const M = new Map();\\n    const P = (i, j) => {   // min cost to paint 0...i with j free painter time\\n        if (i == -1)        // base case 1: no walls to paint, can\\'t have j < 0\\n            return (j >= 0) ? 0 : Infinity;\\n        if (j > i)          // base case 2: can paint all remaining walls for free\\n            return 0;\\n        const s = `${i},${j}`;\\n        let out = M.get(s);\\n        if (out == undefined) {                     // not in memo\\n            out = C[i] + P(i - 1, j + T[i]);        // case 1: pay to paint wall i\\n            out = Math.min(out, P(i - 1, j - 1));   // case 2: paint wall i for free \\n            M.set(s, out);                          // add to memo\\n        }\\n        return out;\\n    }\\n    return P(n - 1, 0);     // min cost to paint all houses without free painter time\\n};\\n// O(n^2) subproblems / storage\\n// O(1) work per subproblem\\n// O(n^2) running time\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst paintWalls = (C, T) => {\\n    const n = C.length;\\n    const M = new Map();\\n    const P = (i, j) => {   // min cost to paint 0...i with j free painter time\\n        if (i == -1)        // base case 1: no walls to paint, can\\'t have j < 0\\n            return (j >= 0) ? 0 : Infinity;\\n        if (j > i)          // base case 2: can paint all remaining walls for free\\n            return 0;\\n        const s = `${i},${j}`;\\n        let out = M.get(s);\\n        if (out == undefined) {                     // not in memo\\n            out = C[i] + P(i - 1, j + T[i]);        // case 1: pay to paint wall i\\n            out = Math.min(out, P(i - 1, j - 1));   // case 2: paint wall i for free \\n            M.set(s, out);                          // add to memo\\n        }\\n        return out;\\n    }\\n    return P(n - 1, 0);     // min cost to paint all houses without free painter time\\n};\\n// O(n^2) subproblems / storage\\n// O(1) work per subproblem\\n// O(n^2) running time\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651443,
                "title": "100-easy-solution-c-topdown",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int solve(int ind, vector<int> &cost, vector<int> &time, int n) {\\n        if(n <= 0)\\n            return 0;\\n\\n        if(ind == cost.size())\\n            return 1e9;// 10^6;\\n\\n        if(dp[ind][n] != -1)\\n            return dp[ind][n];\\n\\n        int notTake = solve(ind + 1, cost, time, n); // free\\n        int take = cost[ind] + solve(ind + 1, cost, time, n - time[ind] - 1); // n -> walls // paid\\n\\n        return dp[ind][n] = min(notTake, take);\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, cost, time, time.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int solve(int ind, vector<int> &cost, vector<int> &time, int n) {\\n        if(n <= 0)\\n            return 0;\\n\\n        if(ind == cost.size())\\n            return 1e9;// 10^6;\\n\\n        if(dp[ind][n] != -1)\\n            return dp[ind][n];\\n\\n        int notTake = solve(ind + 1, cost, time, n); // free\\n        int take = cost[ind] + solve(ind + 1, cost, time, n - time[ind] - 1); // n -> walls // paid\\n\\n        return dp[ind][n] = min(notTake, take);\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, cost, time, time.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651360,
                "title": "take-nottake-approach-basic-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Take** : \\nPainting the current wall with a cost of `cost[i]` and incrementing the count by `1+time[i]` meaning that next `time[i]`\\nno.of walls can be painted for free within this `time[i]`. So we consider current wall and those time[i] no.of walls as painted and go for the next index. \\n**notTake** : \\nGoing to next wall for choosing paid version so that current wall will automatically get considered as free version as we go on counting the no.of walls painted. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust return minimum of take, notTake. \\nNote : if we consider totalTime[i] so far as one of the parameter, and checking if totalTime[i]>=totalLength-countPainted to stop, works fine but it gives MLE(Memory Limit Exceeded) hence it can be reduced at mentioned now. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```class Solution {\\n    int[][] dp;\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length;\\n        dp = new int[n][n];\\n        return dfs(0,cost,time,0);\\n    }\\n    public int dfs(int i, int[] cost, int[] time, int paintedWallsCount){\\n        if(paintedWallsCount>=cost.length) return 0;\\n        if(i>=cost.length) return 1000000000;\\n        if(dp[i][paintedWallsCount]!=0) return dp[i][paintedWallsCount];\\n        int notTake = dfs(i+1,cost,time,paintedWallsCount);\\n        int take = cost[i]+dfs(i+1,cost,time, paintedWallsCount+1+time[i]);\\n        return dp[i][paintedWallsCount]=Math.min(take,notTake);\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    int[][] dp;\\n    public int paintWalls(int[] cost, int[] time) {\\n        int n = cost.length;\\n        dp = new int[n][n];\\n        return dfs(0,cost,time,0);\\n    }\\n    public int dfs(int i, int[] cost, int[] time, int paintedWallsCount){\\n        if(paintedWallsCount>=cost.length) return 0;\\n        if(i>=cost.length) return 1000000000;\\n        if(dp[i][paintedWallsCount]!=0) return dp[i][paintedWallsCount];\\n        int notTake = dfs(i+1,cost,time,paintedWallsCount);\\n        int take = cost[i]+dfs(i+1,cost,time, paintedWallsCount+1+time[i]);\\n        return dp[i][paintedWallsCount]=Math.min(take,notTake);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651338,
                "title": "fast-python3-solution-beats-100",
                "content": "# Approach\\nWith each wall entry, you have a decision to make:\\n\\n- Pay to paint the wall, which will \\n    - add to the total cost\\n    - add to the available time\\n- Get the free guy to paint it, which will\\n    - subtract 1 from the available time\\n\\nA naive recursive solution would traverse every decision branch. This would have a perfomance of $$O(2^n)$$. Because $$n$$ can equal a number up to 500, this would be time prohibitive..\\n\\nAn approach is a breadth-first calculation, pruning the sub-optimal branches. Each node would consist of:\\n\\n- Time (which could be a negative value)\\n- Cost so far\\n\\nIf multiple nodes with the same depth have the same time value, then pick the one with the smaller cost.\\n\\nWe can also stop expanding nodes early:\\n\\n- If you have enough time to paint the walls for free, there\\'s no need to keep expanding a node. Just calculate the result and mark it as a possible best value\\n- If the accumulated cost is greater or equal to the best value, discard the node\\n\\n# Code\\n```\\nimport math\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def paintWalls(self, cost: list[int], time: list[int]) -> int:\\n        if len(cost) == 1:\\n            return cost[0]\\n        dp = defaultdict(lambda: math.inf)\\n        dp[time[0]] = cost[0]\\n        dp[-1] = 0\\n        best_result = math.inf\\n        for i in range(1, len(cost)):\\n            c = cost[i]\\n            t = time[i]\\n            dp2 = defaultdict(lambda: math.inf)\\n            remaining_walls_after_this_one = len(cost) - i - 1\\n            for remaining_time, cost_so_far in dp.items():\\n                remaining_time_if_we_paint = remaining_time + t\\n                total_cost_if_we_paint = cost_so_far + c\\n                if total_cost_if_we_paint < best_result:\\n                    if remaining_walls_after_this_one <= remaining_time_if_we_paint:\\n                        best_result = min(best_result, total_cost_if_we_paint)\\n                    else:\\n                        dp2[remaining_time_if_we_paint] = min(dp2[remaining_time_if_we_paint], total_cost_if_we_paint)\\n                remaining_time_if_we_dont_paint = remaining_time - 1\\n                if remaining_walls_after_this_one <= remaining_time_if_we_dont_paint:\\n                    best_result = min(best_result, cost_so_far)\\n                else:\\n                    dp2[remaining_time_if_we_dont_paint] = min(dp2[remaining_time_if_we_dont_paint], cost_so_far)\\n            dp = dp2\\n        return best_result\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def paintWalls(self, cost: list[int], time: list[int]) -> int:\\n        if len(cost) == 1:\\n            return cost[0]\\n        dp = defaultdict(lambda: math.inf)\\n        dp[time[0]] = cost[0]\\n        dp[-1] = 0\\n        best_result = math.inf\\n        for i in range(1, len(cost)):\\n            c = cost[i]\\n            t = time[i]\\n            dp2 = defaultdict(lambda: math.inf)\\n            remaining_walls_after_this_one = len(cost) - i - 1\\n            for remaining_time, cost_so_far in dp.items():\\n                remaining_time_if_we_paint = remaining_time + t\\n                total_cost_if_we_paint = cost_so_far + c\\n                if total_cost_if_we_paint < best_result:\\n                    if remaining_walls_after_this_one <= remaining_time_if_we_paint:\\n                        best_result = min(best_result, total_cost_if_we_paint)\\n                    else:\\n                        dp2[remaining_time_if_we_paint] = min(dp2[remaining_time_if_we_paint], total_cost_if_we_paint)\\n                remaining_time_if_we_dont_paint = remaining_time - 1\\n                if remaining_walls_after_this_one <= remaining_time_if_we_dont_paint:\\n                    best_result = min(best_result, cost_so_far)\\n                else:\\n                    dp2[remaining_time_if_we_dont_paint] = min(dp2[remaining_time_if_we_dont_paint], cost_so_far)\\n            dp = dp2\\n        return best_result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651335,
                "title": "c-0-1-knapsack-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int helper(int i, int count, vector<int>& cost, vector<int>& time, vector<vector<int>>& memo){\\n        if(count <= 0){\\n            return 0;\\n        }\\n        if(i == cost.size()){\\n            return INT_MAX;\\n        }\\n        if(memo[i][count] != -1){\\n            return memo[i][count];\\n        }\\n        int take = helper(i + 1, count - time[i] - 1, cost, time, memo);\\n        int notTake = helper(i + 1, count, cost, time, memo);\\n        if(take == INT_MAX){\\n            return memo[i][count] = notTake;\\n        }\\n        return memo[i][count] = min(cost[i] + take, notTake);\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int count = cost.size();\\n        vector<vector<int>> memo(count, vector<int>(count + 1, -1));\\n        return helper(0, count, cost, time, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int helper(int i, int count, vector<int>& cost, vector<int>& time, vector<vector<int>>& memo){\\n        if(count <= 0){\\n            return 0;\\n        }\\n        if(i == cost.size()){\\n            return INT_MAX;\\n        }\\n        if(memo[i][count] != -1){\\n            return memo[i][count];\\n        }\\n        int take = helper(i + 1, count - time[i] - 1, cost, time, memo);\\n        int notTake = helper(i + 1, count, cost, time, memo);\\n        if(take == INT_MAX){\\n            return memo[i][count] = notTake;\\n        }\\n        return memo[i][count] = min(cost[i] + take, notTake);\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int count = cost.size();\\n        vector<vector<int>> memo(count, vector<int>(count + 1, -1));\\n        return helper(0, count, cost, time, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651316,
                "title": "explained-solution-don-t-think-like-0-1-knapsack-first-think-like-simple-dp-problem-easy-to-under",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat will be the maximum time in which both Paid painter and free painter will paint all the wall.\\nTime will be the maximum time among all the time taken by paid painter.\\nBut we have to minimize the cost also if not then directly our ans will be the sum of all the cost. \\nFor minimize the cost we have to go through all the possibility and this can be done by recursion.\\nBut recursion will take exponential time complexity so we apply Dynamic programming to reduce the time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe time taken by the paid painter to paint the wall is the no of wall painted by the free painter.\\nSo by all possibility find out the min cost to paint all the wall together paid and free painter.\\nFor that now apply simply 0/1 Knapsack approach.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)+O(n) Stack space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<pair<int,int>>&vp,int ind,int wall,int n,vector<vector<int>>&dp){\\n        if(wall<=0) return 0;\\n        if(ind>n-1){\\n            return 1e9;\\n        }\\n\\n        if(dp[ind][wall]!=-1) return dp[ind][wall];\\n\\n        int take=vp[ind].first+fun(vp,ind+1,wall-vp[ind].second-1,n,dp);\\n        int nottake=0+fun(vp,ind+1,wall,n,dp);\\n\\n        return dp[ind][wall]=min(take,nottake);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<pair<int,int>>vp;\\n        int n=cost.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        //No need of vector pair \\n        //I firstly tried with the vector pair so i leave as it is.\\n        for(int i=0;i<n;++i){\\n            vp.push_back({cost[i],time[i]});\\n        }\\n        sort(vp.begin(),vp.end());\\n        return fun(vp,0,n,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<pair<int,int>>&vp,int ind,int wall,int n,vector<vector<int>>&dp){\\n        if(wall<=0) return 0;\\n        if(ind>n-1){\\n            return 1e9;\\n        }\\n\\n        if(dp[ind][wall]!=-1) return dp[ind][wall];\\n\\n        int take=vp[ind].first+fun(vp,ind+1,wall-vp[ind].second-1,n,dp);\\n        int nottake=0+fun(vp,ind+1,wall,n,dp);\\n\\n        return dp[ind][wall]=min(take,nottake);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<pair<int,int>>vp;\\n        int n=cost.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        //No need of vector pair \\n        //I firstly tried with the vector pair so i leave as it is.\\n        for(int i=0;i<n;++i){\\n            vp.push_back({cost[i],time[i]});\\n        }\\n        sort(vp.begin(),vp.end());\\n        return fun(vp,0,n,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651305,
                "title": "top-down-dp-c-commented-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    //Here curr_time gives the possible number of walls that can be painted by free painter\\n    int solve(vector<int>& cost, vector<int>& time,int idx,int curr_time,vector<vector<int>> &dp){\\n        if(curr_time>=(n-idx)){\\n            return 0;\\n        }\\n        if(idx==n){\\n            return 1e9;\\n        }\\n\\n        if(dp[idx][n+curr_time]!=-1){\\n            return dp[idx][n+curr_time];\\n        }\\n\\n        //to be done by free painter \\n        int case1=solve(cost,time,idx+1,curr_time-1,dp);\\n\\n        //to be done by paid painter\\n        int case2=cost[idx]+solve(cost,time,idx+1,curr_time+time[idx],dp);\\n\\n        return dp[idx][n+curr_time]=min(case1,case2);\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        n=cost.size();\\n        vector<vector<int>> dp(n,vector<int>(2*n+1,-1));\\n        return solve(cost,time,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    //Here curr_time gives the possible number of walls that can be painted by free painter\\n    int solve(vector<int>& cost, vector<int>& time,int idx,int curr_time,vector<vector<int>> &dp){\\n        if(curr_time>=(n-idx)){\\n            return 0;\\n        }\\n        if(idx==n){\\n            return 1e9;\\n        }\\n\\n        if(dp[idx][n+curr_time]!=-1){\\n            return dp[idx][n+curr_time];\\n        }\\n\\n        //to be done by free painter \\n        int case1=solve(cost,time,idx+1,curr_time-1,dp);\\n\\n        //to be done by paid painter\\n        int case2=cost[idx]+solve(cost,time,idx+1,curr_time+time[idx],dp);\\n\\n        return dp[idx][n+curr_time]=min(case1,case2);\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        n=cost.size();\\n        vector<vector<int>> dp(n,vector<int>(2*n+1,-1));\\n        return solve(cost,time,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651238,
                "title": "dp-o-n-2",
                "content": "# Intuition\\n\\n`dp` is a matrix. `dp[i][j]` is the cost of painting $i$ walls, when the available paid painters are the first $j$ one.\\n\\nWhen $i=0$ the cost is zero when the task is impossible the cost is infinite.\\nThen the key relation is:\\n$$\\n    \\\\text{dp}_{i,j} = \\\\min(\\\\text{dp}_{i,j-1}, \\\\text{cost}_j+\\\\text{dp}_{0\\\\vee(i-\\\\text{time}_j), j})\\n$$\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(time)\\n        INF = 10**9+1\\n        dp = [[0 if i==0 else INF]*(n+1) for i in range(n+1)]\\n        for i in range(1, n+1):\\n            c0 = INF\\n            for j, (t, c) in enumerate(zip(time, cost), 1):\\n                i0 = max(i-t-1, 0)\\n                c1 = c + dp[i0][j-1]\\n                if c0 > c1:\\n                    c0 = c1\\n                dp[i][j] = c0\\n        return dp[-1][-1]\\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(time)\\n        INF = 10**9+1\\n        dp = [[0 if i==0 else INF]*(n+1) for i in range(n+1)]\\n        for i in range(1, n+1):\\n            c0 = INF\\n            for j, (t, c) in enumerate(zip(time, cost), 1):\\n                i0 = max(i-t-1, 0)\\n                c1 = c + dp[i0][j-1]\\n                if c0 > c1:\\n                    c0 = c1\\n                dp[i][j] = c0\\n        return dp[-1][-1]\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651222,
                "title": "0-1-knapsack-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int start,int n,vector<int>& cost, vector<int>& time,int ct,vector<vector<int>> &dp)\\n    {\\n        if(ct>=n)\\n            return 0;\\n        if(start==n)\\n            return 1e9;\\n        if(dp[start][ct]!=-1)\\n            return dp[start][ct];\\n        int nt=f(start+1,n,cost,time,ct,dp);\\n        int take=cost[start]+f(start+1,n,cost,time,ct+1+time[start],dp);\\n        return dp[start][ct]=min(take,nt);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n,k=0;\\n      n=cost.size(); \\n     for(int i=0;i<n;i++)\\n         k=max(k,time[i]);\\n     k+=5;\\n    vector<vector<int>> dp(n,vector<int>(n+k,-1));\\n      return f(0,n,cost,time,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int start,int n,vector<int>& cost, vector<int>& time,int ct,vector<vector<int>> &dp)\\n    {\\n        if(ct>=n)\\n            return 0;\\n        if(start==n)\\n            return 1e9;\\n        if(dp[start][ct]!=-1)\\n            return dp[start][ct];\\n        int nt=f(start+1,n,cost,time,ct,dp);\\n        int take=cost[start]+f(start+1,n,cost,time,ct+1+time[start],dp);\\n        return dp[start][ct]=min(take,nt);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n,k=0;\\n      n=cost.size(); \\n     for(int i=0;i<n;i++)\\n         k=max(k,time[i]);\\n     k+=5;\\n    vector<vector<int>> dp(n,vector<int>(n+k,-1));\\n      return f(0,n,cost,time,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651197,
                "title": "100-faster-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int help(vector<int>& cost, vector<int>& time,int st,int t,vector<vector<int>> &dp){\\n        if(t<=0) return 0;\\n        if(st>=cost.size()) return 1e9;\\n        if(dp[st][t]!=-1) return dp[st][t];\\n        int take = cost[st]+help(cost,time,st+1,t-time[st]-1,dp);\\n        int no_take = help(cost,time,st+1,t,dp);\\n\\n        return dp[st][t] = min(take,no_take);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return help(cost,time,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(vector<int>& cost, vector<int>& time,int st,int t,vector<vector<int>> &dp){\\n        if(t<=0) return 0;\\n        if(st>=cost.size()) return 1e9;\\n        if(dp[st][t]!=-1) return dp[st][t];\\n        int take = cost[st]+help(cost,time,st+1,t-time[st]-1,dp);\\n        int no_take = help(cost,time,st+1,t,dp);\\n\\n        return dp[st][t] = min(take,no_take);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return help(cost,time,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651071,
                "title": "c-solution-using-dp-o-n-n-top-down-approach",
                "content": "# Approach\\nHere we need to make optimal selection of wall which are to be painted by paid painter so all rest can be painted by free painter.This can be done by knapsack .\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int inf=1000000000;\\n    int dp[502][502];\\n // Here i represent index and t represent number of wall painted by free painter +  paid painter\\n    int solve(int i,vector<int>& cost, vector<int>& time,int t){\\n        int n=cost.size();\\n        if(i==n){\\n            // if t is equal to or greater then n then all wall is painted so we return 0\\n            if(t>=n)return 0;\\n            return inf;\\n        }\\n        if(dp[i][t]!=-1)return dp[i][t];\\n\\n        // if we choose ith wall to be painted by paid painter then we need cost[i] amount and t is increases by 1+time[i] because  1 wall is painted by paid painter and time[i] wall is painted by free painter\\n        //time[i] time paid painter is busy so time[i] wall can be painted by free painter\\n        // we do this min(t+1+time[i],n) because there is only n walls\\n        int take=solve(i+1,cost,time,min(t+1+time[i],n))+cost[i];\\n        int skip=solve(i+1,cost,time,t);\\n        \\n        return dp[i][t]=min(skip,take);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,cost,time,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int inf=1000000000;\\n    int dp[502][502];\\n // Here i represent index and t represent number of wall painted by free painter +  paid painter\\n    int solve(int i,vector<int>& cost, vector<int>& time,int t){\\n        int n=cost.size();\\n        if(i==n){\\n            // if t is equal to or greater then n then all wall is painted so we return 0\\n            if(t>=n)return 0;\\n            return inf;\\n        }\\n        if(dp[i][t]!=-1)return dp[i][t];\\n\\n        // if we choose ith wall to be painted by paid painter then we need cost[i] amount and t is increases by 1+time[i] because  1 wall is painted by paid painter and time[i] wall is painted by free painter\\n        //time[i] time paid painter is busy so time[i] wall can be painted by free painter\\n        // we do this min(t+1+time[i],n) because there is only n walls\\n        int take=solve(i+1,cost,time,min(t+1+time[i],n))+cost[i];\\n        int skip=solve(i+1,cost,time,t);\\n        \\n        return dp[i][t]=min(skip,take);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,cost,time,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651012,
                "title": "c-dynamic-programming-with-intuition",
                "content": "# Intuition\\nif u try greedy it wont work here and u have to try out all possible combination so this gives an idea about dp \\nand if u have done problems on pick-notpick dp its straight forward intutive after reading the problem \\n\\n# Approach\\ntring out all possible combinations with pick and not pick \\n\\n# Complexity\\n- Time complexity: O(501*501)\\n\\n- Space complexity: O(501*501)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& cost, vector<int>& time, int i, int bank,vector<vector<int>> &dp){\\n        if(bank <= 0){\\n            return 0;\\n        }\\n        if(i >= cost.size()){\\n            return 1e9;   \\n        }\\n        if(dp[i][bank] != -1){\\n            return dp[i][bank];\\n        }\\n        else {\\n            int notTake = solve(cost, time, i+1, bank,dp);\\n            int take = cost[i] + solve(cost, time, i+1, bank -  time[i] -1,dp); \\n            return dp[i][bank] = min(notTake, take);      \\n        }\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<vector<int>> dp(501,vector<int>(501,-1));\\n        return solve(cost, time, 0, time.size(),dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& cost, vector<int>& time, int i, int bank,vector<vector<int>> &dp){\\n        if(bank <= 0){\\n            return 0;\\n        }\\n        if(i >= cost.size()){\\n            return 1e9;   \\n        }\\n        if(dp[i][bank] != -1){\\n            return dp[i][bank];\\n        }\\n        else {\\n            int notTake = solve(cost, time, i+1, bank,dp);\\n            int take = cost[i] + solve(cost, time, i+1, bank -  time[i] -1,dp); \\n            return dp[i][bank] = min(notTake, take);      \\n        }\\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<vector<int>> dp(501,vector<int>(501,-1));\\n        return solve(cost, time, 0, time.size(),dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651005,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nso basically This is a similar to 0/1 knapsack problem we can take the painter for the work or we don\\'t want to take.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso basically The approach is that suppose we are taking that painter to paint then we can use the free painter for (paid painters time) .\\nThis is the main thing that we shold think. One another thing that we have total of n wall to paint so whenever we are using the painter to paint that particular wall then we can neglect the some of the walls which are most costlier for paid painter (for to paint by free painter).\\n\\nHope you understand.\\nPlease upvote if you like.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int recursion(vector<int>& cost,vector<int>& time,int i ,int n ){\\n        if(n<=0)return 0;\\n        if(i>=cost.size())return 1e9;\\n        \\n        if(dp[i][n]!=-1){\\n            return dp[i][n];\\n        }\\n        int ch1  =  cost[i]+recursion(cost,time,i+1,n-time[i]-1);\\n        int ch2  =  recursion(cost,time,i+1,n);\\n        \\n        return dp[i][n]=min(ch1,ch2);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        for(int i =0;i<501;i++){\\n            for(int j =0;j<501;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return recursion(cost,time,0,cost.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int recursion(vector<int>& cost,vector<int>& time,int i ,int n ){\\n        if(n<=0)return 0;\\n        if(i>=cost.size())return 1e9;\\n        \\n        if(dp[i][n]!=-1){\\n            return dp[i][n];\\n        }\\n        int ch1  =  cost[i]+recursion(cost,time,i+1,n-time[i]-1);\\n        int ch2  =  recursion(cost,time,i+1,n);\\n        \\n        return dp[i][n]=min(ch1,ch2);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        for(int i =0;i<501;i++){\\n            for(int j =0;j<501;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return recursion(cost,time,0,cost.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650946,
                "title": "c-memoisation-code-bassed-on-0-1-knapsack-explaind",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to paint n walls with minimum cost.\\nsince free painter can complete the wall in 1 unit time each, \\nwe have two options for each wall :-\\n    let say if we take the curr wall which takes time[i] time then in that much time we can paint time[i] walls,, now remaining walls = (n - time[i] - 1);  that 1 wall is paid by paid painter.\\n another option is curr wall not painted by paid then just leave it,, free painter will paint this wall\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n    int solve(int i, int j, vector<pair<int,int>>&vec){\\n        if(j <= 0){\\n            return 0;\\n        }\\n        if(i == vec.size())return 1e9;\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int notTake = INT_MAX, take = INT_MAX;\\n        notTake = solve(i+1, j, vec);\\n        take = vec[i].first + solve(i+1, j - vec[i].second - 1, vec);\\n        return dp[i][j] = min(notTake, take);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<pair<int,int>>vec;\\n        int n = cost.size();\\n        \\n        for(int i =0; i <n ;i++){\\n            vec.push_back({cost[i], time[i]});    \\n        }\\n        sort(vec.begin(), vec.end());\\n        memset(dp , -1, sizeof(dp));\\n        return solve(0, n, vec);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n    int solve(int i, int j, vector<pair<int,int>>&vec){\\n        if(j <= 0){\\n            return 0;\\n        }\\n        if(i == vec.size())return 1e9;\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int notTake = INT_MAX, take = INT_MAX;\\n        notTake = solve(i+1, j, vec);\\n        take = vec[i].first + solve(i+1, j - vec[i].second - 1, vec);\\n        return dp[i][j] = min(notTake, take);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<pair<int,int>>vec;\\n        int n = cost.size();\\n        \\n        for(int i =0; i <n ;i++){\\n            vec.push_back({cost[i], time[i]});    \\n        }\\n        sort(vec.begin(), vec.end());\\n        memset(dp , -1, sizeof(dp));\\n        return solve(0, n, vec);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650938,
                "title": "c-2d-dynamic-programming-explained",
                "content": "# Intuition\\nAt first glance, this may seem to be a greedy problem, i.e.\\n\\n*\"Give the low cost walls to the paid painter, and the high cost walls to the free painter\".*\\n\\nHowever, this may not always be true. There could be situations where the paid painter should ignore a low cost wall in favor of a higher wall with a longer duration.\\n\\nFor this reason, we will use DP to choose which walls the paid painter will paint.\\n\\n# Approach\\nUse 2D dynamic programming.\\n\\nStates consist of index `i` and the number of walls painted `w`.\\n\\nStart at index 0 with 0 walls painted.\\n\\nIn each state, choose whether the paid painter will paint the wall at cost `cost[i]` or skip the wall. If the wall is not skipped, the free painter will be able to paint `time[i]` walls, so the number of walls painted would increase to `w + time[i] + 1`.\\n\\nIf all of the walls have been painted, we have reached a valid end state. Return 0.\\n\\nIf all of the walls have been considered but not all can be painted (i.e. all were skipped by the paid painter), then the end state is not valid. Return INT_MAX.\\n\\n# Code\\n```\\nclass Solution {\\n    int memo[500][500];\\n    int dp(vector<int>& cost, vector<int>& time, int i, int w) {\\n        if (w >= cost.size()) return 0;\\n        if (i == cost.size()) return INT_MAX;\\n        if (memo[i][w] != -1) return memo[i][w];\\n        \\n        int take = (dp(cost, time, i + 1, w + time[i] + 1) != INT_MAX ? cost[i] + dp(cost, time, i + 1, w + time[i] + 1) : INT_MAX);\\n        int skip = dp(cost, time, i + 1, w);\\n        \\n        memo[i][w] = min(take, skip);\\n        return memo[i][w];\\n    }\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        for (int i = 0; i < cost.size(); ++i) fill_n(memo[i], cost.size(), -1);\\n        return dp(cost, time, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int memo[500][500];\\n    int dp(vector<int>& cost, vector<int>& time, int i, int w) {\\n        if (w >= cost.size()) return 0;\\n        if (i == cost.size()) return INT_MAX;\\n        if (memo[i][w] != -1) return memo[i][w];\\n        \\n        int take = (dp(cost, time, i + 1, w + time[i] + 1) != INT_MAX ? cost[i] + dp(cost, time, i + 1, w + time[i] + 1) : INT_MAX);\\n        int skip = dp(cost, time, i + 1, w);\\n        \\n        memo[i][w] = min(take, skip);\\n        return memo[i][w];\\n    }\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        for (int i = 0; i < cost.size(); ++i) fill_n(memo[i], cost.size(), -1);\\n        return dp(cost, time, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650917,
                "title": "how-is-this-tle-o-n-2-tle-test-cases-pass-in-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution(): memo_(501*501, -1) {};\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        cost_ = move(cost), time_ = move(time);\\n        N_ = cost_.size();\\n        return rec(0, N_);\\n    }\\n    vector<int> cost_, time_;\\n    int N_;\\n    vector<long long> memo_;\\n    long long rec(int i, int walls){\\n        assert(i<=N_ || i>=0);\\n        assert(walls<=N_ || walls>=0);\\n        if(walls==0) {\\n            return 0;\\n        }\\n        if(i==N_){\\n            return 1L<<31;\\n        }\\n        int key = i<<10 | walls;\\n        long long mn = memo_[key];\\n        if(mn != -1) return mn;\\n        mn = min(rec(i+1, walls),\\n            cost_[i]+rec(i+1, max(0, walls-1-time_[i])));\\n        return memo_[key] = mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(): memo_(501*501, -1) {};\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        cost_ = move(cost), time_ = move(time);\\n        N_ = cost_.size();\\n        return rec(0, N_);\\n    }\\n    vector<int> cost_, time_;\\n    int N_;\\n    vector<long long> memo_;\\n    long long rec(int i, int walls){\\n        assert(i<=N_ || i>=0);\\n        assert(walls<=N_ || walls>=0);\\n        if(walls==0) {\\n            return 0;\\n        }\\n        if(i==N_){\\n            return 1L<<31;\\n        }\\n        int key = i<<10 | walls;\\n        long long mn = memo_[key];\\n        if(mn != -1) return mn;\\n        mn = min(rec(i+1, walls),\\n            cost_[i]+rec(i+1, max(0, walls-1-time_[i])));\\n        return memo_[key] = mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650914,
                "title": "top-down-c-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(space used by stack during recursion)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int help(vector<int>& c, vector<int>& t,int i,int rem,vector<vector<int>>&dp)\\n    {\\n        int n=c.size();\\n        if(rem<=0)return 0;\\n        if(i==n)return INT_MIN;\\n        if(dp[i][rem]!=-1)return dp[i][rem];\\n        int one = c[i]+help(c,t,i+1,rem-1-t[i],dp);\\n        int two = help(c,t,i+1,rem,dp);\\n        if(one>=0 && two>=0)return dp[i][rem] = min(one,two);\\n        if(one>=0)return dp[i][rem] = one;\\n        return dp[i][rem] = two;\\n    }\\n    int paintWalls(vector<int>& c, vector<int>& t) {\\n        vector<pair<int,int>>v;\\n        int n=c.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return help(c,t,0,n,dp);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(vector<int>& c, vector<int>& t,int i,int rem,vector<vector<int>>&dp)\\n    {\\n        int n=c.size();\\n        if(rem<=0)return 0;\\n        if(i==n)return INT_MIN;\\n        if(dp[i][rem]!=-1)return dp[i][rem];\\n        int one = c[i]+help(c,t,i+1,rem-1-t[i],dp);\\n        int two = help(c,t,i+1,rem,dp);\\n        if(one>=0 && two>=0)return dp[i][rem] = min(one,two);\\n        if(one>=0)return dp[i][rem] = one;\\n        return dp[i][rem] = two;\\n    }\\n    int paintWalls(vector<int>& c, vector<int>& t) {\\n        vector<pair<int,int>>v;\\n        int n=c.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return help(c,t,0,n,dp);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650913,
                "title": "simple-dp-solution-like-0-1-knapsack-problem-beats-100-solution",
                "content": "# Approach\\nHere we can simply think of the problem as, when we paint a wall by the painter1 then we can skip time[i] walls (basically this time[i] no. of walls will be painted by the painter2 with zero cost).\\n\\nSo we can re-think the problem as select n walls from the given one so that the sum of the times to pain the wall(painded by painter 2) + the number of wall taken (painted by painter 1) > total no. of walls to paint.\\n\\nThis is similar to the 0/1 Knapsack where the cost is same as weight and our bag size is wall count. But in Knapsack we reduce the bag size by the stone size here we reduce the wall count by the time[i] and additional -1 to reduced currently painted wall.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505] = {};\\n\\n    int solve(vector<int>& cost, vector<int>& time, int i, int wallReamining){\\n        if(wallReamining <= 0) \\n        return 0;\\n        if(i >= cost.size()) \\n        return 1000000000;\\n        if(dp[i][wallReamining] != 0) \\n        return dp[i][wallReamining];\\n        int notTake = solve(cost, time, i+1, wallReamining);\\n        int take = cost[i] + solve(cost, time, i+1, wallReamining -  time[i] -1); \\n        return dp[i][wallReamining] = min(notTake, take);      \\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        return solve(cost, time, 0, time.size());\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505] = {};\\n\\n    int solve(vector<int>& cost, vector<int>& time, int i, int wallReamining){\\n        if(wallReamining <= 0) \\n        return 0;\\n        if(i >= cost.size()) \\n        return 1000000000;\\n        if(dp[i][wallReamining] != 0) \\n        return dp[i][wallReamining];\\n        int notTake = solve(cost, time, i+1, wallReamining);\\n        int take = cost[i] + solve(cost, time, i+1, wallReamining -  time[i] -1); \\n        return dp[i][wallReamining] = min(notTake, take);      \\n    }\\n\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        return solve(cost, time, 0, time.size());\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650885,
                "title": "0-1-knapsack-dp-c",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp[505][501];\\n    long long helper(vector<int>&cost, vector<int>&time, int i, int remaining){\\n        if(remaining<=0) return 0;\\n        if(i==cost.size()) return INT_MAX;\\n        long long ans=INT_MAX;\\n        if(dp[i][remaining]!=-1) return dp[i][remaining];\\n        ans=min(ans,cost[i]+helper(cost,time,i+1, remaining-time[i]-1));\\n        ans=min(ans,helper(cost,time,i+1,remaining));\\n        return dp[i][remaining]=ans;\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(cost,time,0,time.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[505][501];\\n    long long helper(vector<int>&cost, vector<int>&time, int i, int remaining){\\n        if(remaining<=0) return 0;\\n        if(i==cost.size()) return INT_MAX;\\n        long long ans=INT_MAX;\\n        if(dp[i][remaining]!=-1) return dp[i][remaining];\\n        ans=min(ans,cost[i]+helper(cost,time,i+1, remaining-time[i]-1));\\n        ans=min(ans,helper(cost,time,i+1,remaining));\\n        return dp[i][remaining]=ans;\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(cost,time,0,time.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650877,
                "title": "explained-iterative-dp-video-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nI have Explained my solution using dynamic programming in this video\\nhttps://www.youtube.com/watch?v=QRC6yM9t23w\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n,vector<int>(2*n+1,0)); \\n        for(int i = n-1; i>=0; i--){\\n            for(int j = 0; j <= 2*n; j+=1){ // mapped difference range (-n to n) -> (0 to 2n)\\n                \\n                int realTime = j-n; // actual difference\\n                if(i == (n-1)){\\n                    if(realTime>=1){\\n                        dp[i][j] = 0;\\n                        continue;\\n                    }else if((realTime+time[i])>=0){\\n                        dp[i][j] = cost[i];\\n                    }else dp[i][j] = INT_MAX;\\n                    continue;\\n                }\\n                \\n                dp[i][j] = INT_MAX;\\n                \\n                if(j!=0){\\n                    dp[i][j] = min(dp[i][j],dp[i+1][j-1]);\\n                }\\n                \\n                if(dp[i+1][min(2*n,j+time[i])]!=INT_MAX) dp[i][j] = min(dp[i][j],cost[i] + dp[i+1][min(2*n,j+time[i])]);\\n                \\n            }\\n        }\\n        return dp[0][n];\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int n = cost.size();\\n        vector<vector<int>> dp(n,vector<int>(2*n+1,0)); \\n        for(int i = n-1; i>=0; i--){\\n            for(int j = 0; j <= 2*n; j+=1){ // mapped difference range (-n to n) -> (0 to 2n)\\n                \\n                int realTime = j-n; // actual difference\\n                if(i == (n-1)){\\n                    if(realTime>=1){\\n                        dp[i][j] = 0;\\n                        continue;\\n                    }else if((realTime+time[i])>=0){\\n                        dp[i][j] = cost[i];\\n                    }else dp[i][j] = INT_MAX;\\n                    continue;\\n                }\\n                \\n                dp[i][j] = INT_MAX;\\n                \\n                if(j!=0){\\n                    dp[i][j] = min(dp[i][j],dp[i+1][j-1]);\\n                }\\n                \\n                if(dp[i+1][min(2*n,j+time[i])]!=INT_MAX) dp[i][j] = min(dp[i][j],cost[i] + dp[i+1][min(2*n,j+time[i])]);\\n                \\n            }\\n        }\\n        return dp[0][n];\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650866,
                "title": "just-simple-subset-sum-with-extra-min",
                "content": "# Intuition\\n\\n#### Optimization problem\\n\\nIt is similar to coin-change.\\nUnlike coin-change which is often counting problem, this one is optimization problem.\\n\\n#### Time and free-painting logic\\n\\nUnlike coin-change problem, there is that the free-painting logic.\\nThe time input is only needed for free-painting logic.\\n\\n# Approach\\nUse DP, just like coin-change or subset-sum. The problem is pseudo-polynomial.\\n\\nWhile memoization, we calculate the minimum cost for a specific number of tasks completed.\\n\\nOnly trick part is calculating number of task.\\n\\n`nm2 = min(N,1+nm+t)`\\n\\n# Complexity\\n- Time complexity:\\n`O(N*N)`\\n\\n- Space complexity:\\n`O(N)`\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        N = len(cost)\\n        \\n        memo = dict()\\n        memo[0] = 0\\n\\n        for c,t in zip(cost,time):\\n            next_memo = memo.copy()\\n            for nm,cm in memo.items():\\n                cm2 = cm+c\\n                nm2 = min(N,1+nm+t)\\n                if nm2 not in next_memo or next_memo[nm2] > cm2:\\n                    next_memo[nm2] = cm2\\n            memo = next_memo\\n\\n        return memo[N]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        N = len(cost)\\n        \\n        memo = dict()\\n        memo[0] = 0\\n\\n        for c,t in zip(cost,time):\\n            next_memo = memo.copy()\\n            for nm,cm in memo.items():\\n                cm2 = cm+c\\n                nm2 = min(N,1+nm+t)\\n                if nm2 not in next_memo or next_memo[nm2] > cm2:\\n                    next_memo[nm2] = cm2\\n            memo = next_memo\\n\\n        return memo[N]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650851,
                "title": "the-dp-approach-mapping-intuition-to-easy-problem",
                "content": "What happens when paid painter paints a wall with cost \\'c\\' in time \\'t\\'?\\n:-> (t + 1) walls get painted : **t by free painter** and **1 by paid painter**.\\nin other words t + 1 walls gets painted with cost c.\\nlet n = number of walls.\\nHow many walls could have been **hypothetically** painted if there were **infinite more walls** and paid painter\\npainted all the n walls given to us?\\n:-> **sum(time) + n** : **sum(time) by free painter** and n by **paid painter**.\\nand will have taken us **sum(cost)** unit of cost.\\n\\nso, let\\'s say you have  a table, where **table[i][j]** represent what would have been minimum cost of painting **j hypothetical walls** if paid painter painted only some(let say k) of the 1st **i walls** given to us. The constraint being **sum of time of painting those k wall** by paid painter is j - k.\\n\\n(In other words **while paid painter paints k walls**, **hypothetically j walls can be painted**, if free painter can **simultaneously paint j - k walls**. So, j - k can maximum be \\'the sum of time taken by paid painter to paint those k walls\\'.)\\nHence, for a valid table[i][j] entry, we need to choose **k from 1st i walls for paid painter to paint**  s.t. meanwhile j-k (= sum of time of chosen k walls) can be painted by free painter with minimum cost.\\n\\nif **j >= n** ==> k walls among first i can be painted by paid painter and remaining n - k walls can be painter by free painter with cost table[i][j] and this entry can be one of our contendar for minimum cost.\\n\\nNow, if you choose any particular wall(having paid time t) it will contribute to t + 1 hypothetical wall.\\nHence, if you count (**t**a +**1**) hypothetical walls for every **a**th wall in chosen k walls, then max possible j is  sum(**t**a +**1**)\\n\\n**Now, do the DP with each walls contribution being (t + 1) with cost c such that you want atleast n contributions.** ---> variant of Knapsack problem\\n{\\ngiven **contribution array x and cost array c**, find minimum cost for atleast **target contributions**.\\nhere, target = n,\\nand elements of array x is mapped by (elements of array t) + 1\\n}\\n\\nTC: O(n * sum(Time))\\nspace can be optimized to O(sum(Time))\\n**This problem is easy but mapping to it was hard and time comsuming.**\\n(If you want, you can reduce sum(Time) to n in these complexities as entries of hypothetical above n can be clubbed together)\\n```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int mT = 0;\\n        for(int x: time) mT += x;\\n        int ans = 0;\\n        for(int x: cost) ans += x;\\n        int n = cost.size();\\n        vector<vector<int> > table(2, vector<int>(mT + n, -1));\\n        table[0][0] = 0;\\n        int c = 1;\\n        for(int i = 0; i < n; i++){\\n            table[c] = table[c^1];\\n            for(int j = time[i] + 1; j < mT + n; j++){\\n                if(table[c^1][j - time[i] - 1] != -1){\\n                    if(table[c][j] == -1) table[c][j] = cost[i] + table[c^1][j - time[i] - 1];\\n                    else table[c][j] = min(table[c][j], cost[i] + table[c^1][j - time[i] - 1]);\\n                    if(j >= n) ans = min(ans, table[c][j]);\\n                }\\n            }\\n            c ^= 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        int mT = 0;\\n        for(int x: time) mT += x;\\n        int ans = 0;\\n        for(int x: cost) ans += x;\\n        int n = cost.size();\\n        vector<vector<int> > table(2, vector<int>(mT + n, -1));\\n        table[0][0] = 0;\\n        int c = 1;\\n        for(int i = 0; i < n; i++){\\n            table[c] = table[c^1];\\n            for(int j = time[i] + 1; j < mT + n; j++){\\n                if(table[c^1][j - time[i] - 1] != -1){\\n                    if(table[c][j] == -1) table[c][j] = cost[i] + table[c^1][j - time[i] - 1];\\n                    else table[c][j] = min(table[c][j], cost[i] + table[c^1][j - time[i] - 1]);\\n                    if(j >= n) ans = min(ans, table[c][j]);\\n                }\\n            }\\n            c ^= 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650830,
                "title": "cpp-0-1-knapsack-dp-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(int i,int t,vector<pair<long long,long long>> &arr,vector<vector<long long>> &dp){\\n        if(t<=0) return 0;\\n        if(i<0) return 1e10;\\n\\n        if(dp[i][t]!=-1) return dp[i][t];\\n\\t\\t\\n\\t\\tlong long take=1e10;\\n        if(t>0) take = arr[i].first+solve(i-1,t-arr[i].second,arr,dp);\\n        long long nottk = 0+solve(i-1,t,arr,dp);\\n        \\n        return dp[i][t]=min(take,nottk);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<pair<long long,long long>> arr;\\n        int n = cost.size();\\n        vector<vector<long long>> dp(n+1,vector<long long>(n+1,-1));\\n        for(int i=0;i<n;i++){\\n            arr.push_back({cost[i],time[i]+1});\\n        }\\n        return solve(n-1,n,arr,dp);\\n    }\\n};\\n```\\n\\n`Please upvote if it helps you :)`",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int i,int t,vector<pair<long long,long long>> &arr,vector<vector<long long>> &dp){\\n        if(t<=0) return 0;\\n        if(i<0) return 1e10;\\n\\n        if(dp[i][t]!=-1) return dp[i][t];\\n\\t\\t\\n\\t\\tlong long take=1e10;\\n        if(t>0) take = arr[i].first+solve(i-1,t-arr[i].second,arr,dp);\\n        long long nottk = 0+solve(i-1,t,arr,dp);\\n        \\n        return dp[i][t]=min(take,nottk);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n        vector<pair<long long,long long>> arr;\\n        int n = cost.size();\\n        vector<vector<long long>> dp(n+1,vector<long long>(n+1,-1));\\n        for(int i=0;i<n;i++){\\n            arr.push_back({cost[i],time[i]+1});\\n        }\\n        return solve(n-1,n,arr,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650798,
                "title": "every-easy-intuition-explained-java-c-dp",
                "content": "For all the folks who were not able to this problem in the contest, donot worry, I am one of you guys.\\nBut let me tell you what i observed from the solutions.\\n\\nSTEP 1:\\nYour goal is to iterate a value to reach the length of the array where iteration is based out of the time not the cost.\\nDonot care about the value of cost, but just perform \"TARGET SUM\" solution where target is the length of array and elements are times[].\\n\\nSTEP2:\\nFrom all those possible elements try to minimise the value of cost which you additionally added without any logic. MINIMISING these cost is like reaching through all the values so that you reach the best solution.\\nThere you have the logic to use DP over any other method.\\n\\nA good solution for the above is at : https://leetcode.com/problems/painting-the-walls/discuss/3650617/Easy-Java-Solution-oror-Very-Intuitive-oror-For-Beginners-oror-Upvote\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3650791,
                "title": "dp-go-through-walls-time-balance-can-be-negative",
                "content": "# Intuition\\nUsing paid painter will produce time_balance, using free painter will consume time_balance.\\n\\n**dp(idx,time_balance)**:\\n    The minimal cost to paint wall idx~n, with extra time_balance. \\n\\nWe scan from left to right, for each wall, we can:\\n1. Either use paid painter to paint it\\n2. Or use free painter to paint it.\\n\\nEither way, we must paint wall at index i, don\\'t skip it. In case there is not enough time balance for free painter, don\\'t skip free painter, instead we use free painter and record a negative time balance. Because paid painter coming later might offset this negative balance.\\n\\n# Complexity\\ntime_balance>n will be recorded as n.\\nTime complexity equals total combinations of idx and time_balance, which is: \\nO(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        @cache\\n        def dp(idx,time_balance):\\n            if idx>=n:\\n                return 0 if time_balance>=0 else math.inf\\n            use_paid = cost[idx]+dp(idx+1,min(n,time_balance+time[idx]))\\n            use_free = dp(idx+1,time_balance-1)\\n            return min(use_paid,use_free)\\n        return dp(0,0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        n = len(cost)\\n        @cache\\n        def dp(idx,time_balance):\\n            if idx>=n:\\n                return 0 if time_balance>=0 else math.inf\\n            use_paid = cost[idx]+dp(idx+1,min(n,time_balance+time[idx]))\\n            use_free = dp(idx+1,time_balance-1)\\n            return min(use_paid,use_free)\\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650771,
                "title": "simple-solution-dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // int rec()\\n    // [5,7,8,15]\\n        vector<pair<int,int>> arr;\\n        int n;\\n        int dp[501][1005];\\n        int rec(int idx,int tot){\\n            if(idx==n){\\n                if(tot<n) return 1e9;\\n                return 0;\\n            }\\n            if(tot>=n){\\n                return 0;\\n            }\\n\\n            if(dp[idx][tot]!=-1){\\n                return dp[idx][tot];\\n            }\\n\\n            return dp[idx][tot] = min(rec(idx+1,tot),arr[idx].first+rec(idx+1,1+tot+arr[idx].second));\\n        }\\n    // [2,1,1,1]\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n         n = cost.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back({cost[i],time[i]});\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // int rec()\\n    // [5,7,8,15]\\n        vector<pair<int,int>> arr;\\n        int n;\\n        int dp[501][1005];\\n        int rec(int idx,int tot){\\n            if(idx==n){\\n                if(tot<n) return 1e9;\\n                return 0;\\n            }\\n            if(tot>=n){\\n                return 0;\\n            }\\n\\n            if(dp[idx][tot]!=-1){\\n                return dp[idx][tot];\\n            }\\n\\n            return dp[idx][tot] = min(rec(idx+1,tot),arr[idx].first+rec(idx+1,1+tot+arr[idx].second));\\n        }\\n    // [2,1,1,1]\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n         n = cost.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back({cost[i],time[i]});\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650729,
                "title": "knapsack-0-1-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // int rec()\\n    // [5,7,8,15]\\n        vector<pair<int,int>> arr;\\n        int n;\\n        int dp[501][1005];\\n        int rec(int idx,int tot){\\n            if(idx==n){\\n                if(tot<n) return 1e9;\\n                return 0;\\n            }\\n            if(tot>=n){\\n                return 0;\\n            }\\n\\n            if(dp[idx][tot]!=-1){\\n                return dp[idx][tot];\\n            }\\n\\n            return dp[idx][tot] = min(rec(idx+1,tot),arr[idx].first+rec(idx+1,1+tot+arr[idx].second));\\n        }\\n    // [2,1,1,1]\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n         n = cost.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back({cost[i],time[i]});\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // int rec()\\n    // [5,7,8,15]\\n        vector<pair<int,int>> arr;\\n        int n;\\n        int dp[501][1005];\\n        int rec(int idx,int tot){\\n            if(idx==n){\\n                if(tot<n) return 1e9;\\n                return 0;\\n            }\\n            if(tot>=n){\\n                return 0;\\n            }\\n\\n            if(dp[idx][tot]!=-1){\\n                return dp[idx][tot];\\n            }\\n\\n            return dp[idx][tot] = min(rec(idx+1,tot),arr[idx].first+rec(idx+1,1+tot+arr[idx].second));\\n        }\\n    // [2,1,1,1]\\n    \\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n         n = cost.size();\\n        for(int i=0;i<n;i++){\\n            arr.push_back({cost[i],time[i]});\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650710,
                "title": "python-o-n-2-top-down-convert-problems-to-easy-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        \"\"\"\\n        select x number of paid painter and y total time\\n        select len(time) - x free painter and len(time) - x total time\\n\\n        hence time used by paid painter must be more than or equal time used by free painter\\n        y >= len(time) - x\\n        y + x >= len(time)\\n        sum (ti + 1) >= len(time)\\n        \"\"\"\\n        @cache\\n        def dp(i, t):\\n            if t >= len(time):\\n                return 0\\n\\n            if i == len(cost):\\n                return float(\"inf\")\\n\\n            ans = dp(i + 1, t)\\n            ans = min(ans, cost[i] + dp(i + 1, t + time[i] + 1))\\n            return ans\\n\\n        return dp(0, 0)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\\n        \"\"\"\\n        select x number of paid painter and y total time\\n        select len(time) - x free painter and len(time) - x total time\\n\\n        hence time used by paid painter must be more than or equal time used by free painter\\n        y >= len(time) - x\\n        y + x >= len(time)\\n        sum (ti + 1) >= len(time)\\n        \"\"\"\\n        @cache\\n        def dp(i, t):\\n            if t >= len(time):\\n                return 0\\n\\n            if i == len(cost):\\n                return float(\"inf\")\\n\\n            ans = dp(i + 1, t)\\n            ans = min(ans, cost[i] + dp(i + 1, t + time[i] + 1))\\n            return ans\\n\\n        return dp(0, 0)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1934691,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1934321,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1935666,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1934159,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1935253,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1934858,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1999645,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1990785,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1978855,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1943021,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1934691,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1934321,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1935666,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1934159,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1935253,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1934858,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1999645,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1990785,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1978855,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            },
            {
                "id": 1943021,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Painting the walls with pain in the ..head"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Just in case you are stuck and do not want to see the solution here is a hint\\n\\nhint: consider only painter 1 and think take or not take case"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can it be solved using binary search?"
                    },
                    {
                        "username": "srd2802",
                        "content": "is there any Greedy approach for this question"
                    },
                    {
                        "username": "johan456789",
                        "content": "[@JS00](/JS00) Can you please explain greedy doesn\\'t work? How do you know when solving this problem?"
                    },
                    {
                        "username": "xavier-xia-99",
                        "content": "[@Hussain_14](/Hussain_14) were you able to get AC? cause this one fails at 1724"
                    },
                    {
                        "username": "JS00",
                        "content": "I do not think this can be done without dynamic programming. We have to minimize cost while maximizing time for the paid worker(so that our free worker can paint as many walls as he can as he is fast AND cheap, but only works when paid worker is occupied).\\n\\nIf you have come up with a greedy approach, test it against this case:-\\ncost: [42,8,28,35,21,13,21,35]\\ntime: [2,1,1,1,2,1,1,2]"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I tried the greedy approach. You can see my code here:\\n\\n``class Solution {\\npublic:\\n    static bool comp(pair<int, int> &p1, pair<int, int> &p2)\\n    {\\n        if((p1.first/p1.second)==(p2.first/p2.second))\\n            return p1.first<p2.first;\\n        return (double)(p1.first/p1.second)<(double)(p2.first/p2.second);\\n    }\\n    int paintWalls(vector<int>& cost, vector<int>& time) {\\n\\n         vector<pair<int, int>> p(time.size());\\n        for(int i=0;i<time.size();i++)\\n        {\\n            p[i].first=cost[i];\\n            p[i].second=time[i];\\n        }\\n        \\n        sort(p.begin(), p.end(), comp);  // here I am trying to sort by cost so that the paid \\n//         painter takes the minimum cost greedy is what I am using.\\n        \\n        int i=0;\\n        int j=cost.size();\\n        \\n        int totalcost=0;\\n        while(i<j)\\n        {\\n            int occ=p[i].second;\\n            totalcost+=p[i].first;\\n            while(j>i and occ)\\n                occ--, j--;\\n            i++;\\n        }\\n        \\n        return totalcost;\\n    }\\n}; ``"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Seriously, Why this problem is easier the second medium problem in contest?"
                    },
                    {
                        "username": "qwertyluzzluli",
                        "content": "Can somebody please tell why this code is not working for the testcase cost:[26,53,10,24,25,20,63,51]\ntime:[1,1,1,1,2,2,2,1]\nmine output is 54 \nand the correct output is 55.\nclass Solution {\nprivate:\n    int solve(vector<int>& cost, vector<int>& time,\nint t1,int t2,int index, vector<vector<int>>&dp){\n      int n = time.size();\n      if(index >=n && t1<t2) return 1e9;\n      if(index >=n && t1>=t2) return 0;\n      if(dp[t1][t2] != -1) return dp[t1][t2];\n      int o1 = cost[index] + solve(cost,time,t1+time[index],t2,index+1,dp);\n      int o2 = 0 + solve(cost,time,t1,t2+1,index+1,dp);\n      return dp[t1][t2] = min(o1,o2);\n    }\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n            int n = time.size();\nvector<vector<int>>dp(501,vector<int>(501,-1));\n       return solve(cost,time,0,0,0,dp); \n    }\n};\n"
                    },
                    {
                        "username": "4dalols",
                        "content": "I don\\'t believe it works to store dp[t1][t2], as having the same time pair with a different index may have a different minimum value "
                    },
                    {
                        "username": "Popat_lal",
                        "content": " Where i am missing the trick ? It is saying wrong on second example test case but i am not getiing it why it is wrong ? It has passed 850 testcases.\n```\nclass Solution {\npublic:\nint solve(int i,vector<int>& cost, vector<int>& time,int t ){\n    if(i==cost.size()){\n        return 0;\n    }\n    if(i>cost.size()) return INT_MAX;\n    int free=INT_MAX;\n    if(t>0) free=solve(i+1,cost,time,t-1); \n    int paid=solve(i+1,cost,time,t+time[i])+cost[i];\n    \n    return min(paid,free);\n}\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        return solve(0,cost,time, 0);\n    }\n};\n```"
                    },
                    {
                        "username": "bytheby",
                        "content": "shouldn\\'t the answer just be the sum of the smallest ceil(n-1/2) costs because I will make the free painter paint the walls with the highest costs and since the paid one will be painting the lower cost walls, he will be busy? what am I missing here?"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how    will i conclude 'Paid painters will be used for a maximum of N/2 units of time. There is no need to use paid painter for a time greater than this.'' by my own  observation ."
                    },
                    {
                        "username": "user1565F",
                        "content": "time[I]>=1"
                    },
                    {
                        "username": "user5276Hx",
                        "content": "Do we have to paint the walls in the order in which they are mentioned in the array??"
                    },
                    {
                        "username": "ranestad",
                        "content": "No. You paint them in the most efficient order (the order to get the lest amount of time)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Bind Function to Context",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1952627,
                "content": [
                    {
                        "username": "dhanu084",
                        "content": "This was asked to me in a interview at a well established startup ."
                    },
                    {
                        "username": "saripov_denis",
                        "content": "Should be easy level"
                    }
                ]
            },
            {
                "id": 2066223,
                "content": [
                    {
                        "username": "dhanu084",
                        "content": "This was asked to me in a interview at a well established startup ."
                    },
                    {
                        "username": "saripov_denis",
                        "content": "Should be easy level"
                    }
                ]
            }
        ]
    }
]