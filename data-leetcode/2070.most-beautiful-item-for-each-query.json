[
    {
        "title": "Most Beautiful Item for Each Query",
        "question_content": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.\n&nbsp;\nExample 1:\n\nInput: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\nOutput: [2,4,5,5,6,6]\nExplanation:\n- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.\n\nExample 2:\n\nInput: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\nOutput: [4]\nExplanation: \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.  \n\nExample 3:\n\nInput: items = [[10,1000]], queries = [5]\nOutput: [0]\nExplanation:\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= items.length, queries.length <= 105\n\titems[i].length == 2\n\t1 <= pricei, beautyi, queries[j] <= 109",
        "solutions": [
            {
                "id": 1575898,
                "title": "c-solution-sorting",
                "content": "**Solution**\\n\\n* Brute force approach would be : For each query, traverse the items and check the ones having price less than or equal to `queries[i]` and find the maximum beauty among these items - *O(QN)*.\\n* Drawback of previous approach is, we have to traverse items multiple times. If we have found the answer for query say 80, we can find the answer for query 100 by only traversing the item with price in the range (80, 100] instead of checking all items in price range [0, 100].\\n\\n* If the items are sorted in increasing order of their price, then in the above example, for query 80 we will traverse the items only upto price 80 and then for 100 we will continue from the item where we would have left for 80.\\n\\n* The only problem is that the above method need the queries to be in increasing order. If query 80 comes after 100 then we don\\'t have a way to use result for 100 to find the result for 80.\\n\\n* Hence, we will sort the queries, keeping their original index with them. Then process them in the same order.\\n\\n**Algorithm**\\n\\n1. Store each query `queries[i]` as a pair of {`queries[i]`, `i`} into the vector `queriesPair`.\\n2. Sort `queriesPair` and `items` in ascending order.\\n3. Iterate over `queriesPair`, find the maximum beauty of item having price less than `queriesPair[i].first`\\n4. Store it in the `maxBeauty`.\\n5. Store `maxBeauty` in the answer vector `ans` at index `queriesPair[i].second`.\\n\\n**Time Complexity**: \\n\\n- Sorting items takes NlogN\\n- Sorting queries takes QlogQ\\n- Iterating over each Item and query takes (N + Q)\\n- Time Complexity : O(NlogN + QlogQ)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        vector<int> ans(queries.size());\\n        \\n        vector<pair<int ,int>> queriesPair;\\n        for (int i = 0; i < queries.size(); i++) {\\n            queriesPair.push_back({queries[i], i});\\n        }\\n        \\n        sort(queriesPair.begin(), queriesPair.end());\\n        sort(items.begin(), items.end());\\n        \\n        int itemIndex = 0, maxBeauty = 0;\\n        for (int i = 0; i < queriesPair.size(); i++) {\\n            int maxPriceAllowed = queriesPair[i].first;\\n            int queryOriginalIndex = queriesPair[i].second;\\n            \\n            // Iterate over items, stop when the price exceeds query price or no item left\\n            while (itemIndex < items.size() && items[itemIndex][0] <= maxPriceAllowed) {\\n                maxBeauty = max(maxBeauty, items[itemIndex][1]);\\n                itemIndex++;\\n            }\\n            \\n            ans[queryOriginalIndex] = maxBeauty;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        vector<int> ans(queries.size());\\n        \\n        vector<pair<int ,int>> queriesPair;\\n        for (int i = 0; i < queries.size(); i++) {\\n            queriesPair.push_back({queries[i], i});\\n        }\\n        \\n        sort(queriesPair.begin(), queriesPair.end());\\n        sort(items.begin(), items.end());\\n        \\n        int itemIndex = 0, maxBeauty = 0;\\n        for (int i = 0; i < queriesPair.size(); i++) {\\n            int maxPriceAllowed = queriesPair[i].first;\\n            int queryOriginalIndex = queriesPair[i].second;\\n            \\n            // Iterate over items, stop when the price exceeds query price or no item left\\n            while (itemIndex < items.size() && items[itemIndex][0] <= maxPriceAllowed) {\\n                maxBeauty = max(maxBeauty, items[itemIndex][1]);\\n                itemIndex++;\\n            }\\n            \\n            ans[queryOriginalIndex] = maxBeauty;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575928,
                "title": "java-treemap-binarysearch-similar-problems",
                "content": "similar problems:\\n1235. Maximum Profit in Job Scheduling https://leetcode.com/problems/maximum-profit-in-job-scheduling/\\n2008. Maximum Earnings From Taxi https://leetcode.com/problems/maximum-earnings-from-taxi/\\n1353. Maximum Number of Events That Can Be Attended  https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/\\n2054. Two Best Non-Overlapping Events https://leetcode.com/problems/two-best-non-overlapping-events/\\n\\nTreeMap\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int[] result = new int[queries.length];\\n        Arrays.sort(items, (a, b) -> (a[0] - b[0]));\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>(){{put(0, 0);}};\\n        int currMax = 0;\\n        for(int[] item : items) {\\n            currMax = Math.max(currMax, item[1]);      //maintain largerst beauty so far\\n            map.put(item[0], currMax);                 //store in treeMap\\n        }\\n        \\n        for(int i = 0; i < queries.length; ++i)\\n            result[i] = map.floorEntry(queries[i]).getValue();\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nBinarySearch:\\n\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int[] result = new int[queries.length];\\n        Arrays.sort(items, (a, b) -> (a[0] - b[0]));\\n        \\n        for(int i = 1; i < items.length; ++i)\\n            items[i][1] = Math.max(items[i][1], items[i - 1][1]);\\n\\n        for(int j = 0; j < queries.length; ++j)\\n            result[j] = binarySearch(items, queries[j]);\\n        \\n        return result;\\n    }\\n    \\n    private int binarySearch(int[][] items, int target) {\\n        int lo = 0, hi = items.length - 1;\\n        while(lo < hi) {\\n            int mid = (lo + hi + 1) >> 1;  //find rightmost item\\n            if(items[mid][0] > target)\\n                hi = mid - 1;\\n            else\\n                lo = mid;\\n        }\\n        return items[lo][0] <= target ? items[lo][1] : 0;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int[] result = new int[queries.length];\\n        Arrays.sort(items, (a, b) -> (a[0] - b[0]));\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>(){{put(0, 0);}};\\n        int currMax = 0;\\n        for(int[] item : items) {\\n            currMax = Math.max(currMax, item[1]);      //maintain largerst beauty so far\\n            map.put(item[0], currMax);                 //store in treeMap\\n        }\\n        \\n        for(int i = 0; i < queries.length; ++i)\\n            result[i] = map.floorEntry(queries[i]).getValue();\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576050,
                "title": "python-4-lines-solution",
                "content": "# **Explanation**\\nStep 1. Sort the items by price, `O(nlog)`\\nStep 2. Iterate items, find maximum value up to now, `O(n)`\\nStep 3. For each queries, binary search the maximum `beauty`, `O(qlog)`\\nStep 3 can be doen in `O(q+n)` though.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn + qlogn)`\\nSpace `O(n)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def maximumBeauty(self, A, queries):\\n        A = sorted(A + [[0, 0]])\\n        for i in xrange(len(A) - 1):\\n            A[i + 1][1] = max(A[i][1], A[i + 1][1])\\n        return [A[bisect.bisect(A, [q + 1]) - 1][1] for q in queries]\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def maximumBeauty(self, A, queries):\\n        A = sorted(A + [[0, 0]])\\n        for i in xrange(len(A) - 1):\\n            A[i + 1][1] = max(A[i][1], A[i + 1][1])\\n        return [A[bisect.bisect(A, [q + 1]) - 1][1] for q in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1576065,
                "title": "c-offline-query",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Offline Query\\n\\nA common trick for solving problems related to a series of queries. \\n\\nWhen we know all the queries upfront, we can sort the query and the original data in some order so that we can scan the query and the original data simultaneously (which takes `O(N + Q)` time), instead of scanning all original data for each query (which takes `O(N * Q)` time).\\n\\nThe name \"offline\" signifies the fact that we know all the queries upfront/offline. If the queries keep streaming in (i.e. online), we can\\'t reorder the queries to get a better time complexity.\\n\\n**Problems**:\\n* [1707. Maximum XOR With an Element From Array (Hard)](https://leetcode.com/problems/maximum-xor-with-an-element-from-array/)\\n* [1847. Closest Room (Hard)](https://leetcode.com/problems/closest-room/)\\n* [2070. Most Beautiful Item for Each Query (Medium)](https://leetcode.com/problems/most-beautiful-item-for-each-query/)\\n\\n## Solution 1. Offline Query\\n\\nSort both `items` and `queries` in ascending order of `price`. Traverse `queries`. Use a pointer `i` to cover all the items with a price `<=` the current query, and compute the maximum beauty among them. In this way, we traverse both array only once.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/most-beautiful-item-for-each-query/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN + MlogM + M + N) where `N`/`M` is the length of `items`/`queries`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& A, vector<int>& Q) {\\n        vector<pair<int, int>> queries;\\n        for (int i = 0; i < Q.size(); ++i) queries.push_back({Q[i],i});\\n        sort(begin(queries), end(queries));\\n        sort(begin(A), end(A));\\n        int i = 0, N = A.size(), maxBeauty = 0;\\n        vector<int> ans(Q.size());\\n        for (auto q : queries) {\\n            auto &[query, index] = q;\\n            for (; i < N && A[i][0] <= query; ++i) maxBeauty = max(maxBeauty, A[i][1]);\\n            ans[index] = maxBeauty;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/most-beautiful-item-for-each-query/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN + MlogM + M + N) where `N`/`M` is the length of `items`/`queries`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& A, vector<int>& Q) {\\n        vector<pair<int, int>> queries;\\n        for (int i = 0; i < Q.size(); ++i) queries.push_back({Q[i],i});\\n        sort(begin(queries), end(queries));\\n        sort(begin(A), end(A));\\n        int i = 0, N = A.size(), maxBeauty = 0;\\n        vector<int> ans(Q.size());\\n        for (auto q : queries) {\\n            auto &[query, index] = q;\\n            for (; i < N && A[i][0] <= query; ++i) maxBeauty = max(maxBeauty, A[i][1]);\\n            ans[index] = maxBeauty;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575883,
                "title": "simple-java-solution-using-treemap",
                "content": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items,(a,b)->a[0]-b[0]); // Sort items by price in ascending order\\n        int maxBeauty = 0;\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        for(int[] item: items){\\n            maxBeauty = Math.max(maxBeauty,item[1]); // rolling max of beauty seen\\n            tm.put(item[0],maxBeauty);\\n        }\\n        int result[] = new int[queries.length];\\n        int index=0;\\n        for(int query: queries){\\n            Integer key = tm.floorKey(query); // if entry for a price exists, value should have max beauty seen else pick floor price entry\\n            result[index++] = (key==null)?0:tm.get(key); \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items,(a,b)->a[0]-b[0]); // Sort items by price in ascending order\\n        int maxBeauty = 0;\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        for(int[] item: items){\\n            maxBeauty = Math.max(maxBeauty,item[1]); // rolling max of beauty seen\\n            tm.put(item[0],maxBeauty);\\n        }\\n        int result[] = new int[queries.length];\\n        int index=0;\\n        for(int query: queries){\\n            Integer key = tm.floorKey(query); // if entry for a price exists, value should have max beauty seen else pick floor price entry\\n            result[index++] = (key==null)?0:tm.get(key); \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575893,
                "title": "c-easy-sorting-binary-search-solution-qlogn-nlogn",
                "content": "1) Sort in ascending order of price and beauty\\n2) Now set the prefix max Beauty for each pair\\n\\nBefore Sorting \\n1 2\\t\\n3 2\\t\\n2 4\\t\\n5 6\\t\\n3 5\\t\\n\\n\\nAfter sorting \\n1 2                          \\n2 4                          \\n3 2                          \\n3 5                          \\n5 6                          \\n\\n\\nPrefix Max\\n\\n1 2\\n2 4\\n3 4\\n3 5\\n5 6\\n\\n\\nFor each query , find the largest last pair whose price is less than equal to given value , and print the correspoding prefix max beauty.\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        int maxi = items[0][1];\\n        // for(auto xt : items)\\n        // {\\n        //    cout<<xt[0]<<\" \"<<xt[1]<<endl;\\n        // }\\n        for(auto &xt : items)\\n        {\\n            maxi = max(maxi , xt[1]);\\n            xt[1] = maxi;\\n        }\\n        // for(auto xt : items)\\n        // {\\n        //    cout<<xt[0]<<\" \"<<xt[1]<<endl;\\n        // }\\n        vector<int>ans;\\n        int n = items.size();\\n        \\n        for(int key : queries){\\n            int left = 0;\\n            int right = n - 1;\\n\\n            int count = 0;\\n\\n            while (left <= right) {\\n                int mid = (right + left) / 2;\\n                if (items[mid][0] <= key) {\\n                    count = mid + 1;\\n                    left = mid + 1;\\n                }\\n                else\\n                    right = mid - 1;\\n            }\\n            \\n            if(count==0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(items[count-1][1]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        int maxi = items[0][1];\\n        // for(auto xt : items)\\n        // {\\n        //    cout<<xt[0]<<\" \"<<xt[1]<<endl;\\n        // }\\n        for(auto &xt : items)\\n        {\\n            maxi = max(maxi , xt[1]);\\n            xt[1] = maxi;\\n        }\\n        // for(auto xt : items)\\n        // {\\n        //    cout<<xt[0]<<\" \"<<xt[1]<<endl;\\n        // }\\n        vector<int>ans;\\n        int n = items.size();\\n        \\n        for(int key : queries){\\n            int left = 0;\\n            int right = n - 1;\\n\\n            int count = 0;\\n\\n            while (left <= right) {\\n                int mid = (right + left) / 2;\\n                if (items[mid][0] <= key) {\\n                    count = mid + 1;\\n                    left = mid + 1;\\n                }\\n                else\\n                    right = mid - 1;\\n            }\\n            \\n            if(count==0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(items[count-1][1]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1578512,
                "title": "sort-and-sweep",
                "content": "Rhymes with short and sweet :)\\n\\nWe sort items cheap-to-expensive, and then sweep the array and assign maximum beauty so far.\\n\\nThen, use a binary search to find the maximum beauty for the price.\\n\\n**C++**\\n```cpp\\nvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& qs) {\\n    sort(begin(items), end(items));\\n    for (int i = 1; i < items.size(); ++i)\\n        items[i][1] = max(items[i][1], items[i - 1][1]);\\n    for (int i = 0; i < qs.size(); ++i) {\\n        auto it = upper_bound(begin(items), end(items), vector<int>{qs[i], INT_MAX});\\n        qs[i] = it == begin(items) ? 0 : (*prev(it))[1];\\n    }\\n    return qs;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& qs) {\\n    sort(begin(items), end(items));\\n    for (int i = 1; i < items.size(); ++i)\\n        items[i][1] = max(items[i][1], items[i - 1][1]);\\n    for (int i = 0; i < qs.size(); ++i) {\\n        auto it = upper_bound(begin(items), end(items), vector<int>{qs[i], INT_MAX});\\n        qs[i] = it == begin(items) ? 0 : (*prev(it))[1];\\n    }\\n    return qs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575973,
                "title": "python3-sorting-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        maxArr = [items[0][1]] * len(items)\\n\\t\\t# for each cell calculate maximum beautifulnes\\n        for i in range(1, len(items)):\\n            maxArr[i] = max(maxArr[i-1], items[i][1])\\n        \\n        onlyKeys = list(map(lambda x:x[0], items)) # since 3.9 python doesn\\'t have `key` in bisect\\n        \\n        res = []\\n        for q in queries:\\n            # if minimum price is greated than query, no items can be found for query\\n            notPossible = items[0][0] > q\\n            if notPossible:\\n                res.append(0)\\n            else:\\n                # otherwise find last cell with value less or equals to query\\n                i = bisect.bisect_right(onlyKeys, q)\\n                # lookup result in our maximum array by index\\n                res.append(maxArr[i-1])\\n        \\n        return res\\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        maxArr = [items[0][1]] * len(items)\\n\\t\\t# for each cell calculate maximum beautifulnes\\n        for i in range(1, len(items)):\\n            maxArr[i] = max(maxArr[i-1], items[i][1])\\n        \\n        onlyKeys = list(map(lambda x:x[0], items)) # since 3.9 python doesn\\'t have `key` in bisect\\n        \\n        res = []\\n        for q in queries:\\n            # if minimum price is greated than query, no items can be found for query\\n            notPossible = items[0][0] > q\\n            if notPossible:\\n                res.append(0)\\n            else:\\n                # otherwise find last cell with value less or equals to query\\n                i = bisect.bisect_right(onlyKeys, q)\\n                # lookup result in our maximum array by index\\n                res.append(maxArr[i-1])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575918,
                "title": "c-o-nlogn-map-binary-search",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n=items.size(), m=queries.size();\\n        \\n        map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            int p=items[i][0], b=items[i][1];\\n            if(mp.find(p)==mp.end()){\\n                mp[p]=b;\\n            }else{\\n                int prev=mp[p];\\n                mp[p]=max(prev,b);\\n            }\\n        }\\n        map<int,int> :: iterator it;\\n        int maxb=-1;\\n        for(it=mp.begin();it!=mp.end();it++){\\n            int p=it->first;\\n            int b=mp[p];\\n            maxb=max(maxb,b);\\n            mp[p]=maxb; // maximum beauty possible till price [1,p]\\n        }\\n        \\n        vector<int> ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int p=queries[i];\\n            \\n            if(mp.find(p)!=mp.end()){\\n                ans[i]=mp[p];\\n            }else{\\n                auto it = mp.lower_bound(p); // checking beauty for price just lower than for given query\\n                if(it!=mp.begin()){\\n                    --it;\\n                    ans[i]=it->second;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Do Upvote If it Helps**",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n=items.size(), m=queries.size();\\n        \\n        map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            int p=items[i][0], b=items[i][1];\\n            if(mp.find(p)==mp.end()){\\n                mp[p]=b;\\n            }else{\\n                int prev=mp[p];\\n                mp[p]=max(prev,b);\\n            }\\n        }\\n        map<int,int> :: iterator it;\\n        int maxb=-1;\\n        for(it=mp.begin();it!=mp.end();it++){\\n            int p=it->first;\\n            int b=mp[p];\\n            maxb=max(maxb,b);\\n            mp[p]=maxb; // maximum beauty possible till price [1,p]\\n        }\\n        \\n        vector<int> ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int p=queries[i];\\n            \\n            if(mp.find(p)!=mp.end()){\\n                ans[i]=mp[p];\\n            }else{\\n                auto it = mp.lower_bound(p); // checking beauty for price just lower than for given query\\n                if(it!=mp.begin()){\\n                    --it;\\n                    ans[i]=it->second;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575882,
                "title": "java-o-nlogn-o-qlogn-sort-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] q) {\\n        \\n        Arrays.sort(items,(a,b)->a[0]-b[0]); // sort on the basis of prices.\\n        \\n        for(int i = 1; i < items.length; i++){\\n            items[i][1] = Math.max( items[i][1], items[i-1][1] ); // ith item will store max beauty till now.\\n        }\\n        \\n        int n = q.length;\\n        int ans[] = new int[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            int s = 0, e = items.length - 1;\\n            \\n            while(s <= e){  // perform binary search to find the last price <= queries[i].\\n                int mid = s + (e - s) / 2;\\n                \\n                if(items[mid][0] <= q[i]) {\\n                    s = mid + 1;\\n                    ans[i] = Math.max( ans[i], items[mid][1] );        // update ans[i] for max value.\\n                }else{\\n                    e = mid - 1;\\n                }\\n            \\n            }\\n            \\n        }\\n    \\n        return ans;\\n    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] q) {\\n        \\n        Arrays.sort(items,(a,b)->a[0]-b[0]); // sort on the basis of prices.\\n        \\n        for(int i = 1; i < items.length; i++){\\n            items[i][1] = Math.max( items[i][1], items[i-1][1] ); // ith item will store max beauty till now.\\n        }\\n        \\n        int n = q.length;\\n        int ans[] = new int[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            int s = 0, e = items.length - 1;\\n            \\n            while(s <= e){  // perform binary search to find the last price <= queries[i].\\n                int mid = s + (e - s) / 2;\\n                \\n                if(items[mid][0] <= q[i]) {\\n                    s = mid + 1;\\n                    ans[i] = Math.max( ans[i], items[mid][1] );        // update ans[i] for max value.\\n                }else{\\n                    e = mid - 1;\\n                }\\n            \\n            }\\n            \\n        }\\n    \\n        return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576408,
                "title": "binary-search-solution",
                "content": "Sort the array by its price and then modify the items array in such a way that each item contains the maximum value that we can get within that price.\\n\\nfor example if we have items=[[2,5], [3,2], [4,4]]\\nthen modified items=[[2,5], [3,5], [4,5]]\\nhere the values of items[1] and items[2] is 5 because that is the maximum value we can get within price=4, price=3 and price=2.\\n\\nNow the items array contains the maximum value that we can get within price p. So for each query we just need to find the index of the item for which price<=queries[i].**\\n\\nQuestion with similar concept : https://leetcode.com/problems/two-best-non-overlapping-events/\\n\\n```\\nvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        int cur=0;\\n        for(int i=0;i<items.size();i++){\\n            cur=max(items[i][1], cur);\\n            items[i][1]=cur;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int x=queries[i];\\n            int low=0, high=items.size()-1, mid=0, a=-1;\\n            while(low<high){\\n                mid=low+(high-low)/2;\\n                if(items[mid][0]<=x){\\n                    a=mid;\\n                    low=mid+1;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n            if(items[low][0]<=x)a=low;\\n            if(a==-1)ans.push_back(0);\\n            else\\n            ans.push_back(items[a][1]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        int cur=0;\\n        for(int i=0;i<items.size();i++){\\n            cur=max(items[i][1], cur);\\n            items[i][1]=cur;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int x=queries[i];\\n            int low=0, high=items.size()-1, mid=0, a=-1;\\n            while(low<high){\\n                mid=low+(high-low)/2;\\n                if(items[mid][0]<=x){\\n                    a=mid;\\n                    low=mid+1;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n            if(items[low][0]<=x)a=low;\\n            if(a==-1)ans.push_back(0);\\n            else\\n            ans.push_back(items[a][1]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576202,
                "title": "c-easy-solution-sorting-binary-search-clean-code",
                "content": "This question is based on **binary search**.\\n\\n**Approach:**\\n1. First **sort** the items vector.\\n2. Now store the maximum value of beauty till the current index i ( i >=0 && i <= n-1)\\n3. Now iterate on the queries vector and **find the greatest index of the q[i] in the items vector using binary search.**\\n4. **If the index is -1** then there is no such value in items vector. Simply put 0 in ans[i]. \\n5. Store the value corresponding to this index in ans[i].\\n\\n**Code:**\\n\\n\\n    int binary_s(vector<vector<int>>&items, int val){\\n        \\n        int lo = 0;\\n        int hi = items.size() - 1;\\n        \\n        int ans = -1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(items[mid][0] <= val){\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n            else{\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& q) {\\n        \\n        int n = items.size();\\n        sort(items.begin() , items.end());\\n        \\n        vector<int>a(n);\\n        int max_val = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            int val = items[i][1];\\n            max_val = max(max_val , val);\\n            a[i] = max_val;\\n        }\\n        \\n        int m = q.size();\\n        \\n        vector<int>ans(m);\\n        for(int i = 0 ; i < m ; i++){\\n            int idx = binary_s(items, q[i]);\\n            if(idx == -1){\\n                ans[i] = 0;\\n            }\\n            else{\\n                ans[i] = a[idx];   \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n\\tPlease upvote the post if this helped you!",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "This question is based on **binary search**.\\n\\n**Approach:**\\n1. First **sort** the items vector.\\n2. Now store the maximum value of beauty till the current index i ( i >=0 && i <= n-1)\\n3. Now iterate on the queries vector and **find the greatest index of the q[i] in the items vector using binary search.**\\n4. **If the index is -1** then there is no such value in items vector. Simply put 0 in ans[i]. \\n5. Store the value corresponding to this index in ans[i].\\n\\n**Code:**\\n\\n\\n    int binary_s(vector<vector<int>>&items, int val){\\n        \\n        int lo = 0;\\n        int hi = items.size() - 1;\\n        \\n        int ans = -1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(items[mid][0] <= val){\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n            else{\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& q) {\\n        \\n        int n = items.size();\\n        sort(items.begin() , items.end());\\n        \\n        vector<int>a(n);\\n        int max_val = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            int val = items[i][1];\\n            max_val = max(max_val , val);\\n            a[i] = max_val;\\n        }\\n        \\n        int m = q.size();\\n        \\n        vector<int>ans(m);\\n        for(int i = 0 ; i < m ; i++){\\n            int idx = binary_s(items, q[i]);\\n            if(idx == -1){\\n                ans[i] = 0;\\n            }\\n            else{\\n                ans[i] = a[idx];   \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n\\tPlease upvote the post if this helped you!",
                "codeTag": "Unknown"
            },
            {
                "id": 1575934,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        vector<int> arr1,arr2;\\n        \\n        for(int i=0;i<items.size();i++){\\n            arr1.push_back(items[i][0]);\\n            arr2.push_back(items[i][1]);\\n        }\\n        \\n        vector<int> ret;\\n        \\n        vector<int>narr;\\n        int maxm = 0;\\n        \\n        // creating a new array which stores maximum value till ith term;\\n        for(int i=0;i<arr2.size();i++){\\n            maxm = max(maxm,arr2[i]);\\n            narr.push_back(maxm);\\n        }\\n        \\n        for(int i =0;i<queries.size();i++){\\n            int x = queries[i];\\n            \\n            auto l = lower_bound(arr1.begin(),arr1.end(),x+1);\\n            int dis = l-1-arr1.begin();\\n            \\n            if(dis == -1) ret.push_back(0);\\n            else ret.push_back(narr[dis]); // directly putting maximum value using the array which we created earlier\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        vector<int> arr1,arr2;\\n        \\n        for(int i=0;i<items.size();i++){\\n            arr1.push_back(items[i][0]);\\n            arr2.push_back(items[i][1]);\\n        }\\n        \\n        vector<int> ret;\\n        \\n        vector<int>narr;\\n        int maxm = 0;\\n        \\n        // creating a new array which stores maximum value till ith term;\\n        for(int i=0;i<arr2.size();i++){\\n            maxm = max(maxm,arr2[i]);\\n            narr.push_back(maxm);\\n        }\\n        \\n        for(int i =0;i<queries.size();i++){\\n            int x = queries[i];\\n            \\n            auto l = lower_bound(arr1.begin(),arr1.end(),x+1);\\n            int dis = l-1-arr1.begin();\\n            \\n            if(dis == -1) ret.push_back(0);\\n            else ret.push_back(narr[dis]); // directly putting maximum value using the array which we created earlier\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297445,
                "title": "python3-sort-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem said `price is less than or equal` so it means we can think about sorting by `price` and then do binary search to find `price is less than or equal` to the `queries[j]`. But it is not only that simple. In here we have to find the maximum `beauty` for all the price less than or equal to `queries[j]`. Assume the highest `price` in `items` that is <= `queries[j]` is at index `i`. we can easily get that `max beauty = items[k][1] for 0 <= k <= i` \\n- So we must find the max beauty in range from 0 to i for the `queries[j]`\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort items by price - $O(nlogn)$\\n- update the beauty for index i in items = `max(items[x] for x in range(i + 1))` - $O(n)$\\n- for each query, binary search for the highest item which has price `<=` this query\\'s value, then add to final result the `max beauty` in range `first query to current querry` - $O(nlogn)$\\n\\n# Complexity\\n- Time complexity: $O(nlogn + n + nlogn)$ ~ $O(nlogn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        n = len(items)\\n        res = []\\n        for i in range(1, n):\\n            items[i][1] = max(items[i][1], items[i - 1][1])\\n\\n        for q in queries:\\n            l, r = 0, n - 1\\n            while l <= r:\\n                m = (l + r) >> 1\\n                p, b = items[m]\\n                if p > q: r = m - 1\\n                else: l = m + 1\\n            res.append(items[r][1] if r >= 0 else 0)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        n = len(items)\\n        res = []\\n        for i in range(1, n):\\n            items[i][1] = max(items[i][1], items[i - 1][1])\\n\\n        for q in queries:\\n            l, r = 0, n - 1\\n            while l <= r:\\n                m = (l + r) >> 1\\n                p, b = items[m]\\n                if p > q: r = m - 1\\n                else: l = m + 1\\n            res.append(items[r][1] if r >= 0 else 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410510,
                "title": "c-simple-c-code-o-nlogn",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int BinarySearch(vector<vector<int>>& items, int q, vector<int> &Beauty)\\n    {\\n        int start = 0, end = items.size()-1;\\n        int val = 0;\\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            if(q >= items[mid][0])\\n            {\\n                val = Beauty[mid];\\n                start = mid+1;\\n            }\\n            else\\n                end = mid-1;\\n        }\\n        return val;\\n    }\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) \\n    {\\n        int n = items.size();\\n        sort(items.begin(), items.end());\\n        vector<int> ans, mxBeauty(n);\\n        mxBeauty[0] = items[0][1];\\n        for(int i = 1; i < n; i++)\\n        {\\n            mxBeauty[i] = max(mxBeauty[i-1],items[i][1]);\\n        }\\n        for(int &q : queries)\\n        {\\n            ans.push_back(BinarySearch(items, q, mxBeauty));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int BinarySearch(vector<vector<int>>& items, int q, vector<int> &Beauty)\\n    {\\n        int start = 0, end = items.size()-1;\\n        int val = 0;\\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            if(q >= items[mid][0])\\n            {\\n                val = Beauty[mid];\\n                start = mid+1;\\n            }\\n            else\\n                end = mid-1;\\n        }\\n        return val;\\n    }\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) \\n    {\\n        int n = items.size();\\n        sort(items.begin(), items.end());\\n        vector<int> ans, mxBeauty(n);\\n        mxBeauty[0] = items[0][1];\\n        for(int i = 1; i < n; i++)\\n        {\\n            mxBeauty[i] = max(mxBeauty[i-1],items[i][1]);\\n        }\\n        for(int &q : queries)\\n        {\\n            ans.push_back(BinarySearch(items, q, mxBeauty));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612984,
                "title": "most-beautiful-item-for-each-query-using-binary-search",
                "content": "**Most Beautiful item for Each Query **\\n// all steps \\n->>>>> \\n // items - > [[2,4], [4,5], [2,1] ,[3,6] ,[1,3]]  another example i take\\n      // quries-> [1,3,2]\\n\\n      // fill the answer array \\n      // ans = [3,6,4]\\n\\n\\n      // sort the items array\\n      // [[1,3] , [2,1] ,[2,4] ,[3,6] ,[4,5]]\\n      // store prefix max in items[i][1]\\n\\n      // [[1,3], [2,3], [2,4], [3,6], [4,6]]\\n\\n      //  loop over each quries \\n      // price req is quries[i]\\n\\n     // find a index in items array where items[i][0] > priceRequired\\n\\n     // the previous ind is the ans and the beauty is store over\\n     // items[ind][1] \\n\\t \\n\\t \\n\\t \\n# code -> using binary search\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        \\n      \\n    sort(items.begin() , items.end());\\n\\n    // calculate the prefix max array\\n   \\n    int n = items.size();\\n    for(int i =0 ; i<n ; i++){\\n      if(i==0) continue;\\n\\n      items[i][1] = max(items[i-1][1] , items[i][1] );\\n    }\\n\\n\\n   // [[1,3], [2,3], [2,4], [3,6], [4,6]]  are formed now\\n\\nvector<int> ans;\\n\\n  for(auto &priceReq : queries){\\n      vector<int> dummy(2);\\n\\n      dummy[0] = priceReq;\\n      dummy[1] = INT_MAX;\\n\\n      int ind = upper_bound(items.begin() , items.end() , dummy) - items.begin();\\n\\n      ind--;\\n\\n      if(ind>=0){\\n        ans.push_back(items[ind][1]);\\n      }else\\n      {\\n        ans.push_back(0);\\n      } \\n  }\\n\\n\\n      \\n      return ans;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        \\n      \\n    sort(items.begin() , items.end());\\n\\n    // calculate the prefix max array\\n   \\n    int n = items.size();\\n    for(int i =0 ; i<n ; i++){\\n      if(i==0) continue;\\n\\n      items[i][1] = max(items[i-1][1] , items[i][1] );\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1596922,
                "title": "well-explained-99-faster-mainly-for-beginners",
                "content": "## IDEA :\\n\\n* Step 1. Sort the items by price, O(nlog)\\n\\n* Step 2. Iterate items, find maximum value up to now, O(n) and store the max value in dictionary(MAP) here `dic`.\\n* Step 3. For each queries, binary search the maximum beauty, O(log k) in key of the map which we formed and append the max value of the query from dictionary in O(1) .\\n* Step 4. Whole process is doen in `O(q+n)` though.\\n\\n**Impementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n\\n\\t\\t\\titems.sort()\\n\\t\\t\\tdic = dict()\\n\\t\\t\\tres = []\\n\\t\\t\\tgmax = 0\\n\\t\\t\\tfor p,b in items:\\n\\t\\t\\t\\tgmax = max(b,gmax)\\n\\t\\t\\t\\tdic[p] = gmax\\n\\n\\t\\t\\tkeys = sorted(dic.keys())\\n\\t\\t\\tfor q in queries:\\n\\t\\t\\t\\tind = bisect.bisect_left(keys,q)\\n\\t\\t\\t\\tif ind<len(keys) and keys[ind]==q:\\n\\t\\t\\t\\t\\tres.append(dic[q])\\n\\t\\t\\t\\telif ind==0:\\n\\t\\t\\t\\t\\tres.append(0)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append(dic[keys[ind-1]])\\n\\n\\t\\t\\treturn res\\n\\t\\n### \\tThanks and Upvote if you like the Idea !!\\u270C",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Sorting"
                ],
                "code": "## IDEA :\\n\\n* Step 1. Sort the items by price, O(nlog)\\n\\n* Step 2. Iterate items, find maximum value up to now, O(n) and store the max value in dictionary(MAP) here `dic`.\\n* Step 3. For each queries, binary search the maximum beauty, O(log k) in key of the map which we formed and append the max value of the query from dictionary in O(1) .\\n* Step 4. Whole process is doen in `O(q+n)` though.\\n\\n**Impementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n\\n\\t\\t\\titems.sort()\\n\\t\\t\\tdic = dict()\\n\\t\\t\\tres = []\\n\\t\\t\\tgmax = 0\\n\\t\\t\\tfor p,b in items:\\n\\t\\t\\t\\tgmax = max(b,gmax)\\n\\t\\t\\t\\tdic[p] = gmax\\n\\n\\t\\t\\tkeys = sorted(dic.keys())\\n\\t\\t\\tfor q in queries:\\n\\t\\t\\t\\tind = bisect.bisect_left(keys,q)\\n\\t\\t\\t\\tif ind<len(keys) and keys[ind]==q:\\n\\t\\t\\t\\t\\tres.append(dic[q])\\n\\t\\t\\t\\telif ind==0:\\n\\t\\t\\t\\t\\tres.append(0)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append(dic[keys[ind-1]])\\n\\n\\t\\t\\treturn res\\n\\t\\n### \\tThanks and Upvote if you like the Idea !!\\u270C",
                "codeTag": "Java"
            },
            {
                "id": 1576228,
                "title": "100-faster-sorting-and-map-c",
                "content": "```\\nvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        map<int,int> mp;\\n        int maxbeauty=INT_MIN;\\n        for(auto i:items){\\n            maxbeauty=max(maxbeauty,i[1]);\\n            mp[i[0]]=maxbeauty;\\n        }\\n        vector<int> ans(queries.size());\\n        \\n        for(int i=0;i<queries.size();i++){\\n\\t\\t\\n            if(mp.find(queries[i])!=mp.end()){\\n                ans[i]=mp[queries[i]];\\n            }\\n\\t\\t\\t\\n            else{\\n                   auto it = mp.lower_bound(queries[i]);   // In, it=mp.lower_bound(value), it always points on key which is higher than value\\n                   if(it!=mp.begin()){\\n                              it--;\\n                              ans[i]=(*it).second;\\n                            }\\n                   else ans[i]=0;\\n               }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        map<int,int> mp;\\n        int maxbeauty=INT_MIN;\\n        for(auto i:items){\\n            maxbeauty=max(maxbeauty,i[1]);\\n            mp[i[0]]=maxbeauty;\\n        }\\n        vector<int> ans(queries.size());\\n        \\n        for(int i=0;i<queries.size();i++){\\n\\t\\t\\n            if(mp.find(queries[i])!=mp.end()){\\n                ans[i]=mp[queries[i]];\\n            }\\n\\t\\t\\t\\n            else{\\n                   auto it = mp.lower_bound(queries[i]);   // In, it=mp.lower_bound(value), it always points on key which is higher than value\\n                   if(it!=mp.begin()){\\n                              it--;\\n                              ans[i]=(*it).second;\\n                            }\\n                   else ans[i]=0;\\n               }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3278733,
                "title": "c-most-easy-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        map<int,int> mp;\\n        int maxi=INT_MIN;\\n        int n=items.size();\\n        mp[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,items[i][1]);\\n            mp[items[i][0]]=maxi;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            auto it=mp.lower_bound(queries[i]);\\n            if(mp.find(queries[i])!=mp.end())\\n            ans.push_back((*it).second);\\n            else\\n            {\\n                *it--;\\n                ans.push_back((*it).second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        map<int,int> mp;\\n        int maxi=INT_MIN;\\n        int n=items.size();\\n        mp[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,items[i][1]);\\n            mp[items[i][0]]=maxi;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            auto it=mp.lower_bound(queries[i]);\\n            if(mp.find(queries[i])!=mp.end())\\n            ans.push_back((*it).second);\\n            else\\n            {\\n                *it--;\\n                ans.push_back((*it).second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596785,
                "title": "c-map-sorting-with-explanation",
                "content": "***PLEASE UPVOTE IF U LIKE MY SOLUTION AND EXPLANATION***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n       \\n        //map of the price and the maximum beauty of all the items below the price\\n        map<int,int>mp2;\\n        \\n        //sort the items vector\\n        sort(items.begin(),items.end());\\n        \\n        mp2[items[0][0]]=items[0][1];\\n        for(int i=1;i<items.size();i++)\\n        {\\n            //just store the max_beauty(curr_it)=max(beauty(curr_it),beauty(prev_it));\\n            //mp2[prev_it] stores the max beauty of all the items whose price are below prev_it(price)\\n            mp2[items[i][0]]=max(items[i][1],mp2[items[i-1][0]]);\\n        }\\n        vector<int>res;\\n        for(auto &it:queries)\\n        {\\n            //for each query we find the price<=query in the map\\n            auto x=mp2.upper_bound(it);\\n            \\n            //if all prices are greater than the query then we return 0\\n            if(x==mp2.begin()){res.push_back(0);continue;}\\n            \\n            //as upper_bound returns the next greater ele even if there is the el present \\n\\t\\t\\t//in the map so x-- points to the iterator<=query\\n            x--;\\n            \\n            //just return the beauty associated with the iterator\\n            res.push_back((*x).second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n       \\n        //map of the price and the maximum beauty of all the items below the price\\n        map<int,int>mp2;\\n        \\n        //sort the items vector\\n        sort(items.begin(),items.end());\\n        \\n        mp2[items[0][0]]=items[0][1];\\n        for(int i=1;i<items.size();i++)\\n        {\\n            //just store the max_beauty(curr_it)=max(beauty(curr_it),beauty(prev_it));\\n            //mp2[prev_it] stores the max beauty of all the items whose price are below prev_it(price)\\n            mp2[items[i][0]]=max(items[i][1],mp2[items[i-1][0]]);\\n        }\\n        vector<int>res;\\n        for(auto &it:queries)\\n        {\\n            //for each query we find the price<=query in the map\\n            auto x=mp2.upper_bound(it);\\n            \\n            //if all prices are greater than the query then we return 0\\n            if(x==mp2.begin()){res.push_back(0);continue;}\\n            \\n            //as upper_bound returns the next greater ele even if there is the el present \\n\\t\\t\\t//in the map so x-- points to the iterator<=query\\n            x--;\\n            \\n            //just return the beauty associated with the iterator\\n            res.push_back((*x).second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576585,
                "title": "python3-greedy",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/e61879b77928a08bb15cc182a69259d6e2bce59a) for solutions of biweekly 65. \\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        ans = [0]*len(queries)\\n        prefix = ii = 0 \\n        for x, i in sorted((x, i) for i, x in enumerate(queries)): \\n            while ii < len(items) and items[ii][0] <= x: \\n                prefix = max(prefix, items[ii][1])\\n                ii += 1\\n            ans[i] = prefix\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        ans = [0]*len(queries)\\n        prefix = ii = 0 \\n        for x, i in sorted((x, i) for i, x in enumerate(queries)): \\n            while ii < len(items) and items[ii][0] <= x: \\n                prefix = max(prefix, items[ii][1])\\n                ii += 1\\n            ans[i] = prefix\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576154,
                "title": "c-sorting-map-concept-of-prefix-sum-designing-floorkey-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        map<int,int> m;\\n        vector<int> ans;\\n        sort(items.begin(),items.end());\\n        int maxBeauty = 0;\\n        \\n\\t\\t// I am filling the map in such a way that every element has the following parts - \\n\\t\\t// First element of a map element (it->first) : Contains PRICE\\n\\t\\t// Second element of a map element (it->second) : Contains Maximum BEAUTY till that PRICE (i.e till it->first)\\n\\t\\t// In this way we are keeping prefix price-beauty map \\n\\t\\t// Since it is a map, it is sorted in terms of the first element, i.e in terms of PRICE.\\n        for(int i=0; i<items.size(); i++){\\n            int currMaxPrice = items[i][0];\\n            int currBeauty = items[i][1];\\n            maxBeauty = max(maxBeauty,currBeauty);\\n            m[currMaxPrice] = maxBeauty;\\n        }\\n        for(int i=0; i<queries.size(); i++){\\n            int maxAllowedPrice = queries[i];\\n            auto begin = m.begin();\\n            auto end = --m.end();\\n\\t\\t\\t\\n\\t\\t\\t// If the current query PRICE is less that the smallest PRICE in the map, \\n\\t\\t\\t// then there are no PRICE which are less than query[i]\\n            if(begin->first > maxAllowedPrice)\\n                ans.push_back(0);\\n\\t\\t\\t\\t\\n\\t\\t\\t// If the current query price is more than the maximum PRICE in the map \\n\\t\\t\\t// (i.e it is greater than the last element PRICE in the map), \\n\\t\\t\\t// then it is obviously greater than all other PRICE values in the map. \\n\\t\\t\\t// In this case we add the last elements BEAUTY, which is the cummulative maximum BEAUTY.\\n            else if(end->first < maxAllowedPrice){\\n                ans.push_back(end->second);\\n            }\\n            else{\\n                auto find = m.find(maxAllowedPrice);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If the exact PRICE is there in the map, then that element will contain the maximum BEAUTY till that PRICE.\\n\\t\\t\\t\\t// So we can simply add that BEAUTY\\n                if(find != m.end())\\n                    ans.push_back(find->second);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Else we find the lower_bound (please read about lower_bound, incase you don\\'t know).\\n\\t\\t\\t\\t// And we add the immediate previous BEAUTY value.\\n                else{\\n                    auto lower = m.lower_bound(maxAllowedPrice);\\n                    --lower;\\n                    ans.push_back(lower->second);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        map<int,int> m;\\n        vector<int> ans;\\n        sort(items.begin(),items.end());\\n        int maxBeauty = 0;\\n        \\n\\t\\t// I am filling the map in such a way that every element has the following parts - \\n\\t\\t// First element of a map element (it->first) : Contains PRICE\\n\\t\\t// Second element of a map element (it->second) : Contains Maximum BEAUTY till that PRICE (i.e till it->first)\\n\\t\\t// In this way we are keeping prefix price-beauty map \\n\\t\\t// Since it is a map, it is sorted in terms of the first element, i.e in terms of PRICE.\\n        for(int i=0; i<items.size(); i++){\\n            int currMaxPrice = items[i][0];\\n            int currBeauty = items[i][1];\\n            maxBeauty = max(maxBeauty,currBeauty);\\n            m[currMaxPrice] = maxBeauty;\\n        }\\n        for(int i=0; i<queries.size(); i++){\\n            int maxAllowedPrice = queries[i];\\n            auto begin = m.begin();\\n            auto end = --m.end();\\n\\t\\t\\t\\n\\t\\t\\t// If the current query PRICE is less that the smallest PRICE in the map, \\n\\t\\t\\t// then there are no PRICE which are less than query[i]\\n            if(begin->first > maxAllowedPrice)\\n                ans.push_back(0);\\n\\t\\t\\t\\t\\n\\t\\t\\t// If the current query price is more than the maximum PRICE in the map \\n\\t\\t\\t// (i.e it is greater than the last element PRICE in the map), \\n\\t\\t\\t// then it is obviously greater than all other PRICE values in the map. \\n\\t\\t\\t// In this case we add the last elements BEAUTY, which is the cummulative maximum BEAUTY.\\n            else if(end->first < maxAllowedPrice){\\n                ans.push_back(end->second);\\n            }\\n            else{\\n                auto find = m.find(maxAllowedPrice);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If the exact PRICE is there in the map, then that element will contain the maximum BEAUTY till that PRICE.\\n\\t\\t\\t\\t// So we can simply add that BEAUTY\\n                if(find != m.end())\\n                    ans.push_back(find->second);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Else we find the lower_bound (please read about lower_bound, incase you don\\'t know).\\n\\t\\t\\t\\t// And we add the immediate previous BEAUTY value.\\n                else{\\n                    auto lower = m.lower_bound(maxAllowedPrice);\\n                    --lower;\\n                    ans.push_back(lower->second);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575919,
                "title": "c-sorting-queries-explanation-concise-code-comments",
                "content": "**Idea**\\nThe idea is to process the queries in the increasing order. I construct a 2D queries array of dimentions *q * 2* which has the index of the query as the second element of each query. This array is sorted on the basis of the first element i.e *the actual query value not its index*. The items array is sorted on the basis of price. Then the queries are processed in increasing order and using a *two-pointer approach*, I maintain an iterator which traverses items in increasing order and it points to the first item whose price is greater than the current query. While doing so, I also determine the maximum beauty encountered. This is the answer for the present query. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& qry) {\\n        int n = items.size();\\n        int q = qry.size();\\n        vector<int> op(q);\\n\\t\\t\\n\\t\\t// Creating a 2D queries array to maintain the orginal indices of queries after sorting\\n        vector<vector<int>> queries(q, vector<int>(2));\\n        for(int i = 0; i < q; i++) {\\n            queries[i] = {qry[i], i};\\n        }\\n        sort(queries.begin(), queries.end());\\n        sort(items.begin(), items.end());\\n        \\n        int j = 0;\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// Traversing the queries in increasing order\\n        for(int i = 0; i < q; i++) {\\n\\t\\t\\n\\t\\t\\t// Finding the first item whose price is greater than the query\\n\\t\\t\\t// The maximum beauty encountered before this element \\n\\t\\t\\t// is the answer for the present query\\n            while(j < n && items[j][0] <= queries[i][0]) {\\n                ans = max(ans, items[j][1]);\\n                j++;\\n            }\\n            op[queries[i][1]] = ans;\\n        }\\n        \\n        return op;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n*Space Complexity (Auxiliary): O(q), where q is the number of queries.*\\n*Time Complexity: O(nlogn + qlogq)*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& qry) {\\n        int n = items.size();\\n        int q = qry.size();\\n        vector<int> op(q);\\n\\t\\t\\n\\t\\t// Creating a 2D queries array to maintain the orginal indices of queries after sorting\\n        vector<vector<int>> queries(q, vector<int>(2));\\n        for(int i = 0; i < q; i++) {\\n            queries[i] = {qry[i], i};\\n        }\\n        sort(queries.begin(), queries.end());\\n        sort(items.begin(), items.end());\\n        \\n        int j = 0;\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// Traversing the queries in increasing order\\n        for(int i = 0; i < q; i++) {\\n\\t\\t\\n\\t\\t\\t// Finding the first item whose price is greater than the query\\n\\t\\t\\t// The maximum beauty encountered before this element \\n\\t\\t\\t// is the answer for the present query\\n            while(j < n && items[j][0] <= queries[i][0]) {\\n                ans = max(ans, items[j][1]);\\n                j++;\\n            }\\n            op[queries[i][1]] = ans;\\n        }\\n        \\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659116,
                "title": "c-sort",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& v1, vector<int>& v) {\\n        int n = v.size(),i;\\n        vector<vector<int>> v2;\\n        for(i=0;i<n;i++){\\n            v2.push_back({v[i],i});\\n        }\\n        vector<int> ans(n,0);\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        // for(auto &i: v1)cout<<i[0]<<\" \"<<i[1]<<\" #  \";cout<<endl;\\n        // for(auto &i: v2)cout<<i[0]<<\" \"<<i[1]<<\" #  \";cout<<endl;\\n        int  j = 0, x = 0, a = v1.size(),b=v2.size();\\n        i = 0;\\n        while(j<b){\\n            while(i<a&&v2[j][0]>=v1[i][0]){\\n                x = max(v1[i][1],x);\\n                i++;\\n            }\\n            ans[v2[j][1]] = x;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& v1, vector<int>& v) {\\n        int n = v.size(),i;\\n        vector<vector<int>> v2;\\n        for(i=0;i<n;i++){\\n            v2.push_back({v[i],i});\\n        }\\n        vector<int> ans(n,0);\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        // for(auto &i: v1)cout<<i[0]<<\" \"<<i[1]<<\" #  \";cout<<endl;\\n        // for(auto &i: v2)cout<<i[0]<<\" \"<<i[1]<<\" #  \";cout<<endl;\\n        int  j = 0, x = 0, a = v1.size(),b=v2.size();\\n        i = 0;\\n        while(j<b){\\n            while(i<a&&v2[j][0]>=v1[i][0]){\\n                x = max(v1[i][1],x);\\n                i++;\\n            }\\n            ans[v2[j][1]] = x;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3659112,
                "title": "c-sort",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& v1, vector<int>& v) {\\n        int n = v.size(),i;\\n        vector<vector<int>> v2;\\n        for(i=0;i<n;i++){\\n            v2.push_back({v[i],i});\\n        }\\n        vector<int> ans(n,0);\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        // for(auto &i: v1)cout<<i[0]<<\" \"<<i[1]<<\" #  \";cout<<endl;\\n        // for(auto &i: v2)cout<<i[0]<<\" \"<<i[1]<<\" #  \";cout<<endl;\\n        int  j = 0, x = 0, a = v1.size(),b=v2.size();\\n        i = 0;\\n        while(j<b){\\n            while(i<a&&v2[j][0]>=v1[i][0]){\\n                x = max(v1[i][1],x);\\n                i++;\\n            }\\n            ans[v2[j][1]] = x;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& v1, vector<int>& v) {\\n        int n = v.size(),i;\\n        vector<vector<int>> v2;\\n        for(i=0;i<n;i++){\\n            v2.push_back({v[i],i});\\n        }\\n        vector<int> ans(n,0);\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        // for(auto &i: v1)cout<<i[0]<<\" \"<<i[1]<<\" #  \";cout<<endl;\\n        // for(auto &i: v2)cout<<i[0]<<\" \"<<i[1]<<\" #  \";cout<<endl;\\n        int  j = 0, x = 0, a = v1.size(),b=v2.size();\\n        i = 0;\\n        while(j<b){\\n            while(i<a&&v2[j][0]>=v1[i][0]){\\n                x = max(v1[i][1],x);\\n                i++;\\n            }\\n            ans[v2[j][1]] = x;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2825114,
                "title": "python-3-3-lines-binary-search-w-example-t-m-96-57",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n\\n                                                    # Ex:      items = [[1,2],[3,2],[2,4],[5,6],[3,5]]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t#        queries = [1,2,3,4,5,6]\\n\\n        price, beauty = zip(*sorted(items))         # sorted(items = [[1,2],[2,4],[3,2],[3, 5],[5, 6]]\\n                                                    # price = [1,2,3,3,5], beauty = [2,4,2,5,6]\\n\\n        beauty = list(accumulate(beauty,lambda x,y: max(x,y)))\\n\\t\\t\\n                                                    # beauty = [2,4,4,5,6]   \\n        return [0 if q < price[0] else \\n                beauty[bisect_right(price, q)-1] for q in queries]\\n\\t\\t\\t\\t\\n                                                    #   q       price[i]            beauty[i]\\n                                                    #  \\u2013\\u2013\\u2013\\u2013     \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                    #    1      [ /1\\\\ ,2,3,3,5]     [ /2\\\\ ,4,4,5,6]\\n                                                    #    2      [1, /2\\\\, 3,3,5]     [2, /4\\\\ ,4,5,6]\\n                                                    #    3      [1,2,3, /3\\\\  5]     [2,4,4, /5\\\\ ,6]\\n                                                    #    4      [1,2,3, /3\\\\ ,5]     [2,4,4, /5\\\\ ,6]\\n                                                    #    5      [1,2,3,3, /5\\\\ ]     [2,4,4,5, /6\\\\ ]\\n                                                    #    6      [1,2,3,3, /5\\\\ ]     [2,4,4,5, /6\\\\ ]\\n\\n                                                    #                        return [2,4,5,5,6,6]\\n\\n```\\n[https://leetcode.com/submissions/detail/845387460/](http://)\\n\\n\\n\\nI could be wrong, but I think it\\'s *O*(*N*log*N*) / *O*(*N*).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n\\n                                                    # Ex:      items = [[1,2],[3,2],[2,4],[5,6],[3,5]]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t#        queries = [1,2,3,4,5,6]\\n\\n        price, beauty = zip(*sorted(items))         # sorted(items = [[1,2],[2,4],[3,2],[3, 5],[5, 6]]\\n                                                    # price = [1,2,3,3,5], beauty = [2,4,2,5,6]\\n\\n        beauty = list(accumulate(beauty,lambda x,y: max(x,y)))\\n\\t\\t\\n                                                    # beauty = [2,4,4,5,6]   \\n        return [0 if q < price[0] else \\n                beauty[bisect_right(price, q)-1] for q in queries]\\n\\t\\t\\t\\t\\n                                                    #   q       price[i]            beauty[i]\\n                                                    #  \\u2013\\u2013\\u2013\\u2013     \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                    #    1      [ /1\\\\ ,2,3,3,5]     [ /2\\\\ ,4,4,5,6]\\n                                                    #    2      [1, /2\\\\, 3,3,5]     [2, /4\\\\ ,4,5,6]\\n                                                    #    3      [1,2,3, /3\\\\  5]     [2,4,4, /5\\\\ ,6]\\n                                                    #    4      [1,2,3, /3\\\\ ,5]     [2,4,4, /5\\\\ ,6]\\n                                                    #    5      [1,2,3,3, /5\\\\ ]     [2,4,4,5, /6\\\\ ]\\n                                                    #    6      [1,2,3,3, /5\\\\ ]     [2,4,4,5, /6\\\\ ]\\n\\n                                                    #                        return [2,4,5,5,6,6]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994065,
                "title": "by-binarysearch-using-hashing-technique-java-optimized-approach",
                "content": "**Binary Search** using **Hashing** technique\\n\\n* Sort the items (2D array) By making a pair class and sort it,\\n* make another beauty array that store the maximum beauty of every index till now (According to the sorted items array indexing)  (that will us to achive to get maximum beauty of any index in O(1).\\n* now starts traversing on queries ,and on each iteration apply binary search on it.\\n\\n```\\nclass pair {\\n\\tint p;\\n\\tint b;\\n\\n\\tpair(int p, int b) {\\n\\t\\tthis.p = p;\\n\\t\\tthis.b = b;\\n\\t}\\n}\\n\\nclass Solution {\\n\\tpublic int[] maximumBeauty(int[][] items, int[] q) {\\n\\n\\t\\tint n = items.length,i=0;\\n\\n\\t\\tpair[] p = new pair[n];\\n \\n\\t\\tfor (int[] x : items) {\\n\\t\\t\\tint pii = x[0];\\n\\t\\t\\tint b = x[1];\\n\\t\\t\\tpair pi = new pair(pii, b);\\n\\t\\t\\tp[i] = pi;\\n\\n\\t\\t\\tbe[i] = maxb;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\tArrays.sort(p, (a, b) -> {\\n\\t\\t\\treturn a.p - b.p;\\n\\t\\t});\\n\\n\\t\\ti = 0;\\n\\t\\tint[] be = new int[n];\\n\\t\\tint maxb = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\tfor (pair x : p) {\\n\\n\\t\\t\\tmaxb = Integer.max(maxb, x.b);\\n\\t\\t\\tbe[i] = maxb;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\ti = 0;\\n\\t\\tint[] ans = new int[q.length];\\n\\n\\t\\tfor (int x : q) {\\n\\t\\t\\tans[i] = search(p, x, be);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic int search(pair[] p, int el, int[] b) {\\n\\n\\t\\tint l = 0, h = p.length - 1,  i = -1;\\n\\n\\t\\twhile (l <= h) {\\n\\n\\t\\t\\tint mid = (l + h) / 2;\\n\\n\\t\\t\\tif (p[mid].p <= el) {\\n\\t\\t\\t\\ti = mid;\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\th = mid - 1;\\n\\t\\t}\\n\\n\\t\\tif (i == -1) return 0;\\n\\t\\t\\n\\t\\treturn b[i];\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass pair {\\n\\tint p;\\n\\tint b;\\n\\n\\tpair(int p, int b) {\\n\\t\\tthis.p = p;\\n\\t\\tthis.b = b;\\n\\t}\\n}\\n\\nclass Solution {\\n\\tpublic int[] maximumBeauty(int[][] items, int[] q) {\\n\\n\\t\\tint n = items.length,i=0;\\n\\n\\t\\tpair[] p = new pair[n];\\n \\n\\t\\tfor (int[] x : items) {\\n\\t\\t\\tint pii = x[0];\\n\\t\\t\\tint b = x[1];\\n\\t\\t\\tpair pi = new pair(pii, b);\\n\\t\\t\\tp[i] = pi;\\n\\n\\t\\t\\tbe[i] = maxb;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\tArrays.sort(p, (a, b) -> {\\n\\t\\t\\treturn a.p - b.p;\\n\\t\\t});\\n\\n\\t\\ti = 0;\\n\\t\\tint[] be = new int[n];\\n\\t\\tint maxb = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\tfor (pair x : p) {\\n\\n\\t\\t\\tmaxb = Integer.max(maxb, x.b);\\n\\t\\t\\tbe[i] = maxb;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\ti = 0;\\n\\t\\tint[] ans = new int[q.length];\\n\\n\\t\\tfor (int x : q) {\\n\\t\\t\\tans[i] = search(p, x, be);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic int search(pair[] p, int el, int[] b) {\\n\\n\\t\\tint l = 0, h = p.length - 1,  i = -1;\\n\\n\\t\\twhile (l <= h) {\\n\\n\\t\\t\\tint mid = (l + h) / 2;\\n\\n\\t\\t\\tif (p[mid].p <= el) {\\n\\t\\t\\t\\ti = mid;\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\th = mid - 1;\\n\\t\\t}\\n\\n\\t\\tif (i == -1) return 0;\\n\\t\\t\\n\\t\\treturn b[i];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990106,
                "title": "runtime-264-ms-faster-than-100-00-of-javascript-online-submissions",
                "content": "```\\nvar maximumBeauty = function(items, queries) {\\n    items.sort((a,b) => a[0]-b[0]);\\n    const n = items.length;\\n    \\n    \\n    let mx = items[0][1];\\n    \\n    for (let i = 0; i<n; i++) {\\n        mx = Math.max(mx, items[i][1]);\\n        items[i][1] = mx;\\n    }\\n    \\n    \\n    const ans = [];\\n    \\n    for (const q of queries) {\\n        let l = 0, r = n-1, a = 0;\\n        while (l<=r) {\\n            let mid = Math.floor(l+(r-l)/2);\\n            if (items[mid][0]<=q) {\\n                a = items[mid][1]\\n                l = mid+1;\\n            } else r = mid-1;\\n        }\\n        ans.push(a)\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar maximumBeauty = function(items, queries) {\\n    items.sort((a,b) => a[0]-b[0]);\\n    const n = items.length;\\n    \\n    \\n    let mx = items[0][1];\\n    \\n    for (let i = 0; i<n; i++) {\\n        mx = Math.max(mx, items[i][1]);\\n        items[i][1] = mx;\\n    }\\n    \\n    \\n    const ans = [];\\n    \\n    for (const q of queries) {\\n        let l = 0, r = n-1, a = 0;\\n        while (l<=r) {\\n            let mid = Math.floor(l+(r-l)/2);\\n            if (items[mid][0]<=q) {\\n                a = items[mid][1]\\n                l = mid+1;\\n            } else r = mid-1;\\n        }\\n        ans.push(a)\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575953,
                "title": "c-map-multiset-simple-easy-to-understand",
                "content": "class Solution {\\npublic:\\n  \\n    \\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& v) {\\n        map<int,int>m;\\n        sort(items.begin(), items.end());\\n        int max_val = 0;\\n        for(int i=0;i<items.size();i++){\\n            int s= items[i][0];\\n            int d = items[i][1];\\n            max_val = max(max_val , d);  /// store the max_val , at that point\\n            m[s] = max(m[s] , max_val);  \\n        }\\n        \\n        multiset <int, greater <int> > iammultiset;\\n        for(auto i : m){\\n             iammultiset.insert(i.first);\\n        }\\n        \\n        for(int i=0;i<v.size();i++){\\n            if(m.find(v[i])!=m.end()){  // if v[i] is present in map , simply that number will be maximum\\n                v[i]  = m[v[i]];\\n            }\\n            else{   /// else the maximum will me lower_bound of v[i] in map \\n                v[i] = m[ *iammultiset.lower_bound(v[i]) ];\\n            }\\n        }\\n        \\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n  \\n    \\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& v) {\\n        map<int,int>m;\\n        sort(items.begin(), items.end());\\n        int max_val = 0;\\n        for(int i=0;i<items.size();i++){\\n            int s= items[i][0];\\n            int d = items[i][1];\\n            max_val = max(max_val , d);  /// store the max_val , at that point\\n            m[s] = max(m[s] , max_val);  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3160508,
                "title": "sortng-simple-easy-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n       vector<vector<int>> v;\\n        int n = queries.size();\\n        for(int i = 0; i < n; i++){\\n            v.push_back({queries[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        sort(items.begin(),items.end());\\n        vector<int> ans(n);\\n        int j=0;\\n        n = items.size();\\n        int mx = 0;\\n        for(auto &i: v){\\n            while(j<n && items[j][0]<=i[0]){\\n                mx = max(mx,items[j][1]);\\n                j++;\\n            }\\n            ans[i[1]] = mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n       vector<vector<int>> v;\\n        int n = queries.size();\\n        for(int i = 0; i < n; i++){\\n            v.push_back({queries[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        sort(items.begin(),items.end());\\n        vector<int> ans(n);\\n        int j=0;\\n        n = items.size();\\n        int mx = 0;\\n        for(auto &i: v){\\n            while(j<n && items[j][0]<=i[0]){\\n                mx = max(mx,items[j][1]);\\n                j++;\\n            }\\n            ans[i[1]] = mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976319,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int n = queries.length, m = items.length;\\n        Arrays.sort(items, Comparator.comparingInt(o -> o[0]));\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < m; i++)\\n            items[i][1] = Math.max(items[i][1], items[i > 0? i - 1 : 0][1]);\\n\\n        int j = 0;\\n        for (int q : queries){\\n            int lo = -1, hi = m - 1; //pad lo = -1 to mark no result\\n            while(lo < hi){\\n                int mid = lo + (hi - lo) / 2 + 1;\\n                if (q >= items[mid][0]) lo = mid;\\n                else hi = mid - 1;\\n            }\\n            ans[j++] = lo == -1? 0 : items[lo][1];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n***Consider upvote if usefull!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int n = queries.length, m = items.length;\\n        Arrays.sort(items, Comparator.comparingInt(o -> o[0]));\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < m; i++)\\n            items[i][1] = Math.max(items[i][1], items[i > 0? i - 1 : 0][1]);\\n\\n        int j = 0;\\n        for (int q : queries){\\n            int lo = -1, hi = m - 1; //pad lo = -1 to mark no result\\n            while(lo < hi){\\n                int mid = lo + (hi - lo) / 2 + 1;\\n                if (q >= items[mid][0]) lo = mid;\\n                else hi = mid - 1;\\n            }\\n            ans[j++] = lo == -1? 0 : items[lo][1];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774133,
                "title": "python-sort-dict-bisect-90-75",
                "content": "```\\nclass Solution:\\n\\n    def floorSearch(self, array: List[int], target: int) -> int:\\n\\t\\n        idx = bisect_left(array,target)\\n        return array[idx-1]\\n    \\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        items.sort()\\n        dic = {}\\n        curr_max_beauty = items[0][1]\\n        keys = []\\n        for price,beauty in items:\\n            keys.append(price)\\n            curr_max_beauty = max(beauty,curr_max_beauty)\\n            dic[price] = curr_max_beauty\\n        res = []\\n        for q in queries:\\n            if q < keys[0]:\\n                res.append(0)\\n            elif q in dic:\\n                res.append(dic[q])\\n            else:\\n                res.append(dic[self.floorSearch(keys,q)])\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def floorSearch(self, array: List[int], target: int) -> int:\\n\\t\\n        idx = bisect_left(array,target)\\n        return array[idx-1]\\n    \\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        items.sort()\\n        dic = {}",
                "codeTag": "Java"
            },
            {
                "id": 1758802,
                "title": "java-using-map-and-binary-search-o-qlogn-nlogn-beats-73",
                "content": "```\\nclass Solution {\\n\\tMap<Integer, Integer> map;\\n\\tint[] res;\\n\\tint[] maxTillNow;\\n\\n\\tpublic int[] maximumBeauty(int[][] items, int[] q) {\\n\\t\\tmap = new HashMap<>();\\n\\t\\tres = new int[q.length];\\n\\n\\t\\tint x = 0;\\n\\t\\tfor (int[] a : items)\\n\\t\\t\\tmap.put(a[0], Math.max(map.getOrDefault(a[0], 0), a[1]));\\n\\n\\t\\tmaxTillNow = new int[map.size()];\\n\\t\\tint[] ar = new int[map.size()];\\n\\n\\t\\tfor (Map.Entry<Integer, Integer> e : map.entrySet()) {\\n\\t\\t\\tar[x++] = (int) e.getKey();\\n\\t\\t}\\n\\t\\tArrays.sort(ar);\\n\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < ar.length; i++) {\\n\\t\\t\\tmax = Math.max(max, map.get(ar[i]));\\n\\t\\t\\tmaxTillNow[i] = max;\\n\\t\\t}\\n\\n\\t\\tint i = 0;\\n\\t\\tfor (int val : q)\\n\\t\\t\\tres[i++] = find(ar, val, ar.length);\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n\\n\\tint find(int[] ar, int val, int n) {\\n\\t\\tint l = 0, r = n - 1, mid = l + (r - l) / 2;\\n\\t\\tint lastLess = -1;\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tmid = l + (r - l) / 2;\\n\\t\\t\\tif (ar[mid] == val)\\n\\t\\t\\t\\treturn maxTillNow[mid];\\n\\t\\t\\tif (val > ar[mid]) {\\n\\t\\t\\t\\tlastLess = mid;\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t}\\n\\n\\t\\treturn lastLess >= 0 ? maxTillNow[lastLess] : 0;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\tMap<Integer, Integer> map;\\n\\tint[] res;\\n\\tint[] maxTillNow;\\n\\n\\tpublic int[] maximumBeauty(int[][] items, int[] q) {\\n\\t\\tmap = new HashMap<>();\\n\\t\\tres = new int[q.length];\\n\\n\\t\\tint x = 0;\\n\\t\\tfor (int[] a : items)\\n\\t\\t\\tmap.put(a[0], Math.max(map.getOrDefault(a[0], 0), a[1]));\\n\\n\\t\\tmaxTillNow = new int[map.size()];\\n\\t\\tint[] ar = new int[map.size()];\\n\\n\\t\\tfor (Map.Entry<Integer, Integer> e : map.entrySet()) {\\n\\t\\t\\tar[x++] = (int) e.getKey();\\n\\t\\t}\\n\\t\\tArrays.sort(ar);\\n\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < ar.length; i++) {\\n\\t\\t\\tmax = Math.max(max, map.get(ar[i]));\\n\\t\\t\\tmaxTillNow[i] = max;\\n\\t\\t}\\n\\n\\t\\tint i = 0;\\n\\t\\tfor (int val : q)\\n\\t\\t\\tres[i++] = find(ar, val, ar.length);\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n\\n\\tint find(int[] ar, int val, int n) {\\n\\t\\tint l = 0, r = n - 1, mid = l + (r - l) / 2;\\n\\t\\tint lastLess = -1;\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tmid = l + (r - l) / 2;\\n\\t\\t\\tif (ar[mid] == val)\\n\\t\\t\\t\\treturn maxTillNow[mid];\\n\\t\\t\\tif (val > ar[mid]) {\\n\\t\\t\\t\\tlastLess = mid;\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t}\\n\\n\\t\\treturn lastLess >= 0 ? maxTillNow[lastLess] : 0;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598060,
                "title": "multiple-approaches-explained-sorting-binary-search-offline-query-c-clean-code",
                "content": "-----------------------------------------------------\\n# **Approach 1: Sorting + Binary Search**\\n-----------------------------------------------------\\n\\n-----------------------------------------------------\\n * **Code :**\\n\\n\\t\\tvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n\\n\\t\\t\\tint n = items.size();\\n\\n\\t\\t\\tsort(items.begin(), items.end());\\n\\n\\t\\t\\tvector<int> maxBeautyTillNow(n, 0);\\n\\n\\t\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\t\\tmaxBeautyTillNow[i] = (i == 0) ? items[i][1] : max(maxBeautyTillNow[i-1], items[i][1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> answer;\\n\\t\\t\\tfor(auto& query : queries) {\\n\\t\\t\\t\\tint idx = upper_bound(items.begin(), items.end(), vector<int>({query, INT_MAX})) - items.begin();\\n\\n\\t\\t\\t\\tif(idx >= n || items[idx][0] > query) idx--;\\n\\n\\t\\t\\t\\tif(idx < 0) answer.push_back(0);\\n\\t\\t\\t\\telse answer.push_back(maxBeautyTillNow[idx]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn answer;\\n\\t\\t}\\n\\n-----------------------------------------------------\\n\\n* **Complexity :**\\n\\n\\t* Time : `O(N logN) + O(N) + O(Q logN)` \\n\\t\\t* `O(N logN)` : sorting `items` list, \\n\\t\\t* `O(N)` : building prefix max i.e `maxBeautyTillNow` array and \\n\\t\\t* `O(Q logN)` : searching index for each query in `queries`\\n\\n\\n\\t* Space : `O(N)`, N is size of `items` list\\n\\t\\t* N : Size of `items` list\\n\\t\\t* Q : Size of `queries` list\\n-----------------------------------------------------\\n-----------------------------------------------------\\n# **Approach 2 : Sorting + Offline Query**\\n-----------------------------------------------------\\n\\n-----------------------------------------------------\\n * **Code :**\\n\\n\\t\\tvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n\\n\\t\\t\\tint n = items.size();\\n\\t\\t\\tint m = queries.size();\\n\\n\\t\\t\\tsort(begin(items), end(items));\\n\\n\\t\\t\\tvector<pair<int, int>> newQueries;\\n\\t\\t\\tint i=0; \\n\\t\\t\\tfor(auto& q : queries) {\\n\\t\\t\\t\\tnewQueries.push_back({q, i++});\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort(begin(newQueries), end(newQueries));\\n\\n\\t\\t\\tint idx = 0, maxBeauty = 0;\\n\\t\\t\\tvector<int> answer(m, 0);\\n\\n\\t\\t\\tfor(auto& [query, index] : newQueries) {\\n\\n\\t\\t\\t\\twhile(idx < n && items[idx][0] <= query) {\\n\\t\\t\\t\\t\\tmaxBeauty = max(maxBeauty, items[idx][1]);\\n\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tanswer[index] = maxBeauty;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn answer;\\n\\t\\t}\\n-----------------------------------------------------\\n\\n* **Complexity :**\\n\\n\\t* Time : `O(N logN) + O(Q + Q log Q) + O(Q + N)` \\n\\t\\t* `O(N log N)` : sorting `items` list, \\n\\t\\t* `O(Q + Q logQ )` : creating and sorting `newQueries` list, \\n\\t\\t* `O(Q + N)` : processing query in `newQueries`\\n\\n\\t* Space : `O(Q)`, Q is size of `queries` list\\n\\t\\t* N : Size of `items` list\\n\\t\\t* Q : Size of `queries` list\\n-----------------------------------------------------\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "-----------------------------------------------------\\n# **Approach 1: Sorting + Binary Search**\\n-----------------------------------------------------\\n\\n-----------------------------------------------------\\n * **Code :**\\n\\n\\t\\tvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n\\n\\t\\t\\tint n = items.size();\\n\\n\\t\\t\\tsort(items.begin(), items.end());\\n\\n\\t\\t\\tvector<int> maxBeautyTillNow(n, 0);\\n\\n\\t\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\t\\tmaxBeautyTillNow[i] = (i == 0) ? items[i][1] : max(maxBeautyTillNow[i-1], items[i][1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> answer;\\n\\t\\t\\tfor(auto& query : queries) {\\n\\t\\t\\t\\tint idx = upper_bound(items.begin(), items.end(), vector<int>({query, INT_MAX})) - items.begin();\\n\\n\\t\\t\\t\\tif(idx >= n || items[idx][0] > query) idx--;\\n\\n\\t\\t\\t\\tif(idx < 0) answer.push_back(0);\\n\\t\\t\\t\\telse answer.push_back(maxBeautyTillNow[idx]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn answer;\\n\\t\\t}\\n\\n-----------------------------------------------------\\n\\n* **Complexity :**\\n\\n\\t* Time : `O(N logN) + O(N) + O(Q logN)` \\n\\t\\t* `O(N logN)` : sorting `items` list, \\n\\t\\t* `O(N)` : building prefix max i.e `maxBeautyTillNow` array and \\n\\t\\t* `O(Q logN)` : searching index for each query in `queries`\\n\\n\\n\\t* Space : `O(N)`, N is size of `items` list\\n\\t\\t* N : Size of `items` list\\n\\t\\t* Q : Size of `queries` list\\n-----------------------------------------------------\\n-----------------------------------------------------\\n# **Approach 2 : Sorting + Offline Query**\\n-----------------------------------------------------\\n\\n-----------------------------------------------------\\n * **Code :**\\n\\n\\t\\tvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n\\n\\t\\t\\tint n = items.size();\\n\\t\\t\\tint m = queries.size();\\n\\n\\t\\t\\tsort(begin(items), end(items));\\n\\n\\t\\t\\tvector<pair<int, int>> newQueries;\\n\\t\\t\\tint i=0; \\n\\t\\t\\tfor(auto& q : queries) {\\n\\t\\t\\t\\tnewQueries.push_back({q, i++});\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort(begin(newQueries), end(newQueries));\\n\\n\\t\\t\\tint idx = 0, maxBeauty = 0;\\n\\t\\t\\tvector<int> answer(m, 0);\\n\\n\\t\\t\\tfor(auto& [query, index] : newQueries) {\\n\\n\\t\\t\\t\\twhile(idx < n && items[idx][0] <= query) {\\n\\t\\t\\t\\t\\tmaxBeauty = max(maxBeauty, items[idx][1]);\\n\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tanswer[index] = maxBeauty;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn answer;\\n\\t\\t}\\n-----------------------------------------------------\\n\\n* **Complexity :**\\n\\n\\t* Time : `O(N logN) + O(Q + Q log Q) + O(Q + N)` \\n\\t\\t* `O(N log N)` : sorting `items` list, \\n\\t\\t* `O(Q + Q logQ )` : creating and sorting `newQueries` list, \\n\\t\\t* `O(Q + N)` : processing query in `newQueries`\\n\\n\\t* Space : `O(Q)`, Q is size of `queries` list\\n\\t\\t* N : Size of `items` list\\n\\t\\t* Q : Size of `queries` list\\n-----------------------------------------------------\\n\\n***If you find this helpful, do give it a like :)***",
                "codeTag": "Unknown"
            },
            {
                "id": 1588699,
                "title": "python-faster-than-99-78-1124ms",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        to_check = queries.copy()\\n        to_check = sorted(to_check)[::-1]\\n        items = sorted(items, key=lambda x:x[0])\\n        items = items[::-1]\\n        max_beauty = 0\\n        ans_lookup = dict()\\n        while to_check:\\n            while items and items[-1][0] <= to_check[-1]:\\n                max_beauty = max(max_beauty,items.pop()[1])\\n            ans_lookup[to_check.pop()] = max_beauty\\n        return [ans_lookup[x] for x in queries]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        to_check = queries.copy()\\n        to_check = sorted(to_check)[::-1]\\n        items = sorted(items, key=lambda x:x[0])\\n        items = items[::-1]\\n        max_beauty = 0\\n        ans_lookup = dict()\\n        while to_check:\\n            while items and items[-1][0] <= to_check[-1]:\\n                max_beauty = max(max_beauty,items.pop()[1])\\n            ans_lookup[to_check.pop()] = max_beauty\\n        return [ans_lookup[x] for x in queries]",
                "codeTag": "Java"
            },
            {
                "id": 1584929,
                "title": "java-solution-with-binary-search-80-32-faster",
                "content": "```\\nclass Solution {\\n   public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int m = items.length;\\n        Arrays.sort(items, (a, b) -> Double.compare(a[0], b[0]));\\n        int n = queries.length;\\n        int[] mxLeft = new int[m];\\n\\n        mxLeft[0]= items[0][1];\\n        for(int i=1;i<m;i++)\\n            mxLeft[i] = Math.max(mxLeft[i-1],items[i][1]);\\n\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            int curr= queries[i];\\n            int l=0,r=m-1;\\n            int profit = -1;\\n\\n            while(l<=r){\\n                int mid = l+(r-l)/2;\\n                if(items[mid][0]>curr){\\n                    r=mid-1;\\n                }\\n                else{\\n                    profit=mid;\\n                    l=mid+1;\\n                }\\n            }\\n            if(profit==-1) continue;\\n            ans[i]=mxLeft[profit];\\n        }\\n\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int m = items.length;\\n        Arrays.sort(items, (a, b) -> Double.compare(a[0], b[0]));\\n        int n = queries.length;\\n        int[] mxLeft = new int[m];\\n\\n        mxLeft[0]= items[0][1];\\n        for(int i=1;i<m;i++)\\n            mxLeft[i] = Math.max(mxLeft[i-1],items[i][1]);\\n\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            int curr= queries[i];\\n            int l=0,r=m-1;\\n            int profit = -1;\\n\\n            while(l<=r){\\n                int mid = l+(r-l)/2;\\n                if(items[mid][0]>curr){\\n                    r=mid-1;\\n                }\\n                else{\\n                    profit=mid;\\n                    l=mid+1;\\n                }\\n            }\\n            if(profit==-1) continue;\\n            ans[i]=mxLeft[profit];\\n        }\\n\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576303,
                "title": "c-easy-to-understand-sorting-map-100-faster-356-ms-solution",
                "content": "\\n```\\nstatic const auto Initialize = []{\\n    ios::sync_with_stdio(false); cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& it, vector<int>& q) {\\n        int n=it.size();\\n        int m=q.size();\\n        sort(it.begin(),it.end());\\n        map<int,int>mp;\\n        mp[0]=0;\\n        mp[it[0][0]]=it[0][1];\\n        int ma=0;\\n        for(int i=1;i<n;i++){\\n            it[i][1]=it[i][1]>it[i-1][1]?it[i][1]:it[i-1][1];\\n            mp[it[i][0]]=it[i][1];\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<m;i++){\\n            if(!mp.count(q[i])){\\n                mp[q[i]]=0;\\n            }\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            auto it1=it;\\n            it1--;\\n            if(it->second==0){\\n                it->second=it1->second;\\n            }\\n        }\\n        for(auto x:q){\\n            ans.push_back(mp[x]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf u Like the Solution Please Do Upvote",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nstatic const auto Initialize = []{\\n    ios::sync_with_stdio(false); cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& it, vector<int>& q) {\\n        int n=it.size();\\n        int m=q.size();\\n        sort(it.begin(),it.end());\\n        map<int,int>mp;\\n        mp[0]=0;\\n        mp[it[0][0]]=it[0][1];\\n        int ma=0;\\n        for(int i=1;i<n;i++){\\n            it[i][1]=it[i][1]>it[i-1][1]?it[i][1]:it[i-1][1];\\n            mp[it[i][0]]=it[i][1];\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<m;i++){\\n            if(!mp.count(q[i])){\\n                mp[q[i]]=0;\\n            }\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            auto it1=it;\\n            it1--;\\n            if(it->second==0){\\n                it->second=it1->second;\\n            }\\n        }\\n        for(auto x:q){\\n            ans.push_back(mp[x]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576099,
                "title": "thinking-process-behind-binary-search-and-sort-with-pictures-c-implementation",
                "content": "# Thinking Process\\nYou must have seen many different solution in the discussion tab, everyone is saying that **Sort + Binary Search!**. But wait, from where did that even came from?\\nLet me explain it to you in depth the thinking process behind this approach.\\n\\n* I am hoping that you know how to solve this with brute force approach. Let\\'s start with something new.\\n* The problem want us to find the maximum beauty out of all items for each query such that the price of each item is `<= query` itself.\\n* So that\\'s mean, the answer for query `q = 5` depends on items whose price is `<= 5`. ***And this also implies that we don\\'t give a shit about items whose price value is greater than the query***. when you get this thought you probably got the idea of sorting.\\n* With sorting we can optimise the brute force by avoiding unnecessary iterations over items.\\n* But again, in worst case we might end up having the same time complexity as of brute force. So that\\'s mean sorting alone is not enough.\\n* Now let\\'s write the items in sorted order first, than think of how to optimise it. I am using pen and paper, you can use whatever you like.\\n\\n![image](https://assets.leetcode.com/users/images/3b3c549e-5178-4536-9393-b83724372d23_1636821270.5248866.jpeg)\\n\\n* Now, in the image I have shared above only one thing you may found new that is the rectangular box I have made. It is nothing but the maximum beauty available till the current index in the available items. \\n* Let\\'s say we are looking for maximum beauty for query `q = 3`. You can easily see that the answer for this is` 7`. \\n* If you closely look to the sorted array of items, you will realize that if you have that rectangular box with you than you just need the last index of query in the list of sorted items. If you have that you can easily find the maximum beauty for the current query in constant time. \\n* And also finding the last index of an item in a sorted array is a standard binary search problem. ***That\\'s is how we finally reach to Sorting + Binary Search solution.***\\n\\nSo, the answer for the queries shown in image is : [2, 2, 7, 7, 7, 7]. And yes don\\'t forget to handle the edge case when the query do not exists in the items array.\\n\\n# C++ Implementation\\n```\\nclass Solution {\\npublic:\\n    int findLastIndex(vector<vector<int>>& items, int& q) {\\n        // as usual binary search\\n        int lo = 0, hi = items.size()-1, res = -1;\\n        while(lo <= hi) {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            // if the current item price <= required item price\\n            // than this might be our answer, so update answer \\n            // and look for the right half for higher values\\n            if(items[mid][0] <= q) {\\n                res = mid;\\n                lo = mid+1;\\n            }\\n            \\n            // else we need to search in lower half\\n            else {\\n                hi = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n = items.size();\\n        \\n        // sort on the basis of first price\\n        sort(begin(items), end(items));\\n        \\n        // maxBeauty store the max beauty till the current index, \\n        // it will always be in increasing order\\n        vector<int> maxBeauty(n);\\n        vector<int> res;\\n        \\n        // assign the maximum beauty to each index\\n        maxBeauty[0] = items[0][1];\\n        for(int i=1; i<n; i++) {\\n            maxBeauty[i] = max(maxBeauty[i-1], items[i][1]);\\n        }\\n        \\n        // now for every query binary seach the last index in the pairs\\n        // whose price <= current query price\\n        for(auto q: queries) {\\n            auto i = findLastIndex(items, q);\\n                    \\n            // if we do not find this item in the items list\\n            res.push_back(i == -1 ? 0 : maxBeauty[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n# Time Complexity\\n* I leave this to you, let me know in the comments. \\n* Thanks for reading and Happy coding!.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLastIndex(vector<vector<int>>& items, int& q) {\\n        // as usual binary search\\n        int lo = 0, hi = items.size()-1, res = -1;\\n        while(lo <= hi) {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            // if the current item price <= required item price\\n            // than this might be our answer, so update answer \\n            // and look for the right half for higher values\\n            if(items[mid][0] <= q) {\\n                res = mid;\\n                lo = mid+1;\\n            }\\n            \\n            // else we need to search in lower half\\n            else {\\n                hi = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n = items.size();\\n        \\n        // sort on the basis of first price\\n        sort(begin(items), end(items));\\n        \\n        // maxBeauty store the max beauty till the current index, \\n        // it will always be in increasing order\\n        vector<int> maxBeauty(n);\\n        vector<int> res;\\n        \\n        // assign the maximum beauty to each index\\n        maxBeauty[0] = items[0][1];\\n        for(int i=1; i<n; i++) {\\n            maxBeauty[i] = max(maxBeauty[i-1], items[i][1]);\\n        }\\n        \\n        // now for every query binary seach the last index in the pairs\\n        // whose price <= current query price\\n        for(auto q: queries) {\\n            auto i = findLastIndex(items, q);\\n                    \\n            // if we do not find this item in the items list\\n            res.push_back(i == -1 ? 0 : maxBeauty[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576084,
                "title": "python3-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        items.sort(key=lambda x: x[0])\\n        a = []\\n        b = []\\n        \\n        for i in range(len(items)):\\n            a.append(items[i][0])\\n            \\n        for i in range(len(items)):\\n            b.append(items[i][1])\\n            \\n        for i in range(1,len(b)):\\n            if b[i] < b[i-1]:\\n                b[i] = b[i-1]\\n\\n        idx = 0\\n        \\n        res = []\\n        \\n        for i in range(len(queries)):\\n            \\n            idx = bisect.bisect_right(a,queries[i])\\n            \\n            if idx == 0:\\n                res.append(0)\\n            else:\\n                res.append(b[idx-1])\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        items.sort(key=lambda x: x[0])\\n        a = []\\n        b = []\\n        \\n        for i in range(len(items)):\\n            a.append(items[i][0])\\n            \\n        for i in range(len(items)):\\n            b.append(items[i][1])\\n            \\n        for i in range(1,len(b)):\\n            if b[i] < b[i-1]:\\n                b[i] = b[i-1]\\n\\n        idx = 0\\n        \\n        res = []\\n        \\n        for i in range(len(queries)):\\n            \\n            idx = bisect.bisect_right(a,queries[i])\\n            \\n            if idx == 0:\\n                res.append(0)\\n            else:\\n                res.append(b[idx-1])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576041,
                "title": "c-sorting-binary-search",
                "content": "# ***Approach***\\n```\\nSteps\\n\\t(1) Sort the items on the basis of their price\\n\\t(2) prepare answer for every price in prefix\\n\\t(3) use binary search to find a price value in items which is closest to query price\\n\\t(4) take answer from prefix to answer a query\\n\\tTime : O(nlog(n) + qlog(n))\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    static bool comparator(vector<int> &a , vector<int> &b)\\n    {\\n        return a[0] < b[0];\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>> &nums, vector<int> &queries) {\\n        vector<int> prefix;\\n        sort(nums.begin() , nums.end() , comparator);\\n        \\n        int max_beauty = 0;\\n        for(auto v : nums)\\n        {\\n            max_beauty = max(max_beauty , v[1]);\\n            prefix.push_back(max_beauty);\\n        }\\n        \\n        vector<int> res;\\n        for(int q : queries)\\n        {   \\n            int x = bin_search(nums , q);\\n            if(x < 0)\\n                res.push_back(0);\\n            else\\n                res.push_back(prefix[x]);\\n        }\\n        return res;\\n    }\\n    int bin_search(vector<vector<int>> &nums , int target)\\n    {\\n        int left = 0 , right = nums.size() - 1;\\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            if(nums[mid][0] > target)\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return right;\\n    }\\n};\\n```\\n# ***If you liked the Solution, Give it an Upvote :)***",
                "solutionTags": [],
                "code": "```\\nSteps\\n\\t(1) Sort the items on the basis of their price\\n\\t(2) prepare answer for every price in prefix\\n\\t(3) use binary search to find a price value in items which is closest to query price\\n\\t(4) take answer from prefix to answer a query\\n\\tTime : O(nlog(n) + qlog(n))\\n```\n```\\nclass Solution {\\npublic:\\n    static bool comparator(vector<int> &a , vector<int> &b)\\n    {\\n        return a[0] < b[0];\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>> &nums, vector<int> &queries) {\\n        vector<int> prefix;\\n        sort(nums.begin() , nums.end() , comparator);\\n        \\n        int max_beauty = 0;\\n        for(auto v : nums)\\n        {\\n            max_beauty = max(max_beauty , v[1]);\\n            prefix.push_back(max_beauty);\\n        }\\n        \\n        vector<int> res;\\n        for(int q : queries)\\n        {   \\n            int x = bin_search(nums , q);\\n            if(x < 0)\\n                res.push_back(0);\\n            else\\n                res.push_back(prefix[x]);\\n        }\\n        return res;\\n    }\\n    int bin_search(vector<vector<int>> &nums , int target)\\n    {\\n        int left = 0 , right = nums.size() - 1;\\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            if(nums[mid][0] > target)\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575998,
                "title": "lessons-learned",
                "content": "**Code**:\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        int m = items.length;\\n        int n = queries.length;\\n        \\n        // SORT FOR BINARY SEARCH\\n        Arrays.sort(items, (a, b) -> a[0] - b[0]);\\n        \\n        // AUXILLARY ARRAY FOR FINDING MAX IN O(1) \\n        int[] maxBeauty = new int[m];\\n        maxBeauty[0] = items[0][1];\\n        for (int i = 1; i < m; ++i) {\\n            int beauty = items[i][1];\\n            maxBeauty[i] = Math.max(maxBeauty[i - 1], beauty);\\n        }\\n        \\n        // BUILD ANSWER\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            int val = binarySearch(queries[i], items, maxBeauty);\\n            ans[i] = val;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // BINARY SEARCH\\n    private int binarySearch(int maxPrice, int[][] items, int[] maxBeauty) {\\n        int m = items.length;\\n        int ans = 0;\\n        int left = 0, right = m - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int price = items[mid][0];\\n            if (price <= maxPrice) {\\n                ans = maxBeauty[mid];\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        int m = items.length;\\n        int n = queries.length;\\n        \\n        // SORT FOR BINARY SEARCH\\n        Arrays.sort(items, (a, b) -> a[0] - b[0]);\\n        \\n        // AUXILLARY ARRAY FOR FINDING MAX IN O(1) \\n        int[] maxBeauty = new int[m];\\n        maxBeauty[0] = items[0][1];\\n        for (int i = 1; i < m; ++i) {\\n            int beauty = items[i][1];\\n            maxBeauty[i] = Math.max(maxBeauty[i - 1], beauty);\\n        }\\n        \\n        // BUILD ANSWER\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            int val = binarySearch(queries[i], items, maxBeauty);\\n            ans[i] = val;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // BINARY SEARCH\\n    private int binarySearch(int maxPrice, int[][] items, int[] maxBeauty) {\\n        int m = items.length;\\n        int ans = 0;\\n        int left = 0, right = m - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int price = items[mid][0];\\n            if (price <= maxPrice) {\\n                ans = maxBeauty[mid];\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575930,
                "title": "c-binary-search-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int next(vector<vector<int>>& arr, int target, int end){\\n      \\n        if(end==0) return -1;\\n        if(target>arr[end-1][0]) return end-1;\\n   \\n        int start=0;\\n \\n        int ans=-1;\\n        while (start<=end){\\n            int mid=(start+end)/2;\\n\\n            if (arr[mid][0]>=target){\\n                end=mid-1;\\n            }\\n\\n            else{\\n                ans=mid;\\n                start=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        \\n        map<int,int>mp;\\n        sort(items.begin(),items.end());\\n        int mx=INT_MIN;\\n        for(auto x:items){\\n            mx=max(mx,x[1]);\\n            mp[x[0]]=mx;\\n        }\\n        \\n        /*\\n        for(auto x:items){\\n            cout<<x[0]<<\" \"<<x[1]<<\\'\\\\n\\';\\n        }*/\\n        \\n        vector<int>res;\\n        for(auto x:queries){\\n            if(!(mp[x])){\\n                \\n                if(x<items[0][0]) mp[x]=0;\\n                else if(x>=items[items.size()-1][0]) mp[x]=mp[items[items.size()-1][0]];\\n                else {\\n                    int k=next(items,x,items.size());\\n                    mp[x]=mp[items[k][0]];\\n                }\\n                      \\n            }\\n            \\n            res.push_back(mp[x]);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int next(vector<vector<int>>& arr, int target, int end){\\n      \\n        if(end==0) return -1;\\n        if(target>arr[end-1][0]) return end-1;\\n   \\n        int start=0;\\n \\n        int ans=-1;\\n        while (start<=end){\\n            int mid=(start+end)/2;\\n\\n            if (arr[mid][0]>=target){\\n                end=mid-1;\\n            }\\n\\n            else{\\n                ans=mid;\\n                start=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        \\n        map<int,int>mp;\\n        sort(items.begin(),items.end());\\n        int mx=INT_MIN;\\n        for(auto x:items){\\n            mx=max(mx,x[1]);\\n            mp[x[0]]=mx;\\n        }\\n        \\n        /*\\n        for(auto x:items){\\n            cout<<x[0]<<\" \"<<x[1]<<\\'\\\\n\\';\\n        }*/\\n        \\n        vector<int>res;\\n        for(auto x:queries){\\n            if(!(mp[x])){\\n                \\n                if(x<items[0][0]) mp[x]=0;\\n                else if(x>=items[items.size()-1][0]) mp[x]=mp[items[items.size()-1][0]];\\n                else {\\n                    int k=next(items,x,items.size());\\n                    mp[x]=mp[items[k][0]];\\n                }\\n                      \\n            }\\n            \\n            res.push_back(mp[x]);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1575903,
                "title": "java-treemap-simple-no-sorting-explanation",
                "content": "**Approach:**\\n* Create TreeMap[price, max beauty of a product].\\n* Iterate through tree map and update the max beauty of a product with max beauty to so far.\\n* For each query use built in floorEntry method to find the greatest price less than or equal to a query.\\n\\n**Complexities:**\\nTime Complexity: O(N log N + Q log N)\\nSpace Complexity: O(N)\\n\\n**Solution:**\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        NavigableMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int[] item: items) {\\n            if (map.containsKey(item[0])) {\\n                map.put(item[0], Math.max(item[1], map.get(item[0])));\\n            } else {\\n                map.put(item[0], item[1]);\\n            }\\n        }\\n        \\n        int maxSoFar = Integer.MIN_VALUE;\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            maxSoFar = Math.max(maxSoFar, entry.getValue());\\n            entry.setValue(maxSoFar);\\n        }   \\n            \\n        for (int i = 0; i < queries.length; ++ i) {\\n            Map.Entry<Integer, Integer> entry = map.floorEntry(queries[i]);\\n            if (entry == null) {\\n                queries[i] = 0;\\n            } else {\\n                queries[i] = entry.getValue();\\n            }\\n        }\\n        \\n        return queries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        NavigableMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int[] item: items) {\\n            if (map.containsKey(item[0])) {\\n                map.put(item[0], Math.max(item[1], map.get(item[0])));\\n            } else {\\n                map.put(item[0], item[1]);\\n            }\\n        }\\n        \\n        int maxSoFar = Integer.MIN_VALUE;\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            maxSoFar = Math.max(maxSoFar, entry.getValue());\\n            entry.setValue(maxSoFar);\\n        }   \\n            \\n        for (int i = 0; i < queries.length; ++ i) {\\n            Map.Entry<Integer, Integer> entry = map.floorEntry(queries[i]);\\n            if (entry == null) {\\n                queries[i] = 0;\\n            } else {\\n                queries[i] = entry.getValue();\\n            }\\n        }\\n        \\n        return queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993740,
                "title": "c-explained-simple-intuitive-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    static bool sortVec(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) \\n    {\\n        vector<int> res, max_beauty, price;\\n        int temp = 0;\\n\\n        sort(items.begin(), items.end(), sortVec);\\n        for(int i=0; i<items.size(); i++) price.push_back(items[i][0]);\\n\\n        // Maintain a list of max_beauty seen like a specific index number\\n        for(int i=0; i<items.size(); i++)\\n        {\\n            temp = max(temp, items[i][1]);\\n            max_beauty.push_back(temp);\\n        }\\n \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            int ub = upper_bound(price.begin(), price.end(), queries[i]) - price.begin();\\n            // Now that we know the upper bound index till a certain price, we can just use that index\\n            // to access the max_beauty seen until that index\\n            temp = (ub == 0 ? 0 : max_beauty[ub-1]);\\n            res.push_back(temp);\\n        } \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    static bool sortVec(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) \\n    {\\n        vector<int> res, max_beauty, price;\\n        int temp = 0;\\n\\n        sort(items.begin(), items.end(), sortVec);\\n        for(int i=0; i<items.size(); i++) price.push_back(items[i][0]);\\n\\n        // Maintain a list of max_beauty seen like a specific index number\\n        for(int i=0; i<items.size(); i++)\\n        {\\n            temp = max(temp, items[i][1]);\\n            max_beauty.push_back(temp);\\n        }\\n \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            int ub = upper_bound(price.begin(), price.end(), queries[i]) - price.begin();\\n            // Now that we know the upper bound index till a certain price, we can just use that index\\n            // to access the max_beauty seen until that index\\n            temp = (ub == 0 ? 0 : max_beauty[ub-1]);\\n            res.push_back(temp);\\n        } \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904573,
                "title": "c-super-easy-greedy-clean-code-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        \\n        sort(items.begin(),items.end());\\n        int sz = items.size();\\n        for(int i=1; i<sz; i++){\\n            items[i][1] = max(items[i-1][1],items[i][1]);\\n        }\\n        sz = queries.size();\\n        vector<int> ans(sz,0);\\n        for(int i=0; i<sz; i++){\\n            vector<int> comp = {queries[i],INT_MAX};\\n            int idx = upper_bound(items.begin(),items.end(),comp) - items.begin();\\n            idx--;\\n            if(idx < 0) continue;\\n            ans[i] = items[idx][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        \\n        sort(items.begin(),items.end());\\n        int sz = items.size();\\n        for(int i=1; i<sz; i++){\\n            items[i][1] = max(items[i-1][1],items[i][1]);\\n        }\\n        sz = queries.size();\\n        vector<int> ans(sz,0);\\n        for(int i=0; i<sz; i++){\\n            vector<int> comp = {queries[i],INT_MAX};\\n            int idx = upper_bound(items.begin(),items.end(),comp) - items.begin();\\n            idx--;\\n            if(idx < 0) continue;\\n            ans[i] = items[idx][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624564,
                "title": "c-hash-map-sorting",
                "content": "# Approach\\nSort the items according to prices and then change the items array such that at ith index, the items array stores the maximum beauty of items from 0 to index i. Now we can use a map to answer the queries efficiently by taking the upper bound of each query and storing the prev element\\'s beauty (just before the upper bound) in our answer.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& q) {\\n        sort(items.begin(),items.end());\\n        int n = items.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            items[i][1] = max(items[i-1][1],items[i][1]);\\n        }\\n        map<int,int> m;\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[items[i][0]] = items[i][1];\\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            auto it = m.upper_bound(q[i]);\\n            if(it==m.begin())\\n            ans.push_back(0);\\n            else\\n            {\\n                ans.push_back(prev(it)->second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& q) {\\n        sort(items.begin(),items.end());\\n        int n = items.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            items[i][1] = max(items[i-1][1],items[i][1]);\\n        }\\n        map<int,int> m;\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[items[i][0]] = items[i][1];\\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            auto it = m.upper_bound(q[i]);\\n            if(it==m.begin())\\n            ans.push_back(0);\\n            else\\n            {\\n                ans.push_back(prev(it)->second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944025,
                "title": "kotlin-sort-heap",
                "content": "# Intuition\\nsort array by prices, sort queries\\nfor each query add all beauties with price less or equal to priority queue and take an answer from it (if exists)\\n\\n# Code\\n```\\nclass Solution {\\n    fun maximumBeauty(a: Array<IntArray>, q: IntArray): IntArray {\\n        a.sortWith(compareBy { it: IntArray -> it[0] })\\n        var p = IntArray(a.size)\\n        for (i in 0..a.size - 1) {\\n            p[i] = a[i][0]\\n        }\\n        var iq = Array<IntArray>(q.size, { IntArray(2, { 0 }) })\\n        for (i in 0..q.size - 1) {\\n            iq[i][0] = q[i]\\n            iq[i][1] = i // original index\\n        }\\n        iq.sortWith(compareBy { it[0] })\\n        var qq = PriorityQueue<Int>(Collections.reverseOrder())\\n\\n        var pos = 0\\n        for (i in 0..iq.size - 1) {\\n            var cp = iq[i][0]\\n\\n            while (pos < a.size) {\\n                if (a[pos][0] > cp) break\\n                qq.add(a[pos][1])\\n                pos++\\n            }\\n\\n            q[iq[i][1]] = if (qq.size == 0) 0 else qq.peek()\\n        }\\n\\n        return q\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumBeauty(a: Array<IntArray>, q: IntArray): IntArray {\\n        a.sortWith(compareBy { it: IntArray -> it[0] })\\n        var p = IntArray(a.size)\\n        for (i in 0..a.size - 1) {\\n            p[i] = a[i][0]\\n        }\\n        var iq = Array<IntArray>(q.size, { IntArray(2, { 0 }) })\\n        for (i in 0..q.size - 1) {\\n            iq[i][0] = q[i]\\n            iq[i][1] = i // original index\\n        }\\n        iq.sortWith(compareBy { it[0] })\\n        var qq = PriorityQueue<Int>(Collections.reverseOrder())\\n\\n        var pos = 0\\n        for (i in 0..iq.size - 1) {\\n            var cp = iq[i][0]\\n\\n            while (pos < a.size) {\\n                if (a[pos][0] > cp) break\\n                qq.add(a[pos][1])\\n                pos++\\n            }\\n\\n            q[iq[i][1]] = if (qq.size == 0) 0 else qq.peek()\\n        }\\n\\n        return q\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640978,
                "title": "c-python-short-concise",
                "content": "\\n# C++\\n```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215433,
                "title": "python",
                "content": "\\t\\t\\tlists = []\\n\\t\\t\\tfor i in range(len(queries)):\\n\\t\\t\\t\\tlists.append([queries[i], i])\\n\\t\\t\\tlists.sort()\\n\\t\\t\\titems.sort()\\n\\t\\t\\tl = 0\\n\\t\\t\\tmaxs = 0\\n\\t\\t\\tfor i in range(len(lists)):\\n\\t\\t\\t\\twhile (l < len(items) and items[l][0] <= lists[i][0]):\\n\\t\\t\\t\\t\\tif (items[l][1] > maxs):\\n\\t\\t\\t\\t\\t\\tmaxs = items[l][1]\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\tqueries[lists[i][1]] = maxs\\n\\t\\t\\treturn queries\\n",
                "solutionTags": [],
                "code": "\\t\\t\\tlists = []\\n\\t\\t\\tfor i in range(len(queries)):\\n\\t\\t\\t\\tlists.append([queries[i], i])\\n\\t\\t\\tlists.sort()\\n\\t\\t\\titems.sort()\\n\\t\\t\\tl = 0\\n\\t\\t\\tmaxs = 0\\n\\t\\t\\tfor i in range(len(lists)):\\n\\t\\t\\t\\twhile (l < len(items) and items[l][0] <= lists[i][0]):\\n\\t\\t\\t\\t\\tif (items[l][1] > maxs):\\n\\t\\t\\t\\t\\t\\tmaxs = items[l][1]\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\tqueries[lists[i][1]] = maxs\\n\\t\\t\\treturn queries\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2164671,
                "title": "c-sorting-binary-search-prefix-max",
                "content": "```\\n\\n\\nstruct cmp{\\n    bool operator() (const vector<int> &a,const vector<int> &b) const {\\n        if(a[0] == b[0]){\\n            return a[1] < b[1];\\n        }\\n        \\n        return a[0] < b[0];\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& q) {\\n        //{p,b}\\n        //p<=q[j]\\n        \\n        /*sort according to price\\n        \\n        q=2\\n        \\n        (1,1) (1,2) (1,3) (2,1) (4,3)\\n        */\\n        int n = items.size();\\n        sort(items.begin(),items.end(),cmp());//O(nlogn)\\n        \\n        for(int i=1;i<n;i++){\\n            items[i][1] = max(items[i][1],items[i-1][1]);\\n        }\\n        vector<int> res(q.size());\\n        \\n        for(int i=0;i<q.size();i++){\\n            int lo = 0;\\n            int hi = n-1;\\n            int idx = -1;\\n\\n            while(lo<=hi){\\n                int mid = lo+(hi-lo)/2;\\n                int val = items[mid][0];\\n                if(val <= q[i]){\\n                    idx = mid;\\n                    lo = mid+1;\\n                }\\n                else{\\n                    hi = mid-1;\\n                }\\n            }\\n            \\n            if(idx == -1){\\n                res[i] = 0;\\n            }\\n            else{\\n                res[i] = items[idx][1];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n\\n\\nstruct cmp{\\n    bool operator() (const vector<int> &a,const vector<int> &b) const {\\n        if(a[0] == b[0]){\\n            return a[1] < b[1];\\n        }\\n        \\n        return a[0] < b[0];\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& q) {\\n        //{p,b}\\n        //p<=q[j]\\n        \\n        /*sort according to price\\n        \\n        q=2\\n        \\n        (1,1) (1,2) (1,3) (2,1) (4,3)\\n        */\\n        int n = items.size();\\n        sort(items.begin(),items.end(),cmp());//O(nlogn)\\n        \\n        for(int i=1;i<n;i++){\\n            items[i][1] = max(items[i][1],items[i-1][1]);\\n        }\\n        vector<int> res(q.size());\\n        \\n        for(int i=0;i<q.size();i++){\\n            int lo = 0;\\n            int hi = n-1;\\n            int idx = -1;\\n\\n            while(lo<=hi){\\n                int mid = lo+(hi-lo)/2;\\n                int val = items[mid][0];\\n                if(val <= q[i]){\\n                    idx = mid;\\n                    lo = mid+1;\\n                }\\n                else{\\n                    hi = mid-1;\\n                }\\n            }\\n            \\n            if(idx == -1){\\n                res[i] = 0;\\n            }\\n            else{\\n                res[i] = items[idx][1];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122741,
                "title": "c-using-map-store-prefix-max-then-binary-search",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> maximumBeauty(vector<vector<int>>& v, vector<int>& q) {\\n\\t\\t\\t\\tvector<int> res;\\n\\t\\t\\t\\tmap<int,int> m;\\n\\n\\t\\t\\t\\tfor(int i=0; i<v.size(); i++){\\n\\t\\t\\t\\t\\tif(m.find(v[i][0])!=m.end()){\\n\\t\\t\\t\\t\\t\\tm[v[i][0]] = max(m[v[i][0]],v[i][1]);\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tm[v[i][0]] = v[i][1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvector<pair<int,int>> arr;\\n\\t\\t\\t\\tint x=0;\\n\\t\\t\\t\\tfor(auto i: m){\\n\\t\\t\\t\\t\\tif(x==0){\\n\\t\\t\\t\\t\\t\\tarr.push_back({i.first,i.second});\\n\\t\\t\\t\\t\\t\\tx=1;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tint k = max(i.second,arr[arr.size()-1].second);\\n\\t\\t\\t\\t\\t\\tarr.push_back({i.first,k});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(auto i: q){\\n\\t\\t\\t\\t\\tint p = 0;\\n\\t\\t\\t\\t\\tint l = 0;\\n\\t\\t\\t\\t\\tint h = arr.size()-1;\\n\\n\\t\\t\\t\\t\\twhile(l<=h){\\n\\t\\t\\t\\t\\t\\tint m = (l+h)/2;\\n\\n\\t\\t\\t\\t\\t\\tif(arr[m].first == i){\\n\\t\\t\\t\\t\\t\\t\\tp = arr[m].second;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}else if(arr[m].first > i){\\n\\t\\t\\t\\t\\t\\t\\th = m-1;\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\tp = arr[m].second;\\n\\t\\t\\t\\t\\t\\t\\tl = m+1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tres.push_back(p);\\n\\t\\t\\t\\t}\\n\\n\\n\\n\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> maximumBeauty(vector<vector<int>>& v, vector<int>& q) {\\n\\t\\t\\t\\tvector<int> res;\\n\\t\\t\\t\\tmap<int,int> m;\\n\\n\\t\\t\\t\\tfor(int i=0; i<v.size(); i++){\\n\\t\\t\\t\\t\\tif(m.find(v[i][0])!=m.end()){\\n\\t\\t\\t\\t\\t\\tm[v[i][0]] = max(m[v[i][0]],v[i][1]);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1829491,
                "title": "java-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        // item [prices, beauty]\\n        \\n        /// queries, for each query determine maximum beauty of an item whose prices is less than or equal queries[j];\\n        \\n        /// prices <= queries[j];\\n        \\n        /// search from items, find prices <= queries[j], maximum beauty\\n        /// search maximum beauty or search for item\\n        \\n        /// search a item, item have price > query, search less\\n        /// search a item, item have price <= query\\n        /// search for beauty         mid       query\\n        \\n        /// sort by beauty,    \\n        /// upperbound query\\n        /// maximum item price <= query\\n        /// 0 -> item have maximum price < \\n        \\n        /// maximum beauty \\n        Arrays.sort(items, (a,b) -> a[0] - b[0]);\\n        int[] maxSofar = new int[items.length];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < items.length; i++) {\\n            max = Math.max(max, items[i][1]);\\n            maxSofar[i] = max;\\n        }\\n        \\n        int[] re = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = search(items, queries[i]);\\n            if (items[idx][0] > queries[i]) {\\n                re[i] = 0;\\n            } else re[i] = maxSofar[idx];\\n        }\\n        \\n        return re;\\n    }\\n    \\n    private int search(int[][] items, int val) {\\n        int i = 0, j = items.length - 1;\\n        while(i < j) {\\n            int mid = (i + j + 1) / 2;\\n            if (items[mid][0] <= val) i = mid;\\n            else j = mid - 1;\\n        }\\n        \\n        return i;\\n    }\\n}\\n\\n\\n/// [1,2], [2,4], [3,4] [3, 5], [5,6]; \\n///  2       4      4     5       6\\n/// //// 1 2 3 4 5 6  i = 0, j = 4        3",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        // item [prices, beauty]\\n        \\n        /// queries, for each query determine maximum beauty of an item whose prices is less than or equal queries[j];\\n        \\n        /// prices <= queries[j];\\n        \\n        /// search from items, find prices <= queries[j], maximum beauty\\n        /// search maximum beauty or search for item\\n        \\n        /// search a item, item have price > query, search less\\n        /// search a item, item have price <= query\\n        /// search for beauty         mid       query\\n        \\n        /// sort by beauty,    \\n        /// upperbound query\\n        /// maximum item price <= query\\n        /// 0 -> item have maximum price < \\n        \\n        /// maximum beauty \\n        Arrays.sort(items, (a,b) -> a[0] - b[0]);\\n        int[] maxSofar = new int[items.length];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < items.length; i++) {\\n            max = Math.max(max, items[i][1]);\\n            maxSofar[i] = max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1791832,
                "title": "simple-c-code-binary-search-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int findIndex(vector<vector<int>> &items,int target){\\n        int n=items.size();\\n        int lo=0;\\n        int hi=n-1;\\n        int mid;\\n        int idx=-1;\\n        while(lo<=hi){\\n            mid=(lo+hi)/2;\\n            if(items[mid][0]<=target){\\n                idx=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n=items.size();\\n        sort(items.begin(),items.end());\\n        vector<int> maxTillNow(n);\\n        maxTillNow[0]=items[0][1];\\n        for(int i=1;i<n;i++){\\n            maxTillNow[i]=max(maxTillNow[i-1],items[i][1]);\\n        }\\n        vector<int> ans;\\n        for(int q:queries){\\n            int idx=findIndex(items,q);\\n            if(idx==-1){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(maxTillNow[idx]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPLEASE UPVOTE IF YOU LIKE THE POST :)",
                "solutionTags": [
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findIndex(vector<vector<int>> &items,int target){\\n        int n=items.size();\\n        int lo=0;\\n        int hi=n-1;\\n        int mid;\\n        int idx=-1;\\n        while(lo<=hi){\\n            mid=(lo+hi)/2;\\n            if(items[mid][0]<=target){\\n                idx=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n=items.size();\\n        sort(items.begin(),items.end());\\n        vector<int> maxTillNow(n);\\n        maxTillNow[0]=items[0][1];\\n        for(int i=1;i<n;i++){\\n            maxTillNow[i]=max(maxTillNow[i-1],items[i][1]);\\n        }\\n        vector<int> ans;\\n        for(int q:queries){\\n            int idx=findIndex(items,q);\\n            if(idx==-1){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(maxTillNow[idx]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697639,
                "title": "java-binary-search-n-m-log-n-beats-100",
                "content": "```\\nclass Solution {\\n    \\n    private static int N;\\n    private static int M;\\n    \\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        N = items.length;\\n        M = queries.length;\\n        Arrays.sort(items, (a,b)->{\\n            return a[0]-b[0];\\n        });\\n        \\n        int []dp = new int[N];\\n        dp[0] = items[0][1];\\n        for(int i=1; i<N; ++i) {\\n            dp[i] = Math.max(items[i][1], dp[i-1]);\\n        }\\n        \\n        int []ans = new int[M];\\n        for(int i=0; i<M; ++i) {\\n            int idx = binarySearch(items, queries[i]);\\n            ans[i] = idx==-1?0:dp[idx];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int binarySearch(final int[][] items, final int target) {\\n        int left = 0;\\n        int right = N-1;\\n        int idx = -1;\\n        while(left<=right) {\\n            int mid = left+(right-left)/2;\\n            if(items[mid][0]<=target) {\\n                idx = mid;\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private static int N;\\n    private static int M;\\n    \\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        N = items.length;\\n        M = queries.length;\\n        Arrays.sort(items, (a,b)->{\\n            return a[0]-b[0];\\n        });\\n        \\n        int []dp = new int[N];\\n        dp[0] = items[0][1];\\n        for(int i=1; i<N; ++i) {\\n            dp[i] = Math.max(items[i][1], dp[i-1]);\\n        }\\n        \\n        int []ans = new int[M];\\n        for(int i=0; i<M; ++i) {\\n            int idx = binarySearch(items, queries[i]);\\n            ans[i] = idx==-1?0:dp[idx];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int binarySearch(final int[][] items, final int target) {\\n        int left = 0;\\n        int right = N-1;\\n        int idx = -1;\\n        while(left<=right) {\\n            int mid = left+(right-left)/2;\\n            if(items[mid][0]<=target) {\\n                idx = mid;\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664913,
                "title": "c-binary-search-prefix-sum",
                "content": "```\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        int n= items.size();\\n        for(int i=1; i<n; i++)\\n            items[i][1]=max(items[i][1],items[i-1][1]);\\n        vector<int> ans;\\n        for(auto i: queries){\\n            int a=0, b=n-1;\\n            while(a<b){\\n                int mid=b+((a-b)/2);\\n                if(items[mid][0]<=i)\\n                    a=mid;\\n                if(items[mid][0]>i)\\n                    b=mid-1;\\n            }\\n            if(items[0][0]>i)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(items[a][1]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        int n= items.size();\\n        for(int i=1; i<n; i++)\\n            items[i][1]=max(items[i][1],items[i-1][1]);\\n        vector<int> ans;\\n        for(auto i: queries){\\n            int a=0, b=n-1;\\n            while(a<b){\\n                int mid=b+((a-b)/2);\\n                if(items[mid][0]<=i)\\n                    a=mid;\\n                if(items[mid][0]>i)\\n                    b=mid-1;\\n            }\\n            if(items[0][0]>i)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(items[a][1]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661300,
                "title": "java-2-solutions-binary-search-or-treemap",
                "content": "First we preprocess the input data array. For any price, we only care about the maximum value up to that price point, so let\\'s update the input array beauty value to the max of `(beauty[i], beauty[i - 1])` from `0` to `n`. Note that it overlaps one element per loop to ensure that the maximum value gets carried over.\\n\\nThen we can either perform a binary search on the indexes or use TreeMap to find the highest index that is less than or equals to `queries[i]`.\\n\\n**Solution 1 (Binary Search 85ms as of 01/01/2022):**\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int n = queries.length, m = items.length;\\n        Arrays.sort(items, Comparator.comparingInt(o -> o[0]));\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < m; i++)\\n            items[i][1] = Math.max(items[i][1], items[i > 0? i - 1 : 0][1]);\\n\\n        int j = 0;\\n        for (int q : queries){\\n            int lo = -1, hi = m - 1; //pad lo = -1 to mark no result\\n            while(lo < hi){\\n                int mid = lo + (hi - lo) / 2 + 1;\\n                if (q >= items[mid][0]) lo = mid;\\n                else hi = mid - 1;\\n            }\\n            ans[j++] = lo == -1? 0 : items[lo][1];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n**Solution 2 (TreeMap 210ms as of 01/01/2022):**\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int n = queries.length, m = items.length;\\n        Arrays.sort(items, Comparator.comparingInt(o -> o[0]));\\n        int[] ans = new int[n];\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < m; i++){\\n            items[i][1] = Math.max(items[i][1], items[i > 0? i - 1 : 0][1]);\\n            map.put(items[i][0], items[i][1]);\\n        }\\n\\n        int j = 0;\\n        for (int q : queries)\\n            ans[j++] = map.floorKey(q) == null? 0 : map.get(map.floorKey(q));\\n\\n        return ans;\\n    }\\n}\\n```\\n\\nAs expected, binary search is a few times faster because of less overhead and no need to enqueue anything unlike treemap.\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int n = queries.length, m = items.length;\\n        Arrays.sort(items, Comparator.comparingInt(o -> o[0]));\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < m; i++)\\n            items[i][1] = Math.max(items[i][1], items[i > 0? i - 1 : 0][1]);\\n\\n        int j = 0;\\n        for (int q : queries){\\n            int lo = -1, hi = m - 1; //pad lo = -1 to mark no result\\n            while(lo < hi){\\n                int mid = lo + (hi - lo) / 2 + 1;\\n                if (q >= items[mid][0]) lo = mid;\\n                else hi = mid - 1;\\n            }\\n            ans[j++] = lo == -1? 0 : items[lo][1];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int n = queries.length, m = items.length;\\n        Arrays.sort(items, Comparator.comparingInt(o -> o[0]));\\n        int[] ans = new int[n];\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < m; i++){\\n            items[i][1] = Math.max(items[i][1], items[i > 0? i - 1 : 0][1]);\\n            map.put(items[i][0], items[i][1]);\\n        }\\n\\n        int j = 0;\\n        for (int q : queries)\\n            ans[j++] = map.floorKey(q) == null? 0 : map.get(map.floorKey(q));\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622459,
                "title": "c-o-nlogn-time-and-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        vector<int> storer1(items.size());\\n        vector<int> storer2(items.size());\\n        vector<int> ans;\\n        storer1[0]=items[0][0];\\n        storer2[0]=items[0][1];\\n        int n = items.size();\\n        for(int i=1;i<n;i++){\\n            storer1[i]=items[i][0];\\n            storer2[i]=max(items[i][1],storer2[i-1]);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]<storer1[0]) ans.push_back(0);\\n            else if(queries[i]>=storer1[n-1]) ans.push_back(storer2[n-1]);\\n            else{\\n                int storer=upper_bound(storer1.begin(),storer1.end(),queries[i])-storer1.begin()-1;\\n                if(storer1[storer]<=queries[i]){\\n                    ans.push_back(storer2[storer]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        vector<int> storer1(items.size());\\n        vector<int> storer2(items.size());\\n        vector<int> ans;\\n        storer1[0]=items[0][0];\\n        storer2[0]=items[0][1];\\n        int n = items.size();\\n        for(int i=1;i<n;i++){\\n            storer1[i]=items[i][0];\\n            storer2[i]=max(items[i][1],storer2[i-1]);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]<storer1[0]) ans.push_back(0);\\n            else if(queries[i]>=storer1[n-1]) ans.push_back(storer2[n-1]);\\n            else{\\n                int storer=upper_bound(storer1.begin(),storer1.end(),queries[i])-storer1.begin()-1;\\n                if(storer1[storer]<=queries[i]){\\n                    ans.push_back(storer2[storer]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602411,
                "title": "c-binary-search-o-nlogn-time-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        vector<int> price, beauty, res;\\n        sort(items.begin(), items.end());\\n        int mx = 0;\\n        for(auto &it : items){\\n            price.push_back(it[0]); // stored price of each item in sorted order\\n            mx = max(mx, it[1]); // max beauty that we can get for price <= it[0]\\n            beauty.push_back(mx); // stored the max beauty (at same index as it[0])\\n        }\\n\\t\\t\\n        for(auto &q : queries){\\n            int ub = upper_bound(price.begin(), price.end(), q) - price.begin(); // upper_bound returns an iterator.\\n\\t\\t\\t// so, if i is the index at which price[i] = q, than upper_bound will return an iterator pointing at (i+1)th element.\\n\\t\\t\\tint index = ub-1; // therefore, ub-1 would give us the index i, with max beauty at price = q. \\n            if(index >= 0){\\n                res.push_back(beauty[index]); // if valid index, push it in res vector.\\n            }else{ \\n                res.push_back(0); // otherwise push 0.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        vector<int> price, beauty, res;\\n        sort(items.begin(), items.end());\\n        int mx = 0;\\n        for(auto &it : items){\\n            price.push_back(it[0]); // stored price of each item in sorted order\\n            mx = max(mx, it[1]); // max beauty that we can get for price <= it[0]\\n            beauty.push_back(mx); // stored the max beauty (at same index as it[0])\\n        }\\n\\t\\t\\n        for(auto &q : queries){\\n            int ub = upper_bound(price.begin(), price.end(), q) - price.begin(); // upper_bound returns an iterator.\\n\\t\\t\\t// so, if i is the index at which price[i] = q, than upper_bound will return an iterator pointing at (i+1)th element.\\n\\t\\t\\tint index = ub-1; // therefore, ub-1 would give us the index i, with max beauty at price = q. \\n            if(index >= 0){\\n                res.push_back(beauty[index]); // if valid index, push it in res vector.\\n            }else{ \\n                res.push_back(0); // otherwise push 0.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589551,
                "title": "java-sort-and-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int[] ans = new int[queries.length];\\n        Arrays.sort(items, (a, b) -> (a[0] - b[0]));\\n        int maxBeautySoFar = Integer.MIN_VALUE;\\n        int[] maxBeauty = new int[items.length];\\n        \\n        for(int i = 0; i < items.length; i++) {\\n            if(maxBeautySoFar < items[i][1]) maxBeautySoFar = items[i][1];\\n            maxBeauty[i] = maxBeautySoFar;\\n        }\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = findLargestIdxWithPriceLessThan(items, queries[i]);\\n            if(idx != Integer.MIN_VALUE) ans[i] = maxBeauty[idx];\\n        }\\n        return ans;\\n    }\\n    \\n    public int findLargestIdxWithPriceLessThan(int[][] items, int price) {\\n        int l = 0;\\n        int r = items.length - 1;\\n        int maxIdxLessThanEqualToPrice = Integer.MIN_VALUE; \\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(items[mid][0] > price) {\\n                r = mid - 1;\\n            } else {\\n                maxIdxLessThanEqualToPrice = Math.max(maxIdxLessThanEqualToPrice, mid);\\n                l = mid + 1;\\n            }\\n        }\\n        return maxIdxLessThanEqualToPrice;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int[] ans = new int[queries.length];\\n        Arrays.sort(items, (a, b) -> (a[0] - b[0]));\\n        int maxBeautySoFar = Integer.MIN_VALUE;\\n        int[] maxBeauty = new int[items.length];\\n        \\n        for(int i = 0; i < items.length; i++) {\\n            if(maxBeautySoFar < items[i][1]) maxBeautySoFar = items[i][1];\\n            maxBeauty[i] = maxBeautySoFar;\\n        }\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = findLargestIdxWithPriceLessThan(items, queries[i]);\\n            if(idx != Integer.MIN_VALUE) ans[i] = maxBeauty[idx];\\n        }\\n        return ans;\\n    }\\n    \\n    public int findLargestIdxWithPriceLessThan(int[][] items, int price) {\\n        int l = 0;\\n        int r = items.length - 1;\\n        int maxIdxLessThanEqualToPrice = Integer.MIN_VALUE; \\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(items[mid][0] > price) {\\n                r = mid - 1;\\n            } else {\\n                maxIdxLessThanEqualToPrice = Math.max(maxIdxLessThanEqualToPrice, mid);\\n                l = mid + 1;\\n            }\\n        }\\n        return maxIdxLessThanEqualToPrice;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581645,
                "title": "golang-sort-solution",
                "content": "```go\\nfunc maximumBeauty(items [][]int, queries []int) []int {\\n\\tsort.Slice(items, func(i, j int) bool {\\n\\t\\tif items[i][0] == items[j][0] {\\n\\t\\t\\treturn items[i][1] > items[j][1]\\n\\t\\t}\\n\\t\\treturn items[i][0] < items[j][0]\\n\\t})\\n\\tbeauty := 0\\n\\tmagic := make([][]int, 0)\\n\\tfor _, v := range items {\\n\\t\\tif v[1] > beauty {\\n\\t\\t\\tbeauty = v[1]\\n\\t\\t\\tmagic = append(magic, []int{v[0], beauty})\\n\\t\\t}\\n\\t}\\n\\tresult := make([]int, len(queries))\\n\\tfor i, q := range queries {\\n\\t\\tresult[i] = binarySearch(magic, q)\\n\\t}\\n\\treturn result\\n}\\n\\nfunc binarySearch(magic [][]int, query int) int {\\n\\tl, r := 0, len(magic)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif magic[m][0] > query {\\n\\t\\t\\tr = m-1\\n\\t\\t} else {\\n\\t\\t\\tl = m+1\\n\\t\\t}\\n\\t}\\n\\tif l-1 >= 0 {\\n\\t\\treturn magic[l-1][1]\\n\\t}\\n\\treturn 0\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```go\\nfunc maximumBeauty(items [][]int, queries []int) []int {\\n\\tsort.Slice(items, func(i, j int) bool {\\n\\t\\tif items[i][0] == items[j][0] {\\n\\t\\t\\treturn items[i][1] > items[j][1]\\n\\t\\t}\\n\\t\\treturn items[i][0] < items[j][0]\\n\\t})\\n\\tbeauty := 0\\n\\tmagic := make([][]int, 0)\\n\\tfor _, v := range items {\\n\\t\\tif v[1] > beauty {\\n\\t\\t\\tbeauty = v[1]\\n\\t\\t\\tmagic = append(magic, []int{v[0], beauty})\\n\\t\\t}\\n\\t}\\n\\tresult := make([]int, len(queries))\\n\\tfor i, q := range queries {\\n\\t\\tresult[i] = binarySearch(magic, q)\\n\\t}\\n\\treturn result\\n}\\n\\nfunc binarySearch(magic [][]int, query int) int {\\n\\tl, r := 0, len(magic)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif magic[m][0] > query {\\n\\t\\t\\tr = m-1\\n\\t\\t} else {\\n\\t\\t\\tl = m+1\\n\\t\\t}\\n\\t}\\n\\tif l-1 >= 0 {\\n\\t\\treturn magic[l-1][1]\\n\\t}\\n\\treturn 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580782,
                "title": "dictionary-of-max-beauties-99-55-speed",
                "content": "![image](https://assets.leetcode.com/users/images/d9a554f1-efea-4216-aea2-3eb4d418e0c5_1637046775.226072.png)\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        max_beauty = defaultdict(int)\\n        for price, beauty in items:\\n            max_beauty[price] = max(beauty, max_beauty[price])\\n        prices = sorted(max_beauty.keys())\\n        for p1, p2 in zip(prices, prices[1:]):\\n            max_beauty[p2] = max(max_beauty[p2], max_beauty[p1])\\n        return [max_beauty[prices[idx - 1]]\\n                if (idx := bisect_right(prices, q)) > 0 else 0\\n                for q in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        max_beauty = defaultdict(int)\\n        for price, beauty in items:\\n            max_beauty[price] = max(beauty, max_beauty[price])\\n        prices = sorted(max_beauty.keys())\\n        for p1, p2 in zip(prices, prices[1:]):\\n            max_beauty[p2] = max(max_beauty[p2], max_beauty[p1])\\n        return [max_beauty[prices[idx - 1]]\\n                if (idx := bisect_right(prices, q)) > 0 else 0\\n                for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579985,
                "title": "python3-100-00-faster-runtime-100-00-less-memory-usage-sort-binary-search",
                "content": "Similar questions:\\n- https://leetcode.com/problems/closest-room/\\n- https://leetcode.com/problems/two-best-non-overlapping-events/\\n- https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/\\n\\n```python\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n\\t    # sort all items to define max `beauty` and binary search\\n        items.sort(key=lambda a: a[0])\\n\\t\\t\\n\\t\\t# save maximum `beauty` for each element\\n        mx = 0\\n        for item in items:\\n            mx = max(mx, item[1])\\n            item[1] = mx        \\n\\n        results = []\\n        for q in queries:\\n            l, h = 0, len(items) - 1\\n            ans = 0\\n            while l <= h:\\n                m = l + (h - l) // 2\\n                \\n                if items[m][0] <= q:\\n\\t\\t\\t\\t    # update answer for each low constraint update\\n                    ans = items[m][1]\\n                    l = m + 1\\n                else:\\n                    h = m - 1\\n\\n            results.append(ans)\\n        return results\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n\\t    # sort all items to define max `beauty` and binary search\\n        items.sort(key=lambda a: a[0])\\n\\t\\t\\n\\t\\t# save maximum `beauty` for each element\\n        mx = 0\\n        for item in items:\\n            mx = max(mx, item[1])\\n            item[1] = mx        \\n\\n        results = []\\n        for q in queries:\\n            l, h = 0, len(items) - 1\\n            ans = 0\\n            while l <= h:\\n                m = l + (h - l) // 2\\n                \\n                if items[m][0] <= q:\\n\\t\\t\\t\\t    # update answer for each low constraint update\\n                    ans = items[m][1]\\n                    l = m + 1\\n                else:\\n                    h = m - 1\\n\\n            results.append(ans)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577167,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>&nums, vector<int>& qur)\\n    {\\n        int n=qur.size();\\n        vector<int>ans(n,0);\\n        vector<vector<int>>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            q.push_back({qur[i],i});\\n        }\\n        sort(q.begin(),q.end());\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int max_val=0;\\n        for(auto it:q)\\n        {\\n            int val=it[0];\\n            int index=it[1];\\n            while(i<nums.size()&&nums[i][0]<=val)\\n            {\\n                max_val=max(max_val,nums[i][1]);\\n                i++;\\n            }\\n            ans[index]=max_val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>&nums, vector<int>& qur)\\n    {\\n        int n=qur.size();\\n        vector<int>ans(n,0);\\n        vector<vector<int>>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            q.push_back({qur[i],i});\\n        }\\n        sort(q.begin(),q.end());\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int max_val=0;\\n        for(auto it:q)\\n        {\\n            int val=it[0];\\n            int index=it[1];\\n            while(i<nums.size()&&nums[i][0]<=val)\\n            {\\n                max_val=max(max_val,nums[i][1]);\\n                i++;\\n            }\\n            ans[index]=max_val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577161,
                "title": "c-sorting",
                "content": "```\\n\\n```public:\\n    vector<int> maximumBeauty(vector<vector<int>>& nums, vector<int>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            v.push_back({queries[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int>res(queries.size());\\n        int j=0,maxx=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int x=v[i].first;\\n            while(j<nums.size()&&nums[j][0]<=x)\\n            {\\n                maxx=max(maxx,nums[j][1]);\\n                j++;\\n            }\\n            res[v[i].second]=maxx;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576320,
                "title": "python-java-sort-and-binary-search",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t\\titems.sort(key = lambda x:(x[0], -x[1]))\\n\\t\\t\\tcurMax = -float(\"inf\")\\n\\t\\t\\tfor i in range(len(items)):\\n\\t\\t\\t\\tcurMax = max(curMax, items[i][1])\\n\\t\\t\\t\\titems[i][1] = curMax\\n\\t\\t\\tres = []\\n\\t\\t\\tfor query in queries:\\n\\t\\t\\t\\tif items[0][0] > query:\\n\\t\\t\\t\\t\\tres.append(0)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl = 0\\n\\t\\t\\t\\t\\tr = len(items) - 1\\n\\t\\t\\t\\t\\twhile l + 1 < r:\\n\\t\\t\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\t\\t\\tif items[m][0] <= query:\\n\\t\\t\\t\\t\\t\\t\\tl = m\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\t\\tif items[r][0] <= query:\\n\\t\\t\\t\\t\\t\\tres.append(items[r][1])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres.append(items[l][1])\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int[] maximumBeauty(int[][] items, int[] queries) {\\n\\t\\t\\tArrays.sort(items, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n\\t\\t\\tint[] res = new int[queries.length];\\n\\t\\t\\tint curMax = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int i = 0; i < items.length; i ++) {\\n\\t\\t\\t\\tcurMax = Math.max(curMax, items[i][1]);\\n\\t\\t\\t\\titems[i][1] = curMax;\\n\\t\\t\\t}\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tfor (int query: queries) {\\n\\t\\t\\t\\tif (items[0][0] <= query) {\\n\\t\\t\\t\\t\\tint l = 0;\\n\\t\\t\\t\\t\\tint r = items.length - 1;\\n\\t\\t\\t\\t\\twhile (l + 1 < r) {\\n\\t\\t\\t\\t\\t\\tint m = (r - l) / 2 + l;\\n\\t\\t\\t\\t\\t\\tif (items[m][0] <= query) {\\n\\t\\t\\t\\t\\t\\t\\tl = m;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tr = m;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (items[r][0] <= query) {\\n\\t\\t\\t\\t\\t\\tres[i] = items[r][1];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tres[i] = items[l][1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti ++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t\\titems.sort(key = lambda x:(x[0], -x[1]))\\n\\t\\t\\tcurMax = -float(\"inf\")\\n\\t\\t\\tfor i in range(len(items)):\\n\\t\\t\\t\\tcurMax = max(curMax, items[i][1])\\n\\t\\t\\t\\titems[i][1] = curMax\\n\\t\\t\\tres = []\\n\\t\\t\\tfor query in queries:\\n\\t\\t\\t\\tif items[0][0] > query:\\n\\t\\t\\t\\t\\tres.append(0)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl = 0\\n\\t\\t\\t\\t\\tr = len(items) - 1\\n\\t\\t\\t\\t\\twhile l + 1 < r:\\n\\t\\t\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\t\\t\\tif items[m][0] <= query:\\n\\t\\t\\t\\t\\t\\t\\tl = m\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\t\\tif items[r][0] <= query:\\n\\t\\t\\t\\t\\t\\tres.append(items[r][1])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres.append(items[l][1])\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int[] maximumBeauty(int[][] items, int[] queries) {\\n\\t\\t\\tArrays.sort(items, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n\\t\\t\\tint[] res = new int[queries.length];\\n\\t\\t\\tint curMax = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int i = 0; i < items.length; i ++) {\\n\\t\\t\\t\\tcurMax = Math.max(curMax, items[i][1]);\\n\\t\\t\\t\\titems[i][1] = curMax;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1576299,
                "title": "c-intuitive-solution-100-faster",
                "content": "Online Queries mode(100% faster till date)\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        \\n        for (int i = 1; i < items.size(); ++i) {\\n            items[i][1] = max(items[i][1], items[i - 1][1]); \\n        }\\n        \\n        vector<int> ans;\\n        \\n        for (auto query: queries) {\\n            auto it = lower_bound(items.begin(), items.end(), vector{query, INT_MAX});\\n            if (it == items.begin()) {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            --it;\\n            ans.push_back((*it)[1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nOffline Queries mode (slower than online mode)\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        vector<pair<int, int>> queries_idx(queries.size());\\n        \\n        for (int i = 0; i < queries.size(); ++i) {\\n            queries_idx[i] = {queries[i], i};\\n        }\\n        \\n        sort(queries_idx.begin(), queries_idx.end());\\n        sort(items.begin(), items.end());\\n        \\n        int max_beauty = 0;\\n        vector<int> ans(queries.size());\\n        int items_idx = 0;\\n        \\n        for (auto [query, idx]: queries_idx) {\\n            while (items_idx < items.size() && items[items_idx][0] <= query) {\\n                max_beauty = max(max_beauty, items[items_idx][1]);\\n                ++items_idx;\\n            }\\n            ans[idx] = max_beauty;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        \\n        for (int i = 1; i < items.size(); ++i) {\\n            items[i][1] = max(items[i][1], items[i - 1][1]); \\n        }\\n        \\n        vector<int> ans;\\n        \\n        for (auto query: queries) {\\n            auto it = lower_bound(items.begin(), items.end(), vector{query, INT_MAX});\\n            if (it == items.begin()) {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            --it;\\n            ans.push_back((*it)[1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        vector<pair<int, int>> queries_idx(queries.size());\\n        \\n        for (int i = 0; i < queries.size(); ++i) {\\n            queries_idx[i] = {queries[i], i};\\n        }\\n        \\n        sort(queries_idx.begin(), queries_idx.end());\\n        sort(items.begin(), items.end());\\n        \\n        int max_beauty = 0;\\n        vector<int> ans(queries.size());\\n        int items_idx = 0;\\n        \\n        for (auto [query, idx]: queries_idx) {\\n            while (items_idx < items.size() && items[items_idx][0] <= query) {\\n                max_beauty = max(max_beauty, items[items_idx][1]);\\n                ++items_idx;\\n            }\\n            ans[idx] = max_beauty;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576295,
                "title": "c-solution-map-lower-bound",
                "content": "Create map with key being price and value being max(beauty which holds same price)\\n```\\n[[1,2],[3,2],[2,4],[5,6],[3,5]]\\n```\\nMap would look like\\nKey             Value\\n1                     2\\n2                     4\\n3                     5\\n5                      6\\n\\nNow will use DP kind of technique and hence will modify map with max(beauty[i],beauty[i-1])\\n\\nand lastly apply lower_bound to get answer of each query in log N\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        map<int,int> m;\\n        for(int i=0;i<items.size();i++){\\n            int first = items[i][0];\\n            int second = items[i][1];\\n            m[first] = max(m[first],second);\\n        }\\n        //d(m);\\n        auto it = m.begin();\\n        int prev = it->second;\\n        it++;\\n        for(;it!=m.end();it++){\\n            it->second = max(it->second,prev);\\n            prev = it->second;\\n        }\\n\\n        vector<int> ans(queries.size());\\n        for(int i=0;i<queries.size();i++){\\n            auto x = m.upper_bound(queries[i]);\\n            if(x!=m.begin()){\\n                --x;    \\n                ans[i] = (*x).second;\\n            }\\n            else{\\n                ans[i] = m.begin()->first <= queries[i] ? m.begin()->second : 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[[1,2],[3,2],[2,4],[5,6],[3,5]]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        map<int,int> m;\\n        for(int i=0;i<items.size();i++){\\n            int first = items[i][0];\\n            int second = items[i][1];\\n            m[first] = max(m[first],second);\\n        }\\n        //d(m);\\n        auto it = m.begin();\\n        int prev = it->second;\\n        it++;\\n        for(;it!=m.end();it++){\\n            it->second = max(it->second,prev);\\n            prev = it->second;\\n        }\\n\\n        vector<int> ans(queries.size());\\n        for(int i=0;i<queries.size();i++){\\n            auto x = m.upper_bound(queries[i]);\\n            if(x!=m.begin()){\\n                --x;    \\n                ans[i] = (*x).second;\\n            }\\n            else{\\n                ans[i] = m.begin()->first <= queries[i] ? m.begin()->second : 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576236,
                "title": "my-simple-approach-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        //assigning better beauty values to lower prices\\n        int n=items.size();\\n        for(int i=1;i<n;i++){\\n            if(items[i][1]<items[i-1][1]){\\n                items[i][1]=items[i-1][1];\\n            }\\n        }\\n\\t\\t//assigning values to with same price\\n        for(int i=n-1;i>0;i--){\\n            \\n            if(items[i][0]==items[i-1][0]){\\n                items[i-1][1]=max(items[i-1][1],items[i][1]);\\n                items[i][1]=max(items[i-1][1],items[i][1]);\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     cout<<items[i][1]<<\" \";\\n        // }\\n        \\n        vector<int>v;\\n        int mn=INT_MAX;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            mn=min(mn,items[i][0]);\\n            mx=max(mx,items[i][0]);\\n        }\\n        //find the customised lower bound\\n        vector<int>x;\\n        for(int i=0;i<n;i++){\\n            x.push_back(items[i][0]);\\n        }\\n        for(auto i:queries)\\n        {    \\n            int X=i;\\n            int N=n;\\n            if(i<mn){\\n                v.push_back(0);\\n                continue;\\n            }\\n            if(i>mx){\\n                v.push_back(items[n-1][1]);\\n                continue;\\n            }\\n            int low1 = lower_bound(x.begin(), x.end(), i)-x.begin();\\n            if(x[low1] != i){\\n                low1--;\\n            }\\n            v.push_back(items[low1][1]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        //assigning better beauty values to lower prices\\n        int n=items.size();\\n        for(int i=1;i<n;i++){\\n            if(items[i][1]<items[i-1][1]){\\n                items[i][1]=items[i-1][1];\\n            }\\n        }\\n\\t\\t//assigning values to with same price\\n        for(int i=n-1;i>0;i--){\\n            \\n            if(items[i][0]==items[i-1][0]){\\n                items[i-1][1]=max(items[i-1][1],items[i][1]);\\n                items[i][1]=max(items[i-1][1],items[i][1]);\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     cout<<items[i][1]<<\" \";\\n        // }\\n        \\n        vector<int>v;\\n        int mn=INT_MAX;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            mn=min(mn,items[i][0]);\\n            mx=max(mx,items[i][0]);\\n        }\\n        //find the customised lower bound\\n        vector<int>x;\\n        for(int i=0;i<n;i++){\\n            x.push_back(items[i][0]);\\n        }\\n        for(auto i:queries)\\n        {    \\n            int X=i;\\n            int N=n;\\n            if(i<mn){\\n                v.push_back(0);\\n                continue;\\n            }\\n            if(i>mx){\\n                v.push_back(items[n-1][1]);\\n                continue;\\n            }\\n            int low1 = lower_bound(x.begin(), x.end(), i)-x.begin();\\n            if(x[low1] != i){\\n                low1--;\\n            }\\n            v.push_back(items[low1][1]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1576187,
                "title": "java-sort-items-and-queries-no-treemap-offline-beats-100",
                "content": "**Idea:**\\n1. Sort items by the price\\n2. Sort queries as well, but keep their original index also, so that we can fill up answer easily for each query. \\n3. We sort queries and then for each query price, we move ahead in items array until it is <= query price. We also maintain running max till this point\\n4. Once we reach till an item such that its price > query price, we stop and update ans with current max we found so far.\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items, (a, b) -> a[0] - b[0]); // sort items by price\\n        int[] ans = new int[queries.length];\\n        int[][] q = new int[queries.length][2]; // convert queries into {queryPrice, index} format so that later when we sort the query, we still know their original index, it will be used to fill ans array\\n        for(int i = 0; i < queries.length; i++) {\\n            q[i][0] = queries[i];\\n            q[i][1] = i;\\n        }\\n        Arrays.sort(q, (a, b) -> a[0] - b[0]); // sort queries by the query price values\\n        int curmax = 0; // running max\\n        int i = 0; // pointer inside sorted items array\\n        for(int[] qe : q) {\\n            int idx = qe[1];\\n            int upper = qe[0];\\n            while(i < items.length && items[i][0] <= upper) { // we move ahead in items array untill it is <= query price\\n                curmax = Math.max(curmax, items[i][1]);\\n                i++;\\n            }\\n            ans[idx] = curmax; // just put current running max in ans,\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items, (a, b) -> a[0] - b[0]); // sort items by price\\n        int[] ans = new int[queries.length];\\n        int[][] q = new int[queries.length][2]; // convert queries into {queryPrice, index} format so that later when we sort the query, we still know their original index, it will be used to fill ans array\\n        for(int i = 0; i < queries.length; i++) {\\n            q[i][0] = queries[i];\\n            q[i][1] = i;\\n        }\\n        Arrays.sort(q, (a, b) -> a[0] - b[0]); // sort queries by the query price values\\n        int curmax = 0; // running max\\n        int i = 0; // pointer inside sorted items array\\n        for(int[] qe : q) {\\n            int idx = qe[1];\\n            int upper = qe[0];\\n            while(i < items.length && items[i][0] <= upper) { // we move ahead in items array untill it is <= query price\\n                curmax = Math.max(curmax, items[i][1]);\\n                i++;\\n            }\\n            ans[idx] = curmax; // just put current running max in ans,\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576117,
                "title": "c-solution-using-map-and-binary-search",
                "content": "Idea:\\n* get the max beauty for a given price p and save it in a map\\n* now case may arise that a price lower than the current price may have beauty greater than current price, so making some prefix (max) beauty for each given price.\\n* then using binary search, just finding as per given query price.\\n```\\n\\tvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n=queries.size();\\n        vector<int>ans;\\n        sort(items.begin(),items.end());\\n        map<int,int>mx_prices;\\n        \\n        for(int i=0;i<items.size();i++){\\n            int num=items[i][0], val=items[i][1];\\n            mx_prices[num]=max(val,mx_prices[num]);\\n        }\\n        int temp=0;\\n        for(auto &x:mx_prices){\\n            x.second=max(x.second,temp);\\n            temp=x.second;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int qprice=queries[i];\\n            auto it=mx_prices.upper_bound(qprice);\\n            if(it==mx_prices.begin()){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            it--;\\n            ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n=queries.size();\\n        vector<int>ans;\\n        sort(items.begin(),items.end());\\n        map<int,int>mx_prices;\\n        \\n        for(int i=0;i<items.size();i++){\\n            int num=items[i][0], val=items[i][1];\\n            mx_prices[num]=max(val,mx_prices[num]);\\n        }\\n        int temp=0;\\n        for(auto &x:mx_prices){\\n            x.second=max(x.second,temp);\\n            temp=x.second;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int qprice=queries[i];\\n            auto it=mx_prices.upper_bound(qprice);\\n            if(it==mx_prices.begin()){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            it--;\\n            ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576096,
                "title": "c-it-did-work-but-30-minutes-late-max-heap-and-sorting",
                "content": "Code had bugs during contest but I\\'m glad that it later worked. and happy that I was able to do it somehow.\\nPlease dry run the solution atleast once, it is very simple, much simpler than what it looks.\\n\\n**Logic:** On top of max heap we store max weight.\\nThen, we sort queries[], and start traversing from maximum price, if we can\\'t afford what is at the top of heap, we pop out until we reach a price which we can afford. I have commented this part in code.\\nHow to check what we can afford, map will do that for us: {weight: price}.\\n\\nSince we sorted queries[], we need to put elements back at their right position, copy[] array does that, it stores initiial queries, and later we fetch the corresponding {price: weight} pair from sorted map and store it at correct location in res.\\n\\n**T.C:** Mainly due to following operations - Inserting all weight into heap O(MlogM) + sorting the queries[] array O(NlogN) = O(NlogN) + O(MlogM)\\nwhere M = items.size(), N = queries.size()\\n\\n**Also, it is surprisingly fast!**\\n\\n![image](https://assets.leetcode.com/users/images/1afa00b6-59e7-43c7-948c-7c1f5fa6b40c_1636822877.5933678.png)\\n\\n```\\nvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        unordered_map<int, int> m;\\n        priority_queue<int> maxHeap;\\n        for(auto &c:items){\\n            int price = c[0], wt = c[1];\\n            maxHeap.push(wt);\\n            if(m.find(wt) != m.end()) {\\n                if(m[wt] > price) m[wt] = price;\\n            }\\n            else m[wt] = price;\\n        }\\n       \\n        vector<int> copy(queries.size(), 0);\\n        for(int i=0; i<queries.size(); i++) copy[i] = queries[i];\\n        sort(queries.begin(), queries.end());\\n        \\n        unordered_map<int, int> sorted;\\n        \\n        for(int i=queries.size()-1; i>=0; i--){\\n            int c = queries[i];\\n\\t\\t\\t// We can afford this\\n            if(m[maxHeap.top()] <= c) sorted[c] = maxHeap.top();\\n            else{\\n\\t\\t\\t//We can\\'t afford what is at top currently. So, pop until we reach a weight that we can afford. \\n                while(maxHeap.size() && m[maxHeap.top()] > c) maxHeap.pop();\\n                if(maxHeap.size()) sorted[c] = maxHeap.top();\\n            }\\n        }\\n        vector<int> res(queries.size(), 0);\\n\\t\\t//Insert elements at right place as per queries[]\\n        for(int i=0; i<copy.size(); i++) res[i] = sorted[copy[i]];\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        unordered_map<int, int> m;\\n        priority_queue<int> maxHeap;\\n        for(auto &c:items){\\n            int price = c[0], wt = c[1];\\n            maxHeap.push(wt);\\n            if(m.find(wt) != m.end()) {\\n                if(m[wt] > price) m[wt] = price;\\n            }\\n            else m[wt] = price;\\n        }\\n       \\n        vector<int> copy(queries.size(), 0);\\n        for(int i=0; i<queries.size(); i++) copy[i] = queries[i];\\n        sort(queries.begin(), queries.end());\\n        \\n        unordered_map<int, int> sorted;\\n        \\n        for(int i=queries.size()-1; i>=0; i--){\\n            int c = queries[i];\\n\\t\\t\\t// We can afford this\\n            if(m[maxHeap.top()] <= c) sorted[c] = maxHeap.top();\\n            else{\\n\\t\\t\\t//We can\\'t afford what is at top currently. So, pop until we reach a weight that we can afford. \\n                while(maxHeap.size() && m[maxHeap.top()] > c) maxHeap.pop();\\n                if(maxHeap.size()) sorted[c] = maxHeap.top();\\n            }\\n        }\\n        vector<int> res(queries.size(), 0);\\n\\t\\t//Insert elements at right place as per queries[]\\n        for(int i=0; i<copy.size(); i++) res[i] = sorted[copy[i]];\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576093,
                "title": "java-binary-search-easy-and-readable-solution-o-nlogn-qlogn",
                "content": "```\\n\\n//Time: O(NlogN) for Sorting items, O(QLogN) to binary search the answer to each query\\n//Space: O(N), for storing beauties of items\\n\\nclass CustomComparator implements Comparator<int[]>{\\n    public int compare(int[] a1, int[] a2){\\n        if(a1[0] < a2[0]){\\n            return -1;\\n        }\\n        else if(a1[0] == a2[0]){\\n            return a1[1] - a2[1];\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        Arrays.sort(items, new CustomComparator());\\n        \\n        int[] beauties = new int[items.length];\\n        \\n        beauties[0] = items[0][1];\\n        \\n        for(int i=1;i<items.length;i++){\\n            beauties[i] = Math.max(beauties[i-1], items[i][1]);\\n        }\\n        \\n        int[] ans = new int[queries.length];\\n        \\n        for(int i=0;i< queries.length; i++){\\n            \\n            int price = queries[i];\\n            \\n            int low = 0;\\n            int high = items.length-1;\\n            int res = 0;\\n            \\n            while(low <= high){\\n                \\n                int mid = low + (high-low)/2;\\n                \\n                if(items[mid][0] <= price){\\n                    res = beauties[mid];\\n                    low = mid+1;\\n                }\\n                else{\\n                    high = mid-1;\\n                }\\n                \\n            }\\n            \\n            ans[i] = res;\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n//Time: O(NlogN) for Sorting items, O(QLogN) to binary search the answer to each query\\n//Space: O(N), for storing beauties of items\\n\\nclass CustomComparator implements Comparator<int[]>{\\n    public int compare(int[] a1, int[] a2){\\n        if(a1[0] < a2[0]){\\n            return -1;\\n        }\\n        else if(a1[0] == a2[0]){\\n            return a1[1] - a2[1];\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        Arrays.sort(items, new CustomComparator());\\n        \\n        int[] beauties = new int[items.length];\\n        \\n        beauties[0] = items[0][1];\\n        \\n        for(int i=1;i<items.length;i++){\\n            beauties[i] = Math.max(beauties[i-1], items[i][1]);\\n        }\\n        \\n        int[] ans = new int[queries.length];\\n        \\n        for(int i=0;i< queries.length; i++){\\n            \\n            int price = queries[i];\\n            \\n            int low = 0;\\n            int high = items.length-1;\\n            int res = 0;\\n            \\n            while(low <= high){\\n                \\n                int mid = low + (high-low)/2;\\n                \\n                if(items[mid][0] <= price){\\n                    res = beauties[mid];\\n                    low = mid+1;\\n                }\\n                else{\\n                    high = mid-1;\\n                }\\n                \\n            }\\n            \\n            ans[i] = res;\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576060,
                "title": "python-runtime-1358-ms-faster-than-100-00-time-o-nlogn",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        N = len(queries)\\n        new = [(v,i) for i,v in enumerate(queries)]\\n        new.sort()\\n        ans = [0] * N\\n        \\n        score = j = 0\\n\\t\\t\\n\\t\\t# we iterate through items from the lowest to the highest and update current max number\\n\\t\\t# if the price in queries is higher, we add current max to answer at corresponding index\\n        for k,v in items:\\n            while j < N and k > new[j][0]:\\n                ans[new[j][1]] = score\\n                j += 1\\n            score = max(score, v)\\n\\t\\t\\t\\n\\t\\t# if there are bigger prices in queries than available in items, we put max number\\n        while j < N:\\n            _, idx = new[j]\\n            ans[idx] = score\\n            j += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        N = len(queries)\\n        new = [(v,i) for i,v in enumerate(queries)]\\n        new.sort()\\n        ans = [0] * N\\n        \\n        score = j = 0\\n\\t\\t\\n\\t\\t# we iterate through items from the lowest to the highest and update current max number\\n\\t\\t# if the price in queries is higher, we add current max to answer at corresponding index\\n        for k,v in items:\\n            while j < N and k > new[j][0]:\\n                ans[new[j][1]] = score\\n                j += 1\\n            score = max(score, v)\\n\\t\\t\\t\\n\\t\\t# if there are bigger prices in queries than available in items, we put max number\\n        while j < N:\\n            _, idx = new[j]\\n            ans[idx] = score\\n            j += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575991,
                "title": "java-priority-queue-solution",
                "content": "* Sort the given [prices-beauty] matrix on the basis of increasing prices.\\n\\n* Now sort the Queries in increasing manner along with storing the index of every query so that later on we can easily fill the resultant array.\\n\\n* Now make a Priority Queue of [prices-beauty] and make sure it stores these pairs in decreasing order of beauty, (i.e highest beauty on top).\\n\\n* Simply iterate over the sorted query list and store all the  [price-beauty] pairs in the PriorityQueue whose prices are less than or equal to current Query(this can be done using another pointer..here see j pointer in code).\\n\\n* Finally peek() the PriorityQueue to see the greatest beauty upto current price and store it in the resultant array.\\n\\n\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] mat, int[] query) {\\n        int n = mat.length;\\n\\n        Arrays.sort(mat, (a, b) - > a[0] - b[0]);\\n\\n        int q = query.length;\\n        int res[] = new int[q];\\n        ArrayList < Pair > a = new ArrayList < > ();\\n        for (int i = 0; i < q; i++) {\\n            a.add(new Pair(query[i], i));\\n        }\\n\\n        Collections.sort(a, new Comparator < Pair > () {\\n\\n            @Override\\n            public int compare(Pair o1, Pair o2) {\\n                return o1.query - o2.query;\\n            }\\n\\n        });\\n\\n\\n        PriorityQueue < int[] > pQueue = new PriorityQueue < > ((c, d) - > d[1] - c[1]);\\n\\n        int j = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            int curr = a.get(i).query;\\n            while (j < n && mat[j][0] <= curr) {\\n                pQueue.add(new int[] {\\n                    mat[j][0], mat[j][1]\\n                });\\n                j++;\\n            }\\n            if (pQueue.size() > 0) res[a.get(i).index] = pQueue.peek()[1];\\n        }\\n\\n        return res;\\n    }\\n\\n\\n    static class Pair {\\n        int query;\\n        int index;\\n        public Pair(int query, int index) {\\n            super();\\n            this.query = query;\\n            this.index = index;\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] mat, int[] query) {\\n        int n = mat.length;\\n\\n        Arrays.sort(mat, (a, b) - > a[0] - b[0]);\\n\\n        int q = query.length;\\n        int res[] = new int[q];\\n        ArrayList < Pair > a = new ArrayList < > ();\\n        for (int i = 0; i < q; i++) {\\n            a.add(new Pair(query[i], i));\\n        }\\n\\n        Collections.sort(a, new Comparator < Pair > () {\\n\\n            @Override\\n            public int compare(Pair o1, Pair o2) {\\n                return o1.query - o2.query;\\n            }\\n\\n        });\\n\\n\\n        PriorityQueue < int[] > pQueue = new PriorityQueue < > ((c, d) - > d[1] - c[1]);\\n\\n        int j = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            int curr = a.get(i).query;\\n            while (j < n && mat[j][0] <= curr) {\\n                pQueue.add(new int[] {\\n                    mat[j][0], mat[j][1]\\n                });\\n                j++;\\n            }\\n            if (pQueue.size() > 0) res[a.get(i).index] = pQueue.peek()[1];\\n        }\\n\\n        return res;\\n    }\\n\\n\\n    static class Pair {\\n        int query;\\n        int index;\\n        public Pair(int query, int index) {\\n            super();\\n            this.query = query;\\n            this.index = index;\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575963,
                "title": "java-treemap-easy-to-understand",
                "content": "Sorting on the basis of price. Next, we insert the corresponding maximum beauty for that price into our map. Lastly, we iterate and find the price (queries[i]) in our map, if not present, then the `lowerKey` which is the next smaller entry in the map.\\n```\\nclass Solution\\n{\\n    public int[] maximumBeauty(int[][] items, int[] queries)\\n    {\\n        Arrays.sort(items, Comparator.comparingDouble(o -> o[0]));\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int max = 0;\\n        for(int i = 0; i < items.length; i++)\\n        {\\n            if(items[i][1] > max)\\n                max = items[i][1];\\n            map.put(items[i][0],max);\\n        }\\n        for(int i = 0; i < queries.length; i++)\\n        {\\n            if(map.containsKey(queries[i]))\\n                queries[i] = map.get(queries[i]);\\n            else\\n            {\\n                if(map.lowerKey(queries[i]) != null)\\n                    queries[i] = map.get(map.lowerKey(queries[i]));\\n                else\\n                    queries[i] = 0;\\n            }\\n        }\\n        return queries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int[] maximumBeauty(int[][] items, int[] queries)\\n    {\\n        Arrays.sort(items, Comparator.comparingDouble(o -> o[0]));\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int max = 0;\\n        for(int i = 0; i < items.length; i++)\\n        {\\n            if(items[i][1] > max)\\n                max = items[i][1];\\n            map.put(items[i][0],max);\\n        }\\n        for(int i = 0; i < queries.length; i++)\\n        {\\n            if(map.containsKey(queries[i]))\\n                queries[i] = map.get(queries[i]);\\n            else\\n            {\\n                if(map.lowerKey(queries[i]) != null)\\n                    queries[i] = map.get(map.lowerKey(queries[i]));\\n                else\\n                    queries[i] = 0;\\n            }\\n        }\\n        return queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575961,
                "title": "c-solution-clear-easy-to-understand",
                "content": "```cpp\\n#define ff first\\n#define ss second\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) \\n        {\\n        map<int,int> m;\\n        vector<int> vect;\\n        for(int i=0; i<items.size(); i++)\\n        {\\n            int price = items[i][0];\\n            int beauty = items[i][1];\\n            if(m.find(price)==m.end())\\n            {\\n                vect.push_back(price);\\n                m[price] = beauty;\\n            }\\n            int temp = m[price];\\n            m[price] = max(temp, beauty);\\n        }\\n        vector<pair<int,int>> temp;\\n        for(auto itr = m.begin(); itr!=m.end(); itr++)\\n        {\\n            temp.push_back({itr->ff, itr->ss});\\n        }\\n        for(int i=1; i<temp.size(); i++)\\n        {\\n            temp[i].ss = max(temp[i].ss, temp[i-1].ss);\\n            m[temp[i].ff] = temp[i].ss;\\n        }\\n        if(vect.size()>1) sort(vect.begin(), vect.end());\\n        vector<int> ans;\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            int a1 = upper_bound(vect.begin(), vect.end(), queries[i]) - vect.begin() - 1;\\n            if(a1==-1) ans.push_back(0);\\n            else ans.push_back(m[vect[a1]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n#define ff first\\n#define ss second\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) \\n        {\\n        map<int,int> m;\\n        vector<int> vect;\\n        for(int i=0; i<items.size(); i++)\\n        {\\n            int price = items[i][0];\\n            int beauty = items[i][1];\\n            if(m.find(price)==m.end())\\n            {\\n                vect.push_back(price);\\n                m[price] = beauty;\\n            }\\n            int temp = m[price];\\n            m[price] = max(temp, beauty);\\n        }\\n        vector<pair<int,int>> temp;\\n        for(auto itr = m.begin(); itr!=m.end(); itr++)\\n        {\\n            temp.push_back({itr->ff, itr->ss});\\n        }\\n        for(int i=1; i<temp.size(); i++)\\n        {\\n            temp[i].ss = max(temp[i].ss, temp[i-1].ss);\\n            m[temp[i].ff] = temp[i].ss;\\n        }\\n        if(vect.size()>1) sort(vect.begin(), vect.end());\\n        vector<int> ans;\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            int a1 = upper_bound(vect.begin(), vect.end(), queries[i]) - vect.begin() - 1;\\n            if(a1==-1) ans.push_back(0);\\n            else ans.push_back(m[vect[a1]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575950,
                "title": "help-needed-gives-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comparator(vector<int>&a,vector<int>&b){\\n        if(a[0]<b[0])\\n            return true;\\n        if(a[0]==b[0])\\n            return a[1]<b[1];\\n        return false;\\n    }\\n    \\n    int binSearch(vector<pair<int,int>>arr,int size,int tar){\\n        \\n            int l=-1;\\n            int r=size;\\n            \\n            if(arr[0].first>tar)\\n                return -1;\\n        \\n            if(arr[size-1].first<tar)\\n                return size-1;\\n        \\n            while(l+1<r){\\n                int mid=(l+r)/2;\\n                \\n                if(arr[mid].first<=tar)\\n                    l=mid;\\n                else r=mid;\\n                \\n            }\\n        \\n        return l;\\n        \\n    }\\n    \\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        \\n        sort(items.begin(),items.end(),comparator);\\n        \\n        vector<pair<int,int>>arr;\\n        int maxi=-1;\\n        \\n        int i=0;\\n        int size=items.size();\\n        \\n        while(i<size){\\n            maxi=max(maxi,items[i][1]);\\n            arr.push_back({items[i][0],maxi});\\n            i++;\\n        }\\n        \\n        vector<int>ans;\\n        \\n        for(auto every:queries){\\n            \\n            int ind=binSearch(arr,size,every);\\n            if(ind==-1){\\n                ans.push_back(0);\\n            }\\n            else{\\n                ans.push_back(arr[ind].second);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comparator(vector<int>&a,vector<int>&b){\\n        if(a[0]<b[0])\\n            return true;\\n        if(a[0]==b[0])\\n            return a[1]<b[1];\\n        return false;\\n    }\\n    \\n    int binSearch(vector<pair<int,int>>arr,int size,int tar){\\n        \\n            int l=-1;\\n            int r=size;\\n            \\n            if(arr[0].first>tar)\\n                return -1;\\n        \\n            if(arr[size-1].first<tar)\\n                return size-1;\\n        \\n            while(l+1<r){\\n                int mid=(l+r)/2;\\n                \\n                if(arr[mid].first<=tar)\\n                    l=mid;\\n                else r=mid;\\n                \\n            }\\n        \\n        return l;\\n        \\n    }\\n    \\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        \\n        sort(items.begin(),items.end(),comparator);\\n        \\n        vector<pair<int,int>>arr;\\n        int maxi=-1;\\n        \\n        int i=0;\\n        int size=items.size();\\n        \\n        while(i<size){\\n            maxi=max(maxi,items[i][1]);\\n            arr.push_back({items[i][0],maxi});\\n            i++;\\n        }\\n        \\n        vector<int>ans;\\n        \\n        for(auto every:queries){\\n            \\n            int ind=binSearch(arr,size,every);\\n            if(ind==-1){\\n                ans.push_back(0);\\n            }\\n            else{\\n                ans.push_back(arr[ind].second);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575900,
                "title": "java-simple-ac-solution-using-treemap-with-comments",
                "content": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        if (queries == null || items == null || queries.length == 0 || items.length == 0) {\\n            return queries;\\n        }\\n        \\n        int[] result = new int[queries.length];\\n\\n\\t\\t// Sort the items as per their price\\n        Arrays.sort(items, (a, b) -> a[0] - b[0]);\\n        \\n        int maxSoFar = 0;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int[] item: items) {\\n\\t\\t\\t// Calculate the max beauty encountered so far for the current price\\n            maxSoFar = Math.max(maxSoFar, item[1]);\\n            map.put(item[0], maxSoFar);\\n        }\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            Integer floorKey = map.floorKey(queries[i]);\\n\\t\\t\\t// No price less than or equal to this query was found\\n            if (floorKey == null) {\\n                result[i] = 0;\\n            } else {\\n                result[i] = map.get(floorKey);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        if (queries == null || items == null || queries.length == 0 || items.length == 0) {\\n            return queries;\\n        }\\n        \\n        int[] result = new int[queries.length];\\n\\n\\t\\t// Sort the items as per their price\\n        Arrays.sort(items, (a, b) -> a[0] - b[0]);\\n        \\n        int maxSoFar = 0;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int[] item: items) {\\n\\t\\t\\t// Calculate the max beauty encountered so far for the current price\\n            maxSoFar = Math.max(maxSoFar, item[1]);\\n            map.put(item[0], maxSoFar);\\n        }\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            Integer floorKey = map.floorKey(queries[i]);\\n\\t\\t\\t// No price less than or equal to this query was found\\n            if (floorKey == null) {\\n                result[i] = 0;\\n            } else {\\n                result[i] = map.get(floorKey);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061421,
                "title": "easy-bs-cpp",
                "content": "# Intuition\\nThe problem requires finding the maximum beauty of an item whose price is less than or equal to a given query price. To optimize the solution, we can preprocess the items array to find, for each item, the maximum beauty of items with equal or lower prices that come before it. Then, for each query, we can perform a binary search to find the item with a price less than or equal to the query price and return its maximum beauty.\\n\\n# Approach\\n1. Sort the `items` array based on the price in ascending order.\\n2. Iterate through the sorted `items` array, keeping track of the maximum beauty encountered so far.\\n3. Update the beauty value of each item in the `items` array with the maximum beauty encountered so far among items with equal or lower prices.\\n4. Initialize an empty `ans` array to store the results for each query.\\n5. For each query price `q[i]` in the `queries` array, perform a binary search to find the item with a price less than or equal to `q[i]`. Use the updated beauty values to determine the maximum beauty.\\n6. Store the maximum beauty for the current query in the `ans` array.\\n7. Finally, return the `ans` array containing the results for all queries.\\n\\n# Complexity\\n- Time complexity: \\n   - Sorting the `items` array takes O(n*log(n)) time, where n is the number of items.\\n   - The preprocessing step to update the beauty values takes O(n) time.\\n   - For each query, performing a binary search takes O(log(n)) time.\\n   - Overall, the time complexity is O(n*log(n) + m*log(n)), where m is the number of queries.\\n- Space complexity:\\n   - The space complexity is O(n) for storing the updated beauty values.\\n   - Additional space for other variables is negligible.\\n   - Overall, the space complexity is O(n).\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        // Sort the items based on price in ascending order\\n        sort(items.begin(), items.end());\\n        \\n        int maxBeauty = 0;\\n        \\n        // Preprocess to update beauty values\\n        for (int i = 0; i < items.size(); i++) {\\n            maxBeauty = max(maxBeauty, items[i][1]);\\n            items[i][1] = maxBeauty;\\n        }\\n        \\n        int n = queries.size();\\n        vector<int> ans(n, 0);\\n        \\n        // Process each query\\n        for (int i = 0; i < n; i++) {\\n            int low = 0, high = items.size() - 1;\\n            int maxItemBeauty = 0;\\n            \\n            // Binary search to find the item with price <= query price\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (items[mid][0] <= queries[i]) {\\n                    maxItemBeauty = max(maxItemBeauty, items[mid][1]);\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n            \\n            ans[i] = maxItemBeauty;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        // Sort the items based on price in ascending order\\n        sort(items.begin(), items.end());\\n        \\n        int maxBeauty = 0;\\n        \\n        // Preprocess to update beauty values\\n        for (int i = 0; i < items.size(); i++) {\\n            maxBeauty = max(maxBeauty, items[i][1]);\\n            items[i][1] = maxBeauty;\\n        }\\n        \\n        int n = queries.size();\\n        vector<int> ans(n, 0);\\n        \\n        // Process each query\\n        for (int i = 0; i < n; i++) {\\n            int low = 0, high = items.size() - 1;\\n            int maxItemBeauty = 0;\\n            \\n            // Binary search to find the item with price <= query price\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (items[mid][0] <= queries[i]) {\\n                    maxItemBeauty = max(maxItemBeauty, items[mid][1]);\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n            \\n            ans[i] = maxItemBeauty;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061007,
                "title": "easy-c-brute-force-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& item, vector<int>& queries) {\\n        int n=item.size();\\n        set<int> mset;\\n        unordered_map<int,int> st;\\n        sort(item.begin(),item.end());\\n        int maxe = item[0][1];\\n        for(int i=0;i<n;i++){\\n            maxe = max(maxe,item[i][1]);\\n            st[item[i][0]]=maxe;\\n            mset.insert(item[i][0]);\\n        }        \\n        vector<int> res;\\n        for(int i=0;i<queries.size();i++){\\n            int q = queries[i];\\n            if(!st[q]){\\n                auto it = mset.lower_bound(q);\\n                if(it!=mset.begin()) --it,q = *it;\\n            }\\n            res.push_back(st[q]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& item, vector<int>& queries) {\\n        int n=item.size();\\n        set<int> mset;\\n        unordered_map<int,int> st;\\n        sort(item.begin(),item.end());\\n        int maxe = item[0][1];\\n        for(int i=0;i<n;i++){\\n            maxe = max(maxe,item[i][1]);\\n            st[item[i][0]]=maxe;\\n            mset.insert(item[i][0]);\\n        }        \\n        vector<int> res;\\n        for(int i=0;i<queries.size();i++){\\n            int q = queries[i];\\n            if(!st[q]){\\n                auto it = mset.lower_bound(q);\\n                if(it!=mset.begin()) --it,q = *it;\\n            }\\n            res.push_back(st[q]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022800,
                "title": "easy-solution-beats-95-nnn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        int[] ans = new int[queries.length];\\n        for(int i = items.length - 2; i >= 0; i--){\\n            if(items[i][0] == items[i + 1][0]){\\n                items[i][1] = items[i + 1][1];\\n            }\\n        }\\n        int max = items[0][1];\\n        for(int i = 1; i <items.length; i++){\\n            max = Math.max(max,items[i][1]);\\n            items[i][1] = max;\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            int res = search(queries[i], items);\\n            if (res < 0){\\n                ans[i] = 0;\\n            } else {\\n                ans[i] = items[res][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int search(int res, int items[][]) {\\n        int l = 0, r = items.length - 1;\\n        if(res < items[0][0])\\n            return -1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            if(items[m][0] == res){\\n                return m;\\n            }\\n            if (items[m][0] < res){\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        if(items[r][0] < res)\\n            return r;\\n        else return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        int[] ans = new int[queries.length];\\n        for(int i = items.length - 2; i >= 0; i--){\\n            if(items[i][0] == items[i + 1][0]){\\n                items[i][1] = items[i + 1][1];\\n            }\\n        }\\n        int max = items[0][1];\\n        for(int i = 1; i <items.length; i++){\\n            max = Math.max(max,items[i][1]);\\n            items[i][1] = max;\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            int res = search(queries[i], items);\\n            if (res < 0){\\n                ans[i] = 0;\\n            } else {\\n                ans[i] = items[res][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int search(int res, int items[][]) {\\n        int l = 0, r = items.length - 1;\\n        if(res < items[0][0])\\n            return -1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            if(items[m][0] == res){\\n                return m;\\n            }\\n            if (items[m][0] < res){\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        if(items[r][0] < res)\\n            return r;\\n        else return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013290,
                "title": "c-python-binary-search-prefix-solution-with-explanation",
                "content": "1. sort items based on price\\n2. calculate prefix maximum beauty value up to i\\n3. traverse queries, binary search price, answer is prefix maximum value.\\ntc is O(nlogn + qlogn), sc is O(n).\\n\\n### python\\n```python\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort(key=lambda x: x[0])\\n        prefix = [0]\\n        for _, b in items:\\n            prefix.append(max(b, prefix[-1]))\\n        \\n        ans = []\\n        for p in queries:\\n            t = bisect_right(items, p, key=lambda x:x[0])\\n            ans.append(prefix[t])\\n        return ans\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end(), [](auto &x, auto &y) -> bool {return x[0] < y[0];});\\n        vector<int> prefix {0};\\n        for (auto &x: items) prefix.emplace_back(max(prefix.back(), x[1]));\\n\\n        vector<int> ans;\\n        for (int& x: queries) {\\n            int t = upper_bound(items.begin(), items.end(), x, [](int target, auto &x) {return target < x[0];}) - items.begin();\\n            ans.emplace_back(prefix[t]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort(key=lambda x: x[0])\\n        prefix = [0]\\n        for _, b in items:\\n            prefix.append(max(b, prefix[-1]))\\n        \\n        ans = []\\n        for p in queries:\\n            t = bisect_right(items, p, key=lambda x:x[0])\\n            ans.append(prefix[t])\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end(), [](auto &x, auto &y) -> bool {return x[0] < y[0];});\\n        vector<int> prefix {0};\\n        for (auto &x: items) prefix.emplace_back(max(prefix.back(), x[1]));\\n\\n        vector<int> ans;\\n        for (int& x: queries) {\\n            int t = upper_bound(items.begin(), items.end(), x, [](int target, auto &x) {return target < x[0];}) - items.begin();\\n            ans.emplace_back(prefix[t]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991793,
                "title": "most-beautiful-item-for-each-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        // Arrays.sort(items,(a,b)->Integer.compare(a[0],b[0]));\\n        // HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        // int max = 0;\\n        // for(int i=0;i<items.length;i++)\\n        // {\\n        //     max = Math.max(max,items[i][1]);\\n        //     hm.put(items[i][0],max);\\n        // }\\n        // int[] ans = new int[queries.length];\\n        // max =0;\\n        // for(int i=0;i<queries.length;i++)\\n        // {\\n        //     if(hm.containsKey(queries[i]))\\n        //     {ans[i] = hm.get(queries[i]);\\n        //     max = Math.max(max,hm.get(queries[i]));\\n        //     }\\n        //     else\\n        //     ans[i] = max;\\n        // }\\n        // return ans;\\n        int result[]=new int[queries.length];\\n        HashMap<Integer,Integer> h=new HashMap<Integer,Integer>();\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        for(int i=0;i<items.length;i++)\\n        {\\n             if(!h.containsKey(items[i][0]))\\n             {\\n                 h.put(items[i][0],items[i][1]);\\n                 l.add(items[i][0]);\\n             }\\n             else\\n             {\\n                 if(h.get(items[i][0])<items[i][1])\\n                 {\\n                     h.put(items[i][0],items[i][1]);\\n                 }\\n             }\\n        }\\n        int max=0;\\n        Collections.sort(l);\\n        int arr[]=new int[l.size()];\\n        for(int i=0;i<l.size();i++)\\n        {\\n            if(h.get(l.get(i))>max)\\n            {\\n                max=h.get(l.get(i));\\n            }\\n            arr[i]=max;\\n        }\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int low=0,high=l.size()-1;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(l.get(mid)==queries[i])\\n                {\\n                    result[i]=arr[mid];\\n                    break;\\n                }\\n                else if(l.get(mid)<queries[i])\\n                {\\n                    result[i]=arr[mid];\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    high=mid-1;\\n                }\\n\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        // Arrays.sort(items,(a,b)->Integer.compare(a[0],b[0]));\\n        // HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        // int max = 0;\\n        // for(int i=0;i<items.length;i++)\\n        // {\\n        //     max = Math.max(max,items[i][1]);\\n        //     hm.put(items[i][0],max);\\n        // }\\n        // int[] ans = new int[queries.length];\\n        // max =0;\\n        // for(int i=0;i<queries.length;i++)\\n        // {\\n        //     if(hm.containsKey(queries[i]))\\n        //     {ans[i] = hm.get(queries[i]);\\n        //     max = Math.max(max,hm.get(queries[i]));\\n        //     }\\n        //     else\\n        //     ans[i] = max;\\n        // }\\n        // return ans;\\n        int result[]=new int[queries.length];\\n        HashMap<Integer,Integer> h=new HashMap<Integer,Integer>();\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        for(int i=0;i<items.length;i++)\\n        {\\n             if(!h.containsKey(items[i][0]))\\n             {\\n                 h.put(items[i][0],items[i][1]);\\n                 l.add(items[i][0]);\\n             }\\n             else\\n             {\\n                 if(h.get(items[i][0])<items[i][1])\\n                 {\\n                     h.put(items[i][0],items[i][1]);\\n                 }\\n             }\\n        }\\n        int max=0;\\n        Collections.sort(l);\\n        int arr[]=new int[l.size()];\\n        for(int i=0;i<l.size();i++)\\n        {\\n            if(h.get(l.get(i))>max)\\n            {\\n                max=h.get(l.get(i));\\n            }\\n            arr[i]=max;\\n        }\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int low=0,high=l.size()-1;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(l.get(mid)==queries[i])\\n                {\\n                    result[i]=arr[mid];\\n                    break;\\n                }\\n                else if(l.get(mid)<queries[i])\\n                {\\n                    result[i]=arr[mid];\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    high=mid-1;\\n                }\\n\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968907,
                "title": "java-using-treemap",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < items.length; i++) map.put(items[i][0], Math.max(map.getOrDefault(items[i][0], 0), items[i][1]));\\n        TreeMap<Integer, Integer> mapSorted = new TreeMap<>();\\n        for (int key : map.keySet()) mapSorted.put(key, map.get(key));\\n        int prev = 0, c = 0;\\n        int[] arr = new int[mapSorted.size()], res = new int[queries.length];\\n        for (int key : mapSorted.keySet()) {\\n            mapSorted.put(key, Math.max(mapSorted.get(key), prev));\\n            prev = mapSorted.get(key);\\n            arr[c++] = key;\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            Integer val = mapSorted.get(queries[i]);\\n            if (val == null) {\\n                Integer higherKey = mapSorted.lowerKey(queries[i]);\\n                val = higherKey == null ? 0 : mapSorted.get(higherKey);\\n            }\\n            res[i] = val;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < items.length; i++) map.put(items[i][0], Math.max(map.getOrDefault(items[i][0], 0), items[i][1]));\\n        TreeMap<Integer, Integer> mapSorted = new TreeMap<>();\\n        for (int key : map.keySet()) mapSorted.put(key, map.get(key));\\n        int prev = 0, c = 0;\\n        int[] arr = new int[mapSorted.size()], res = new int[queries.length];\\n        for (int key : mapSorted.keySet()) {\\n            mapSorted.put(key, Math.max(mapSorted.get(key), prev));\\n            prev = mapSorted.get(key);\\n            arr[c++] = key;\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            Integer val = mapSorted.get(queries[i]);\\n            if (val == null) {\\n                Integer higherKey = mapSorted.lowerKey(queries[i]);\\n                val = higherKey == null ? 0 : mapSorted.get(higherKey);\\n            }\\n            res[i] = val;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957843,
                "title": "binary-search-easy-intuitive",
                "content": "\\n# Approach\\nsort the given array.\\nMaintain a variable for storing maximum beauty .\\nStart traversing from the o index store the beauty of each element as teh maximum beauty till now.\\nUse binary search to find the floor value of the given queries[i].\\n\\n# Complexity\\n- Time complexity:\\no(nlogn)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binary(vector<vector<int>>& items,int target)\\n    {\\n        int s=0;\\n        int e=items.size()-1;\\n        int mid=s+(e-s)/2;\\n        int ans=-1;\\n        while(s<=e)\\n        {\\n            if(items[mid][0]<=target)\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else\\n            e=mid-1;\\n            mid=s+(e-s)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n\\n        int pre=-1;\\n        for(int i=0;i<items.size();i++)\\n        {\\n            if(items[i][1]>pre)\\n            {\\n                pre=items[i][1];\\n            }\\n            else\\n            {\\n                items[i][1]=pre;\\n            }\\n        }\\n\\n        vector<int>ans;\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int k=binary(items,queries[i]);\\n            if(k==-1)\\n            ans.push_back(0);\\n            else\\n            ans.push_back(items[k][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binary(vector<vector<int>>& items,int target)\\n    {\\n        int s=0;\\n        int e=items.size()-1;\\n        int mid=s+(e-s)/2;\\n        int ans=-1;\\n        while(s<=e)\\n        {\\n            if(items[mid][0]<=target)\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else\\n            e=mid-1;\\n            mid=s+(e-s)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n\\n        int pre=-1;\\n        for(int i=0;i<items.size();i++)\\n        {\\n            if(items[i][1]>pre)\\n            {\\n                pre=items[i][1];\\n            }\\n            else\\n            {\\n                items[i][1]=pre;\\n            }\\n        }\\n\\n        vector<int>ans;\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int k=binary(items,queries[i]);\\n            if(k==-1)\\n            ans.push_back(0);\\n            else\\n            ans.push_back(items[k][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943836,
                "title": "c-easy-solution-upper-bound-sorting-well-commented",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        map<int,int> mp;\\n        int maxi=INT_MIN;\\n        sort(items.begin(),items.end());// sort according to price\\n        int n=items.size();\\n        int m=queries.size();\\n        for(int i=0;i<n;i++){\\n        //for each price in items get maximum beauty till that price\\n            maxi=max(maxi,items[i][1]);   \\n            mp[items[i][0]]=maxi;//store max beauty in map\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            //find element lesser than or equal to that price\\n           auto upper = mp.upper_bound(queries[i]);\\n           if(upper==mp.begin()) queries[i]=0;\\n           //replace queries[i] with mp[price] as it is \\n           //maximum till that price\\n           else queries[i]=(--upper)->second;\\n        }\\n\\n        return queries;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        map<int,int> mp;\\n        int maxi=INT_MIN;\\n        sort(items.begin(),items.end());// sort according to price\\n        int n=items.size();\\n        int m=queries.size();\\n        for(int i=0;i<n;i++){\\n        //for each price in items get maximum beauty till that price\\n            maxi=max(maxi,items[i][1]);   \\n            mp[items[i][0]]=maxi;//store max beauty in map\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            //find element lesser than or equal to that price\\n           auto upper = mp.upper_bound(queries[i]);\\n           if(upper==mp.begin()) queries[i]=0;\\n           //replace queries[i] with mp[price] as it is \\n           //maximum till that price\\n           else queries[i]=(--upper)->second;\\n        }\\n\\n        return queries;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923362,
                "title": "c-sorting-binary-search-solution-clean-and-concise",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn + mlogm + mlog(vec.size()))\\n\\n- Space complexity:\\nO(m+n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int findindex(int num, vector<int>& vec){ //binary search to appropriate index for num\\n\\n        int l=0; int h = vec.size()-1;\\n        while(l<=h){\\n            int m = l + (h-l)/2;\\n\\n            if(vec[m]==num) return m;\\n            else if(vec[m]<num){\\n                l=m+1;\\n            }\\n            else h = m-1;\\n        }\\n\\n        return l;\\n    }\\n\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& q) {\\n        \\n        int n = items.size();\\n        int m = q.size();\\n        vector<int> ans(m,0);\\n\\n        sort(items.begin(), items.end());\\n        unordered_map<int,int> mp;\\n\\n        int maxi = -1; //maximum beauty\\n        vector<int> vec;\\n\\n        for(int i=0; i<n; i++){\\n            maxi = max(maxi, items[i][1]); //saving maxbeauty for a price\\n            //cout<<maxi<<\" \"; //debug\\n            mp[items[i][0]] = maxi;\\n        }\\n\\n        for(auto it: mp){\\n            vec.push_back(it.first);\\n        }\\n\\n        sort(vec.begin(), vec.end());\\n        for(int i=0; i<vec.size(); i++) cout<<vec[i]<<\" \"; //debug\\n\\n        for(int i=0; i<m; i++){ //parsing the query\\n\\n            if( mp.find(q[i])!=mp.end() ){\\n                ans[i] = mp[q[i]];\\n            }\\n            else{ // if q[i], not originally in map then we find its apt postion in vec\\n                int x = findindex(q[i], vec);\\n                if(x==0) ans[i]=0;\\n                else ans[i] = mp[vec[x-1]]; \\n            }\\n        }\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findindex(int num, vector<int>& vec){ //binary search to appropriate index for num\\n\\n        int l=0; int h = vec.size()-1;\\n        while(l<=h){\\n            int m = l + (h-l)/2;\\n\\n            if(vec[m]==num) return m;\\n            else if(vec[m]<num){\\n                l=m+1;\\n            }\\n            else h = m-1;\\n        }\\n\\n        return l;\\n    }\\n\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& q) {\\n        \\n        int n = items.size();\\n        int m = q.size();\\n        vector<int> ans(m,0);\\n\\n        sort(items.begin(), items.end());\\n        unordered_map<int,int> mp;\\n\\n        int maxi = -1; //maximum beauty\\n        vector<int> vec;\\n\\n        for(int i=0; i<n; i++){\\n            maxi = max(maxi, items[i][1]); //saving maxbeauty for a price\\n            //cout<<maxi<<\" \"; //debug\\n            mp[items[i][0]] = maxi;\\n        }\\n\\n        for(auto it: mp){\\n            vec.push_back(it.first);\\n        }\\n\\n        sort(vec.begin(), vec.end());\\n        for(int i=0; i<vec.size(); i++) cout<<vec[i]<<\" \"; //debug\\n\\n        for(int i=0; i<m; i++){ //parsing the query\\n\\n            if( mp.find(q[i])!=mp.end() ){\\n                ans[i] = mp[q[i]];\\n            }\\n            else{ // if q[i], not originally in map then we find its apt postion in vec\\n                int x = findindex(q[i], vec);\\n                if(x==0) ans[i]=0;\\n                else ans[i] = mp[vec[x-1]]; \\n            }\\n        }\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3904378,
                "title": "short-c-map-upper-bound",
                "content": "# Approach\\nUse map to store maximum beauty sorted by price.\\n\\nWith first iteration, we build a map with maximum beauty per price.\\nWith second iteration, we go with ascending price, and updating the beauty with the highest beauty seen so far.\\nFinally, we iterate through queries to find first entry with a higher price, and return an entry before.\\nIf the higher price is at the beginning of the map, it means there are no \"affordable\" items, and the result for this query is 0. Otherwise return beauty for the previous element (also applies if no item with higher price was found and `it == items_map.end()`).\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        map<int, int> items_map;\\n\\n        for (const auto &vec : items) {\\n            items_map[vec[0]] = max(items_map[vec[0]], vec[1]);\\n        }\\n\\n        int prev_max = 0;\\n        for (auto &[price, beauty] : items_map) {\\n            if (beauty >= prev_max) {\\n                prev_max = beauty;\\n            } else {\\n                beauty = prev_max;\\n            }\\n        }\\n\\n        for (int &q : queries) {\\n            auto it = items_map.upper_bound(q);\\n            if (it == items_map.begin()) {\\n                q = 0;\\n            } else {\\n                q = (--it)->second;\\n            }\\n        }\\n\\n        return queries;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        map<int, int> items_map;\\n\\n        for (const auto &vec : items) {\\n            items_map[vec[0]] = max(items_map[vec[0]], vec[1]);\\n        }\\n\\n        int prev_max = 0;\\n        for (auto &[price, beauty] : items_map) {\\n            if (beauty >= prev_max) {\\n                prev_max = beauty;\\n            } else {\\n                beauty = prev_max;\\n            }\\n        }\\n\\n        for (int &q : queries) {\\n            auto it = items_map.upper_bound(q);\\n            if (it == items_map.begin()) {\\n                q = 0;\\n            } else {\\n                q = (--it)->second;\\n            }\\n        }\\n\\n        return queries;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874580,
                "title": "fastest-solution-using-numpy",
                "content": "# Complexity\\n- Time complexity: $O((n+m)\\\\log n)$, where $n$ is the length of `items` and $m$ is the length of `queries`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n+m)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        # add extra entry to handle queries that are too small\\n        items = [[0,0]] + items\\n        \\n        # create NumPy arrays\\n        items = np.array(items)\\n        queries = np.array(queries)\\n\\n        # sort items by price\\n        items = items[items[:,0].argsort()]\\n\\n        # prefix-max the beauty scores\\n        np.maximum.accumulate(items[:,1], out=items[:,1])\\n\\n        # binary search\\n        i = np.searchsorted(items[:,0], queries, side=\\'right\\')\\n        return items[i-1, 1].tolist()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        # add extra entry to handle queries that are too small\\n        items = [[0,0]] + items\\n        \\n        # create NumPy arrays\\n        items = np.array(items)\\n        queries = np.array(queries)\\n\\n        # sort items by price\\n        items = items[items[:,0].argsort()]\\n\\n        # prefix-max the beauty scores\\n        np.maximum.accumulate(items[:,1], out=items[:,1])\\n\\n        # binary search\\n        i = np.searchsorted(items[:,0], queries, side=\\'right\\')\\n        return items[i-1, 1].tolist()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786903,
                "title": "once-again-share-my-sorting-solution",
                "content": "# Intuition\\n\\nBrute force is O(n^3).\\nBut if we sort the arrays by price (both query and price array), then we make brute force solution into O(n log n). So do that instead.\\n\\n# Approach\\n\\n1. Sort the price array.\\n2. Sort the queries array (but keep original index also).\\n3. For each query, do binary search in price array to find the max.\\n4. Return the solution\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\n\\nO(n) extra space\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] nums, int[] queries) {\\n\\n        Arrays.sort(nums, (a, b) -> Integer.compare(a[0], b[0]));\\n        int[][] queryIndex = new int[queries.length][2];\\n        for (int i=0; i<queries.length; i++) {\\n            queryIndex[i] = new int[]{queries[i], i};\\n        }\\n\\n        Arrays.sort(queryIndex, (a, b) -> Integer.compare(a[0], b[0]));\\n        int n = nums.length;\\n        int[] b = new int[n];\\n        b[0] = nums[0][1];\\n        int[] ans = new int[queries.length];\\n\\n        for (int i=1; i<n; i++)\\n            b[i] = Math.max(nums[i][1], b[i-1]);\\n\\n        for (int i=0; i<queryIndex.length; i++) {\\n            int q = queryIndex[i][0];\\n\\n            int index = binarySearch(nums, q);\\n            if (index != -1 && index < n) {\\n                ans[queryIndex[i][1]] = b[index];        \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int binarySearch(int[][] nums, int target) {\\n        int l=0, r=nums.length-1;\\n        int sol = -1;\\n\\n        while (l<=r) {\\n            int mid = (l+r)/2;\\n            if (nums[mid][0] == target) {\\n                sol = mid;\\n                l = mid+1;\\n            }\\n            if (nums[mid][0] > target) {\\n                r = mid-1;\\n            } else {\\n                sol = mid;\\n                l = mid+1;\\n            }\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] nums, int[] queries) {\\n\\n        Arrays.sort(nums, (a, b) -> Integer.compare(a[0], b[0]));\\n        int[][] queryIndex = new int[queries.length][2];\\n        for (int i=0; i<queries.length; i++) {\\n            queryIndex[i] = new int[]{queries[i], i};\\n        }\\n\\n        Arrays.sort(queryIndex, (a, b) -> Integer.compare(a[0], b[0]));\\n        int n = nums.length;\\n        int[] b = new int[n];\\n        b[0] = nums[0][1];\\n        int[] ans = new int[queries.length];\\n\\n        for (int i=1; i<n; i++)\\n            b[i] = Math.max(nums[i][1], b[i-1]);\\n\\n        for (int i=0; i<queryIndex.length; i++) {\\n            int q = queryIndex[i][0];\\n\\n            int index = binarySearch(nums, q);\\n            if (index != -1 && index < n) {\\n                ans[queryIndex[i][1]] = b[index];        \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int binarySearch(int[][] nums, int target) {\\n        int l=0, r=nums.length-1;\\n        int sol = -1;\\n\\n        while (l<=r) {\\n            int mid = (l+r)/2;\\n            if (nums[mid][0] == target) {\\n                sol = mid;\\n                l = mid+1;\\n            }\\n            if (nums[mid][0] > target) {\\n                r = mid-1;\\n            } else {\\n                sol = mid;\\n                l = mid+1;\\n            }\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778280,
                "title": "easy-c-sol",
                "content": "\\n# Approach\\nSort items vector and stores prices in one vector and beauty in another vector.\\nfor beauty vector use beauty[i]=max(beauty[i-1],items[i][1]);\\nuse upper bound to find the index of given query.\\nstore that beauty[index] in your ans array\\n\\n# Complexity\\n- Time complexity:\\n $$O(NlogN)$$\\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        int n=items.size();\\n        vector<int>prices(n,0);\\n        for(int i=0;i<n;i++)prices[i]=items[i][0];\\n        // for(auto it:prices)cout<<it<<\" \";\\n        // cout<<endl;\\n        vector<int>pref(n,0);\\n        pref[0]=items[0][1];\\n        for(int i=1;i<n;i++)\\n        {\\n            pref[i]=max(items[i][1],pref[i-1]);\\n        }\\n        // for(auto it:pref)cout<<it<<\" \";\\n        // cout<<endl;\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n           int ind=upper_bound(prices.begin(),prices.end(),queries[i])-prices.begin();\\n           if(ind==0)ans.push_back(0);\\n           else ans.push_back(pref[ind-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Brainteaser",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        int n=items.size();\\n        vector<int>prices(n,0);\\n        for(int i=0;i<n;i++)prices[i]=items[i][0];\\n        // for(auto it:prices)cout<<it<<\" \";\\n        // cout<<endl;\\n        vector<int>pref(n,0);\\n        pref[0]=items[0][1];\\n        for(int i=1;i<n;i++)\\n        {\\n            pref[i]=max(items[i][1],pref[i-1]);\\n        }\\n        // for(auto it:pref)cout<<it<<\" \";\\n        // cout<<endl;\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n           int ind=upper_bound(prices.begin(),prices.end(),queries[i])-prices.begin();\\n           if(ind==0)ans.push_back(0);\\n           else ans.push_back(pref[ind-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3769555,
                "title": "simple-s-rting-binary-search-approch-in-c",
                "content": "## Intution :\\n* ####  we need to change the value of beauty for every  items with maximum beauty upto we have among all items whose prices is less then the current item price , so during binary searching we will be able to find max beauty . \\n## Approach :\\n* #### sort the items array in increasing order based on prices , if two items have same prices sort them in decreasing order based on their beauty \\n* #### then update items with maximum beauty till we have \\n* #### then simply apply binary search for each querie\\n\\n## Complexity :\\n### Time Complexity : O(max(N,M)*logN) , N = Items.size() , M =queries.size()\\n### Space Complexity : O(1)\\n```\\nclass Solution {\\n    static bool compare(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[0]<b[0]) return true;\\n        else if(a[0] == b[0]) a[1]>=b[1];\\n        return false;\\n    }\\n    \\n    int search(int num,vector<vector<int>> &arr)\\n    {\\n        int n = arr.size();\\n        int l=0;\\n        int h = n-1;\\n        int ans = 0;\\n        while(l<=h)\\n        {\\n            int mid = l+(h-l)/2;\\n            if(arr[mid][0]<=num)\\n            {\\n                ans = arr[mid][1];\\n                l = mid+1;\\n            }else{\\n                h = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m);\\n\\t\\t\\n        sort(items.begin(),items.end(),compare);\\n \\n        int max_beauty = 0;\\n        for(int i=0;i<items.size();i++)\\n        {\\n            max_beauty = max(max_beauty,items[i][1]);\\n            items[i][1] = max_beauty;\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            ans[i] = search(queries[i],items);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    static bool compare(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[0]<b[0]) return true;\\n        else if(a[0] == b[0]) a[1]>=b[1];\\n        return false;\\n    }\\n    \\n    int search(int num,vector<vector<int>> &arr)\\n    {\\n        int n = arr.size();\\n        int l=0;\\n        int h = n-1;\\n        int ans = 0;\\n        while(l<=h)\\n        {\\n            int mid = l+(h-l)/2;\\n            if(arr[mid][0]<=num)\\n            {\\n                ans = arr[mid][1];\\n                l = mid+1;\\n            }else{\\n                h = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m);\\n\\t\\t\\n        sort(items.begin(),items.end(),compare);\\n \\n        int max_beauty = 0;\\n        for(int i=0;i<items.size();i++)\\n        {\\n            max_beauty = max(max_beauty,items[i][1]);\\n            items[i][1] = max_beauty;\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            ans[i] = search(queries[i],items);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762774,
                "title": "simple-sorting-binary-search-solution-in-c",
                "content": "# Intuition\\nIf we have items sorted by pricee, we just need to find the max beauty till price is less than or equal to query\\n\\n# Approach\\nFor sorting by price, we simply sort the items using a custom sort.\\nFor finding the maxPrice we simply pre compute is using prefix array method. To find the index for searching for any given query, we use binary search on the sorted items. (*I tried using upper bound / lower bound instead of coding for binary search but it did not look very intuitive, if someone can explain using those, it will be helpful.*)\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) - sorting\\nO(n) - prefixMax\\nO(mlogn) - queries+binarySearch\\ntotal = O(nlogn+mlogn)\\n\\n- Space complexity:\\nO(n) - prefixMax Array\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int myBinarySearch(vector<vector<int> > &items, int maxPrice)\\n    {\\n        int start = 0, end = items.size()-1, mid;\\n        while(start < end)\\n        {\\n            mid = start + (end-start)/2;\\n            if (items[mid][0] <= maxPrice)\\n                start = mid+1;\\n            else\\n                end = mid;\\n        }\\n        return(end);\\n    }\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end(), [](const auto &lhs, const auto &rhs)\\n        {\\n            if (lhs[0] == rhs[0])\\n                return(lhs[1] <= rhs[1]);\\n            return(lhs[0] < rhs[0]);\\n        });\\n        vector<int> prefixMax(items.size());\\n        prefixMax[0] = items[0][1];\\n        for (int i=1; i<items.size(); i++)\\n            prefixMax[i] = max(prefixMax[i-1], items[i][1]);\\n        vector<int> res;\\n        for (int &q: queries)\\n        {\\n            int idx = myBinarySearch(items, q);\\n            if (items[idx][0] <= q)\\n                res.push_back(prefixMax[idx]);\\n            else if ((idx-1) >= 0)\\n                res.push_back(prefixMax[idx-1]);\\n            else\\n                res.push_back(0);\\n        }\\n        return(res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int myBinarySearch(vector<vector<int> > &items, int maxPrice)\\n    {\\n        int start = 0, end = items.size()-1, mid;\\n        while(start < end)\\n        {\\n            mid = start + (end-start)/2;\\n            if (items[mid][0] <= maxPrice)\\n                start = mid+1;\\n            else\\n                end = mid;\\n        }\\n        return(end);\\n    }\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end(), [](const auto &lhs, const auto &rhs)\\n        {\\n            if (lhs[0] == rhs[0])\\n                return(lhs[1] <= rhs[1]);\\n            return(lhs[0] < rhs[0]);\\n        });\\n        vector<int> prefixMax(items.size());\\n        prefixMax[0] = items[0][1];\\n        for (int i=1; i<items.size(); i++)\\n            prefixMax[i] = max(prefixMax[i-1], items[i][1]);\\n        vector<int> res;\\n        for (int &q: queries)\\n        {\\n            int idx = myBinarySearch(items, q);\\n            if (items[idx][0] <= q)\\n                res.push_back(prefixMax[idx]);\\n            else if ((idx-1) >= 0)\\n                res.push_back(prefixMax[idx-1]);\\n            else\\n                res.push_back(0);\\n        }\\n        return(res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730005,
                "title": "sort-lower-bound-store-max-beauty-as-you-go-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end(),[&](const auto &a,const auto &b){\\n            if(a[0]==b[0]) return a[1]>b[1];\\n            return a[0]<b[0];\\n        });\\n        vector<int> ans;\\n        vector<int> storeBeauty;\\n        int maxi = INT_MIN;\\n        for(int i=0;i<items.size();i++){\\n            maxi = max(maxi,items[i][1]);\\n            storeBeauty.push_back(maxi);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            auto it = lower_bound(items.begin(),items.end(),queries[i],[&](const auto &a,int b){\\n                return a[0] < b;\\n            });\\n            int idx = it - items.begin();\\n            if(idx==items.size()){\\n               ans.push_back(maxi);\\n               continue;\\n            }\\n            if(idx==0){\\n               if(items[0][0]<=queries[i]){\\n                  ans.push_back(items[0][1]); continue;\\n               }else\\n               ans.push_back(0); continue;\\n            }\\n            if(queries[i]!= items[idx][0]) ans.push_back(storeBeauty[idx-1]);\\n            else ans.push_back(storeBeauty[idx]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end(),[&](const auto &a,const auto &b){\\n            if(a[0]==b[0]) return a[1]>b[1];\\n            return a[0]<b[0];\\n        });\\n        vector<int> ans;\\n        vector<int> storeBeauty;\\n        int maxi = INT_MIN;\\n        for(int i=0;i<items.size();i++){\\n            maxi = max(maxi,items[i][1]);\\n            storeBeauty.push_back(maxi);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            auto it = lower_bound(items.begin(),items.end(),queries[i],[&](const auto &a,int b){\\n                return a[0] < b;\\n            });\\n            int idx = it - items.begin();\\n            if(idx==items.size()){\\n               ans.push_back(maxi);\\n               continue;\\n            }\\n            if(idx==0){\\n               if(items[0][0]<=queries[i]){\\n                  ans.push_back(items[0][1]); continue;\\n               }else\\n               ans.push_back(0); continue;\\n            }\\n            if(queries[i]!= items[idx][0]) ans.push_back(storeBeauty[idx-1]);\\n            else ans.push_back(storeBeauty[idx]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717283,
                "title": "easy-solution-binary-search-time-complexity-o-nlog-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfirst sort items array by price then items[i][1] each of index i find the maximum number becoming i=0 to i and the asing it items[i][1] after doing these we will each quirey and find it in items array in price where items[i+1][0]>items[i][0]\\n\\n# Complexity\\n# Time complexity:O(Nlog(N))\\n\\n# Space complexity: O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        vector<int>ans;\\n        int max=0;\\n        for(int i=0;i<items.size();i++)\\n        {\\n            if(max<items[i][1])\\n              max=items[i][1];\\n            items[i][1]=max;\\n        }\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int t=queries[i];\\n            int l=0,h=items.size()-1,mid=0;\\n            while(l<=h)\\n            {\\n                 mid=(l+h)/2;\\n                 if(t>=items[mid][0]&&(items.size()==mid+1||t<items[mid+1][0]))\\n                 {  \\n                    ans.push_back(items[mid][1]);\\n                     break;\\n                 }\\n                 if(t<items[mid][0])\\n                 {\\n                     h=mid-1;\\n                 }\\n                 else\\n                 {\\n                     l=mid+1;\\n                 }\\n            }\\n            if(l>h)\\n            ans.push_back(0);\\n             \\n        }\\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        vector<int>ans;\\n        int max=0;\\n        for(int i=0;i<items.size();i++)\\n        {\\n            if(max<items[i][1])\\n              max=items[i][1];\\n            items[i][1]=max;\\n        }\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int t=queries[i];\\n            int l=0,h=items.size()-1,mid=0;\\n            while(l<=h)\\n            {\\n                 mid=(l+h)/2;\\n                 if(t>=items[mid][0]&&(items.size()==mid+1||t<items[mid+1][0]))\\n                 {  \\n                    ans.push_back(items[mid][1]);\\n                     break;\\n                 }\\n                 if(t<items[mid][0])\\n                 {\\n                     h=mid-1;\\n                 }\\n                 else\\n                 {\\n                     l=mid+1;\\n                 }\\n            }\\n            if(l>h)\\n            ans.push_back(0);\\n             \\n        }\\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703373,
                "title": "c-binary-search-sorting-prefix-array",
                "content": "# Approach : Binary Search \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& que) {\\n        sort(items.begin(),items.end());\\n        int n=items.size();\\n        vector<int>pre(n,0);\\n        pre[0]=items[0][1];\\n        for(int i=1;i<n;i++){\\n            pre[i]=max(pre[i-1],items[i][1]);\\n        }\\n        auto func=[&](int q){\\n            int low=0,high=n-1;\\n            int ans=-1;\\n            while(low<=high){\\n                int mid=(low+(high-low)/2);\\n                if(items[mid][0]<=q){\\n                    ans=mid;\\n                    low=mid+1;\\n                }\\n                else high=mid-1;\\n            }\\n            if(ans==-1) return 0;\\n            return pre[ans];\\n        };\\n        vector<int>ret;\\n        for(int i=0;i<que.size();i++){\\n            ret.push_back(func(que[i]));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& que) {\\n        sort(items.begin(),items.end());\\n        int n=items.size();\\n        vector<int>pre(n,0);\\n        pre[0]=items[0][1];\\n        for(int i=1;i<n;i++){\\n            pre[i]=max(pre[i-1],items[i][1]);\\n        }\\n        auto func=[&](int q){\\n            int low=0,high=n-1;\\n            int ans=-1;\\n            while(low<=high){\\n                int mid=(low+(high-low)/2);\\n                if(items[mid][0]<=q){\\n                    ans=mid;\\n                    low=mid+1;\\n                }\\n                else high=mid-1;\\n            }\\n            if(ans==-1) return 0;\\n            return pre[ans];\\n        };\\n        vector<int>ret;\\n        for(int i=0;i<que.size();i++){\\n            ret.push_back(func(que[i]));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694282,
                "title": "c-binary-search-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& t, vector<int>& q) {\\n       vector<int> w=q;\\n        sort(t.begin(),t.end());sort(q.begin(),q.end());\\n        int mx=0;int s=0;map<int,int> p;\\n        for(auto j : q)\\n        {\\n            int i=s,e=t.size()-1;int id=s-1;\\n            while(i<=e)\\n            {\\n                  int m=(i+e)/2;\\n                  if(t[m][0]<=j)\\n                  {\\n                      id=max(id,m);\\n                      i=m+1;\\n                  }\\n                  else\\n                  e=m-1;\\n            }\\n            if(id!=s-1)\\n            {\\n              int l=INT_MIN;\\n              for(int k=s;k<=id;k++)\\n              l=max(l,t[k][1]);\\n\\n              mx=max(mx,l);\\n              p[j]=mx;\\n              s=id;\\n            }\\n            else\\n            p[j]=mx;\\n        }\\n        vector<int> v(q.size(),0);\\n        for(int i=0;i<w.size();i++)\\n        v[i]=p[w[i]];\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& t, vector<int>& q) {\\n       vector<int> w=q;\\n        sort(t.begin(),t.end());sort(q.begin(),q.end());\\n        int mx=0;int s=0;map<int,int> p;\\n        for(auto j : q)\\n        {\\n            int i=s,e=t.size()-1;int id=s-1;\\n            while(i<=e)\\n            {\\n                  int m=(i+e)/2;\\n                  if(t[m][0]<=j)\\n                  {\\n                      id=max(id,m);\\n                      i=m+1;\\n                  }\\n                  else\\n                  e=m-1;\\n            }\\n            if(id!=s-1)\\n            {\\n              int l=INT_MIN;\\n              for(int k=s;k<=id;k++)\\n              l=max(l,t[k][1]);\\n\\n              mx=max(mx,l);\\n              p[j]=mx;\\n              s=id;\\n            }\\n            else\\n            p[j]=mx;\\n        }\\n        vector<int> v(q.size(),0);\\n        for(int i=0;i<w.size();i++)\\n        v[i]=p[w[i]];\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639112,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int result[]=new int[queries.length];\\n        HashMap<Integer,Integer> h=new HashMap<Integer,Integer>();\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        for(int i=0;i<items.length;i++)\\n        {\\n             if(!h.containsKey(items[i][0]))\\n             {\\n                 h.put(items[i][0],items[i][1]);\\n                 l.add(items[i][0]);\\n             }\\n             else\\n             {\\n                 if(h.get(items[i][0])<items[i][1])\\n                 {\\n                     h.put(items[i][0],items[i][1]);\\n                 }\\n             }\\n        }\\n        int max=0;\\n        Collections.sort(l);\\n        int arr[]=new int[l.size()];\\n        for(int i=0;i<l.size();i++)\\n        {\\n            if(h.get(l.get(i))>max)\\n            {\\n                max=h.get(l.get(i));\\n            }\\n            arr[i]=max;\\n        }\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int low=0,high=l.size()-1;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(l.get(mid)==queries[i])\\n                {\\n                    result[i]=arr[mid];\\n                    break;\\n                }\\n                else if(l.get(mid)<queries[i])\\n                {\\n                    result[i]=arr[mid];\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    high=mid-1;\\n                }\\n\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int result[]=new int[queries.length];\\n        HashMap<Integer,Integer> h=new HashMap<Integer,Integer>();\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        for(int i=0;i<items.length;i++)\\n        {\\n             if(!h.containsKey(items[i][0]))\\n             {\\n                 h.put(items[i][0],items[i][1]);\\n                 l.add(items[i][0]);\\n             }\\n             else\\n             {\\n                 if(h.get(items[i][0])<items[i][1])\\n                 {\\n                     h.put(items[i][0],items[i][1]);\\n                 }\\n             }\\n        }\\n        int max=0;\\n        Collections.sort(l);\\n        int arr[]=new int[l.size()];\\n        for(int i=0;i<l.size();i++)\\n        {\\n            if(h.get(l.get(i))>max)\\n            {\\n                max=h.get(l.get(i));\\n            }\\n            arr[i]=max;\\n        }\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int low=0,high=l.size()-1;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(l.get(mid)==queries[i])\\n                {\\n                    result[i]=arr[mid];\\n                    break;\\n                }\\n                else if(l.get(mid)<queries[i])\\n                {\\n                    result[i]=arr[mid];\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    high=mid-1;\\n                }\\n\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626190,
                "title": "fast-and-easy-upper-bound-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we can consider items smaller than current item, so we can make vector which stores largest value we encounter till now or till current item, at last use lower or upper bound as per preference to find beauty corresponds to item. \\n\\n# Complexity\\n- Time complexity: $$O(nlogn + qlogn)$$ , first for sorting and second for each query we need to find corresponding item.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n=items.size();\\n        sort(items.begin(),items.end());\\n        vector<int> item(n),val(n);\\n        int mi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            item[i]=items[i][0];\\n            if(mi<items[i][1])\\n                mi=items[i][1];\\n            val[i]=mi;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int itr=upper_bound(item.begin(),item.end(),queries[i])-item.begin();\\n            itr-=1;\\n            if(itr==-1)\\n                ans.emplace_back(0);\\n            else \\n                ans.emplace_back(val[itr]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n=items.size();\\n        sort(items.begin(),items.end());\\n        vector<int> item(n),val(n);\\n        int mi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            item[i]=items[i][0];\\n            if(mi<items[i][1])\\n                mi=items[i][1];\\n            val[i]=mi;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int itr=upper_bound(item.begin(),item.end(),queries[i])-item.begin();\\n            itr-=1;\\n            if(itr==-1)\\n                ans.emplace_back(0);\\n            else \\n                ans.emplace_back(val[itr]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624299,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n  vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n    int maxBeauty = -1;\\n    vector<int> prices;\\n    unordered_map<int, int> maxBeautyForPrice;\\n    for (auto& item : items) {\\n      prices.push_back(item[0]);\\n      maxBeautyForPrice[item[0]] = max(maxBeautyForPrice[item[0]], item[1]);\\n    }\\n    sort(prices.begin(), prices.end());\\n    int maxSoFar = 0;\\n    for (int i = 0; i < prices.size(); ++i) {\\n      maxSoFar = max(maxSoFar, maxBeautyForPrice[prices[i]]);\\n      maxBeautyForPrice[prices[i]] = maxSoFar;\\n    }\\n    vector<int> ans;\\n    for (int qr : queries) {\\n      auto it = upper_bound(prices.begin(), prices.end(), qr);\\n      if (it == prices.begin()) {\\n        ans.push_back(0);\\n      } else {\\n        ans.push_back(maxBeautyForPrice[(*--it)]);\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n    int maxBeauty = -1;\\n    vector<int> prices;\\n    unordered_map<int, int> maxBeautyForPrice;\\n    for (auto& item : items) {\\n      prices.push_back(item[0]);\\n      maxBeautyForPrice[item[0]] = max(maxBeautyForPrice[item[0]], item[1]);\\n    }\\n    sort(prices.begin(), prices.end());\\n    int maxSoFar = 0;\\n    for (int i = 0; i < prices.size(); ++i) {\\n      maxSoFar = max(maxSoFar, maxBeautyForPrice[prices[i]]);\\n      maxBeautyForPrice[prices[i]] = maxSoFar;\\n    }\\n    vector<int> ans;\\n    for (int qr : queries) {\\n      auto it = upper_bound(prices.begin(), prices.end(), qr);\\n      if (it == prices.begin()) {\\n        ans.push_back(0);\\n      } else {\\n        ans.push_back(maxBeautyForPrice[(*--it)]);\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621742,
                "title": "java-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items,new CustomComparator());\\n        int ans[] = new int[queries.length];\\n        int max[] = new int[items.length];\\n        int maxTillNow = items[0][1];\\n        for(int i=0;i<items.length;i++){\\n            maxTillNow = Math.max(maxTillNow,items[i][1]);\\n            max[i] = maxTillNow;            \\n        }\\n        for(int i=0;i<queries.length;i++){\\n            if(queries[i]<items[0][0]){\\n                ans[i] = 0;\\n                continue;\\n            }\\n            int index = search(items,0,items.length-1,queries[i]);            \\n            ans[i] = max[index];\\n        }\\n        return ans;\\n    }\\n\\n    public int search(int[][] items,int start,int end,int val){                    \\n        if(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(val >= items[mid][0]){\\n                return search(items,mid+1,end,val);\\n            }else{\\n                return search(items,start,mid-1,val);\\n            }\\n        }else{\\n            return end;\\n        }\\n    }\\n\\n    public class CustomComparator implements Comparator<int[]>{\\n        public int compare(int[] a,int[] b){\\n            if(a[0]!=b[0]){\\n                return a[0]-b[0];\\n            }\\n            return a[1]-b[1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items,new CustomComparator());\\n        int ans[] = new int[queries.length];\\n        int max[] = new int[items.length];\\n        int maxTillNow = items[0][1];\\n        for(int i=0;i<items.length;i++){\\n            maxTillNow = Math.max(maxTillNow,items[i][1]);\\n            max[i] = maxTillNow;            \\n        }\\n        for(int i=0;i<queries.length;i++){\\n            if(queries[i]<items[0][0]){\\n                ans[i] = 0;\\n                continue;\\n            }\\n            int index = search(items,0,items.length-1,queries[i]);            \\n            ans[i] = max[index];\\n        }\\n        return ans;\\n    }\\n\\n    public int search(int[][] items,int start,int end,int val){                    \\n        if(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(val >= items[mid][0]){\\n                return search(items,mid+1,end,val);\\n            }else{\\n                return search(items,start,mid-1,val);\\n            }\\n        }else{\\n            return end;\\n        }\\n    }\\n\\n    public class CustomComparator implements Comparator<int[]>{\\n        public int compare(int[] a,int[] b){\\n            if(a[0]!=b[0]){\\n                return a[0]-b[0];\\n            }\\n            return a[1]-b[1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621741,
                "title": "java-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items,new CustomComparator());\\n        int ans[] = new int[queries.length];\\n        int max[] = new int[items.length];\\n        int maxTillNow = items[0][1];\\n        for(int i=0;i<items.length;i++){\\n            maxTillNow = Math.max(maxTillNow,items[i][1]);\\n            max[i] = maxTillNow;            \\n        }\\n        for(int i=0;i<queries.length;i++){\\n            if(queries[i]<items[0][0]){\\n                ans[i] = 0;\\n                continue;\\n            }\\n            int index = search(items,0,items.length-1,queries[i]);            \\n            ans[i] = max[index];\\n        }\\n        return ans;\\n    }\\n\\n    public int search(int[][] items,int start,int end,int val){                    \\n        if(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(val >= items[mid][0]){\\n                return search(items,mid+1,end,val);\\n            }else{\\n                return search(items,start,mid-1,val);\\n            }\\n        }else{\\n            return end;\\n        }\\n    }\\n\\n    public class CustomComparator implements Comparator<int[]>{\\n        public int compare(int[] a,int[] b){\\n            if(a[0]!=b[0]){\\n                return a[0]-b[0];\\n            }\\n            return a[1]-b[1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items,new CustomComparator());\\n        int ans[] = new int[queries.length];\\n        int max[] = new int[items.length];\\n        int maxTillNow = items[0][1];\\n        for(int i=0;i<items.length;i++){\\n            maxTillNow = Math.max(maxTillNow,items[i][1]);\\n            max[i] = maxTillNow;            \\n        }\\n        for(int i=0;i<queries.length;i++){\\n            if(queries[i]<items[0][0]){\\n                ans[i] = 0;\\n                continue;\\n            }\\n            int index = search(items,0,items.length-1,queries[i]);            \\n            ans[i] = max[index];\\n        }\\n        return ans;\\n    }\\n\\n    public int search(int[][] items,int start,int end,int val){                    \\n        if(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(val >= items[mid][0]){\\n                return search(items,mid+1,end,val);\\n            }else{\\n                return search(items,start,mid-1,val);\\n            }\\n        }else{\\n            return end;\\n        }\\n    }\\n\\n    public class CustomComparator implements Comparator<int[]>{\\n        public int compare(int[] a,int[] b){\\n            if(a[0]!=b[0]){\\n                return a[0]-b[0];\\n            }\\n            return a[1]-b[1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604394,
                "title": "binary-search-tc-o-n-logm-and-sc-o-n",
                "content": "/* here we sort the items according to prices and if prices are same then accroding to beauty in ascending order then for every queiry we do binary search o item and find the last possible index whose price is  <= queries[i] \\nBUT FOR SOME TEST CASES WHERE items are [[1,4],[3,2],[2,2],[5,6],[3,5]] and after sorting the items look like [[1,4],[2,2],[3,2],[3,5],[5,6]]  query are [2]\\n\\nthen according to above approach we get ans =2 but the ans is 4\\n\\nso to overcome this we create a vector maxi where maxi[0]=item[0][1] and after this we store maxi[i]=max(item[i][1],maxi[i-1]) \\nso this maxi array stores the maximum beauty till the index which we calculated by binary search*/\\n```\\nclass Solution {\\npublic:\\n    int binary(int price,vector<vector<int>> &items){\\n        int low=0;\\n        int high=items.size()-1;\\n        int ans=items.size();\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(items[mid][0]<=price){\\n                low=mid+1;\\n                ans=mid;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        vector<int> ans;\\n        vector<int> maxi;\\n        \\n        maxi.push_back(items[0][1]);\\n        for(int i=1; i<items.size(); i++){\\n            int temp=max(items[i][1],maxi[i-1]);\\n            maxi.push_back(temp);\\n        }\\n        for(int i=0; i<queries.size(); i++){\\n            \\n            int index=binary(queries[i],items);\\n            \\n            if(index==items.size()){\\n                ans.push_back(0);\\n            }\\n            else{\\n                ans.push_back(maxi[index]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int binary(int price,vector<vector<int>> &items){\\n        int low=0;\\n        int high=items.size()-1;\\n        int ans=items.size();\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(items[mid][0]<=price){\\n                low=mid+1;\\n                ans=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3588085,
                "title": "java-simple-solution-binary-search",
                "content": "Here the problem is to find the best beauty product under the price given by the query.\\nSo first we will sort the items list according to price.\\nAt every index storing the maximum beauty less than equal to price of that item[i] in max array.\\nFrom binary search we are going to find the index of last occurence of the item whose price is less than or equal to given query.\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items,(a,b)->(a[0]-b[0]));\\n        int[] max=new int[items.length];\\n        \\n        max[0]=items[0][1];\\n    for(int i=1;i<items.length;i++)\\n    {\\n        max[i]=Math.max(items[i][1],max[i-1]);\\n    }\\n        int []ans=new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int idx=binarySearch(items,queries[i]);\\n            if(idx!=-1)\\n            {\\n                ans[i]=max[idx];\\n            }\\n            else\\n                ans[i]=0;\\n        }\\n        return ans;\\n    }\\n    public int binarySearch(int[][] items,int query)\\n    {\\n        int l=-1;\\n        int r=items.length;\\n        while(l+1<r)\\n        {\\n            int mid=(l+r)/2;\\n            if(items[mid][0]<=query)\\n            {\\n                l=mid;\\n            }\\n            else\\n                r=mid;\\n        }\\n        return l;\\n    }\\n}\\n```\\nwhere n is items length and m is query length.\\nO((n+m)long n);\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items,(a,b)->(a[0]-b[0]));\\n        int[] max=new int[items.length];\\n        \\n        max[0]=items[0][1];\\n    for(int i=1;i<items.length;i++)\\n    {\\n        max[i]=Math.max(items[i][1],max[i-1]);\\n    }\\n        int []ans=new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int idx=binarySearch(items,queries[i]);\\n            if(idx!=-1)\\n            {\\n                ans[i]=max[idx];\\n            }\\n            else\\n                ans[i]=0;\\n        }\\n        return ans;\\n    }\\n    public int binarySearch(int[][] items,int query)\\n    {\\n        int l=-1;\\n        int r=items.length;\\n        while(l+1<r)\\n        {\\n            int mid=(l+r)/2;\\n            if(items[mid][0]<=query)\\n            {\\n                l=mid;\\n            }\\n            else\\n                r=mid;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573852,
                "title": "c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: NLogN + QLogN\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        vector<int>answer(queries.size(),0);\\n        map<int,int>mp;\\n        int maxvalue=0;\\n        sort(items.begin(),items.end());\\n        for(auto x:items){\\n            if(mp.find(x[0])==mp.end()){\\n                maxvalue=max(maxvalue,x[1]);\\n                mp[x[0]]=maxvalue;\\n            }\\n            else{\\n                mp[x[0]]=max(mp[x[0]],x[1]);\\n                maxvalue=max(maxvalue,x[1]);\\n            }\\n        }\\n        int i=0;\\n        for(auto x:queries){\\n            auto it=mp.upper_bound(x);\\n            if(it!=mp.begin())answer[i]=prev(it)->second;\\n            i++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        vector<int>answer(queries.size(),0);\\n        map<int,int>mp;\\n        int maxvalue=0;\\n        sort(items.begin(),items.end());\\n        for(auto x:items){\\n            if(mp.find(x[0])==mp.end()){\\n                maxvalue=max(maxvalue,x[1]);\\n                mp[x[0]]=maxvalue;\\n            }\\n            else{\\n                mp[x[0]]=max(mp[x[0]],x[1]);\\n                maxvalue=max(maxvalue,x[1]);\\n            }\\n        }\\n        int i=0;\\n        for(auto x:queries){\\n            auto it=mp.upper_bound(x);\\n            if(it!=mp.begin())answer[i]=prev(it)->second;\\n            i++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542035,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort both queries and items\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        table = {query:0 for query in queries}\\n        sortedQueries = queries[:]\\n        sortedQueries.sort()\\n        ptr1, ptr2 = 0, 0\\n        maxBeauty = 0\\n        while ptr1 < len(items) and ptr2 < len(sortedQueries):\\n            if items[ptr1][0]<=sortedQueries[ptr2]:\\n                maxBeauty = max(maxBeauty, items[ptr1][1])\\n                ptr1 += 1\\n            else:\\n                table[sortedQueries[ptr2]] = maxBeauty\\n                ptr2 += 1\\n        while ptr2 < len(sortedQueries):\\n            table[sortedQueries[ptr2]] = maxBeauty\\n            ptr2 += 1\\n\\n        return [table[key] for key in queries]\\n\\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        table = {query:0 for query in queries}\\n        sortedQueries = queries[:]\\n        sortedQueries.sort()\\n        ptr1, ptr2 = 0, 0\\n        maxBeauty = 0\\n        while ptr1 < len(items) and ptr2 < len(sortedQueries):\\n            if items[ptr1][0]<=sortedQueries[ptr2]:\\n                maxBeauty = max(maxBeauty, items[ptr1][1])\\n                ptr1 += 1\\n            else:\\n                table[sortedQueries[ptr2]] = maxBeauty\\n                ptr2 += 1\\n        while ptr2 < len(sortedQueries):\\n            table[sortedQueries[ptr2]] = maxBeauty\\n            ptr2 += 1\\n\\n        return [table[key] for key in queries]\\n\\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515359,
                "title": "simple-solution-using-java-streams",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every Item,\\nFilter queries with less price\\nmap to int\\nfind the max\\nelse return 0\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every Item,\\nFilter queries with less price\\nmap to int\\nfind the max\\nelse return 0\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nM X N\\nwhere M is items in query and N is the number of items\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int [] response = new int[queries.length];\\n        int count = 0;\\n        for (int i: queries) {\\n            response[count++] = Arrays.stream(items)\\n                                .filter(arr -> arr[0] <= i)\\n                                .mapToInt(arr -> arr[1])\\n                                .max()\\n                                .orElse(0);\\n        }\\n        return response;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int [] response = new int[queries.length];\\n        int count = 0;\\n        for (int i: queries) {\\n            response[count++] = Arrays.stream(items)\\n                                .filter(arr -> arr[0] <= i)\\n                                .mapToInt(arr -> arr[1])\\n                                .max()\\n                                .orElse(0);\\n        }\\n        return response;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485639,
                "title": "python3-sorting-binary-search-and-prefix-max",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        n=len(items)\\n        items.sort()\\n        ans=[]\\n        \\n        prefix=[items[0][1]]\\n        \\n        for i in range(1,n):\\n            prefix.append(max(prefix[-1],items[i][1]))\\n            \\n        \\n        for q in queries:\\n            ind=bisect_right(items,[q,inf])\\n            \\n            if ind==0:\\n                ans.append(0)\\n            else:\\n                ans.append(prefix[ind-1])\\n            \\n            \\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        n=len(items)\\n        items.sort()\\n        ans=[]\\n        \\n        prefix=[items[0][1]]\\n        \\n        for i in range(1,n):\\n            prefix.append(max(prefix[-1],items[i][1]))\\n            \\n        \\n        for q in queries:\\n            ind=bisect_right(items,[q,inf])\\n            \\n            if ind==0:\\n                ans.append(0)\\n            else:\\n                ans.append(prefix[ind-1])\\n            \\n            \\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462650,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    \\n  def maximumBeauty(items: Array[Array[Int]], queries: Array[Int]): Array[Int] = {\\n    val maps = items.map(n => (n(0), n(1))).groupBy(_._1).mapValues(n => n.map(_._2).max).toList.sortBy(_._1)\\n    val itemsSorted = ((List(0) ++ maps.map(_._1)).toArray zip maps.map(_._2).scanLeft(0) { (acc, cur) => acc max cur}).map(n => Array(n._1, n._2))\\n\\n    @annotation.tailrec\\n    def search(l: Int = 0, r: Int, target: Int): Int =\\n      if (l >= r)  l - 1\\n      else {\\n        val mid = l + (r - l) / 2\\n        if (itemsSorted(mid)(0) > target) search(l, mid, target)\\n        else search(mid + 1, r, target)\\n      }\\n    queries.map(n => itemsSorted(search(0, itemsSorted.length, n))(1))\\n}\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    \\n  def maximumBeauty(items: Array[Array[Int]], queries: Array[Int]): Array[Int] = {\\n    val maps = items.map(n => (n(0), n(1))).groupBy(_._1).mapValues(n => n.map(_._2).max).toList.sortBy(_._1)\\n    val itemsSorted = ((List(0) ++ maps.map(_._1)).toArray zip maps.map(_._2).scanLeft(0) { (acc, cur) => acc max cur}).map(n => Array(n._1, n._2))\\n\\n    @annotation.tailrec\\n    def search(l: Int = 0, r: Int, target: Int): Int =\\n      if (l >= r)  l - 1\\n      else {\\n        val mid = l + (r - l) / 2\\n        if (itemsSorted(mid)(0) > target) search(l, mid, target)\\n        else search(mid + 1, r, target)\\n      }\\n    queries.map(n => itemsSorted(search(0, itemsSorted.length, n))(1))\\n}\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3427416,
                "title": "python-runtime-1204-ms-beats-98-55-memory-73-9-mb-beats-43-48",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], que: List[int]) -> List[int]:\\n        items.sort()\\n        dic,val,res={},0,[]\\n        for i in items:\\n            val=max(val,i[1])\\n            dic[i[0]]=val\\n        values=dic.keys()\\n        mino,maxi=min(values),max(values)\\n        for i in que:\\n            if i in values:res.append(dic[i])\\n            else:\\n                if i<mino:res.append(0)\\n                else:\\n                    if i>maxi:res.append(dic[maxi])\\n                    else:\\n                        while not i in values:\\n                            i-=1\\n                        res.append(dic[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], que: List[int]) -> List[int]:\\n        items.sort()\\n        dic,val,res={},0,[]\\n        for i in items:\\n            val=max(val,i[1])\\n            dic[i[0]]=val\\n        values=dic.keys()\\n        mino,maxi=min(values),max(values)\\n        for i in que:\\n            if i in values:res.append(dic[i])\\n            else:\\n                if i<mino:res.append(0)\\n                else:\\n                    if i>maxi:res.append(dic[maxi])\\n                    else:\\n                        while not i in values:\\n                            i-=1\\n                        res.append(dic[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413353,
                "title": "c-sorting-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n = items.size();\\n        sort(items.begin(), items.end());\\n        for(int i = 1; i < n; i++) {\\n            items[i][1] = max(items[i][1], items[i - 1][1]);\\n        }\\n        vector<int> ans;\\n        for(int q: queries) {\\n            auto iter = upper_bound(items.begin(), items.end(), vector<int>{q, INT_MAX});\\n            ans.push_back(iter != items.begin()? (*prev(iter))[1]: 0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n = items.size();\\n        sort(items.begin(), items.end());\\n        for(int i = 1; i < n; i++) {\\n            items[i][1] = max(items[i][1], items[i - 1][1]);\\n        }\\n        vector<int> ans;\\n        for(int q: queries) {\\n            auto iter = upper_bound(items.begin(), items.end(), vector<int>{q, INT_MAX});\\n            ans.push_back(iter != items.begin()? (*prev(iter))[1]: 0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391688,
                "title": "binary-easy-peasy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> a, vector<int>b)\\n    {\\n        if(a[0]==b[0])\\n        return a[1]>b[1];\\n        else return a[0]<b[0];\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& q) \\n    {\\n        sort(items.begin(),items.end(),cmp);\\n        vector<int> res;\\n        int mx = items[0][1];\\n        for(int i = 1; i<items.size();i++)\\n        {\\n             mx = max(mx,items[i][1]);\\n             items[i][1] = mx;\\n        }\\n\\n      \\n        for(int i =  0 ; i<q.size();i++)\\n        {   if(q[i]<items[0][0])\\n        {\\nres.push_back(0);\\n        continue;\\n        }\\n            int l = 0 , h = items.size()-1 , mid , ans  =-1 ;\\n            while(l<=h)\\n            {\\n                mid = (l+h)/2;\\n                if(items[mid][0]<=q[i])\\n                {\\n                    ans  =mid; \\n                    l = mid +1; \\n                }\\n                else h = mid -1; \\n            }\\n            if(ans==-1)\\n            res.push_back(0);\\n            else res.push_back(items[ans][1]);\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> a, vector<int>b)\\n    {\\n        if(a[0]==b[0])\\n        return a[1]>b[1];\\n        else return a[0]<b[0];\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& q) \\n    {\\n        sort(items.begin(),items.end(),cmp);\\n        vector<int> res;\\n        int mx = items[0][1];\\n        for(int i = 1; i<items.size();i++)\\n        {\\n             mx = max(mx,items[i][1]);\\n             items[i][1] = mx;\\n        }\\n\\n      \\n        for(int i =  0 ; i<q.size();i++)\\n        {   if(q[i]<items[0][0])\\n        {\\nres.push_back(0);\\n        continue;\\n        }\\n            int l = 0 , h = items.size()-1 , mid , ans  =-1 ;\\n            while(l<=h)\\n            {\\n                mid = (l+h)/2;\\n                if(items[mid][0]<=q[i])\\n                {\\n                    ans  =mid; \\n                    l = mid +1; \\n                }\\n                else h = mid -1; \\n            }\\n            if(ans==-1)\\n            res.push_back(0);\\n            else res.push_back(items[ans][1]);\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391037,
                "title": "python-o-n-log-n-sort-and-one-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        new_queries = list(enumerate(queries))\\n        new_queries.sort(key=lambda p: p[1])\\n\\n        items.sort()\\n        i = 0\\n        cur_max = 0\\n        ans = []\\n        for index, q in new_queries:\\n            while i < len(items) and items[i][0] <= q:\\n                cur_max = max(cur_max, items[i][1])\\n                i += 1\\n\\n            ans.append([index, cur_max])\\n\\n        ans.sort()\\n        return [a[1] for a in ans]\\n\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        new_queries = list(enumerate(queries))\\n        new_queries.sort(key=lambda p: p[1])\\n\\n        items.sort()\\n        i = 0\\n        cur_max = 0\\n        ans = []\\n        for index, q in new_queries:\\n            while i < len(items) and items[i][0] <= q:\\n                cur_max = max(cur_max, items[i][1])\\n                i += 1\\n\\n            ans.append([index, cur_max])\\n\\n        ans.sort()\\n        return [a[1] for a in ans]\\n\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383054,
                "title": "java-sorting-and-binarysearch",
                "content": "# Complexity\\nm : items.length, n : queries.length\\n- Time complexity: $$O((m + n)logm)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items, (a,b) -> a[0] != b[0] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\\n\\n        int max = 0, n = items.length;\\n        for(int i = 0; i < n; i++) {\\n            max = Math.max(max, items[i][1]);\\n            items[i][1] = max;\\n        }\\n\\n        int i = 0, j = 0;\\n        int[] res = new int[queries.length];\\n        while(j < queries.length) {\\n            int lo = 0, hi = n - 1;\\n            while(lo < hi) {\\n                int mid = (lo + hi + 1) >> 1;\\n                if(items[mid][0] <= queries[j])\\n                    lo = mid;\\n                else\\n                    hi = mid - 1;\\n            }\\n            \\n            res[j] = items[lo][0] <= queries[j] ? items[lo][1] : 0;\\n            j++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items, (a,b) -> a[0] != b[0] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\\n\\n        int max = 0, n = items.length;\\n        for(int i = 0; i < n; i++) {\\n            max = Math.max(max, items[i][1]);\\n            items[i][1] = max;\\n        }\\n\\n        int i = 0, j = 0;\\n        int[] res = new int[queries.length];\\n        while(j < queries.length) {\\n            int lo = 0, hi = n - 1;\\n            while(lo < hi) {\\n                int mid = (lo + hi + 1) >> 1;\\n                if(items[mid][0] <= queries[j])\\n                    lo = mid;\\n                else\\n                    hi = mid - 1;\\n            }\\n            \\n            res[j] = items[lo][0] <= queries[j] ? items[lo][1] : 0;\\n            j++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375949,
                "title": "must-know-offline-query-method",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n=queries.size();\\n        vector<pair<int,int>>v(n);\\n        vector<int>ans(n);\\n        for(int i=0;i<queries.size();i++){\\n            v.push_back({queries[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        sort(items.begin(),items.end());\\n        int m=items.size();\\n        int i=0;\\n        int maxi=0;\\n        for(auto it:v){\\n            int maxval=it.first;\\n            int pos=it.second;\\n            while(i<items.size()  && items[i][0]<=maxval){\\n                \\n                maxi=max(maxi,items[i][1]);\\n                i++;\\n            }\\n            ans[pos]=maxi;\\n        }\\n        return ans;    \\n\\n            \\n\\n\\n       \\n\\n        \\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n=queries.size();\\n        vector<pair<int,int>>v(n);\\n        vector<int>ans(n);\\n        for(int i=0;i<queries.size();i++){\\n            v.push_back({queries[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        sort(items.begin(),items.end());\\n        int m=items.size();\\n        int i=0;\\n        int maxi=0;\\n        for(auto it:v){\\n            int maxval=it.first;\\n            int pos=it.second;\\n            while(i<items.size()  && items[i][0]<=maxval){\\n                \\n                maxi=max(maxi,items[i][1]);\\n                i++;\\n            }\\n            ans[pos]=maxi;\\n        }\\n        return ans;    \\n\\n            \\n\\n\\n       \\n\\n        \\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360454,
                "title": "easy-to-understand-treemap-using-floorkey",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items,(o1,o2)->o1[0]==o2[0]?o1[1]-o2[1]:o1[0]-o2[0]);\\n        int ans[] = new int[queries.length];\\n        TreeMap<Integer,Integer> map  = new TreeMap(); \\n        for(int p [] : items){\\n            if(map.floorKey(p[0])==null){\\n                map.put(p[0],p[1]);\\n            }else{\\n                map.put(p[0],Math.max(map.get(map.floorKey(p[0])),p[1]));\\n            }\\n        }\\n        int i=0; \\n        for(int in: queries){\\n            ans[i]= map.floorKey(in)==null ? 0: map.get(map.floorKey(in));\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items,(o1,o2)->o1[0]==o2[0]?o1[1]-o2[1]:o1[0]-o2[0]);\\n        int ans[] = new int[queries.length];\\n        TreeMap<Integer,Integer> map  = new TreeMap(); \\n        for(int p [] : items){\\n            if(map.floorKey(p[0])==null){\\n                map.put(p[0],p[1]);\\n            }else{\\n                map.put(p[0],Math.max(map.get(map.floorKey(p[0])),p[1]));\\n            }\\n        }\\n        int i=0; \\n        for(int in: queries){\\n            ans[i]= map.floorKey(in)==null ? 0: map.get(map.floorKey(in));\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350317,
                "title": "sort-queries-and-answer-offline",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        n = len(queries)\\n        items.sort()\\n        res = [0] * n\\n        items.sort()\\n        queries = sorted([(queries[i], i) for i in range(n)])\\n        i = 0\\n        maxbeauty = 0\\n        for q, j in queries:\\n            while i < len(items) and items[i][0] <= q:\\n                maxbeauty = max(maxbeauty, items[i][1])\\n                i += 1\\n            res[j] = maxbeauty\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        n = len(queries)\\n        items.sort()\\n        res = [0] * n\\n        items.sort()\\n        queries = sorted([(queries[i], i) for i in range(n)])\\n        i = 0\\n        maxbeauty = 0\\n        for q, j in queries:\\n            while i < len(items) and items[i][0] <= q:\\n                maxbeauty = max(maxbeauty, items[i][1])\\n                i += 1\\n            res[j] = maxbeauty\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302200,
                "title": "python-binary-search-sorting-maxing-hashmap-pruning-beats-98",
                "content": "* We first preprocess the items, by sorting it with price.\\n* Then, we create the max array, which is strictly increasing. Lazy map is a hashmap mapping the price to its latest index on items after sorting.\\n* Each time the query is called, we check whether q exist in lazymap, If so, we retrieve the lazymap index in O(1) and find the max immediately\\n* If not existing, meaning we need to do the binary search on the sorted items base on price. \\n* The binary search returns the latest index possible that is less than or equal to q. However, there are an edge case. When the returned index shows that the best possible result is still larger than q, we can ensure that this item doesn\\'t exist and return 0\\n* Note that I use math.ceil for the \\'upper bound of left side\\' fashion, and will use floor when trying to find the \\'lower bound on right side\\' fashion\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        def bsearch(target,arr):\\n            l,r = 0, len(arr)-1\\n            while l < r:\\n                mid = math.ceil((l+r)/2)\\n                \\n                if arr[mid][0] <=target:\\n                    l = mid \\n                else:\\n                    r = mid - 1\\n            return l\\n        \\n        \\n        items.sort(key=lambda x:x[0])\\n        maxibeauty = []\\n        beauty = 0\\n        lazymap = {}\\n        for i in range(len(items)):\\n            beauty = max(beauty,items[i][1])\\n            maxibeauty.append(beauty)\\n            lazymap[items[i][0]] = i\\n        \\n        ans = []\\n        for q in queries:\\n            if q in lazymap:\\n                ans.append(maxibeauty[lazymap[q]])\\n            else:\\n                index = bsearch(q,items)\\n                \\n                if items[index][0] > q:\\n                    ans.append(0)\\n                else:\\n                    ans.append(maxibeauty[index])\\n        return ans",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        def bsearch(target,arr):\\n            l,r = 0, len(arr)-1\\n            while l < r:\\n                mid = math.ceil((l+r)/2)\\n                \\n                if arr[mid][0] <=target:\\n                    l = mid \\n                else:\\n                    r = mid - 1\\n            return l\\n        \\n        \\n        items.sort(key=lambda x:x[0])\\n        maxibeauty = []\\n        beauty = 0\\n        lazymap = {}",
                "codeTag": "Java"
            },
            {
                "id": 3297855,
                "title": "python-stop-and-go-explained",
                "content": "The idea here is we will find the best beauty up until  > query price at which point we will log our result using the index we stored earlier\\ninstead of than repeating the same work for the next query we can use the fact that query is always increasing aswell as price to our advantage\\nif our last query was 2 and our new one is 3 we only need to iterate now past 3 and stop, our mx will have the max value up to that point\\nthis means we are only iterating over queries once and items once which is O(N + M) but our total Time will be N(log(N)) due to sorting and O(N) space due to Tim Sort\\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        \\n        #stop and go iterate over items of lesser or equal value until we catch up than move on the the next query\\n        mx = 0\\n        res = [0] * len(queries)\\n        \\n        #add the index to the list so we can keep track of our position\\n        for i in range(len(queries)):\\n            queries[i] = [queries[i], i]\\n        \\n        #we are going to need both of these costs in sorted order (Tim sort)\\n        queries.sort()\\n        items.sort()\\n        \\n        #This will keep track of our position in items so we can pick up where we left off after each query to avoid repeated work\\n        i = 0  \\n        \\n        #the idea here is we will find the best beauty up until  > query price at which point we will log our result using the index we stored earlier\\n        #instead of than repeating the same work for the next query we can use the fact that query is always increasing aswell as price to our advantage\\n        #if our last query was 2 and our new one is 3 we only need to iterate now past 3 and stop, our mx will have the max value up to that point\\n        #this means we are only iterating over queries once and items once which is 2N or O(N) but our total Time will be N(log(N)) due to sorting and O(N) due to Tim Sort\\n        for val,j in queries:\\n            \\n            while i < len(items) and items[i][0] <= val:\\n                mx = max(mx, items[i][1])\\n                i+=1\\n            \\n            res[j] = mx\\n            \\n        \\n        return res\\n\\t\\t",
                "solutionTags": [],
                "code": "The idea here is we will find the best beauty up until  > query price at which point we will log our result using the index we stored earlier\\ninstead of than repeating the same work for the next query we can use the fact that query is always increasing aswell as price to our advantage\\nif our last query was 2 and our new one is 3 we only need to iterate now past 3 and stop, our mx will have the max value up to that point\\nthis means we are only iterating over queries once and items once which is O(N + M) but our total Time will be N(log(N)) due to sorting and O(N) space due to Tim Sort\\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        \\n        #stop and go iterate over items of lesser or equal value until we catch up than move on the the next query\\n        mx = 0\\n        res = [0] * len(queries)\\n        \\n        #add the index to the list so we can keep track of our position\\n        for i in range(len(queries)):\\n            queries[i] = [queries[i], i]\\n        \\n        #we are going to need both of these costs in sorted order (Tim sort)\\n        queries.sort()\\n        items.sort()\\n        \\n        #This will keep track of our position in items so we can pick up where we left off after each query to avoid repeated work\\n        i = 0  \\n        \\n        #the idea here is we will find the best beauty up until  > query price at which point we will log our result using the index we stored earlier\\n        #instead of than repeating the same work for the next query we can use the fact that query is always increasing aswell as price to our advantage\\n        #if our last query was 2 and our new one is 3 we only need to iterate now past 3 and stop, our mx will have the max value up to that point\\n        #this means we are only iterating over queries once and items once which is 2N or O(N) but our total Time will be N(log(N)) due to sorting and O(N) due to Tim Sort\\n        for val,j in queries:\\n            \\n            while i < len(items) and items[i][0] <= val:\\n                mx = max(mx, items[i][1])\\n                i+=1\\n            \\n            res[j] = mx\\n            \\n        \\n        return res\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 3290771,
                "title": "c-sorting-binary-search-o-n-log-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        int n = items.size();\\n        for(int i=1;i<n;i++)items[i][1]=max(items[i-1][1], items[i][1]);\\n        vector<int> ans;\\n        for(auto &x : queries)\\n        {\\n            if(x < items[0][0]){ans.push_back(0);continue;}\\n            int l=0, r=n-1, res=0;\\n            while(l <= r)\\n            {\\n                int mid = (l+r)/2;\\n                if(items[mid][0] <= x)\\n                {\\n                    res = items[mid][1];\\n                    l = mid+1;\\n                }\\n                else r = mid-1;\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        int n = items.size();\\n        for(int i=1;i<n;i++)items[i][1]=max(items[i-1][1], items[i][1]);\\n        vector<int> ans;\\n        for(auto &x : queries)\\n        {\\n            if(x < items[0][0]){ans.push_back(0);continue;}\\n            int l=0, r=n-1, res=0;\\n            while(l <= r)\\n            {\\n                int mid = (l+r)/2;\\n                if(items[mid][0] <= x)\\n                {\\n                    res = items[mid][1];\\n                    l = mid+1;\\n                }\\n                else r = mid-1;\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290556,
                "title": "c-simple-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        int n=items.size();\\n        int mx=items[0][1];\\n        for(int i=1;i<n;i++)\\n        { \\n            mx=max(items[i][1],mx);\\n            items[i][1]=mx;\\n        }\\n        vector<int>res;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int temp=-1;\\n            int l=0,u=n-1;\\n            while(l<=u)\\n            {\\n                int mid=(l+u)/2;\\n                if(items[mid][0]<=queries[i])\\n                {\\n                    temp=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                {\\n                    u=mid-1;\\n                }\\n            }\\n            if(temp==-1)\\n            res.push_back(0);\\n            else\\n            res.push_back(items[temp][1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(),items.end());\\n        int n=items.size();\\n        int mx=items[0][1];\\n        for(int i=1;i<n;i++)\\n        { \\n            mx=max(items[i][1],mx);\\n            items[i][1]=mx;\\n        }\\n        vector<int>res;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int temp=-1;\\n            int l=0,u=n-1;\\n            while(l<=u)\\n            {\\n                int mid=(l+u)/2;\\n                if(items[mid][0]<=queries[i])\\n                {\\n                    temp=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                {\\n                    u=mid-1;\\n                }\\n            }\\n            if(temp==-1)\\n            res.push_back(0);\\n            else\\n            res.push_back(items[temp][1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273781,
                "title": "simple-and-easy-to-understand-solution-o-nlogn-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        int n=items.size();\\n        map<int, int> mp;\\n        mp[0]=0;\\n        int max_yet=INT_MIN;\\n        for(int i=0; i<n; i++)\\n        {\\n            max_yet=max(max_yet, items[i][1]);\\n            mp[items[i][0]]=max_yet;\\n        }\\n        vector<int> res;\\n        for(auto q:queries)\\n        {\\n            if(mp.find(q)!=mp.end())\\n            {\\n                int itr=mp.find(q)->second;\\n                res.push_back(itr);\\n            }\\n            else \\n            {\\n                int itr=(--mp.lower_bound(q))->second;\\n                res.push_back(itr);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        int n=items.size();\\n        map<int, int> mp;\\n        mp[0]=0;\\n        int max_yet=INT_MIN;\\n        for(int i=0; i<n; i++)\\n        {\\n            max_yet=max(max_yet, items[i][1]);\\n            mp[items[i][0]]=max_yet;\\n        }\\n        vector<int> res;\\n        for(auto q:queries)\\n        {\\n            if(mp.find(q)!=mp.end())\\n            {\\n                int itr=mp.find(q)->second;\\n                res.push_back(itr);\\n            }\\n            else \\n            {\\n                int itr=(--mp.lower_bound(q))->second;\\n                res.push_back(itr);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273534,
                "title": "easy-and-clean-3-ways-using-binary-search-sorting-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        //Way 1 Using Priority Queue\\n        PriorityQueue<int []> pqCap = new PriorityQueue<>((a,b) -> a[0] - b[0]);\\n        PriorityQueue<int []> pqProfit = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        int [] temp = new int[queries.length];\\n        for(int i = 0 ;  i< queries.length; i++)\\n        temp[i] = queries[i];\\n        Arrays.sort(queries);\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int [] res = new int[queries.length];\\n        for(int i = 0; i < items.length; i++)\\n        {\\n            pqCap.add(new int[]{items[i][0], items[i][1]});\\n        }\\n        for(int i = 0; i < queries.length; i++)\\n        {\\n            while(pqCap.size() > 0 && pqCap.peek()[0] <= queries[i])\\n            pqProfit.add(pqCap.poll());\\n            if(pqProfit.size() > 0)\\n            {\\n                if(!map.containsKey(queries[i]))\\n                map.put(queries[i], pqProfit.peek()[1]);\\n            }\\n            else if(!map.containsKey(queries[i]))\\n            map.put(queries[i], 0);\\n        }\\n        for(int i = 0 ; i < temp.length;i++)\\n        {\\n            res[i] = map.get(temp[i]);\\n        }\\n        return res;\\n\\n        //Way 2 Using Binary Search\\n        Arrays.sort(items, (a,b) -> a[0] - b[0]);\\n        int maxBeauty = items[0][1];\\n        for(int i = 1 ; i < items.length; i++)\\n        {\\n            maxBeauty = Math.max(maxBeauty, items[i][1]);\\n            items[i][1] = maxBeauty;\\n        }\\n        int [] res = new int[queries.length];\\n        for(int i = 0 ; i < queries.length; i++)\\n        {\\n            res[i] = BinarySearch(queries[i], items);\\n        }\\n        return res;\\n\\n\\n        //Way 3\\n        Arrays.sort(items, (a,b) -> a[0] - b[0]);\\n        int [] res = new int[queries.length];\\n        List<int[]> list = new ArrayList<>();\\n        for(int i = 0; i < queries.length; i++)\\n        list.add(new int[]{queries[i], i});\\n        Collections.sort(list, (a,b) -> a[0] - b[0]);\\n        int maxBeauty = 0;\\n        int j = 0;\\n        for(int i = 0; i < list.size(); i++)\\n        {\\n            int [] val = list.get(i);\\n            while(j < items.length && items[j][0] <= val[0])\\n            {\\n                maxBeauty = Math.max(maxBeauty, items[j][1]);\\n                j++;\\n            }\\n            res[val[1]] = maxBeauty;\\n        }\\n        return res;\\n    }\\n\\n    public int BinarySearch(int price, int [][] items)\\n    {\\n        int low = 0;\\n        int high  = items.length - 1;\\n        int maxBeauty = 0;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if(items[mid][0] <= price)\\n            {\\n                maxBeauty = items[mid][1];\\n                low = mid + 1;\\n            }\\n            else\\n            high = mid - 1;\\n        }\\n        return maxBeauty;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        //Way 1 Using Priority Queue\\n        PriorityQueue<int []> pqCap = new PriorityQueue<>((a,b) -> a[0] - b[0]);\\n        PriorityQueue<int []> pqProfit = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        int [] temp = new int[queries.length];\\n        for(int i = 0 ;  i< queries.length; i++)\\n        temp[i] = queries[i];\\n        Arrays.sort(queries);\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int [] res = new int[queries.length];\\n        for(int i = 0; i < items.length; i++)\\n        {\\n            pqCap.add(new int[]{items[i][0], items[i][1]});\\n        }\\n        for(int i = 0; i < queries.length; i++)\\n        {\\n            while(pqCap.size() > 0 && pqCap.peek()[0] <= queries[i])\\n            pqProfit.add(pqCap.poll());\\n            if(pqProfit.size() > 0)\\n            {\\n                if(!map.containsKey(queries[i]))\\n                map.put(queries[i], pqProfit.peek()[1]);\\n            }\\n            else if(!map.containsKey(queries[i]))\\n            map.put(queries[i], 0);\\n        }\\n        for(int i = 0 ; i < temp.length;i++)\\n        {\\n            res[i] = map.get(temp[i]);\\n        }\\n        return res;\\n\\n        //Way 2 Using Binary Search\\n        Arrays.sort(items, (a,b) -> a[0] - b[0]);\\n        int maxBeauty = items[0][1];\\n        for(int i = 1 ; i < items.length; i++)\\n        {\\n            maxBeauty = Math.max(maxBeauty, items[i][1]);\\n            items[i][1] = maxBeauty;\\n        }\\n        int [] res = new int[queries.length];\\n        for(int i = 0 ; i < queries.length; i++)\\n        {\\n            res[i] = BinarySearch(queries[i], items);\\n        }\\n        return res;\\n\\n\\n        //Way 3\\n        Arrays.sort(items, (a,b) -> a[0] - b[0]);\\n        int [] res = new int[queries.length];\\n        List<int[]> list = new ArrayList<>();\\n        for(int i = 0; i < queries.length; i++)\\n        list.add(new int[]{queries[i], i});\\n        Collections.sort(list, (a,b) -> a[0] - b[0]);\\n        int maxBeauty = 0;\\n        int j = 0;\\n        for(int i = 0; i < list.size(); i++)\\n        {\\n            int [] val = list.get(i);\\n            while(j < items.length && items[j][0] <= val[0])\\n            {\\n                maxBeauty = Math.max(maxBeauty, items[j][1]);\\n                j++;\\n            }\\n            res[val[1]] = maxBeauty;\\n        }\\n        return res;\\n    }\\n\\n    public int BinarySearch(int price, int [][] items)\\n    {\\n        int low = 0;\\n        int high  = items.length - 1;\\n        int maxBeauty = 0;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if(items[mid][0] <= price)\\n            {\\n                maxBeauty = items[mid][1];\\n                low = mid + 1;\\n            }\\n            else\\n            high = mid - 1;\\n        }\\n        return maxBeauty;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270625,
                "title": "sort-binary-search-java-solution",
                "content": "# Approach\\nCombination of binary search and sorting\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass PriceBeauty {\\n    public final int price;\\n    public int beauty;\\n\\n    public PriceBeauty(int price, int beauty) {\\n        this.price = price;\\n        this.beauty = beauty;\\n    }\\n    \\n    public void setBeauty(int beauty) {\\n        this.beauty = beauty;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        Arrays.sort(items, (int[] o1, int[] o2) -> o1[0] - o2[0]); // sort items by price\\n        List<PriceBeauty> pbList = new ArrayList<>();\\n\\n        int maxBeauty = 0;\\n        for(int[] priceBeauty: items) {\\n            if (priceBeauty[1] > maxBeauty) {\\n                maxBeauty = priceBeauty[1];\\n            }\\n            if(!pbList.isEmpty() && pbList.get(pbList.size()-1).price == priceBeauty[0]) {\\n                pbList.get(pbList.size()-1).setBeauty(maxBeauty);\\n            } else {\\n                pbList.add(new PriceBeauty(priceBeauty[0], maxBeauty));\\n            }\\n        }\\n\\n        int[] output = new int[queries.length];\\n        for(int i=0; i<queries.length; i++) {\\n            int pos = binarySearch(queries[i], pbList);\\n            if (pos == -1) {\\n                output[i] = 0;\\n            } else {\\n                output[i] = pbList.get(pos).beauty;\\n            }\\n        }\\n\\n        return output;\\n    }\\n\\n    private int binarySearch(int q, List<PriceBeauty> list) {\\n        if (q < list.get(0).price) {\\n            return -1;\\n        } else if (q > list.get(list.size()-1).price) {\\n            return list.size()-1;\\n        }\\n\\n        int first = 0, last = list.size()-1;\\n        while(first <= last) {\\n            int mid = (first + last)/2;\\n            if (list.get(mid).price == q) {\\n                return mid;\\n            } else if(list.get(mid).price > q) {\\n                last = mid-1;\\n            } else {\\n                first = mid+1;\\n            }\\n        }\\n        if (list.get(first).price < q) {\\n            return first;\\n        } else {\\n            return last;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PriceBeauty {\\n    public final int price;\\n    public int beauty;\\n\\n    public PriceBeauty(int price, int beauty) {\\n        this.price = price;\\n        this.beauty = beauty;\\n    }\\n    \\n    public void setBeauty(int beauty) {\\n        this.beauty = beauty;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        Arrays.sort(items, (int[] o1, int[] o2) -> o1[0] - o2[0]); // sort items by price\\n        List<PriceBeauty> pbList = new ArrayList<>();\\n\\n        int maxBeauty = 0;\\n        for(int[] priceBeauty: items) {\\n            if (priceBeauty[1] > maxBeauty) {\\n                maxBeauty = priceBeauty[1];\\n            }\\n            if(!pbList.isEmpty() && pbList.get(pbList.size()-1).price == priceBeauty[0]) {\\n                pbList.get(pbList.size()-1).setBeauty(maxBeauty);\\n            } else {\\n                pbList.add(new PriceBeauty(priceBeauty[0], maxBeauty));\\n            }\\n        }\\n\\n        int[] output = new int[queries.length];\\n        for(int i=0; i<queries.length; i++) {\\n            int pos = binarySearch(queries[i], pbList);\\n            if (pos == -1) {\\n                output[i] = 0;\\n            } else {\\n                output[i] = pbList.get(pos).beauty;\\n            }\\n        }\\n\\n        return output;\\n    }\\n\\n    private int binarySearch(int q, List<PriceBeauty> list) {\\n        if (q < list.get(0).price) {\\n            return -1;\\n        } else if (q > list.get(list.size()-1).price) {\\n            return list.size()-1;\\n        }\\n\\n        int first = 0, last = list.size()-1;\\n        while(first <= last) {\\n            int mid = (first + last)/2;\\n            if (list.get(mid).price == q) {\\n                return mid;\\n            } else if(list.get(mid).price > q) {\\n                last = mid-1;\\n            } else {\\n                first = mid+1;\\n            }\\n        }\\n        if (list.get(first).price < q) {\\n            return first;\\n        } else {\\n            return last;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247134,
                "title": "100-90-python",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        beauties, prev = defaultdict(int), 0\\n        for price, beauty in sorted(items + [[i, 0] for i in queries]):\\n            beauties[price] = max(beauties[price], beauty, prev)\\n            prev = max(beauty, prev)\\n        return [beauties[i] for i in queries] \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        beauties, prev = defaultdict(int), 0\\n        for price, beauty in sorted(items + [[i, 0] for i in queries]):\\n            beauties[price] = max(beauties[price], beauty, prev)\\n            prev = max(beauty, prev)\\n        return [beauties[i] for i in queries] \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191279,
                "title": "python-sorting-two-pointers-solution",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        queries = [(q, i) for i, q in enumerate(queries)]\\n        queries.sort()\\n\\n        answer = [0] * len(queries)\\n        j, cur_max = 0, 0\\n        for q, i in queries:\\n            while j < len(items) and items[j][0] <= q:\\n                cur_max = max(cur_max, items[j][1])\\n                j += 1\\n            answer[i] = cur_max\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        queries = [(q, i) for i, q in enumerate(queries)]\\n        queries.sort()\\n\\n        answer = [0] * len(queries)\\n        j, cur_max = 0, 0\\n        for q, i in queries:\\n            while j < len(items) and items[j][0] <= q:\\n                cur_max = max(cur_max, items[j][1])\\n                j += 1\\n            answer[i] = cur_max\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189283,
                "title": "c-binary-search-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[0]==b[0])\\n            return a[1]>b[1];\\n        return a[0]<b[0];\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries)\\n    {\\n        sort(items.begin(),items.end(),cmp);\\n        vector<int> ans;\\n        for(int i=1;i<items.size();i++)\\n        {\\n            items[i][1]=max(items[i-1][1],items[i][1]);\\n        }\\n        for(auto &it:queries)\\n        {\\n            int left=0,right=items.size()-1,cnt=0;\\n            while(left<=right)\\n            {\\n                int mid=left+(right-left)/2;\\n                if(items[mid][0]<=it)\\n                {\\n                    cnt=mid+1;\\n                    left=mid+1;\\n                }\\n                else\\n                {\\n                    right=mid-1;\\n                }\\n            }\\n            if(cnt==0)\\n                ans.push_back(0);\\n            else\\n            {\\n                ans.push_back(items[cnt-1][1]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[0]==b[0])\\n            return a[1]>b[1];\\n        return a[0]<b[0];\\n    }\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries)\\n    {\\n        sort(items.begin(),items.end(),cmp);\\n        vector<int> ans;\\n        for(int i=1;i<items.size();i++)\\n        {\\n            items[i][1]=max(items[i-1][1],items[i][1]);\\n        }\\n        for(auto &it:queries)\\n        {\\n            int left=0,right=items.size()-1,cnt=0;\\n            while(left<=right)\\n            {\\n                int mid=left+(right-left)/2;\\n                if(items[mid][0]<=it)\\n                {\\n                    cnt=mid+1;\\n                    left=mid+1;\\n                }\\n                else\\n                {\\n                    right=mid-1;\\n                }\\n            }\\n            if(cnt==0)\\n                ans.push_back(0);\\n            else\\n            {\\n                ans.push_back(items[cnt-1][1]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131047,
                "title": "best-simple-solution",
                "content": "\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int n = queries.length, m = items.length;\\n        Arrays.sort(items, Comparator.comparingInt(o -> o[0]));\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < m; i++)\\n            items[i][1] = Math.max(items[i][1], items[i > 0? i - 1 : 0][1]);\\n\\n        int j = 0;\\n        for (int q : queries){\\n            int lo = -1, hi = m - 1; //pad lo = -1 to mark no result\\n            while(lo < hi){\\n                int mid = lo + (hi - lo) / 2 + 1;\\n                if (q >= items[mid][0]) lo = mid;\\n                else hi = mid - 1;\\n            }\\n            ans[j++] = lo == -1? 0 : items[lo][1];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        int n = queries.length, m = items.length;\\n        Arrays.sort(items, Comparator.comparingInt(o -> o[0]));\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < m; i++)\\n            items[i][1] = Math.max(items[i][1], items[i > 0? i - 1 : 0][1]);\\n\\n        int j = 0;\\n        for (int q : queries){\\n            int lo = -1, hi = m - 1; //pad lo = -1 to mark no result\\n            while(lo < hi){\\n                int mid = lo + (hi - lo) / 2 + 1;\\n                if (q >= items[mid][0]) lo = mid;\\n                else hi = mid - 1;\\n            }\\n            ans[j++] = lo == -1? 0 : items[lo][1];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130532,
                "title": "binary-search-upper-bound-approach",
                "content": "# Approach\\n=>First sort the items array by price.\\n=>store the maximum beauty till ith index(in maxi array)\\n=>For every ith query, find the index where we get maximum beauty having price <= query[i] that can be find easily by upper_bound, but you will get the previous index(index-1) as its correct index beacause of upper bound gives you the next index where price > query[i].\\n=>you will get the answer of ith query in maxi array ( = maxi[index])\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*logM) + O(MlogM)(sorting items array) => where, N = queries.length, M = items.length\\n\\n- Space complexity:\\nO(N)+O(M) => O(M) for storing maximum beauty till ith index.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n = queries.size();\\n        int m = items.size();\\n        vector<int> maxi(m, 0);\\n        vector<int> ans(n, 0);\\n\\n        sort(items.begin(), items.end());\\n\\n        maxi[0] = items[0][1];\\n        for(int i = 1; i < m; i++) {\\n            maxi[i] = max(maxi[i-1], items[i][1]);\\n        }\\n    \\n        vector<int> price(m, 0);\\n        for(int i = 0; i < m; i++) price[i] = items[i][0];\\n\\n        for(int i = 0; i < n; i++) {\\n            int ind = upper_bound(price.begin(), price.end(), queries[i])-price.begin();\\n\\n            if(ind > 0) {\\n                ind--;\\n                ans[i] = maxi[ind];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        int n = queries.size();\\n        int m = items.size();\\n        vector<int> maxi(m, 0);\\n        vector<int> ans(n, 0);\\n\\n        sort(items.begin(), items.end());\\n\\n        maxi[0] = items[0][1];\\n        for(int i = 1; i < m; i++) {\\n            maxi[i] = max(maxi[i-1], items[i][1]);\\n        }\\n    \\n        vector<int> price(m, 0);\\n        for(int i = 0; i < m; i++) price[i] = items[i][0];\\n\\n        for(int i = 0; i < n; i++) {\\n            int ind = upper_bound(price.begin(), price.end(), queries[i])-price.begin();\\n\\n            if(ind > 0) {\\n                ind--;\\n                ans[i] = maxi[ind];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128794,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1,vector<int>&v2)\\n    {\\n        if(v1[0] == v2[0])  //it means that the price are equal\\n        {\\n            return v1[1] < v2[1];\\n        }\\n        return v1[0] < v2[0];\\n    }\\n    vector<int>leftmax;\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) \\n    {\\n        //this maxleft will keep the max in the range of (0 till i) [both inclusive]\\n        leftmax.resize(items.size(),INT_MIN);\\n\\n        vector<int>ans;\\n        //item=[price , beauty]\\n        sort(items.begin(),items.end(),cmp);\\n\\n        //filling the leftmax array with the max beauty in the inclusive range of (0 till i)\\n        leftmax[0] = items[0][1];\\n        for(int i=1;i<items.size();i++)\\n        {\\n            leftmax[i] = max(leftmax[i-1],items[i][1]);\\n        }\\n\\n        for(int i=0;i<items.size();i++)\\n        {\\n            cout<<items[i][0]<<\" \"<<items[i][1]<<\"  \";\\n        }\\n        //as now the array is sorted on the basis of the price \\n        //we can now apply the binary search on the price\\n        for(int i=0;i<queries.size();i++)\\n        {\\n             int val = fun(items,queries[i]);\\n             ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n    int fun(vector<vector<int>>&items,int &price)\\n    {\\n        int ans = 0;\\n        //at the end will be looking for the max beauty having price less than price\\n        int start = 0;\\n        int end = items.size()-1;\\n\\n        while(start <= end)\\n        {\\n            int mid = (start + end)/2;\\n            \\n            if(items[mid][0] < price)\\n            {\\n                ans = max(ans,leftmax[mid]);\\n                start = mid+1;\\n            }\\n            else if(items[mid][0] == price)\\n            {\\n                ans = max(ans,leftmax[mid]);\\n                start = mid+1;\\n            }\\n            else if(items[mid][0] > price)\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(end >= 0 and end<items.size() and items[end][0]<=price)\\n        {\\n            ans = max(ans,leftmax[end]);\\n        }\\n        if(start >=0 and start<items.size() and items[start][0]<=price)\\n        {\\n            ans = max(ans,leftmax[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1,vector<int>&v2)\\n    {\\n        if(v1[0] == v2[0])  //it means that the price are equal\\n        {\\n            return v1[1] < v2[1];\\n        }\\n        return v1[0] < v2[0];\\n    }\\n    vector<int>leftmax;\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) \\n    {\\n        //this maxleft will keep the max in the range of (0 till i) [both inclusive]\\n        leftmax.resize(items.size(),INT_MIN);\\n\\n        vector<int>ans;\\n        //item=[price , beauty]\\n        sort(items.begin(),items.end(),cmp);\\n\\n        //filling the leftmax array with the max beauty in the inclusive range of (0 till i)\\n        leftmax[0] = items[0][1];\\n        for(int i=1;i<items.size();i++)\\n        {\\n            leftmax[i] = max(leftmax[i-1],items[i][1]);\\n        }\\n\\n        for(int i=0;i<items.size();i++)\\n        {\\n            cout<<items[i][0]<<\" \"<<items[i][1]<<\"  \";\\n        }\\n        //as now the array is sorted on the basis of the price \\n        //we can now apply the binary search on the price\\n        for(int i=0;i<queries.size();i++)\\n        {\\n             int val = fun(items,queries[i]);\\n             ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n    int fun(vector<vector<int>>&items,int &price)\\n    {\\n        int ans = 0;\\n        //at the end will be looking for the max beauty having price less than price\\n        int start = 0;\\n        int end = items.size()-1;\\n\\n        while(start <= end)\\n        {\\n            int mid = (start + end)/2;\\n            \\n            if(items[mid][0] < price)\\n            {\\n                ans = max(ans,leftmax[mid]);\\n                start = mid+1;\\n            }\\n            else if(items[mid][0] == price)\\n            {\\n                ans = max(ans,leftmax[mid]);\\n                start = mid+1;\\n            }\\n            else if(items[mid][0] > price)\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(end >= 0 and end<items.size() and items[end][0]<=price)\\n        {\\n            ans = max(ans,leftmax[end]);\\n        }\\n        if(start >=0 and start<items.size() and items[start][0]<=price)\\n        {\\n            ans = max(ans,leftmax[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3121740,
                "title": "python-easy-to-read-and-understand-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        ans = []\\n        n = len(items)\\n        for i in range(1, n):\\n            items[i][1] = max(items[i][1], items[i-1][1])\\n        \\n        for q in queries:\\n            res = 0\\n            start, end = 0, n-1\\n            while start <= end:\\n                mid = (start+end)//2\\n                if items[mid][0] <= q:\\n                    res = max(res, items[mid][1])\\n                    start = mid+1\\n                else:\\n                    end = mid-1\\n            ans.append(res)\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort()\\n        ans = []\\n        n = len(items)\\n        for i in range(1, n):\\n            items[i][1] = max(items[i][1], items[i-1][1])\\n        \\n        for q in queries:\\n            res = 0\\n            start, end = 0, n-1\\n            while start <= end:\\n                mid = (start+end)//2\\n                if items[mid][0] <= q:\\n                    res = max(res, items[mid][1])\\n                    start = mid+1\\n                else:\\n                    end = mid-1\\n            ans.append(res)\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3095392,
                "title": "binary-search-on-sorted-items-and-using-prefix-max",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        \"\"\"\\n        :type items: List[List[int]]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        def bs(target,left = None,right = None):\\n            if left is None or right is None:\\n                left, right = 0, len(items)\\n            if target< items[0][0]:\\n                return 0\\n            while left<right:\\n                mid = (left+right)//2\\n                if items[mid][0] ==  target:\\n                    return prev_max[items[mid][0]]\\n                if items[mid][0]< target: \\n                    left = mid+1\\n                else: right = mid \\n            return prev_max[items[left-1][0]]\\n\\n        items = sorted(items, key = lambda x: x[0])\\n\\n        prev_max = defaultdict()\\n        prev_max[items[0][0]] = items[0][1]\\n\\n        for i in range(1,len(items)):\\n            prev_max[items[i][0]] = max(prev_max[items[i-1][0]], items[i][1])\\n\\n        res = []\\n        for query in queries:\\n            res.append(bs(query))\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        \"\"\"\\n        :type items: List[List[int]]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        def bs(target,left = None,right = None):\\n            if left is None or right is None:\\n                left, right = 0, len(items)\\n            if target< items[0][0]:\\n                return 0\\n            while left<right:\\n                mid = (left+right)//2\\n                if items[mid][0] ==  target:\\n                    return prev_max[items[mid][0]]\\n                if items[mid][0]< target: \\n                    left = mid+1\\n                else: right = mid \\n            return prev_max[items[left-1][0]]\\n\\n        items = sorted(items, key = lambda x: x[0])\\n\\n        prev_max = defaultdict()\\n        prev_max[items[0][0]] = items[0][1]\\n\\n        for i in range(1,len(items)):\\n            prev_max[items[i][0]] = max(prev_max[items[i-1][0]], items[i][1])\\n\\n        res = []\\n        for query in queries:\\n            res.append(bs(query))\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092855,
                "title": "c",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint cmp(const void* a, const void* b){\\n    int* A = *(int**)a ;\\n    int* B = *(int**)b ;\\n    if(A[0] == B[0])\\n        return B[1] - A[1] ;\\n    return A[0] - B[0] ;\\n}\\nint binarySearch(int** set, int n, int val){\\n    int l = 0, r = n -1 ;\\n    while(l < r){\\n        int mid = r - (r-l)/2 ;\\n        if(set[mid][0] == val)\\n            return set[mid][1] ;\\n        else if(set[mid][0] < val)\\n            l = mid ;\\n        else\\n            r = mid - 1;\\n    }\\n    if(set[l][0] <= val)\\n        return set[l][1] ;\\n    else\\n        return 0 ;\\n}\\nint* maximumBeauty(int** items, int itemsSize, int* itemsColSize, int* queries, int queriesSize, int* returnSize){\\n    qsort( items, itemsSize, sizeof(int*) , cmp) ;\\n    int** set = malloc(itemsSize * sizeof(int*)) ;\\n    int set_cn = 0; \\n    set[set_cn] = malloc(2 * sizeof(int)) ;\\n    set[set_cn][0] = items[0][0] ;\\n    set[set_cn][1] = items[0][1] ;\\n    set_cn++;\\n    for(int i = 1; i < itemsSize; i++){\\n        if(items[i][0] != items[i-1][0]){\\n            set[set_cn] = malloc(2 * sizeof(int) ) ;\\n            set[set_cn][0] = items[i][0] ;\\n            set[set_cn][1] = items[i][1] ;\\n            if(set[set_cn][1] < set[set_cn-1][1] )\\n                set[set_cn][1] = set[set_cn-1][1]  ;\\n            set_cn++;\\n        }\\n    }\\n    \\n    int* ans = malloc(queriesSize * sizeof(int)) ;\\n    for(int i = 0; i < queriesSize; i++){\\n        ans[i] = binarySearch(set, set_cn, queries[i]) ;\\n    }\\n    //free memory \\n    for(int i = 0; i < set_cn; i++){\\n        free(set[i]) ;\\n    }\\n    free(set) ;\\n    *returnSize = queriesSize ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint cmp(const void* a, const void* b){\\n    int* A = *(int**)a ;\\n    int* B = *(int**)b ;\\n    if(A[0] == B[0])\\n        return B[1] - A[1] ;\\n    return A[0] - B[0] ;\\n}\\nint binarySearch(int** set, int n, int val){\\n    int l = 0, r = n -1 ;\\n    while(l < r){\\n        int mid = r - (r-l)/2 ;\\n        if(set[mid][0] == val)\\n            return set[mid][1] ;\\n        else if(set[mid][0] < val)\\n            l = mid ;\\n        else\\n            r = mid - 1;\\n    }\\n    if(set[l][0] <= val)\\n        return set[l][1] ;\\n    else\\n        return 0 ;\\n}\\nint* maximumBeauty(int** items, int itemsSize, int* itemsColSize, int* queries, int queriesSize, int* returnSize){\\n    qsort( items, itemsSize, sizeof(int*) , cmp) ;\\n    int** set = malloc(itemsSize * sizeof(int*)) ;\\n    int set_cn = 0; \\n    set[set_cn] = malloc(2 * sizeof(int)) ;\\n    set[set_cn][0] = items[0][0] ;\\n    set[set_cn][1] = items[0][1] ;\\n    set_cn++;\\n    for(int i = 1; i < itemsSize; i++){\\n        if(items[i][0] != items[i-1][0]){\\n            set[set_cn] = malloc(2 * sizeof(int) ) ;\\n            set[set_cn][0] = items[i][0] ;\\n            set[set_cn][1] = items[i][1] ;\\n            if(set[set_cn][1] < set[set_cn-1][1] )\\n                set[set_cn][1] = set[set_cn-1][1]  ;\\n            set_cn++;\\n        }\\n    }\\n    \\n    int* ans = malloc(queriesSize * sizeof(int)) ;\\n    for(int i = 0; i < queriesSize; i++){\\n        ans[i] = binarySearch(set, set_cn, queries[i]) ;\\n    }\\n    //free memory \\n    for(int i = 0; i < set_cn; i++){\\n        free(set[i]) ;\\n    }\\n    free(set) ;\\n    *returnSize = queriesSize ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3048218,
                "title": "java-sort-solution-using-treemap",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items, (a, b) -> a[0] - b[0]);\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int max = 0;\\n        for (int[] item : items) {\\n            map.put(item[0], Math.max(max, item[1]));\\n            max = Math.max(max, item[1]);\\n        }\\n\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            Integer key = map.floorKey(queries[i]);\\n            if (key != null) {\\n                res[i] = map.get(key);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items, (a, b) -> a[0] - b[0]);\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int max = 0;\\n        for (int[] item : items) {\\n            map.put(item[0], Math.max(max, item[1]));\\n            max = Math.max(max, item[1]);\\n        }\\n\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            Integer key = map.floorKey(queries[i]);\\n            if (key != null) {\\n                res[i] = map.get(key);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029815,
                "title": "c-upper-bound-faster-than-98",
                "content": "```\\nclass Solution {\\n    map<int, int> data; \\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        for(const auto &item : items) {\\n            data[item[0]] = max(data[item[0]], item[1]);\\n        }\\n        \\n        // adjust the current max to the previous keys\\n        auto prv = data.begin();\\n        auto nxt = next(prv);\\n        while(nxt != data.end()) {\\n            nxt->second = max(prv->second, nxt->second);\\n            ++prv, ++nxt;\\n        }\\n        \\n        const int N = queries.size();\\n        vector<int> ret(N, 0);\\n        for(int i = 0; i < N; ++i) {\\n            const int q = queries[i];\\n            auto it = data.upper_bound(q);\\n            if(it != data.begin()) {\\n                ret[i] = prev(it)->second;\\n            }            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    map<int, int> data; \\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        for(const auto &item : items) {\\n            data[item[0]] = max(data[item[0]], item[1]);\\n        }\\n        \\n        // adjust the current max to the previous keys\\n        auto prv = data.begin();\\n        auto nxt = next(prv);\\n        while(nxt != data.end()) {\\n            nxt->second = max(prv->second, nxt->second);\\n            ++prv, ++nxt;\\n        }\\n        \\n        const int N = queries.size();\\n        vector<int> ret(N, 0);\\n        for(int i = 0; i < N; ++i) {\\n            const int q = queries[i];\\n            auto it = data.upper_bound(q);\\n            if(it != data.begin()) {\\n                ret[i] = prev(it)->second;\\n            }            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944892,
                "title": "c-easy-application-of-upper-bound-clean-and-concise",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& quer) {\\n        int n=items.size();\\n        sort(items.begin(),items.end());\\n        int mini=items[0][1];\\n        for(auto &x:items){\\n            mini=max(mini,x[1]);\\n            x[1]=mini;\\n        }\\n        map<int,int> mp;\\n        for(auto &x:items){\\n            mp[x[0]]=x[1];\\n        }\\n        vector<int> res;\\n        for(auto x:quer){\\n            auto idx= mp.upper_bound(x);\\n            if(idx!=mp.begin()){\\n                res.push_back(prev(idx)->second);\\n            }\\n            else{\\n                res.push_back(0);\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& quer) {\\n        int n=items.size();\\n        sort(items.begin(),items.end());\\n        int mini=items[0][1];\\n        for(auto &x:items){\\n            mini=max(mini,x[1]);\\n            x[1]=mini;\\n        }\\n        map<int,int> mp;\\n        for(auto &x:items){\\n            mp[x[0]]=x[1];\\n        }\\n        vector<int> res;\\n        for(auto x:quer){\\n            auto idx= mp.upper_bound(x);\\n            if(idx!=mp.begin()){\\n                res.push_back(prev(idx)->second);\\n            }\\n            else{\\n                res.push_back(0);\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861170,
                "title": "4-liner",
                "content": "**sorting / bs / 2 pass / running max / inplace**\\n**time: `O(NlogN)`; space: `O(1)`**\\n```\\nvector<int> maximumBeauty(vector<vector<int>>& i, vector<int>& q)\\n{\\n\\ti.push_back({0,0});\\n\\tsort(begin(i), end(i));\\n\\tpartial_sum(begin(i), end(i), begin(i), [](auto & M, auto & e){ return vector{e[0], max(M[1], e[1])}; });\\n\\treturn {begin(q), transform(begin(q), end(q), begin(q), [&](auto & e){return prev(lower_bound(begin(i), end(i), vector{e+1,0}))->at(1);})};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> maximumBeauty(vector<vector<int>>& i, vector<int>& q)\\n{\\n\\ti.push_back({0,0});\\n\\tsort(begin(i), end(i));\\n\\tpartial_sum(begin(i), end(i), begin(i), [](auto & M, auto & e){ return vector{e[0], max(M[1], e[1])}; });\\n\\treturn {begin(q), transform(begin(q), end(q), begin(q), [&](auto & e){return prev(lower_bound(begin(i), end(i), vector{e+1,0}))->at(1);})};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2840443,
                "title": "python3-let-me-know-if-it-can-be-improved-further",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort(key = lambda x: (x[0]))\\n        base = [i for i in range(len(queries))]\\n        partialRes = {}\\n        i = beauty = 0\\n        for query, b in sorted(zip(queries, base), key = lambda x: x[0]):\\n            while i < len(items) and items[i][0] <= query:\\n                beauty = max(beauty, items[i][1])\\n                i += 1\\n            partialRes[b] = beauty\\n        return [beauty for b, beauty in sorted(partialRes.items(), key = lambda x:x[0])]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        items.sort(key = lambda x: (x[0]))\\n        base = [i for i in range(len(queries))]\\n        partialRes = {}\\n        i = beauty = 0\\n        for query, b in sorted(zip(queries, base), key = lambda x: x[0]):\\n            while i < len(items) and items[i][0] <= query:\\n                beauty = max(beauty, items[i][1])\\n                i += 1\\n            partialRes[b] = beauty\\n        return [beauty for b, beauty in sorted(partialRes.items(), key = lambda x:x[0])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775136,
                "title": "groupby-python",
                "content": "Sorry, wanted to clean these notes up, but gotta go get my hurr did\\n\\n```\\nfrom bisect import bisect_right\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        # We only care about highest beauty at a given price\\n        # if we groupby price and then sort by beauty reversed\\n        # only the first item in each group matters\\n        # and while the beauty of the cheaper item is greater than that of the subsequent\\n        # items at higher prices those subsequent items can be ignored\\n        # From here we know that if any query is higher than the maximum price of \\n        # the items, we\\'ll return whichever one has the most beauty\\n        # You could have a set of items where the price is really low\\n        # But then the Beauty is super high\\n        # [1, 10000], [2,2], [3,100], [4,2000]... etc\\n        # in this case, the [1, 10000] will superced all the subsequent items, \\n        # until an item with greater beauty is seen\\n        # In this way we can further reduce the desired items\\n        # if you only have one item you\\'re just going to return that item as many times as you\\n        # have queries unless the query value is less than the item\\'s price\\n        # Step 1: sort by price\\n        # step 2: group by price\\n        # step 3: reverse sort by beauty\\n        # step 4: reduce item list by removing useless items\\n        # ### THOUGHT ####\\n        # At this point it could make sense to start processing the queries as well\\n        # ### ANOTHER THOUGHT ###\\n        # We\\'re doing a LOT to the input upfront\\n        # I think step 4 could be kind of pointless\\n        # if we do 1-3 and then store the most valuable thing \\n        items = groupby(sorted(items, key = lambda x:x[0]), key = lambda x:x[0])\\n        items = sorted([sorted(g)[-1] for _,g in items], key = lambda x:x[1])[::-1]\\n        for i in range(len(queries)):\\n            query = queries[i]\\n            for item in items:\\n                if query >= item[0]:\\n                    queries[i] = item[1]\\n                    break\\n                else:\\n                    queries[i] = 0\\n        return queries\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_right\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        # We only care about highest beauty at a given price\\n        # if we groupby price and then sort by beauty reversed\\n        # only the first item in each group matters\\n        # and while the beauty of the cheaper item is greater than that of the subsequent\\n        # items at higher prices those subsequent items can be ignored\\n        # From here we know that if any query is higher than the maximum price of \\n        # the items, we\\'ll return whichever one has the most beauty\\n        # You could have a set of items where the price is really low\\n        # But then the Beauty is super high\\n        # [1, 10000], [2,2], [3,100], [4,2000]... etc\\n        # in this case, the [1, 10000] will superced all the subsequent items, \\n        # until an item with greater beauty is seen\\n        # In this way we can further reduce the desired items\\n        # if you only have one item you\\'re just going to return that item as many times as you\\n        # have queries unless the query value is less than the item\\'s price\\n        # Step 1: sort by price\\n        # step 2: group by price\\n        # step 3: reverse sort by beauty\\n        # step 4: reduce item list by removing useless items\\n        # ### THOUGHT ####\\n        # At this point it could make sense to start processing the queries as well\\n        # ### ANOTHER THOUGHT ###\\n        # We\\'re doing a LOT to the input upfront\\n        # I think step 4 could be kind of pointless\\n        # if we do 1-3 and then store the most valuable thing \\n        items = groupby(sorted(items, key = lambda x:x[0]), key = lambda x:x[0])\\n        items = sorted([sorted(g)[-1] for _,g in items], key = lambda x:x[1])[::-1]\\n        for i in range(len(queries)):\\n            query = queries[i]\\n            for item in items:\\n                if query >= item[0]:\\n                    queries[i] = item[1]\\n                    break\\n                else:\\n                    queries[i] = 0\\n        return queries\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764043,
                "title": "java-sorting-binary-search-memoization",
                "content": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items, (arr1, arr2) -> arr1[0] - arr2[0]);\\n        int n = items.length;\\n        int[] maxPrice = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(max, items[i][1]);\\n            maxPrice[i] = max;\\n        }\\n        int m = queries.length;\\n        int[] res = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            int query = queries[i];\\n            int low = 0;\\n            int high = n - 1;\\n            int resIndex = 0;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if (items[mid][0] > query) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    resIndex = mid;\\n                    low = mid + 1;\\n                }\\n            }\\n            if (high >= 0) {\\n                res[i] = maxPrice[resIndex];\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        Arrays.sort(items, (arr1, arr2) -> arr1[0] - arr2[0]);\\n        int n = items.length;\\n        int[] maxPrice = new int[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(max, items[i][1]);\\n            maxPrice[i] = max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2742921,
                "title": "python-from-brute-force-to-optimized-solution",
                "content": "## **1. BRUTE FORCE APPROACH - TLE**\\n\\nThe pretty straightforward way is to use two nested loops. For each query, go through each item and get the maximum beauty for an item whose price <= query. Will give TLE for large inputs.\\n\\n```\\ndef maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n\\toutput = []\\n\\n\\t# In Brute Force Approach\\n\\t# We can go through each query        \\n\\tfor target in queries:\\n\\t\\tmaxBeauty = 0 \\n\\t\\t# And then loop through each item\\n\\t\\t# To find the maximum beauty of an item\\n\\t\\t# Whose price is <= query\\n\\t\\tfor i in range(len(items)): \\n\\t\\t\\tif items[i][0] <= target: \\n\\t\\t\\t\\tmaxBeauty = max(maxBeauty, items[i][1])\\n\\n\\t\\toutput.append(maxBeauty)\\n\\n\\treturn output\\n```\\n\\n## **2. USING SORTING AND REDUCING ITERATIONS**\\n\\nDid you notice what are we doing again and again? What if the new query is greater than previous one? Is there any need to again start the inner loop from beginning? NO! because we can pick from where we left last time as we know that till that index, we have already found the maxBeauty. And that\\'s the idea of this approach.\\n\\n```\\ndef maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        # Output Array to return\\n        output = [0] * len(queries)\\n        \\n        # Sort the items based on the price\\n        items.sort()\\n        \\n        # Sort the queries as well\\n        # But since we also want their original indices\\n        # Convert each query into a tuple of (query, index) before sorting it\\n        queries = [(query, i)  for i, query in enumerate(queries)]\\n        \\n        # Sort the queries\\n        queries.sort()\\n        \\n        # The index at which we found maxBeauty for previous query\\n        # Initially, it will be the 0th index\\n        idx = 0\\n        \\n        # The maxBeauty for previous query\\n        maxBeauty = 0\\n        \\n        for query, index in queries:\\n            \\n            # Instead of again looping from beginning of items list\\n            # We can start from where we left for previous query\\n            # Because queries are in sorted order\\n            for i in range(idx, len(items)):\\n                # If this item has price more than query, break\\n                if items[i][0] > query: break\\n                    \\n                # Otherwise, set maxBeauty to the maximum of previous and current beauty value\\n                maxBeauty = max(maxBeauty, items[i][1])\\n                \\n                # Also increment this variable\\n                # It is used to keep track of the index till which we iterated for the current query\\n                # So that for the next query, we start the loop from this index, instead of from the beginning\\n                idx += 1\\n                    \\n            output[index] = maxBeauty\\n\\t\\t\\n\\t\\treturn output\\n            \\n```\\n        \\n\\t\\t\\n## **3. BINARY SEARCH**\\n\\nIt is not possible to apply the Binary Search directly to the items because they are sorted based on the price whereas we have to find the maximum beauty value. So it is possible that an item with less price has a higher beauty value than an item with a higher price. \\n\\nHence, before applying Binary search, we want to get rid of this issue with max beauty. What if we precompute the max beauty value till each index? If we can do that, all that\\'s left is to apply Binary Search on items list to find the highest price that is <= query. \\n\\n\\n```\\n def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        # Output Array to return\\n        output = [0] * len(queries)\\n        \\n        # Sort the items based on the price\\n        items.sort()\\n        \\n        # To perform binary search based on price\\n        # We need to ensure that at any index in items array\\n        # we can find what is the max beauty value till that index in constant time\\n        # So we can precompute the max beauty till any index\\n        for i in range(1, len(items)): items[i][1] = max(items[i][1], items[i-1][1])\\n        \\n        \\n        # Sort the queries as well\\n        # But since we also want their original indices\\n        # Convert each query into a tuple of (query, index) before sorting it\\n        queries = [(query, i)  for i, query in enumerate(queries)]\\n        \\n        # Sort the queries\\n        queries.sort()\\n        \\n        # The index at which we found maxBeauty for previous query\\n        # Initially, it will be the 0th index\\n        idx = 0\\n\\n        for query, index in queries:\\n            \\n            # Now, instead of linear search, apply Binary Search\\n            start, end = idx, len(items) - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # If the price of item at mid is <= query\\n                # Then it can be one possible solution\\n                # But there may be an item after it with price <= query\\n                # So keep searching for that on right side of mid\\n                if items[mid][0] <= query:\\n                    idx = mid\\n                    output[index] = items[mid][1]\\n                    start = mid + 1\\n                else: end = mid - 1\\n            \\n        return output\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n\\toutput = []\\n\\n\\t# In Brute Force Approach\\n\\t# We can go through each query        \\n\\tfor target in queries:\\n\\t\\tmaxBeauty = 0 \\n\\t\\t# And then loop through each item\\n\\t\\t# To find the maximum beauty of an item\\n\\t\\t# Whose price is <= query\\n\\t\\tfor i in range(len(items)): \\n\\t\\t\\tif items[i][0] <= target: \\n\\t\\t\\t\\tmaxBeauty = max(maxBeauty, items[i][1])\\n\\n\\t\\toutput.append(maxBeauty)\\n\\n\\treturn output\\n```\n```\\ndef maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        # Output Array to return\\n        output = [0] * len(queries)\\n        \\n        # Sort the items based on the price\\n        items.sort()\\n        \\n        # Sort the queries as well\\n        # But since we also want their original indices\\n        # Convert each query into a tuple of (query, index) before sorting it\\n        queries = [(query, i)  for i, query in enumerate(queries)]\\n        \\n        # Sort the queries\\n        queries.sort()\\n        \\n        # The index at which we found maxBeauty for previous query\\n        # Initially, it will be the 0th index\\n        idx = 0\\n        \\n        # The maxBeauty for previous query\\n        maxBeauty = 0\\n        \\n        for query, index in queries:\\n            \\n            # Instead of again looping from beginning of items list\\n            # We can start from where we left for previous query\\n            # Because queries are in sorted order\\n            for i in range(idx, len(items)):\\n                # If this item has price more than query, break\\n                if items[i][0] > query: break\\n                    \\n                # Otherwise, set maxBeauty to the maximum of previous and current beauty value\\n                maxBeauty = max(maxBeauty, items[i][1])\\n                \\n                # Also increment this variable\\n                # It is used to keep track of the index till which we iterated for the current query\\n                # So that for the next query, we start the loop from this index, instead of from the beginning\\n                idx += 1\\n                    \\n            output[index] = maxBeauty\\n\\t\\t\\n\\t\\treturn output\\n            \\n```\n```\\n def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        # Output Array to return\\n        output = [0] * len(queries)\\n        \\n        # Sort the items based on the price\\n        items.sort()\\n        \\n        # To perform binary search based on price\\n        # We need to ensure that at any index in items array\\n        # we can find what is the max beauty value till that index in constant time\\n        # So we can precompute the max beauty till any index\\n        for i in range(1, len(items)): items[i][1] = max(items[i][1], items[i-1][1])\\n        \\n        \\n        # Sort the queries as well\\n        # But since we also want their original indices\\n        # Convert each query into a tuple of (query, index) before sorting it\\n        queries = [(query, i)  for i, query in enumerate(queries)]\\n        \\n        # Sort the queries\\n        queries.sort()\\n        \\n        # The index at which we found maxBeauty for previous query\\n        # Initially, it will be the 0th index\\n        idx = 0\\n\\n        for query, index in queries:\\n            \\n            # Now, instead of linear search, apply Binary Search\\n            start, end = idx, len(items) - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # If the price of item at mid is <= query\\n                # Then it can be one possible solution\\n                # But there may be an item after it with price <= query\\n                # So keep searching for that on right side of mid\\n                if items[mid][0] <= query:\\n                    idx = mid\\n                    output[index] = items[mid][1]\\n                    start = mid + 1\\n                else: end = mid - 1\\n            \\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2727351,
                "title": "go-solution-faster-than-100",
                "content": "```go\\nimport \"sort\"\\n\\nfunc maximumBeauty(items [][]int, queries []int) []int {\\n    list := reduce(items)\\n    sort.Slice(list, func(i, j int) bool { return list[i].price < list[j].price })\\n    \\n    maxBeauty := list[0].beauty\\n    for i := 1; i < len(list); i++ {\\n        maxBeauty = max(maxBeauty, list[i].beauty)\\n        list[i].beauty = maxBeauty\\n    }\\n    \\n    answer := make([]int, len(queries))\\n    for i, query := range queries {\\n        index := sort.Search(len(list), func (j int) bool { return list[j].price > query }) - 1\\n        if index >= 0 {\\n            answer[i] = list[index].beauty\\n        }\\n    }\\n    \\n    return answer\\n}\\n\\nfunc reduce(items [][]int) []Item {\\n    maxBeauty := map[int]int{}\\n    for _, item := range items {\\n        p, b := item[0], item[1]\\n        maxBeauty[p] = max(maxBeauty[p], b)\\n    }\\n    \\n    res := make([]Item, 0, len(maxBeauty))\\n    for p, b := range maxBeauty {\\n        res = append(res, Item{price: p, beauty: b})\\n    }\\n    \\n    return res\\n}\\n\\ntype Item struct {\\n    price int\\n    beauty int\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```go\\nimport \"sort\"\\n\\nfunc maximumBeauty(items [][]int, queries []int) []int {\\n    list := reduce(items)\\n    sort.Slice(list, func(i, j int) bool { return list[i].price < list[j].price })\\n    \\n    maxBeauty := list[0].beauty\\n    for i := 1; i < len(list); i++ {\\n        maxBeauty = max(maxBeauty, list[i].beauty)\\n        list[i].beauty = maxBeauty\\n    }\\n    \\n    answer := make([]int, len(queries))\\n    for i, query := range queries {\\n        index := sort.Search(len(list), func (j int) bool { return list[j].price > query }) - 1\\n        if index >= 0 {\\n            answer[i] = list[index].beauty\\n        }\\n    }\\n    \\n    return answer\\n}\\n\\nfunc reduce(items [][]int) []Item {\\n    maxBeauty := map[int]int{}\\n    for _, item := range items {\\n        p, b := item[0], item[1]\\n        maxBeauty[p] = max(maxBeauty[p], b)\\n    }\\n    \\n    res := make([]Item, 0, len(maxBeauty))\\n    for p, b := range maxBeauty {\\n        res = append(res, Item{price: p, beauty: b})\\n    }\\n    \\n    return res\\n}\\n\\ntype Item struct {\\n    price int\\n    beauty int\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2721416,
                "title": "intuitive-solution-beginner-friendly",
                "content": "# Intuition\\nBasically the idea is to sort it based on the prices.\\nthen we have to realise that same prices with different beauties will result in same answer(beauty), because we are intreseted in highest beauty among the same priced items. so update them with maximum beauty present with equal price values\\n\\nnow it is basically finding the upperbound of the query and return its coresponding beauty value\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogq) O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe are not using any extra space other than the answer list we are returning\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        def binarySearch(l, i, j, target):\\n            while i < j:\\n                mid = (i+j)>>1\\n                if l[mid][0] <= target:\\n                    i = mid + 1\\n                else:\\n                    j = mid\\n            return l[i][1] if target >= l[i][0] else l[i-1][1]\\n                    \\n        items.sort(key = lambda x : x[0])\\n        i, n = 0,  len(items)\\n        currmax = items[0][1]\\n        mincost = items[0][0]\\n        for i in range(n):\\n            currmax = max(currmax, items[i][1])\\n            items[i][1] = currmax\\n        \\n        ans = []\\n        for q in queries:\\n            if q < mincost:\\n                ans.append(0)\\n                continue\\n            else:\\n                ans.append(binarySearch(items, 0, n -1 , q))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        def binarySearch(l, i, j, target):\\n            while i < j:\\n                mid = (i+j)>>1\\n                if l[mid][0] <= target:\\n                    i = mid + 1\\n                else:\\n                    j = mid\\n            return l[i][1] if target >= l[i][0] else l[i-1][1]\\n                    \\n        items.sort(key = lambda x : x[0])\\n        i, n = 0,  len(items)\\n        currmax = items[0][1]\\n        mincost = items[0][0]\\n        for i in range(n):\\n            currmax = max(currmax, items[i][1])\\n            items[i][1] = currmax\\n        \\n        ans = []\\n        for q in queries:\\n            if q < mincost:\\n                ans.append(0)\\n                continue\\n            else:\\n                ans.append(binarySearch(items, 0, n -1 , q))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670627,
                "title": "c-o-nlogn-beat-100",
                "content": "```\\n     vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        map<int, int> m;\\n        for(auto& it:items){\\n            auto& x = m[it[0]];\\n            x = max(x, it[1]);          \\n        } \\n        map<int,int, greater<int>> m2;\\n        for(auto [p, b] : m){\\n            if(m2.empty() || m2.begin()->second < b) m2.emplace(p,b);\\n        }\\n        \\n        vector<int> res;\\n        for(auto p:queries){\\n            auto it = m2.lower_bound(p);\\n            res.push_back(it == m2.end() ? 0 : it->second);\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n     vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        map<int, int> m;\\n        for(auto& it:items){\\n            auto& x = m[it[0]];\\n            x = max(x, it[1]);          \\n        } \\n        map<int,int, greater<int>> m2;\\n        for(auto [p, b] : m){\\n            if(m2.empty() || m2.begin()->second < b) m2.emplace(p,b);\\n        }\\n        \\n        vector<int> res;\\n        for(auto p:queries){\\n            auto it = m2.lower_bound(p);\\n            res.push_back(it == m2.end() ? 0 : it->second);\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2659514,
                "title": "complete-walkthrough-when-you-should-binary-search-explained",
                "content": "**Don\\'t have time to read at all, Directly Jump to the section where Clean Code is written**\\n**Under this commented Code**\\n\\n```\\n/*\\n    If encountered any problem and it has\\n    find maximum/minimum of something under the condition like\\n        \\n        maximum_of_something(whose something is) <= some_value OR\\n        minimum_of_something(whose something is) >= some_value\\n        \\n        NOTE: This type of relation(s)[ >= , <=] b/w the some variables.\\n                and varify that if we\\'re getting the anwer[possibly not optimal 1] for something then\\n                also getting an answer for before of that something.\\n                \\n                Basically determined the Monotonic-Nature-of-answer based on some parameters.\\n        \\n        Best way to solve/optimized the searching is to used Binary Search.\\n    ==========================================================================\\n    \\n    Like in this problem, the problem is asking for\\n    -----------------------------------------------\\n        determine the maximum beauty of an item whose price is less than or equal to queries[j]\\n                    +-------------------------+               +-------------------------------+\\n                            ^                                                   ^\\n                            |                                                   |\\n                            |                                                   |    \\n                        maximum of beauty of an item -> whose prices        <= queries[j]\\n                        \\n    \\n        NOTE: This problem takes me hardly a minute to figure that the problem\\n                can be solved using Binary Search & once data is sorted.\\n                \\n                Because I\\'ve experieance of 84 problems that I\\'ve solved using Binary Search.\\n                \\n    -------------------------------------------------------------------------------------------\\n    \\n    Let\\'s Monotonic Nature for first sameple test-case.\\n    \\n    items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\\n    \\n    sort the given data based on first(price) -> in ascending order\\n        + if first equal then based on second(beauty) in descending order\\n                * sorting can be done in different ways based on user-to-user\\n                * and implemented methods.\\n                \\n    sorted_items = [[1, 2], [2, 4], [3, 5], [3, 2], [5, 6]]\\n    \\n    for query at index 3 = queries[3] = 4\\n        \\n        all items having prices less than or equal to 4 are : [1, 2], [2, 4], [3, 5], [3, 2]\\n                                                                ^       ^       ^       ^\\n                                                                |       |       |       |\\n                                                                |       |       |       |\\n                                                               i = 0   i=1      i=2     i=3\\n                                                               valid   valid    valid   valid\\n                                                               answer  answer   answer  answer\\n                                                                                  ^      ^\\n                                                                                  |      |\\n                                                                                  |     max-beuaty-starts decreasing\\n                                                                                  |\\n                                                                            optimal(maximum_bueaty) answer\\n                                                                            before it all prices are in\\n                                                                            increasing order (prev_price <= next_price)\\n                                                                                 ^\\n                                                                                 |\\n                                                                                 |\\n                                                                            goal to find this peak\\n                                                                            beauty for the given query(4)\\n                                                                        \\n                                                                    \\n                    Hence, we can see that we\\'ve Monotonic function w.r.t to maximum beauty. -> for this query.\\n                        + similarly, we can define/look the Mononotic Nature of maximum beauty for different queries.\\n                        \\n    -------------------------------------------------------------------------------------------------------------------\\n    \\n    But what if sorted items is like : [[1, 6], [2, 3], [3, 1]] queries = [3]\\n    \\n    Q: How do you determine/get the index corresponding to the maximum beauty using Binary Search?\\n    A: The problem is that you don\\'t know any specific ordering of beauties(second_part) if all prices(first_part)\\n        are different.\\n        \\n        resolve it before implementing the solution.\\n    \\n*/\\n\\nclass Solution extends PredicateAPI {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        Arrays.sort(items, (a, b) -> {\\n            if(a[0] == b[0]) return -Integer.compare(a[1], b[1]);\\n            return Integer.compare(a[0], b[0]);\\n        });\\n        \\n        int n = queries.length, m = items.length;\\n        int[] answer = new int[n];\\n        \\n        //maxBeauty[i] : returns the maximum element in the range of indices [0, i] in sorted \\'items\\' array.\\n        int[] maxBeauty = new int[m];\\n        maxBeauty[0] = items[0][1];\\n        \\n        //building max-prefix array to get maximum beuaty for any jth query in Constant time.\\n        for(int i = 1; i < m; i += 1) {\\n            maxBeauty[i] = Math.max(maxBeauty[i - 1], items[i][1]);\\n        }\\n        \\n        for(int j = 0; j < queries.length; j += 1) {\\n            int idx = getMaxPossibleIndex(items, queries[j]);\\n            if(idx != -1) answer[j] = maxBeauty[idx]; \\n        }\\n        return answer;\\n    }\\n    \\n    private int getMaxPossibleIndex(int[][] items, int queryPrice) {\\n        int left = 0, right = items.length - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(!isCurrentItemHasLessOrEqualPrice(items, mid, queryPrice)) //checking reverse part item.price > queryPrice\\n                right = mid - 1;\\n            else\\n                left = mid + 1; //always move to right search space if items.price <= queryPrice\\n        }\\n        //idx is always 1 index ahead than required itemsi.price <= queryPricej\\n        return left - 1; //or return right \\n    }\\n} \\n\\nclass PredicateAPI {\\n    \\n    /*\\n        Possible Output configurations for our \"isCurrentItemHasLessOrEqualPrice()\" predicate function are:\\n        \\n        Type:1 T T T T T F F F ....     -> w.r.t sorted prices in items array\\n        \\n        Type:2 F F F .......\\n        \\n        Goal: To find the maximum(peak) beauty corresponding to the any True[T].\\n                + But how you\\'ll ensure that the maximum beauty is corresponding to which True[T].\\n                + this is the biggest problem.\\n                \\n        \\n        Instead new Goal: Returns the an index(largest possible) \\'i\\' such that itemi.prece <= queryPrice.\\n            Once we\\'ve index \\'i\\' for jth query, find the maximum beauty of an item in the range [0, i]\\n            \\n            NOTE: Now with this new goal if prices of two items are same then it doesn\\'t matter\\n                    in which order you sort the second part.\\n            \\n        i : Index corresponding to the last occurrence of True[T], if has any.\\n    */\\n    \\n    public boolean isCurrentItemHasLessOrEqualPrice(int[][] items, int itemIdx, int queryPrice) {\\n        return items[itemIdx][0] <= queryPrice;\\n    }\\n}\\n```\\n\\n```\\nClean Code\\n```\\n\\n```\\nclass Solution extends PredicateAPI {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        Arrays.sort(items, (a, b) -> {\\n            if(a[0] == b[0]) return -Integer.compare(a[1], b[1]);\\n            return Integer.compare(a[0], b[0]);\\n        });\\n        \\n        int n = queries.length, m = items.length;\\n        int[] answer = new int[n];\\n        \\n        int[] maxBeauty = new int[m];\\n        maxBeauty[0] = items[0][1];\\n        \\n        for(int i = 1; i < m; i += 1) {\\n            maxBeauty[i] = Math.max(maxBeauty[i - 1], items[i][1]);\\n        }\\n        \\n        for(int j = 0; j < queries.length; j += 1) {\\n            int idx = getMaxPossibleIndex(items, queries[j]);\\n            if(idx != -1) answer[j] = maxBeauty[idx]; \\n        }\\n        return answer;\\n    }\\n    \\n    private int getMaxPossibleIndex(int[][] items, int queryPrice) {\\n        int left = 0, right = items.length - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(!isCurrentItemHasLessOrEqualPrice(items, mid, queryPrice)) \\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left - 1;\\n    }\\n} \\n\\nclass PredicateAPI {\\n    public boolean isCurrentItemHasLessOrEqualPrice(int[][] items, int itemIdx, int queryPrice) {\\n        return items[itemIdx][0] <= queryPrice;\\n    }\\n}\\n```\\n\\n```\\nOptimized One : Using Previous Query Results for Repeated Queries.\\n```\\n\\n```\\nclass Solution extends PredicateAPI {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        Arrays.sort(items, (a, b) -> {\\n            if(a[0] == b[0]) return -Integer.compare(a[1], b[1]);\\n            return Integer.compare(a[0], b[0]);\\n        });\\n        \\n        int n = queries.length, m = items.length;\\n        int[] answer = new int[n];\\n        \\n        int[] maxBeauty = new int[m];\\n        maxBeauty[0] = items[0][1];\\n        \\n        for(int i = 1; i < m; i += 1) {\\n            maxBeauty[i] = Math.max(maxBeauty[i - 1], items[i][1]);\\n        }\\n        \\n        int[][] qrs = new int[n][2];\\n        for(int i = 0; i < n; i += 1) qrs[i] = new int[]{queries[i], i};\\n        \\n        //sorting queries to process it in sorted manner to avoid calculations for repeated queries.\\n        //and also it helps to use the answers of queries to answer other queries.\\n        Arrays.sort(qrs, (a, b) -> Integer.compare(a[0], b[0]));\\n        \\n        int startSearchAtIdx = 0, previousQueryAns = 0;\\n        \\n        /*\\n            [[10,1000],[10, 20], [10, 24], [12, 30]]\\n            [5, 6, 7, 8, 10, 20, 30] -> can be more optimized for this type of queries.\\n            +---------+\\n                ^\\n                |\\n            for these four queries.\\n            answer would be 0.\\n            \\n            I\\'ve done by the condition \"queryPrice >= items[startSearchAtIdx][0]\".\\n        */\\n        \\n        for(int j = 0; j < n; j += 1) {\\n            int queryIndex = qrs[j][1], queryPrice = qrs[j][0];\\n            //if current query\\'s price NOT equal to previous query\\'s price\\n            if(j == 0 || (queryPrice != qrs[j - 1][0] && queryPrice >= items[startSearchAtIdx][0])) {\\n                int idx = getMaxPossibleIndex(items, startSearchAtIdx, queryPrice);\\n                if(idx != -1) {\\n                    answer[queryIndex] = maxBeauty[idx];\\n                    previousQueryAns = answer[queryIndex];\\n                    startSearchAtIdx = idx; //analyze this line carefully, search space always keep reducing.\\n                } else {\\n                     previousQueryAns = 0;\\n                }\\n            } else {\\n                answer[queryIndex] = previousQueryAns; //Just use previous answer. \\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private int getMaxPossibleIndex(int[][] items, int left, int queryPrice) {\\n        int right = items.length - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(!isCurrentItemHasLessOrEqualPrice(items, mid, queryPrice)) \\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left - 1;\\n    }\\n} \\n\\nclass PredicateAPI {\\n    public boolean isCurrentItemHasLessOrEqualPrice(int[][] items, int itemIdx, int queryPrice) {\\n        return items[itemIdx][0] <= queryPrice;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    If encountered any problem and it has\\n    find maximum/minimum of something under the condition like\\n        \\n        maximum_of_something(whose something is) <= some_value OR\\n        minimum_of_something(whose something is) >= some_value\\n        \\n        NOTE: This type of relation(s)[ >= , <=] b/w the some variables.\\n                and varify that if we\\'re getting the anwer[possibly not optimal 1] for something then\\n                also getting an answer for before of that something.\\n                \\n                Basically determined the Monotonic-Nature-of-answer based on some parameters.\\n        \\n        Best way to solve/optimized the searching is to used Binary Search.\\n    ==========================================================================\\n    \\n    Like in this problem, the problem is asking for\\n    -----------------------------------------------\\n        determine the maximum beauty of an item whose price is less than or equal to queries[j]\\n                    +-------------------------+               +-------------------------------+\\n                            ^                                                   ^\\n                            |                                                   |\\n                            |                                                   |    \\n                        maximum of beauty of an item -> whose prices        <= queries[j]\\n                        \\n    \\n        NOTE: This problem takes me hardly a minute to figure that the problem\\n                can be solved using Binary Search & once data is sorted.\\n                \\n                Because I\\'ve experieance of 84 problems that I\\'ve solved using Binary Search.\\n                \\n    -------------------------------------------------------------------------------------------\\n    \\n    Let\\'s Monotonic Nature for first sameple test-case.\\n    \\n    items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\\n    \\n    sort the given data based on first(price) -> in ascending order\\n        + if first equal then based on second(beauty) in descending order\\n                * sorting can be done in different ways based on user-to-user\\n                * and implemented methods.\\n                \\n    sorted_items = [[1, 2], [2, 4], [3, 5], [3, 2], [5, 6]]\\n    \\n    for query at index 3 = queries[3] = 4\\n        \\n        all items having prices less than or equal to 4 are : [1, 2], [2, 4], [3, 5], [3, 2]\\n                                                                ^       ^       ^       ^\\n                                                                |       |       |       |\\n                                                                |       |       |       |\\n                                                               i = 0   i=1      i=2     i=3\\n                                                               valid   valid    valid   valid\\n                                                               answer  answer   answer  answer\\n                                                                                  ^      ^\\n                                                                                  |      |\\n                                                                                  |     max-beuaty-starts decreasing\\n                                                                                  |\\n                                                                            optimal(maximum_bueaty) answer\\n                                                                            before it all prices are in\\n                                                                            increasing order (prev_price <= next_price)\\n                                                                                 ^\\n                                                                                 |\\n                                                                                 |\\n                                                                            goal to find this peak\\n                                                                            beauty for the given query(4)\\n                                                                        \\n                                                                    \\n                    Hence, we can see that we\\'ve Monotonic function w.r.t to maximum beauty. -> for this query.\\n                        + similarly, we can define/look the Mononotic Nature of maximum beauty for different queries.\\n                        \\n    -------------------------------------------------------------------------------------------------------------------\\n    \\n    But what if sorted items is like : [[1, 6], [2, 3], [3, 1]] queries = [3]\\n    \\n    Q: How do you determine/get the index corresponding to the maximum beauty using Binary Search?\\n    A: The problem is that you don\\'t know any specific ordering of beauties(second_part) if all prices(first_part)\\n        are different.\\n        \\n        resolve it before implementing the solution.\\n    \\n*/\\n\\nclass Solution extends PredicateAPI {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        Arrays.sort(items, (a, b) -> {\\n            if(a[0] == b[0]) return -Integer.compare(a[1], b[1]);\\n            return Integer.compare(a[0], b[0]);\\n        });\\n        \\n        int n = queries.length, m = items.length;\\n        int[] answer = new int[n];\\n        \\n        //maxBeauty[i] : returns the maximum element in the range of indices [0, i] in sorted \\'items\\' array.\\n        int[] maxBeauty = new int[m];\\n        maxBeauty[0] = items[0][1];\\n        \\n        //building max-prefix array to get maximum beuaty for any jth query in Constant time.\\n        for(int i = 1; i < m; i += 1) {\\n            maxBeauty[i] = Math.max(maxBeauty[i - 1], items[i][1]);\\n        }\\n        \\n        for(int j = 0; j < queries.length; j += 1) {\\n            int idx = getMaxPossibleIndex(items, queries[j]);\\n            if(idx != -1) answer[j] = maxBeauty[idx]; \\n        }\\n        return answer;\\n    }\\n    \\n    private int getMaxPossibleIndex(int[][] items, int queryPrice) {\\n        int left = 0, right = items.length - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(!isCurrentItemHasLessOrEqualPrice(items, mid, queryPrice)) //checking reverse part item.price > queryPrice\\n                right = mid - 1;\\n            else\\n                left = mid + 1; //always move to right search space if items.price <= queryPrice\\n        }\\n        //idx is always 1 index ahead than required itemsi.price <= queryPricej\\n        return left - 1; //or return right \\n    }\\n} \\n\\nclass PredicateAPI {\\n    \\n    /*\\n        Possible Output configurations for our \"isCurrentItemHasLessOrEqualPrice()\" predicate function are:\\n        \\n        Type:1 T T T T T F F F ....     -> w.r.t sorted prices in items array\\n        \\n        Type:2 F F F .......\\n        \\n        Goal: To find the maximum(peak) beauty corresponding to the any True[T].\\n                + But how you\\'ll ensure that the maximum beauty is corresponding to which True[T].\\n                + this is the biggest problem.\\n                \\n        \\n        Instead new Goal: Returns the an index(largest possible) \\'i\\' such that itemi.prece <= queryPrice.\\n            Once we\\'ve index \\'i\\' for jth query, find the maximum beauty of an item in the range [0, i]\\n            \\n            NOTE: Now with this new goal if prices of two items are same then it doesn\\'t matter\\n                    in which order you sort the second part.\\n            \\n        i : Index corresponding to the last occurrence of True[T], if has any.\\n    */\\n    \\n    public boolean isCurrentItemHasLessOrEqualPrice(int[][] items, int itemIdx, int queryPrice) {\\n        return items[itemIdx][0] <= queryPrice;\\n    }\\n}\\n```\n```\\nClean Code\\n```\n```\\nclass Solution extends PredicateAPI {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        Arrays.sort(items, (a, b) -> {\\n            if(a[0] == b[0]) return -Integer.compare(a[1], b[1]);\\n            return Integer.compare(a[0], b[0]);\\n        });\\n        \\n        int n = queries.length, m = items.length;\\n        int[] answer = new int[n];\\n        \\n        int[] maxBeauty = new int[m];\\n        maxBeauty[0] = items[0][1];\\n        \\n        for(int i = 1; i < m; i += 1) {\\n            maxBeauty[i] = Math.max(maxBeauty[i - 1], items[i][1]);\\n        }\\n        \\n        for(int j = 0; j < queries.length; j += 1) {\\n            int idx = getMaxPossibleIndex(items, queries[j]);\\n            if(idx != -1) answer[j] = maxBeauty[idx]; \\n        }\\n        return answer;\\n    }\\n    \\n    private int getMaxPossibleIndex(int[][] items, int queryPrice) {\\n        int left = 0, right = items.length - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(!isCurrentItemHasLessOrEqualPrice(items, mid, queryPrice)) \\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left - 1;\\n    }\\n} \\n\\nclass PredicateAPI {\\n    public boolean isCurrentItemHasLessOrEqualPrice(int[][] items, int itemIdx, int queryPrice) {\\n        return items[itemIdx][0] <= queryPrice;\\n    }\\n}\\n```\n```\\nOptimized One : Using Previous Query Results for Repeated Queries.\\n```\n```\\nclass Solution extends PredicateAPI {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        \\n        Arrays.sort(items, (a, b) -> {\\n            if(a[0] == b[0]) return -Integer.compare(a[1], b[1]);\\n            return Integer.compare(a[0], b[0]);\\n        });\\n        \\n        int n = queries.length, m = items.length;\\n        int[] answer = new int[n];\\n        \\n        int[] maxBeauty = new int[m];\\n        maxBeauty[0] = items[0][1];\\n        \\n        for(int i = 1; i < m; i += 1) {\\n            maxBeauty[i] = Math.max(maxBeauty[i - 1], items[i][1]);\\n        }\\n        \\n        int[][] qrs = new int[n][2];\\n        for(int i = 0; i < n; i += 1) qrs[i] = new int[]{queries[i], i};\\n        \\n        //sorting queries to process it in sorted manner to avoid calculations for repeated queries.\\n        //and also it helps to use the answers of queries to answer other queries.\\n        Arrays.sort(qrs, (a, b) -> Integer.compare(a[0], b[0]));\\n        \\n        int startSearchAtIdx = 0, previousQueryAns = 0;\\n        \\n        /*\\n            [[10,1000],[10, 20], [10, 24], [12, 30]]\\n            [5, 6, 7, 8, 10, 20, 30] -> can be more optimized for this type of queries.\\n            +---------+\\n                ^\\n                |\\n            for these four queries.\\n            answer would be 0.\\n            \\n            I\\'ve done by the condition \"queryPrice >= items[startSearchAtIdx][0]\".\\n        */\\n        \\n        for(int j = 0; j < n; j += 1) {\\n            int queryIndex = qrs[j][1], queryPrice = qrs[j][0];\\n            //if current query\\'s price NOT equal to previous query\\'s price\\n            if(j == 0 || (queryPrice != qrs[j - 1][0] && queryPrice >= items[startSearchAtIdx][0])) {\\n                int idx = getMaxPossibleIndex(items, startSearchAtIdx, queryPrice);\\n                if(idx != -1) {\\n                    answer[queryIndex] = maxBeauty[idx];\\n                    previousQueryAns = answer[queryIndex];\\n                    startSearchAtIdx = idx; //analyze this line carefully, search space always keep reducing.\\n                } else {\\n                     previousQueryAns = 0;\\n                }\\n            } else {\\n                answer[queryIndex] = previousQueryAns; //Just use previous answer. \\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private int getMaxPossibleIndex(int[][] items, int left, int queryPrice) {\\n        int right = items.length - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(!isCurrentItemHasLessOrEqualPrice(items, mid, queryPrice)) \\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left - 1;\\n    }\\n} \\n\\nclass PredicateAPI {\\n    public boolean isCurrentItemHasLessOrEqualPrice(int[][] items, int itemIdx, int queryPrice) {\\n        return items[itemIdx][0] <= queryPrice;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653331,
                "title": "java-simple-treemap-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        for(int[] item : items) {\\n            int val = tm.getOrDefault(item[0], 0);\\n            if(item[1] > val) {\\n                tm.put(item[0], item[1]);\\n            }\\n        }\\n        \\n        int prevVal = 0;\\n        for(int key : tm.keySet()) {\\n            if(tm.get(key) < prevVal) {\\n                tm.put(key, prevVal);\\n            }\\n            prevVal = tm.get(key);\\n        }\\n\\n        int[] ansArr = new int[queries.length]; \\n        int idx = 0;\\n        for(int q : queries) {\\n            Integer key = tm.floorKey(q);\\n            if(key == null) {\\n                ansArr[idx++] = 0;\\n            } else {\\n                ansArr[idx++] = tm.get(key);\\n            }\\n        }\\n\\n        return ansArr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        for(int[] item : items) {\\n            int val = tm.getOrDefault(item[0], 0);\\n            if(item[1] > val) {\\n                tm.put(item[0], item[1]);\\n            }\\n        }\\n        \\n        int prevVal = 0;\\n        for(int key : tm.keySet()) {\\n            if(tm.get(key) < prevVal) {\\n                tm.put(key, prevVal);\\n            }\\n            prevVal = tm.get(key);\\n        }\\n\\n        int[] ansArr = new int[queries.length]; \\n        int idx = 0;\\n        for(int q : queries) {\\n            Integer key = tm.floorKey(q);\\n            if(key == null) {\\n                ansArr[idx++] = 0;\\n            } else {\\n                ansArr[idx++] = tm.get(key);\\n            }\\n        }\\n\\n        return ansArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641782,
                "title": "using-hashmap-sorting-and-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        \\n        def binary_search(prices,target):\\n            \\n            if target < prices[0]:\\n                return - 1\\n            \\n            if target > prices[-1] :\\n                return len(prices) - 1\\n            \\n            \\n            low  = 0\\n            high = len(prices) - 1\\n            \\n            while low <= high:\\n                \\n                m = (low + high) // 2\\n                \\n                if prices[m] == target:\\n                    return m\\n                elif prices[m] > target:\\n                    high = m - 1\\n                else:\\n                    low = m + 1\\n            \\n            return high\\n        \\n\\t\\t#Time -> O(NlogN) Space -> O(N)\\n        #Logic ->\\n\\t\\t#Idea is that using hashmap we store the max possible beauty availble for each price\\n\\t\\t#after that we sort the price hashmap by key\\n\\t\\t#then we update the hashmap with max possible beauty for each price point move left to right\\n\\t\\t#in asc order of price points\\n\\t\\t#as we move from left to right we create a max marker, which will store max possible\\n\\t\\t#beauty from left to right and update the price hashmap with the max beauty\\n\\t\\t#we use binary search just to check if the price exsist in the available price list\\n\\t\\t#if it does we just index the sorted price array and access the max beauty from hashmap\\n\\t\\t#and append to answer\\n\\t\\t\\n\\t\\t#hashmap which will store max beauty avail for each price point\\n        price = {}        \\n        \\n        for p,b in items:\\n            beauty = price.get(p,0) \\n            price[p] = max(beauty,b)            \\n        \\n\\t\\t#answer\\n        output       = []\\n\\t\\t#we sort the avail price list so that next we can find the max possible value \\n\\t\\t#for each price point as according to the req we check from price and less than avail prices\\n        avail_prices = sorted(price.keys())\\n\\t\\t                       \\n        max_ = 0\\n        for p in avail_prices:\\n            b    = price[p]\\n            max_ = max(max_,b)\\n            price[p]= max_\\n                \\n        for p in queries:\\n            \\n            max_   = 0\\n            pIndex = binary_search(avail_prices,p)\\n            \\n            if pIndex != -1:\\n                max_ = price[avail_prices[pIndex]]\\n                                \\n            output.append(max_)\\n        \\n        return output        \\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        \\n        def binary_search(prices,target):\\n            \\n            if target < prices[0]:\\n                return - 1\\n            \\n            if target > prices[-1] :\\n                return len(prices) - 1\\n            \\n            \\n            low  = 0\\n            high = len(prices) - 1\\n            \\n            while low <= high:\\n                \\n                m = (low + high) // 2\\n                \\n                if prices[m] == target:\\n                    return m\\n                elif prices[m] > target:\\n                    high = m - 1\\n                else:\\n                    low = m + 1\\n            \\n            return high\\n        \\n\\t\\t#Time -> O(NlogN) Space -> O(N)\\n        #Logic ->\\n\\t\\t#Idea is that using hashmap we store the max possible beauty availble for each price\\n\\t\\t#after that we sort the price hashmap by key\\n\\t\\t#then we update the hashmap with max possible beauty for each price point move left to right\\n\\t\\t#in asc order of price points\\n\\t\\t#as we move from left to right we create a max marker, which will store max possible\\n\\t\\t#beauty from left to right and update the price hashmap with the max beauty\\n\\t\\t#we use binary search just to check if the price exsist in the available price list\\n\\t\\t#if it does we just index the sorted price array and access the max beauty from hashmap\\n\\t\\t#and append to answer\\n\\t\\t\\n\\t\\t#hashmap which will store max beauty avail for each price point\\n        price = {}        \\n        \\n        for p,b in items:\\n            beauty = price.get(p,0) \\n            price[p] = max(beauty,b)            \\n        \\n\\t\\t#answer\\n        output       = []\\n\\t\\t#we sort the avail price list so that next we can find the max possible value \\n\\t\\t#for each price point as according to the req we check from price and less than avail prices\\n        avail_prices = sorted(price.keys())\\n\\t\\t                       \\n        max_ = 0\\n        for p in avail_prices:\\n            b    = price[p]\\n            max_ = max(max_,b)\\n            price[p]= max_\\n                \\n        for p in queries:\\n            \\n            max_   = 0\\n            pIndex = binary_search(avail_prices,p)\\n            \\n            if pIndex != -1:\\n                max_ = price[avail_prices[pIndex]]\\n                                \\n            output.append(max_)\\n        \\n        return output        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639883,
                "title": "explanation-of-everyone-s-short-code-hindi-dry-run",
                "content": "```\\n vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        \\n        //IMPORTANT --> is question me dikkt ye aari hai ki hum price<=query[j] to nikal skte binary search se par fr maxBeauty nikalne k liye 0 se idx th element sbko check krna pdega kiski max Beauty to is problem ko solve krne k liye hmne maxBeuaty array hi bnadiya\\n        \\n        int n=items.size(),maxo=0;\\n        vector<int> maxBeauty(n,0);  //maxBeauty till ith index\\n        \\n        sort(items.begin(),items.end()); //to apply binary search in every query\\n        for(int i=0;i<n;i++)\\n        {\\n            maxo=max(maxo,items[i][1]);\\n            maxBeauty[i]=maxo;  //maxBeauty till ith index stored in maxBeauty[i]\\n        }\\n        \\n        vector<int> ans;\\n        for(auto q:queries)\\n        {\\n            int atMostPrice=q;\\n            int s=0,e=n-1,idx=-1;\\n            \\n            while(s<=e)  //o(logn)\\n            {\\n                int mid=(s+e)/2;\\n\\n         //mai us index tak jaunga jitna meri aukaat(yaani paisa yaani <=query[i])\\n                if(items[mid][0]<=atMostPrice)  //items[mid][0] is the price\\n                {\\n                    idx=mid;  //ans updated\\n                    s=mid+1;  //aur aukat h meri aur aage jaunga khreedne ke liye\\n                }\\n                else \\n                    e=mid-1;  //bhai meri aukaat se bhr price ka item hai ye vps ajao\\n            }\\n            \\n            if(idx==-1)  //meri aukaat bht km thi koi b item ni khreed skta utne me\\n                ans.push_back(0);\\n            \\n            else         //meri aukaat thi item khreedne ki par maxBeuty wla hi lunga\\n                ans.push_back(maxBeauty[idx]);//maxBeauty of any item till idx th ele\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        \\n        //IMPORTANT --> is question me dikkt ye aari hai ki hum price<=query[j] to nikal skte binary search se par fr maxBeauty nikalne k liye 0 se idx th element sbko check krna pdega kiski max Beauty to is problem ko solve krne k liye hmne maxBeuaty array hi bnadiya\\n        \\n        int n=items.size(),maxo=0;\\n        vector<int> maxBeauty(n,0);  //maxBeauty till ith index\\n        \\n        sort(items.begin(),items.end()); //to apply binary search in every query\\n        for(int i=0;i<n;i++)\\n        {\\n            maxo=max(maxo,items[i][1]);\\n            maxBeauty[i]=maxo;  //maxBeauty till ith index stored in maxBeauty[i]\\n        }\\n        \\n        vector<int> ans;\\n        for(auto q:queries)\\n        {\\n            int atMostPrice=q;\\n            int s=0,e=n-1,idx=-1;\\n            \\n            while(s<=e)  //o(logn)\\n            {\\n                int mid=(s+e)/2;\\n\\n         //mai us index tak jaunga jitna meri aukaat(yaani paisa yaani <=query[i])\\n                if(items[mid][0]<=atMostPrice)  //items[mid][0] is the price\\n                {\\n                    idx=mid;  //ans updated\\n                    s=mid+1;  //aur aukat h meri aur aage jaunga khreedne ke liye\\n                }\\n                else \\n                    e=mid-1;  //bhai meri aukaat se bhr price ka item hai ye vps ajao\\n            }\\n            \\n            if(idx==-1)  //meri aukaat bht km thi koi b item ni khreed skta utne me\\n                ans.push_back(0);\\n            \\n            else         //meri aukaat thi item khreedne ki par maxBeuty wla hi lunga\\n                ans.push_back(maxBeauty[idx]);//maxBeauty of any item till idx th ele\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2607587,
                "title": "java-binary-search",
                "content": "```java\\n//TC : O(Nlog(N))\\n//SC : O(N)\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        // 1. sort the items according to its price\\n        // 2. use dp[i] to record the max beauty we can have when we can afford price at items[i][0]\\n        // 3. use binary search to find the most expensive item we can afford, and find the max beauty use its index in array dp\\n        \\n        \\n        Arrays.sort(items, (n1, n2) -> (n1[0] == n2[0] ? n2[1] - n1[1]: n1[0] - n2[0]));\\n        int[] dp = new int[items.length];\\n        for (int i = 0; i < items.length; i ++) {\\n            if (i == 0)\\n                dp[i] = items[i][1];\\n            else\\n                dp[i] = Math.max(dp[i-1], items[i][1]);\\n        }\\n        int n = queries.length;\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; i ++) {\\n            ans[i] = bsearch(items, queries[i], dp);\\n        }\\n        return ans;\\n    }\\n    \\n    int bsearch(int[][] items, int tar, int[] dp) {\\n        int lf = 0, rh = items.length;\\n        while (lf < rh) {\\n            int mid = lf + (rh - lf) / 2;\\n            if (items[mid][0] > tar) {\\n                rh = mid;\\n            }\\n            else {\\n                lf = mid+1;\\n            }\\n        }\\n        if (lf == 0)\\n            return 0;\\n        else\\n            return dp[lf-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```java\\n//TC : O(Nlog(N))\\n//SC : O(N)\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n        // 1. sort the items according to its price\\n        // 2. use dp[i] to record the max beauty we can have when we can afford price at items[i][0]\\n        // 3. use binary search to find the most expensive item we can afford, and find the max beauty use its index in array dp\\n        \\n        \\n        Arrays.sort(items, (n1, n2) -> (n1[0] == n2[0] ? n2[1] - n1[1]: n1[0] - n2[0]));\\n        int[] dp = new int[items.length];\\n        for (int i = 0; i < items.length; i ++) {\\n            if (i == 0)\\n                dp[i] = items[i][1];\\n            else\\n                dp[i] = Math.max(dp[i-1], items[i][1]);\\n        }\\n        int n = queries.length;\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; i ++) {\\n            ans[i] = bsearch(items, queries[i], dp);\\n        }\\n        return ans;\\n    }\\n    \\n    int bsearch(int[][] items, int tar, int[] dp) {\\n        int lf = 0, rh = items.length;\\n        while (lf < rh) {\\n            int mid = lf + (rh - lf) / 2;\\n            if (items[mid][0] > tar) {\\n                rh = mid;\\n            }\\n            else {\\n                lf = mid+1;\\n            }\\n        }\\n        if (lf == 0)\\n            return 0;\\n        else\\n            return dp[lf-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604060,
                "title": "java-treemap-solution",
                "content": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n       TreeMap<Integer, Integer> mp = new TreeMap<>();\\n        Arrays.sort(items, (a,b)->a[0]-b[0]);\\n        \\n        \\n        int ans[]= new int[queries.length];\\n        int max= items[0][1];\\n        for(int curr[]:items)\\n        {\\n            mp.put(curr[0], Math.max(max, curr[1]));\\n            max=Math.max(curr[1], max);\\n            \\n        }\\n        int i=0;\\n        mp.put(0, 0);\\n        for(int q:queries)\\n        {\\n            \\n           ans[i++]= mp.get(mp.floorKey(q));\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximumBeauty(int[][] items, int[] queries) {\\n       TreeMap<Integer, Integer> mp = new TreeMap<>();\\n        Arrays.sort(items, (a,b)->a[0]-b[0]);\\n        \\n        \\n        int ans[]= new int[queries.length];\\n        int max= items[0][1];\\n        for(int curr[]:items)\\n        {\\n            mp.put(curr[0], Math.max(max, curr[1]));\\n            max=Math.max(curr[1], max);\\n            \\n        }\\n        int i=0;\\n        mp.put(0, 0);\\n        for(int q:queries)\\n        {\\n            \\n           ans[i++]= mp.get(mp.floorKey(q));\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1925719,
                "content": [
                    {
                        "username": "_drigger",
                        "content": " `Since we can consider items smaller than current item, so we can make vector which stores largest value we encounter till now or till current item, at last use lower or upper bound as per preference to find beauty corresponds to item.`"
                    },
                    {
                        "username": "user3158w",
                        "content": "You should also mention the time complexity you expect, because it can be made in different ways with different time complexities."
                    },
                    {
                        "username": "_tofu_",
                        "content": "CPP code with detailed explanation.\n\n```\nclass Solution2 {\npublic:\n    vector<int> maximumBeauty(vector<vector<int>> &items, vector<int> &queries) {\n        int n = queries.size();\n\n        vector<vector<int>> new_queries(n);\n        for (int i = 0; i < n; i++) new_queries[i] = {queries[i], i};\n        sort(new_queries.rbegin(), new_queries.rend());// sort it in descending order\n\n        auto lambda_cmp = [&](vector<int> a, vector<int> b) {\n            if (a[1] == b[1]) return a[0] > b[0];\n            return a[1] > b[1];\n        };\n        sort(items.begin(), items.end(), lambda_cmp);// large beauty first\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, less<>> max_heap;//{beauty, price}\n        vector<int> res(n);\n\n        int i = 0;\n        for (const auto x: new_queries) {\n            int price = x[0];\n            int idx = x[1];\n\n            /*\n            We already sort queries in descending order\n            We already sort items in descending order as well.\n            If the biggest beauty come with price higher than biggest query price, then we have to skip all of it first.\n            */\n            while (i < items.size() && items[i][0] > price) i++;\n\n            /*\n            Now, we can make sure that: start from i, all the price of item is lowwer or equal to query[i]\n            Actually, we will push all the remain item in items[] in one time. (Because we already skip all non-valid item in previous while loop)\n            */\n            while (i < items.size() && items[i][0] <= price) {\n                max_heap.push({items[i][1], items[i][0]});\n                i++;\n            }\n\n            /*\n            When we enter for loop in second or third time, there is a chance that current biggest beauty come with the price \n            that is higher than the remain query, so we have to pop it out.\n            */\n            while (!max_heap.empty() && max_heap.top().second > price) max_heap.pop();\n\n            if (!max_heap.empty()) res[idx] = max_heap.top().first;\n        }\n\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "pridhi369",
                        "content": "why is time complexity a problem just for last two test cases "
                    }
                ]
            },
            {
                "id": 1862301,
                "content": [
                    {
                        "username": "_drigger",
                        "content": " `Since we can consider items smaller than current item, so we can make vector which stores largest value we encounter till now or till current item, at last use lower or upper bound as per preference to find beauty corresponds to item.`"
                    },
                    {
                        "username": "user3158w",
                        "content": "You should also mention the time complexity you expect, because it can be made in different ways with different time complexities."
                    },
                    {
                        "username": "_tofu_",
                        "content": "CPP code with detailed explanation.\n\n```\nclass Solution2 {\npublic:\n    vector<int> maximumBeauty(vector<vector<int>> &items, vector<int> &queries) {\n        int n = queries.size();\n\n        vector<vector<int>> new_queries(n);\n        for (int i = 0; i < n; i++) new_queries[i] = {queries[i], i};\n        sort(new_queries.rbegin(), new_queries.rend());// sort it in descending order\n\n        auto lambda_cmp = [&](vector<int> a, vector<int> b) {\n            if (a[1] == b[1]) return a[0] > b[0];\n            return a[1] > b[1];\n        };\n        sort(items.begin(), items.end(), lambda_cmp);// large beauty first\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, less<>> max_heap;//{beauty, price}\n        vector<int> res(n);\n\n        int i = 0;\n        for (const auto x: new_queries) {\n            int price = x[0];\n            int idx = x[1];\n\n            /*\n            We already sort queries in descending order\n            We already sort items in descending order as well.\n            If the biggest beauty come with price higher than biggest query price, then we have to skip all of it first.\n            */\n            while (i < items.size() && items[i][0] > price) i++;\n\n            /*\n            Now, we can make sure that: start from i, all the price of item is lowwer or equal to query[i]\n            Actually, we will push all the remain item in items[] in one time. (Because we already skip all non-valid item in previous while loop)\n            */\n            while (i < items.size() && items[i][0] <= price) {\n                max_heap.push({items[i][1], items[i][0]});\n                i++;\n            }\n\n            /*\n            When we enter for loop in second or third time, there is a chance that current biggest beauty come with the price \n            that is higher than the remain query, so we have to pop it out.\n            */\n            while (!max_heap.empty() && max_heap.top().second > price) max_heap.pop();\n\n            if (!max_heap.empty()) res[idx] = max_heap.top().first;\n        }\n\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "pridhi369",
                        "content": "why is time complexity a problem just for last two test cases "
                    }
                ]
            },
            {
                "id": 1940735,
                "content": [
                    {
                        "username": "_drigger",
                        "content": " `Since we can consider items smaller than current item, so we can make vector which stores largest value we encounter till now or till current item, at last use lower or upper bound as per preference to find beauty corresponds to item.`"
                    },
                    {
                        "username": "user3158w",
                        "content": "You should also mention the time complexity you expect, because it can be made in different ways with different time complexities."
                    },
                    {
                        "username": "_tofu_",
                        "content": "CPP code with detailed explanation.\n\n```\nclass Solution2 {\npublic:\n    vector<int> maximumBeauty(vector<vector<int>> &items, vector<int> &queries) {\n        int n = queries.size();\n\n        vector<vector<int>> new_queries(n);\n        for (int i = 0; i < n; i++) new_queries[i] = {queries[i], i};\n        sort(new_queries.rbegin(), new_queries.rend());// sort it in descending order\n\n        auto lambda_cmp = [&](vector<int> a, vector<int> b) {\n            if (a[1] == b[1]) return a[0] > b[0];\n            return a[1] > b[1];\n        };\n        sort(items.begin(), items.end(), lambda_cmp);// large beauty first\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, less<>> max_heap;//{beauty, price}\n        vector<int> res(n);\n\n        int i = 0;\n        for (const auto x: new_queries) {\n            int price = x[0];\n            int idx = x[1];\n\n            /*\n            We already sort queries in descending order\n            We already sort items in descending order as well.\n            If the biggest beauty come with price higher than biggest query price, then we have to skip all of it first.\n            */\n            while (i < items.size() && items[i][0] > price) i++;\n\n            /*\n            Now, we can make sure that: start from i, all the price of item is lowwer or equal to query[i]\n            Actually, we will push all the remain item in items[] in one time. (Because we already skip all non-valid item in previous while loop)\n            */\n            while (i < items.size() && items[i][0] <= price) {\n                max_heap.push({items[i][1], items[i][0]});\n                i++;\n            }\n\n            /*\n            When we enter for loop in second or third time, there is a chance that current biggest beauty come with the price \n            that is higher than the remain query, so we have to pop it out.\n            */\n            while (!max_heap.empty() && max_heap.top().second > price) max_heap.pop();\n\n            if (!max_heap.empty()) res[idx] = max_heap.top().first;\n        }\n\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "pridhi369",
                        "content": "why is time complexity a problem just for last two test cases "
                    }
                ]
            },
            {
                "id": 1914423,
                "content": [
                    {
                        "username": "_drigger",
                        "content": " `Since we can consider items smaller than current item, so we can make vector which stores largest value we encounter till now or till current item, at last use lower or upper bound as per preference to find beauty corresponds to item.`"
                    },
                    {
                        "username": "user3158w",
                        "content": "You should also mention the time complexity you expect, because it can be made in different ways with different time complexities."
                    },
                    {
                        "username": "_tofu_",
                        "content": "CPP code with detailed explanation.\n\n```\nclass Solution2 {\npublic:\n    vector<int> maximumBeauty(vector<vector<int>> &items, vector<int> &queries) {\n        int n = queries.size();\n\n        vector<vector<int>> new_queries(n);\n        for (int i = 0; i < n; i++) new_queries[i] = {queries[i], i};\n        sort(new_queries.rbegin(), new_queries.rend());// sort it in descending order\n\n        auto lambda_cmp = [&](vector<int> a, vector<int> b) {\n            if (a[1] == b[1]) return a[0] > b[0];\n            return a[1] > b[1];\n        };\n        sort(items.begin(), items.end(), lambda_cmp);// large beauty first\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, less<>> max_heap;//{beauty, price}\n        vector<int> res(n);\n\n        int i = 0;\n        for (const auto x: new_queries) {\n            int price = x[0];\n            int idx = x[1];\n\n            /*\n            We already sort queries in descending order\n            We already sort items in descending order as well.\n            If the biggest beauty come with price higher than biggest query price, then we have to skip all of it first.\n            */\n            while (i < items.size() && items[i][0] > price) i++;\n\n            /*\n            Now, we can make sure that: start from i, all the price of item is lowwer or equal to query[i]\n            Actually, we will push all the remain item in items[] in one time. (Because we already skip all non-valid item in previous while loop)\n            */\n            while (i < items.size() && items[i][0] <= price) {\n                max_heap.push({items[i][1], items[i][0]});\n                i++;\n            }\n\n            /*\n            When we enter for loop in second or third time, there is a chance that current biggest beauty come with the price \n            that is higher than the remain query, so we have to pop it out.\n            */\n            while (!max_heap.empty() && max_heap.top().second > price) max_heap.pop();\n\n            if (!max_heap.empty()) res[idx] = max_heap.top().first;\n        }\n\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "pridhi369",
                        "content": "why is time complexity a problem just for last two test cases "
                    }
                ]
            }
        ]
    }
]