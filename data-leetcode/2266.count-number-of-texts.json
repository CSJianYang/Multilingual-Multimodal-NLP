[
    {
        "title": "Maximum Candies Allocated to K Children",
        "question_content": "You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.\nYou are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can take at most one pile of candies and some piles of candies may go unused.\nReturn the maximum number of candies each child can get.\n&nbsp;\nExample 1:\n\nInput: candies = [5,8,6], k = 3\nOutput: 5\nExplanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.\n\nExample 2:\n\nInput: candies = [2,5], k = 11\nOutput: 0\nExplanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= candies.length <= 105\n\t1 <= candies[i] <= 107\n\t1 <= k <= 1012",
        "solutions": [
            {
                "id": 1908888,
                "title": "java-c-python-binary-search-with-explanation",
                "content": "# **Intuition**\\nBinary search\\n<br>\\n\\n# **Explanation**\\nAssume we want give each child `m` candies, for each pile of `candies[i]`,\\nwe can divide out at most `candies[i] / m` sub piles with each pile `m` candies.\\n\\nWe can sum up all the sub piles we can divide out, then compare with the `k` children.\\n\\nIf `k > sum`, \\nwe don\\'t allocate to every child, \\nsince the pile of `m` candidies it too big,\\nso we assign `right = m - 1`.\\n\\nIf `k <= sum`, \\nwe are able to allocate to every child, \\nsince the pile of `m` candidies is small enough\\nso we assign `left = m`.\\n\\nWe repeatly do this until `left == right`, and that\\'s the maximum number of candies each child can get.\\n<br>\\n\\n# **Tips**\\nTip1.  `left < right` Vs `left <= right`\\n\\nCheck all my solution, I keep using `left < right`.\\nThe easy but important approach: \\nfollow and upvote my codes,\\ntry to do the same.\\nyou\\'ll find all binary search is similar,\\nnever bother thinking it anymore.\\n\\nTip2. `mid = (left + right + 1) / 2` Vs `mid = (left + right) / 2`\\n\\n`mid = (left + right) / 2` to find **first** element valid\\n`mid = (left + right + 1) / 2 `to find **last** element valid\\n<br>\\n\\n# **Complexity**\\nTime `O(nlog10000000)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximumCandies(int[] A, long k) {\\n        int left = 0, right = 10_000_000;\\n        while (left < right) {\\n            long sum = 0;\\n            int mid = (left + right + 1) / 2;\\n            for (int a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = 1e7;\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maximumCandies(self, A, k):\\n        left, right = 0, sum(A) / k\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            if k > sum(a / mid for a in A):\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return left\\n```\\n<br>\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 2226. [Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908888/JavaC%2B%2BPython-Binary-Search-with-Explanation)\\n- 1802. [Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/discuss/1119801/Python-Binary-Search)\\n- 1539. [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC++Python-O(logN))\\n- 1482. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maximumCandies(int[] A, long k) {\\n        int left = 0, right = 10_000_000;\\n        while (left < right) {\\n            long sum = 0;\\n            int mid = (left + right + 1) / 2;\\n            for (int a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\n```cpp\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = 1e7;\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\n```py\\n    def maximumCandies(self, A, k):\\n        left, right = 0, sum(A) / k\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            if k > sum(a / mid for a in A):\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1908695,
                "title": "binary-search",
                "content": "Say we decide to allocate `m` candies. We can check if all `k` kids can get `m` candies in O(n).\\n\\nTherefore, we can binary-search for the maximum value `m`. The overall runtime complexity will be O(n * log m), where `m` is maximum number of candies in a single pile (10000000).\\n\\nThe fact that we can split piles could be confusing. But it simply means that we can distribute `m` candies to ` candies[i] / m` children from pile `i`.\\n\\n**C++**\\n```cpp    \\nint maximumCandies(vector<int>& candies, long long k) {\\n    int l = 0, r = 10000000;\\n    while(l < r) {\\n        long long m = (l + r + 1) / 2, cnt = 0;\\n        for (int i = 0; i < candies.size() && cnt < k; ++i)\\n            cnt += candies[i] / m;\\n        if (cnt >= k)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nint maximumCandies(vector<int>& candies, long long k) {\\n    int l = 0, r = 10000000;\\n    while(l < r) {\\n        long long m = (l + r + 1) / 2, cnt = 0;\\n        for (int i = 0; i < candies.size() && cnt < k; ++i)\\n            cnt += candies[i] / m;\\n        if (cnt >= k)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908738,
                "title": "c-easy-solution-with-explanation",
                "content": "Lets see about the brute force solution.\\n\\nWe can check for candies=1,2 and so,on until we find an answer.\\n\\nCan\\'t we do something better,instead of linear search ?.\\n\\nYes, we can do **binary search.**\\n \\nIf we can divide the candies into piles containing x number of candies all the numbers below x,\\nwill also be satisfied.\\n\\nIn this question we have to find the maximum number of candies.\\n\\nLets see the lowest value is 1 and highest value as the maximum element in candies.\\n\\nNow we will find the mid, and we will check weather we can divide mid amount of candies into piles \\nsuch that they will be sufficient for k children.\\n\\nFinally we return the ans.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    bool solve(vector<int>& v, ll mid, ll k){\\n        int n = v.size();\\n        ll cnt = 0;\\n        for(int i=0;i<n;i++){\\n            cnt += (v[i]/mid);\\n            if(cnt>=k) return true;\\n        }\\n        return false;\\n    }\\n    \\n    // v is the candies vector.\\n    int maximumCandies(vector<int>& v, long long k) {\\n        int n = v.size();\\n\\t\\tint mx = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tmx = max(mx,v[i]);\\n        }\\n        \\n        ll low = 1, high = mx;\\n        ll ans = 0;\\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(solve(v,mid,k)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity= O(nlogp)   // p is the maximum candy.\\nSpace Complexity- O(1);**\\n\\n\\nUpvote if it helps!!\\nThank you!!\\n\\nMore binary search problems:\\n\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\nhttps://leetcode.com/problems/find-the-duplicate-number/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/\\nhttps://leetcode.com/problems/most-beautiful-item-for-each-query/\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nhttps://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\nhttps://leetcode.com/problems/heaters/\\nhttps://leetcode.com/problems/minimum-absolute-sum-difference/\\nhttps://leetcode.com/problems/frequency-of-the-most-frequent-element/",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    bool solve(vector<int>& v, ll mid, ll k){\\n        int n = v.size();\\n        ll cnt = 0;\\n        for(int i=0;i<n;i++){\\n            cnt += (v[i]/mid);\\n            if(cnt>=k) return true;\\n        }\\n        return false;\\n    }\\n    \\n    // v is the candies vector.\\n    int maximumCandies(vector<int>& v, long long k) {\\n        int n = v.size();\\n\\t\\tint mx = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tmx = max(mx,v[i]);\\n        }\\n        \\n        ll low = 1, high = mx;\\n        ll ans = 0;\\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(solve(v,mid,k)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908797,
                "title": "binary-search-solution-with-explanation-java-o-n-log-max-candies",
                "content": "Simple Binary Search Solution | Java | O(n log(max(candies)))\\n\\n**Idea**:\\nBrute force :Start with 1 candy and see if we can allocate. If yes, then check for 2 candy. \\nOptimization: Instead of checking every candy at a time, why can\\'t we directly check for a number to see if we can allocate that many candy. This way we reduce our search space. Best way to do it is binary search.\\n\\n**Approach**:\\nFirst go through each pile and store the maximum of candy of that pile.\\nNow your seach space will be `[0 - max]`. Now, we will pick `mid` from that and check if we can allocate that many candies to k children. If yes, update `lo`, if not update `hi`.\\n0 is trickey number because you can always allocate that many candies. So, at the end I do a check one more time on lo to see if I can allocate that candies. otherwise return lo-1.\\n\\n**TimeComplexity**:\\n`O(n)` to check if you can allocate x candies to k people\\ncalling above function `log(max(candies))`.\\nSo, overall time complexity `O(n log(max(candies)))`\\n\\n**Upvote if it helps. Thanks :)**\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        int max = 0;\\n        for(int candy : candies)\\n            max = Math.max(max, candy);\\n        int lo = 0, hi = max;\\n        \\n        while(lo < hi) {            \\n            int mid = lo + (hi-lo)/2;\\n            if(canAllocate(candies, k, mid)) {\\n                lo = mid+1;\\n            } else {\\n                hi = mid ;\\n            }\\n        }  \\n        return canAllocate(candies, k, lo) ? lo : lo-1;\\n    }\\n    \\n    public boolean canAllocate(int[] candies, long k, int allow) {\\n        if(allow == 0)\\n            return true;\\n        long total = 0;\\n        for(int candy : candies) {\\n            total += candy / allow;\\n            if(total >= k)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        int max = 0;\\n        for(int candy : candies)\\n            max = Math.max(max, candy);\\n        int lo = 0, hi = max;\\n        \\n        while(lo < hi) {            \\n            int mid = lo + (hi-lo)/2;\\n            if(canAllocate(candies, k, mid)) {\\n                lo = mid+1;\\n            } else {\\n                hi = mid ;\\n            }\\n        }  \\n        return canAllocate(candies, k, lo) ? lo : lo-1;\\n    }\\n    \\n    public boolean canAllocate(int[] candies, long k, int allow) {\\n        if(allow == 0)\\n            return true;\\n        long total = 0;\\n        for(int candy : candies) {\\n            total += candy / allow;\\n            if(total >= k)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908862,
                "title": "binary-search-intutive-intution-explanation",
                "content": "Intution : We Know we had  to distribute  maximum candies , whenever face Problem in which we  have   to distribute  and finding the maximum or minium, See the Time Complexity if Time Complexity isaround 10^4, and your answer require optimal ways then think of dp solution, if Time Complexity is around 10^5 either it can be done by  sorting with greedy or binary search on ans. Now with this it was clear it is binary search on ans problem. So Just checked how can I distribute \\n1. Search space can be 1 to sum(candies), Why\\n Becuase you have to give them at least one so low = 1.\\n 2. Just find the mid and check, if distributing mid candies it is possible to distribute if yes, then reduce your search space so that more optimal ans can be find.\\n\\n**Please UPVOTE Guys , If it helps, That motivates**\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        return split>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        \\n        long long start = 1, end = sum;\\n        long long ans = 0;\\n        \\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(check(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nTime Complexity : nlog(m}\\nSpace Complexity: O(1)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1908775,
                "title": "100-faster-c-python-java-binary-search-with-logic",
                "content": "![image](https://assets.leetcode.com/users/images/82a7e416-2997-4676-929e-712206ab4b1a_1648961313.8131979.png)\\n\\n**Idea**\\n\\n* start can be taken as 1 , highest we can distribute equally is average.\\n\\n* Use Binary Search and try to distribute the candies equal to mid, if possible try to maximize it by moving on right, else if not possible try it by decreasing the value by moving on left\\n* **TC: O(NlogN) SC: O(1)**\\n\\n```\\ndef canSplit(candies, mid, k):\\n    split = 0\\n    for i in candies:\\n        split += i//mid\\n    if split >= k:\\n        return True\\n    else:\\n        return False\\n    \\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        end = sum(candies)//k\\n        start = 1\\n        ans = 0\\n        while start <= end:\\n            mid = (start + end)//2\\n            if canSplit(candies, mid, k):\\n                start = mid + 1\\n                ans = mid\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canSplit(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        long long start = 1, end = sum/k;\\n        long long ans = 0;\\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean canSplit(int[] candies, long k, long mid) {\\n        long split = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            sum += candies[i];\\n        }\\n        long start = 1, end = sum;\\n        long ans = 0;\\n        while(start <= end) {\\n            long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\ndef canSplit(candies, mid, k):\\n    split = 0\\n    for i in candies:\\n        split += i//mid\\n    if split >= k:\\n        return True\\n    else:\\n        return False\\n    \\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        end = sum(candies)//k\\n        start = 1\\n        ans = 0\\n        while start <= end:\\n            mid = (start + end)//2\\n            if canSplit(candies, mid, k):\\n                start = mid + 1\\n                ans = mid\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```\n```\\nclass Solution {\\npublic:\\n    bool canSplit(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        long long start = 1, end = sum/k;\\n        long long ans = 0;\\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canSplit(int[] candies, long k, long mid) {\\n        long split = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            sum += candies[i];\\n        }\\n        long start = 1, end = sum;\\n        long ans = 0;\\n        while(start <= end) {\\n            long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908707,
                "title": "binary-search-explained",
                "content": "**Explanation :**\\nBinary search between **[1, max(candies)]** to find the result.\\n**if we can allocate currCandy candies to k children. then update start, if not update end.**\\nSimilar Question : [https://leetcode.com/problems/koko-eating-bananas/]\\n**Time O(Nlog(MaxC))\\nSpace O(1)**\\n    \\n    \\n```\\nclass Solution {\\npublic:\\n    \\n    bool doit(int currCandy, vector<int>& candies, long long k) {\\n       \\n\\t\\t// c candies can be divided into (c/currCandy) number of piles of size currCandy.\\n        for (auto& c : candies)   k -= (c/currCandy);\\n        return k <= 0;\\n    }\\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int start(1), end(INT_MIN);\\n        for (auto& candy : candies) end = max(end, candy);\\n        \\n        while (start <= end) {\\n            int currCandy = start+(end-start)/2;\\n\\t\\t\\t// If we can divide the candies into piles containing currCandy number of candies all the numbers below currCandy can be distributed too.\\n            if (doit(currCandy, candies, k))    start = currCandy+1;\\n            else    end = currCandy-1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool doit(int currCandy, vector<int>& candies, long long k) {\\n       \\n\\t\\t// c candies can be divided into (c/currCandy) number of piles of size currCandy.\\n        for (auto& c : candies)   k -= (c/currCandy);\\n        return k <= 0;\\n    }\\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int start(1), end(INT_MIN);\\n        for (auto& candy : candies) end = max(end, candy);\\n        \\n        while (start <= end) {\\n            int currCandy = start+(end-start)/2;\\n\\t\\t\\t// If we can divide the candies into piles containing currCandy number of candies all the numbers below currCandy can be distributed too.\\n            if (doit(currCandy, candies, k))    start = currCandy+1;\\n            else    end = currCandy-1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266489,
                "title": "easy-to-understand-optimized-binary-search-approach-beginner-friendly-detail-explained",
                "content": "\\n# Approach\\n1. minimum size of candy can be 1,less than 1 can not be possible.\\n2. maximum size of candy can be maximum element of given candies array,greater than max element can not be possible.\\n3. we chose candy size by bianry search, so that we can choose in optimised time.\\n4. function func give information about that, candies array\\'s element can be divided into mid size.\\n5. In function func,\\'cnt\\' count the nummber of \\'mid\\' size candy can be divided from candies array elements.\\n6. when count of mid size candy greater than our need(k), then we return true, *i.e.*  our answer should be mid but greater than mid can be possible.\\n# Complexity\\n- Time complexity:$$O(N*logN)$$\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool func(vector<int>&pile,long long h,int mid)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<pile.size();i++)\\n        {\\n            cnt += pile[i]/mid ;\\n            if(cnt>h)\\n            return true;\\n        }\\n        return cnt>=h;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int s = 1,e = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            int mid = s+ (e-s)/2;\\n            if(func(candies,k,mid))\\n            {\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else\\n            e = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you feel this helpful then plz like and upvote this solution \\uD83D\\uDE0A\\nKEEP LEETCODING.............**\\n![upvote.png](https://assets.leetcode.com/users/images/2fccf5b3-2212-4efd-afe0-0a5ca0b80d68_1678151551.9504004.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(vector<int>&pile,long long h,int mid)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<pile.size();i++)\\n        {\\n            cnt += pile[i]/mid ;\\n            if(cnt>h)\\n            return true;\\n        }\\n        return cnt>=h;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int s = 1,e = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            int mid = s+ (e-s)/2;\\n            if(func(candies,k,mid))\\n            {\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else\\n            e = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909217,
                "title": "c-solution-100-faster",
                "content": "\"\"\"\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll left=1,right=*max_element(candies.begin(),candies.end());\\n        ll size=candies.size();\\n        ll maxi=0;\\n        while(left<=right){\\n            ll mid=left+(right-left)/2;\\n            ll temp=0;\\n            for(int i=0;i<size;i++){\\n                temp+=candies[i]/mid;\\n            }\\n            if(temp>=k){\\n                maxi=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\"\"\"\\n\\nPlease Upvote if you find it Helpful \\uD83D\\uDE42.",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll left=1,right=*max_element(candies.begin(),candies.end());\\n        ll size=candies.size();\\n        ll maxi=0;\\n        while(left<=right){\\n            ll mid=left+(right-left)/2;\\n            ll temp=0;\\n            for(int i=0;i<size;i++){\\n                temp+=candies[i]/mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1909039,
                "title": "c-binary-search-on-answer-explained-o-nlogn",
                "content": "**CONCEPT**\\n* In these type of question first we have to find search space which is the possible set of answers which this question can have. Like in this case minimum answer can be zero and maximum can be maximum of the candies not more than that. \\n* Simply apply binary search on this range [0,max] and if mid is possible answer than we will try to increase this answer by reducing our search space to [mid+1,max] else we will try to find answer in [0,mid].\\n* isPossible function tells whether is it possible to divide the candies or not. So it is implemented greedily. So i have count the maximum number of children i can distribute candies to and if it is greater than equal to k than it is possible to divide else not.\\n* Time:O(NlogN) and Space:O(1\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, long long k, long long mid){\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=mid){\\n                cnt+=(nums[i]/mid);\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(),candies.end());\\n        int n=candies.size();\\n        long long sum=0;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n            mx=max(mx,candies[i]);\\n            \\n        }\\n        \\n        long long l=1,r=mx;\\n        int res=0;\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            if(isPossible(candies,k,mid)){\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, long long k, long long mid){\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=mid){\\n                cnt+=(nums[i]/mid);\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(),candies.end());\\n        int n=candies.size();\\n        long long sum=0;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n            mx=max(mx,candies[i]);\\n            \\n        }\\n        \\n        long long l=1,r=mx;\\n        int res=0;\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            if(isPossible(candies,k,mid)){\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908820,
                "title": "c-binary-search",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Binary Answer\\n\\nBinary search in range `L = 1, R = max(A)`.\\n\\nFor a given `M = (L + R) / 2`, we test if we can give `M` candies to each child, which can be done by traversing the array once, taking `O(N)` time. \\n\\nIf possible/valid, we make `L = M + 1`; otherwise, we make `R = M - 1`.\\n\\nIn the end, since we are looking for the greatest valid number, we return `R`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/maximum-candies-allocated-to-k-children/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(sum(A)))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        long L = 1, R = *max_element(begin(A), end(A)), N = A.size();\\n        auto valid = [&](long m) {\\n            long cnt = 0;\\n            for (int n : A) {\\n                cnt += n / m;\\n                if (cnt >= k) return true;\\n            }\\n            return false;\\n        };\\n        while (L <= R) {\\n            long M = L + (R - L) / 2;\\n            if (valid(M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/maximum-candies-allocated-to-k-children/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(sum(A)))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        long L = 1, R = *max_element(begin(A), end(A)), N = A.size();\\n        auto valid = [&](long m) {\\n            long cnt = 0;\\n            for (int n : A) {\\n                cnt += n / m;\\n                if (cnt >= k) return true;\\n            }\\n            return false;\\n        };\\n        while (L <= R) {\\n            long M = L + (R - L) / 2;\\n            if (valid(M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909387,
                "title": "c-accepted-solution-binary-search-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long sum=0;\\n        \\n        int n=candies.size();\\n        \\n        //calculate sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(long long)candies[i];\\n        }\\n        \\n        \\n        // if sum<k then we are not able to give a single one candy\\n        if(sum<k) return 0;\\n        \\n        \\n        long long h=sum/k;  // max possible ans cant exceed sum/k\\n        long long l=1;      // min possible ans will be 1\\n        long long res=1;\\n        \\n        \\n        //next part is just binary search\\n        while(h>=l)\\n        {\\n            long long m=(h+l)/2;\\n            long long count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count+=candies[i]/m;\\n            }\\n            \\n            if(count>=k)\\n            {\\n                res=max(res,m);\\n                l=m+1;\\n            }\\n            else\\n            {\\n                h=m-1;\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```\\n**upvote**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long sum=0;\\n        \\n        int n=candies.size();\\n        \\n        //calculate sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(long long)candies[i];\\n        }\\n        \\n        \\n        // if sum<k then we are not able to give a single one candy\\n        if(sum<k) return 0;\\n        \\n        \\n        long long h=sum/k;  // max possible ans cant exceed sum/k\\n        long long l=1;      // min possible ans will be 1\\n        long long res=1;\\n        \\n        \\n        //next part is just binary search\\n        while(h>=l)\\n        {\\n            long long m=(h+l)/2;\\n            long long count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count+=candies[i]/m;\\n            }\\n            \\n            if(count>=k)\\n            {\\n                res=max(res,m);\\n                l=m+1;\\n            }\\n            else\\n            {\\n                h=m-1;\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361579,
                "title": "c-binary-search-simple-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat comes to my mind is to check what number of candies(search space) is satisfying children.\\nSo by this intuition we can find the search space. \\n\\nMinimum candy child can  get will be 1:\\nExample: [1,2,3,4] and k=5\\nTotal 5 children and all of them should have same amount of candies\\nso for example let candy=2 now check whether we can get 2 candies from all the piles or not\\n1st pile:- candies[0]=1 and we can\\'t get 2 candies -> count=0\\n2nd pile:- candies[1]=2 we can get 2 candies -> count=1\\n3rd pile:- candies[2]=3 we can get 2 candies -> count=2\\n4th pile:- candies[3]=4 we can get total pair of 2 candy -> count=4\\n\\nAt end we can only satisfy 4 children but we need to satisfy 5 children(k=5)\\nso minimum value child can get will be 1 candy.\\n\\nMaximum candy child can get will be maximum element in candies:\\nExample candies=[1,2,3,4] and k=1\\nHere we need to satisy 1 children and it should have maximum candy we can just allocate all candy to single children \\nso maximum value of candy child can get will be 4.\\n\\nWe got our search space here\\nstart=1 and end=max_element\\n\\nNow approach is to apply binary search and check whether particular number of candies satisfies all the children or not\\nExample: candies=[5,8,6], k = 3\\nsuppose we reached mid=5 now count the number of 5 candies from each pile:\\n```\\n bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n        if(count>=k) return true;\\n        return false;\\n    }\\n```\\nWe are dividing each piles with mid value and checking how many number of 5 candies we can get.\\nFor [5,8,6]->\\n    Each child gets 1 pile of total 5 candies\\n    5/5=1 -> For first child\\n    8/5=1 -> For second child\\n    6/5=1 -> For third child\\n\\nWe can distribute max 5 candies to 3 children\\nIf count is greater or equal to children then we can distribute equal candies to all children .\\n\\n# Complexity\\n- Time complexity:\\n $$O(n(log(end)))$$ where n=candies.size() and end=max_element\\n\\n- Space complexity\\n    $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n\\n        if(count>=k) return true;\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start=1;\\n        int end=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(isSatisfying(candies,mid,k)){\\n                //we need to maximize search space so storing answer and finding anther maxi\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\n bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n        if(count>=k) return true;\\n        return false;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n\\n        if(count>=k) return true;\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start=1;\\n        int end=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(isSatisfying(candies,mid,k)){\\n                //we need to maximize search space so storing answer and finding anther maxi\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909559,
                "title": "easy-tricky-binary-search-approach-explained-along-with-code",
                "content": "# This problem is a kind of Upper Bond problem of Binary search.\\nHere we just simply have to make an binary search call by setting the min and max variables which is the range in which we have to be get the correct answer. Since we can give as minimum as 0 candies to k children because there are not many candies for everyone so our min = 0. and the maximum candies which we can give is the maximum pile of candie which is available with us because there is no way we can distribute more candies than what we have available.\\nTo Calculate mid we will use this formula **mid = min + (max-min)/2** this will give us the exact possible value of mid everytime.\\nAnd then we need a condtion to verify if the current **mid** is a right input so for that we have a condition that the number of candie pile can be divided such that all the **k** childeren should get same number of candy so we will make a boolean function to check the exact same thing which we  discussed.\\n\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int candie : candies){\\n            max = Math.max(candie,max);\\n        }\\n        \\n        int answer = 0;\\n        while(min <= max){\\n            int mid = min + (max - min)/2;\\n            if(checkIfTrue(candies,k,mid)){\\n                answer = mid;\\n                min = mid+1;\\n            }else{\\n                max = mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public boolean checkIfTrue(int[] candies,long k,int divid){\\n        long cnt = 0;\\n        for(int candie : candies){\\n            cnt += (long) Math.floor(candie/divid);\\n        }\\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int candie : candies){\\n            max = Math.max(candie,max);\\n        }\\n        \\n        int answer = 0;\\n        while(min <= max){\\n            int mid = min + (max - min)/2;\\n            if(checkIfTrue(candies,k,mid)){\\n                answer = mid;\\n                min = mid+1;\\n            }else{\\n                max = mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public boolean checkIfTrue(int[] candies,long k,int divid){\\n        long cnt = 0;\\n        for(int candie : candies){\\n            cnt += (long) Math.floor(candie/divid);\\n        }\\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182046,
                "title": "best-solution-in-c-binarysearch-on-answer",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool occurrences(int x,vector<int>& candies,long k){\\n        long ans=0;\\n        for(auto it:candies){\\n            ans+=it/x;\\n            if(ans>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int size=candies.size(),ans=-1;\\n        long sum=0;\\n        for(auto it:candies)\\n            sum+=it;\\n        if(sum<k)\\n            return 0;\\n        int ll=1,ul=sum/k,mid;\\n        while(ll<=ul){\\n            mid= (ll+ul) >> 1;\\n            if(occurrences(mid,candies,k)){\\n                ans=mid;\\n                ll=mid+1;\\n            }\\n            else\\n                ul=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool occurrences(int x,vector<int>& candies,long k){\\n        long ans=0;\\n        for(auto it:candies){\\n            ans+=it/x;\\n            if(ans>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int size=candies.size(),ans=-1;\\n        long sum=0;\\n        for(auto it:candies)\\n            sum+=it;\\n        if(sum<k)\\n            return 0;\\n        int ll=1,ul=sum/k,mid;\\n        while(ll<=ul){\\n            mid= (ll+ul) >> 1;\\n            if(occurrences(mid,candies,k)){\\n                ans=mid;\\n                ll=mid+1;\\n            }\\n            else\\n                ul=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958952,
                "title": "concise-binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &c, long long k) {\\n        long long cnt = 0;\\n        for(int i : c) cnt += i / x;\\n        return cnt < k ? false : true;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int s = 1, e = 1e9, ans = INT_MIN;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, candies, k)) ans = max(ans, m), s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans == INT_MIN ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &c, long long k) {\\n        long long cnt = 0;\\n        for(int i : c) cnt += i / x;\\n        return cnt < k ? false : true;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int s = 1, e = 1e9, ans = INT_MIN;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, candies, k)) ans = max(ans, m), s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans == INT_MIN ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434695,
                "title": "java-solution-using-binary-search",
                "content": "```\\nprivate boolean isPossible(int[] candies,int max,long k){\\n        long sum = 0;\\n        for(int i = 0; i<candies.length;i++){\\n            sum += (candies[i]/max);\\n        }\\n        if(sum>=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int s = 1;\\n        int e = 0;\\n        for(int i = 0; i< candies.length;i++){\\n            e = Math.max(e,candies[i]);                  // ans can\\'t be more than the height number in the array so take end, the max candie from array.\\n        }\\n        int ans = 0;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isPossible(candies,mid,k)){       // if posible to distribute candies with mid then store ans and increase start to mid + 1, Becoz we need maximum possible ans according to question.\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nprivate boolean isPossible(int[] candies,int max,long k){\\n        long sum = 0;\\n        for(int i = 0; i<candies.length;i++){\\n            sum += (candies[i]/max);\\n        }\\n        if(sum>=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int s = 1;\\n        int e = 0;\\n        for(int i = 0; i< candies.length;i++){\\n            e = Math.max(e,candies[i]);                  // ans can\\'t be more than the height number in the array so take end, the max candie from array.\\n        }\\n        int ans = 0;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isPossible(candies,mid,k)){       // if posible to distribute candies with mid then store ans and increase start to mid + 1, Becoz we need maximum possible ans according to question.\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1975986,
                "title": "python-easy-to-understand-50-faster",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    the problem can be tackled using binary search \\n    max_candies that can be allocated to children = max(candies)\\n    min_candies that can be allocated to children = 1\\n    \\n    we will apply binary search on finding the optimal values of candies that can be\\n    distributed to children. \\n    \"\"\"\\n    def check_fulfilment(self, candies, elem, k):\\n        count = 0\\n        for candy in candies:\\n            count+= candy // elem\\n        if count >= k:\\n            return True\\n        return False\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        low = 1\\n        high = max(candies)\\n        if sum(candies) < k:\\n            return 0\\n        while low <= high:\\n            mid = (low+high) // 2\\n            # check if I can fulfil that order\\n            status = self.check_fulfilment(candies, mid, k)\\n            if status:\\n                low = mid+1\\n            else:         \\n                high = mid-1\\n        # low is the maximum number of candies that can be  distributed\\n        return high\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    the problem can be tackled using binary search \\n    max_candies that can be allocated to children = max(candies)\\n    min_candies that can be allocated to children = 1\\n    \\n    we will apply binary search on finding the optimal values of candies that can be\\n    distributed to children. \\n    \"\"\"\\n    def check_fulfilment(self, candies, elem, k):\\n        count = 0\\n        for candy in candies:\\n            count+= candy // elem\\n        if count >= k:\\n            return True\\n        return False\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        low = 1\\n        high = max(candies)\\n        if sum(candies) < k:\\n            return 0\\n        while low <= high:\\n            mid = (low+high) // 2\\n            # check if I can fulfil that order\\n            status = self.check_fulfilment(candies, mid, k)\\n            if status:\\n                low = mid+1\\n            else:         \\n                high = mid-1\\n        # low is the maximum number of candies that can be  distributed\\n        return high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960155,
                "title": "c-discrete-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(long val,vector<int>&candies,long k){\\n        long sum = 0;\\n        for(auto it : candies){\\n            sum += (it/val);\\n        }\\n        return sum >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long start = 1, end = 1e9;\\n        while(start < end){\\n            long mid = (start + end) / 2;\\n            if(!check(mid,candies,k)){\\n                end = mid;\\n            }\\n            else start = mid+1;\\n        }\\n        return start-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long val,vector<int>&candies,long k){\\n        long sum = 0;\\n        for(auto it : candies){\\n            sum += (it/val);\\n        }\\n        return sum >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long start = 1, end = 1e9;\\n        while(start < end){\\n            long mid = (start + end) / 2;\\n            if(!check(mid,candies,k)){\\n                end = mid;\\n            }\\n            else start = mid+1;\\n        }\\n        return start-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912213,
                "title": "easy-to-understand-python-solution-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies, k):\\n        n = len(candies)\\n        left = 1  # the least number of candy in each stack we can give to each student is one\\n        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array\\n        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. \\n               # If we don\\'t have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.\\n\\n        while left <= right:  # binary search\\n            numberOfPiles = 0\\n            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack\\n\\n            for i in range(n):   # loop through the array to find the numbers of stack we can form\\n                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)\\n\\n            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute\\n                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student \\n                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student\\n            else: \\n                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies, k):\\n        n = len(candies)\\n        left = 1  # the least number of candy in each stack we can give to each student is one\\n        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array\\n        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. \\n               # If we don\\'t have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.\\n\\n        while left <= right:  # binary search\\n            numberOfPiles = 0\\n            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack\\n\\n            for i in range(n):   # loop through the array to find the numbers of stack we can form\\n                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)\\n\\n            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute\\n                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student \\n                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student\\n            else: \\n                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911684,
                "title": "1-liner-python-ruby",
                "content": "Binary-search the smallest allocation `a` that\\'s too large, the answer is 1 lower. Ruby still excels at this, though Python improved now that it supports a `key`.\\n\\nRuby:\\n```\\ndef maximum_candies(candies, k)\\n  (1..10**8).bsearch { |a| candies.sum { |c| c / a } < k } - 1\\nend\\n```\\nPython:\\n\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        return bisect_left(range(1, 10**8), True, key=lambda a: sum(c // a for c in candies) < k)\\n",
                "solutionTags": [
                    "Python",
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef maximum_candies(candies, k)\\n  (1..10**8).bsearch { |a| candies.sum { |c| c / a } < k } - 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1910012,
                "title": "c-o-n-solution-with-explanation-binary-search",
                "content": "**Code:**\\n**TC: O(N), SC: O(1)**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& candies, int mid, long long k)\\n    {\\n        //it contains piles of candies that tells whether we can distribute or not assign to children equally \\n        long count=0;\\n        for(auto it:candies)\\n        {\\n            count += it/mid;\\n        \\n            //whenever count is greater than or equal to k it tells we can distribute mid to k children and return true;\\n            if(count>=k) return true;\\n        }\\n        //when we can\\'t distribute mid piles to k children, we return false;\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        //initialize two pointers, 1 for minimum no. of candy, 1 for maximum no. of candy\\n        int min_candy = 1;\\n        int max_candy = *max_element(begin(candies), end(candies)); //we can also use for(auto it:candies) max_candy = max(max_candy, it)\\n        \\n        //use binary search for finding candies that can get by each child\\n        while(min_candy<=max_candy)\\n        {\\n            //find mid value\\n            long mid = (min_candy+max_candy)>>1;\\n            \\n            //if we can distribute mid piles of candies to k children successfully\\n            //we check for next greater candies\\n            if(isPossible(candies, mid, k))\\n            {\\n                min_candy = mid+1;\\n            }\\n            \\n            //if we can\\'t distribute mid piles of candies to k children\\n            //we check for lesser candies\\n            else\\n            {\\n                max_candy = mid-1;\\n                \\n            }\\n        }\\n        \\n        //return maxi_candies that can assign to each child\\n        return max_candy;\\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& candies, int mid, long long k)\\n    {\\n        //it contains piles of candies that tells whether we can distribute or not assign to children equally \\n        long count=0;\\n        for(auto it:candies)\\n        {\\n            count += it/mid;\\n        \\n            //whenever count is greater than or equal to k it tells we can distribute mid to k children and return true;\\n            if(count>=k) return true;\\n        }\\n        //when we can\\'t distribute mid piles to k children, we return false;\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        //initialize two pointers, 1 for minimum no. of candy, 1 for maximum no. of candy\\n        int min_candy = 1;\\n        int max_candy = *max_element(begin(candies), end(candies)); //we can also use for(auto it:candies) max_candy = max(max_candy, it)\\n        \\n        //use binary search for finding candies that can get by each child\\n        while(min_candy<=max_candy)\\n        {\\n            //find mid value\\n            long mid = (min_candy+max_candy)>>1;\\n            \\n            //if we can distribute mid piles of candies to k children successfully\\n            //we check for next greater candies\\n            if(isPossible(candies, mid, k))\\n            {\\n                min_candy = mid+1;\\n            }\\n            \\n            //if we can\\'t distribute mid piles of candies to k children\\n            //we check for lesser candies\\n            else\\n            {\\n                max_candy = mid-1;\\n                \\n            }\\n        }\\n        \\n        //return maxi_candies that can assign to each child\\n        return max_candy;\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909538,
                "title": "easy-understandable-java-accepted",
                "content": "```\\nclass Solution {\\n    public static int maximumCandies(int[] arr, long k) {\\n\\t\\tArrays.sort(arr);\\n\\t\\tint low = 1;\\n\\t\\tint right = arr[arr.length - 1];\\n\\t\\twhile (low <= right) {\\n\\t\\t\\tint mid = (right - low) / 2 + low;\\n\\t\\t\\tif (helper(arr, k, mid)) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn right;\\n\\t}\\n\\n\\tpublic static boolean helper(int[] arr, long k, int mid) {\\n\\t\\tlong curr = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0 && curr < k; i--) {\\n\\t\\t\\tcurr += arr[i] / mid;\\n\\t\\t}\\n\\t\\treturn curr >= k;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public static int maximumCandies(int[] arr, long k) {\\n\\t\\tArrays.sort(arr);\\n\\t\\tint low = 1;\\n\\t\\tint right = arr[arr.length - 1];\\n\\t\\twhile (low <= right) {\\n\\t\\t\\tint mid = (right - low) / 2 + low;\\n\\t\\t\\tif (helper(arr, k, mid)) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn right;\\n\\t}\\n\\n\\tpublic static boolean helper(int[] arr, long k, int mid) {\\n\\t\\tlong curr = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0 && curr < k; i--) {\\n\\t\\t\\tcurr += arr[i] / mid;\\n\\t\\t}\\n\\t\\treturn curr >= k;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909171,
                "title": "intuition-behind-binary-search-on-answers",
                "content": "<br>\\n\\n`When there are multiple answers that are valid but we need to find the maximum possible valid answer or minimum possible valid answer then we can use binary search on answers.`\\n\\n**How does it work ?**\\n\\nin this problem we know that minimum number of candies that we can allocate is 0 and maximum is max(candies), so in all such problems we need to find the **minimum possible answer** and **maximum possible answer** and binary search between them to find **maximum / minimum valid answer** in logarithmic time.\\n\\nAnd binary search on answers can be used only in those problems in which **we can validate whether the current answer in valid or not**. In this problem we can do that by checking if we can allocate x number of candies among k children by dividing some piles, so we can do binary search here.\\n\\n<br>\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int left = 1, ans = 0;\\n        int right = *max_element(candies.begin(), candies.end());\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(canAllocate(candies, k, mid)) {\\n                left = mid + 1;\\n                ans = mid;\\n            }\\n            else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\nprivate:\\n    bool canAllocate(vector<int>& candies, long long k, int candy) {\\n        \\n        long long total = 0;\\n        \\n        for(int c: candies) {\\n            total += c / candy;\\n            if(total >= k) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n<br>\\n\\n**Time complexity: O(n) * log(max(candies))\\nSpace complexity: O(1)**\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int left = 1, ans = 0;\\n        int right = *max_element(candies.begin(), candies.end());\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(canAllocate(candies, k, mid)) {\\n                left = mid + 1;\\n                ans = mid;\\n            }\\n            else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\nprivate:\\n    bool canAllocate(vector<int>& candies, long long k, int candy) {\\n        \\n        long long total = 0;\\n        \\n        for(int c: candies) {\\n            total += c / candy;\\n            if(total >= k) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909087,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,h=0;\\n        for(int& t:candies)\\n            h+=t;\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long val=0;\\n            for(auto t:candies)\\n                val+=(t/mid);\\n            if(val>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,h=0;\\n        for(int& t:candies)\\n            h+=t;\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long val=0;\\n            for(auto t:candies)\\n                val+=(t/mid);\\n            if(val>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908890,
                "title": "javascript-2226-maximum-candies-allocated-to-k-children",
                "content": "\\n**Weekly Contest 287**\\n\\n- Q1 answer\\n  - https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/discuss/1908839/JavaScript-2224.-Minimum-Number-of-Operations-to-Convert-Time\\n- Q2 answer\\n  - https://leetcode.com/problems/find-players-with-zero-or-one-losses/discuss/1908871/JavaScript-2225.-Find-Players-With-Zero-or-One-Losses\\n- Q3 answer\\n  - https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908890/JavaScript-2226.-Maximum-Candies-Allocated-to-K-Children\\n  - **below**\\n    - Similar to some other DP problems, but this is greedy\\n    - **Less code** solution\\n    - **More code - with comments** solution\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Less code** solution\\n\\n```\\nvar maximumCandies = function (candies, k) {\\n    function ok(min_candy) {\\n        let count = 0;\\n        for (let candy of candies) count += Math.floor(candy / min_candy);\\n        return count >= k;\\n    }\\n\\n    let l = 0,\\n        h = Math.max(...candies);\\n\\n    while (l <= h) {\\n        let m = l + Math.trunc((h - l) / 2);\\n        if (ok(m)) l = m + 1;\\n        else h = m - 1;\\n    }\\n    return h;\\n};\\n```\\n\\n---\\n\\n**More code - with comments** solution\\n\\n```\\nvar maximumCandies = function (cand, k) {\\n    function is_good_number_of_candies(cmin) {\\n        let count = 0;\\n        for (let c of cand) {\\n            count += Math.trunc(c / cmin); // how many mins (cmin) can we give from this pile (c)\\n        }\\n        return count >= k;\\n    }\\n\\n    let sum = cand.reduce((sum, x) => sum + x, 0);\\n    if (sum < k) return 0; // not enough, to give at least 1 candy\\n\\n    let lo = 1; // 1 is possible\\n    let hi = cand.reduce((max, x) => Math.max(max, x), -Infinity); // max possible\\n\\n    // since # of candies are too large, try binary search\\n    while (lo <= hi) {\\n        let mid = lo + Math.trunc((hi - lo) / 2);\\n        if (is_good_number_of_candies(mid)) {\\n            lo = mid + 1; // mid is good (##), try next one\\n        } else {\\n            hi = mid - 1;\\n        }\\n    }\\n    return lo - 1; // last good was mid, 1 below lo (## above)\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCandies = function (candies, k) {\\n    function ok(min_candy) {\\n        let count = 0;\\n        for (let candy of candies) count += Math.floor(candy / min_candy);\\n        return count >= k;\\n    }\\n\\n    let l = 0,\\n        h = Math.max(...candies);\\n\\n    while (l <= h) {\\n        let m = l + Math.trunc((h - l) / 2);\\n        if (ok(m)) l = m + 1;\\n        else h = m - 1;\\n    }\\n    return h;\\n};\\n```\n```\\nvar maximumCandies = function (cand, k) {\\n    function is_good_number_of_candies(cmin) {\\n        let count = 0;\\n        for (let c of cand) {\\n            count += Math.trunc(c / cmin); // how many mins (cmin) can we give from this pile (c)\\n        }\\n        return count >= k;\\n    }\\n\\n    let sum = cand.reduce((sum, x) => sum + x, 0);\\n    if (sum < k) return 0; // not enough, to give at least 1 candy\\n\\n    let lo = 1; // 1 is possible\\n    let hi = cand.reduce((max, x) => Math.max(max, x), -Infinity); // max possible\\n\\n    // since # of candies are too large, try binary search\\n    while (lo <= hi) {\\n        let mid = lo + Math.trunc((hi - lo) / 2);\\n        if (is_good_number_of_candies(mid)) {\\n            lo = mid + 1; // mid is good (##), try next one\\n        } else {\\n            hi = mid - 1;\\n        }\\n    }\\n    return lo - 1; // last good was mid, 1 below lo (## above)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908756,
                "title": "c-binary-search-fastest",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& c , long long mid){\\n        int n = c.size();\\n        long long cnt = 0;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            cnt += (c[i]/mid);\\n        }\\n        return cnt;\\n    }\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long sol = 0;\\n        int n = c.size();\\n        int low = 1;\\n        int high = *max_element(c.begin(),c.end());\\n        while(low <= high){\\n            long long mid = (high+low)/2;\\n            cout<<mid<<\" \";\\n            if(solve(c,mid) >= k){\\n                sol = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return sol;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& c , long long mid){\\n        int n = c.size();\\n        long long cnt = 0;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            cnt += (c[i]/mid);\\n        }\\n        return cnt;\\n    }\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long sol = 0;\\n        int n = c.size();\\n        int low = 1;\\n        int high = *max_element(c.begin(),c.end());\\n        while(low <= high){\\n            long long mid = (high+low)/2;\\n            cout<<mid<<\" \";\\n            if(solve(c,mid) >= k){\\n                sol = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return sol;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3925584,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& arr, long long k) {\\n          long long int result = 0 ;\\n          long long int low  = 1;\\n          auto it = max_element(arr.begin() , arr.end());\\n          long long int high = (long long int)(*it);\\n          int n = arr.size();\\n          while(low <= high){\\n              long long int mid = low + (high - low)/2;\\n              long long int count = 0;\\n              for(int i = 0 ; i < n ; i++){\\n                  count += ((long long int)arr[i] / mid);\\n                  if(count >= k)break;\\n              }\\n              if(count >= k){\\n                   result = mid;\\n                   low = mid + 1;\\n               }else{\\n                   high = mid - 1;\\n              }\\n          }\\n          return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& arr, long long k) {\\n          long long int result = 0 ;\\n          long long int low  = 1;\\n          auto it = max_element(arr.begin() , arr.end());\\n          long long int high = (long long int)(*it);\\n          int n = arr.size();\\n          while(low <= high){\\n              long long int mid = low + (high - low)/2;\\n              long long int count = 0;\\n              for(int i = 0 ; i < n ; i++){\\n                  count += ((long long int)arr[i] / mid);\\n                  if(count >= k)break;\\n              }\\n              if(count >= k){\\n                   result = mid;\\n                   low = mid + 1;\\n               }else{\\n                   high = mid - 1;\\n              }\\n          }\\n          return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601419,
                "title": "binary-search-c-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere i apply **Binary Search Algorithm** to find out Maximum Number of candies.\\n\\nMaximum Number of Candies Always Belong to range **[1 , Maximum of array]** , number of Maximum Candies can be any Element from this sorted array that satisfy the given condition-\\n**[1,2,3,4,5,6,7,8,9...........Maximum of given array]**\\n\\nFirst  = 1 \\nLast   = Maximum\\n\\nFind Index That Satisfy the Given Condition(allocate piles of candies to k children such that each child gets the same number of candies) ?\\n\\n**Note:-Here I also apply the same approach, have a look at these problems and try to solve with the same approach.**\\n\\n**Problem:-** https://leetcode.com/problems/koko-eating-bananas/description/\\n**Solution:-** https://leetcode.com/problems/koko-eating-bananas/solutions/3601174/binary-search-c-with-explanation/\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,long long k,int n)\\n    {\\n        long long count = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        count+=(arr[i]/n);\\n        \\n        if(count>=k)\\n        return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        \\n           int n = arr.size(),ans = 0;\\n           int first = 1,last = INT_MIN;\\n\\n           for(int i = 0;i<n;i++)\\n           last = max(last,arr[i])+1;\\n        \\n           while(first<last)\\n           {\\n               int mid = (first+last)/2;\\n\\n               if(check(arr,k,mid))\\n               {\\n                   first = mid+1;\\n                   ans = max(ans,mid);\\n               }\\n               else\\n               last = mid;\\n           }\\n           \\n           return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/4d957791-93e7-424e-a2ba-a546017c5145_1685983637.253224.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,long long k,int n)\\n    {\\n        long long count = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        count+=(arr[i]/n);\\n        \\n        if(count>=k)\\n        return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        \\n           int n = arr.size(),ans = 0;\\n           int first = 1,last = INT_MIN;\\n\\n           for(int i = 0;i<n;i++)\\n           last = max(last,arr[i])+1;\\n        \\n           while(first<last)\\n           {\\n               int mid = (first+last)/2;\\n\\n               if(check(arr,k,mid))\\n               {\\n                   first = mid+1;\\n                   ans = max(ans,mid);\\n               }\\n               else\\n               last = mid;\\n           }\\n           \\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365306,
                "title": "using-binary-search-on-answer-explanation",
                "content": "instead of applying binary search directly on array we will apply binary search on the range of the answer.\\n\\nlow = 1 because there can be minimum 1 candy in the array\\nhigh = maximum in the array because that is the maaximum amount of candies that can be present in the pile\\n\\n\\nnow we want to validate each mid that we will get \\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies (int[] candies, long k) {\\n        int max = 0;\\n        for (int i : candies) {\\n            max = (max > i) ? max : i;\\n        }\\n        int start = 1, end = max, mid = 0, res = 0;\\n        while (start <= end) {\\n            mid = start + (end - start) / 2;\\n            if (isValid(candies, k, mid)) {\\n                res = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    private boolean isValid(int[] candies, long k, int mid) {\\n        long totalPiles = 0;\\n        for (int i : candies) {\\n            int toAdd = i / mid;\\n            totalPiles += toAdd;\\n        }\\n        return totalPiles >= k;\\n    }\\n\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies (int[] candies, long k) {\\n        int max = 0;\\n        for (int i : candies) {\\n            max = (max > i) ? max : i;\\n        }\\n        int start = 1, end = max, mid = 0, res = 0;\\n        while (start <= end) {\\n            mid = start + (end - start) / 2;\\n            if (isValid(candies, k, mid)) {\\n                res = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    private boolean isValid(int[] candies, long k, int mid) {\\n        long totalPiles = 0;\\n        for (int i : candies) {\\n            int toAdd = i / mid;\\n            totalPiles += toAdd;\\n        }\\n        return totalPiles >= k;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272035,
                "title": "c-binary-search-on-search-space-easy-solution",
                "content": "**Time Complexity : O(n*logm)** , where m is the maximum number of candies in the single pile.\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& candies, long long k, int max_candies){\\n        long long child_cnt = 0;\\n        \\n        for(auto candies: candies)\\n            child_cnt += candies/max_candies;\\n        \\n        return child_cnt >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start = 1;\\n        int end = *max_element(candies.begin(), candies.end());\\n        int res = 0;\\n\\t\\t\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(candies, k, mid)){\\n                res = mid;\\n                start = mid+1;\\n            }\\n            else\\n                end = mid-1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nUpvote if this helps.\\nThanks!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& candies, long long k, int max_candies){\\n        long long child_cnt = 0;\\n        \\n        for(auto candies: candies)\\n            child_cnt += candies/max_candies;\\n        \\n        return child_cnt >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start = 1;\\n        int end = *max_element(candies.begin(), candies.end());\\n        int res = 0;\\n\\t\\t\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(candies, k, mid)){\\n                res = mid;\\n                start = mid+1;\\n            }\\n            else\\n                end = mid-1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269073,
                "title": "easy-java-code-beats-99",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the range of candies to be distributed then,\\nUse Binary Search to find the maximum number of candies distributed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long sum = 0;\\n        for(int i = 0 ; i < candies.length; i++){\\n            sum+= candies[i];\\n        }\\n        int left = 1;\\n        int right = (int)(sum/k);\\n        // System.out.println(sum+\" \"+right);\\n        \\n        while(left <= right){\\n            int mid = (right - left) / 2 + left;\\n            long count = 0;\\n            \\n            for(int i = 0 ; i < candies.length; i++){\\n                count+= candies[i]/mid;\\n            }\\n            if(count >= k){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long sum = 0;\\n        for(int i = 0 ; i < candies.length; i++){\\n            sum+= candies[i];\\n        }\\n        int left = 1;\\n        int right = (int)(sum/k);\\n        // System.out.println(sum+\" \"+right);\\n        \\n        while(left <= right){\\n            int mid = (right - left) / 2 + left;\\n            long count = 0;\\n            \\n            for(int i = 0 ; i < candies.length; i++){\\n                count+= candies[i]/mid;\\n            }\\n            if(count >= k){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157693,
                "title": "java-sol-easy-binary-search-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 1;\\n        int high = Arrays.stream(candies).max().getAsInt();\\n        int ans = 0;\\n        while (low<=high) {\\n            int mid = low + (high-low)/2;\\n            long currAns = 0;\\n            for (int i : candies) {\\n                currAns += i/mid;\\n            }\\n            if (currAns >= k) {\\n                low = mid+1;\\n                ans = Math.max(ans, mid);\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 1;\\n        int high = Arrays.stream(candies).max().getAsInt();\\n        int ans = 0;\\n        while (low<=high) {\\n            int mid = low + (high-low)/2;\\n            long currAns = 0;\\n            for (int i : candies) {\\n                currAns += i/mid;\\n            }\\n            if (currAns >= k) {\\n                low = mid+1;\\n                ans = Math.max(ans, mid);\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911441,
                "title": "binary-search-method",
                "content": "class Solution {\\npublic:\\n    bool allocation(vector<int>& candies,long long k,long long mid){\\n        if(mid==0) return true;\\n        \\n        long long q=0;\\n        long long count=0;\\n         for(int i=0;i<candies.size();i++){\\n            int q=candies[i]/mid;\\n            count+=q;\\n            if(count>=k){\\n               return true;\\n              }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int ans=0;\\n        for(int i=0;i<candies.size();i++){\\n          ans=max(ans,candies[i]);\\n        }  \\n        long long low=0,high=ans;\\n        while(low<high){\\n            long long mid=(low+high)/2;\\n            \\n            if(allocation(candies,k,mid)){\\n                low=mid+1;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n       \\n       return allocation(candies,k,low)?low:low-1;\\n        \\n       \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool allocation(vector<int>& candies,long long k,long long mid){\\n        if(mid==0) return true;\\n        \\n        long long q=0;\\n        long long count=0;\\n         for(int i=0;i<candies.size();i++){\\n            int q=candies[i]/mid;\\n            count+=q;\\n            if(count>=k){\\n               return true;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1911109,
                "title": "c-simple-binary-search-solution-o-n-log-max-candies",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int mid, long long k){\\n        long long count = 0;\\n        for(int i : arr){\\n            count += (i/mid);\\n        }\\n        \\n        return (count >= k);\\n    }\\n    \\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int lo = 1, hi = *max_element(arr.begin(),arr.end()),ans = 0;        \\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,mid,k)){\\n                ans = mid;\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int mid, long long k){\\n        long long count = 0;\\n        for(int i : arr){\\n            count += (i/mid);\\n        }\\n        \\n        return (count >= k);\\n    }\\n    \\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int lo = 1, hi = *max_element(arr.begin(),arr.end()),ans = 0;        \\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,mid,k)){\\n                ans = mid;\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909817,
                "title": "c-binary-search",
                "content": "```\\n  bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n  bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909667,
                "title": "c-binary-search-solution",
                "content": "**Please Upvote If It Helps**\\n```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int>& candies,long long k)\\n    {\\n        // it will containg the count that will tell we can assign or not assign candies to children \\n        long sum = 0;\\n        for(auto it : candies)\\n        {\\n            sum += (it/mid);\\n            \\n            // if any time our sum is reches to k childrens it means we can assign so return true\\n            if(sum>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        // initializing two pointers onr for min one for max\\n        // our answer lies between both of them it is final\\n        long left  = 1;\\n        long right = *max_element(begin(candies), end(candies));\\n        \\n        // applyting the binary search for searching that element\\n        while(left<=right)\\n        {\\n            // deriving mid value\\n            long mid = left+(right-left)/2;\\n            \\n            // if we can assign mid candies to k childrens successfully \\n            // then can check for next bigger value\\n            if(valid(mid,candies,k))\\n            {\\n                left = mid+1;\\n            }\\n            \\n            // if we can not assign mid candies to k childrens successfully\\n            // then can check for lesser value\\n            else\\n            {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int>& candies,long long k)\\n    {\\n        // it will containg the count that will tell we can assign or not assign candies to children \\n        long sum = 0;\\n        for(auto it : candies)\\n        {\\n            sum += (it/mid);\\n            \\n            // if any time our sum is reches to k childrens it means we can assign so return true\\n            if(sum>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        // initializing two pointers onr for min one for max\\n        // our answer lies between both of them it is final\\n        long left  = 1;\\n        long right = *max_element(begin(candies), end(candies));\\n        \\n        // applyting the binary search for searching that element\\n        while(left<=right)\\n        {\\n            // deriving mid value\\n            long mid = left+(right-left)/2;\\n            \\n            // if we can assign mid candies to k childrens successfully \\n            // then can check for next bigger value\\n            if(valid(mid,candies,k))\\n            {\\n                left = mid+1;\\n            }\\n            \\n            // if we can not assign mid candies to k childrens successfully\\n            // then can check for lesser value\\n            else\\n            {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909092,
                "title": "java-binary-search-easy-to-understand",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. First calculate **total number** of candies. Let it be `sum`.\\n2. If `sum < k`, **return 0** we have **more children than candies**.\\n3. If `sum = k`, **return 1** as we have** as many children as candies**.\\n4. Else, perform **binary search** on **number of candies** in the range where `low = 1`, and `high = max of candies`.\\n5. Check for `mid`, if we can distribute mid number of candies to each children, then we can move `low to mid + 1`, else move` high to mid - 1.`\\n6. Store the **last satisfied mid value in `ans`**.\\n7. Return `ans`.\\n\\n**Source Code:**\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        long max = 0;\\n        \\n        for(int v : candies) {\\n            sum += v;\\n            max = Math.max(v, max);\\n        }\\n        \\n        if(sum < k)\\n            return 0;\\n        \\n        if(sum == k)\\n            return 1;\\n        \\n        long x = 1, y = max, ans = 1;\\n        \\n        while(x <= y) {\\n            long mid = (x + y) >> 1;\\n            long cur = 0;\\n            \\n            for(int v : candies) {\\n                cur += v / mid;\\n            }\\n            \\n            if(cur>= k) {\\n                ans = mid;\\n                x = mid + 1;\\n            }\\n            else\\n                y = mid - 1;\\n        }\\n        \\n        return (int) (ans);\\n        \\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(n * log(max)) // n = number of candy piles, max = max value of candy pile\\nSpace Complexity : O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        long max = 0;\\n        \\n        for(int v : candies) {\\n            sum += v;\\n            max = Math.max(v, max);\\n        }\\n        \\n        if(sum < k)\\n            return 0;\\n        \\n        if(sum == k)\\n            return 1;\\n        \\n        long x = 1, y = max, ans = 1;\\n        \\n        while(x <= y) {\\n            long mid = (x + y) >> 1;\\n            long cur = 0;\\n            \\n            for(int v : candies) {\\n                cur += v / mid;\\n            }\\n            \\n            if(cur>= k) {\\n                ans = mid;\\n                x = mid + 1;\\n            }\\n            else\\n                y = mid - 1;\\n        }\\n        \\n        return (int) (ans);\\n        \\n    }\\n}\\n```\n```\\nTime Complexity: O(n * log(max)) // n = number of candy piles, max = max value of candy pile\\nSpace Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909052,
                "title": "c-binary-search-easy-explaination-code",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    long long int maxPiles(vector<int> candies, long long int k)\\n    {\\n        long long int l = 1; // We can select an minimum 1 element\\n        long long int h = 0;\\n        for (auto i : candies)\\n        {\\n            h += i;\\n        }\\n        if (k > h)\\n        {\\n            return 0;\\n        }\\n        h /= k; // at most selection\\n                //  this ans for storing mid value\\n        int ans = 0;\\n        while (l <= h)\\n        {\\n            long long mid = (l + h) / 2;\\n            long long int count = 0;\\n            for (auto i : candies)\\n            {\\n                int tt = (i / mid);\\n                count += tt;\\n            }\\n            if (count >= k)\\n            {\\n                ans = mid; // updating mid\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k)\\n    {\\n        return maxPiles(candies, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    long long int maxPiles(vector<int> candies, long long int k)\\n    {\\n        long long int l = 1; // We can select an minimum 1 element\\n        long long int h = 0;\\n        for (auto i : candies)\\n        {\\n            h += i;\\n        }\\n        if (k > h)\\n        {\\n            return 0;\\n        }\\n        h /= k; // at most selection\\n                //  this ans for storing mid value\\n        int ans = 0;\\n        while (l <= h)\\n        {\\n            long long mid = (l + h) / 2;\\n            long long int count = 0;\\n            for (auto i : candies)\\n            {\\n                int tt = (i / mid);\\n                count += tt;\\n            }\\n            if (count >= k)\\n            {\\n                ans = mid; // updating mid\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k)\\n    {\\n        return maxPiles(candies, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908784,
                "title": "cpp-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    //checks if each children can get C candies\\n    bool isPossible(vector<int>& candies, long long C, long long k) {\\n        long long cnt = 0;\\n        for(auto c : candies) {\\n            cnt += (long long)(c/C);\\n        }\\n        \\n        return cnt >= k;\\n    }\\n    \\n    //Binary Search on ans(no. of candies each can get)\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(auto c : candies) sum += (long long)c;\\n        \\n        long long end = sum / k + 1;\\n        long long beg = 0;\\n        while(beg + 1 < end) {\\n            long long mid = (beg + end) / 2;\\n            if(isGood(candies, mid, k)) beg = mid;\\n            else end = mid;\\n        }\\n        \\n        return (int)beg;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //checks if each children can get C candies\\n    bool isPossible(vector<int>& candies, long long C, long long k) {\\n        long long cnt = 0;\\n        for(auto c : candies) {\\n            cnt += (long long)(c/C);\\n        }\\n        \\n        return cnt >= k;\\n    }\\n    \\n    //Binary Search on ans(no. of candies each can get)\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(auto c : candies) sum += (long long)c;\\n        \\n        long long end = sum / k + 1;\\n        long long beg = 0;\\n        while(beg + 1 < end) {\\n            long long mid = (beg + end) / 2;\\n            if(isGood(candies, mid, k)) beg = mid;\\n            else end = mid;\\n        }\\n        \\n        return (int)beg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908729,
                "title": "python-solution-with-binary-search-explained",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        # The lower bound is 1 and higher bound is maximum value from candies. \\n        lo, hi = 1, max(candies)\\n        # This higher bound is not generally possible except for cases like candies = [5,5,5,5] & k = 4\\n        res = 0 # Current maximum result\\n        if sum(candies) < k: # If true then we cannot give even 1 candy to each child thus return 0\\n            return 0\\n        \\n        def cal_num_of_piles(pile_size): # Criterion function\\n            count = 0\\n            for c in candies:\\n                count += c // pile_size\\n            return count >= k\\n        \\n        while lo <= hi: # Binary Search Algorithm \\n            mid = (lo + hi + 1) // 2 # Expected answer\\n            if cal_num_of_piles(mid): # Check if mid is a possible answer.\\n                res = mid # Update the current maximum answer\\n                lo = mid + 1 # Check ahead of mid\\n            else:\\n                hi = mid - 1 # Check below mid\\n        return res\\n```\\n\\n**Concept of Binary Search on Answer:**\\nThe best way to explain Binary Search the Answer is that we use binary search to guess the answer to the problem. By guessing we mean that we will get several \\u201CYES\\u201D or \\u201CNO\\u201D feedback or maybe \\u201Ctoo high\\u201D, \\u201Ctoo low\\u201D, or \\u201Cexactly\\u201D responses. Since we need the maximum answer Binary Search tries to converge on the largest possible answer till the possibility exists.\\n\\n**Binary Search on Answer has 3 basic requirements:**\\n1. The problem must have multiple possible answers. **[Range of possible solutions]**\\n2. The problem must be an optimization problem. **[Minimizing/Maximizing the result]**\\n3. We must develope a function/criterion to determine when to update left and right pointers. **[Criterion to update pointers]**\\n\\n**Observations:**\\n`For candies = [5,8,6] & k = 3` we have many possible answers: 1, 2, 3, 4, 5 all seem to work fine but we return 5 as it is the largest.\\n1. Thus we have a range of solutions and we are asked to maximize the final result. **Requirement 1 and 2 are fulfilled**.\\n2. One might feel that the possible answers must be smaller than the smallest value of an array. Eg: `for candies = [5,6,8] & k = 3` then the answer is 5. For say `candies = [7,9,13] & k = 4` the possible answers are 6, 5...2, 1. However this is not always correct. For Eg: `candies = [1,2,3,4,10] & k = 5` the possible answers are 1, 2, 3. Here we can neglect the 0th and 1st piles to get a better answer. This is because we are told that we may let some piles of candies go unused.\\n3. **Developing the criterion:** Since we only need to check if a given value can be possibly divided k times with the given candies array. Hence we get an easy update function. \\n\\t```\\n\\tdef cal_num_of_piles(pile_size):\\n\\t\\tcount = 0 # Number of divisions with current pile_size\\n\\t\\tfor c in candies:\\n\\t\\t\\tcount += c // pile_size # Add how many piles can be generated with ith candies with given pile_size\\n\\t\\treturn count >= k\\n\\t```\\n***So all three requirements are now fulfilled.***\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        # The lower bound is 1 and higher bound is maximum value from candies. \\n        lo, hi = 1, max(candies)\\n        # This higher bound is not generally possible except for cases like candies = [5,5,5,5] & k = 4\\n        res = 0 # Current maximum result\\n        if sum(candies) < k: # If true then we cannot give even 1 candy to each child thus return 0\\n            return 0\\n        \\n        def cal_num_of_piles(pile_size): # Criterion function\\n            count = 0\\n            for c in candies:\\n                count += c // pile_size\\n            return count >= k\\n        \\n        while lo <= hi: # Binary Search Algorithm \\n            mid = (lo + hi + 1) // 2 # Expected answer\\n            if cal_num_of_piles(mid): # Check if mid is a possible answer.\\n                res = mid # Update the current maximum answer\\n                lo = mid + 1 # Check ahead of mid\\n            else:\\n                hi = mid - 1 # Check below mid\\n        return res\\n```\n```\\n\\tdef cal_num_of_piles(pile_size):\\n\\t\\tcount = 0 # Number of divisions with current pile_size\\n\\t\\tfor c in candies:\\n\\t\\t\\tcount += c // pile_size # Add how many piles can be generated with ith candies with given pile_size\\n\\t\\treturn count >= k\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3822063,
                "title": "beats-100-binary-search-easy-approach",
                "content": "# Complexity\\n- Time complexity : $$O(NlogN + NlogM)$$ M = Range i.e. high-low = totSum/k-1\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        sort(begin(candies),end(candies));\\n\\n        long long totSum = accumulate(begin(candies),end(candies),0ll);\\n        if(totSum < k) return 0;\\n\\n        long long low=1 , high=totSum/k; // can also take some bigger value like 1e8\\n        while(low <= high) {\\n            long long mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,candies,k)) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return high;\\n    }\\n\\n    bool isPossible(long long mid, vector<int> &candies, long long k) {\\n        int n = candies.size();\\n        long long cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            cnt += 1ll*(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        sort(begin(candies),end(candies));\\n\\n        long long totSum = accumulate(begin(candies),end(candies),0ll);\\n        if(totSum < k) return 0;\\n\\n        long long low=1 , high=totSum/k; // can also take some bigger value like 1e8\\n        while(low <= high) {\\n            long long mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,candies,k)) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return high;\\n    }\\n\\n    bool isPossible(long long mid, vector<int> &candies, long long k) {\\n        int n = candies.size();\\n        long long cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            cnt += 1ll*(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273752,
                "title": "beats-99-easy-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long sum=0;\\n        for(auto i:candies)sum+=i;\\n        int mn=*min_element(candies.begin(),candies.end());\\n        long long s=mn/((k+n-1)/n);\\n        long long e=sum/k;\\n        long long m;\\n        while(s<=e){\\n            m=(s+e)/2;\\n            long long ct=0;\\n            if(m==0){\\n                ct=LONG_MAX;\\n            }else{\\n            for(auto i:candies){\\n                ct+=(i/m);\\n            }\\n            }\\n            if(ct<k){\\n                e=m-1;\\n            }else{\\n                s=m+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long sum=0;\\n        for(auto i:candies)sum+=i;\\n        int mn=*min_element(candies.begin(),candies.end());\\n        long long s=mn/((k+n-1)/n);\\n        long long e=sum/k;\\n        long long m;\\n        while(s<=e){\\n            m=(s+e)/2;\\n            long long ct=0;\\n            if(m==0){\\n                ct=LONG_MAX;\\n            }else{\\n            for(auto i:candies){\\n                ct+=(i/m);\\n            }\\n            }\\n            if(ct<k){\\n                e=m-1;\\n            }else{\\n                s=m+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268223,
                "title": "range-bs-runtime-174-ms-beats-98-32-must-see",
                "content": "# Code\\n```\\n//for fast io\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n//actual code\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        long long int maxele = *max_element(candies.begin(),candies.end());\\n        long long int start = 0;\\n        long long int end   = maxele;\\n        long long int ans = 0;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end-start)/2));\\n\\n            //we will try to allocate the piles to every children \\n            //having exactly mid candies\\n\\n            if(fun(candies,mid,k) == true)\\n            {\\n                if(mid > ans) ans = mid;\\n                start = mid+1;\\n            }\\n            else \\n            {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,long long int &mid,long long int &k)\\n    {\\n        if(mid == 0) return true;\\n\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (arr[i]/mid);\\n            count = count + temp;\\n        }\\n        if(count >= k) return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n//for fast io\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n//actual code\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        long long int maxele = *max_element(candies.begin(),candies.end());\\n        long long int start = 0;\\n        long long int end   = maxele;\\n        long long int ans = 0;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end-start)/2));\\n\\n            //we will try to allocate the piles to every children \\n            //having exactly mid candies\\n\\n            if(fun(candies,mid,k) == true)\\n            {\\n                if(mid > ans) ans = mid;\\n                start = mid+1;\\n            }\\n            else \\n            {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,long long int &mid,long long int &k)\\n    {\\n        if(mid == 0) return true;\\n\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (arr[i]/mid);\\n            count = count + temp;\\n        }\\n        if(count >= k) return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2962740,
                "title": "c-binary-search-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& candies, long long k, int mid) {\\n        long long n = candies.size(), candy = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            candy = candy + candies[i]/mid;\\n        }\\n\\n        if(candy >= k) \\n            return true;\\n\\n        else return false;\\n        \\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long n = candies.size(), max = INT_MIN;\\n        long long sum = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            sum = candies[i] + sum;         //calculating sum of all candies\\n            if(candies[i] > max) {          //calculating minimum pile of candy\\n                max = candies[i];\\n            }\\n        }\\n\\n        if(sum < k) {\\n            return 0;       // bcoz no. children is more than total candy\\n        }\\n\\n        long long start = 1, end = max, ans = 0;\\n        long long mid = start + (end - start)/2;\\n\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n\\n            if(solve(candies, k, mid)) {\\n                start = mid + 1;\\n                ans = mid;\\n            }\\n\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(n log m)\\n\\n- Space complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& candies, long long k, int mid) {\\n        long long n = candies.size(), candy = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            candy = candy + candies[i]/mid;\\n        }\\n\\n        if(candy >= k) \\n            return true;\\n\\n        else return false;\\n        \\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long n = candies.size(), max = INT_MIN;\\n        long long sum = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            sum = candies[i] + sum;         //calculating sum of all candies\\n            if(candies[i] > max) {          //calculating minimum pile of candy\\n                max = candies[i];\\n            }\\n        }\\n\\n        if(sum < k) {\\n            return 0;       // bcoz no. children is more than total candy\\n        }\\n\\n        long long start = 1, end = max, ans = 0;\\n        long long mid = start + (end - start)/2;\\n\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n\\n            if(solve(candies, k, mid)) {\\n                start = mid + 1;\\n                ans = mid;\\n            }\\n\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836560,
                "title": "simple-c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool good(int x , long long k , vector<int> &arr ){\\n        long long ct = 0;\\n        for(int i=0 ; i<n ; i++){\\n            ct += (arr[i]/x);\\n        }\\n        return (ct>=k);\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int low = 1;\\n        int high = 1e9+1;\\n        n = arr.size();\\n        int ans = 0;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(good(mid , k , arr)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// [4,7,5]\\n// 4\\n\\n// op -> 3\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool good(int x , long long k , vector<int> &arr ){\\n        long long ct = 0;\\n        for(int i=0 ; i<n ; i++){\\n            ct += (arr[i]/x);\\n        }\\n        return (ct>=k);\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int low = 1;\\n        int high = 1e9+1;\\n        n = arr.size();\\n        int ans = 0;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(good(mid , k , arr)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// [4,7,5]\\n// 4\\n\\n// op -> 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565461,
                "title": "99-faster-python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/8f3fb19a-40a0-4acf-9475-84ea66780864_1662967246.5710497.png)\\n\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k:return 0\\n        else:\\n            low=0 \\n            high=max(candies)\\n            while low<high:\\n                mid=math.ceil((low+high)/2)\\n                if sum(c//mid for c in candies)>=k: low=mid\\n                else: high=mid-1\\n            return low\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k:return 0\\n        else:\\n            low=0 \\n            high=max(candies)\\n            while low<high:\\n                mid=math.ceil((low+high)/2)\\n                if sum(c//mid for c in candies)>=k: low=mid\\n                else: high=mid-1\\n            return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503906,
                "title": "binary-search-ac-code-explained-with-comments",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &candies, long long k, long long mid){\\n\\n        long long total = 0;\\n        \\n        for(int i=0;i<candies.size();i++){ \\n            \\n           //Here we are maintaining the count of candies that we are distributing. \\n           total += candies[i]/mid;\\n            \\n        }\\n        \\n        //Checking if the total number of candies that can be distirbuted\\n        //for the pile of value \\'mid\\' is less than or equal to total no. of children.\\n        //If the above condition is false then we cannot divide the candies into piler of size mid\\n        return (total>=k);\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        //We will do the binary search for all the elements \\n        // from \\'1\\' to the largest value in the candies.\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        for(int i=0;i<candies.size();i++){\\n            high = max(high, candies[i]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            long long mid = (low+high)/2;\\n            \\n            //Checking if the middle element can be a valid pile.\\n            //If the function returns true than we will move to the left side to\\n            //check if even a larger answer is possible.\\n            if(isValid(candies, k, mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                //If the function returns false then we will move to the left half\\n                //to find the possible valid pile value.\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &candies, long long k, long long mid){\\n\\n        long long total = 0;\\n        \\n        for(int i=0;i<candies.size();i++){ \\n            \\n           //Here we are maintaining the count of candies that we are distributing. \\n           total += candies[i]/mid;\\n            \\n        }\\n        \\n        //Checking if the total number of candies that can be distirbuted\\n        //for the pile of value \\'mid\\' is less than or equal to total no. of children.\\n        //If the above condition is false then we cannot divide the candies into piler of size mid\\n        return (total>=k);\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        //We will do the binary search for all the elements \\n        // from \\'1\\' to the largest value in the candies.\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        for(int i=0;i<candies.size();i++){\\n            high = max(high, candies[i]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            long long mid = (low+high)/2;\\n            \\n            //Checking if the middle element can be a valid pile.\\n            //If the function returns true than we will move to the left side to\\n            //check if even a larger answer is possible.\\n            if(isValid(candies, k, mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                //If the function returns false then we will move to the left half\\n                //to find the possible valid pile value.\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442477,
                "title": "c-efficient-sol-with-explanation-complexity",
                "content": "***Explanation :***\\nAccording to question we have to find the maximum size of each pile that we can get to satisfy k children.\\nWe do this using ***Binary Search : (why?)***\\n***Binary Search can be used on following type of problems :***\\n***1. Maximization problems\\n2. Minimization problems***\\nWe binary search for the maximum size of the pile . \\n***Range of binary search :*** \\n***lo=1***, (cannot be 0 sized pile) ***hi=maximum elemnt in candies array.***\\nFor every mid value , we check if it is possible to make k or more piles of size ***mid***\\n***If yes*** , we move ***lo= mid+1***, to get maximum possible size of pile .\\n***If no*** , then we move ***hi= mid-1*** , to decrease size of pile .\\n\\n***Complexity Analysis :\\nTC : O(n log x ) ( x--> maximum elment in candies array)\\nSC : O(1)***\\n\\n**UPVOTE IF YOU LIKE** \\u2705\\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n    bool isPossible_to_divide(vector<int>&candies,long long size,long long k){\\n        long long ans=0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=(candies[i]/size);\\n        }\\n        return ans>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=1,hi=*max_element(candies.begin(),candies.end()),mid,ans=0;\\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            if(isPossible_to_divide(candies, mid, k)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else hi=mid-1;\\n        }\\n        return  ans;\\n    }\\n};\\n// Any other queries are welcomed as well.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible_to_divide(vector<int>&candies,long long size,long long k){\\n        long long ans=0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=(candies[i]/size);\\n        }\\n        return ans>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=1,hi=*max_element(candies.begin(),candies.end()),mid,ans=0;\\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            if(isPossible_to_divide(candies, mid, k)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else hi=mid-1;\\n        }\\n        return  ans;\\n    }\\n};\\n// Any other queries are welcomed as well.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402075,
                "title": "c-binary-search-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        int left = 1, right = *max_element(c.begin(), c.end());\\n        int ans = 0;\\n        while(left <= right){\\n            int Cand = (left + right) >> 1;\\n            long long sum = 0;\\n            for(auto it: c){\\n                sum += it / Cand;\\n                if(sum >= k) break;\\n            }\\n            if(sum >= k){\\n                ans = Cand;\\n                left = Cand + 1;\\n            }\\n            else{\\n                right = Cand-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        int left = 1, right = *max_element(c.begin(), c.end());\\n        int ans = 0;\\n        while(left <= right){\\n            int Cand = (left + right) >> 1;\\n            long long sum = 0;\\n            for(auto it: c){\\n                sum += it / Cand;\\n                if(sum >= k) break;\\n            }\\n            if(sum >= k){\\n                ans = Cand;\\n                left = Cand + 1;\\n            }\\n            else{\\n                right = Cand-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276939,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& c,long long k,int mid)\\n    {\\n        if(!mid)\\n            return 1;\\n      long long x=0;    \\n        for(int i=0;i<c.size();i++)\\n        {\\n            x+=(c[i]/mid);\\n        }\\n        return x>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low=0,ans=0;\\n       int high=*max_element(candies.begin(),candies.end());\\n        while(low<=high)\\n        {\\n           int mid=(high+low)>>1;\\n            if(solve(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& c,long long k,int mid)\\n    {\\n        if(!mid)\\n            return 1;\\n      long long x=0;    \\n        for(int i=0;i<c.size();i++)\\n        {\\n            x+=(c[i]/mid);\\n        }\\n        return x>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low=0,ans=0;\\n       int high=*max_element(candies.begin(),candies.end());\\n        while(low<=high)\\n        {\\n           int mid=(high+low)>>1;\\n            if(solve(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158323,
                "title": "binary-search-approach-with-detailed-explained-in-comments",
                "content": "### Please Upvote if you like this\\n\\n#### Time Complexity: Log(mx)  * O(N)\\n#### Log(mx) for binary search and O(N) for iterating through the candies array.\\n\\n#### Space Complexity: O(1) because we did use constant extra space.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n//         get the sum and mx of all candies\\n        long long sum = 0;\\n        int mx = INT_MIN;\\n//         Iterate the loop to get the sum of all values and maximum among then\\n        for(int &i: candies){\\n            sum += i;\\n            mx = max(i, mx);\\n        }\\n        \\n//         if sum < k then return 0 because it will never fulfill the k children requirements:\\n//         \"each child gets the same number of candies\" it impossible to distribute atleast 1 candy to all so return 0\\n        \\n        if(sum < k) return 0;\\n        \\n//         start pointers for binary search\\n        int start = 1, end = mx;\\n        int ans = 0;\\n        \\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end-start)/2;\\n            long long cand = 0;\\n            \\n//             take floor all values or simply write (i/mid) because it won\\'t let candies to merged\\n            for(int &i: candies){\\n                cand += floor(i/mid);\\n            }\\n            \\n//             cand >= k means that no. of mid candies can be distributed among all children. If cand >= k update the answer and search for more bigger value.\\n            if(cand >= k){\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n//             if it doesn\\'t satisfy the condition then search for lower value.\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        // return the possible answer if it is otherwise return 0 as default value of ans.\\n        return ans;\\n    }\\n};\\n```\\n### Please Upvote if you like this",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n//         get the sum and mx of all candies\\n        long long sum = 0;\\n        int mx = INT_MIN;\\n//         Iterate the loop to get the sum of all values and maximum among then\\n        for(int &i: candies){\\n            sum += i;\\n            mx = max(i, mx);\\n        }\\n        \\n//         if sum < k then return 0 because it will never fulfill the k children requirements:\\n//         \"each child gets the same number of candies\" it impossible to distribute atleast 1 candy to all so return 0\\n        \\n        if(sum < k) return 0;\\n        \\n//         start pointers for binary search\\n        int start = 1, end = mx;\\n        int ans = 0;\\n        \\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end-start)/2;\\n            long long cand = 0;\\n            \\n//             take floor all values or simply write (i/mid) because it won\\'t let candies to merged\\n            for(int &i: candies){\\n                cand += floor(i/mid);\\n            }\\n            \\n//             cand >= k means that no. of mid candies can be distributed among all children. If cand >= k update the answer and search for more bigger value.\\n            if(cand >= k){\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n//             if it doesn\\'t satisfy the condition then search for lower value.\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        // return the possible answer if it is otherwise return 0 as default value of ans.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017213,
                "title": "c-binary-search-by-value",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        // corner case\\n        long long sum = 0;\\n        for(auto c : candies){\\n            sum += c;\\n        }\\n        if(sum < k){\\n            return 0;\\n        }\\n        // binary search\\n        long long start = 1, end = *max_element(candies.begin(), candies.end());\\n        while(start < end){\\n            long long mid = start + (end - start + 1) / 2; // since we want to get the upper bound of the answers(maximum)\\n            long long count = numKidsAllocatedWithGivenCandyNum(candies, mid);\\n            if(count < k){\\n                // the number is too large, mid cannot be the answer\\n                end = mid - 1; \\n            }\\n            else{\\n                // the number is too small, but could be the answer\\n                start = mid;\\n            }\\n        }\\n        \\n        return start;\\n    }\\n    \\n    long long numKidsAllocatedWithGivenCandyNum(vector<int>& candies, int val){\\n        long long count = 0;\\n        for(auto candy : candies){\\n            count += candy / val;\\n        }\\n        return count;\\n    }\\n \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        // corner case\\n        long long sum = 0;\\n        for(auto c : candies){\\n            sum += c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2008765,
                "title": "python-binary-search",
                "content": "\\n    def maximumCandies(self, candies, k):\\n        def dfs(c):\\n            count = 0\\n            \\n            for candy in candies:\\n                count += candy//c\\n                \\n            if count >= k:\\n                return True\\n            \\n            return False\\n            \\n        low, high = 1, max(candies)\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            \\n            if dfs(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n                \\n        return high\\n",
                "solutionTags": [],
                "code": "\\n    def maximumCandies(self, candies, k):\\n        def dfs(c):\\n            count = 0\\n            \\n            for candy in candies:\\n                count += candy//c\\n                \\n            if count >= k:\\n                return True\\n            \\n            return False\\n            \\n        low, high = 1, max(candies)\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            \\n            if dfs(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n                \\n        return high\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1988406,
                "title": "python-binary-search-99",
                "content": "\\n\\n\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        total_candies = sum(candies)\\n        max_candies = total_candies//k\\n        \\n        if max_candies<=1:\\n            return max_candies\\n        \\n\\n        i, j = 2, max_candies\\n        \\n        \\n        while i<=j:\\n            candy = (i+j)//2\\n            \\n            n_pile = sum([each//candy for each in candies])\\n            \\n            if n_pile>=k: \\n                i = candy+1\\n            else: \\n                j = candy-1\\n                \\n            \\n                \\n        return candy if n_pile >= k else candy-1\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        total_candies = sum(candies)\\n        max_candies = total_candies//k\\n        \\n        if max_candies<=1:\\n            return max_candies\\n        \\n\\n        i, j = 2, max_candies\\n        \\n        \\n        while i<=j:\\n            candy = (i+j)//2\\n            \\n            n_pile = sum([each//candy for each in candies])\\n            \\n            if n_pile>=k: \\n                i = candy+1\\n            else: \\n                j = candy-1\\n                \\n            \\n                \\n        return candy if n_pile >= k else candy-1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985777,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n        }\\n        if(sum<k)return 0;\\n        if(sum==k)return 1;\\n        long ans=sum/k;\\n       // System.out.println(ans);\\n        if(ans==1)return (int)ans;\\n        long l=0;\\n        long mid=0;\\n        long h=ans;\\n\\t\\t//binary search\\n        while(l<=h){\\n            mid=l+(h-l)/2;\\n              long c=0;\\n            for(int j=0;j<n;j++){\\n                c+=(long)candies[j]/mid;\\n            }\\n            if(c>=k){\\n                ans=mid;\\n               // System.out.println(ans);\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1976270,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931345,
                "title": "kotlin-binary-search-solution",
                "content": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var (min, max, sum) = Triple(1, Integer.MIN_VALUE, 0L)\\n        candies.forEach { sum += it.also { if (it > max) max = it } }\\n        if (sum < k) return 0\\n\\n        var result = min\\n        while (max > min) {\\n            if (canEachChildGetCCandies(result, candies, k)) min = result\\n            else max = result -1\\n            result = (min + max + 1) / 2\\n        }\\n        return result\\n    }\\n\\n    fun canEachChildGetCCandies(c: Int, candies: IntArray, k: Long) =\\n        candies.fold(0L) { sum, it -> sum + it / c } >= k\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var (min, max, sum) = Triple(1, Integer.MIN_VALUE, 0L)\\n        candies.forEach { sum += it.also { if (it > max) max = it } }\\n        if (sum < k) return 0\\n\\n        var result = min\\n        while (max > min) {\\n            if (canEachChildGetCCandies(result, candies, k)) min = result\\n            else max = result -1\\n            result = (min + max + 1) / 2\\n        }\\n        return result\\n    }\\n\\n    fun canEachChildGetCCandies(c: Int, candies: IntArray, k: Long) =\\n        candies.fold(0L) { sum, it -> sum + it / c } >= k\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929691,
                "title": "2-python-solutions-binary-search",
                "content": "### ***Solution 1: Time O(nlog n) / Memory O(1)***\\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        lo=0 ; hi=sum(C)//k\\n        while lo<hi:\\n            mid=(lo+hi)//2+1\\n            if sum(c//mid for c in C)>=k: lo=mid\\n            else: hi=mid-1\\n        return lo\\n```\\n-----------------\\n### ***Solution 2: One-Line Version   -->  Time O(nlog n) / Memory O(1)***\\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        return bisect_left(range(1,sum(C)//k+1), True, key=lambda x:sum(c//x for c in C)<k)\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        lo=0 ; hi=sum(C)//k\\n        while lo<hi:\\n            mid=(lo+hi)//2+1\\n            if sum(c//mid for c in C)>=k: lo=mid\\n            else: hi=mid-1\\n        return lo\\n```\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        return bisect_left(range(1,sum(C)//k+1), True, key=lambda x:sum(c//x for c in C)<k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927152,
                "title": "c-easy-to-understand-with-simple-binary-search",
                "content": "Expalnation  : \\nstep 1 : find minimum and maximum values of candies you can give to each child that gives you the range of minimum and maximum candies minimum is always 0.\\nstep 2: check for one by one each candies per child on range of minimum and maximum what maximum satisfy your condition but linearly you may get TLE so think of Binary search.\\n\\n\\t    // Binary search on minimum and maximum possible values and \\n\\t   //\\tcheck according to mid value it is possible to allocate mid candies to each child\\n\\t  //  if yess then increase low to mid because we want a maximum candies per child\\n...\\n\\n\\nint maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(long long i=0;i<candies.size();i++)\\n            sum += candies[i];\\n        if(sum < k)\\n            return 0;\\n        if(sum==k)\\n            return 1;\\n        long long low = 0;\\n        long long high = sum/k+1;\\n        \\n        long long ans=0;\\n\\t\\t// Binary search on minimum and maximum possible values and \\n\\t\\t//check according to mid value it is possible to allocate mid candies to each child\\n\\t\\t//if yess then increase low to mid because we want a maximum candies per child\\n       while(low < high)\\n       {\\n           int mid = low + (high - low)/2;\\n           if(mid == 0) return 0;\\n           long long count=0;\\n           for(int j=0;j<candies.size();j++)\\n            {\\n               long long pile = candies[j];\\n                count +=  (pile/mid);\\n            }\\n           if(count>=k)\\n           {\\n               if(mid>ans)\\n                   ans = mid;\\n               low = mid+1;\\n           }\\n           else\\n               high = mid;\\n           \\n       }\\n        return ans==0 ? 0 : ans;\\n    }\\n\\t\\n...",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "Expalnation  : \\nstep 1 : find minimum and maximum values of candies you can give to each child that gives you the range of minimum and maximum candies minimum is always 0.\\nstep 2: check for one by one each candies per child on range of minimum and maximum what maximum satisfy your condition but linearly you may get TLE so think of Binary search.\\n\\n\\t    // Binary search on minimum and maximum possible values and \\n\\t   //\\tcheck according to mid value it is possible to allocate mid candies to each child\\n\\t  //  if yess then increase low to mid because we want a maximum candies per child\\n...\\n\\n\\nint maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(long long i=0;i<candies.size();i++)\\n            sum += candies[i];\\n        if(sum < k)\\n            return 0;\\n        if(sum==k)\\n            return 1;\\n        long long low = 0;\\n        long long high = sum/k+1;\\n        \\n        long long ans=0;\\n\\t\\t// Binary search on minimum and maximum possible values and \\n\\t\\t//check according to mid value it is possible to allocate mid candies to each child\\n\\t\\t//if yess then increase low to mid because we want a maximum candies per child\\n       while(low < high)\\n       {\\n           int mid = low + (high - low)/2;\\n           if(mid == 0) return 0;\\n           long long count=0;\\n           for(int j=0;j<candies.size();j++)\\n            {\\n               long long pile = candies[j];\\n                count +=  (pile/mid);\\n            }\\n           if(count>=k)\\n           {\\n               if(mid>ans)\\n                   ans = mid;\\n               low = mid+1;\\n           }\\n           else\\n               high = mid;\\n           \\n       }\\n        return ans==0 ? 0 : ans;\\n    }\\n\\t\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 1923331,
                "title": "a-few-solutions",
                "content": "Use binary search to find the maximal `k` candy \"chunks\" we can `take` from each `A[i]`<sup>th</sup> pile of candies to satisfy threshold `T` children.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maximumCandies(A: IntArray, T: Long): Int {\\n        var i = 0\\n        var j = A.max()!!\\n        while (i < j) {\\n            var k = (i + j + 1) / 2\\n            var take = A.map{ it.toLong() / k }.sum()\\n            if (T <= take)\\n                i = k\\n            else\\n                j = k - 1\\n        }\\n        return i\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maximumCandies = (A, T) => {\\n    let i = 0,\\n        j = Math.max(...A);\\n    while (i < j) {\\n        let k = Math.floor((i + j + 1) / 2);\\n        let take = _.sum(A.map(x => Math.floor(x / k)));\\n        if (T <= take)\\n            i = k;\\n        else\\n            j = k - 1;\\n    }\\n    return i;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maximumCandies(self, A: List[int], T: int) -> int:\\n        i = 0\\n        j = max(A)\\n        while i < j:\\n            k = (i + j + 1) // 2\\n            take = sum(x // k for x in A)\\n            if T <= take:\\n                i = k\\n            else:\\n                j = k - 1\\n        return i\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn maximum_candies(A: VI, T: i64) -> i32 {\\n        let mut i = 0;\\n        let mut j = *A.iter().max().unwrap();\\n        while i < j {\\n            let k = (i + j + 1) / 2;\\n            let take: i64 = A.iter().map(|x| *x as i64 / k as i64).sum();\\n            if T <= take {\\n                i = k;\\n            } else {\\n                j = k - 1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    int maximumCandies(VI& A, LL T) {\\n        LL i = 0,\\n           j = *max_element(A.begin(), A.end());\\n        while (i < j) {\\n            auto k = (i + j + 1LL) / 2;\\n            auto take = accumulate(A.begin(), A.end(), 0LL, [=](auto t, auto x) { return t + x / k; });\\n            if (T <= take)\\n                i = k;\\n            else\\n                j = k - 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(A: IntArray, T: Long): Int {\\n        var i = 0\\n        var j = A.max()!!\\n        while (i < j) {\\n            var k = (i + j + 1) / 2\\n            var take = A.map{ it.toLong() / k }.sum()\\n            if (T <= take)\\n                i = k\\n            else\\n                j = k - 1\\n        }\\n        return i\\n    }\\n}\\n```\n```\\nlet maximumCandies = (A, T) => {\\n    let i = 0,\\n        j = Math.max(...A);\\n    while (i < j) {\\n        let k = Math.floor((i + j + 1) / 2);\\n        let take = _.sum(A.map(x => Math.floor(x / k)));\\n        if (T <= take)\\n            i = k;\\n        else\\n            j = k - 1;\\n    }\\n    return i;\\n};\\n```\n```\\nclass Solution:\\n    def maximumCandies(self, A: List[int], T: int) -> int:\\n        i = 0\\n        j = max(A)\\n        while i < j:\\n            k = (i + j + 1) // 2\\n            take = sum(x // k for x in A)\\n            if T <= take:\\n                i = k\\n            else:\\n                j = k - 1\\n        return i\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn maximum_candies(A: VI, T: i64) -> i32 {\\n        let mut i = 0;\\n        let mut j = *A.iter().max().unwrap();\\n        while i < j {\\n            let k = (i + j + 1) / 2;\\n            let take: i64 = A.iter().map(|x| *x as i64 / k as i64).sum();\\n            if T <= take {\\n                i = k;\\n            } else {\\n                j = k - 1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    int maximumCandies(VI& A, LL T) {\\n        LL i = 0,\\n           j = *max_element(A.begin(), A.end());\\n        while (i < j) {\\n            auto k = (i + j + 1LL) / 2;\\n            auto take = accumulate(A.begin(), A.end(), 0LL, [=](auto t, auto x) { return t + x / k; });\\n            if (T <= take)\\n                i = k;\\n            else\\n                j = k - 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917758,
                "title": "binary-search-pattern-problem-nlog-max-candy",
                "content": "1. Its the common pattern for the binary search and in this case we need to find the maximum candies that can be allocated to K students where each of them get equal amount of candies.\\n2. So we can give 0 candies in minimum or we can give max(candies) to the students\\n3. Thus our search space will be 0 to max(candies)\\n4. Apply our binary search concept.\\n5. Find the middle and check if middle amount of candies can be distributed to k students, if yes, we need to find maximum, so we think there is more optimal answer to the right of our search space that will maximize our result, so update low = middle + 1 and store result = middle.\\n6. If we are not able to distribute middle amount of candies to k number of students, then any candies to the right of middle is also of no use, we need to explore the left part and move right = middle - 1;\\n7. Finally return our result.\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        if (candies == null || candies.length == 0) {\\n            return 0;\\n        }\\n        int low = 0;\\n        int high = findMax(candies);\\n        return binarySearch(candies, k, low, high);\\n    }\\n    \\n    public int binarySearch(int [] candies, long k, int low, int high) {\\n        int result = -1;\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (isPossibleToDivide(candies, middle, k)) {\\n                result = middle;\\n                low = middle + 1;\\n            }\\n            else {\\n                high = middle - 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isPossibleToDivide(int [] candies, int inHand, long k) {\\n        if (inHand == 0) {\\n            return true;\\n        }\\n        long total = 0;\\n        for (int num : candies) {\\n            total += (num) / inHand;\\n            if (total >= k) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int findMax(int [] candies) {\\n        int max = 0;\\n        for (int num : candies) {\\n            if (max < num) {\\n                max = num;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        if (candies == null || candies.length == 0) {\\n            return 0;\\n        }\\n        int low = 0;\\n        int high = findMax(candies);\\n        return binarySearch(candies, k, low, high);\\n    }\\n    \\n    public int binarySearch(int [] candies, long k, int low, int high) {\\n        int result = -1;\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (isPossibleToDivide(candies, middle, k)) {\\n                result = middle;\\n                low = middle + 1;\\n            }\\n            else {\\n                high = middle - 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isPossibleToDivide(int [] candies, int inHand, long k) {\\n        if (inHand == 0) {\\n            return true;\\n        }\\n        long total = 0;\\n        for (int num : candies) {\\n            total += (num) / inHand;\\n            if (total >= k) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int findMax(int [] candies) {\\n        int max = 0;\\n        for (int num : candies) {\\n            if (max < num) {\\n                max = num;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910615,
                "title": "cpp-easy-solution-binary-search",
                "content": "## **APPROACH**\\n* First check out how many number of maximum candies we can give to children if there were no constraints\\n* That would be dividing the sum in k children.\\n* So now we know our answer for number of candies we can give each child range from 1 to sum/k  and ( 0 in case of not enough candies)\\n* So find r which is sum/k and l which is 1\\n* And do binary search\\n* in this binary search we need to check that for a pile , how many parts we can create of mid number of candies.\\n* Then add all the parts we got of mid size.\\n* and if this number is more than k , it means , we can possibly give even more candies to each child , so decrease the search space and look for more number of candies that whether it could be a possible ans or not. \\n\\n\\n## **CODE**\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int>& candies, ll temp,ll k)\\n    {\\n        ll val=0;\\n        for(auto x:candies)\\n        {\\n            val+=(x/temp);\\n        }\\n        \\n        return val>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        // binary search \\n        // find range\\n        \\n        ll sum=0;\\n        for(auto x:candies)\\n        {\\n            sum+=x;\\n        }\\n        \\n        ll l=1,r=sum/k;\\n        \\n        if(r==0)\\n            return 0;\\n        \\n        // now do BS\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            \\n            bool check=isValid(candies,mid,k);\\n            \\n            if(check)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n                \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```\\n\\n### **TIME-COMPLEXITY** :\\nO(nlogm)  where m can be 10^12 in worst case.\\n### **SPACE-COMPLEXITY**:\\nO(1)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int>& candies, ll temp,ll k)\\n    {\\n        ll val=0;\\n        for(auto x:candies)\\n        {\\n            val+=(x/temp);\\n        }\\n        \\n        return val>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        // binary search \\n        // find range\\n        \\n        ll sum=0;\\n        for(auto x:candies)\\n        {\\n            sum+=x;\\n        }\\n        \\n        ll l=1,r=sum/k;\\n        \\n        if(r==0)\\n            return 0;\\n        \\n        // now do BS\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            \\n            bool check=isValid(candies,mid,k);\\n            \\n            if(check)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n                \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910250,
                "title": "binary-search-c",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long calculate(vector<int> & candies, int num){\\n        long long ans = 0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=candies[i]/num;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int ans = 0;\\n        int high = 10000005;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            long long curr = calculate(candies,mid);\\n            if(curr>=k){\\n                low = mid+1;\\n                ans = mid;\\n            }\\n            else\\n                high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long calculate(vector<int> & candies, int num){\\n        long long ans = 0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=candies[i]/num;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int ans = 0;\\n        int high = 10000005;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            long long curr = calculate(candies,mid);\\n            if(curr>=k){\\n                low = mid+1;\\n                ans = mid;\\n            }\\n            else\\n                high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910232,
                "title": "c-solution-binary-search-faster-that-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long right = *max_element(candies.begin(), candies.end());\\n        long long left = 0;\\n        while(right > left){\\n            long long mid = (right + left + 1)/2;\\n            long long sum = 0;\\n            for(int i = 0;i < candies.size(); i++){\\n                sum += candies[i]/mid;\\n            }\\n            if (sum < k){\\n                right = mid - 1;\\n            }else if (sum >= k){\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long right = *max_element(candies.begin(), candies.end());\\n        long long left = 0;\\n        while(right > left){\\n            long long mid = (right + left + 1)/2;\\n            long long sum = 0;\\n            for(int i = 0;i < candies.size(); i++){\\n                sum += candies[i]/mid;\\n            }\\n            if (sum < k){\\n                right = mid - 1;\\n            }else if (sum >= k){\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909852,
                "title": "java-o-nlogn-solution",
                "content": "\\n\\n        \\n        long sum=0;\\n        for(int i:candies)\\n            sum+=i;\\n        long low=0,high=sum;\\n        long ans=0;\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n            if(mid==0)\\n            {\\n                low=mid+1;\\n                continue;\\n            }\\n            long tmp=0;\\n            for(int i=0;i<candies.length;i++)\\n            {\\n                tmp+=candies[i]/mid;\\n            }\\n            if(tmp>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return (int)ans;\\n    \\n\\t",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "\\n\\n        \\n        long sum=0;\\n        for(int i:candies)\\n            sum+=i;\\n        long low=0,high=sum;\\n        long ans=0;\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n            if(mid==0)\\n            {\\n                low=mid+1;\\n                continue;\\n            }\\n            long tmp=0;\\n            for(int i=0;i<candies.length;i++)\\n            {\\n                tmp+=candies[i]/mid;\\n            }\\n            if(tmp>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return (int)ans;\\n    \\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1909799,
                "title": "left-right-1-2-vs-left-right-2",
                "content": "This post mainly focus on `(left+right+1)/2` and `(left+right)/2`.\\n\\n`mid = (left + right) / 2` to find *first* element valid\\n`mid = (left + right + 1) / 2` to find *last* element valid\\n\\nE.g. `[0, 1, 1, 1, 1]`\\n`mid = (left + right) / 2` would give index 1\\n`mid = (left + right + 1) / 2` would give index 5\\n\\nFor `mid = (left + right + 1) / 2`:\\n1. if `sum == k`, since we are going to find the last valid one, then move `left` till the very left: `left = mid`;\\n2. when go out of while loop, it\\'s getting to the first element NOT valid, so `right` need to decrement by one: `right = mid - 1`. So it would be:\\n\\n```\\nif (sum >= k) left = mid\\nelse right = mid -1\\n```\\nIf one wonders it\\'s `sum >= k` or `sum > k`, just take a moment think about if you want to first or last same element\\n\\nUsually we write `mid = (left + right) / 2` in\\n```\\nif (num[mid] < target) left = mid + 1\\nelse right = mid\\n```\\n\\nBtw, if using a helper `sum` function, be sure to return a `long` type not `int` otherwise you will hit error\\n\\nOriginal answer:\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        // binary search\\n        int left = 0, right = 10000000;\\n        \\n        while (left < right) {\\n            int mid = (left + right + 1) / 2;\\n\\n            // equal: go to the rightmost of these same numbers\\n            if (sum(candies, mid) >= k) \\n                left = mid;\\n            else \\n                right = mid - 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private long sum(int[] candies, int mid) {\\n        long count = 0;\\n        for (int c : candies) {\\n            count += c / mid;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nif (sum >= k) left = mid\\nelse right = mid -1\\n```\n```\\nif (num[mid] < target) left = mid + 1\\nelse right = mid\\n```\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        // binary search\\n        int left = 0, right = 10000000;\\n        \\n        while (left < right) {\\n            int mid = (left + right + 1) / 2;\\n\\n            // equal: go to the rightmost of these same numbers\\n            if (sum(candies, mid) >= k) \\n                left = mid;\\n            else \\n                right = mid - 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private long sum(int[] candies, int mid) {\\n        long count = 0;\\n        for (int c : candies) {\\n            count += c / mid;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909786,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * log(max. element in array))***\\n* ***Space Complexity : O(1)***\\n\\n```\\n    bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n    bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909572,
                "title": "python3-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        \\n        low,high = 0,sum(candies)\\n        while low < high:\\n            mid = low + (high - low)//2 + 1\\n            if sum(i//mid for i in candies) >= k:\\n                low = mid\\n            else:\\n                high = mid-1\\n                \\n        return low\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        \\n        low,high = 0,sum(candies)\\n        while low < high:\\n            mid = low + (high - low)//2 + 1\\n            if sum(i//mid for i in candies) >= k:\\n                low = mid\\n            else:\\n                high = mid-1\\n                \\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909404,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nint maximumCandies(vector<int>& c, long long k) \\n    {\\n        // I got the intuition because it was following the pattern of breaking down the question into two parts, I had to check if a number was feasible to keep and also no way of obviously finding it anyway else. Check Koko Eating bananas and similar pattern questions\\n        \\n        int left = 1 ;\\n        int right = 1e9;\\n        int res = INT_MIN;\\n        \\n        int n = c.size();\\n        long long sum = 0;\\n        \\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right-left)/2;\\n            \\n            if(isfeasible(c,k,mid))\\n            {\\n                res = max(res,mid);\\n                left = mid+1;\\n            }\\n            \\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return res == INT_MIN? 0 : res; // if we didn\\'t find any feasible value and the result is the initial one we had\\n    }\\n    \\n    bool isfeasible(vector<int> &c, long long k, int candy)\\n    {\\n        // checking feasibility\\n        long long count = 0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            count+= c[i]/candy; // counting number of children that can have piles with \\'candy\\' number of candies\\n        }\\n        \\n        if(count>=k)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nint maximumCandies(vector<int>& c, long long k) \\n    {\\n        // I got the intuition because it was following the pattern of breaking down the question into two parts, I had to check if a number was feasible to keep and also no way of obviously finding it anyway else. Check Koko Eating bananas and similar pattern questions\\n        \\n        int left = 1 ;\\n        int right = 1e9;\\n        int res = INT_MIN;\\n        \\n        int n = c.size();\\n        long long sum = 0;\\n        \\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right-left)/2;\\n            \\n            if(isfeasible(c,k,mid))\\n            {\\n                res = max(res,mid);\\n                left = mid+1;\\n            }\\n            \\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return res == INT_MIN? 0 : res; // if we didn\\'t find any feasible value and the result is the initial one we had\\n    }\\n    \\n    bool isfeasible(vector<int> &c, long long k, int candy)\\n    {\\n        // checking feasibility\\n        long long count = 0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            count+= c[i]/candy; // counting number of children that can have piles with \\'candy\\' number of candies\\n        }\\n        \\n        if(count>=k)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909394,
                "title": "java-c-greedy-binary-search-explained-easy-to-understand",
                "content": "Idea: .Minimun and maximum candies that can be given to a child form a monotonically increasing function.\\n    .Thus to find the maximum candies to a single child, binary search can be applied in the above mentioned search space\\n\\t\\nC++\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& cd, long long k) {\\n        long long l = 0, r = 1E7;\\n        long long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            auto m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            auto cgc = 0LL;\\n            if(m != 0l)\\n            {\\n                for (auto x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int maximumCandies(int[] cd, long k) {\\n        long l = 0, r = 10000000;\\n        long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            var m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            var cgc = 0l;\\n            if(m != 0l)\\n            {\\n                for (var x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\nAny corrections, suggestions or optimizations to code are welcomed. :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& cd, long long k) {\\n        long long l = 0, r = 1E7;\\n        long long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            auto m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            auto cgc = 0LL;\\n            if(m != 0l)\\n            {\\n                for (auto x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maximumCandies(int[] cd, long k) {\\n        long l = 0, r = 10000000;\\n        long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            var m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            var cgc = 0l;\\n            if(m != 0l)\\n            {\\n                for (var x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909330,
                "title": "c-binary-search-on-asnwer",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    \\n    bool isPossible(vector<int>& candies, ll k , ll mid ){\\n        ll children = 0 ;\\n        for(auto &x : candies) children += x / mid ;\\n        return children >= k ;\\n        \\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll totalCandies = accumulate(begin(candies),end(candies),0LL) ;\\n        ll lo = 1 , hi = totalCandies/k ;\\n        \\n        int ans = -1 ;\\n        while(lo <= hi){\\n            ll mid = lo + (hi-lo)/2LL ;\\n            if(isPossible(candies,k,mid)){\\n               ans = mid ;\\n               lo = mid + 1 ;\\n            }\\n            else hi = mid - 1 ;\\n        }\\n        return ans==-1 ? 0 : ans  ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    \\n    bool isPossible(vector<int>& candies, ll k , ll mid ){\\n        ll children = 0 ;\\n        for(auto &x : candies) children += x / mid ;\\n        return children >= k ;\\n        \\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll totalCandies = accumulate(begin(candies),end(candies),0LL) ;\\n        ll lo = 1 , hi = totalCandies/k ;\\n        \\n        int ans = -1 ;\\n        while(lo <= hi){\\n            ll mid = lo + (hi-lo)/2LL ;\\n            if(isPossible(candies,k,mid)){\\n               ans = mid ;\\n               lo = mid + 1 ;\\n            }\\n            else hi = mid - 1 ;\\n        }\\n        return ans==-1 ? 0 : ans  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909268,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int ans = 0;\\n        int l = 0,h = INT_MAX,m;\\n        while(l <= h) {\\n            m = l + (h -l )/2;\\n            if(isPossible(candies, m, k)) {\\n                ans = max(ans, m);\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& candies, int amount, long long k) {\\n        long long sum = 0;\\n        long long int cnt = 0;\\n        for(int candie : candies) {\\n            if(candie >= amount && amount != 0) cnt += candie/amount;\\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int ans = 0;\\n        int l = 0,h = INT_MAX,m;\\n        while(l <= h) {\\n            m = l + (h -l )/2;\\n            if(isPossible(candies, m, k)) {\\n                ans = max(ans, m);\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& candies, int amount, long long k) {\\n        long long sum = 0;\\n        long long int cnt = 0;\\n        for(int candie : candies) {\\n            if(candie >= amount && amount != 0) cnt += candie/amount;\\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909224,
                "title": "c-binary-search",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint help(ll mid,vector<int>&nums,ll k){\\n\\t\\t\\tll res = 0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++) res+=(nums[i]/mid);\\n\\t\\t\\treturn res>=k;\\n\\t\\t}\\n\\n\\t\\tint maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tll i = 1, j = 1e9;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tll mid = (i+j)/2;\\n\\t\\t\\t\\tif(help(mid,candies,k)) i = mid+1;\\n\\t\\t\\t\\telse j = mid-1;\\n\\t\\t\\t}\\n\\t\\t\\treturn i-1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint help(ll mid,vector<int>&nums,ll k){\\n\\t\\t\\tll res = 0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++) res+=(nums[i]/mid);\\n\\t\\t\\treturn res>=k;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1909207,
                "title": "java-efficient-binary-search-approach-explained",
                "content": "**Find total candies**\\n\\tif `total < k,` then we cannot give candy to all child, so `return 0`.\\n\\tif `total == k`, then each child can get only `1 candy`.\\n\\nOtherwise,\\n\\tUse binary search to find possible candies.\\n\\tHere, `high = total / k` as this is maximum we can assign to each child.\\n\\tFor each mid, find **how many piles can be created** `(candy / mid)`. If numbers of piles i.e. `sum >= k` then we can assign atleast `mid` candies.\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long total = 0;\\n        for (int candy : candies) {\\n            total += candy;\\n        }\\n        if (total < k) {\\n            return 0;\\n        }\\n        if (total == k) {\\n            return 1;\\n        }\\n        long low = 1;\\n        long high = total / k;\\n        int ans = 0;\\n        while (low <= high) {\\n            long mid = (low + high) / 2;\\n            long sum = 0;\\n            for (int candy: candies) {\\n                sum += (candy / mid);\\n            }\\n            if (sum >= k) {\\n                ans = (int) mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long total = 0;\\n        for (int candy : candies) {\\n            total += candy;\\n        }\\n        if (total < k) {\\n            return 0;\\n        }\\n        if (total == k) {\\n            return 1;\\n        }\\n        long low = 1;\\n        long high = total / k;\\n        int ans = 0;\\n        while (low <= high) {\\n            long mid = (low + high) / 2;\\n            long sum = 0;\\n            for (int candy: candies) {\\n                sum += (candy / mid);\\n            }\\n            if (sum >= k) {\\n                ans = (int) mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909168,
                "title": "binary-search-similar-approach-as-book-allocation-problem-in-cpp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& can, long long k) {\\n        int l=1,h=*max_element(can.begin(),can.end());  //here l initialised by 1 for the case when h=1\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            long long cnt=0;\\n            if(mid==0)\\n                break;\\n            for(int i=0;i<can.size();i++)\\n            {\\n                cnt+=1ll*can[i]/mid;\\n            }\\n            if(cnt>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& can, long long k) {\\n        int l=1,h=*max_element(can.begin(),can.end());  //here l initialised by 1 for the case when h=1\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            long long cnt=0;\\n            if(mid==0)\\n                break;\\n            for(int i=0;i<can.size();i++)\\n            {\\n                cnt+=1ll*can[i]/mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1909006,
                "title": "c-binary-search-faster-than-100",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]);\\n        }\\n        if(k==1)return mx;\\n        long long l=0,h=mx;\\n        long long ans=0;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            if(solve(nums,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }else{\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int solve(vector<int> nums,long long val,long long k){\\n        if(val==0)return true;\\n        long long c=0;\\n        for(int i=0;i<nums.size();i++){\\n            c+=nums[i]/val;\\n        }\\n        if(c>=k)return true;\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1908944,
                "title": "binary-search-time-o-nlogn-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(long long mid,long long k, vector<int>&candies)\\n    {\\n        long long temp=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            temp+=candies[i]/mid;\\n            if(temp>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            sum+=candies[i];\\n        }\\n        long long l=1,h=sum;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            \\n            if(check(mid,k,candies))\\n            {\\n                ans=(int)mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long mid,long long k, vector<int>&candies)\\n    {\\n        long long temp=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            temp+=candies[i]/mid;\\n            if(temp>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            sum+=candies[i];\\n        }\\n        long long l=1,h=sum;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            \\n            if(check(mid,k,candies))\\n            {\\n                ans=(int)mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908896,
                "title": "c-binary-search-clean-and-concise",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        \\n        ll sum=0;\\n        for(auto i:candies)\\n            sum+=i;\\n        if(sum<k)\\n            return 0;\\n        ll low=1;\\n        ll high=1e15;\\n        ll ans=0;\\n        while(low<=high)\\n        {\\n            ll mid=(low+high)/2;\\n           ll st=0;\\n            for(auto i:candies)\\n            {\\n                if(mid!=0)\\n                st+=(i/mid);\\n            }\\n            if(st>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        \\n        ll sum=0;\\n        for(auto i:candies)\\n            sum+=i;\\n        if(sum<k)\\n            return 0;\\n        ll low=1;\\n        ll high=1e15;\\n        ll ans=0;\\n        while(low<=high)\\n        {\\n            ll mid=(low+high)/2;\\n           ll st=0;\\n            for(auto i:candies)\\n            {\\n                if(mid!=0)\\n                st+=(i/mid);\\n            }\\n            if(st>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908845,
                "title": "easy-python-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 1, max(candies)\\n        while l <= r:\\n            m = (l + r)//2\\n            if self.countPile(candies, m) >= k:\\n                if self.countPile(candies, m + 1) < k: return m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return 0\\n                \\n    def countPile(self, candies, pileSize):\\n        return sum(candy//pileSize for candy in candies)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 1, max(candies)\\n        while l <= r:\\n            m = (l + r)//2\\n            if self.countPile(candies, m) >= k:\\n                if self.countPile(candies, m + 1) < k: return m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return 0\\n                \\n    def countPile(self, candies, pileSize):\\n        return sum(candy//pileSize for candy in candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908844,
                "title": "java-simple-binarysearch-tc-o-n-log-max",
                "content": "Solution:\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```\\n\\n**TimeComplexity:** O(N * log(Max)) where N is the number of candies.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908830,
                "title": "c-easy-binary-search",
                "content": "Approach:\\n* Firstly we will take given range and apply binary search.\\n* low will be 1 as min 1 candy shoud be given and high is upper limit of candy group in given constraint i.e 10^7.\\n* Firstly we will calculate mid and check if candy pile of k forms k groups or not if it is forming more than or equal to k groups then  we can take it as a possible answer and take low=mid+1 because we have to find max answer and there might exist any number more than mid that may satisfy given condition. if groups of mid are less than k then we have to search in left part fo high=mid-1.\\n    \\nComplexity:\\n* \\tTime: O(n log (10^7)) we are using binary search from 1 to 10^7 so log (10^7) and at each step we have to traverse array so it is multiplied by n.\\n* \\tSpace: O(1)\\n```\\t\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll low=1,high=10000001;\\n        int answer=0;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll groups=getGroups(candies,mid);\\n            if(groups>=k){\\n\\t\\t\\t\\t//probable any might be mid.\\n                answer=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    ll getGroups(vector<int> &candies,ll mid){\\n        ll groups=0;\\n        for(auto can:candies){\\n            groups+=(can/mid);\\n        }\\n        return groups;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\t\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll low=1,high=10000001;\\n        int answer=0;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll groups=getGroups(candies,mid);\\n            if(groups>=k){\\n\\t\\t\\t\\t//probable any might be mid.\\n                answer=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    ll getGroups(vector<int> &candies,ll mid){\\n        ll groups=0;\\n        for(auto can:candies){\\n            groups+=(can/mid);\\n        }\\n        return groups;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908821,
                "title": "c-binary-search-concise",
                "content": "```\\nclass Solution{\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0, n = candies.size();\\n        for(int i =0;i<n;i++){\\n            sum+= candies[i];\\n        }\\n        if(k>sum) return 0;\\n        long long lower = 1;\\n        long long upper = sum/k;\\n        \\n        long long ans = 0;\\n        \\n        while(lower<=upper){ \\n             long long mid = lower + (upper-lower)/2;\\n             long long count = 0;\\n             for(int i =0;i<n;i++){\\n                count+= candies[i]/mid;\\n             }\\n             if(count>=k){\\n                ans = max(ans,mid);\\n                lower = mid+1;\\n             }\\n             else{\\n                upper = mid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0, n = candies.size();\\n        for(int i =0;i<n;i++){\\n            sum+= candies[i];\\n        }\\n        if(k>sum) return 0;\\n        long long lower = 1;\\n        long long upper = sum/k;\\n        \\n        long long ans = 0;\\n        \\n        while(lower<=upper){ \\n             long long mid = lower + (upper-lower)/2;\\n             long long count = 0;\\n             for(int i =0;i<n;i++){\\n                count+= candies[i]/mid;\\n             }\\n             if(count>=k){\\n                ans = max(ans,mid);\\n                lower = mid+1;\\n             }\\n             else{\\n                upper = mid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908813,
                "title": "binary-search-same-as-koko-eating-bananas-python3",
                "content": "This problem is the very similar to the [Koko Eating bananas](https://leetcode.com/problems/koko-eating-bananas/). In fact, the only thing that changes in the condition and boundaries.\\n\\n\\n```\\ndef maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def can_take(target):\\n            count = 0\\n            for candy in candies:\\n                if candy >= target:\\n                    count += (candy // target) # Find out how many children this pile can feed :) \\n            return count >= k   # Make sure that we have enough to feed all the children\\n        \\n        l, r = 1, max(candies)\\n        res = 0\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can_take(m):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n  ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def can_take(target):\\n            count = 0\\n            for candy in candies:\\n                if candy >= target:\\n                    count += (candy // target) # Find out how many children this pile can feed :) \\n            return count >= k   # Make sure that we have enough to feed all the children\\n        \\n        l, r = 1, max(candies)\\n        res = 0\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can_take(m):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 1908805,
                "title": "python-java-binary-search",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\t\\tl = 1\\n\\t\\t\\tr = sum(candies)\\n\\t\\t\\tif r < k:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tdef allocate(m):\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor candy in candies:\\n\\t\\t\\t\\t\\tcnt += candy // m\\n\\t\\t\\t\\treturn cnt\\n\\t\\t\\twhile l + 1 < r:\\n\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\tif allocate(m) < k:\\n\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl = m\\n\\t\\t\\tif allocate(r) >= k:\\n\\t\\t\\t\\treturn r\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn l\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int maximumCandies(int[] candies, long k) {\\n\\t\\t\\tlong l = 1;\\n\\t\\t\\tlong r = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tr += candy;\\n\\t\\t\\t}\\n\\t\\t\\tif (r < k) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\twhile (l + 1 < r) {\\n\\t\\t\\t\\tlong m = (r - l) / 2 + l;\\n\\t\\t\\t\\tif (allocate(candies, m) < k) {\\n\\t\\t\\t\\t\\tr = m - 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tl = m;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (allocate(candies, r) >= k) {\\n\\t\\t\\t\\treturn (int)r;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn (int)l;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate long allocate(int[] candies, long m) {\\n\\t\\t\\tlong cnt = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tcnt += candy / m;\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t} \\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\t\\tl = 1\\n\\t\\t\\tr = sum(candies)\\n\\t\\t\\tif r < k:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tdef allocate(m):\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor candy in candies:\\n\\t\\t\\t\\t\\tcnt += candy // m\\n\\t\\t\\t\\treturn cnt\\n\\t\\t\\twhile l + 1 < r:\\n\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\tif allocate(m) < k:\\n\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl = m\\n\\t\\t\\tif allocate(r) >= k:\\n\\t\\t\\t\\treturn r\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn l\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int maximumCandies(int[] candies, long k) {\\n\\t\\t\\tlong l = 1;\\n\\t\\t\\tlong r = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tr += candy;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1908799,
                "title": "python-binary-search-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python] \\uD83C\\uDF1F Binary Search Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\nWe can greedy test every potential target from 1~ total//k.\\nSo we use binary Search to find our maximum target.\\n* canDivide: Simply use res += candy // target. To check whether a candy pile could split into how many piles to fit the target.\\n\\n## Complexity Analysis\\n* Time: O(NlogN)\\n* Space: O(1)\\n\\n## Code\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        total = sum(candies)\\n        if total < k:\\n            return 0\\n        \\n        # We can test our current target is valid\\n        def canDivide(target):\\n            res = 0\\n            for candy in candies:\\n                res += candy // target\\n            return res >= k\\n        \\n        # Greedy high would be total // k\\n        low, high = 1, total // k\\n        res = 0\\n        # Binary Search\\n        while low <= high:\\n            target = low + (high - low) // 2\\n            if canDivide(target):\\n                res = target\\n                low = target + 1\\n            else:\\n                high = target - 1\\n        return res\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        total = sum(candies)\\n        if total < k:\\n            return 0\\n        \\n        # We can test our current target is valid\\n        def canDivide(target):\\n            res = 0\\n            for candy in candies:\\n                res += candy // target\\n            return res >= k\\n        \\n        # Greedy high would be total // k\\n        low, high = 1, total // k\\n        res = 0\\n        # Binary Search\\n        while low <= high:\\n            target = low + (high - low) // 2\\n            if canDivide(target):\\n                res = target\\n                low = target + 1\\n            else:\\n                high = target - 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908787,
                "title": "c-binary-search-o-nlogn-intiution-comments",
                "content": "intiution : our search space(no of candies we can allocate) will be 1  to max number in array . if we can allocate a particular number of candy then search for next higher number else search number lower than that particular number.\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int maxCand = INT_MIN;\\n        long long s = 0;\\n        for(int i = 0;i < candies.size();i++){\\n            if(candies[i] > maxCand)\\n                maxCand = candies[i];\\n            s += candies[i];\\n        }\\n\\t\\t// if total number of candies are less than the no of children then we can never allocate same number of candies to children hence return 0\\n        if(k > s)\\n            return 0;\\n        int l = 1;\\n        int h = maxCand;\\n        while(l <= h){\\n            int mid = l + (h - l) / 2;\\n            long long sum = 0;\\n            for(int i =a 0;i < candies.size();i++){\\n\\t\\t\\t// mid means the number that we check if we can allocate that number of candy to children.\\n\\t\\t\\t// [ 5 8 6] and if mid = 2 then we can get 2 piles of 2 candies from 5 and 2 piles from 8 and 3 piles from 6.\\n                sum += candies[i] / mid;\\n            }\\n\\t\\t\\t// if total no of piles of mid number candy is >= k then we can allocate mid number candy to children hence check for next higher possible number.\\n            if(sum >= k)\\n                l = mid + 1;\\n\\t\\t\\t\\t// else check for lower number than mid.\\n            else\\n                h = mid - 1;\\n        }\\n\\t\\t// at end h points to a maximum number that we can allocate to children.\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int maxCand = INT_MIN;\\n        long long s = 0;\\n        for(int i = 0;i < candies.size();i++){\\n            if(candies[i] > maxCand)\\n                maxCand = candies[i];\\n            s += candies[i];\\n        }\\n\\t\\t// if total number of candies are less than the no of children then we can never allocate same number of candies to children hence return 0\\n        if(k > s)\\n            return 0;\\n        int l = 1;\\n        int h = maxCand;\\n        while(l <= h){\\n            int mid = l + (h - l) / 2;\\n            long long sum = 0;\\n            for(int i =a 0;i < candies.size();i++){\\n\\t\\t\\t// mid means the number that we check if we can allocate that number of candy to children.\\n\\t\\t\\t// [ 5 8 6] and if mid = 2 then we can get 2 piles of 2 candies from 5 and 2 piles from 8 and 3 piles from 6.\\n                sum += candies[i] / mid;\\n            }\\n\\t\\t\\t// if total no of piles of mid number candy is >= k then we can allocate mid number candy to children hence check for next higher possible number.\\n            if(sum >= k)\\n                l = mid + 1;\\n\\t\\t\\t\\t// else check for lower number than mid.\\n            else\\n                h = mid - 1;\\n        }\\n\\t\\t// at end h points to a maximum number that we can allocate to children.\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908745,
                "title": "binary-search-clean-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public boolean valid(int mid, int candies[], long k){\\n      \\n        long c=0;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            int val=candies[i];\\n            c+=val/mid;\\n            if(c>=k){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            max=Math.max(candies[i],max);\\n        }\\n        \\n        int low=1;\\n        int high=max;\\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            int mid= low +(high-low) / 2;\\n            \\n            if(valid(mid,candies,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            \\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean valid(int mid, int candies[], long k){\\n      \\n        long c=0;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            int val=candies[i];\\n            c+=val/mid;\\n            if(c>=k){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            max=Math.max(candies[i],max);\\n        }\\n        \\n        int low=1;\\n        int high=max;\\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            int mid= low +(high-low) / 2;\\n            \\n            if(valid(mid,candies,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            \\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908742,
                "title": "python-binary-search",
                "content": "\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\n        n = len(candies)\\n        \\n        if k > sum(candies):\\n            return 0\\n        \\n        def check(m):\\n            cnt = 0\\n            for c in candies:\\n                cnt += c//m\\n            \\n            if cnt >= k:\\n                return True\\n            else:\\n                return False\\n        \\n        l = 1\\n        r = max(candies)\\n        \\n        while l < r:\\n            m = l + (r-l+1)//2\\n            \\n            if check(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n        \\n",
                "solutionTags": [],
                "code": "\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\n        n = len(candies)\\n        \\n        if k > sum(candies):\\n            return 0\\n        \\n        def check(m):\\n            cnt = 0\\n            for c in candies:\\n                cnt += c//m\\n            \\n            if cnt >= k:\\n                return True\\n            else:\\n                return False\\n        \\n        l = 1\\n        r = max(candies)\\n        \\n        while l < r:\\n            m = l + (r-l+1)//2\\n            \\n            if check(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1908739,
                "title": "easy-concept-using-binary-search",
                "content": "\\nSimply do binary search, \\'guess\\' the max number of candies each child can get\\nsearching range: left = 0, right = (sum(candies)//k)+1\\nin each guess, we go through the whole candies array and check whether this guess is valid\\n\\ntime complexity: O(logS)*O(N), where S is the span of searching range\\nspace complexity: O(1)\\n\\n```\\nfrom typing import List\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        def is_valid(x):\\n            if x == 0: return True\\n            cnt = 0\\n            for p in candies:\\n                if p >= x:              # we can divide pile into any number of sub-piles\\n                    cnt += p//x\\n                if cnt >= k:\\n                    return True\\n            return False\\n        \\n        l, r = 0, (sum(candies)//k)+1\\n        while l < r:\\n            m = (l+r+1)//2\\n            if is_valid(m):             # everyone can get m candies, but could get more: try bigger m\\n                l = m\\n            else:\\n                r = m-1\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nfrom typing import List\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        def is_valid(x):\\n            if x == 0: return True\\n            cnt = 0\\n            for p in candies:\\n                if p >= x:              # we can divide pile into any number of sub-piles\\n                    cnt += p//x\\n                if cnt >= k:\\n                    return True\\n            return False\\n        \\n        l, r = 0, (sum(candies)//k)+1\\n        while l < r:\\n            m = (l+r+1)//2\\n            if is_valid(m):             # everyone can get m candies, but could get more: try bigger m\\n                l = m\\n            else:\\n                r = m-1\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908704,
                "title": "binary-search-c-o-nlogk",
                "content": "```\\n// use binary search to get optimum valuse\\n// O(n)\\n\\nclass Solution {\\npublic:\\n    bool check( long long mid, vector<int> &candies, long long k){\\n        long long cnt=0;\\n        for(auto c : candies){\\n            cnt += 1ll*c/mid;\\n        }\\n        return cnt >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=0, hi = 1e12+1;  // check for highest possible (although it will be max(candies))\\n        while(lo < hi){\\n            long long mid = lo+(hi-lo+1)/2;  \\n            if(mid == 0)\\n                return 0;\\n            if(check(mid, candies, k))\\n                lo = mid;\\n            else\\n                hi = mid-1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n// use binary search to get optimum valuse\\n// O(n)\\n\\nclass Solution {\\npublic:\\n    bool check( long long mid, vector<int> &candies, long long k){\\n        long long cnt=0;\\n        for(auto c : candies){\\n            cnt += 1ll*c/mid;\\n        }\\n        return cnt >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=0, hi = 1e12+1;  // check for highest possible (although it will be max(candies))\\n        while(lo < hi){\\n            long long mid = lo+(hi-lo+1)/2;  \\n            if(mid == 0)\\n                return 0;\\n            if(check(mid, candies, k))\\n                lo = mid;\\n            else\\n                hi = mid-1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908700,
                "title": "easy-to-understand-with-detailed-explanation-and-java-code-binary-search",
                "content": "***Please upvote if you find this helpful :)***\\n\\nA typical binary search implemetation. \\n\\nWe need to find the maximum candies every child can get. We take a lower and an upper bound and try to find if the current candy count can be given to every child or not. In case it can be given, then we try to find the same thing for a higher candy count and hence update our low to mid+1. In case, the current count is not valid, then we decrease the count to high = mid-1\\n\\nEdge case - If the sum of candies is less than no of students then the candies can\\'t be distributed and the ans will be 0.\\n\\n```\\nclass Solution {\\n    \\n    private boolean isValid(int[] candies, long k, int target){\\n        long ans = 0;\\n        for(int candy: candies){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += (long)(candy/target);\\n        }\\n        return (ans>=k);\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 0;\\n        int high = 10000000;\\n        int ans = 0;\\n        long sum = 0;\\n        for(int candy: candies){\\n            sum += candy;\\n        }\\n        if(sum<k){\\n            return 0;\\n        }\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isValid(candies,k,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isValid(int[] candies, long k, int target){\\n        long ans = 0;\\n        for(int candy: candies){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += (long)(candy/target);\\n        }\\n        return (ans>=k);\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 0;\\n        int high = 10000000;\\n        int ans = 0;\\n        long sum = 0;\\n        for(int candy: candies){\\n            sum += candy;\\n        }\\n        if(sum<k){\\n            return 0;\\n        }\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isValid(candies,k,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908698,
                "title": "c-binary-search-on-search-space-o-n-log-m-time-o-1-space",
                "content": "\\n**Binary search on Search space**\\nWe can atleast give 1 candy  and atmost max(candies) to each child. So, we binary search between 1 to max(candies).\\n\\n**How do we check, if we can give X candies to K children?**\\nIf we divide candy heaps into K or more sub heapes of size X. So, we try to divide each candy heap and see how many candy sub heaps of size X we can form. Sum of all X candy heaps in the array >= K children. Then we can say, we can divide X candies to K children.\\n\\n**Time complexity:** O(n log m), where n = size of array & m = max element in array\\n**Space complexity:** O(1)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, long long k, int val) {\\n        long long count = 0;\\n        for(int candy: candies) {\\n            count += candy / val;\\n        }\\n        \\n        return count >= k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int left = 1;\\n        int right = INT_MIN;\\n        long long sum = 0;\\n        for(int candy: candies) { \\n            right = max(right, candy);\\n            sum += candy;\\n        }\\n        \\n        if(sum < k) { return 0; }\\n        \\n        long long result = 0;\\n        while(left <= right) {\\n            long long mid = left + (right - left) / 2;\\n            if(isPossible(candies, k, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, long long k, int val) {\\n        long long count = 0;\\n        for(int candy: candies) {\\n            count += candy / val;\\n        }\\n        \\n        return count >= k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int left = 1;\\n        int right = INT_MIN;\\n        long long sum = 0;\\n        for(int candy: candies) { \\n            right = max(right, candy);\\n            sum += candy;\\n        }\\n        \\n        if(sum < k) { return 0; }\\n        \\n        long long result = 0;\\n        while(left <= right) {\\n            long long mid = left + (right - left) / 2;\\n            if(isPossible(candies, k, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052744,
                "title": "c-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinary search approach similar to koko eating bananas\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool noOfCandies(vector<int> candies,int n,long long candiesPerChild,long long totalNoOfKids){\\n        long long noOfKidsWithCandies=0;\\n        for(int i=0;i<n;i++){\\n            noOfKidsWithCandies+=candies[i]/candiesPerChild;\\n            if(noOfKidsWithCandies>=totalNoOfKids){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long low=1;\\n        long long high=0;\\n        for(int i=0;i<n;i++){\\n            high+=candies[i];\\n        }\\n        if(k>high){\\n            return 0;\\n        }\\n        while(low<=high){\\n            long long mid=low+(high-low)/2;\\n            if(noOfCandies(candies,n,mid,k)){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool noOfCandies(vector<int> candies,int n,long long candiesPerChild,long long totalNoOfKids){\\n        long long noOfKidsWithCandies=0;\\n        for(int i=0;i<n;i++){\\n            noOfKidsWithCandies+=candies[i]/candiesPerChild;\\n            if(noOfKidsWithCandies>=totalNoOfKids){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long low=1;\\n        long long high=0;\\n        for(int i=0;i<n;i++){\\n            high+=candies[i];\\n        }\\n        if(k>high){\\n            return 0;\\n        }\\n        while(low<=high){\\n            long long mid=low+(high-low)/2;\\n            if(noOfCandies(candies,n,mid,k)){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024376,
                "title": "exactly-the-same-as-koko-eat-banana",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        for (int candy : candies) max = Math.max(max, candy);\\n        int l = 0, r = max;\\n        while (l < r) {\\n            System.out.println(l + \" \" + r);\\n            int mid = r - (r - l ) / 2; // mid as unit\\n            if (canDivide(candies, k, mid)) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n\\n    private boolean canDivide(int[] candies, long k, int unit) {\\n        if (unit == 0) return true; // This is different from koko question\\n        long cnt = 0;\\n        for (int candy : candies) {\\n            cnt += (long) candy / unit;\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        for (int candy : candies) max = Math.max(max, candy);\\n        int l = 0, r = max;\\n        while (l < r) {\\n            System.out.println(l + \" \" + r);\\n            int mid = r - (r - l ) / 2; // mid as unit\\n            if (canDivide(candies, k, mid)) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n\\n    private boolean canDivide(int[] candies, long k, int unit) {\\n        if (unit == 0) return true; // This is different from koko question\\n        long cnt = 0;\\n        for (int candy : candies) {\\n            cnt += (long) candy / unit;\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023068,
                "title": "c-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long x=*max_element(candies.begin(),candies.end());\\n        long long low=1,high=x;\\n        long long ans=0;\\n        while(low<=high){\\n            long long mid=(low+high)/2;\\n            long long cnt=0;\\n            for(int i=0;i<candies.size();i++){\\n                cnt=cnt+candies[i]/mid;\\n            }\\n            if(cnt>=k){\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long x=*max_element(candies.begin(),candies.end());\\n        long long low=1,high=x;\\n        long long ans=0;\\n        while(low<=high){\\n            long long mid=(low+high)/2;\\n            long long cnt=0;\\n            for(int i=0;i<candies.size();i++){\\n                cnt=cnt+candies[i]/mid;\\n            }\\n            if(cnt>=k){\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988243,
                "title": "9-o-n-solution-using-binary-search",
                "content": "# Intuition\\nbecause equal no. of candies have to be distributed among k children, so we will have to check the feasibility of the number of candies that can be distributed.\\n\\nex: for cadies [ 5, 6, 8] and k = 3,\\nwe have to distriburte among k = 3 children, so we will find the largest number that can be extracted from any of the indexes k (3) times.\\nIt can be in different indexes or the same indexes.\\nfor the above example, it can be sub-divided into\\n[5, [5, 1], [5, 3]], so we can have 5 as the largest number of candies that can be distributed.\\n\\nif we had candies: [2, 20], k = 3;\\nhere we simply have to divide 20 into 3 equal numbers\\n[2, [6, 6, 6, 2]]\\nin the above we have 6 as an answer.\\n\\ntry solving problem number : 875\\n# Approach\\nfor every feasible number T from 1 -> totalSumOfCandies / n candies, we will check for each of them if its feasible or not to divide the array on that number T.\\nwe will use BS for this\\n\\n\\n# Complexity\\n- Time complexity:\\nN*O(N)\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tint n = candies.size();\\n\\n\\t\\t\\tlong long totalCandies = accumulate(begin(candies),end(candies),0ll);\\n\\n\\t\\t\\tif(totalCandies < k)\\treturn 0;\\n\\n\\t\\t\\tlong long s = 1, e = totalCandies/k;\\n\\t\\t\\tlong long mid = -1;\\n\\n\\t\\t\\twhile(s <= e) {\\n\\t\\t\\t\\tmid = s + (e-s)/2;\\n\\n\\t\\t\\t\\tlong int cnt = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tif(candies[i] >= mid)\\n\\t\\t\\t\\t\\t\\tcnt += 1ll*(candies[i]/mid);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cnt >= k)\\ts = mid+1;\\n\\t\\t\\t\\telse\\t\\t\\te = mid-1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn e;\\n\\t\\t}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tint n = candies.size();\\n\\n\\t\\t\\tlong long totalCandies = accumulate(begin(candies),end(candies),0ll);\\n\\n\\t\\t\\tif(totalCandies < k)\\treturn 0;\\n\\n\\t\\t\\tlong long s = 1, e = totalCandies/k;\\n\\t\\t\\tlong long mid = -1;\\n\\n\\t\\t\\twhile(s <= e) {\\n\\t\\t\\t\\tmid = s + (e-s)/2;\\n\\n\\t\\t\\t\\tlong int cnt = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tif(candies[i] >= mid)\\n\\t\\t\\t\\t\\t\\tcnt += 1ll*(candies[i]/mid);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cnt >= k)\\ts = mid+1;\\n\\t\\t\\t\\telse\\t\\t\\te = mid-1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn e;\\n\\t\\t}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963858,
                "title": "simple-python-solution",
                "content": "# Intuition\\nThis is similar to minimizing the result but now we have to find the maximum that satisfies some condition. If you remember firstBadVersion problem, you know we didn\\'t stop until we found the result, the only difference is minimum lies on the left side of our inputs, and maximum on the right side. \\n\\n# Approach\\nBinary Search and narrow down till we have our result.\\n\\n# Code\\n```\\ndef success(number, candies, children):    \\n    count = 0\\n    for candy in candies:\\n        if number > 0:\\n            count += math.floor(candy/number)\\n        \\n        if count >= children:\\n            return True\\n    \\n    return False\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n\\n        left = 1\\n        right = max(set(candies))\\n\\n        result = 0\\n        while left <= right:\\n            mid  = (left + right)//2\\n            if success(mid, candies, k):\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef success(number, candies, children):    \\n    count = 0\\n    for candy in candies:\\n        if number > 0:\\n            count += math.floor(candy/number)\\n        \\n        if count >= children:\\n            return True\\n    \\n    return False\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n\\n        left = 1\\n        right = max(set(candies))\\n\\n        result = 0\\n        while left <= right:\\n            mid  = (left + right)//2\\n            if success(mid, candies, k):\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947592,
                "title": "c-solution-faster-than-95",
                "content": "# Intuition\\nImplementation of Book Allocation problem using Binary Search\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int> arr, long long k, int mid) {\\n        long long int children = 0;\\n        for (int i : arr) {\\n            children += i / mid;\\n            if (children >= k) return true;\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int start = 1;\\n        long long int end = *max_element(candies.begin(), candies.end());;\\n        long long int mid = start + (end - start) / 2;\\n        long long int ans = 0;\\n\\n        while(start <= end) {\\n            if(isPossible(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n            else end = mid - 1;\\n            mid = start + (end - start) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach\\nI\\'ll try to explain using a testcase and dry run:\\n\\n### Input:\\ncandies = [5, 8, 6]\\nk = 3\\n\\n\\n\\n### Dry Run:\\n\\n1. Initialize start as 1, end as the maximum element in candies, which is 8, and mid as (1 + 8) / 2 = 4. ans is initialized as 0.\\n\\n\\n2. Enter the binary search loop:\\n- Check if it\\'s possible to distribute candies with mid = 4 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 4, which is 1.\\n        - For the second pile of 8 candies, children += 8 / 4, which is 3.\\n        - For the third pile of 6 candies, children += 6 / 4, which is 4.\\n    - Check if children (4) is greater than or equal to k (3). It\\'s true.\\n    - Set ans to 4 and update start to mid + 1, which is 5.\\n    - Update mid to (5 + 8) / 2 = 6.\\n\\n\\n3. Loop again:\\n- Check if it\\'s possible to distribute candies with mid = 6 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 6, which is 0.\\n        - For the second pile of 8 candies, children += 8 / 6, which is 1.\\n        - For the third pile of 6 candies, children += 6 / 6, which is 1.\\n    - Check if children (1) is greater than or equal to k (3). It\\'s false.\\n    - Update end to mid - 1, which is 5.\\n    - Update mid to (5 + 5) / 2 = 5.\\n\\n\\n4. Loop again:\\n- Check if it\\'s possible to distribute candies with mid = 5 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 5, which is 1.\\n        - For the second pile of 8 candies, children += 8 / 5, which is 2.\\n        - For the third pile of 6 candies, children += 6 / 5, which is 3.\\n    - Check if children (3) is greater than or equal to k (3). It\\'s true.\\n    - Set ans to 5 and update start to mid + 1, which is 6.\\n    - Update mid to (6 + 5) / 2 = 5.\\n\\n5. Since start is not less than or equal to end, the loop ends.\\n\\n\\n### Output:\\nThe function returns ans, which is 5. This means each child can receive at most 5 candies.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n * log(max_element))\\n\\n- Space complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int> arr, long long k, int mid) {\\n        long long int children = 0;\\n        for (int i : arr) {\\n            children += i / mid;\\n            if (children >= k) return true;\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int start = 1;\\n        long long int end = *max_element(candies.begin(), candies.end());;\\n        long long int mid = start + (end - start) / 2;\\n        long long int ans = 0;\\n\\n        while(start <= end) {\\n            if(isPossible(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n            else end = mid - 1;\\n            mid = start + (end - start) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936994,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n     public int MaximumCandies(int[] candies, long k)\\n    {\\n        long left = 1;\\n        long right = 0;\\n\\n        long sum = 0;\\n        foreach (var candy in candies)\\n        {\\n            sum += candy;\\n        }\\n\\n        right = sum / k;\\n        var answer = 0;\\n        \\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var count = CalculateCandies(mid, candies);\\n            \\n            if (count < k)\\n            {\\n                right = mid - 1;\\n            }\\n            else\\n            {\\n                answer = (int)mid;\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    long CalculateCandies(long mid, int[] candies)\\n    {\\n        long count = 0;\\n        \\n        foreach (var candy in candies)\\n        {\\n            if (candy >= mid)\\n            {\\n                count += candy / mid;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n     public int MaximumCandies(int[] candies, long k)\\n    {\\n        long left = 1;\\n        long right = 0;\\n\\n        long sum = 0;\\n        foreach (var candy in candies)\\n        {\\n            sum += candy;\\n        }\\n\\n        right = sum / k;\\n        var answer = 0;\\n        \\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var count = CalculateCandies(mid, candies);\\n            \\n            if (count < k)\\n            {\\n                right = mid - 1;\\n            }\\n            else\\n            {\\n                answer = (int)mid;\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    long CalculateCandies(long mid, int[] candies)\\n    {\\n        long count = 0;\\n        \\n        foreach (var candy in candies)\\n        {\\n            if (candy >= mid)\\n            {\\n                count += candy / mid;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931339,
                "title": "easy-binary-search-solution",
                "content": "Using Binary search optimized approach\\n\\n```\\nclass Solution {\\npublic:\\n    bool func(long long n,vector<int>& arr,long long k)\\n    {\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++)\\n            res+=(long long)arr[i]/n;\\n        return res>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,n=candies.size();\\n        long long h=1;\\n        for(int i=0;i<n;i++)\\n            h=max(h,(long long)candies[i]);\\n        long long ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=(l+h)/2;\\n            if(func(mid,candies,k))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(long long n,vector<int>& arr,long long k)\\n    {\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++)\\n            res+=(long long)arr[i]/n;\\n        return res>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,n=candies.size();\\n        long long h=1;\\n        for(int i=0;i<n;i++)\\n            h=max(h,(long long)candies[i]);\\n        long long ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=(l+h)/2;\\n            if(func(mid,candies,k))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927055,
                "title": "easy-java-solution-for-beginners",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] nums, long k) {\\n        int n=nums.length;\\n        int max=0;\\n        for(int x:nums){\\n            max=Math.max(x,max);\\n        }\\n        int st=1;\\n        int end=max;\\n        int ans=0;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(solve(nums,mid)>=k){\\n                ans=Math.max(ans,mid);\\n                st=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double solve(int[] nums,int t){\\n        double count=0;\\n        if(t==0) return 0;\\n        for(int x:nums){\\n            count+=x/t;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] nums, long k) {\\n        int n=nums.length;\\n        int max=0;\\n        for(int x:nums){\\n            max=Math.max(x,max);\\n        }\\n        int st=1;\\n        int end=max;\\n        int ans=0;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(solve(nums,mid)>=k){\\n                ans=Math.max(ans,mid);\\n                st=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double solve(int[] nums,int t){\\n        double count=0;\\n        if(t==0) return 0;\\n        for(int x:nums){\\n            count+=x/t;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924412,
                "title": "go-binary-search-100-runtime-90-memory",
                "content": "```\\nfunc maximumCandies(candies []int, k int64) int {\\n    sum := 0\\n    for _, c := range candies {\\n        sum+=c\\n    }\\n    if k > int64(sum) {\\n        return 0\\n    }\\n\\n    l, r, res := 1, sum/int(k), 0\\n\\n    for l <= r {\\n        m := (l+r)/2\\n        numOfCandies := 0\\n        \\n        for _, c := range candies {\\n            numOfCandies += (c / m)\\n        }\\n        if int64(numOfCandies) < k {\\n            r = m - 1\\n        } else {\\n            res = m\\n            l = m + 1\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumCandies(candies []int, k int64) int {\\n    sum := 0\\n    for _, c := range candies {\\n        sum+=c\\n    }\\n    if k > int64(sum) {\\n        return 0\\n    }\\n\\n    l, r, res := 1, sum/int(k), 0\\n\\n    for l <= r {\\n        m := (l+r)/2\\n        numOfCandies := 0\\n        \\n        for _, c := range candies {\\n            numOfCandies += (c / m)\\n        }\\n        if int64(numOfCandies) < k {\\n            r = m - 1\\n        } else {\\n            res = m\\n            l = m + 1\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902866,
                "title": "c-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\log{max(candies)})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(), candies.end());\\n        int lo = 1, hi = 0, mid, res = 0, n = candies.size();\\n        hi = candies.back();\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            long long tmp = k;\\n            for (int i = n - 1; i >= 0; -- i) {\\n                tmp -= 1LL * candies[i] / mid;\\n                if (tmp <= 0) break;\\n            }\\n            if (tmp <= 0) {\\n                res = mid;\\n                lo = mid + 1;\\n            } else hi = mid - 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(), candies.end());\\n        int lo = 1, hi = 0, mid, res = 0, n = candies.size();\\n        hi = candies.back();\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            long long tmp = k;\\n            for (int i = n - 1; i >= 0; -- i) {\\n                tmp -= 1LL * candies[i] / mid;\\n                if (tmp <= 0) break;\\n            }\\n            if (tmp <= 0) {\\n                res = mid;\\n                lo = mid + 1;\\n            } else hi = mid - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901111,
                "title": "binary-search-on-solution-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of piles, given the number of candies per child, can be calculated in linear time and is monotonic. So we can binary search on the solution space.\\n\\n# Complexity\\n- Time complexity: $$O(N*log(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n        let count_piles = |n| {\\n            candies.iter().map(|&c| (c / n) as i64).sum::<i64>()\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *candies.iter().max().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if count_piles(mid) >= k { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n        let count_piles = |n| {\\n            candies.iter().map(|&c| (c / n) as i64).sum::<i64>()\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *candies.iter().max().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if count_piles(mid) >= k { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900497,
                "title": "c-solution-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(nlong(n))$$\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int high = INT_MIN;\\n        for(auto it : candies){\\n            high = max(high,it);\\n        }\\n        int low =1;\\n        while(low <= high){\\n            long long candiesget=0;\\n            int mid = (low+high)/2;\\n            for(auto it : candies){\\n                candiesget += (it)/mid;\\n\\n            }\\n            if(candiesget >= k){\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int high = INT_MIN;\\n        for(auto it : candies){\\n            high = max(high,it);\\n        }\\n        int low =1;\\n        while(low <= high){\\n            long long candiesget=0;\\n            int mid = (low+high)/2;\\n            for(auto it : candies){\\n                candiesget += (it)/mid;\\n\\n            }\\n            if(candiesget >= k){\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893424,
                "title": "easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 0, max(candies)\\n        while l <= r:\\n            m = (l+r)//2\\n            l, r = (m+1, r) if not m or sum(candy // m for candy in candies) >= k else (l, m-1)\\n        return r\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 0, max(candies)\\n        while l <= r:\\n            m = (l+r)//2\\n            l, r = (m+1, r) if not m or sum(candy // m for candy in candies) >= k else (l, m-1)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891171,
                "title": "best-approach-v-easy-to-understand-beats-90",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool morePossible(vector<int>& candies, long long k, int amount){\\n        long long count = 0;\\n        for(int i = 0; i<candies.size(); i++){\\n            count += (candies[i]/amount);\\n        }\\n        if(count >= k)return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int right = *max_element(candies.begin(), candies.end());\\n        int left = 1;\\n        int res = 0;\\n       \\n        while(left <= right){\\n            int mid = (left +right)/2;\\n            if(morePossible(candies, k, mid)){\\n                res = mid;\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool morePossible(vector<int>& candies, long long k, int amount){\\n        long long count = 0;\\n        for(int i = 0; i<candies.size(); i++){\\n            count += (candies[i]/amount);\\n        }\\n        if(count >= k)return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int right = *max_element(candies.begin(), candies.end());\\n        int left = 1;\\n        int res = 0;\\n       \\n        while(left <= right){\\n            int mid = (left +right)/2;\\n            if(morePossible(candies, k, mid)){\\n                res = mid;\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890228,
                "title": "kotlin-solution",
                "content": "# Binary search\\n```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var left = 0\\n        var right = 10_000_000\\n\\n        while (left < right) {\\n            val m = (left + right + 1) / 2\\n            var childWithCandies: Long = 0\\n\\n            candies.forEach {\\n                childWithCandies += it / m\\n            }\\n\\n            if (childWithCandies >= k) left = m\\n            else right = m - 1\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var left = 0\\n        var right = 10_000_000\\n\\n        while (left < right) {\\n            val m = (left + right + 1) / 2\\n            var childWithCandies: Long = 0\\n\\n            candies.forEach {\\n                childWithCandies += it / m\\n            }\\n\\n            if (childWithCandies >= k) left = m\\n            else right = m - 1\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887281,
                "title": "java-solution-binary-search-on-answer-beats-95",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity: O(N*logM) M is range of max element.. \\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n       int low =1;\\n       int high = findMax(candies); \\n       while(low <= high){\\n           int mid = low + (high-low)/2;\\n           if(isValid(candies,mid,k)){\\n               low = mid+1;\\n           }else {\\n               high = mid-1;\\n           }\\n       }\\n       return high;\\n    }\\n    public int findMax(int [] candies){\\n        int max = 0;\\n        for(int i:candies){\\n            max = Math.max(max,i);\\n        }\\n        return max;\\n    }\\n\\n    public boolean isValid(int [] candies, int mid,long k){\\n        long piles = 0;\\n        for(int i: candies){\\n            int add = i/mid;\\n            piles += add;\\n        }\\n        return piles >=k;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n       int low =1;\\n       int high = findMax(candies); \\n       while(low <= high){\\n           int mid = low + (high-low)/2;\\n           if(isValid(candies,mid,k)){\\n               low = mid+1;\\n           }else {\\n               high = mid-1;\\n           }\\n       }\\n       return high;\\n    }\\n    public int findMax(int [] candies){\\n        int max = 0;\\n        for(int i:candies){\\n            max = Math.max(max,i);\\n        }\\n        return max;\\n    }\\n\\n    public boolean isValid(int [] candies, int mid,long k){\\n        long piles = 0;\\n        for(int i: candies){\\n            int add = i/mid;\\n            piles += add;\\n        }\\n        return piles >=k;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880468,
                "title": "simple-binary-search-beginers",
                "content": "# Intuition\\nThe very simple binary search with simple and easy checker function \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst just put a binary search on the possible values of the answer in the vector simple and easy approch \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(  log(n) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checker(int target,long long int k ,vector <int > & candies)\\n    {\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            k-=candies[i]/target;\\n        }\\n        if(k>0) return false;\\n        else return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int low=1,mid,high=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(checker(mid,k,candies))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checker(int target,long long int k ,vector <int > & candies)\\n    {\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            k-=candies[i]/target;\\n        }\\n        if(k>0) return false;\\n        else return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int low=1,mid,high=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(checker(mid,k,candies))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879864,
                "title": "easy-c-sol",
                "content": "# Intuition\\njust use binary search to find mid and check that mid is possible or not..\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&candies,int mid,long long k)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            cnt+=(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n         int high=*max_element(candies.begin(),candies.end());\\n         int low=1;\\n         int ans=0;\\n         while(low<=high)\\n         {\\n              int mid=(low+high)/2;\\n              if(check(candies,mid,k))\\n              {\\n                  ans=max(ans,mid);\\n                  low=mid+1;\\n              }\\n              else high=mid-1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&candies,int mid,long long k)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            cnt+=(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n         int high=*max_element(candies.begin(),candies.end());\\n         int low=1;\\n         int ans=0;\\n         while(low<=high)\\n         {\\n              int mid=(low+high)/2;\\n              if(check(candies,mid,k))\\n              {\\n                  ans=max(ans,mid);\\n                  low=mid+1;\\n              }\\n              else high=mid-1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872085,
                "title": "detailed-thought-process-start-with-linear-search-and-convert-your-thought-to-binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search: \\nHere this is the problem of maximisation over sorted search space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# **First think of searching maximum candy linearly :**\\n\\nWhat will be sorted search space for this problem:\\n    Here candies = {5,8,6}; k = 3\\n   here total candies = (5+8+6) = 19 and these 19 candies we have to distribute on k children.\\n\\nso one just intuitive way comes to our mind that just devide 19 by 3 i.e 19/3 = 6 candy.  so distribute 6 candy to each children 6*3 = 18 candy will be distributed. so here one possible ans could be 6,\\nsay ans = 6, now check if this ans is valid or not\\n\\nhere we are distributing 6 candy to each children, then one thing we have to make sure that each of the piles must contains candy greater than or equal to 6 candy then only we will be able to distribute 6 candy to each children. as in problem statement it is clearly mentioned that you can\\'t merge two piles of candies.  but we can distribute two children from one pile. but candy from two pile can\\'t be distributed to single child.\\n\\nHere candies[0] = 5 < ans =6, so here it is not possible to distribute 6 candy to each children.\\nas to distribute 6 candy, we have to 2 extra candy to pile candies[1] = 8, so if we are using these 2 extra candy in candies[0] = 5 to distribute 6, then it is a king of merging candy from two piles that is conflicting the problem statement. so this is not possible.\\n\\n\\nNow lets reduce the amount of candy from 6 to 5, say ans = 5, lets check if we can distribute , so clearly we can see that each of the piles has greater than or equal to 5 candy. so this is our feasible ans.\\n\\nso we will not go below 5 as we need maximum candy to distribute.\\n\\n# Binary Search thought:\\n\\nSo above idea to search the maximum candy linearley. \\n\\nbut here search space is sorted we can apply binary search on the search space low = 1 and high = 10^7 or (sum of all candy)/ k\\n\\nhere low = 1 as we can distribute 1 candy for sure as 1<=candies[i]<= 10^7\\nand high = (sum of all candy)/ k or we can take directly 10^7 as it is the max possible value of candy in a pile. any thing greater than 10^7 is not possible. \\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 0; int max = 0;\\n        long sum = 0;\\n        for(int candy : candies){\\n            sum += candy;\\n        }\\n\\n        if(sum < k) return 0;\\n        long s = 1;\\n        long e = (long)1e7;//sum/k;\\n        long ans = s;\\n        while(s <= e){\\n            long mid = s + (e-s)/2;\\n            if(canDistribute(candies,mid, k)){\\n                ans = mid;\\n                s = mid + 1;\\n            } else {\\n                e = mid -1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n\\n    private boolean canDistribute(int [] candies, long mid, long k){\\n        long count = 0;\\n        for(int candy : candies){\\n           count += candy/mid;\\n        }\\n        return count >= k;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: O(nlog(Max{candies[i]})) as a for loop is running at starting to find the sum. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 0; int max = 0;\\n        long sum = 0;\\n        for(int candy : candies){\\n            sum += candy;\\n        }\\n\\n        if(sum < k) return 0;\\n        long s = 1;\\n        long e = (long)1e7;//sum/k;\\n        long ans = s;\\n        while(s <= e){\\n            long mid = s + (e-s)/2;\\n            if(canDistribute(candies,mid, k)){\\n                ans = mid;\\n                s = mid + 1;\\n            } else {\\n                e = mid -1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n\\n    private boolean canDistribute(int [] candies, long mid, long k){\\n        long count = 0;\\n        for(int candy : candies){\\n           count += candy/mid;\\n        }\\n        return count >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862887,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findNumberOfPeople(vector<int>& candies, long long mid) {\\n        long long total = 0;\\n        for(int i=0; i<candies.size(); i++) {\\n            total += candies[i] / mid;\\n        }\\n        return total;\\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        if(accumulate(candies.begin(),candies.end(),0ll)<k)\\n        return 0;\\n        long long s = 1;\\n        long long h = *max_element(candies.begin(), candies.end());\\n        while (s < h) {\\n            long long m = s + (h - s + 1) / 2;\\n            if (findNumberOfPeople(candies, m) >= k) {\\n                s = m;\\n            }\\n            else {\\n                h = m - 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findNumberOfPeople(vector<int>& candies, long long mid) {\\n        long long total = 0;\\n        for(int i=0; i<candies.size(); i++) {\\n            total += candies[i] / mid;\\n        }\\n        return total;\\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        if(accumulate(candies.begin(),candies.end(),0ll)<k)\\n        return 0;\\n        long long s = 1;\\n        long long h = *max_element(candies.begin(), candies.end());\\n        while (s < h) {\\n            long long m = s + (h - s + 1) / 2;\\n            if (findNumberOfPeople(candies, m) >= k) {\\n                s = m;\\n            }\\n            else {\\n                h = m - 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849983,
                "title": "binary-search-13-ms-beats-99-7-runtime-98-77-memory",
                "content": "# Complexity\\n- Time complexity:\\nO(k * log(sum(candies)/k))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n  public int maximumCandies(int[] candies, long k) {\\n    long countCandies = 0;\\n    for (int i = 0; i < candies.length; i++) {\\n      countCandies += candies[i];\\n    }\\n\\n    long left = 1, right = countCandies / k;\\n    long maxCandies = 0;\\n    while (left <= right) {\\n      long mid = left + (right - left) / 2;\\n      long countAlloted = 0;\\n      for (int i = 0; i < candies.length; i++) {\\n        countAlloted += candies[i] / mid;\\n        if (countAlloted >= k) {\\n          break;\\n        }\\n      }\\n\\n      if (countAlloted >= k) {\\n        maxCandies = mid;\\n        left = mid + 1;\\n        continue;\\n      }\\n\\n      right = mid - 1;\\n    }\\n\\n    return (int) maxCandies;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int maximumCandies(int[] candies, long k) {\\n    long countCandies = 0;\\n    for (int i = 0; i < candies.length; i++) {\\n      countCandies += candies[i];\\n    }\\n\\n    long left = 1, right = countCandies / k;\\n    long maxCandies = 0;\\n    while (left <= right) {\\n      long mid = left + (right - left) / 2;\\n      long countAlloted = 0;\\n      for (int i = 0; i < candies.length; i++) {\\n        countAlloted += candies[i] / mid;\\n        if (countAlloted >= k) {\\n          break;\\n        }\\n      }\\n\\n      if (countAlloted >= k) {\\n        maxCandies = mid;\\n        left = mid + 1;\\n        continue;\\n      }\\n\\n      right = mid - 1;\\n    }\\n\\n    return (int) maxCandies;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848305,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    bool isPossible(vector<int>&candies,long long k,long long mid){\\n        long long count = 0;\\n        long long sum = 0;\\n        for(auto i:candies)\\n            count += i/mid;\\n        return count >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        long long high = 0;\\n        for(auto i:candies)\\n            high += i;\\n        long long ans = 0;\\n        long long mid = 0;\\n        if(high < k)\\n            return 0;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isPossible(candies,k,mid)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool isPossible(vector<int>&candies,long long k,long long mid){\\n        long long count = 0;\\n        long long sum = 0;\\n        for(auto i:candies)\\n            count += i/mid;\\n        return count >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        long long high = 0;\\n        for(auto i:candies)\\n            high += i;\\n        long long ans = 0;\\n        long long mid = 0;\\n        if(high < k)\\n            return 0;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isPossible(candies,k,mid)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829075,
                "title": "faster-than-100-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(right))\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k : \\n            return 0 \\n        \\n        def helper (val): \\n            crr = 0 \\n            for ele in candies : \\n                crr += (ele//val)\\n            if crr >= k : \\n                return True \\n            return False \\n        \\n        left =1\\n        right = sum(candies)//k \\n\\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left if helper(left) else left-1 \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k : \\n            return 0 \\n        \\n        def helper (val): \\n            crr = 0 \\n            for ele in candies : \\n                crr += (ele//val)\\n            if crr >= k : \\n                return True \\n            return False \\n        \\n        left =1\\n        right = sum(candies)//k \\n\\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left if helper(left) else left-1 \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824964,
                "title": "python-binary-search-solution",
                "content": "# Intuition \\nBinary Search, where the max amount is the number of available candies we have. We want to maximize this so we update our result.\\n# Approach\\nThe only addition to binary search is to consider when a valid amount is foundm updating the max when an amount can be satisfied using integer division.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log(m)), where m = sum(candies), the number of candies we can distribute, and n is the length of candies. \\n\\n- Space complexity:\\nO(1), we are only storing integer variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        res = 0\\n        def can(amt, kids):\\n            for val in candies:\\n                if val >= amt:\\n                    kids -= (val // amt)\\n                    if kids <= 0:\\n                        return True\\n            return kids <= 0\\n        l, r = 1, sum(candies)\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can(m, k):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        res = 0\\n        def can(amt, kids):\\n            for val in candies:\\n                if val >= amt:\\n                    kids -= (val // amt)\\n                    if kids <= 0:\\n                        return True\\n            return kids <= 0\\n        l, r = 1, sum(candies)\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can(m, k):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821954,
                "title": "o-nlogn-solution-c-java-solution",
                "content": "\\n# Code\\n**Java**\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        int l=1,r=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++) r=Math.max(r,candies[i]);\\n        // System.out.println(r);\\n        int ans=0;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(bs(candies,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean bs(int[] candies, int candy,long k){\\n        long total=0;\\n        for(int c:candies){\\n            total+=(c/candy);\\n        }\\n        return k<=total;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(std::vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        int l = 1, r = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            r = std::max(r, candies[i]);\\n        }\\n\\n        int ans = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (bs(candies, mid, k)) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool bs(std::vector<int>& candies, int candy, long long k) {\\n        long long total = 0;\\n        for (int c : candies) {\\n            total += (c / candy);\\n        }\\n        return k <= total;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        int l=1,r=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++) r=Math.max(r,candies[i]);\\n        // System.out.println(r);\\n        int ans=0;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(bs(candies,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean bs(int[] candies, int candy,long k){\\n        long total=0;\\n        for(int c:candies){\\n            total+=(c/candy);\\n        }\\n        return k<=total;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(std::vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        int l = 1, r = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            r = std::max(r, candies[i]);\\n        }\\n\\n        int ans = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (bs(candies, mid, k)) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool bs(std::vector<int>& candies, int candy, long long k) {\\n        long long total = 0;\\n        for (int c : candies) {\\n            total += (c / candy);\\n        }\\n        return k <= total;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820911,
                "title": "java-general-approach-to-handle-these-king-of-question-binary-search",
                "content": "\\tIn This question we know that we will have at least 1 candy in pile and maximum it can 10^7 and each pile can be divded  and we have to find our answer in that range \\n\\t\\n\\tNow there can be cases such that 1 pile is so big that it itself generate the answer from itself and here we check it through our valid \"MOSTLY THIS PART CHANGES IN THIS TYPE OF QUESTION\" .\\n\\tand there is simpy shifting left pointer to maximize the result ; \\n\\t\\n\\t\\n```\\nclass Solution {\\n    boolean valid(int[] arr, long k , int mid ){\\n        long piles = 0; \\n        for(int i = 0 ; i< arr.length ; ++i){\\n            piles += arr[i]/mid;\\n            if(piles >= k) return true;\\n        }\\n        return false;\\n                \\n        \\n    };\\n    public int maximumCandies(int[] candies, long k) {\\n        int l = 1 ,r = 10000000 ; \\n        \\n        int ans = 0; \\n        \\n        while( l <= r ){\\n            int mid = l + (r - l )/2;\\n            \\n            if(valid(candies,k,mid)){\\n                ans = mid; \\n                l = mid + 1; \\n            }\\n            else{\\n                r = mid -1; \\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    boolean valid(int[] arr, long k , int mid ){\\n        long piles = 0; \\n        for(int i = 0 ; i< arr.length ; ++i){\\n            piles += arr[i]/mid;\\n            if(piles >= k) return true;\\n        }\\n        return false;\\n                \\n        \\n    };\\n    public int maximumCandies(int[] candies, long k) {\\n        int l = 1 ,r = 10000000 ; \\n        \\n        int ans = 0; \\n        \\n        while( l <= r ){\\n            int mid = l + (r - l )/2;\\n            \\n            if(valid(candies,k,mid)){\\n                ans = mid; \\n                l = mid + 1; \\n            }\\n            else{\\n                r = mid -1; \\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820402,
                "title": "simple-binary-search",
                "content": "# Intuition\\ncheck how much we can give\\n\\n# Approach\\nBinary Search\\n\\n# Complexity**Bold**\\n- Time complexity:\\nnlog(1e7)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k,long long mid)\\n    {\\n        long long t=0;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            t+=(long long)candies[i]/mid;\\n        }\\n        return t>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long low=1,high=1e7;\\n        long long ans=0;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high)/2;\\n            if(check(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k,long long mid)\\n    {\\n        long long t=0;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            t+=(long long)candies[i]/mid;\\n        }\\n        return t>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long low=1,high=1e7;\\n        long long ans=0;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high)/2;\\n            if(check(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819137,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    bool check(vector<int> &candies, long long k, int mid){\\n        long long numofPiles = 0;\\n        for(int it:candies){\\n            numofPiles += it/mid;\\n        }\\n        return numofPiles >= k;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k) {\\n        int l=1, r=1e7, ans = 0;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(check(candies, k, mid) == true){\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool check(vector<int> &candies, long long k, int mid){\\n        long long numofPiles = 0;\\n        for(int it:candies){\\n            numofPiles += it/mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3810289,
                "title": "similar-to-book-allocations",
                "content": "# Intuition\\nWe have to find how much we can divide so that it is distributed equally.\\n**Naive**\\n- we can start looking form 1 to infinity and once it fails we know previous one is the correct distribution eg:- the max distribution we can do.\\nNow we can optimize it for binary search\\n\\n\\n\\n\\n# Approach\\n**Binary search**\\n- we can find the range how can we distribute as in question (there can be piles that will be unused) therefore as we dont have to include every pile then **MAX pile is the upper bound**\\n- Lower bound will be 1 as we can distribute 1 to each kid\\n\\nSo as we are looking for MAX ,where distribution is doable then we have to look into the right half (upper bound) and vice versa.\\n\\n# Complexity\\n- Time complexity:\\nO(log(max-1+1).N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long low=1,high= getMaxPile(candies);\\n\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n\\n            if(canDivide(candies,k,mid))\\n            {\\n                low=mid+1;      \\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return (int)high;\\n    }\\n\\n    public boolean canDivide(int[] candies, long k, long amount)\\n    {\\n        long count=0;\\n\\n        for(int candy : candies)\\n        {\\n            count+=(candy/amount);\\n        } \\n      //  System.out.println((k<=amount));\\n        return count>=k;  \\n    }\\n\\n    public long getMaxPile(int[] candies)\\n    {\\n        long max=candies[0];\\n\\n        for(int candy : candies)\\n        {\\n            if(candy>max)\\n            {\\n                max=candy;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long low=1,high= getMaxPile(candies);\\n\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n\\n            if(canDivide(candies,k,mid))\\n            {\\n                low=mid+1;      \\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return (int)high;\\n    }\\n\\n    public boolean canDivide(int[] candies, long k, long amount)\\n    {\\n        long count=0;\\n\\n        for(int candy : candies)\\n        {\\n            count+=(candy/amount);\\n        } \\n      //  System.out.println((k<=amount));\\n        return count>=k;  \\n    }\\n\\n    public long getMaxPile(int[] candies)\\n    {\\n        long max=candies[0];\\n\\n        for(int candy : candies)\\n        {\\n            if(candy>max)\\n            {\\n                max=candy;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807049,
                "title": "bs",
                "content": "**time: `O(KlogN)`; space: `O(1)`**\\n```\\nint maximumCandies(vector<int>& c, long long K)\\n{\\n\\tint l{}, h{10000001};\\n\\tfor( ; l+1<h; )\\n\\t{\\n\\t\\tint m = (l+h)/2;\\n\\t\\t(accumulate(begin(c), end(c), 0ll, [&](auto s, auto & c){ return s+1ll*c/m; })>=K ? l : h) = m;\\n\\t}\\n\\treturn l;\\n}\\n```\\n**Similar problems:**\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/2053517/bs?currentPage=1&orderBy=most_relevant&query=android)\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2963593/bs)\\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/discuss/2127417/binary-search)\\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/discuss/1676227/binary-search)\\n[1300. Sum of Mutated Array Closest to Target](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/discuss/2969866/bs)\\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/3251398/ok)\\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/discuss/3251393/ok)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/3253585/bs)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/3254564/bs)\\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/3807049/bs)\\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/3808940/bs)\\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/discuss/3945204/range-bs)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumCandies(vector<int>& c, long long K)\\n{\\n\\tint l{}, h{10000001};\\n\\tfor( ; l+1<h; )\\n\\t{\\n\\t\\tint m = (l+h)/2;\\n\\t\\t(accumulate(begin(c), end(c), 0ll, [&](auto s, auto & c){ return s+1ll*c/m; })>=K ? l : h) = m;\\n\\t}\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805686,
                "title": "python-bs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def ispossible(n):\\n            if n==0:\\n                return True\\n            count = 0\\n            for e in candies:\\n                if e < n:\\n                    continue\\n                elif e == n:\\n                    count+=1\\n                else:\\n                    count+=e//n\\n            return count >= k\\n\\n        l = 0\\n        u = 10000000\\n        while l<=u:\\n            mid = (l+u)//2\\n            if ispossible(mid):\\n                l = mid+1\\n            else:\\n                u = mid-1\\n\\n        return l-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def ispossible(n):\\n            if n==0:\\n                return True\\n            count = 0\\n            for e in candies:\\n                if e < n:\\n                    continue\\n                elif e == n:\\n                    count+=1\\n                else:\\n                    count+=e//n\\n            return count >= k\\n\\n        l = 0\\n        u = 10000000\\n        while l<=u:\\n            mid = (l+u)//2\\n            if ispossible(mid):\\n                l = mid+1\\n            else:\\n                u = mid-1\\n\\n        return l-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797209,
                "title": "easy-c-solution-using-bs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = * max_element ( A.begin() , A.end());\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = * max_element ( A.begin() , A.end());\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759528,
                "title": "easy-to-understand-clean-code-commented-binary-search-in-the-possible-answer",
                "content": "# Approach\\nLet\\'s say you can give maximum `X` candies. How do you find if it\\'s true or not?\\nTry to spit the piles keeping at least `X` candies on that and calculate how many piles you can build. If the number of piles is greater than number of kids then answer is true otherwise false.\\n\\nNow try to find a suitable `X` using binary search.\\n\\n# Complexity\\n- Time complexity:\\n`O(n log N)`\\n\\n- Space complexity:\\n`O(1)` - No extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long min_possible = 1;\\n        long long max_possible = *max_element(candies.begin(), candies.end());\\n        long long ans = 0;\\n\\n        // Find the number of pile you can build keeping at least\\n        // `value` candies in it */\\n        auto check = [&] (int value) {\\n            long long piles = 0;\\n            for (const auto &candy : candies) {\\n                piles += (candy / value);\\n            }\\n\\n            return piles >= k;\\n        };\\n\\n        // find a suitalbe answer using binary search\\n        while (min_possible <= max_possible) {\\n            long long trial = (min_possible + max_possible) / 2;\\n            if (check(trial)) {\\n                ans = max(ans, trial);\\n                min_possible = trial + 1;\\n            } else {\\n                max_possible = trial - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long min_possible = 1;\\n        long long max_possible = *max_element(candies.begin(), candies.end());\\n        long long ans = 0;\\n\\n        // Find the number of pile you can build keeping at least\\n        // `value` candies in it */\\n        auto check = [&] (int value) {\\n            long long piles = 0;\\n            for (const auto &candy : candies) {\\n                piles += (candy / value);\\n            }\\n\\n            return piles >= k;\\n        };\\n\\n        // find a suitalbe answer using binary search\\n        while (min_possible <= max_possible) {\\n            long long trial = (min_possible + max_possible) / 2;\\n            if (check(trial)) {\\n                ans = max(ans, trial);\\n                min_possible = trial + 1;\\n            } else {\\n                max_possible = trial - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759367,
                "title": "maximum-candies-allocated-to-k-children",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, a: List[int], k: int) -> int:\\n        ##Method 1\\n        def chq(a,v,k):\\n            c=0\\n            for i in a:\\n                c+=i//v\\n            return c>=k\\n            mx=float(\"-inf\")\\n        ans=0\\n        l=1\\n        h=max(a)\\n        while l<=h:\\n            m=(l+h)//2\\n            if chq(a,m,k):\\n                ans=m\\n                l=m+1\\n            else:\\n                h=m-1\\n        return(ans)\\n        ### Method 2 (Brute Force)\\n            # d={}\\n            # for i in range(len(a)):\\n            #     n=a[i]\\n            #     if n<v:\\n            #         if n in d:\\n            #             d[n]+=1\\n            #         else:\\n            #             d[n]=1\\n            #         continue\\n            #     while n:\\n            #         if n==0:\\n            #             break\\n            #         elif n<v:\\n            #             if n not in d:\\n            #                 d[n]=1\\n            #             else:\\n            #                 d[n]+=1\\n            #             break\\n            #         else:\\n            #             if v not in d:\\n            #                 d[v]=1\\n            #             else:\\n            #                 d[v]+=1\\n            #             n-=v\\n            # mx=float(\"-inf\")\\n            # for i in d:\\n            #     if d[i]>=k:\\n            #         mx=max(mx,i)\\n            # return mx\\n        # print(chq(a,8,k))\\n        \\n        # for i in range(1,max(a)+1):\\n        #     if chq(a,i,k)!=float(\"-inf\"):\\n        #         mx=max(mx,i)\\n        # if mx==float(\"-inf\"):return 0\\n        # return mx\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, a: List[int], k: int) -> int:\\n        ##Method 1\\n        def chq(a,v,k):\\n            c=0\\n            for i in a:\\n                c+=i//v\\n            return c>=k\\n            mx=float(\"-inf\")\\n        ans=0\\n        l=1\\n        h=max(a)\\n        while l<=h:\\n            m=(l+h)//2\\n            if chq(a,m,k):\\n                ans=m\\n                l=m+1\\n            else:\\n                h=m-1\\n        return(ans)\\n        ### Method 2 (Brute Force)\\n            # d={}\\n            # for i in range(len(a)):\\n            #     n=a[i]\\n            #     if n<v:\\n            #         if n in d:\\n            #             d[n]+=1\\n            #         else:\\n            #             d[n]=1\\n            #         continue\\n            #     while n:\\n            #         if n==0:\\n            #             break\\n            #         elif n<v:\\n            #             if n not in d:\\n            #                 d[n]=1\\n            #             else:\\n            #                 d[n]+=1\\n            #             break\\n            #         else:\\n            #             if v not in d:\\n            #                 d[v]=1\\n            #             else:\\n            #                 d[v]+=1\\n            #             n-=v\\n            # mx=float(\"-inf\")\\n            # for i in d:\\n            #     if d[i]>=k:\\n            #         mx=max(mx,i)\\n            # return mx\\n        # print(chq(a,8,k))\\n        \\n        # for i in range(1,max(a)+1):\\n        #     if chq(a,i,k)!=float(\"-inf\"):\\n        #         mx=max(mx,i)\\n        # if mx==float(\"-inf\"):return 0\\n        # return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757149,
                "title": "binary-search-with-intuition",
                "content": "# Code\\n```\\nclass Solution {\\n    // Intuition: Doing binary search as possible range of ans is available\\n    // TC: O(logr * candies.length)\\n    // SC: O(1)\\n    public int maximumCandies(int[] candies, long totalChildren) {\\n        long l = 1;\\n        long r = candies[0];\\n        for(int c:candies){\\n            r+=c;\\n        }\\n        if(r<totalChildren){\\n            return 0;\\n        }\\n        long ans = 0;\\n        long mid = 0;\\n        // TC: O(logr)\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            // TC: O(candies.length)\\n            if(canDistributeEqually(candies,totalChildren,mid)){\\n                ans = mid;\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n    private boolean canDistributeEqually(int[] candies, long totalChildren, long eachMustHave){\\n        long count = 0;\\n        for(int c:candies){\\n            count+= c/eachMustHave;\\n        }\\n        return count>=totalChildren;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    // Intuition: Doing binary search as possible range of ans is available\\n    // TC: O(logr * candies.length)\\n    // SC: O(1)\\n    public int maximumCandies(int[] candies, long totalChildren) {\\n        long l = 1;\\n        long r = candies[0];\\n        for(int c:candies){\\n            r+=c;\\n        }\\n        if(r<totalChildren){\\n            return 0;\\n        }\\n        long ans = 0;\\n        long mid = 0;\\n        // TC: O(logr)\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            // TC: O(candies.length)\\n            if(canDistributeEqually(candies,totalChildren,mid)){\\n                ans = mid;\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n    private boolean canDistributeEqually(int[] candies, long totalChildren, long eachMustHave){\\n        long count = 0;\\n        for(int c:candies){\\n            count+= c/eachMustHave;\\n        }\\n        return count>=totalChildren;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710929,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first notice that the maximum amount of candies in a pile can range from 0 to the max of candies, max(candies). We binary search over this range, utilizing a helper function to check if the chosen number for every pile is okay to allocate with. If we are successful in choosing the number for the maximum of this pile, we can find the max of this key value with our previous maximum. If we are not successful, then we decrease the size of our pile and binary search to the left. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        candies.sort()\\n        \\n        maximumNumCandies = 0\\n        \\n        #each child can take at most one pile of candies (some may go unused)\\n        #allocate piles of candies to k children such that each child gets the same number of candies\\n\\n        def canAllocatePiles(value):\\n            if value == 0:\\n                return True\\n            allocatedPiles = 0\\n            for pile in candies:\\n                allocatedPiles += (pile // value)\\n            return allocatedPiles >= k\\n\\n\\n        #the lower bound of candies a child can receive is 0. an upper bound is max(candies)\\n        lower, upper = 0, max(candies)\\n        #binary search through\\n        \\n        while lower <= upper:\\n            middle = (lower + upper) // 2\\n            \\n            if canAllocatePiles(middle):\\n                maximumNumCandies = max(maximumNumCandies, middle)\\n                lower = middle + 1\\n            else:\\n                upper = middle - 1\\n        \\n\\n        return maximumNumCandies\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        candies.sort()\\n        \\n        maximumNumCandies = 0\\n        \\n        #each child can take at most one pile of candies (some may go unused)\\n        #allocate piles of candies to k children such that each child gets the same number of candies\\n\\n        def canAllocatePiles(value):\\n            if value == 0:\\n                return True\\n            allocatedPiles = 0\\n            for pile in candies:\\n                allocatedPiles += (pile // value)\\n            return allocatedPiles >= k\\n\\n\\n        #the lower bound of candies a child can receive is 0. an upper bound is max(candies)\\n        lower, upper = 0, max(candies)\\n        #binary search through\\n        \\n        while lower <= upper:\\n            middle = (lower + upper) // 2\\n            \\n            if canAllocatePiles(middle):\\n                maximumNumCandies = max(maximumNumCandies, middle)\\n                lower = middle + 1\\n            else:\\n                upper = middle - 1\\n        \\n\\n        return maximumNumCandies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704735,
                "title": "c-easy-solution-striver-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, int mid, long long k){\\n        long long cntOfsplit = 0;\\n        for(int i = 0; i < candies.size(); i++){\\n            cntOfsplit += candies[i]/mid;\\n        }\\n        return cntOfsplit >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int high = *max_element(candies.begin(), candies.end());\\n        while(low <= high){\\n            int mid = low+ (high- low)/2;\\n            if(isPossible(candies, mid, k)){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, int mid, long long k){\\n        long long cntOfsplit = 0;\\n        for(int i = 0; i < candies.size(); i++){\\n            cntOfsplit += candies[i]/mid;\\n        }\\n        return cntOfsplit >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int high = *max_element(candies.begin(), candies.end());\\n        while(low <= high){\\n            int mid = low+ (high- low)/2;\\n            if(isPossible(candies, mid, k)){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703155,
                "title": "binary-search-intuition-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nClearly answer will be in between 0 and the max element of the vector.\\nWhen k is too high, answer have to b 0\\nWhen k is very low, (e.g. = 1) answer have to be maximum element\\n\\nSo Binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply apply Binary search from with  l =0 and h = max_element. And for every mid element we will calculate in how many kids we can distribue the canides or subpiles. For that we just have to do $candies[i]/mid$. SO,,,,,,,,\\n\\n# Edge Case\\nJust keep in mind that we have low as 0. And when we will divide by mid, in cases mid can be 0 too. So, make a seprate case of that.\\n\\n# Complexity\\n- Time complexity:$O(nlogm)$ \\n- $n$ = Length of candies vector\\n- $m$ = max element of vector\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int i =0;\\n        long long j = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            long long temp=0;\\n            if(mid==0) temp=k;\\n            else\\n            {\\n                for(int a=0;a<candies.size();a++)\\n                {\\n                    temp = temp + floor((double)candies[a]/(double)mid);\\n                }\\n            }   \\n            if(temp>=k)\\n            {\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else\\n            {\\n                j=mid-1;\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int i =0;\\n        long long j = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            long long temp=0;\\n            if(mid==0) temp=k;\\n            else\\n            {\\n                for(int a=0;a<candies.size();a++)\\n                {\\n                    temp = temp + floor((double)candies[a]/(double)mid);\\n                }\\n            }   \\n            if(temp>=k)\\n            {\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else\\n            {\\n                j=mid-1;\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683524,
                "title": "swift-binary-search-solution-space",
                "content": "# Intuition\\n Define a solution space to perform a binary search to find the max # of candies per pile\\n \\n # Approach\\n Define a solution space of possible values.\\n The minimum pile count has to be 1 since a pile cannot contain 0 candies.\\n The maximum pile count is `max(candies)` since piles cannot be merged.\\n Use a binary search to find the max pile count that satisfies `checkPiles`.\\n \\n # Complexity\\n - Time complexity:\\n O(n log n) where `n` is `candies.count`.\\n O(n)(find max) * O(log n)(binary search) * O(n)(checkPiles)\\n \\n - Space complexity:\\n O(1) only a few integers are stored.\\n \\n This problem is similar to to [875. Koko eating bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n\\n```\\nclass Solution {\\n\\n    func checkPiles(_ candies: [Int], _ k: Int, _ size: Int) -> Bool {\\n        var piles = 0\\n        for c in candies {\\n            piles += c / size\\n        }\\n\\n        return piles >= k\\n    }\\n\\n    func maximumCandies(_ candies: [Int], _ k: Int) -> Int {\\n        // Define the solution space\\n        var l = 1, r = Int.min, sum = 0 \\n        for c in candies {\\n            r = max(r, c)\\n            sum += c\\n        }\\n\\n        // The sum of all the piles has to be at least greater than the number of kids.\\n        guard sum >= k else { return 0 }\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            if checkPiles(candies, k, mid) {\\n                // Max number of candies satisfies the condition.\\n                // Try a bigger pile.\\n                l = mid + 1\\n            } else {\\n                // Num of candies per pile did not satisfy the condition.\\n                // Try a smaller pile.\\n                r = mid - 1\\n            }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    func checkPiles(_ candies: [Int], _ k: Int, _ size: Int) -> Bool {\\n        var piles = 0\\n        for c in candies {\\n            piles += c / size\\n        }\\n\\n        return piles >= k\\n    }\\n\\n    func maximumCandies(_ candies: [Int], _ k: Int) -> Int {\\n        // Define the solution space\\n        var l = 1, r = Int.min, sum = 0 \\n        for c in candies {\\n            r = max(r, c)\\n            sum += c\\n        }\\n\\n        // The sum of all the piles has to be at least greater than the number of kids.\\n        guard sum >= k else { return 0 }\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            if checkPiles(candies, k, mid) {\\n                // Max number of candies satisfies the condition.\\n                // Try a bigger pile.\\n                l = mid + 1\\n            } else {\\n                // Num of candies per pile did not satisfy the condition.\\n                // Try a smaller pile.\\n                r = mid - 1\\n            }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639923,
                "title": "java-solution-binary-search-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int p : candies){\\n            sum += p;\\n            max = Math.max(p, max);\\n        }\\n\\n        if(sum < k){\\n            return 0;\\n        }\\n        int lo = 1;\\n        int hi = max;\\n        int ans = -1;\\n        while(lo <= hi){\\n            long value = 0;\\n            int mid = lo + (hi - lo)/2;\\n            for(int i = 0;i<candies.length;i++){\\n                value += (candies[i]/mid);\\n            }\\n            if(value < k){\\n                \\n                hi = mid - 1;\\n            }\\n            else{\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int p : candies){\\n            sum += p;\\n            max = Math.max(p, max);\\n        }\\n\\n        if(sum < k){\\n            return 0;\\n        }\\n        int lo = 1;\\n        int hi = max;\\n        int ans = -1;\\n        while(lo <= hi){\\n            long value = 0;\\n            int mid = lo + (hi - lo)/2;\\n            for(int i = 0;i<candies.length;i++){\\n                value += (candies[i]/mid);\\n            }\\n            if(value < k){\\n                \\n                hi = mid - 1;\\n            }\\n            else{\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630709,
                "title": "java-beats-92-very-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(nlog(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start=1,end=Integer.MIN_VALUE,ansv=0;\\n        for(int i:candies){\\n            end=Math.max(end,i);\\n        }\\n        while(start<=end){\\n            long sum=0;\\n            int mid=start+((end-start)>>1);\\n            for(int i:candies){\\n                sum+=i/mid;\\n            }\\n            if(sum>=k){\\n                    ansv=mid;\\n                    start=mid+1;\\n            }\\n            else\\n            end=mid-1;\\n        }\\n        return ansv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start=1,end=Integer.MIN_VALUE,ansv=0;\\n        for(int i:candies){\\n            end=Math.max(end,i);\\n        }\\n        while(start<=end){\\n            long sum=0;\\n            int mid=start+((end-start)>>1);\\n            for(int i:candies){\\n                sum+=i/mid;\\n            }\\n            if(sum>=k){\\n                    ansv=mid;\\n                    start=mid+1;\\n            }\\n            else\\n            end=mid-1;\\n        }\\n        return ansv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612438,
                "title": "c-easy-to-understand-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool flag(vector<int>&v,long long int mid,int n,long long int k){\\n    long long int kk=0;\\n    for(int i=0;i<n;i++){\\n        kk=kk+(v[i]/mid);\\n        if(kk>=k)return 1;\\n    }\\n    \\n    return 0;\\n\\n}\\n    int maximumCandies(vector<int>&candies, long long k) {\\n        int n=candies.size();\\n       long long int b=0;\\n       long long int a=1;\\n       int mx=0;\\n       for(int i=0;i<n;i++){\\n           mx=max(mx,candies[i]);\\n       }\\n       long long int ans=0;\\n       b=mx;\\n       while(a<=b){\\n           long long int mid=a+(b-a)/2;\\n           if(flag(candies,mid,n,k)){\\n               ans=mid;\\n               a=mid+1;\\n           }\\n           else{\\n               b=mid-1;\\n           }\\n\\n       }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool flag(vector<int>&v,long long int mid,int n,long long int k){\\n    long long int kk=0;\\n    for(int i=0;i<n;i++){\\n        kk=kk+(v[i]/mid);\\n        if(kk>=k)return 1;\\n    }\\n    \\n    return 0;\\n\\n}\\n    int maximumCandies(vector<int>&candies, long long k) {\\n        int n=candies.size();\\n       long long int b=0;\\n       long long int a=1;\\n       int mx=0;\\n       for(int i=0;i<n;i++){\\n           mx=max(mx,candies[i]);\\n       }\\n       long long int ans=0;\\n       b=mx;\\n       while(a<=b){\\n           long long int mid=a+(b-a)/2;\\n           if(flag(candies,mid,n,k)){\\n               ans=mid;\\n               a=mid+1;\\n           }\\n           else{\\n               b=mid-1;\\n           }\\n\\n       }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611752,
                "title": "detailed-explanation-intuition-ranged-binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We a given search space in which our answer occurs minimum answer can be 1  maximum answer can be maximum of array.\\n- Suppose a number 5 satisfies so all numbers less than 5 will also satisfy the problem we have to search for elements greater than 5, same is the case if 5 doesnot satisfy we have to search answers less then 5.\\n- All this indicate the use of **Binary Search**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Apply Binary Search\\n- If any element satisfy update the answer.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long l=1L,h=(long)-1e8,ans=0L;\\n        for(int i:candies)\\n            h = Math.max(h,i);\\n\\n        while(l<=h){\\n            long m = (h-l)/2+l;\\n            if(isPossible(candies,k,m)){\\n                ans = m;\\n                l=m+1;\\n            }else{\\n                h=m-1;\\n            }\\n        }\\n\\n        return (int)ans;\\n\\n        \\n    }\\n\\n    public boolean isPossible(int[] candies, long k,long m){\\n\\n        long c = 0L;\\n        for(int i:candies){\\n            if(i<m)\\n                continue;\\n\\n            c += (long)i/m;\\n            if(c>=k)\\n                return true;\\n        }\\n\\n        return c>=k;\\n\\n    }\\n}\\n```\\n\\n\\n**IF YOU LIKE IT PLS UPVOTE**\\n\\n\\n- thanks\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long l=1L,h=(long)-1e8,ans=0L;\\n        for(int i:candies)\\n            h = Math.max(h,i);\\n\\n        while(l<=h){\\n            long m = (h-l)/2+l;\\n            if(isPossible(candies,k,m)){\\n                ans = m;\\n                l=m+1;\\n            }else{\\n                h=m-1;\\n            }\\n        }\\n\\n        return (int)ans;\\n\\n        \\n    }\\n\\n    public boolean isPossible(int[] candies, long k,long m){\\n\\n        long c = 0L;\\n        for(int i:candies){\\n            if(i<m)\\n                continue;\\n\\n            c += (long)i/m;\\n            if(c>=k)\\n                return true;\\n        }\\n\\n        return c>=k;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610302,
                "title": "easy-c-sol",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n=candies.size();\\n        ll sum=0;\\n        for(auto i:candies)sum+=i;\\n        if(sum<k)return 0;\\n        ll low=1;\\n        ll high=sum;\\n        ll ans=1;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll temp=0;\\n            for(int i=0;i<n;i++){\\n                temp+=floor(candies[i]*1.0/mid);\\n            }\\n            if(temp>=k){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n=candies.size();\\n        ll sum=0;\\n        for(auto i:candies)sum+=i;\\n        if(sum<k)return 0;\\n        ll low=1;\\n        ll high=sum;\\n        ll ans=1;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll temp=0;\\n            for(int i=0;i<n;i++){\\n                temp+=floor(candies[i]*1.0/mid);\\n            }\\n            if(temp>=k){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581078,
                "title": "candies-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n= candies.size();\\n        ll lo=1,hi=1e15,ans=0;\\n        while(lo<=hi){\\n            ll mid= (lo+hi)/2;\\n            ll totalkitnipilesbnsktihjismecandiesho=0;\\n            for(auto itr:candies){\\n                totalkitnipilesbnsktihjismecandiesho+=(itr/mid);\\n            }\\n            if(totalkitnipilesbnsktihjismecandiesho>=k){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n= candies.size();\\n        ll lo=1,hi=1e15,ans=0;\\n        while(lo<=hi){\\n            ll mid= (lo+hi)/2;\\n            ll totalkitnipilesbnsktihjismecandiesho=0;\\n            for(auto itr:candies){\\n                totalkitnipilesbnsktihjismecandiesho+=(itr/mid);\\n            }\\n            if(totalkitnipilesbnsktihjismecandiesho>=k){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581042,
                "title": "java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long lo = 1, hi = Integer.MAX_VALUE;\\n        long ans=0;\\n        while(lo <= hi){\\n            long mid = (lo+hi)/2;\\n            long maxCandies=0;\\n            for(int i:candies){\\n                maxCandies += i/mid;\\n            }\\n            if(maxCandies >= k){\\n                ans = mid;\\n                lo = mid+1;\\n            } else{\\n                hi = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long lo = 1, hi = Integer.MAX_VALUE;\\n        long ans=0;\\n        while(lo <= hi){\\n            long mid = (lo+hi)/2;\\n            long maxCandies=0;\\n            for(int i:candies){\\n                maxCandies += i/mid;\\n            }\\n            if(maxCandies >= k){\\n                ans = mid;\\n                lo = mid+1;\\n            } else{\\n                hi = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568094,
                "title": "possible-and-impossible-bound",
                "content": "# Approach\\nLet l be the lower bound of return value and r be the upper bound of lowest impossible value.\\nWhen l and r differ by 1, then l is what we want.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int: \\n        l = 0 #True\\n        r = sum(candies) // k + 1 #False\\n\\n        while r - l > 1:\\n            m = (l + r) // 2\\n\\n            if sum(x // m for x in candies) >= k:\\n                l = m\\n            else:\\n                r = m\\n        \\n        return l\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int: \\n        l = 0 #True\\n        r = sum(candies) // k + 1 #False\\n\\n        while r - l > 1:\\n            m = (l + r) // 2\\n\\n            if sum(x // m for x in candies) >= k:\\n                l = m\\n            else:\\n                r = m\\n        \\n        return l\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567696,
                "title": "easy-approach-to-solve-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    long long satisfiedchildren(int candiesperperson,vector<int>& candies ){\\n        long long  ans=0;\\n        int n=candies.size();\\n        for(int i=0; i<n; i++){\\n            ans += (candies[i]/candiesperperson);\\n\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int max_ele=INT_MIN;\\n        long long sum=0 , n=candies.size();\\n        for(int i=0; i<n; i++){\\n            max_ele= max(max_ele,candies[i]);\\n            sum+=candies[i];\\n        }\\n        if(sum<k) return 0;\\n\\n        int s=1, e=max_ele;\\n        int ans;\\n        while(s<=e)\\n        {\\n            int candiesperperson = s + (e-s)/2;\\n            long long sc = satisfiedchildren(candiesperperson, candies);\\n            if(sc>=k){\\n                ans=candiesperperson;\\n                s=candiesperperson+1;\\n            }\\n            else{\\n                e=candiesperperson-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    long long satisfiedchildren(int candiesperperson,vector<int>& candies ){\\n        long long  ans=0;\\n        int n=candies.size();\\n        for(int i=0; i<n; i++){\\n            ans += (candies[i]/candiesperperson);\\n\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int max_ele=INT_MIN;\\n        long long sum=0 , n=candies.size();\\n        for(int i=0; i<n; i++){\\n            max_ele= max(max_ele,candies[i]);\\n            sum+=candies[i];\\n        }\\n        if(sum<k) return 0;\\n\\n        int s=1, e=max_ele;\\n        int ans;\\n        while(s<=e)\\n        {\\n            int candiesperperson = s + (e-s)/2;\\n            long long sc = satisfiedchildren(candiesperperson, candies);\\n            if(sc>=k){\\n                ans=candiesperperson;\\n                s=candiesperperson+1;\\n            }\\n            else{\\n                e=candiesperperson-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517862,
                "title": "rust-solution-using-binary-search",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n    let k = k as usize;\\n    let mut count = 0;\\n    let candies = candies.into_iter().map(|v| {\\n      count += v as usize;\\n      v as usize\\n    }).collect::<Vec<usize>>();\\n    if count < k {\\n      return 0\\n    }\\n\\n    let mut left = 0;\\n    let mut right = 10usize.pow(15);\\n    while left + 1 < right {\\n      let mid = (left+right)/2;\\n      let mut temp = 0;\\n      for &v in &candies {\\n        temp += v / mid;\\n      }\\n\\n      if temp < k {\\n        right = mid;\\n      } else {\\n        left = mid;\\n      }\\n    }\\n    left as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n    let k = k as usize;\\n    let mut count = 0;\\n    let candies = candies.into_iter().map(|v| {\\n      count += v as usize;\\n      v as usize\\n    }).collect::<Vec<usize>>();\\n    if count < k {\\n      return 0\\n    }\\n\\n    let mut left = 0;\\n    let mut right = 10usize.pow(15);\\n    while left + 1 < right {\\n      let mid = (left+right)/2;\\n      let mut temp = 0;\\n      for &v in &candies {\\n        temp += v / mid;\\n      }\\n\\n      if temp < k {\\n        right = mid;\\n      } else {\\n        left = mid;\\n      }\\n    }\\n    left as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495761,
                "title": "easy-to-understand-javascript-solution-binary-search",
                "content": "```\\nvar maximumCandies = function(candies, k) {\\n    const sum = candies.reduce((total, candy) => total + candy);\\n    let min = 1;\\n    let max = Math.floor(sum / k) + 1;\\n    const isEnough = (count) => {\\n        const children = candies.reduce((result, candy) => {\\n            return result - Math.floor(candy / count);\\n        }, k);\\n\\n        return children <= 0;\\n    };\\n\\n    while (min < max) {\\n        const mid = Math.floor((min + max) / 2);\\n\\n        isEnough(mid) ? min = mid + 1 : max = mid;\\n    }\\n    return min - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCandies = function(candies, k) {\\n    const sum = candies.reduce((total, candy) => total + candy);\\n    let min = 1;\\n    let max = Math.floor(sum / k) + 1;\\n    const isEnough = (count) => {\\n        const children = candies.reduce((result, candy) => {\\n            return result - Math.floor(candy / count);\\n        }, k);\\n\\n        return children <= 0;\\n    };\\n\\n    while (min < max) {\\n        const mid = Math.floor((min + max) / 2);\\n\\n        isEnough(mid) ? min = mid + 1 : max = mid;\\n    }\\n    return min - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462275,
                "title": "python-binary-search-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        ans,low, high = 0,1, max(candies)\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            i=0\\n            c=0\\n            while i < len(candies):\\n                c+=candies[i]//mid \\n# integer division to to get number of children consuming mid from each pile \\n                i+=1\\n            if c>=k: \\n# if more than k children can consume candies from piles, it is possible that k children can receive more candies instead\\n                ans=mid\\n                low = mid + 1\\n            else:\\n                high = mid-1\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        ans,low, high = 0,1, max(candies)\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            i=0\\n            c=0\\n            while i < len(candies):\\n                c+=candies[i]//mid \\n# integer division to to get number of children consuming mid from each pile \\n                i+=1\\n            if c>=k: \\n# if more than k children can consume candies from piles, it is possible that k children can receive more candies instead\\n                ans=mid\\n                low = mid + 1\\n            else:\\n                high = mid-1\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387141,
                "title": "java-easy-solution-aasheesh-111th-day",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start = 0, end = 0 , ans = 0;\\n        for(int can:candies)    end = Math.max(end , can);\\n        \\n        while(start <= end){\\n            int mid = start + (end - start) /2;\\n            boolean flag = check(candies, k , mid);\\n            if(flag)    end = mid - 1;\\n            else{\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean check(int[] candies, long k, int mid) {\\n        if(mid == 0)    return false;\\n        long sum = 0;\\n        for(int can: candies){\\n            int num = can/mid;\\n            sum +=num;\\n        }\\n        if(sum >= k)   return false;\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start = 0, end = 0 , ans = 0;\\n        for(int can:candies)    end = Math.max(end , can);\\n        \\n        while(start <= end){\\n            int mid = start + (end - start) /2;\\n            boolean flag = check(candies, k , mid);\\n            if(flag)    end = mid - 1;\\n            else{\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean check(int[] candies, long k, int mid) {\\n        if(mid == 0)    return false;\\n        long sum = 0;\\n        for(int can: candies){\\n            int num = can/mid;\\n            sum +=num;\\n        }\\n        if(sum >= k)   return false;\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385996,
                "title": "simple-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long total =0;\\n        for(auto x:candies){\\n            total += x;\\n        }\\n\\n        if(total < k ){\\n            return 0;\\n        }\\n\\n        if(total == k){\\n            return 1;\\n        }\\n\\n        long long l = 1, r = total;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l+r)/2;\\n            long long piles = 0;\\n            for(auto x:candies){\\n                piles += x / mid;\\n            }\\n\\n            if(piles >= k){\\n                ans = max(ans, mid);\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long total =0;\\n        for(auto x:candies){\\n            total += x;\\n        }\\n\\n        if(total < k ){\\n            return 0;\\n        }\\n\\n        if(total == k){\\n            return 1;\\n        }\\n\\n        long long l = 1, r = total;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l+r)/2;\\n            long long piles = 0;\\n            for(auto x:candies){\\n                piles += x / mid;\\n            }\\n\\n            if(piles >= k){\\n                ans = max(ans, mid);\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384561,
                "title": "easy-to-understand-solution-using-binary-search-in-c",
                "content": "# Approach\\n  => Try to distrubute with large value of chocolates\\n  => Inside binary search, try to see if the chocolates can be distributed among n no. of childrens.\\n  => If it can be distributed then set your  start = mid + 1 and answer = mid value\\n  => Otherwise set end = mid - 1 \\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumCandies(int[] candies, long k) {\\n        int ans = 0;\\n        int start = 1;\\n        int end =  (int) 1e9;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            long count = 0;\\n            for(int i=0;i<candies.Length;i++){\\n                if(candies[i] >= mid){\\n                    count +=  candies[i] / mid;\\n                }\\n            }\\n            if(count < k){\\n                end = mid -1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumCandies(int[] candies, long k) {\\n        int ans = 0;\\n        int start = 1;\\n        int end =  (int) 1e9;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            long count = 0;\\n            for(int i=0;i<candies.Length;i++){\\n                if(candies[i] >= mid){\\n                    count +=  candies[i] / mid;\\n                }\\n            }\\n            if(count < k){\\n                end = mid -1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384435,
                "title": "c-binary-search-o-nlog-max-nums-i",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&nums,long long num,long long k){\\n        \\n        long long students=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<num){\\n                continue;\\n            }\\n            else{\\n                int x=nums[i]/num;\\n                students=students+x;\\n                if(students>=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        if(students<k){\\n            return false;\\n        }\\n        return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long start=1;\\n        int maxi=-1e9;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,candies[i]);\\n        }\\n        long long end=maxi;\\n        long long ans=0;\\n        while(start<=end){\\n            \\n            long long mid=(start+end)/2;\\n            if(ispossible(candies,mid,k)){\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool ispossible(vector<int>&nums,long long num,long long k){\\n        \\n        long long students=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<num){\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3383004,
                "title": "c-easy-solution-binary-search-for-beginner",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long int sum=0;\\n        for(auto x:c) sum+=x;\\n        if(sum<k) return 0; // if total candies is less than the sum then we can not allote atleast one to everyone , So ans is 0\\n        \\n       long long int s=1;\\n        long long int e=sum/k;   //this is the max candies that a child can get,\\n        long long int ans;\\n        while(s<=e){\\n            long long int mid=s+(e-s)/2;\\n            if(isPossible(mid,k,c)){         //this function will tell us, is it possible to allot mid no. of candies to allot a child\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    private: bool isPossible(long long int mid,long long int k,vector<int>&c){\\n        for(auto x:c){\\n            k-=(x/mid);\\n        }\\n        return k<=0?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long int sum=0;\\n        for(auto x:c) sum+=x;\\n        if(sum<k) return 0; // if total candies is less than the sum then we can not allote atleast one to everyone , So ans is 0\\n        \\n       long long int s=1;\\n        long long int e=sum/k;   //this is the max candies that a child can get,\\n        long long int ans;\\n        while(s<=e){\\n            long long int mid=s+(e-s)/2;\\n            if(isPossible(mid,k,c)){         //this function will tell us, is it possible to allot mid no. of candies to allot a child\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    private: bool isPossible(long long int mid,long long int k,vector<int>&c){\\n        for(auto x:c){\\n            k-=(x/mid);\\n        }\\n        return k<=0?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1688215,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 1570836,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 1926229,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 2006201,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Number of Texts",
        "question_content": "<p>Alice is texting Bob using her phone. The <strong>mapping</strong> of digits to letters is shown in the figure below.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png\" style=\"width: 200px; height: 162px;\" />\n<p>In order to <strong>add</strong> a letter, Alice has to <strong>press</strong> the key of the corresponding digit <code>i</code> times, where <code>i</code> is the position of the letter in the key.</p>\n\n<ul>\n\t<li>For example, to add the letter <code>&#39;s&#39;</code>, Alice has to press <code>&#39;7&#39;</code> four times. Similarly, to add the letter <code>&#39;k&#39;</code>, Alice has to press <code>&#39;5&#39;</code> twice.</li>\n\t<li>Note that the digits <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code> do not map to any letters, so Alice <strong>does not</strong> use them.</li>\n</ul>\n\n<p>However, due to an error in transmission, Bob did not receive Alice&#39;s text message but received a <strong>string of pressed keys</strong> instead.</p>\n\n<ul>\n\t<li>For example, when Alice sent the message <code>&quot;bob&quot;</code>, Bob received the string <code>&quot;2266622&quot;</code>.</li>\n</ul>\n\n<p>Given a string <code>pressedKeys</code> representing the string received by Bob, return <em>the <strong>total number of possible text messages</strong> Alice could have sent</em>.</p>\n\n<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> pressedKeys = &quot;22233&quot;\n<strong>Output:</strong> 8\n<strong>Explanation:</strong>\nThe possible text messages Alice could have sent are:\n&quot;aaadd&quot;, &quot;abdd&quot;, &quot;badd&quot;, &quot;cdd&quot;, &quot;aaae&quot;, &quot;abe&quot;, &quot;bae&quot;, and &quot;ce&quot;.\nSince there are 8 possible messages, we return 8.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> pressedKeys = &quot;222222222222222222222222222222222222&quot;\n<strong>Output:</strong> 82876089\n<strong>Explanation:</strong>\nThere are 2082876103 possible text messages Alice could have sent.\nSince we need to return the answer modulo 10<sup>9</sup> + 7, we return 2082876103 % (10<sup>9</sup> + 7) = 82876089.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pressedKeys.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pressedKeys</code> only consists of digits from <code>&#39;2&#39;</code> - <code>&#39;9&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2017753,
                "title": "simple-o-n-single-pass-solution",
                "content": "For every number other than 7 and 9, we can consider at most 3 **consecutive** digits whereas for 7 and 9 we can consider atmost 4 **consecutive** digits.\\n\\nLogic:\\n- Make an empty dp array.\\n- Iterate through every key pressed in pressedKeys and for every **i** we can add dp[i-1],dp[i-2],dp[i-3] to dp[i] and if pressedKeys[i] is either 7 or 9 then we can add dp[i-4] also.\\n- <img src=\"https://assets.leetcode.com/users/images/9a4f16ea-9965-4fa6-91a4-b2e3e5629139_1651982047.43855.jpeg\" width=450 height=400 align=center>\\n\\nCode:\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD=pow(10,9)+7\\n        dp=[0]*(len(pressedKeys)+1)\\n        dp[0]=1\\n        for i in range(1,len(pressedKeys)+1):\\n            dp[i]=dp[i-1]%MOD\\n            if(i-2>=0 and pressedKeys[i-1]==pressedKeys[i-2]):\\n                dp[i]=(dp[i]+dp[i-2])%MOD\\n                if(i-3>=0 and pressedKeys[i-1]==pressedKeys[i-3]):\\n                    dp[i]=(dp[i]+dp[i-3])%MOD\\n                    if(pressedKeys[i-1] in \"79\" and i-4>=0 and pressedKeys[i-1]==pressedKeys[i-4]):\\n                        dp[i]=(dp[i]+dp[i-4])%MOD\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD=pow(10,9)+7\\n        dp=[0]*(len(pressedKeys)+1)\\n        dp[0]=1\\n        for i in range(1,len(pressedKeys)+1):\\n            dp[i]=dp[i-1]%MOD\\n            if(i-2>=0 and pressedKeys[i-1]==pressedKeys[i-2]):\\n                dp[i]=(dp[i]+dp[i-2])%MOD\\n                if(i-3>=0 and pressedKeys[i-1]==pressedKeys[i-3]):\\n                    dp[i]=(dp[i]+dp[i-3])%MOD\\n                    if(pressedKeys[i-1] in \"79\" and i-4>=0 and pressedKeys[i-1]==pressedKeys[i-4]):\\n                        dp[i]=(dp[i]+dp[i-4])%MOD\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017810,
                "title": "python-o-n-dp-easy-to-understand-with-explanation",
                "content": "**Observation and intuition**\\n\"return the total number of possible text messages Alice could have sent\" means that this is a counting-number-of-ways problem, which is a signal of trying dynamic programming.\\n\\nLet\\'s have some simple observations trying to get some intuition about the recurrence relations:\\n1. if S = \"2\", then we only have one option: (2)\\n2. if S = \"23\", then we only have one option: (2)(3)\\n3. if S = \"22\", then we have two options: (2)(2), (22)\\n4. if S = \"223\", then we have two options: (2)(2)(3), (22)(3)\\n5. if S = \"222\", then we have four options: (2)(2)(2), (22)(2), (2)(22), (222)\\n\\nNote that ***more options emerge because we can combine the same letters together***, this is the main fact that we should utilize to break down this problem.\\n\\n\\n**Explanation:**\\nWhen we traverse the string S and we are at the index i, there are 3 (or 4 for \"7\" and \"9\") cases to be considered for the letter at index i:\\n1. consider that letter separately, so combination[i] = combination[i - 1]\\n2. if the two last letters stopping at index i are the same, we have an option to combine them, then combination[i] += combination[i - 2]\\n3. if the three last letters stopping at index i are the same, we have an option to combine them, then combination[i] += combination[i - 3]\\n4. if the four last letters (for \"7\" and \"9\") stopping at index i are the same, we have an option to combine them, then combination[i] += combination[i - 4]\\n\\nTake \"2222\" as an example and we are at the last \"2\":\\ncase 1: \"222(2)\", combination[\"2222\"] = combination[\"222\"]\\ncase 2: \"22(22)\", combination[\"2222\"] += combination[\"22\"]\\ncase 3: \"2(222)\", combination[\"2222\"] += combination[\"2\"]\\n\\n```\\nclass Solution:\\n    def countTexts(self, S: str) -> int:\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        dp = [0] * (len(S) + 1)\\n        dp[0] = 1\\n        for i in range(1, len(S) + 1):\\n            dp[i] = dp[i - 1]\\n            if i - 2 >= 0 and S[i-1] == S[i-2]:\\n                dp[i] += dp[i - 2]\\n            if i - 3 >= 0 and S[i-1] == S[i-2] and S[i-1] == S[i-3]:\\n                dp[i] += dp[i - 3]\\n                \\n            if S[i-1] in {\"7\", \"9\"}:\\n                if i - 4 >= 0 and S[i-1] == S[i-2] and S[i-1] == S[i-3] and S[i-1] == S[i-4]:\\n                    dp[i] += dp[i - 4]\\n            dp[i] %= mod\\n            \\n        return dp[-1] % mod",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def countTexts(self, S: str) -> int:\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        dp = [0] * (len(S) + 1)\\n        dp[0] = 1\\n        for i in range(1, len(S) + 1):\\n            dp[i] = dp[i - 1]\\n            if i - 2 >= 0 and S[i-1] == S[i-2]:\\n                dp[i] += dp[i - 2]\\n            if i - 3 >= 0 and S[i-1] == S[i-2] and S[i-1] == S[i-3]:\\n                dp[i] += dp[i - 3]\\n                \\n            if S[i-1] in {\"7\", \"9\"}",
                "codeTag": "Java"
            },
            {
                "id": 2017714,
                "title": "o-n-o-1",
                "content": "We use tabulation `dp` to store the number of possible messages for `i` characters.\\n\\nFor `i + 1`-th character, the number of messages is `dp[i + 1] = dp[i]`, plus:\\n- `dp[i - 1]` if `key[i + 1] == key[i]`\\n- `dp[i - 2]` if `key[i + 1] == key[i - 1]`\\n- `dp[i - 3]` if `key[i + 1] == key[i - 2]`\\n- `dp[i - 4]` if `key[i + 1] == key[i - 3]` and `key[i + 1]` is either 7 or 9.\\n\\nNote that we only need to store the tabulation for 4 previous positions. We can use a circular array to achieve O(1) memory complexity.\\n\\n**C++**\\n```cpp\\nint countTexts(string k) {\\n    int dp[5] = {1, 1, 1, 1, 1}, n = k.size();\\n    for (int i = n - 1; i >= 0; --i) {\\n        dp[i % 5] = 0;\\n        int max_j = min(n, i + (k[i] == \\'7\\' || k[i] == \\'9\\' ? 4 : 3));\\n        for (int j = i; j < max_j && k[i] == k[j]; ++j)\\n            dp[i % 5] = (dp[i % 5] + dp[(j + 1) % 5]) % 1000000007;\\n    }\\n    return dp[0];\\n} \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint countTexts(string k) {\\n    int dp[5] = {1, 1, 1, 1, 1}, n = k.size();\\n    for (int i = n - 1; i >= 0; --i) {\\n        dp[i % 5] = 0;\\n        int max_j = min(n, i + (k[i] == \\'7\\' || k[i] == \\'9\\' ? 4 : 3));\\n        for (int j = i; j < max_j && k[i] == k[j]; ++j)\\n            dp[i % 5] = (dp[i % 5] + dp[(j + 1) % 5]) % 1000000007;\\n    }\\n    return dp[0];\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019208,
                "title": "java-from-recursion-to-memoization-to-tabulation-easy-solution",
                "content": "Recursion -->>\\n\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        return solve(0,pressedKeys,key);\\n    }\\n\\n    public int solve(int ind, String s, int[] key) {\\n        if (ind == s.length()) {\\n            return 1;\\n        }\\n        int count = 0;\\n        int num = s.charAt(ind) - \\'0\\';\\n        int rep = key[num];\\n        for (int i = 0; i < rep && ind + i < s.length() && s.charAt(ind) == s.charAt(ind + i); i++) {\\n            count += solve(ind + 1 + i, s, key);\\n            count %= mod;\\n        }\\n        return  count;\\n    }\\n}\\n```\\n\\nMemoization(Top-Down)-->>\\n\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n         int[] key = new int[] {0,0,3,3,3,3,3,4,3,4};\\n         int n = pressedKeys.length();\\n         int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n         return solve(0,pressedKeys,key,dp);\\n    }\\n    public int solve(int ind , String s ,int[] key,int[]dp){\\n        if(ind==s.length()){\\n            return 1;\\n        }\\n        if(dp[ind]!=-1) return dp[ind];\\n        int count = 0;\\n        int num = s.charAt(ind)-\\'0\\';\\n        int rep = key[num];\\n        for(int i =0;i<rep && ind+i<s.length() && s.charAt(ind)==s.charAt(ind+i);i++){\\n            count += solve(ind+1+i,s,key,dp);\\n            count %= mod;\\n        }\\n        return dp[ind] = count;\\n    }\\n}\\n```\\n\\nTabulation(Bottom up)-->>\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[n] = 1;\\n\\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            int count = 0;\\n            int num = pressedKeys.charAt(ind) - \\'0\\';\\n            int rep = key[num];\\n            for (int i = 0; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i); i++) {\\n                count += dp[ind+i+1];\\n                count %= mod;\\n            }\\n             dp[ind] = count;\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\nDo Upvote if you find these solution Helpful.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        return solve(0,pressedKeys,key);\\n    }\\n\\n    public int solve(int ind, String s, int[] key) {\\n        if (ind == s.length()) {\\n            return 1;\\n        }\\n        int count = 0;\\n        int num = s.charAt(ind) - \\'0\\';\\n        int rep = key[num];\\n        for (int i = 0; i < rep && ind + i < s.length() && s.charAt(ind) == s.charAt(ind + i); i++) {\\n            count += solve(ind + 1 + i, s, key);\\n            count %= mod;\\n        }\\n        return  count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n         int[] key = new int[] {0,0,3,3,3,3,3,4,3,4};\\n         int n = pressedKeys.length();\\n         int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n         return solve(0,pressedKeys,key,dp);\\n    }\\n    public int solve(int ind , String s ,int[] key,int[]dp){\\n        if(ind==s.length()){\\n            return 1;\\n        }\\n        if(dp[ind]!=-1) return dp[ind];\\n        int count = 0;\\n        int num = s.charAt(ind)-\\'0\\';\\n        int rep = key[num];\\n        for(int i =0;i<rep && ind+i<s.length() && s.charAt(ind)==s.charAt(ind+i);i++){\\n            count += solve(ind+1+i,s,key,dp);\\n            count %= mod;\\n        }\\n        return dp[ind] = count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[n] = 1;\\n\\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            int count = 0;\\n            int num = pressedKeys.charAt(ind) - \\'0\\';\\n            int rep = key[num];\\n            for (int i = 0; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i); i++) {\\n                count += dp[ind+i+1];\\n                count %= mod;\\n            }\\n             dp[ind] = count;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109592,
                "title": "very-detailed-recursive-tree-diagram-with-decent-intuition-c-memorized-code",
                "content": "# Count Number of Texts\\n\\n***Intuition***\\n* As we know in feature phones, numbers (2, 3, 4, 5, 6, 8) have maximum 3 characters while (7 and 9) have 4 characters.\\n* So if we encountered same key press again in input then we have 2 choices either we can take it as single key press (take 1st letter of that pressed number) and move on or we can say that  a previously pressed number tapped again (if a same key pressed again then we take the next letter which is embedded to that number key).\\n***Example***\\n\\t* Let\\'s say we have input \"22223\"\\n       * if we consider every number was pressed once then the output word would be \"aaaad\".\\n       * if we consider that 2 was pressed twice at same time then the output word would be \"baac\".\\n       * if we say 2 pressed thrice then, we\\'ll get \"cab\" as the output\\n       * (**note**) This time we can\\'t take four 2s at same time because we know, we can only get a letter from number key 2 when it gets pressed once (a), twice(b) & thrice(c). Therefore the 4th keypress (2) considered as first tap & the keypress gives \\'a\\'.\\n  * **Please refer to the below recursive tree diagram for better understanding.**\\n<br>\\n![image](https://assets.leetcode.com/users/images/54f19f39-f2f0-463c-bec7-148f134327c0_1654338912.543673.png)\\n\\n***Please Upvote if you like the post*** \\u2B06\\uFE0F\\n\\n**Recursion [TLE]**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```\\n\\n**Recursion + Memoization [#ACCEPTED]**\\n*TC : O(N) & SC: O(N), where N is input string length*\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```\\n\\nThanks to [@aman-Raj](https://leetcode.com/aman-raj/) & [@anishakd](https://leetcode.com/anishakd/) for helping in recursive tree diagram \\u2764\\uFE0F.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018336,
                "title": "python-dp-with-diagrams-for-beginners",
                "content": "I have created some diagrams to help learners better understand how the dp works.\\nWe create ```dp = [1] + [0] * len(pressedKeys)``` for dp[0] to become a \"base case\". \\nAt each continuous number, we append the appropriate letter to reach the \"required length\".\\nTake string \"222233\" as an example:\\n![image](https://assets.leetcode.com/users/images/67828b61-eb60-44cd-bbec-438a1f223934_1651988165.4311492.png)\\n\\n\\n\\nSame concept applies when moving to next different number:\\n![image](https://assets.leetcode.com/users/images/50a25151-b975-4404-83a9-4b6da3f8cba8_1652146323.6530101.png)\\n\\n\\n```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1] + [0]*len(pressedKeys)\\n        mod = 10**9 + 7\\n        for i, n in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            # check if is continous\\n            if i >= 1 and pressedKeys[i-1] == n:\\n                dp[i+1] += dp[i-1]\\n                dp[i+1] %= mod\\n                if i >= 2 and pressedKeys[i-2] == n:\\n                    dp[i+1] += dp[i-2]\\n                    dp[i+1] %= mod\\n                    # Special case for \\'7\\' and \\'9\\' that can have 4 characters combination\\n                    if i >= 3 and pressedKeys[i-3] == n and (n == \"7\" or n == \"9\"):\\n                        dp[i+1] += dp[i-3]\\n                        dp[i+1] %= mod\\n        return dp[-1]\\n```\\nCode can be further optimized.\\nInspired from https://leetcode.com/problems/count-number-of-texts/discuss/2017760/JavaPython-3-Time-O(n)-space-O(1)-1-pass-DP-codes .\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp = [1] + [0] * len(pressedKeys)```\n```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1] + [0]*len(pressedKeys)\\n        mod = 10**9 + 7\\n        for i, n in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            # check if is continous\\n            if i >= 1 and pressedKeys[i-1] == n:\\n                dp[i+1] += dp[i-1]\\n                dp[i+1] %= mod\\n                if i >= 2 and pressedKeys[i-2] == n:\\n                    dp[i+1] += dp[i-2]\\n                    dp[i+1] %= mod\\n                    # Special case for \\'7\\' and \\'9\\' that can have 4 characters combination\\n                    if i >= 3 and pressedKeys[i-3] == n and (n == \"7\" or n == \"9\"):\\n                        dp[i+1] += dp[i-3]\\n                        dp[i+1] %= mod\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017760,
                "title": "java-python-3-1-pass-o-n-o-1-dp-codes-w-explanation-analysis-and-similar-problem",
                "content": "A Similar problem: \\n[91. Decode Ways](https://leetcode.com/problems/decode-ways/description/)\\n\\n----\\n\\n1. If the digit at index `i` was pressed just `1` times, then the corresponding solution is same as that of the subproblem of `i - 1`; e.g.,\\n\\n *   7   7   7  (7)\\n\\n2. If the digit at index `i` was acutally pressed `2` times, then the corresponding solution is same as that of the subproblem of `i - 2`; e.g.,\\n\\n*   7   7  (7   7)\\n\\n3.  If the digit at index `i` was acutally pressed `3` times, then the corresponding solution is same as that of the subproblem of `i - 3`; e.g.,\\n\\n *   7  (7   7   7)\\n\\n4.  If the digit at index `i` is `7` or `9` and was acutally pressed `4` times, then the corresponding solution is same as that of the subproblem of `i - 4`; e.g.,\\n\\n *  (7   7   7   7)\\n\\nCombine the above 4 cases, we can use `dp[i]` to indicate the solution of `pressedKeys.substring(0, i)`, and the general DP transition function is as follows:\\n```text\\ndp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]\\n```\\n\\n----\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            dp[i] = dp[i - 1];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[i] = (dp[i] + dp[i - 2]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n```python\\n    def countTexts(self, p: str) -> int:\\n        dp = [1] + [0] * len(p)\\n        for i, c in enumerate(p, 1):\\n            dp[i] = dp[i - 1]\\n            if i >= 2:    \\n                if c == p[i - 2]:\\n                    dp[i] += dp[i - 2]\\n                    if i >= 3 and c == p[i - 3]:\\n                        dp[i] += dp[i - 3]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == p[i - 4]:\\n                            dp[i] += dp[i - 4]\\n            dp[i] %= 10 ** 9 + 7        \\n        return dp[len(p)]\\n```\\n**Analysis:**\\nTime & space: `O(n)`, where `n = pressedKeys.length()`.\\n\\n----\\n\\nAfter space optimization:\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5;\\n            dp[idx] = dp[(i - 1) % 5];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[idx] = (dp[idx] + dp[(i - 2) % 5]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[idx] = (dp[idx] + dp[(i - 3) % 5]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[idx] = (dp[idx] + dp[(i - 4) % 5]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            if i >= 2:    \\n                if c == pressedKeys[i - 2]:\\n                    dp[i % 5] += dp[(i - 2) % 5]\\n                    if i >= 3 and c == pressedKeys[i - 3]:\\n                        dp[i % 5] += dp[(i - 3) % 5]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == pressedKeys[i - 4]:\\n                            dp[i % 5] += dp[(i - 4) % 5]\\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```\\n\\nSimplify the above codes further:\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5, lowBound = Math.max(0, i - (c == \\'7\\' || c == \\'9\\' ? 4 : 3));\\n            dp[idx] = dp[(i - 1) % 5];\\n            for (int j = i - 2; j >= lowBound && c == pressedKeys.charAt(j); --j) {\\n                dp[idx] = (dp[idx] + dp[j % 5]) % MOD; \\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            for j in range(i - 2, max(-1, i - 4 - (c in \\'79\\')), -1):\\n                if c == pressedKeys[j]:\\n                    dp[i % 5] += dp[j % 5]\\n                else:\\n                    break    \\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```\\n**Analysis:**\\nTime: `O(n)`, space: `O(1)`, where `n = pressedKeys.length()`.",
                "solutionTags": [],
                "code": "```text\\ndp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            dp[i] = dp[i - 1];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[i] = (dp[i] + dp[i - 2]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```python\\n    def countTexts(self, p: str) -> int:\\n        dp = [1] + [0] * len(p)\\n        for i, c in enumerate(p, 1):\\n            dp[i] = dp[i - 1]\\n            if i >= 2:    \\n                if c == p[i - 2]:\\n                    dp[i] += dp[i - 2]\\n                    if i >= 3 and c == p[i - 3]:\\n                        dp[i] += dp[i - 3]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == p[i - 4]:\\n                            dp[i] += dp[i - 4]\\n            dp[i] %= 10 ** 9 + 7        \\n        return dp[len(p)]\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5;\\n            dp[idx] = dp[(i - 1) % 5];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[idx] = (dp[idx] + dp[(i - 2) % 5]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[idx] = (dp[idx] + dp[(i - 3) % 5]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[idx] = (dp[idx] + dp[(i - 4) % 5]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            if i >= 2:    \\n                if c == pressedKeys[i - 2]:\\n                    dp[i % 5] += dp[(i - 2) % 5]\\n                    if i >= 3 and c == pressedKeys[i - 3]:\\n                        dp[i % 5] += dp[(i - 3) % 5]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == pressedKeys[i - 4]:\\n                            dp[i % 5] += dp[(i - 4) % 5]\\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5, lowBound = Math.max(0, i - (c == \\'7\\' || c == \\'9\\' ? 4 : 3));\\n            dp[idx] = dp[(i - 1) % 5];\\n            for (int j = i - 2; j >= lowBound && c == pressedKeys.charAt(j); --j) {\\n                dp[idx] = (dp[idx] + dp[j % 5]) % MOD; \\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            for j in range(i - 2, max(-1, i - 4 - (c in \\'79\\')), -1):\\n                if c == pressedKeys[j]:\\n                    dp[i % 5] += dp[j % 5]\\n                else:\\n                    break    \\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2017755,
                "title": "simple-memoization-technique-o-n",
                "content": "**Intuition:** If the pressedString is \"222\", there can 3 different keys pressed: \\'a\\'(\"2\"), \\'b\\'(\"22\") or \\'c\\'(\"222\"). So for every repeated keys, there can be multiple combinations of texts. We store the max repeatations of a particular key in keys array, and then try all recursive paths to get the count of several combinations of keys that can be formed starting from a particular index. As we try all recursive paths, so there has to be many repeated calculations, which can be mitigated by memoisation.\\n\\n```\\nCode:\\nclass Solution {\\npublic:\\n    static const int mod = 1e9+7;\\n    int dp[100001];\\n    static constexpr int keys[10] = {0,0,3,3,3,3,3,4,3,4};  // key \\'1\\' and \\'0\\' not to be used\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return getCounts(pressedKeys, 0);\\n    }\\n    \\n    int getCounts(string &pressed, int idx) {\\n        if(idx == pressed.length())\\n            return 1;\\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        int digit = pressed[idx]-\\'0\\'; long counts = 0;\\n        for(int i = 0; i < keys[digit] && idx+i < pressed.length() && pressed[idx] == pressed[idx+i]; i++) {\\n            counts += getCounts(pressed, idx+i+1);\\n            counts %= mod;\\n        }\\n        return dp[idx] = counts;\\n    }\\n};\\n```\\nKindly upvote if helpful to keep me motivated ^-^. Also comment down for any doubts.\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nCode:\\nclass Solution {\\npublic:\\n    static const int mod = 1e9+7;\\n    int dp[100001];\\n    static constexpr int keys[10] = {0,0,3,3,3,3,3,4,3,4};  // key \\'1\\' and \\'0\\' not to be used\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return getCounts(pressedKeys, 0);\\n    }\\n    \\n    int getCounts(string &pressed, int idx) {\\n        if(idx == pressed.length())\\n            return 1;\\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        int digit = pressed[idx]-\\'0\\'; long counts = 0;\\n        for(int i = 0; i < keys[digit] && idx+i < pressed.length() && pressed[idx] == pressed[idx+i]; i++) {\\n            counts += getCounts(pressed, idx+i+1);\\n            counts %= mod;\\n        }\\n        return dp[idx] = counts;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017730,
                "title": "cpp-short-and-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s,int i,int n,vector<int> &dp){\\n        if(i>=n)return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\'))ans+=func(s,i+4,n,dp);\\n                ans=ans%mod;\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s,int i,int n,vector<int> &dp){\\n        if(i>=n)return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\'))ans+=func(s,i+4,n,dp);\\n                ans=ans%mod;\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018250,
                "title": "c-solution-dp-bottom-up-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n = s.size();\\n        int mod = 1e9 + 7;\\n        vector<int> dp(n + 1);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            dp[i + 1] = dp[i];\\n            if (i > 0 and s[i] == s[i - 1])\\n            {\\n                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % mod;\\n                if (i > 1 and s[i] == s[i - 2])\\n                {\\n                    dp[i + 1] = (dp[i + 1] + dp[i - 2]) % mod;\\n                    if (i > 2 and s[i] == s[i - 3] and (s[i] == \\'7\\' or s[i] == \\'9\\'))\\n                        dp[i + 1] = (dp[i + 1] + dp[i - 3]) % mod;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n = s.size();\\n        int mod = 1e9 + 7;\\n        vector<int> dp(n + 1);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            dp[i + 1] = dp[i];\\n            if (i > 0 and s[i] == s[i - 1])\\n            {\\n                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % mod;\\n                if (i > 1 and s[i] == s[i - 2])\\n                {\\n                    dp[i + 1] = (dp[i + 1] + dp[i - 2]) % mod;\\n                    if (i > 2 and s[i] == s[i - 3] and (s[i] == \\'7\\' or s[i] == \\'9\\'))\\n                        dp[i + 1] = (dp[i + 1] + dp[i - 3]) % mod;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021877,
                "title": "c-dp-solution-o-n",
                "content": "Runtime: 32 ms, faster than 100.00% of C++ online submissions for Count Number of Texts.\\nMemory Usage: 19.3 MB, less than 40.00% of C++ online submissions for Count Number of Texts.\\n\\n\\n```\\nWe can calculate the letter combination count of each digit type for different length using DP.\\n\\nLetter combinations for digit 2,3,4,5,6,8 is same for length  1 to N as they all have 3 letters in their button\\n\\nBase case combinations: Length 1 to 3\\n\\nLength 1 => [2] => \\'a\\' => 1\\nLength 2 => [2,2] => \\'aa\\', \\'b\\' => 2\\nLength 3 =>  [2,2,2] => \\'aaa\\', \\'ab\\', \\'ba\\', \\'c\\' => 4\\n\\nNow for Length > 3 we can get combination count from previous length combinations\\nLength 4 => [2,2,2,2] => \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' , \\'baa\\' , \\'bb\\', \\'ca\\'  => 7\\n\\nLet first letter as \\'a\\', which has length 1 => [2]\\nThen total letter combination of length 4 with first letter \\'a\\' is DP[4-1] = DP[3] =>  \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' => 4\\n\\nLet first letter as \\'b\\', which has length 2 => [2,2]\\nThen total letter combination of length 4 with first letter \\'b\\' is DP[4-2] = DP[2] =>  \\'baa\\' , \\'bb\\' => 2\\n\\nLet first letter as \\'c\\', which has length 3 => [2,2,2]\\nThen total letter combination of length 4 with first letter \\'c\\' is DP[4-3] = DP[1] =>  \\'ca\\' => 1\\n\\nSo, total letter combination of Length 4 => DP[4-1] + DP[4-2] + DP[4-3] = 4 + 2 + 1 = 7 \\n\\nDP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3]\\n\\nLetter combinations for digit 7 and 9 is same for length  0 to N as they all have 4 letters in their button\\n\\nBase case combinations: Length 1 to 4\\n\\nLength 1 => [7] => \\'p\\' => 1\\nLength 2 => [7,7] => \\'pp\\' or \\'q\\' => 2\\nLength 3 =>  [7,7,7] => \\'ppp\\', \\'pq\\', \\'qp\\', \\'r\\' => 4\\nLength 4 => [7,7,7,7] => \\'pppp\\', \\'ppq\\', \\'pqp\\', \\'pr\\', \\'qq\\', \\'qpp\\', \\'rp\\', \\'s\\' => 8\\n\\nSimilary as above, DP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3] + DP[N-4]\\n\\nFirst we get the max frequency of each digit and their frequency chunks.\\nThen we generate letter combinations for 0 to max frequency of each digit in DP\\nThen we multiply the DP[X] of frequency chunks X of each digit as their letter combinations are independent.\\n```\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressed) {\\n        \\n        int MOD = 1000000007;\\n        int pl = pressed.length();\\n        \\n        // base case combinations for 2-9 digits of length 0 to 4\\n        vector<vector<int>>preDP = {{0,1,2,4},{0,1,2,4,8}};\\n            \\n        // store max freq of each digit and freq chunks\\n        int maxFreq[10] = {};\\n        vector<int>freq[10];\\n        \\n        int curr = -1;\\n        int count = 0;\\n        \\n        for(int i=0;i<pl;i++)\\n        {\\n            if(pressed[i]-\\'0\\' == curr)\\n            {\\n                count++;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].back()++;\\n            }\\n            else\\n            {\\n                curr = pressed[i]-\\'0\\';\\n                count = 1;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].push_back(count);\\n            }\\n        }\\n        \\n        vector<long long>dp(pl+1);\\n        unsigned long long totalCount = 1L;\\n        int type;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(maxFreq[i]==0)continue;\\n            \\n            // get digit type\\n            type = (i==7 || i==9) ? 1 : 0;\\n            \\n            // store the base case combinations for length 0 to 4\\n            for(int j=0;j<=maxFreq[i] && j<=3+type;j++)\\n                dp[j] = preDP[type][j];\\n            \\n            // store combinations for length 5 to max freq of current digit \\n            for(int j=4+type;j<=maxFreq[i];j++)\\n                dp[j] = (dp[j-1]  + dp[j-2] + dp[j-3] + (type ? dp[j-4] : 0) + MOD)%MOD;\\n            \\n            // get the digit freq chunk multiplications as they are independent\\n            for(int j=0;j<freq[i].size();j++)\\n                totalCount = (totalCount%MOD * dp[freq[i][j]]%MOD) %MOD ;  \\n        }\\n        \\n        return (int)totalCount;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nWe can calculate the letter combination count of each digit type for different length using DP.\\n\\nLetter combinations for digit 2,3,4,5,6,8 is same for length  1 to N as they all have 3 letters in their button\\n\\nBase case combinations: Length 1 to 3\\n\\nLength 1 => [2] => \\'a\\' => 1\\nLength 2 => [2,2] => \\'aa\\', \\'b\\' => 2\\nLength 3 =>  [2,2,2] => \\'aaa\\', \\'ab\\', \\'ba\\', \\'c\\' => 4\\n\\nNow for Length > 3 we can get combination count from previous length combinations\\nLength 4 => [2,2,2,2] => \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' , \\'baa\\' , \\'bb\\', \\'ca\\'  => 7\\n\\nLet first letter as \\'a\\', which has length 1 => [2]\\nThen total letter combination of length 4 with first letter \\'a\\' is DP[4-1] = DP[3] =>  \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' => 4\\n\\nLet first letter as \\'b\\', which has length 2 => [2,2]\\nThen total letter combination of length 4 with first letter \\'b\\' is DP[4-2] = DP[2] =>  \\'baa\\' , \\'bb\\' => 2\\n\\nLet first letter as \\'c\\', which has length 3 => [2,2,2]\\nThen total letter combination of length 4 with first letter \\'c\\' is DP[4-3] = DP[1] =>  \\'ca\\' => 1\\n\\nSo, total letter combination of Length 4 => DP[4-1] + DP[4-2] + DP[4-3] = 4 + 2 + 1 = 7 \\n\\nDP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3]\\n\\nLetter combinations for digit 7 and 9 is same for length  0 to N as they all have 4 letters in their button\\n\\nBase case combinations: Length 1 to 4\\n\\nLength 1 => [7] => \\'p\\' => 1\\nLength 2 => [7,7] => \\'pp\\' or \\'q\\' => 2\\nLength 3 =>  [7,7,7] => \\'ppp\\', \\'pq\\', \\'qp\\', \\'r\\' => 4\\nLength 4 => [7,7,7,7] => \\'pppp\\', \\'ppq\\', \\'pqp\\', \\'pr\\', \\'qq\\', \\'qpp\\', \\'rp\\', \\'s\\' => 8\\n\\nSimilary as above, DP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3] + DP[N-4]\\n\\nFirst we get the max frequency of each digit and their frequency chunks.\\nThen we generate letter combinations for 0 to max frequency of each digit in DP\\nThen we multiply the DP[X] of frequency chunks X of each digit as their letter combinations are independent.\\n```\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressed) {\\n        \\n        int MOD = 1000000007;\\n        int pl = pressed.length();\\n        \\n        // base case combinations for 2-9 digits of length 0 to 4\\n        vector<vector<int>>preDP = {{0,1,2,4},{0,1,2,4,8}};\\n            \\n        // store max freq of each digit and freq chunks\\n        int maxFreq[10] = {};\\n        vector<int>freq[10];\\n        \\n        int curr = -1;\\n        int count = 0;\\n        \\n        for(int i=0;i<pl;i++)\\n        {\\n            if(pressed[i]-\\'0\\' == curr)\\n            {\\n                count++;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].back()++;\\n            }\\n            else\\n            {\\n                curr = pressed[i]-\\'0\\';\\n                count = 1;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].push_back(count);\\n            }\\n        }\\n        \\n        vector<long long>dp(pl+1);\\n        unsigned long long totalCount = 1L;\\n        int type;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(maxFreq[i]==0)continue;\\n            \\n            // get digit type\\n            type = (i==7 || i==9) ? 1 : 0;\\n            \\n            // store the base case combinations for length 0 to 4\\n            for(int j=0;j<=maxFreq[i] && j<=3+type;j++)\\n                dp[j] = preDP[type][j];\\n            \\n            // store combinations for length 5 to max freq of current digit \\n            for(int j=4+type;j<=maxFreq[i];j++)\\n                dp[j] = (dp[j-1]  + dp[j-2] + dp[j-3] + (type ? dp[j-4] : 0) + MOD)%MOD;\\n            \\n            // get the digit freq chunk multiplications as they are independent\\n            for(int j=0;j<freq[i].size();j++)\\n                totalCount = (totalCount%MOD * dp[freq[i][j]]%MOD) %MOD ;  \\n        }\\n        \\n        return (int)totalCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021692,
                "title": "c-dp-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            //firstly if character is same or different then copy last value.\\n            dp[i]=dp[i-1];\\n            //if last two characters are same then also last that value.\\n            if((i-2)>=0 && s[i-1]==s[i-2])\\n                dp[i]=(dp[i]+dp[i-2])%M;\\n            else\\n                continue;\\n            //if last 3 characters are same then also add that value.\\n            if((i-3)>=0 && s[i-1]==s[i-3])\\n                dp[i]=(dp[i]+dp[i-3])%M;\\n            else\\n                continue;\\n            //if we have 7 or 9 as characters we have to also check for 4th character.\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && (i-4)>=0 && s[i-1]==s[i-4])\\n                dp[i]=(dp[i]+dp[i-4])%M;\\n        }\\n        return dp[n]%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            //firstly if character is same or different then copy last value.\\n            dp[i]=dp[i-1];\\n            //if last two characters are same then also last that value.\\n            if((i-2)>=0 && s[i-1]==s[i-2])\\n                dp[i]=(dp[i]+dp[i-2])%M;\\n            else\\n                continue;\\n            //if last 3 characters are same then also add that value.\\n            if((i-3)>=0 && s[i-1]==s[i-3])\\n                dp[i]=(dp[i]+dp[i-3])%M;\\n            else\\n                continue;\\n            //if we have 7 or 9 as characters we have to also check for 4th character.\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && (i-4)>=0 && s[i-1]==s[i-4])\\n                dp[i]=(dp[i]+dp[i-4])%M;\\n        }\\n        return dp[n]%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019195,
                "title": "easy-memoization-o-n-time-c-with-explanation-with-comments",
                "content": "The simplest way to cache sub problems is to break this problem to :\\ntotal ways=No of ways to have one alphabet * number of ways of rest of the string.\\nWe dont have length of rest of the remaining string constant...like 6+rest, 66+rest\\' map to \\'m\\'+rest  and \\'n\\'+rest\\' respectively.\\nSo we iterate  ```No of ways to to have one alphabet```  and add  ``` number of ways of rest of the string```   in each iteration.\\n```\\nclass Solution {\\npublic:\\n    const int M=1000000007;\\n    vector<int>dp;\\n    int count(string &s,int i)\\n    {\\n        if(i==s.size())return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int no=3;//number of characters in the button\\n        if(s[i]==\\'7\\'||s[i]==\\'9\\')no=4;\\n        int ans=0,len=0;\\n        for(int j=i;j<i+no&&j<s.size();j++) //looping over possible alphabets out of the consecutively same  button press.\\n        {\\n            if(s[j]==s[i])ans=(ans+count(s,j+1))%M;//adding number of ways to have the rest of the string\\n                else break;\\n        }\\n        return dp[i]=ans;\\n        \\n    }\\n    int countTexts(string s) {\\n        dp.resize(s.size(),-1);\\n        return count(s,0);\\n    }\\n};\\n```\\nPlease upvote if you find the solution helping.",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```No of ways to to have one alphabet```\n``` number of ways of rest of the string```\n```\\nclass Solution {\\npublic:\\n    const int M=1000000007;\\n    vector<int>dp;\\n    int count(string &s,int i)\\n    {\\n        if(i==s.size())return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int no=3;//number of characters in the button\\n        if(s[i]==\\'7\\'||s[i]==\\'9\\')no=4;\\n        int ans=0,len=0;\\n        for(int j=i;j<i+no&&j<s.size();j++) //looping over possible alphabets out of the consecutively same  button press.\\n        {\\n            if(s[j]==s[i])ans=(ans+count(s,j+1))%M;//adding number of ways to have the rest of the string\\n                else break;\\n        }\\n        return dp[i]=ans;\\n        \\n    }\\n    int countTexts(string s) {\\n        dp.resize(s.size(),-1);\\n        return count(s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018536,
                "title": "c-for-everyone-who-are-scared-of-dp-like-me",
                "content": "* So I experimented with `2`, `22`, `222` and realised that for `2222` the answer is the sum of previous 3 and this goes on.\\n* Now after doing this I was stuck thinking all the numbers have 3 letters but for `7` and `9`, the story is different since they have 4 letters.\\n* So I experimented **again** with `9`, `99`, `999`, `9999` and realised that for `99999` the answer is the sum of previous 4 and this goes on.\\n* And Boom **AC**.\\n\\n`//Experiment part`\\nWhy we do `dp[n] = dp[n-1] + dp[n-2] + dp[n-3]` ?\\nBecause we have 3 options,\\nLets take example of `22222`.\\n\\n`22222` = `2|2222` + `22|222` + `222|22`.\\nBasically we select the first (1-3) numbers and rest are already calculated.\\n**Note:** we can\\'t have a combination like this `2222|2` since four 2\\'s don\\'t make any combination(in case of 2 but in case of 7 and 9 its does and therefore the summation goes till `dp[n-4]` there).\\n\\n```\\nconst int mod = 1e9 + 7;\\nconst int mxx = 1e5 + 1;\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> a, b;\\n    \\n    Solution()\\n    {\\n        a.resize(mxx, 0);\\n        a[1] = 1;\\n        a[2] = 2;\\n        a[3] = 4;\\n        \\n        for(int i=4; i<=1e5; i++)\\n        {\\n            a[i] = ((a[i-1] + a[i-2]) % mod + a[i-3]) % mod;\\n        }\\n        \\n        b.resize(mxx, 0);\\n        b[1] = 1;\\n        b[2] = 2;\\n        b[3] = 4;\\n        b[4] = 8;\\n        \\n        for(int i=5; i<=1e5; i++)\\n        {\\n            b[i] = ((((b[i-1] + b[i-2]) % mod + b[i-3]) % mod) + b[i-4]) % mod;\\n        }\\n    }\\n    \\n    int countTexts(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n        \\n        int cnt = 1;\\n        int i = 0;\\n        while(i+1 < n)\\n        {\\n            while(i+1 < n && s[i] == s[i+1]) \\n            {\\n                cnt++;\\n                i++;\\n            }\\n            // cout << a[cnt] << \" \";\\n            if(s[i] != \\'7\\' && s[i] != \\'9\\')\\n                ans = ((ll)ans * (ll)a[cnt]) % mod;\\n            else\\n                ans = ((ll)ans * (ll)b[cnt]) % mod;\\n            \\n            cnt = 1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nActually the `experimented` part is something which is really hard for me explain. Do some experiment on your own and maybe it will click.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nconst int mod = 1e9 + 7;\\nconst int mxx = 1e5 + 1;\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> a, b;\\n    \\n    Solution()\\n    {\\n        a.resize(mxx, 0);\\n        a[1] = 1;\\n        a[2] = 2;\\n        a[3] = 4;\\n        \\n        for(int i=4; i<=1e5; i++)\\n        {\\n            a[i] = ((a[i-1] + a[i-2]) % mod + a[i-3]) % mod;\\n        }\\n        \\n        b.resize(mxx, 0);\\n        b[1] = 1;\\n        b[2] = 2;\\n        b[3] = 4;\\n        b[4] = 8;\\n        \\n        for(int i=5; i<=1e5; i++)\\n        {\\n            b[i] = ((((b[i-1] + b[i-2]) % mod + b[i-3]) % mod) + b[i-4]) % mod;\\n        }\\n    }\\n    \\n    int countTexts(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n        \\n        int cnt = 1;\\n        int i = 0;\\n        while(i+1 < n)\\n        {\\n            while(i+1 < n && s[i] == s[i+1]) \\n            {\\n                cnt++;\\n                i++;\\n            }\\n            // cout << a[cnt] << \" \";\\n            if(s[i] != \\'7\\' && s[i] != \\'9\\')\\n                ans = ((ll)ans * (ll)a[cnt]) % mod;\\n            else\\n                ans = ((ll)ans * (ll)b[cnt]) % mod;\\n            \\n            cnt = 1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2017834,
                "title": "python3-group-by-group",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/9aa0edb0815f3e0a75a47808e1690ca424f169e5) for solutions of weekly 292. \\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 1_000_000_007 \\n        \\n        @cache \\n        def fn(n, k): \\n            \"\"\"Return number of possible text of n repeated k times.\"\"\"\\n            if n < 0: return 0\\n            if n == 0: return 1\\n            ans = 0\\n            for x in range(1, k+1): ans = (ans + fn(n-x, k)) % MOD\\n            return ans \\n        \\n        ans = 1\\n        for key, grp in groupby(pressedKeys): \\n            if key in \"79\": k = 4\\n            else: k = 3\\n            ans = (ans * fn(len(list(grp)), k)) % MOD \\n        return ans \\n```\\n\\nAdded a shorter implementation \\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0] * (len(pressedKeys)+1)\\n        dp[0] = 1\\n        for i, ch in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            if i and pressedKeys[i-1] == ch: \\n                dp[i+1] += dp[i-1]\\n                if i >= 2 and pressedKeys[i-2] == ch: \\n                    dp[i+1] += dp[i-2]\\n                    if i >= 3 and pressedKeys[i-3] == ch and ch in \"79\": dp[i+1] += dp[i-3]\\n            dp[i+1] %= 1_000_000_007\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 1_000_000_007 \\n        \\n        @cache \\n        def fn(n, k): \\n            \"\"\"Return number of possible text of n repeated k times.\"\"\"\\n            if n < 0: return 0\\n            if n == 0: return 1\\n            ans = 0\\n            for x in range(1, k+1): ans = (ans + fn(n-x, k)) % MOD\\n            return ans \\n        \\n        ans = 1\\n        for key, grp in groupby(pressedKeys): \\n            if key in \"79\": k = 4\\n            else: k = 3\\n            ans = (ans * fn(len(list(grp)), k)) % MOD \\n        return ans \\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0] * (len(pressedKeys)+1)\\n        dp[0] = 1\\n        for i, ch in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            if i and pressedKeys[i-1] == ch: \\n                dp[i+1] += dp[i-1]\\n                if i >= 2 and pressedKeys[i-2] == ch: \\n                    dp[i+1] += dp[i-2]\\n                    if i >= 3 and pressedKeys[i-3] == ch and ch in \"79\": dp[i+1] += dp[i-3]\\n            dp[i+1] %= 1_000_000_007\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018347,
                "title": "python-top-down-dp-time-o-4-n-easy-understanding",
                "content": "The result is solely impacted by the following four digits at index i.\\nNote that using MOD everywhere can save you a lot of time!\\n\\nTime: O(4*n)\\n\\n``` py\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mp = set([\"2\", \"22\", \"222\",\\n                  \"3\", \"33\", \"333\",\\n                  \\'4\\', \\'44\\', \\'444\\',\\n                  \\'5\\', \\'55\\', \\'555\\',\\n                  \\'6\\', \\'66\\', \\'666\\',\\n                  \\'7\\', \\'77\\', \\'777\\', \\'7777\\', \\n                  \\'8\\', \\'88\\', \\'888\\', \\n                  \\'9\\', \\'99\\', \\'999\\', \\'9999\\'])\\n        MOD = 10**9+7\\n        \\n        @cache\\n        def dp(i):\\n            if i>=len(A): return 1\\n            ans = 0\\n            if i+1<=len(A) and A[i:i+1] in mp: ans += dp(i+1)%MOD\\n            if i+2<=len(A) and A[i:i+2] in mp: ans += dp(i+2)%MOD\\n            if i+3<=len(A) and A[i:i+3] in mp: ans += dp(i+3)%MOD\\n            if i+4<=len(A) and A[i:i+4] in mp: ans += dp(i+4)%MOD\\n            return ans%MOD\\n        \\n        return dp(0)%MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "``` py\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mp = set([\"2\", \"22\", \"222\",\\n                  \"3\", \"33\", \"333\",\\n                  \\'4\\', \\'44\\', \\'444\\',\\n                  \\'5\\', \\'55\\', \\'555\\',\\n                  \\'6\\', \\'66\\', \\'666\\',\\n                  \\'7\\', \\'77\\', \\'777\\', \\'7777\\', \\n                  \\'8\\', \\'88\\', \\'888\\', \\n                  \\'9\\', \\'99\\', \\'999\\', \\'9999\\'])\\n        MOD = 10**9+7\\n        \\n        @cache\\n        def dp(i):\\n            if i>=len(A): return 1\\n            ans = 0\\n            if i+1<=len(A) and A[i:i+1] in mp: ans += dp(i+1)%MOD\\n            if i+2<=len(A) and A[i:i+2] in mp: ans += dp(i+2)%MOD\\n            if i+3<=len(A) and A[i:i+3] in mp: ans += dp(i+3)%MOD\\n            if i+4<=len(A) and A[i:i+4] in mp: ans += dp(i+4)%MOD\\n            return ans%MOD\\n        \\n        return dp(0)%MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786290,
                "title": "recursion-memoization-c-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**If a substring contains the same characters (\\'22...\\', \\'9999......\\', \\'5555......\\',..............) How many text are possible by this substring**................................\\uD83E\\uDD14\\n\\n**Think about the above statement and try to write the code...........**\\n\\nhere the approach is simple that we are counting the possible text for a substring that has the same characters and multiplying all the results to get all the possible text.\\n\\n\\n```\\nFor example:- p = \\'222544\\'\\nsubstring with same characters = \\'222\\', \\'5\\', \\'44\\'\\n\\'222\\' Possible texts:- \\'a\\', \\'ba\\', \\'ab\\', \\'c\\'(4)\\n\\'5\\' Possible texts:- \\'j\\'(1)\\n\\'44\\' Possible texts:- \\'gg\\',\\'h\\'(2)\\n\\nNumber of all possible texts = 4 * 1 * 2 = 8\\n```\\n**Note:-**\\nHere you can see that after enumerating the possible text for a substring I removed all the entries from dp as the previous entry of the same character became invalid so I did that.\\n\\n```\\nFor example:- p = \\'222322\\'\\nHere we can see that \\'2\\' appears in two substrings:-\\n          str1 = \\'222\\' and str2 = \\'22\\'\\n\\nWhen enumerating possible text for str-2, all previous entries\\nstr-1 became invalid so we need to remove them.\\n```\\n# Complexity\\n- Time complexity:O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,char>,int> dp;\\n    int mod = 1e9+7;\\n    long long solve(char c,long long n,long long i)\\n    {\\n        if(i>n) return 0;\\n        if(i>=n-1) return 1;\\n        if(dp.find({i,c})!=dp.end()) return dp[{i,c}];\\n        long long c1 = solve(c,n,i+1);\\n        long long c2 = solve(c,n,i+2);\\n        long long c3 = solve(c,n,i+3);\\n        long long c4 = solve(c,n,i+4);\\n\\n        if(c==\\'7\\' || c==\\'9\\')\\n        return dp[{i,c}] = (c1+c2+c3+c4)%mod;\\n        \\n        return dp[{i,c}] = (c1+c2+c3)%mod;\\n    }\\n    int countTexts(string p) {\\n       long long count = 1,ans = 1;\\n       for(int i = 1;i<p.size();i++)\\n       {\\n           if(p[i]==p[i-1]) count++;\\n           if(p[i]!=p[i-1] || i==p.size()-1)\\n           {\\n               int x = solve(p[i-1],count,0)%mod;\\n               dp.clear();\\n               ans  = ((ans%mod)*(x%mod))%mod;\\n               count = 1;\\n           }\\n       }\\n       return ans%mod;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/347a58e4-fc48-4a72-a4dc-b53ecd812bfa_1689747372.1231217.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nFor example:- p = \\'222544\\'\\nsubstring with same characters = \\'222\\', \\'5\\', \\'44\\'\\n\\'222\\' Possible texts:- \\'a\\', \\'ba\\', \\'ab\\', \\'c\\'(4)\\n\\'5\\' Possible texts:- \\'j\\'(1)\\n\\'44\\' Possible texts:- \\'gg\\',\\'h\\'(2)\\n\\nNumber of all possible texts = 4 * 1 * 2 = 8\\n```\n```\\nFor example:- p = \\'222322\\'\\nHere we can see that \\'2\\' appears in two substrings:-\\n          str1 = \\'222\\' and str2 = \\'22\\'\\n\\nWhen enumerating possible text for str-2, all previous entries\\nstr-1 became invalid so we need to remove them.\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int,char>,int> dp;\\n    int mod = 1e9+7;\\n    long long solve(char c,long long n,long long i)\\n    {\\n        if(i>n) return 0;\\n        if(i>=n-1) return 1;\\n        if(dp.find({i,c})!=dp.end()) return dp[{i,c}];\\n        long long c1 = solve(c,n,i+1);\\n        long long c2 = solve(c,n,i+2);\\n        long long c3 = solve(c,n,i+3);\\n        long long c4 = solve(c,n,i+4);\\n\\n        if(c==\\'7\\' || c==\\'9\\')\\n        return dp[{i,c}] = (c1+c2+c3+c4)%mod;\\n        \\n        return dp[{i,c}] = (c1+c2+c3)%mod;\\n    }\\n    int countTexts(string p) {\\n       long long count = 1,ans = 1;\\n       for(int i = 1;i<p.size();i++)\\n       {\\n           if(p[i]==p[i-1]) count++;\\n           if(p[i]!=p[i-1] || i==p.size()-1)\\n           {\\n               int x = solve(p[i-1],count,0)%mod;\\n               dp.clear();\\n               ans  = ((ans%mod)*(x%mod))%mod;\\n               count = 1;\\n           }\\n       }\\n       return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024229,
                "title": "c-o-n-solution-with-explanation",
                "content": "At any point you have couple of things to do and that is you can choose current character \\n\\n1. As a single character so the answer will be what was at i-1 index because you\\'re adding current character as single character \\n\\n2. Taking current character with last so i-2 will be the added to the answer\\n3. Taking till i-2 character so i-3 will be added to answer\\n4. In case of 7, 9 Taking i-3 character so i-4 will be added to the answer\\n\\nHere is an example to that\\n\\nsuppose we have 222\\n\\nfor i = 0 we can only get \\na\\n\\nfor i = 1 we can get\\naa b\\n\\nfor i = 2 we can get\\n\\n(First taking current character as single)\\naa-a (2-2-2)\\nb-a (22-2)\\n\\n(Taking current with last)\\na-b (2-22)\\n\\nTaking till i-2\\nc (222)\\n\\nIn the solution we\\'ll first calculate the combinations\\n\\n\\n```\\n#define mod 1000000007\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        \\n        int n = s.size();\\n        \\n        if(n<3){\\n            return n;\\n        }\\n        \\n        ll ans = 1;\\n        vector<ll> dp1(n+1,0);\\n        vector<ll> dp2(n+1,0);\\n        \\n        dp1[0] = 1;\\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n        \\n        dp2[0] = 1;\\n        dp2[1] = 1;\\n        dp2[2] = 2;\\n        dp2[3] = 4;\\n        \\n        for(int i = 3 ; i <= n ; i++)    \\n            dp1[i] = (dp1[i-1] + dp1[i-2] + dp1[i-3])%mod;\\n        \\n        for(int i = 4 ; i <= n ; i++)    //for 7 & 9\\n            dp2[i] = (dp2[i-1] + dp2[i-2] + dp2[i-3] + dp2[i-4])%mod;\\n        \\n        int i = 0;\\n        \\n        int start = -1;\\n        \\n        while(i<n-1){\\n            \\n            while(i<n-1 && s[i]==s[i+1])//finding the length same consecutive characters\\n                i++;\\n            \\n            int len = i-start;\\n            \\n            if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                ans = (ans*dp2[len])%mod; //multiplying because for 2 different consecutive characters we can\\'t add for ex if at first place we have 2 options and for place two also 2 option then if we combine we\\'ll have 4 options in total for better understanding see example 1 of the question\\n            else\\n                ans = (ans*dp1[len])%mod;\\n            \\n            start = i;\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define mod 1000000007\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        \\n        int n = s.size();\\n        \\n        if(n<3){\\n            return n;\\n        }\\n        \\n        ll ans = 1;\\n        vector<ll> dp1(n+1,0);\\n        vector<ll> dp2(n+1,0);\\n        \\n        dp1[0] = 1;\\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n        \\n        dp2[0] = 1;\\n        dp2[1] = 1;\\n        dp2[2] = 2;\\n        dp2[3] = 4;\\n        \\n        for(int i = 3 ; i <= n ; i++)    \\n            dp1[i] = (dp1[i-1] + dp1[i-2] + dp1[i-3])%mod;\\n        \\n        for(int i = 4 ; i <= n ; i++)    //for 7 & 9\\n            dp2[i] = (dp2[i-1] + dp2[i-2] + dp2[i-3] + dp2[i-4])%mod;\\n        \\n        int i = 0;\\n        \\n        int start = -1;\\n        \\n        while(i<n-1){\\n            \\n            while(i<n-1 && s[i]==s[i+1])//finding the length same consecutive characters\\n                i++;\\n            \\n            int len = i-start;\\n            \\n            if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                ans = (ans*dp2[len])%mod; //multiplying because for 2 different consecutive characters we can\\'t add for ex if at first place we have 2 options and for place two also 2 option then if we combine we\\'ll have 4 options in total for better understanding see example 1 of the question\\n            else\\n                ans = (ans*dp1[len])%mod;\\n            \\n            start = i;\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374298,
                "title": "python-sliding-window-o-1-space",
                "content": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    \\n    def countTexts(self, pressed_keys: str) -> int:\\n        \\n        key_letters = {\\n            \"2\": 3,\\n            \"3\": 3,\\n            \"4\": 3,\\n            \"5\": 3,\\n            \"6\": 3,\\n            \"7\": 4,\\n            \"8\": 3,\\n            \"9\": 4,\\n        }\\n        \\n        ans = 1\\n        current_count = 1\\n        prev_key = \"\" \\n        previous = deque([]) \\n        \\n        for pressed_key in pressed_keys:\\n            \\n            if pressed_key != prev_key:\\n                ans = (ans * current_count) % (10**9 + 7)\\n                previous = deque([1])\\n                current_count = 1 \\n                prev_key = pressed_key\\n            \\n            current_count = sum(previous) \\n            \\n            if len(previous) == key_letters[pressed_key]:\\n                previous.popleft()\\n                \\n            previous.append(current_count)\\n             \\n        ans = (ans * current_count) % (10**9 + 7)\\n        \\n        return ans\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    \\n    def countTexts(self, pressed_keys: str) -> int:\\n        \\n        key_letters = {\\n            \"2\": 3,\\n            \"3\": 3,\\n            \"4\": 3,\\n            \"5\": 3,\\n            \"6\": 3,\\n            \"7\": 4,\\n            \"8\": 3,\\n            \"9\": 4,\\n        }\\n        \\n        ans = 1\\n        current_count = 1\\n        prev_key = \"\" \\n        previous = deque([]) \\n        \\n        for pressed_key in pressed_keys:\\n            \\n            if pressed_key != prev_key:\\n                ans = (ans * current_count) % (10**9 + 7)\\n                previous = deque([1])\\n                current_count = 1 \\n                prev_key = pressed_key\\n            \\n            current_count = sum(previous) \\n            \\n            if len(previous) == key_letters[pressed_key]:\\n                previous.popleft()\\n                \\n            previous.append(current_count)\\n             \\n        ans = (ans * current_count) % (10**9 + 7)\\n        \\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126835,
                "title": "javascript-solution-dp",
                "content": "```\\nvar countTexts = function(pressedKeys) {\\n    const MOD = 1e9 + 7;\\n    const n = pressedKeys.length;\\n    const dp = new Array(n + 1).fill(0);\\n    \\n    dp[0] = 1;\\n    \\n    let lastChar = \"\";\\n    let repeatCount = 0;\\n    \\n    for (let i = 1; i <= n; ++i) {\\n        const currChar = pressedKeys[i - 1];\\n        \\n        if (currChar != lastChar) repeatCount = 0;\\n        \\n        lastChar = currChar;\\n        repeatCount += 1;\\n        \\n        dp[i] = (dp[i] + dp[i - 1]) % MOD;\\n        \\n        if (i >= 2 && repeatCount >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\\n        if (i >= 3 && repeatCount >= 3) dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n        if ((currChar == \"7\"  || currChar == \"9\") && i >= 4 && repeatCount >= 4) dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n     }\\n    \\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar countTexts = function(pressedKeys) {\\n    const MOD = 1e9 + 7;\\n    const n = pressedKeys.length;\\n    const dp = new Array(n + 1).fill(0);\\n    \\n    dp[0] = 1;\\n    \\n    let lastChar = \"\";\\n    let repeatCount = 0;\\n    \\n    for (let i = 1; i <= n; ++i) {\\n        const currChar = pressedKeys[i - 1];\\n        \\n        if (currChar != lastChar) repeatCount = 0;\\n        \\n        lastChar = currChar;\\n        repeatCount += 1;\\n        \\n        dp[i] = (dp[i] + dp[i - 1]) % MOD;\\n        \\n        if (i >= 2 && repeatCount >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\\n        if (i >= 3 && repeatCount >= 3) dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n        if ((currChar == \"7\"  || currChar == \"9\") && i >= 4 && repeatCount >= 4) dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n     }\\n    \\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2020148,
                "title": "10-line-dp-python-o-n-o-1-beat-100-100-a-easy-bottom-up",
                "content": "```\\nclass Solution(object):\\n    def countTexts(self, keys):\\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 } # dictionary!\\n        \\n        # e.g  dp means all possibilities ending now. 4 status totaly dp2 means we quickly press same num for 2 times. (33)-->e\\n        dp1, dp2, dp3, dp4 = 1, 0, 0, 0   # assuming we passed first key, dp1 is 1\\n\\t\\t\\n        for i in range(1, len(keys)):\\n            if keys[i] == keys[i-1]: # if same with before, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), dp1, dp2, 0 if dic[keys[i]] == 3 else dp3\\n            else: # and when not same, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), 0, 0, 0\\n\\t\\t\\t\\t\\n        return (dp1 + dp2 + dp3 + dp4) % (10**9+7)\\n\\t\\t\\n\\t\\t\\nActually the status is pretty clear. There are 3-4 status when ending at each index among the keys, and status transfer is also clear to see. \\n```\\n\\n\\n\\n\\n```\\n#Also here\\'s top-down dp ( = dfs + memo). Same time complexity, O(N) space. \\nclass Solution:\\n    def countTexts(self, keys: str) -> int:\\n        \\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 }\\n\\n        @lru_cache(None)\\n        def dp(i, acc):\\n            if i == 0:\\n                if acc == 1:\\n                    return 1\\n                return 0\\n\\n            if acc == 1:\\n                return sum([ dp(i-1, k) for k in range(1, dic[keys[i-1]] +1) ]) % (10**9+7)\\n            \\n            if keys[i] == keys[i-1]:\\n                return dp(i-1, acc-1)\\n            \\n            return 0\\n        \\n        return sum([ dp(len(keys)-1, k) for k in range(1, dic[keys[-1]]+1) ]) % (10**9+7)\\n    ```\\n\\t\\n\\n\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def countTexts(self, keys):\\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 } # dictionary!\\n        \\n        # e.g  dp means all possibilities ending now. 4 status totaly dp2 means we quickly press same num for 2 times. (33)-->e\\n        dp1, dp2, dp3, dp4 = 1, 0, 0, 0   # assuming we passed first key, dp1 is 1\\n\\t\\t\\n        for i in range(1, len(keys)):\\n            if keys[i] == keys[i-1]: # if same with before, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), dp1, dp2, 0 if dic[keys[i]] == 3 else dp3\\n            else: # and when not same, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), 0, 0, 0\\n\\t\\t\\t\\t\\n        return (dp1 + dp2 + dp3 + dp4) % (10**9+7)\\n\\t\\t\\n\\t\\t\\nActually the status is pretty clear. There are 3-4 status when ending at each index among the keys, and status transfer is also clear to see. \\n```\n```\\n#Also here\\'s top-down dp ( = dfs + memo). Same time complexity, O(N) space. \\nclass Solution:\\n    def countTexts(self, keys: str) -> int:\\n        \\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 }\\n\\n        @lru_cache(None)\\n        def dp(i, acc):\\n            if i == 0:\\n                if acc == 1:\\n                    return 1\\n                return 0\\n\\n            if acc == 1:\\n                return sum([ dp(i-1, k) for k in range(1, dic[keys[i-1]] +1) ]) % (10**9+7)\\n            \\n            if keys[i] == keys[i-1]:\\n                return dp(i-1, acc-1)\\n            \\n            return 0\\n        \\n        return sum([ dp(len(keys)-1, k) for k in range(1, dic[keys[-1]]+1) ]) % (10**9+7)\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2019026,
                "title": "javascript-coin-change-dp-113ms",
                "content": "```\\nconst mod = 1e9 + 7;\\nconst cal = (c) => c == \\'7\\' || c == \\'9\\' ? 4 : 3\\n\\nconst countTexts = (s) => {\\n    let n = s.length;\\n    let dp = Array(n + 1).fill(0);\\n    dp[0] = 1;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 1; j <= cal(s[i]); j++) {\\n            let len = i - j + 1;\\n            if (len < 0 || s[i] != s[len]) break;\\n            dp[i + 1] += dp[i + 1 - j];\\n        }\\n        dp[i + 1] %= mod;\\n    }\\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst mod = 1e9 + 7;\\nconst cal = (c) => c == \\'7\\' || c == \\'9\\' ? 4 : 3\\n\\nconst countTexts = (s) => {\\n    let n = s.length;\\n    let dp = Array(n + 1).fill(0);\\n    dp[0] = 1;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 1; j <= cal(s[i]); j++) {\\n            let len = i - j + 1;\\n            if (len < 0 || s[i] != s[len]) break;\\n            dp[i + 1] += dp[i + 1 - j];\\n        }\\n        dp[i + 1] %= mod;\\n    }\\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018146,
                "title": "c-top-down-recursive-and-memoization-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int dp[100001][5];\\n    long long d=1000000007;\\n    int get(int n,int k)\\n    {\\n        if(n<0) return 0; // not valid\\n        if(n==0) return 1; // valid\\n        if(dp[n][k]!=-1) return dp[n][k];\\n\\n        long long result=0;\\n        for(int i=1;i<=k;i++) result=(result+get(n-i,k))%d; // i pressed counts are used\\n        dp[n][k]=result;\\n        return result;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        long long result=1,a[10],n=pressedKeys.length(),c=1;\\n\\n        for(int i=0;i<10;i++) a[i]=3; // a[i] is the number of available alphabets for a given digit i\\n        a[7]=4;\\n        a[9]=4;\\n        pressedKeys+=\"0\"; // add a never-appeared digit at the end to make the below code concise\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(pressedKeys[i]==pressedKeys[i-1]) c++; // same digits\\n            else result=(result*get(c,a[pressedKeys[i-1]-\\'0\\']))%d, c=1; // find a different digit, so process the previous same digits\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int dp[100001][5];\\n    long long d=1000000007;\\n    int get(int n,int k)\\n    {\\n        if(n<0) return 0; // not valid\\n        if(n==0) return 1; // valid\\n        if(dp[n][k]!=-1) return dp[n][k];\\n\\n        long long result=0;\\n        for(int i=1;i<=k;i++) result=(result+get(n-i,k))%d; // i pressed counts are used\\n        dp[n][k]=result;\\n        return result;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        long long result=1,a[10],n=pressedKeys.length(),c=1;\\n\\n        for(int i=0;i<10;i++) a[i]=3; // a[i] is the number of available alphabets for a given digit i\\n        a[7]=4;\\n        a[9]=4;\\n        pressedKeys+=\"0\"; // add a never-appeared digit at the end to make the below code concise\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(pressedKeys[i]==pressedKeys[i-1]) c++; // same digits\\n            else result=(result*get(c,a[pressedKeys[i-1]-\\'0\\']))%d, c=1; // find a different digit, so process the previous same digits\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731706,
                "title": "c-easy-recursion-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524389,
                "title": "easy-to-understand-solution-using-combinations-and-dp",
                "content": "The approach is like, first of all we will find the number of texts possible for each substring containing same numbers. Then finally multiply all the values possible number of texts for each substring to  get total number of texts possible  for entire string. \\nHope you Like it!\\n\\n\\n```\\n\\nint countTexts(string s) {\\n        \\n        int n = s.size();\\n        int md  = 1e9+7;\\n        \\n        vector<long long> dp(n,0);\\n        dp[0]=1;\\n        int cnt = 1;\\n        \\n        long long ans = 1;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(s[i]==s[i-1]){\\n                cnt++;\\n                if(s[i] == \\'7\\' || s[i] == \\'9\\'){\\n                    if(cnt<=4){\\n                        dp[i] = 1;\\n                    }\\n                    \\n                        int k = min( cnt-1,4);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                            dp[i] %= md;\\n                            k--;\\n                        }\\n                    \\n                }else {\\n                    \\n                       if(cnt<=3){\\n                        dp[i] = 1;}\\n                    \\n                        int k = min( cnt-1,3);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                         dp[i] %= md;\\n\\n                            k--;\\n                        }\\n                }\\n            }else {\\n                //reseting the count for new substring with different values.\\n                cnt = 1;\\n                dp[i] = 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// adding answer to previous substring.\\n                ans = (ans*dp[i-1])%md;\\n                \\n            }\\n\\t}\\n\\n\\tans = (ans*dp[n-1])%md;\\n\\n\\treturn (int) ans;\\n}\\n\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\n\\nint countTexts(string s) {\\n        \\n        int n = s.size();\\n        int md  = 1e9+7;\\n        \\n        vector<long long> dp(n,0);\\n        dp[0]=1;\\n        int cnt = 1;\\n        \\n        long long ans = 1;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(s[i]==s[i-1]){\\n                cnt++;\\n                if(s[i] == \\'7\\' || s[i] == \\'9\\'){\\n                    if(cnt<=4){\\n                        dp[i] = 1;\\n                    }\\n                    \\n                        int k = min( cnt-1,4);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                            dp[i] %= md;\\n                            k--;\\n                        }\\n                    \\n                }else {\\n                    \\n                       if(cnt<=3){\\n                        dp[i] = 1;}\\n                    \\n                        int k = min( cnt-1,3);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                         dp[i] %= md;\\n\\n                            k--;\\n                        }\\n                }\\n            }else {\\n                //reseting the count for new substring with different values.\\n                cnt = 1;\\n                dp[i] = 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// adding answer to previous substring.\\n                ans = (ans*dp[i-1])%md;\\n                \\n            }\\n\\t}\\n\\n\\tans = (ans*dp[n-1])%md;\\n\\n\\treturn (int) ans;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2405125,
                "title": "c-linear-time-constant-space-solution",
                "content": "## Simple Inputs\\n\\n#### Example 1.1: \"23578\"\\n\\nQ: What if we don\\'t have repetitions in the input string?\\n\\nA: Our fingers just press each key once to produce the message.\\n\\n> The answer is 1\\n\\n#### Example 1.2: \"235782783578\"\\n\\nQ: What if we do have some same digit appear across the input string?\\n\\nA: As long as they are not back-to-back grouping with their own kinds,\\nour fingers still need to press each key once and move around for another.\\n\\n> The answer is still 1\\n\\n#### Short Summary\\n\\nIn examples 1.x, things are simple. \\nWe can safely assume \\n\\n> finger movement **must** occur between **all** adjacent keys\\n\\nand hence one-and-only-one message can be incurred from each of these input strings.\\n\\n## Fancy Inputs\\n\\nAs the problem suggest, we may have same digit in some groups of contiguous substring.\\n\\nWe somehow still want the observation in examples 1.x to happen here.\\nExcept that this time, we can only do \\n\\n> finger movement **may** occur between **some** adjacent keys\\n\\nConsidering this, we may want to cut `\"22233\"` into `\"222\"` and `\"33\"`.\\n\\n**Q: How exactly is `count(\"22233\")` and `count(\"222\")` and `count(\"33\")` are related?**\\n\\n#### Example 2: \"22233\"\\n\\nSince our finger shall jump between `2` and `3` at some point,\\nLet\\'s say we press `222` and form `ba`.\\n**Then we must break the continuity and switch keys** (from `2` to `3`).\\nNext, pressing `33` can give a `e`.\\nThe final message `bae` is then formed by concatenating the pre-chosen segments.\\n\\nMore precisely, \\neach of the possible outcome from `222` can be paired with an outcome from `33` \\nfor producing a possible message.\\n\\nThus, the Product Rule (from Discrete Maths) applies.\\n\\n```\\ncount(\"22233\")   =   count(\"222\")   \\xD7   count(\"33\")\\n```\\n\\n## Extract Subroutine\\n\\nWe can imagine how the product expands, when more **contiguous substrings of same character** present.\\n\\nSay we extract out a subroutine for solving contiguous substrings of this kind, \\n\\n```c++\\nint countSameTexts(char& cc, int& count);\\n```\\n\\nthen we can formulate our solver progam as below. \\n\\n```c++\\nclass Solution {\\npublic:\\n    long modulo = 1000000007;\\n    int countSameTexts(char& cc, int& count);\\n    int countTexts(string pressedKeys) {\\n        long res = 1;\\n        int count = 0;\\n        char current = pressedKeys[0];\\n        for (char& c: pressedKeys)\\n            /* Accumulate count for contiguous substrings of same character */\\n            if (current == c)\\n                count++;\\n            /* Update `res` by Product Rule and `modulo` during key-switch */\\n            else {\\n                res = (res * countSameTexts(current, count)) % modulo;\\n                current = c;\\n                count = 1; // Reset count\\n            }\\n        /* Update `res` one final time */\\n        return (res * countSameTexts(current, count)) % modulo;\\n    }\\n};\\n```\\n\\n## Construct Subroutine By Dynamic Programming\\n\\n### Case 1: 7, 9\\n\\n#### Arbitrary length n\\nFrom the given repetition rule, a string with length `n` can be formed by one of the following.\\n- character formed by subtring of length `1` + chracters from remaining substrings of length `(n - 1)`\\n- character formed by subtring of length `2` + chracters from remaining substrings of length `(n - 2)`\\n- character formed by subtring of length `3` + chracters from remaining substrings of length `(n - 3)`\\n- character formed by subtring of length `4` + chracters from remaining substrings of length `(n - 4)`\\n\\nSub-optimal property is obviously preserved, \\nsince any length of substring from the original string always contains the same character.\\n\\nThe above events are disjoint and exhaustive.\\nThus, the Sum Rule (from Discrete Maths) applies.\\n\\n```\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\\n\\n#### Base Case of length 1, 2, 3, 4\\n\\nFor `n = 1`, obviously `Count_79(2) = 1`.\\n\\nFor `n = 2`, we have `7, 7` or `77`. so `Count_79(2) = 2`.\\n\\nFor `n = 3`, we have `7, 7, 7` or `7, 77` or `77, 7` or `777`. so `Count_79(3) = 4`.\\n\\nFor `n = 4`, the count will involve\\n- 1 permutation involving `7`\\n- 3 permutation involving `7` and `77`\\n- 2 permutation involving `7` and `777`\\n- 1 permutation involving `77` and `77`\\n- 1 permutation involving `7777`\\nHence, `Count_79(4) = 8`.\\n\\n#### Complete Formula \\n\\nFrom base case and recursion, we can obtain the complete formula ... (1)\\n\\n```\\nCount_79(1)   =   1\\nCount_79(2)   =   2\\nCount_79(3)   =   4\\nCount_79(4)   =   8\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\\n\\n### Case 2: 2, 3, 4, 5, 6, 8\\n\\n#### Complete Formula \\n\\nFollow a similar analysis as above, we can have the below formula ... (2)\\n\\n(Can you deduce the details?)\\n\\n```\\nCount_234568(1)   =   1\\nCount_234568(2)   =   2\\nCount_234568(3)   =   4\\nCount_234568(n)   =   Count_234568(n - 1)   +   Count_234568(n - 2)   +   Count_234568(n - 3)\\n```\\n\\n### Code\\n\\nThe code can easily be written, with bottom-up DP.\\n\\n```c++\\nint Solution::countSameTexts(char& cc, int& count) {\\n    // Count for 7, 9\\n    if (cc == \\'7\\' || cc == \\'9\\') {\\n        if (count <= 4)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        long d = 1 << 3;\\n        for (int i = 4; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = d;\\n            long new_d = (a + b + c + d) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n            d = new_d;\\n        }\\n        return d;\\n    }\\n    // Count for 2, 3, 4, 5, 6, 8\\n    else {        \\n        if (count <= 3)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        for (int i = 3; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = (a + b + c) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\n## Possible Optimization\\n\\nFormula in (1) and (2) can easily be speed-up to logarithmic cost, by (binary) exponetiation of matrix.\\nI invite readers to develop a fancy (or somewhat standard) program with this approach :)\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\ncount(\"22233\")   =   count(\"222\")   \\xD7   count(\"33\")\\n```\n```c++\\nint countSameTexts(char& cc, int& count);\\n```\n```c++\\nclass Solution {\\npublic:\\n    long modulo = 1000000007;\\n    int countSameTexts(char& cc, int& count);\\n    int countTexts(string pressedKeys) {\\n        long res = 1;\\n        int count = 0;\\n        char current = pressedKeys[0];\\n        for (char& c: pressedKeys)\\n            /* Accumulate count for contiguous substrings of same character */\\n            if (current == c)\\n                count++;\\n            /* Update `res` by Product Rule and `modulo` during key-switch */\\n            else {\\n                res = (res * countSameTexts(current, count)) % modulo;\\n                current = c;\\n                count = 1; // Reset count\\n            }\\n        /* Update `res` one final time */\\n        return (res * countSameTexts(current, count)) % modulo;\\n    }\\n};\\n```\n```\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\n```\\nCount_79(1)   =   1\\nCount_79(2)   =   2\\nCount_79(3)   =   4\\nCount_79(4)   =   8\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\n```\\nCount_234568(1)   =   1\\nCount_234568(2)   =   2\\nCount_234568(3)   =   4\\nCount_234568(n)   =   Count_234568(n - 1)   +   Count_234568(n - 2)   +   Count_234568(n - 3)\\n```\n```c++\\nint Solution::countSameTexts(char& cc, int& count) {\\n    // Count for 7, 9\\n    if (cc == \\'7\\' || cc == \\'9\\') {\\n        if (count <= 4)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        long d = 1 << 3;\\n        for (int i = 4; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = d;\\n            long new_d = (a + b + c + d) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n            d = new_d;\\n        }\\n        return d;\\n    }\\n    // Count for 2, 3, 4, 5, 6, 8\\n    else {        \\n        if (count <= 3)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        for (int i = 3; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = (a + b + c) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340071,
                "title": "c-dp-memorization-very-simple-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size(),-1);\\n        return fun(dp,pressedKeys,0);\\n    }\\n    long fun(vector<int>& dp,string& s,int i)\\n    {\\n        if(i>=s.length())\\n            return 1;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int n=temp(s[i])-1;\\n        long t=fun(dp,s,i+1)%mod;\\n        for(int j=i+1;j<s.length();j++)\\n        {\\n            if(s[j]==s[i] && n)\\n            {\\n                n--;\\n                t+=fun(dp,s,j+1)%mod;\\n            }\\n            else\\n                break;\\n        }\\n        return dp[i]=t%mod;\\n    }\\n    int temp(char c)\\n    {\\n        if(c==\\'7\\'|| c==\\'9\\')\\n            return 4;\\n        return 3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size(),-1);\\n        return fun(dp,pressedKeys,0);\\n    }\\n    long fun(vector<int>& dp,string& s,int i)\\n    {\\n        if(i>=s.length())\\n            return 1;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int n=temp(s[i])-1;\\n        long t=fun(dp,s,i+1)%mod;\\n        for(int j=i+1;j<s.length();j++)\\n        {\\n            if(s[j]==s[i] && n)\\n            {\\n                n--;\\n                t+=fun(dp,s,j+1)%mod;\\n            }\\n            else\\n                break;\\n        }\\n        return dp[i]=t%mod;\\n    }\\n    int temp(char c)\\n    {\\n        if(c==\\'7\\'|| c==\\'9\\')\\n            return 4;\\n        return 3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166287,
                "title": "java-simple-solution",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    \\n    int mod=(int)Math.pow(10,9)+7;\\n   // String[] keypad={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    int ans=0;\\n    public int countTexts(String pressedKeys) {\\n        \\n        int len=pressedKeys.length();\\n       int[] dp=new int[len+1];\\n        \\n        dp[0]=1;\\n        System.out.print(dp[0]+\" \");\\n        for(int i=1;i<len+1;i++){\\n            \\n            char ch=pressedKeys.charAt(i-1);\\n          \\n         \\n            \\n             dp[i]=(dp[i]%mod+dp[i-1]%mod)%mod;\\n            if(i-2>=0 && pressedKeys.charAt(i-2)==ch ){\\n                \\n                 dp[i]=(dp[i]%mod+dp[i-2]%mod)%mod;\\n                \\n                if(i-3>=0 &&  pressedKeys.charAt(i-3)==ch ){\\n                    \\n                    \\n                        dp[i]=(dp[i]%mod+dp[i-3]%mod)%mod;\\n                    \\n                    if((i-4>=0 && pressedKeys.charAt(i-4)==ch)&& (ch==\\'7\\' || ch==\\'9\\')  ){\\n                        dp[i]=(dp[i]%mod+dp[i-4]%mod)%mod;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n            \\n           // System.out.print(dp[i]+\" \");\\n        }\\n         \\n        return dp[len];\\n    }\\n}\\n             \\n                   \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    \\n    int mod=(int)Math.pow(10,9)+7;\\n   // String[] keypad={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    int ans=0;\\n    public int countTexts(String pressedKeys) {\\n        \\n        int len=pressedKeys.length();\\n       int[] dp=new int[len+1];\\n        \\n        dp[0]=1;\\n        System.out.print(dp[0]+\" \");\\n        for(int i=1;i<len+1;i++){\\n            \\n            char ch=pressedKeys.charAt(i-1);\\n          \\n         \\n            \\n             dp[i]=(dp[i]%mod+dp[i-1]%mod)%mod;\\n            if(i-2>=0 && pressedKeys.charAt(i-2)==ch ){\\n                \\n                 dp[i]=(dp[i]%mod+dp[i-2]%mod)%mod;\\n                \\n                if(i-3>=0 &&  pressedKeys.charAt(i-3)==ch ){\\n                    \\n                    \\n                        dp[i]=(dp[i]%mod+dp[i-3]%mod)%mod;\\n                    \\n                    if((i-4>=0 && pressedKeys.charAt(i-4)==ch)&& (ch==\\'7\\' || ch==\\'9\\')  ){\\n                        dp[i]=(dp[i]%mod+dp[i-4]%mod)%mod;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n            \\n           // System.out.print(dp[i]+\" \");\\n        }\\n         \\n        return dp[len];\\n    }\\n}\\n             \\n                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164807,
                "title": "python-lru-cache",
                "content": "```\\nclass Solution:\\n    def countTexts(self, x: str) -> int:\\n        l=len(x)\\n        @lru_cache(None)\\n        def f(i):\\n            if i==l:return 1\\n            ans=0\\n            for j in range(i,i+(4 if x[i] in \\'97\\' else 3)):\\n                    if j<l and x[j]==x[i]:\\n                        ans+=f(j+1)\\n                    else:\\n                        break\\n            return ans%(10**9+7)\\n        return f(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, x: str) -> int:\\n        l=len(x)\\n        @lru_cache(None)\\n        def f(i):\\n            if i==l:return 1\\n            ans=0\\n            for j in range(i,i+(4 if x[i] in \\'97\\' else 3)):\\n                    if j<l and x[j]==x[i]:\\n                        ans+=f(j+1)\\n                    else:\\n                        break\\n            return ans%(10**9+7)\\n        return f(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033223,
                "title": "python-simple",
                "content": "Should be mostly self explanatory. \\n\\nLoop through the numbers, and when the number is the same as the last number, just keep a running total of one, two, three, and four in a row. (Of course four in a row only exists for 7 or 9). \\n\\nWhen we have a new number, we sum up one, two, three, and four, and multiply that by our answer (ans) to keep a running total in ans. And at this point one = 1, all others are reset to 0.\\n\\nSee the code below:\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        M = 10 ** 9 + 7\\n        ans = one = 1\\n        two = three = four = 0\\n        last = \\'\\'\\n        for x in pressedKeys:\\n            if x == last:\\n                one, two, three, four = one + two + three + four, one, two, three\\n                if x not in \\'79\\':\\n                    four = 0\\n            else:\\n                ans = ans * (one + two + three + four) % M\\n                one = 1\\n                two = three = four = 0\\n            last = x\\n        return ans * (one + two + three + four) % M\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        M = 10 ** 9 + 7\\n        ans = one = 1\\n        two = three = four = 0\\n        last = \\'\\'\\n        for x in pressedKeys:\\n            if x == last:\\n                one, two, three, four = one + two + three + four, one, two, three\\n                if x not in \\'79\\':\\n                    four = 0\\n            else:\\n                ans = ans * (one + two + three + four) % M\\n                one = 1\\n                two = three = four = 0\\n            last = x\\n        return ans * (one + two + three + four) % M\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2029686,
                "title": "c-dynamic-programming-solution",
                "content": "Key idea: total possible number of answer with a digit `d` at the position `i` = \\n(total possible number of answer ends  at the position `i-1` + interpret the last digit as one character if 1 consecutive digits) + \\n(total possible number of answer ends  at the position `i-2` + interpret the last two digits as one character if 2 consecutive digits) + \\n(total possible number of answer ends  at the position `i-3` + interpret the last three digits as one character if 3 consecutive digits) + \\n(total possible number of answer ends  at the position `i-4` + interpret the last four digits as one character if 4 consecutive digits) + \\n\\nOne character is composed of at most 4 digits, so we only have to look up at most 4 entries to fill in each entry of the memorization table.\\n\\n```\\nint keys[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n= pressedKeys.size();\\n        if (n == 0) return 0;\\n        int dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys[i-1];\\n            for (int j = 0; j < keys[c-\\'0\\']; ++j) {\\n                if (i-j <= 0 || pressedKeys[i-j-1] != c) {break;}\\n                dp[i] = (dp[i] + dp[i-j-1]) % mod;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\nSpace complexity: O(n)\\ntime complexity: O(n)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint keys[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n= pressedKeys.size();\\n        if (n == 0) return 0;\\n        int dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys[i-1];\\n            for (int j = 0; j < keys[c-\\'0\\']; ++j) {\\n                if (i-j <= 0 || pressedKeys[i-j-1] != c) {break;}\\n                dp[i] = (dp[i] + dp[i-j-1]) % mod;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019598,
                "title": "memoization-to-tablulation-c",
                "content": "```\\nclass Solution {\\npublic:   \\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int dp[100003];\\n    int solve(string &s,int i){\\n        if(i==s.length()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+solve(s,i+1)%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+solve(s,j+1)%m)%m;\\n        } \\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {  \\n        memset(dp,-1,sizeof dp);\\n      return solve(s,0);\\n    }\\n};\\n``` \\n**CONVERTING IT TO TABULATION (credit-striver)** \\nfollowing steps involve in coverting memoization into tabulation\\n1.Declare same size storage and intialise base case.\\n2.Observe changing paremeter (i)  i->0,1,2,3,4,5 \\n3.write down the loop of changing parameter in reverse order.\\n4.Copy the recusion. \\n\\n```\\nclass Solution {\\npublic:    \\n    //tabulation\\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int countTexts(string s) {  \\n      vector<int> dp(s.length()+1);\\n      dp[s.length()]=1; //step1\\n      for(int i=s.length()-1;i>=0;i--){ //step 2 and 3 \\n\\t  //step 4\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+dp[i+1]%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+dp[j+1]%m)%m;\\n        } \\n        dp[i]=ans;\\n      }\\n      return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int dp[100003];\\n    int solve(string &s,int i){\\n        if(i==s.length()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+solve(s,i+1)%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+solve(s,j+1)%m)%m;\\n        } \\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {  \\n        memset(dp,-1,sizeof dp);\\n      return solve(s,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    //tabulation\\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int countTexts(string s) {  \\n      vector<int> dp(s.length()+1);\\n      dp[s.length()]=1; //step1\\n      for(int i=s.length()-1;i>=0;i--){ //step 2 and 3 \\n\\t  //step 4\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+dp[i+1]%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+dp[j+1]%m)%m;\\n        } \\n        dp[i]=ans;\\n      }\\n      return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018609,
                "title": "python-recursion-memoization",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        keysMap={\"2\":3,\"3\":3,\"4\":3,\"5\":3,\"6\":3,\"7\":4,\"8\":3,\"9\":4}\\n        seen={}\\n        @lru_cache(10)\\n        def find_(ind):\\n            if ind>=len(pressedKeys):\\n                return 1\\n            ans=0\\n            for i in range(keysMap[pressedKeys[ind]]):\\n                if ind+i >= len(pressedKeys) or pressedKeys[ind+i]!=pressedKeys[ind]:\\n                    break\\n                ans+=find_(ind+i+1)\\n            return ans\\n        return find_(0)%1000000007\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        keysMap={\"2\":3,\"3\":3,\"4\":3,\"5\":3,\"6\":3,\"7\":4,\"8\":3,\"9\":4}\\n        seen={}\\n        @lru_cache(10)\\n        def find_(ind):\\n            if ind>=len(pressedKeys):\\n                return 1\\n            ans=0\\n            for i in range(keysMap[pressedKeys[ind]]):\\n                if ind+i >= len(pressedKeys) or pressedKeys[ind+i]!=pressedKeys[ind]:\\n                    break\\n                ans+=find_(ind+i+1)\\n            return ans\\n        return find_(0)%1000000007\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018479,
                "title": "java-memo-explained-o-n",
                "content": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int[] memo=new int[pressedKeys.length()];\\n        \\n        return dfs(pressedKeys,memo,0);\\n    }\\n    \\n    public int dfs(String pk,int[] memo,int index){\\n        if(index==pk.length())  //if end of string is reached that is one permutation\\n            return 1;\\n        \\n        if(memo[index]!=0)      //if countof permutations for that index is already calculated\\n            return memo[index];\\n        \\n        int count=0;\\n        for(int i=0;i<4;i++){   //max we need to go four index forward\\n            //for only button 7 and 9 we have 4 charcters\\n            if(pk.charAt(index)!=\\'7\\' && pk.charAt(index)!=\\'9\\' && i==3)  \\n                break;\\n            \\n            if(index+i>=pk.length())    //if end index goes out of bounds\\n                break;\\n              \\n            if(i!=0){  \\n                //if adjacent characters are not same\\n                if(pk.charAt(index+i)!=pk.charAt(index+i-1))    \\n                    break;\\n            }\\n            \\n            count+=dfs(pk,memo,index+i+1);  //recursive call for remaining string\\n            count%=1000000007;\\n                \\n        }\\n        \\n        memo[index]=count;  //store the calculated value for this index\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int[] memo=new int[pressedKeys.length()];\\n        \\n        return dfs(pressedKeys,memo,0);\\n    }\\n    \\n    public int dfs(String pk,int[] memo,int index){\\n        if(index==pk.length())  //if end of string is reached that is one permutation\\n            return 1;\\n        \\n        if(memo[index]!=0)      //if countof permutations for that index is already calculated\\n            return memo[index];\\n        \\n        int count=0;\\n        for(int i=0;i<4;i++){   //max we need to go four index forward\\n            //for only button 7 and 9 we have 4 charcters\\n            if(pk.charAt(index)!=\\'7\\' && pk.charAt(index)!=\\'9\\' && i==3)  \\n                break;\\n            \\n            if(index+i>=pk.length())    //if end index goes out of bounds\\n                break;\\n              \\n            if(i!=0){  \\n                //if adjacent characters are not same\\n                if(pk.charAt(index+i)!=pk.charAt(index+i-1))    \\n                    break;\\n            }\\n            \\n            count+=dfs(pk,memo,index+i+1);  //recursive call for remaining string\\n            count%=1000000007;\\n                \\n        }\\n        \\n        memo[index]=count;  //store the calculated value for this index\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017949,
                "title": "python-single-pass-dp-o-n-time-o-1-space",
                "content": "**Building our Intuition:**\\nLet us imagine pressedKeys is \"2222\".\\n\\nThe only way to interpret \"2\" is:\\n[\"a\"]\\n\\nThere are two ways we interpret \"22\":\\n[\"aa\", \"b\"]\\n\\nFour ways we interpret \"222\":\\n[\"aaa\", \"ba\", \"ab\", \"c\"]\\n\\n7 ways we interpret \"2222\":\\n[\"aaaa\", \"baa\", \"aba\", \"ca\", \"aab\", \"bb\", \"ac\"]\\n\\nIn each state we can see that to get the ways a digit is interpretting as ending with \"a\", we need to combine all digits that ended previously with \"a\", \"b\", & \"c\". Then to get the ways the str can be interpretted as ending with \"b\", it would be the number of strings that ended with \"b\" in our previous digit. Similarly for \"c\" we need to get the number of ways the previous str ended with \"b\".\\n\\n**So how do we calculate one state from another?**\\nSo for the digit \"2\" in every subsequent digit of \"2\" to get the new combinations we just check how many previous digits ended with \"a\", \"b\", & \"c\". Same idea goes for every other digit except for \"7\" and \"9\" in which case there are 4 transitions, so we need to account and check for one more digit.\\n\\nWhen we see a new digit, i.e. if after seeing \"222\" we then encounter a \"3\", then we reset our states to be all 0, and make our first state to be the combination of all the previous state endings. Meaning if we had \"222\" then the possible combinations we have is [\"aaa\", \"ba\", \"ab\", \"c\"], however whenever we encounter a \"3\", then they all must end with \"d\", and as such we now get [\"aaad\", \"bad\", \"abd\", \"cd\"]. Which then is repersented as [4, 0, 0], meaning we have 4 digits that end with \"d\", and 0 digits that end \"e\" & \"f\".\\n\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        if not pressedKeys:\\n            return 0\\n        \\n        MOD = 10 ** 9 + 7\\n        chars_in_digit = {\\'2\\': 3, \\'3\\': 3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        \\n        prev_states = [1]\\n        prev_digit = None\\n        \\n        for digit in pressedKeys:\\n            total = sum(prev_states) % MOD\\n            \\n            if digit != prev_digit:\\n                prev_states = [total] + [0] * (chars_in_digit[digit] - 1)\\n            else:\\n                prev_states = [total] + prev_states[:chars_in_digit[digit] - 1]\\n                \\n            prev_digit = digit\\n        \\n        return sum(prev_states) % MOD\\n```\\n\\n**TC: O(N)** -> Since all new list creations and tallying of states in each char has an upperbound of 4\\n**SC: O(1)** -> Since prev_states has a max length of 4, and other variables are constant",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        if not pressedKeys:\\n            return 0\\n        \\n        MOD = 10 ** 9 + 7\\n        chars_in_digit = {\\'2\\': 3, \\'3\\': 3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        \\n        prev_states = [1]\\n        prev_digit = None\\n        \\n        for digit in pressedKeys:\\n            total = sum(prev_states) % MOD\\n            \\n            if digit != prev_digit:\\n                prev_states = [total] + [0] * (chars_in_digit[digit] - 1)\\n            else:\\n                prev_states = [total] + prev_states[:chars_in_digit[digit] - 1]\\n                \\n            prev_digit = digit\\n        \\n        return sum(prev_states) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774780,
                "title": "my-dp-memoization-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n    just have special cycles for index+1,index+2 and index+3 elements.\\nIf they are equal like 222 or 7777 then we can take this in cosideration.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int size = 1e5+10;\\n    int dp[100000];\\n    int solve(int ind, string &str, vector<string>& nummap){\\n        \\n        if(str[ind] == \\'0\\' || str[ind]==\\'1\\') return 0;\\n        if(ind == str.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        long long int ans = 0;\\n\\n        if(ind<str.size()-1 && str[ind+1]==str[ind]){\\n            ans += solve(ind+2,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-2 && (str[ind]==str[ind+1] && str[ind+1]==str[ind+2])){\\n            ans += solve(ind+3,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-3 && (str[ind]==\\'7\\' || str[ind]==\\'9\\') &&( str[ind+1]==str[ind] && str[ind+2]==str[ind]  && str[ind+3]==str[ind])){\\n            ans += solve(ind+4,str,nummap)%mod;\\n        }\\n\\n        ans += solve(ind+1,str,nummap)%mod;\\n\\n        return dp[ind] = ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        \\n        vector<string> nummap {\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,pressedKeys,nummap)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int size = 1e5+10;\\n    int dp[100000];\\n    int solve(int ind, string &str, vector<string>& nummap){\\n        \\n        if(str[ind] == \\'0\\' || str[ind]==\\'1\\') return 0;\\n        if(ind == str.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        long long int ans = 0;\\n\\n        if(ind<str.size()-1 && str[ind+1]==str[ind]){\\n            ans += solve(ind+2,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-2 && (str[ind]==str[ind+1] && str[ind+1]==str[ind+2])){\\n            ans += solve(ind+3,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-3 && (str[ind]==\\'7\\' || str[ind]==\\'9\\') &&( str[ind+1]==str[ind] && str[ind+2]==str[ind]  && str[ind+3]==str[ind])){\\n            ans += solve(ind+4,str,nummap)%mod;\\n        }\\n\\n        ans += solve(ind+1,str,nummap)%mod;\\n\\n        return dp[ind] = ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        \\n        vector<string> nummap {\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,pressedKeys,nummap)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677775,
                "title": "dp-based-simple-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int count(string &ss,int s,vector<int>&dp,map<char,int>&m)\\n    {\\n        if(s>=ss.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[s]!=-1)\\n            return dp[s];\\n        int ans=0;\\n        char ch=ss[s];\\n        int k=m[ch];\\n        int j=s;\\n        while(j<ss.length() and j-s<k and ss[j]==ss[s])\\n        {\\n            ans=(ans%mod+count(ss,j+1,dp,m)%mod)%mod;\\n            j++;\\n        }\\n        dp[s]=ans;\\n        return ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,-1);\\n        map<char,int>m;\\n        m[\\'2\\']=3;\\n        m[\\'3\\']=3;\\n        m[\\'4\\']=3;\\n        m[\\'5\\']=3;\\n        m[\\'6\\']=3;\\n        m[\\'7\\']=4;\\n        m[\\'8\\']=3;\\n        m[\\'9\\']=4;\\n        \\n        return count(s,0,dp,m);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int count(string &ss,int s,vector<int>&dp,map<char,int>&m)\\n    {\\n        if(s>=ss.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[s]!=-1)\\n            return dp[s];\\n        int ans=0;\\n        char ch=ss[s];\\n        int k=m[ch];\\n        int j=s;\\n        while(j<ss.length() and j-s<k and ss[j]==ss[s])\\n        {\\n            ans=(ans%mod+count(ss,j+1,dp,m)%mod)%mod;\\n            j++;\\n        }\\n        dp[s]=ans;\\n        return ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,-1);\\n        map<char,int>m;\\n        m[\\'2\\']=3;\\n        m[\\'3\\']=3;\\n        m[\\'4\\']=3;\\n        m[\\'5\\']=3;\\n        m[\\'6\\']=3;\\n        m[\\'7\\']=4;\\n        m[\\'8\\']=3;\\n        m[\\'9\\']=4;\\n        \\n        return count(s,0,dp,m);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557916,
                "title": "c-easy-approach-dp-hahmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    map<pair<int,int>,int>mp;\\n    void create_map(){\\n        mp[{0,1}]=mp[{1,1}]=1;\\n        mp[{0,2}]=mp[{1,2}]=2;\\n        mp[{0,3}]=mp[{1,3}]=4;\\n        mp[{0,4}]=7;\\n        mp[{1,4}]=8;\\n    }    \\n    unsigned int getval(int num,int count){\\n        //base case\\n        if(mp.count({num,count}))\\n            return mp[{num,count}];\\n        \\n        return mp[{num,count}]=(\\n                getval(num,count-1)%mod +\\n                getval(num,count-2)%mod +\\n                getval(num,count-3)%mod +\\n                (num==1 ? getval(num,count-4) : 0)%mod\\n            )%mod;\\n    }\\n    int countTexts(string str) {\\n        create_map();\\n        str.push_back(\\'#\\');\\n        int n= str.size();\\n        long long  ans=1;\\n        int count=1;\\n        for(int i=0;i<n-1;i++){\\n            if(str[i]==str[i+1])\\n                count++;\\n            else{\\n                int num=str[i]-\\'0\\';\\n                long long  curr = getval(num==7 || num==9,count)%mod;\\n                count=1;\\n                ans=(ans *curr)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    map<pair<int,int>,int>mp;\\n    void create_map(){\\n        mp[{0,1}]=mp[{1,1}]=1;\\n        mp[{0,2}]=mp[{1,2}]=2;\\n        mp[{0,3}]=mp[{1,3}]=4;\\n        mp[{0,4}]=7;\\n        mp[{1,4}]=8;\\n    }    \\n    unsigned int getval(int num,int count){\\n        //base case\\n        if(mp.count({num,count}))\\n            return mp[{num,count}];\\n        \\n        return mp[{num,count}]=(\\n                getval(num,count-1)%mod +\\n                getval(num,count-2)%mod +\\n                getval(num,count-3)%mod +\\n                (num==1 ? getval(num,count-4) : 0)%mod\\n            )%mod;\\n    }\\n    int countTexts(string str) {\\n        create_map();\\n        str.push_back(\\'#\\');\\n        int n= str.size();\\n        long long  ans=1;\\n        int count=1;\\n        for(int i=0;i<n-1;i++){\\n            if(str[i]==str[i+1])\\n                count++;\\n            else{\\n                int num=str[i]-\\'0\\';\\n                long long  curr = getval(num==7 || num==9,count)%mod;\\n                count=1;\\n                ans=(ans *curr)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515500,
                "title": "c-intutive",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n   \\n    int countTexts(string pK) \\n    {\\n        int mod = 1e9+7;\\n        \\n        vector<int> dp(pK.length()+1,1);\\n        \\n        \\n        for(int idx=pK.length()-1;idx>=0;idx--){\\n            dp[idx] = dp[idx+1]%mod;\\n        if(idx<pK.length()-1 and pK[idx+1]==pK[idx])\\n        {\\n        dp[idx]=(dp[idx]+dp[idx+2])%mod;\\n        if(idx<pK.length()-2 and pK[idx+1]==pK[idx+2]) dp[idx]=(dp[idx]+dp[idx+3])%mod;\\n        else continue;\\n        if(idx<pK.length()-3 and pK[idx+2]==pK[idx+3] and (pK[idx]==\\'7\\'||pK[idx]==\\'9\\'))                             {dp[idx]=(dp[idx]+dp[idx+4])%mod;}\\n        }\\n        }\\n         \\n        return dp[0]%mod;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    int countTexts(string pK) \\n    {\\n        int mod = 1e9+7;\\n        \\n        vector<int> dp(pK.length()+1,1);\\n        \\n        \\n        for(int idx=pK.length()-1;idx>=0;idx--){\\n            dp[idx] = dp[idx+1]%mod;\\n        if(idx<pK.length()-1 and pK[idx+1]==pK[idx])\\n        {\\n        dp[idx]=(dp[idx]+dp[idx+2])%mod;\\n        if(idx<pK.length()-2 and pK[idx+1]==pK[idx+2]) dp[idx]=(dp[idx]+dp[idx+3])%mod;\\n        else continue;\\n        if(idx<pK.length()-3 and pK[idx+2]==pK[idx+3] and (pK[idx]==\\'7\\'||pK[idx]==\\'9\\'))                             {dp[idx]=(dp[idx]+dp[idx+4])%mod;}",
                "codeTag": "Java"
            },
            {
                "id": 2457241,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        std::vector<long> dp(pressedKeys.size(), 0);\\n        dp[0] = 1;\\n        for (int i = 1; i < pressedKeys.size(); ++i) {\\n            char ch = pressedKeys[i];\\n            int max_num = (ch == \\'7\\' || ch == \\'9\\') ? 4 : 3;\\n\\n            for (int j = 0; j < max_num; ++j) {\\n                if (i - j < 0 || pressedKeys[i - j] != ch) break;\\n                dp[i] += (i - j - 1 < 0) ? 1 : dp[i - j - 1];\\n            }\\n\\n            dp[i] %= modulo_;\\n        }\\n        \\n        return dp.back();\\n    }\\nprivate:\\n    int modulo_ = 1000000007;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        std::vector<long> dp(pressedKeys.size(), 0);\\n        dp[0] = 1;\\n        for (int i = 1; i < pressedKeys.size(); ++i) {\\n            char ch = pressedKeys[i];\\n            int max_num = (ch == \\'7\\' || ch == \\'9\\') ? 4 : 3;\\n\\n            for (int j = 0; j < max_num; ++j) {\\n                if (i - j < 0 || pressedKeys[i - j] != ch) break;\\n                dp[i] += (i - j - 1 < 0) ? 1 : dp[i - j - 1];\\n            }\\n\\n            dp[i] %= modulo_;\\n        }\\n        \\n        return dp.back();\\n    }\\nprivate:\\n    int modulo_ = 1000000007;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260337,
                "title": "c-dp-solution-clean-and-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int mod = 1e9+7;\\n \\n    int countTexts(string s) {\\n\\t\\n        int n = s.length();\\n        vector<int> dp(n+1,0);\\n        \\n        dp[0] = 1;\\n        int ans = 0;\\n        \\n        for(int i = 1; i < n+1; i++){\\n            \\n            dp[i] = (dp[i] + dp[i-1]) % mod;\\n            \\n            \\n            if(i > 1 && s[i-1] == s[i-2])\\n                dp[i] =(dp[i] + dp[i-2]) % mod;\\n            \\n            \\n            if(i > 2 && s[i-1] == s[i-2] && s[i-2] == s[i-3])\\n                dp[i] =(dp[i] + dp[i-3]) % mod;\\n            \\n            \\n            if(s[i-1] == \\'7\\' || s[i-1] == \\'9\\')\\n                if(i > 3 && s[i-1] == s[i-2] && s[i-1] == s[i-3] && s[i-1] == s[i-4])\\n                    dp[i] =(dp[i] + dp[i-4]) % mod;\\n            \\n        }\\n        \\n        return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int mod = 1e9+7;\\n \\n    int countTexts(string s) {\\n\\t\\n        int n = s.length();\\n        vector<int> dp(n+1,0);\\n        \\n        dp[0] = 1;\\n        int ans = 0;\\n        \\n        for(int i = 1; i < n+1; i++){\\n            \\n            dp[i] = (dp[i] + dp[i-1]) % mod;\\n            \\n            \\n            if(i > 1 && s[i-1] == s[i-2])\\n                dp[i] =(dp[i] + dp[i-2]) % mod;\\n            \\n            \\n            if(i > 2 && s[i-1] == s[i-2] && s[i-2] == s[i-3])\\n                dp[i] =(dp[i] + dp[i-3]) % mod;\\n            \\n            \\n            if(s[i-1] == \\'7\\' || s[i-1] == \\'9\\')\\n                if(i > 3 && s[i-1] == s[i-2] && s[i-1] == s[i-3] && s[i-1] == s[i-4])\\n                    dp[i] =(dp[i] + dp[i-4]) % mod;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2136393,
                "title": "c-easy-to-understand-simple-dp-recursion-memoization",
                "content": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int solve(string &s,int i,int n,vector<int> &dp)\\n    {\\n        if(i>=n)\\n        {\\n            return 1;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        ll ans=0;\\n        if(i+1<n&&s[i]==s[i+1])\\n        {\\n            ans+=solve(s,i+2,n,dp)%mod;\\n            if(i+2<n&&s[i]==s[i+2])\\n            {\\n                ans+=solve(s,i+3,n,dp)%mod;\\n                if(i+3<n&&s[i]==s[i+3]&&(s[i]==\\'9\\'||s[i]==\\'7\\'))\\n                {\\n                    ans+=solve(s,i+4,n,dp)%mod;\\n                }\\n            }\\n        }\\n        ans=(ans%mod+solve(s,i+1,n,dp)%mod)%mod;\\n        return dp[i]=ans%mod;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,n,dp);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int solve(string &s,int i,int n,vector<int> &dp)\\n    {\\n        if(i>=n)\\n        {\\n            return 1;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        ll ans=0;\\n        if(i+1<n&&s[i]==s[i+1])\\n        {\\n            ans+=solve(s,i+2,n,dp)%mod;\\n            if(i+2<n&&s[i]==s[i+2])\\n            {\\n                ans+=solve(s,i+3,n,dp)%mod;\\n                if(i+3<n&&s[i]==s[i+3]&&(s[i]==\\'9\\'||s[i]==\\'7\\'))\\n                {\\n                    ans+=solve(s,i+4,n,dp)%mod;\\n                }\\n            }\\n        }\\n        ans=(ans%mod+solve(s,i+1,n,dp)%mod)%mod;\\n        return dp[i]=ans%mod;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135621,
                "title": "c-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countTexts(string &s) \\n    {\\n        int n=s.size();\\n        int dp[n];\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1];\\n            if(s[i]==s[i-1])\\n                dp[i]=i>1?(dp[i]+dp[i-2]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>1 && s[i]==s[i-1] && s[i]==s[i-2])\\n                dp[i]=i>2?(dp[i]+dp[i-3]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>2 && (s[i]==\\'7\\' || s[i]==\\'9\\') && s[i]==s[i-1] && s[i]==s[i-2] && s[i]==s[i-3])\\n                dp[i]=i>3?(dp[i]+dp[i-4]):(dp[i]+1);\\n            dp[i]%=mod;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countTexts(string &s) \\n    {\\n        int n=s.size();\\n        int dp[n];\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1];\\n            if(s[i]==s[i-1])\\n                dp[i]=i>1?(dp[i]+dp[i-2]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>1 && s[i]==s[i-1] && s[i]==s[i-2])\\n                dp[i]=i>2?(dp[i]+dp[i-3]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>2 && (s[i]==\\'7\\' || s[i]==\\'9\\') && s[i]==s[i-1] && s[i]==s[i-2] && s[i]==s[i-3])\\n                dp[i]=i>3?(dp[i]+dp[i-4]):(dp[i]+1);\\n            dp[i]%=mod;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119602,
                "title": "dp-python-3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        mod = 1000000007\\n        def rec2(n):\\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            if n==4:\\n                return 8\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            dp[4] = 8\\n            for i in range(5,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]+dp[i-4]\\n\\n            return dp[-1]\\n            \\n\\n        def rec(n):\\n            \\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            for i in range(4,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]\\n\\n            return dp[-1]\\n        ans = 1\\n        cnt = 1\\n        for i in range(1,len(s)):\\n            if s[i]!=s[i-1]:\\n                if s[i-1] not in[\\'7\\',\\'9\\']:\\n                    ans*=(rec(cnt)%mod)\\n                else:\\n                    ans*=rec2(cnt)%mod\\n                cnt = 1\\n            else:\\n                cnt+=1\\n        ans = ans*rec(cnt) if s[-1] not in[\\'7\\',\\'9\\'] else ans*rec2(cnt)\\n        return ans%mod\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        mod = 1000000007\\n        def rec2(n):\\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            if n==4:\\n                return 8\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            dp[4] = 8\\n            for i in range(5,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]+dp[i-4]\\n\\n            return dp[-1]\\n            \\n\\n        def rec(n):\\n            \\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            for i in range(4,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]\\n\\n            return dp[-1]\\n        ans = 1\\n        cnt = 1\\n        for i in range(1,len(s)):\\n            if s[i]!=s[i-1]:\\n                if s[i-1] not in[\\'7\\',\\'9\\']:\\n                    ans*=(rec(cnt)%mod)\\n                else:\\n                    ans*=rec2(cnt)%mod\\n                cnt = 1\\n            else:\\n                cnt+=1\\n        ans = ans*rec(cnt) if s[-1] not in[\\'7\\',\\'9\\'] else ans*rec2(cnt)\\n        return ans%mod\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2109394,
                "title": "c-top-down-dp-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int helper(string& s,int idx,vector<int>& dp){\\n        if(idx==s.size()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int n=s.size();\\n        int res=0;\\n        res+=helper(s,idx+1,dp);\\n        if(idx+1<n and s[idx+1]==s[idx]){\\n            res+=helper(s,idx+2,dp);\\n            res%=mod;\\n        }\\n        if(idx+2<n and s[idx+1]==s[idx] and s[idx+2]==s[idx]){\\n            res+=helper(s,idx+3,dp);\\n            res%=mod;\\n        }\\n        if((s[idx]==\\'7\\' or s[idx]==\\'9\\') and idx+3<n and s[idx+1]==s[idx] and s[idx+2]==s[idx] and s[idx+3]==s[idx]){\\n            res+=helper(s,idx+4,dp);\\n            res%=mod;\\n        }\\n        return dp[idx]=res;\\n    }\\n    int countTexts(string s) {\\n        vector<int> dp(s.size(),-1);\\n        return helper(s,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int helper(string& s,int idx,vector<int>& dp){\\n        if(idx==s.size()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int n=s.size();\\n        int res=0;\\n        res+=helper(s,idx+1,dp);\\n        if(idx+1<n and s[idx+1]==s[idx]){\\n            res+=helper(s,idx+2,dp);\\n            res%=mod;\\n        }\\n        if(idx+2<n and s[idx+1]==s[idx] and s[idx+2]==s[idx]){\\n            res+=helper(s,idx+3,dp);\\n            res%=mod;\\n        }\\n        if((s[idx]==\\'7\\' or s[idx]==\\'9\\') and idx+3<n and s[idx+1]==s[idx] and s[idx+2]==s[idx] and s[idx+3]==s[idx]){\\n            res+=helper(s,idx+4,dp);\\n            res%=mod;\\n        }\\n        return dp[idx]=res;\\n    }\\n    int countTexts(string s) {\\n        vector<int> dp(s.size(),-1);\\n        return helper(s,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080203,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nPreprocess the input to find the length of each `run` of same consecutive characters, then recursively \"consume\" each `run`.  This recursive \"consuming\" of characters is similar to [91. Decode Ways](https://leetcode.com/problems/decode-ways/discuss/117143/The-ART-of-Dynamic-Programming).\\n\\n---\\n\\n**Note:** if this `run` concept doesn\\'t make sense, look at the supplemental solutions at the very bottom (they are verbosely how I started to solve this problem).\\n\\nWe can recursively consider \"consuming\":\\n\\na. one same consecutive character: `s[i]`\\nb. two same consecutive characters: `s[i], s[i + 1]`\\nc. three same consecutive characters: `s[i], s[i + 1], s[i + 2]`\\nd. four same consecutive characters: `s[i], s[i + 1], s[i + 2], s[i + 3]` \\uD83D\\uDC48 (this use case is only applicable for characters `\\'7\\'` and `\\'9\\'`)\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun countTexts(s: String): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            var cnt = 0\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    cnt += go(i + k)\\n            return cnt\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            if (!m.contains(i)) {\\n                var cnt = 0\\n                for (k in 1..run[i])\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % (1e9 + 7).toInt()\\n                m[i] = cnt\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        var dp = IntArray(N + 1) { 0 }\\n        dp[N] = 1\\n        for (i in N - 1 downTo 0)\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % (1e9 + 7).toInt()\\n        return dp[0]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                cnt += go(i + k);\\n        return cnt;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            for (let k = 1; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % Number(1e9 + 7);\\n            m.set(i, cnt);\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i)\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                dp[i] = (dp[i] + dp[i + k]) % Number(1e9 + 7);\\n    return dp[0];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        @cache\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        dp = [0] * (N + 1)\\n        dp[N] = 1\\n        for i in range(N - 1, -1, -1):\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7)\\n        return dp[0]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int countTexts(string s) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            auto cnt = 0;\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n            return cnt;\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            if (m.find(i) == m.end()) {\\n                auto cnt = 0;\\n                for (auto k{ 1 }; k <= run[i]; ++k)\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n                m[i] = cnt;\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        VI dp(N + 1, 0);\\n        dp[N] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7);\\n        return dp[0];\\n    }\\n};\\n```\\n\\n---\\n\\n**Supplemental Solutions:** the reason for the `run` preprocessing in the solutions above is because it simplifies this redundant and verbose code...\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        let a = go(i + 1),\\n            b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n        return (a + b + c + d) % Number(1e9 + 7);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            let a = go(i + 1),\\n                b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n                c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n                d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n            m.set(i, (a + b + c + d) % Number(1e9 + 7));\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let a = dp[i + 1],\\n            b = i + 1 < N && s[i] == s[i + 1] ? dp[i + 2] : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? dp[i + 3] : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? dp[i + 4] : 0;\\n        dp[i] = (a + b + c + d) % Number(1e9 + 7);\\n    }\\n    return dp[0];\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countTexts(s: String): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            var cnt = 0\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    cnt += go(i + k)\\n            return cnt\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            if (!m.contains(i)) {\\n                var cnt = 0\\n                for (k in 1..run[i])\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % (1e9 + 7).toInt()\\n                m[i] = cnt\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        var dp = IntArray(N + 1) { 0 }\\n        dp[N] = 1\\n        for (i in N - 1 downTo 0)\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % (1e9 + 7).toInt()\\n        return dp[0]\\n    }\\n}\\n```\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                cnt += go(i + k);\\n        return cnt;\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            for (let k = 1; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % Number(1e9 + 7);\\n            m.set(i, cnt);\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i)\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                dp[i] = (dp[i] + dp[i + k]) % Number(1e9 + 7);\\n    return dp[0];\\n};\\n```\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        @cache\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        dp = [0] * (N + 1)\\n        dp[N] = 1\\n        for i in range(N - 1, -1, -1):\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7)\\n        return dp[0]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int countTexts(string s) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            auto cnt = 0;\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n            return cnt;\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            if (m.find(i) == m.end()) {\\n                auto cnt = 0;\\n                for (auto k{ 1 }; k <= run[i]; ++k)\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n                m[i] = cnt;\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        VI dp(N + 1, 0);\\n        dp[N] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7);\\n        return dp[0];\\n    }\\n};\\n```\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        let a = go(i + 1),\\n            b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n        return (a + b + c + d) % Number(1e9 + 7);\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            let a = go(i + 1),\\n                b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n                c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n                d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n            m.set(i, (a + b + c + d) % Number(1e9 + 7));\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let a = dp[i + 1],\\n            b = i + 1 < N && s[i] == s[i + 1] ? dp[i + 2] : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? dp[i + 3] : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? dp[i + 4] : 0;\\n        dp[i] = (a + b + c + d) % Number(1e9 + 7);\\n    }\\n    return dp[0];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037505,
                "title": "c-dp-solution",
                "content": "\\'\\'\\'\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.length();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        int cnt;\\n        for(int i=0;i<pressedKeys.size();i++)\\n        {\\n            int j=i;\\n            if(pressedKeys[i]==\\'7\\' || pressedKeys[i]==\\'9\\')\\n            {\\n                cnt=4;\\n            }\\n            else\\n            {\\n                cnt=3;\\n            }\\n            while(j>=0 && cnt>0 && pressedKeys[j]==pressedKeys[i])\\n            {\\n                dp[i+1] = (dp[i+1] + dp[j])%1000000007;\\n                j--;\\n                cnt--;\\n            }\\n        }\\n        \\n        return dp[n];    \\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "\\'\\'\\'\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.length();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        int cnt;\\n        for(int i=0;i<pressedKeys.size();i++)\\n        {\\n            int j=i;\\n            if(pressedKeys[i]==\\'7\\' || pressedKeys[i]==\\'9\\')\\n            {\\n                cnt=4;\\n            }\\n            else\\n            {\\n                cnt=3;\\n            }\\n            while(j>=0 && cnt>0 && pressedKeys[j]==pressedKeys[i])\\n            {\\n                dp[i+1] = (dp[i+1] + dp[j])%1000000007;\\n                j--;\\n                cnt--;\\n            }\\n        }\\n        \\n        return dp[n];    \\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2037028,
                "title": "go-dp",
                "content": "```\\nfunc countTexts(pressedKeys string) int {\\n    pressedKeysLen := len(pressedKeys)\\n    dp := make([]int, pressedKeysLen + 1)\\n    dp[0] = 1\\n    dp[1] = 1\\n    modulo := int(1e9+7)\\n    for i := 1; i < pressedKeysLen; i++ {\\n        dp[i + 1] = dp[i]\\n        if i >= 1 && pressedKeys[i] == pressedKeys[i - 1] {\\n            dp[i + 1] = dp[i] + dp[i - 1]\\n            if i >= 2 && pressedKeys[i] == pressedKeys[i - 2] {\\n                dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2]\\n                if i >= 3 && (string(pressedKeys[i]) == \"7\" || string(pressedKeys[i]) == \"9\") {\\n                    if pressedKeys[i] == pressedKeys[i - 3] {\\n                        dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2] + dp[i - 3]\\n                    }\\n                }\\n            }\\n        }\\n        dp[i + 1] %= modulo\\n    }\\n    return dp[pressedKeysLen] \\n}",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc countTexts(pressedKeys string) int {\\n    pressedKeysLen := len(pressedKeys)\\n    dp := make([]int, pressedKeysLen + 1)\\n    dp[0] = 1\\n    dp[1] = 1\\n    modulo := int(1e9+7)\\n    for i := 1; i < pressedKeysLen; i++ {\\n        dp[i + 1] = dp[i]\\n        if i >= 1 && pressedKeys[i] == pressedKeys[i - 1] {\\n            dp[i + 1] = dp[i] + dp[i - 1]\\n            if i >= 2 && pressedKeys[i] == pressedKeys[i - 2] {\\n                dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2]\\n                if i >= 3 && (string(pressedKeys[i]) == \"7\" || string(pressedKeys[i]) == \"9\") {\\n                    if pressedKeys[i] == pressedKeys[i - 3] {\\n                        dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2] + dp[i - 3]\\n                    }\\n                }\\n            }\\n        }\\n        dp[i + 1] %= modulo\\n    }\\n    return dp[pressedKeysLen] \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2033632,
                "title": "easy-understanding-code-in-python-with-16-lines",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        dp = [1] + [0] * len(pressedKeys)\\n        prev, c = None, 0\\n        for i, key in enumerate(pressedKeys):\\n            if key == prev:\\n                digits = 4 if prev in \\'79\\' else 3\\n                start = i + 1 - min(digits, c + 1) # c + 1 because in 22233 case, when we look at the last 3, we need to look at the combinations at last \\'2\\' and first \\'3\\' so look back c + 1\\n                dp[i+1] = sum(dp[start : i + 1]) % MOD  # i + 1 because we have a table of len + 1. and we are filling at i + 1 index.\\n                c += 1\\n            else:\\n                dp[i+1] = dp[i] % MOD\\n                c = 1\\n            prev = key\\n        return dp[-1] % MOD\\n```\\nFirst post, hope you enjoy it.\\n\\n\\n\\n\\nI would also like to share a ugly but efficient code with a very simple idea(beats 97.71%):\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        chr3 = []\\n        chr4 = []\\n        prev = pressedKeys[0]\\n        c = 1\\n        \\n        for key in pressedKeys[1:]:\\n            if key == prev:\\n                c += 1\\n            else:\\n                if prev in {\\'7\\', \\'9\\'}:\\n                    chr4.append(c)\\n                else:\\n                    chr3.append(c)\\n                c = 1\\n            prev = key\\n        if prev in {\\'7\\', \\'9\\'}:\\n            chr4.append(c)\\n        else:\\n            chr3.append(c)\\n        \\n        def getCounts(num, digits):\\n            dp = [1] + [0] * num\\n            for i in range(1, num + 1):\\n                start = i - digits\\n                dp[i] = sum(dp[start if start >=0 else 0 : i])%MOD\\n            return dp\\n        \\n        res = 1\\n        if chr3:\\n            max_counts3 = max(chr3)\\n            dp_3digs = getCounts(max_counts3, 3)\\n            for count in chr3:\\n                res *= dp_3digs[count]%MOD\\n        if chr4:\\n            max_counts4 = max(chr4)\\n            dp_4digs = getCounts(max_counts4, 4)\\n            for count in chr4:\\n                res *= dp_4digs[count]%MOD\\n        MOD = 10**9+7\\n        return res%MOD\\n```\\nThe code looks long, but the main idea is simple.\\nIf we have 22222223333444, we find it\\'s seven \\'2\\', four \\'3\\', three \\'4\\'.\\nWe simply return the combinations with 7 repeating numbers x 4 repeating numbers x 3 repeating numbers, without considering what\\'s the number.\\nThen construct a dp table with the longest repeating int size, which is 7 here.\\nwe return dp[7] * dp[3] * dp[4] and only generate a dp table of size 7!\\n\\nIf we have 7 or 9, simply construct another dp table and others remains the same.\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        dp = [1] + [0] * len(pressedKeys)\\n        prev, c = None, 0\\n        for i, key in enumerate(pressedKeys):\\n            if key == prev:\\n                digits = 4 if prev in \\'79\\' else 3\\n                start = i + 1 - min(digits, c + 1) # c + 1 because in 22233 case, when we look at the last 3, we need to look at the combinations at last \\'2\\' and first \\'3\\' so look back c + 1\\n                dp[i+1] = sum(dp[start : i + 1]) % MOD  # i + 1 because we have a table of len + 1. and we are filling at i + 1 index.\\n                c += 1\\n            else:\\n                dp[i+1] = dp[i] % MOD\\n                c = 1\\n            prev = key\\n        return dp[-1] % MOD\\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        chr3 = []\\n        chr4 = []\\n        prev = pressedKeys[0]\\n        c = 1\\n        \\n        for key in pressedKeys[1:]:\\n            if key == prev:\\n                c += 1\\n            else:\\n                if prev in {\\'7\\', \\'9\\'}:\\n                    chr4.append(c)\\n                else:\\n                    chr3.append(c)\\n                c = 1\\n            prev = key\\n        if prev in {\\'7\\', \\'9\\'}:\\n            chr4.append(c)\\n        else:\\n            chr3.append(c)\\n        \\n        def getCounts(num, digits):\\n            dp = [1] + [0] * num\\n            for i in range(1, num + 1):\\n                start = i - digits\\n                dp[i] = sum(dp[start if start >=0 else 0 : i])%MOD\\n            return dp\\n        \\n        res = 1\\n        if chr3:\\n            max_counts3 = max(chr3)\\n            dp_3digs = getCounts(max_counts3, 3)\\n            for count in chr3:\\n                res *= dp_3digs[count]%MOD\\n        if chr4:\\n            max_counts4 = max(chr4)\\n            dp_4digs = getCounts(max_counts4, 4)\\n            for count in chr4:\\n                res *= dp_4digs[count]%MOD\\n        MOD = 10**9+7\\n        return res%MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031394,
                "title": "java-dp-simple",
                "content": "```\\n\\tpublic int countTexts(String pk) {\\n        long[] _3digits = new long[]{1, 2, 4, 7};\\n        long[] _4digits = new long[]{1, 2, 4, 8};\\n        int n = pk.length();\\n        char ch = pk.charAt(0);\\n        int count = 1;\\n        long res = 1;\\n        long[] toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n        List<Long> freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n        int modulo = 1000000007;\\n        \\n        for(int i=1; i<n; i++) {\\n            if (pk.charAt(i) == ch) {\\n                count++;\\n                if (count > 4) {\\n                    long newCount = (freq.get(count - 2) + freq.get(count - 3) + freq.get(count - 4)) % modulo;\\n                    newCount = (ch == \\'7\\' || ch == \\'9\\')? (newCount + freq.get(count - 5))%modulo : newCount;\\n                    freq.add(newCount);\\n                }\\n            }else{\\n                res = (res * freq.get(count - 1)) % modulo;\\n                \\n                ch = pk.charAt(i);\\n                toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n                freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n                count = 1;\\n            }\\n        }\\n        \\n        res = (res * freq.get(count - 1)) % modulo;\\n        return (int) res;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tpublic int countTexts(String pk) {\\n        long[] _3digits = new long[]{1, 2, 4, 7};\\n        long[] _4digits = new long[]{1, 2, 4, 8};\\n        int n = pk.length();\\n        char ch = pk.charAt(0);\\n        int count = 1;\\n        long res = 1;\\n        long[] toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n        List<Long> freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n        int modulo = 1000000007;\\n        \\n        for(int i=1; i<n; i++) {\\n            if (pk.charAt(i) == ch) {\\n                count++;\\n                if (count > 4) {\\n                    long newCount = (freq.get(count - 2) + freq.get(count - 3) + freq.get(count - 4)) % modulo;\\n                    newCount = (ch == \\'7\\' || ch == \\'9\\')? (newCount + freq.get(count - 5))%modulo : newCount;\\n                    freq.add(newCount);\\n                }\\n            }else{\\n                res = (res * freq.get(count - 1)) % modulo;\\n                \\n                ch = pk.charAt(i);\\n                toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n                freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n                count = 1;\\n            }\\n        }\\n        \\n        res = (res * freq.get(count - 1)) % modulo;\\n        return (int) res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2026751,
                "title": "java-tabulation",
                "content": "```\\nclass Solution {\\n    public static int[] press = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n    int mod = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        int[] dp = new int[pressedKeys.length()];\\n        dp[0] = 1;\\n        int freq = 1;\\n        \\n        for(int i=1;i<pressedKeys.length();i++){\\n            char ch = pressedKeys.charAt(i);\\n            if(i==0 || ch!=pressedKeys.charAt(i-1)){\\n                freq = 1;\\n            } else {\\n                freq++;\\n            }\\n            \\n            for(int j=1;j<=Math.min(freq, press[ch-\\'0\\']);j++){\\n                dp[i] += ( (i - j == -1) ? 1 : dp[i - j] );\\n                dp[i] %= mod;\\n            }\\n        }\\n        \\n        return dp[dp.length-1];\\n    }\\n}\\n```\\n\\n# Notes :- \\n\\n1. freq denotes the possible amount of times a key can be pressed. For instance, in the message \"222\", the third \\'2\\' can either be pressed once to type \\'a\\', or twice to type \\'b\\' or thrice simultaneously to type \\'c\\'. \\n2. Math.min(freq, press[ch-\\'0\\']) is necessary. For instance, in the message \"2222\", there is no mapping for all 2\\'s being pressed simultaneously. The 4rth 2 was either pressed once to type \\'a\\', or twice alongwith 3rd \\'2\\' to type \\'b\\' or thrice alongwith 2nd and 3rd \\'2\\' to type \\'c\\'. The \\'min\\' part will ensure that the simultaneous presses of a digit doesn\\'t exceed the allowed maximum simultaneous press for that digit.\\n3. The ( i - j == -1) part only makes sense if first 2 digits are the same, just to escape from \"Array Out Of Bounds Exception\".\\n\\n* Time Complexity :- O(4*N) => O(N)\\n* Space Complexity :- O(N)\\n\\nHope you found the solution and the notes insightful !",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] press = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n    int mod = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        int[] dp = new int[pressedKeys.length()];\\n        dp[0] = 1;\\n        int freq = 1;\\n        \\n        for(int i=1;i<pressedKeys.length();i++){\\n            char ch = pressedKeys.charAt(i);\\n            if(i==0 || ch!=pressedKeys.charAt(i-1)){\\n                freq = 1;\\n            } else {\\n                freq++;\\n            }\\n            \\n            for(int j=1;j<=Math.min(freq, press[ch-\\'0\\']);j++){\\n                dp[i] += ( (i - j == -1) ? 1 : dp[i - j] );\\n                dp[i] %= mod;\\n            }\\n        }\\n        \\n        return dp[dp.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022776,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    Long[][] mem = null;\\n    public int countTexts(String p) {\\n        mem = new Long[p.length()+1][10];\\n        Stack<int[]> arr = new Stack();\\n        for(int i=0; i<p.length(); i++) {\\n            if (arr.size() == 0 || arr.peek()[0] != (p.charAt(i)-\\'0\\')) {\\n                arr.push(new int[]{p.charAt(i)-\\'0\\', 1});\\n            } else {\\n                arr.peek()[1]++;\\n            }\\n        }\\n        \\n        ArrayList<int[]> list = new ArrayList(arr);\\n        long prod = 1;\\n        for(int[] x: list) {\\n            prod *= dp(x[1], x[0])%1000000007;\\n            prod = prod % 1000000007;\\n        }\\n        return (int)(prod%1000000007);\\n    }\\n    \\n    long dp(int c, int l) {\\n        int[] let = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        if (c <= 0) return 1;\\n        if (mem[c][l] != null) return mem[c][l];\\n        long ans = 0;\\n        for(int i=1; i<=let[l]; i++) {\\n            if (c >=i) ans += dp(c-i, l)%1000000007;\\n            ans = ans%1000000007;\\n        }\\n        mem[c][l] = ans;\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Long[][] mem = null;\\n    public int countTexts(String p) {\\n        mem = new Long[p.length()+1][10];\\n        Stack<int[]> arr = new Stack();\\n        for(int i=0; i<p.length(); i++) {\\n            if (arr.size() == 0 || arr.peek()[0] != (p.charAt(i)-\\'0\\')) {\\n                arr.push(new int[]{p.charAt(i)-\\'0\\', 1});\\n            } else {\\n                arr.peek()[1]++;\\n            }\\n        }\\n        \\n        ArrayList<int[]> list = new ArrayList(arr);\\n        long prod = 1;\\n        for(int[] x: list) {\\n            prod *= dp(x[1], x[0])%1000000007;\\n            prod = prod % 1000000007;\\n        }\\n        return (int)(prod%1000000007);\\n    }\\n    \\n    long dp(int c, int l) {\\n        int[] let = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        if (c <= 0) return 1;\\n        if (mem[c][l] != null) return mem[c][l];\\n        long ans = 0;\\n        for(int i=1; i<=let[l]; i++) {\\n            if (c >=i) ans += dp(c-i, l)%1000000007;\\n            ans = ans%1000000007;\\n        }\\n        mem[c][l] = ans;\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021727,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    \\n    public int countTexts(String passedKeys) {\\n        int[] dp = new int[passedKeys.length()+1];\\n        dp[0] = 1;\\n        \\n        for(int i=1; i<=passedKeys.length(); i++){\\n            char c = passedKeys.charAt(i-1);\\n            \\n            dp[i] += dp[i-1];\\n            if(i >= 2 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2)){\\n                dp[i] = (dp[i] + dp[i-2])%MOD;\\n            }\\n            \\n            if(i >= 3 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)){\\n                dp[i] = (dp[i] + dp[i-3])%MOD;\\n            }\\n            \\n            if(c == \\'7\\' || c == \\'9\\'){\\n                if(i >= 4 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)\\n                         && passedKeys.charAt(i-3) == passedKeys.charAt(i-4)\\n                  ){\\n                    dp[i] = (dp[i] + dp[i-4])%MOD;\\n                }   \\n            }\\n        }\\n        \\n        return (int)(dp[passedKeys.length()]%MOD);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    \\n    public int countTexts(String passedKeys) {\\n        int[] dp = new int[passedKeys.length()+1];\\n        dp[0] = 1;\\n        \\n        for(int i=1; i<=passedKeys.length(); i++){\\n            char c = passedKeys.charAt(i-1);\\n            \\n            dp[i] += dp[i-1];\\n            if(i >= 2 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2)){\\n                dp[i] = (dp[i] + dp[i-2])%MOD;\\n            }\\n            \\n            if(i >= 3 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)){\\n                dp[i] = (dp[i] + dp[i-3])%MOD;\\n            }\\n            \\n            if(c == \\'7\\' || c == \\'9\\'){\\n                if(i >= 4 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)\\n                         && passedKeys.charAt(i-3) == passedKeys.charAt(i-4)\\n                  ){\\n                    dp[i] = (dp[i] + dp[i-4])%MOD;\\n                }   \\n            }\\n        }\\n        \\n        return (int)(dp[passedKeys.length()]%MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019838,
                "title": "python-dfs-with-memoization-groupby-o-n-easy-to-read",
                "content": "```\\nfrom functools import lru_cache\\nfrom itertools import groupby\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4]\\n        M = 10**9+7\\n        @lru_cache(None)\\n        def dfs(i, k):\\n            if i == 0: return 1\\n            if i < 0: return 0\\n            res = 0\\n            for j in range(1,k+1):\\n                res = (res + dfs(i-j, k))%M\\n            return res\\n        groups = [(int(k),len(list(v))) for k, v in groupby(pressedKeys)]\\n        res = 1\\n        for k, l in groups:\\n            res = (res*dfs(l, d[k]))%M\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom functools import lru_cache\\nfrom itertools import groupby\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4]\\n        M = 10**9+7\\n        @lru_cache(None)\\n        def dfs(i, k):\\n            if i == 0: return 1\\n            if i < 0: return 0\\n            res = 0\\n            for j in range(1,k+1):\\n                res = (res + dfs(i-j, k))%M\\n            return res\\n        groups = [(int(k),len(list(v))) for k, v in groupby(pressedKeys)]\\n        res = 1\\n        for k, l in groups:\\n            res = (res*dfs(l, d[k]))%M\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2019618,
                "title": "python-3-dp-bottom-up",
                "content": "Take 22223 for an example. \\n\\n2: `a`\\n2+2: 1st `a` plus another `a` gives `aa`, and connecting two 2s gives `b`. Total number of interpretations doubled.\\n22+2: `aa` and `b` from previous index appending another `a` gives `aaa` and `ba`; connecting the last 2 with the 2nd gives `ab`; and connecting all 3 2s gives `c`. Total number of interpretations doubled.\\n222+2: since `maximum connectable` 2s == 3, the additional interpretations it brings are:\\n\\t\\tinterpreations for 2 + 222 (`c`)\\n\\t\\tinterpretations for 22 + 22 (`b`)\\n\\t\\tinterpretations for 222 + 2 (`a`)\\n2222+3: 3 is a different digit to 2, it does not change the number of interpretations.\\n\\nFor digits 7 and 9, `maximum connectable` == 4.\\n\\nState transition:\\n```\\nif digit[i] != digit[i-1]:\\n\\tdp[i] = dp[i - 1]\\nelse:\\n\\tif connected <= max_connectable:\\n\\t\\tdp[i] = dp[i - 1] * 2\\n\\telse:\\n\\t\\tdp[i] += dp[i - j] for j in range(1 to max_connectable inclusively)\\n```\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]) % mod\\n        return dp[-1]\\n```\\n\\nA prefix sum can provide minor acceleration.\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        _sum = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n                _sum = dp[i]\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        _sum += dp[i]\\n                    else:\\n                        dp[i] = _sum % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        if cnt < 4:\\n                            _sum += dp[i]\\n                        else:\\n                            _sum = _sum + dp[i] - dp[i - 3]\\n                    else:\\n                        dp[i] = (_sum + dp[i - 4]) % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nif digit[i] != digit[i-1]:\\n\\tdp[i] = dp[i - 1]\\nelse:\\n\\tif connected <= max_connectable:\\n\\t\\tdp[i] = dp[i - 1] * 2\\n\\telse:\\n\\t\\tdp[i] += dp[i - j] for j in range(1 to max_connectable inclusively)\\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]) % mod\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        _sum = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n                _sum = dp[i]\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        _sum += dp[i]\\n                    else:\\n                        dp[i] = _sum % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        if cnt < 4:\\n                            _sum += dp[i]\\n                        else:\\n                            _sum = _sum + dp[i] - dp[i - 3]\\n                    else:\\n                        dp[i] = (_sum + dp[i - 4]) % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019523,
                "title": "dynamic-programming-memoization-java",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    HashMap<Integer,Integer>map;\\n    public int countTexts(String pressedKeys) {\\n        HashSet<String>set=new HashSet<>();\\n        set.add(\"2\");\\n        set.add(\"22\");\\n        set.add(\"222\");\\n        set.add(\"3\");\\n        set.add(\"33\");\\n        set.add(\"333\");\\n        set.add(\"4\");\\n        set.add(\"44\");\\n        set.add(\"444\");\\n        \\n        set.add(\"5\");\\n        set.add(\"55\");\\n        set.add(\"555\");\\n        set.add(\"6\");\\n        set.add(\"66\");\\n        set.add(\"666\");\\n        set.add(\"7\");\\n        set.add(\"77\");\\n        set.add(\"7777\");\\n        set.add(\"777\");\\n        set.add(\"8\");\\n        set.add(\"88\");\\n        set.add(\"888\");\\n        set.add(\"9\");\\n        set.add(\"99\");\\n        set.add(\"9999\");\\n        set.add(\"999\");\\n        \\n        map=new HashMap<>();\\n        return solver(pressedKeys,set,pressedKeys.length(),0);\\n        \\n    }\\n    \\n    public int solver(String str, HashSet<String>set, int n,int i){\\n        \\n        \\n        if(i==n){\\n            map.put(n,1);\\n            return 1;\\n        }\\n        if(map.containsKey(i)){\\n            return map.get(i);\\n        }\\n        int ans=0;\\n        \\n        for(int j=i+1;j<=n;j++){\\n            String pre=str.substring(i,j);\\n         //   String ros=j==n?\"\":str.substring(j);\\n            if(set.contains(pre)){\\n                if(map.containsKey(j)){\\n                    ans+=map.get(j);\\n                }else{\\n                    ans+=solver(str,set,n,j);\\n                }\\n                \\n                ans%=mod;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        map.put(i,ans);\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    HashMap<Integer,Integer>map;\\n    public int countTexts(String pressedKeys) {\\n        HashSet<String>set=new HashSet<>();\\n        set.add(\"2\");\\n        set.add(\"22\");\\n        set.add(\"222\");\\n        set.add(\"3\");\\n        set.add(\"33\");\\n        set.add(\"333\");\\n        set.add(\"4\");\\n        set.add(\"44\");\\n        set.add(\"444\");\\n        \\n        set.add(\"5\");\\n        set.add(\"55\");\\n        set.add(\"555\");\\n        set.add(\"6\");\\n        set.add(\"66\");\\n        set.add(\"666\");\\n        set.add(\"7\");\\n        set.add(\"77\");\\n        set.add(\"7777\");\\n        set.add(\"777\");\\n        set.add(\"8\");\\n        set.add(\"88\");\\n        set.add(\"888\");\\n        set.add(\"9\");\\n        set.add(\"99\");\\n        set.add(\"9999\");\\n        set.add(\"999\");\\n        \\n        map=new HashMap<>();\\n        return solver(pressedKeys,set,pressedKeys.length(),0);\\n        \\n    }\\n    \\n    public int solver(String str, HashSet<String>set, int n,int i){\\n        \\n        \\n        if(i==n){\\n            map.put(n,1);\\n            return 1;\\n        }\\n        if(map.containsKey(i)){\\n            return map.get(i);\\n        }\\n        int ans=0;\\n        \\n        for(int j=i+1;j<=n;j++){\\n            String pre=str.substring(i,j);\\n         //   String ros=j==n?\"\":str.substring(j);\\n            if(set.contains(pre)){\\n                if(map.containsKey(j)){\\n                    ans+=map.get(j);\\n                }else{\\n                    ans+=solver(str,set,n,j);\\n                }\\n                \\n                ans%=mod;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        map.put(i,ans);\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2019257,
                "title": "easy-solution-dp-dynamic-prorgramming-c-explanation-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n=s.length();\\n        int mod=int(1e9)+7;\\n        vector<int>dp(n,0);\\n        unordered_set<string>um;\\n        for(int i=2;i<=9;i++){\\n            string temp=to_string(i);\\n            string cur=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n        }\\n        um.insert(\"7777\");\\n        um.insert(\"9999\");\\n        \\n        dp[0]=1;\\n        if(n==1) return dp[0];\\n        string cur=s.substr(0,2);\\n        dp[1]=1;\\n        if(um.find(cur)!=um.end()) dp[1]++;\\n        if(n==2) return dp[1];\\n        cur=s.substr(0,3);            \\n        if(um.find(cur)!=um.end()) dp[2]++;\\n        cur=s.substr(1,2);\\n        if(um.find(cur)!=um.end()) dp[2]+=dp[0];\\n        dp[2]+=dp[1];\\n\\n        for(int i=3;i<n;i++){\\n            dp[i]=dp[i-1]%mod;\\n            string cur1=s.substr(i-2,3);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-3]%mod+dp[i]%mod)%mod;\\n            cur1=s.substr(i-1,2);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-2]%mod+dp[i]%mod)%mod;\\n            if(s[i]==\\'7\\' || s[i]==\\'9\\'){\\n                cur1=s.substr(i-3,4);\\n                if(um.find(cur1)!=um.end()){\\n                    if(i==3) dp[i]++;\\n                    else dp[i]=(dp[i-4]%mod+dp[i]%mod)%mod;\\n                } \\n            }\\n        }\\n        \\n        return dp[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n=s.length();\\n        int mod=int(1e9)+7;\\n        vector<int>dp(n,0);\\n        unordered_set<string>um;\\n        for(int i=2;i<=9;i++){\\n            string temp=to_string(i);\\n            string cur=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n        }\\n        um.insert(\"7777\");\\n        um.insert(\"9999\");\\n        \\n        dp[0]=1;\\n        if(n==1) return dp[0];\\n        string cur=s.substr(0,2);\\n        dp[1]=1;\\n        if(um.find(cur)!=um.end()) dp[1]++;\\n        if(n==2) return dp[1];\\n        cur=s.substr(0,3);            \\n        if(um.find(cur)!=um.end()) dp[2]++;\\n        cur=s.substr(1,2);\\n        if(um.find(cur)!=um.end()) dp[2]+=dp[0];\\n        dp[2]+=dp[1];\\n\\n        for(int i=3;i<n;i++){\\n            dp[i]=dp[i-1]%mod;\\n            string cur1=s.substr(i-2,3);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-3]%mod+dp[i]%mod)%mod;\\n            cur1=s.substr(i-1,2);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-2]%mod+dp[i]%mod)%mod;\\n            if(s[i]==\\'7\\' || s[i]==\\'9\\'){\\n                cur1=s.substr(i-3,4);\\n                if(um.find(cur1)!=um.end()){\\n                    if(i==3) dp[i]++;\\n                    else dp[i]=(dp[i-4]%mod+dp[i]%mod)%mod;\\n                } \\n            }\\n        }\\n        \\n        return dp[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019221,
                "title": "easy-to-understand-important-concept-involved",
                "content": "Take a test case like [1,1,1,1,1,1], here we have 6 (1) . Now think properly of what we have to do :\\n\\n[1,1,1,1,1,1]-->[a,a,a,a,a] , [a,b,a,a], [a,b,b] etc;\\n\\nIf we closely look its just like :\\n\\n6=1+1+1+1+1+1  => a+a+a+a+a+a\\n6=1+2+1+1 =>a+b+a+a\\n6=1+3+1=>a+c+a\\n\\n6=1+4 NOT VALID || We can only go upto 3 as given in ques (3presses);\\n\\nDoesn\\'t this look similar to COIN-CHANGE Problem , But HERE IS A CATCH , here we have to compute all the PERMUTATIONS unlike COIN CHANGE where we calculated unique PERMUTATION.\\n\\nYou can take help from here regarding Permutation Thing : https://leetcode.com/problems/combination-sum-iv/discuss/1986766/did-u-missed-this-concept-permutations-vs-unique-permutations\\n\\nSolution is as Follows:\\n\\nclass Solution { \\npublic:\\n    \\n    int COINCHANGE(int sum,int k){\\n        int mod=1e9+7;\\n        vector<int>coin={1,2,3};\\n        if(k==7 || k==9){   //since we can press 4 times there\\n            coin.push_back(4);\\n        }\\n        int n=coin.size();\\n        vector<vector<int>>dp(n+1,vector<int>(sum+1,0));\\n        \\n        for(int i=0;i<=sum;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=1;\\n        }\\n        \\n        for(int k=1;k<=sum;k++){\\n            for(int i=1;i<=n;i++){\\n                if(k-coin[i-1]>=0){\\n                    dp[i][k]=(dp[i-1][k]%mod+dp[n][k-coin[i-1]]%mod)%mod;\\n                }\\n                else{\\n                    dp[i][k]=dp[i-1][k]%mod;\\n                }\\n            }\\n        }\\n        return dp[n][sum];\\n    }\\n    int countTexts(string s) {\\n        \\n        int cnt=0;\\n        long long ans=1;\\n        int mod=1e9+7;\\n        s+=\\'$\\';\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==s[i-1]){\\n                cnt++;\\n            }\\n            else{\\n                int k=s[i-1]-\\'0\\';\\n                ans=((ans%mod)*1LL*(COINCHANGE(cnt+1,k))%mod)%mod;  //Multiplication is done to have all the combinations\\n                ans=ans%mod;\\n                cnt=0;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n };\\n \\n If it is still unclear, please let me know how can I help.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution { \\npublic:\\n    \\n    int COINCHANGE(int sum,int k){\\n        int mod=1e9+7;\\n        vector<int>coin={1,2,3}",
                "codeTag": "Java"
            },
            {
                "id": 2019187,
                "title": "solution-t-o-n-s-o-1-explain-with-schematic",
                "content": "![image](https://assets.leetcode.com/users/images/f6c8d425-39ab-404f-8de8-3090d74572ea_1652003566.5879638.png)\\ndp[] is the possibilities of text combination.\\nfrom the example, you can understand that \\ndp[i+1]+=dp[i]; // it always can be a letter alone and do not forget the dp[-1] should set to 1\\n- dp[i-1],dp[i-2] //if it can combine with the former pressed\\n- dp[i-3] //if this number is 7 or 9 \\n\\nthe Mod operation should be executed whenever it is added, cause the number will be very large at late stage. \\nP.S\\uFF1AIf the number is less than MOD, it will not be affected.\\n\\n```\\n\\tprivate static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        //the last we need is i-4, so 5 is enough.\\n        int[] textPossibility = new int[5]; \\n        char[] chars = pressedKeys.toCharArray();\\n        int n = pressedKeys.length();\\n        textPossibility[0]=1;\\n        for(int i=0;i<n;i++){\\n            char c = pressedKeys.charAt(i);\\n            int index = (i+1)%5;\\n            //suppose the letter is the 1 time pressed\\n            textPossibility[index] = textPossibility[i%5]; \\n            if(i>0 && c==pressedKeys.charAt(i-1)){\\n                textPossibility[index]+= textPossibility[(i-1)%5];\\n                textPossibility[index] %= MOD;\\n                if(i>1 && c==pressedKeys.charAt(i-2)){\\n                    textPossibility[index]+= textPossibility[(i-2)%5];\\n                    textPossibility[index] %= MOD;\\n                    if((c==\\'7\\'||c==\\'9\\') && i>2 && c==pressedKeys.charAt(i-3)){\\n                        textPossibility[index]+= textPossibility[(i-3)%5];\\n                        textPossibility[index] %= MOD;\\n                    }\\n                }\\n            }\\n        }\\n        return textPossibility[n%5];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tprivate static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        //the last we need is i-4, so 5 is enough.\\n        int[] textPossibility = new int[5]; \\n        char[] chars = pressedKeys.toCharArray();\\n        int n = pressedKeys.length();\\n        textPossibility[0]=1;\\n        for(int i=0;i<n;i++){\\n            char c = pressedKeys.charAt(i);\\n            int index = (i+1)%5;\\n            //suppose the letter is the 1 time pressed\\n            textPossibility[index] = textPossibility[i%5]; \\n            if(i>0 && c==pressedKeys.charAt(i-1)){\\n                textPossibility[index]+= textPossibility[(i-1)%5];\\n                textPossibility[index] %= MOD;\\n                if(i>1 && c==pressedKeys.charAt(i-2)){\\n                    textPossibility[index]+= textPossibility[(i-2)%5];\\n                    textPossibility[index] %= MOD;\\n                    if((c==\\'7\\'||c==\\'9\\') && i>2 && c==pressedKeys.charAt(i-3)){\\n                        textPossibility[index]+= textPossibility[(i-3)%5];\\n                        textPossibility[index] %= MOD;\\n                    }\\n                }\\n            }\\n        }\\n        return textPossibility[n%5];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018770,
                "title": "easy-dp-solution-java",
                "content": "```\\n    public int countTexts(String s) {\\n        int n =s.length();\\n        long dp [] =new long[n+1];\\n        dp[0]=1;\\n        int mod = 1000000007;\\n        for(int i=1;i<=n;i++)\\n        {\\n            char ch = s.charAt(i-1);\\n        \\n               dp[i]= (dp[i] + dp[i-1]) % mod;     \\n                   \\n                if((i-2)>=0 && s.charAt(i-2)==ch) dp[i] = (dp[i] + dp[i-2]) % mod;\\n                else continue;\\n                \\n                if((i-3)>=0 && s.charAt(i-3)==ch) dp[i]= ( dp[i]+dp[i-3] )  % mod;\\n                else continue; \\n                \\n                if( (ch==\\'7\\' || ch==\\'9\\') && (i-4)>=0 && s.charAt(i-4)==ch) dp[i] = (dp[i]+dp[i-4] )  % mod;     \\n            \\n        }\\n        \\n        return (int)(dp[n] % mod);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countTexts(String s) {\\n        int n =s.length();\\n        long dp [] =new long[n+1];\\n        dp[0]=1;\\n        int mod = 1000000007;\\n        for(int i=1;i<=n;i++)\\n        {\\n            char ch = s.charAt(i-1);\\n        \\n               dp[i]= (dp[i] + dp[i-1]) % mod;     \\n                   \\n                if((i-2)>=0 && s.charAt(i-2)==ch) dp[i] = (dp[i] + dp[i-2]) % mod;\\n                else continue;\\n                \\n                if((i-3)>=0 && s.charAt(i-3)==ch) dp[i]= ( dp[i]+dp[i-3] )  % mod;\\n                else continue; \\n                \\n                if( (ch==\\'7\\' || ch==\\'9\\') && (i-4)>=0 && s.charAt(i-4)==ch) dp[i] = (dp[i]+dp[i-4] )  % mod;     \\n            \\n        }\\n        \\n        return (int)(dp[n] % mod);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018522,
                "title": "java-memoziation-based-solution",
                "content": "```\\nclass Solution {\\n    Integer[] cache;\\n    int mod = (int)Math.pow(10,9) + 7;\\n    public int countTexts(String pressedKeys) {\\n        cache = new Integer[pressedKeys.length()];\\n        return helper(pressedKeys, 0);\\n    }\\n    \\n    int helper(String cur, int pos) {\\n        if (pos >= cur.length()) {\\n            return 1;\\n        }\\n        \\n        if (cache[pos] != null) {\\n            return cache[pos];\\n        }\\n        int count = 0;\\n        for (int i = pos; i < cur.length() && i < pos + 4; i++) {\\n            if (cur.charAt(i) == cur.charAt(pos)) {\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        if (cur.charAt(pos) == \\'7\\' || cur.charAt(pos) == \\'9\\') {\\n    \\n            count = count > 4 ? 4 : count;\\n        } else {\\n            count = count > 3 ? 3 : count;\\n        }\\n        \\n        int res = 0;\\n        \\n\\n        for (int i = pos; i < cur.length() && i < pos + count; i++) {\\n            res += helper(cur, i+1);\\n            res = res % mod;\\n        }\\n        return cache[pos] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer[] cache;\\n    int mod = (int)Math.pow(10,9) + 7;\\n    public int countTexts(String pressedKeys) {\\n        cache = new Integer[pressedKeys.length()];\\n        return helper(pressedKeys, 0);\\n    }\\n    \\n    int helper(String cur, int pos) {\\n        if (pos >= cur.length()) {\\n            return 1;\\n        }\\n        \\n        if (cache[pos] != null) {\\n            return cache[pos];\\n        }\\n        int count = 0;\\n        for (int i = pos; i < cur.length() && i < pos + 4; i++) {\\n            if (cur.charAt(i) == cur.charAt(pos)) {\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        if (cur.charAt(pos) == \\'7\\' || cur.charAt(pos) == \\'9\\') {\\n    \\n            count = count > 4 ? 4 : count;\\n        } else {\\n            count = count > 3 ? 3 : count;\\n        }\\n        \\n        int res = 0;\\n        \\n\\n        for (int i = pos; i < cur.length() && i < pos + count; i++) {\\n            res += helper(cur, i+1);\\n            res = res % mod;\\n        }\\n        return cache[pos] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018437,
                "title": "dp-tabulation-observation",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL**\\n\\n```\\n#define ll long long\\nclass Solution \\n{\\n    const int M=1e9+7;\\npublic:\\n    int countTexts(string pK) \\n    {\\n        vector<pair<char,int>>v;\\n        int len=pK.length();\\n        \\n        int maxx=0;\\n        bool has_7OR9=0;//optimisation\\n        for(int i=0;i<len;)\\n        {\\n            char ch=pK[i];\\n            int c=0;\\n            while(i<len&&pK[i]==ch)\\n            {\\n                c++;\\n                i++;\\n            }\\n            maxx=max(maxx,c);\\n            if(ch==\\'7\\'||ch==\\'9\\')\\n                has_7OR9=1;\\n            v.push_back({ch,c});\\n        }\\n        \\n        \\n        maxx=max(4,maxx);\\n        vector<ll>dp1(maxx+1,0);//storing characters other than 7 and 9\\n        vector<ll>dp2(maxx+1,0);//storing characters 7 and 9\\n        dp1[1]=1,dp1[2]=2,dp1[3]=4;\\n        dp2[1]=1,dp2[2]=2,dp2[3]=4,dp2[4]=8;\\n        \\n        for(int i=4;i<=maxx;i++)\\n        {\\n            dp1[i]=(dp1[i-1]+dp1[i-2]+dp1[i-3])%M;\\n        }\\n        \\n        //not necessary but okie \\n        if(has_7OR9)\\n        {\\n           for(int i=5;i<=maxx;i++)\\n        {\\n            dp2[i]=(dp2[i-1]%M+dp2[i-2]%M+dp2[i-3]%M+dp2[i-4]%M)%M;\\n        }  \\n        }\\n       \\n        ll res=1;\\n        for(auto [ch,c]:v)\\n        {\\n        if(ch==\\'7\\'||ch==\\'9\\')\\n        {\\n              res=(res*(dp2[c])%M)%M;\\n        }\\n        else\\n        {\\n              res=(res*(dp1[c])%M)%M;\\n        }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nclass Solution \\n{\\n    const int M=1e9+7;\\npublic:\\n    int countTexts(string pK) \\n    {\\n        vector<pair<char,int>>v;\\n        int len=pK.length();\\n        \\n        int maxx=0;\\n        bool has_7OR9=0;//optimisation\\n        for(int i=0;i<len;)\\n        {\\n            char ch=pK[i];\\n            int c=0;\\n            while(i<len&&pK[i]==ch)\\n            {\\n                c++;\\n                i++;\\n            }\\n            maxx=max(maxx,c);\\n            if(ch==\\'7\\'||ch==\\'9\\')\\n                has_7OR9=1;\\n            v.push_back({ch,c});\\n        }\\n        \\n        \\n        maxx=max(4,maxx);\\n        vector<ll>dp1(maxx+1,0);//storing characters other than 7 and 9\\n        vector<ll>dp2(maxx+1,0);//storing characters 7 and 9\\n        dp1[1]=1,dp1[2]=2,dp1[3]=4;\\n        dp2[1]=1,dp2[2]=2,dp2[3]=4,dp2[4]=8;\\n        \\n        for(int i=4;i<=maxx;i++)\\n        {\\n            dp1[i]=(dp1[i-1]+dp1[i-2]+dp1[i-3])%M;\\n        }\\n        \\n        //not necessary but okie \\n        if(has_7OR9)\\n        {\\n           for(int i=5;i<=maxx;i++)\\n        {\\n            dp2[i]=(dp2[i-1]%M+dp2[i-2]%M+dp2[i-3]%M+dp2[i-4]%M)%M;\\n        }  \\n        }\\n       \\n        ll res=1;\\n        for(auto [ch,c]:v)\\n        {\\n        if(ch==\\'7\\'||ch==\\'9\\')\\n        {\\n              res=(res*(dp2[c])%M)%M;\\n        }\\n        else\\n        {\\n              res=(res*(dp1[c])%M)%M;\\n        }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018404,
                "title": "simple-dp-solution-java-34ms-beats-100",
                "content": "We count consecutive repeating digits. For n repeating digits we count the number of ways to convert them into characters using DP.\\nFor digits 7 and 9 there are 4 characters corresponding to them. Their ways of converting n digits is as follows:\\nways[1]=1\\nways[2]=2\\nways[3]=4\\nways[4]=8\\n.\\n.\\n.\\nways[n]=ways[n-1]+ways[n-2]+ways[n-3]+ways[n-4]\\nFor digits other than 7 or 9, there are 3 characters corresponding to them. There ways of converting n repetitive digits is:\\nways[1]=1\\nways[2]=2\\nways[3]=4\\n.\\n.\\n.\\nways[n]=ways[n-1]+ways[n-2]+ways[n-3]\\nThe above formulas can be found out by taking some examples.\\n\\n```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int count=1;\\n        long total=1;\\n        for(int i=1;i<pressedKeys.length();i++)\\n        {\\n            if(pressedKeys.charAt(i)!=pressedKeys.charAt(i-1))\\n            {\\n                if(pressedKeys.charAt(i-1)==\\'7\\'||pressedKeys.charAt(i-1)==\\'9\\')\\n                    total=(total*count7or9(count))%1000000007;\\n                else\\n                    total=(total*countOthers(count)%1000000007);\\n                count=1;\\n            }\\n            else\\n                count++;\\n        }\\n        if(pressedKeys.charAt(pressedKeys.length()-1)==\\'7\\'||pressedKeys.charAt(pressedKeys.length()-1)==\\'9\\')\\n            total=(total*count7or9(count))%1000000007;\\n        else\\n            total=(total*countOthers(count)%1000000007);\\n        return (int)total;\\n    }\\n    public long count7or9(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        else if(count==4)\\n            return 8;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        ways[4]=8;\\n        for(int i=5;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3]+ways[i-4])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n    public long countOthers(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        for(int i=4;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int count=1;\\n        long total=1;\\n        for(int i=1;i<pressedKeys.length();i++)\\n        {\\n            if(pressedKeys.charAt(i)!=pressedKeys.charAt(i-1))\\n            {\\n                if(pressedKeys.charAt(i-1)==\\'7\\'||pressedKeys.charAt(i-1)==\\'9\\')\\n                    total=(total*count7or9(count))%1000000007;\\n                else\\n                    total=(total*countOthers(count)%1000000007);\\n                count=1;\\n            }\\n            else\\n                count++;\\n        }\\n        if(pressedKeys.charAt(pressedKeys.length()-1)==\\'7\\'||pressedKeys.charAt(pressedKeys.length()-1)==\\'9\\')\\n            total=(total*count7or9(count))%1000000007;\\n        else\\n            total=(total*countOthers(count)%1000000007);\\n        return (int)total;\\n    }\\n    public long count7or9(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        else if(count==4)\\n            return 8;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        ways[4]=8;\\n        for(int i=5;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3]+ways[i-4])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n    public long countOthers(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        for(int i=4;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018217,
                "title": "java-o-n-time-o-1-space-with-comments-image-explanation-circular-array",
                "content": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    public int countTexts(String pK) {\\n        int n = pK.length();\\n        int[] dp = new int[5];\\n        // 1 represents number is present previously, unique digit.\\n        Arrays.fill(dp,1);\\n        for(int i=n-1;i>=0;i--){\\n            dp[i%5] = 0;\\n            // Range till which dp needs to filled, i.e., \\n\\t\\t\\t// For every i we can add dp[i-1],dp[i-2],dp[i-3] to dp[i] and if pK[i] is either 7 or 9 then we can add dp[i-4] also. \\t\\t\\n\\t\\t\\tint max;\\n            if(pK.charAt(i)==\\'7\\' || pK.charAt(i)==\\'9\\') max = i+4;\\n            else max = i+3;\\n\\t\\t\\t// If max goes beyond length then iterate till n. \\n            if(max>n) max=n;\\n            for(int j =i;j<max && pK.charAt(i)==pK.charAt(j);j++){\\n\\t\\t\\t // Since array is circular for dp[i], dp[i-1],dp[i-2],dp[i-3] will be dp[i+2],dp[i+3],dp[i+4], hence j+1 while adding.\\n                dp[i%5] = (dp[i%5] + dp[(j+1)%5])%mod;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/895ac456-577d-40fc-bcc1-35b83aa8f813_1651985770.7568316.png)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    public int countTexts(String pK) {\\n        int n = pK.length();\\n        int[] dp = new int[5];\\n        // 1 represents number is present previously, unique digit.\\n        Arrays.fill(dp,1);\\n        for(int i=n-1;i>=0;i--){\\n            dp[i%5] = 0;\\n            // Range till which dp needs to filled, i.e., \\n\\t\\t\\t// For every i we can add dp[i-1],dp[i-2],dp[i-3] to dp[i] and if pK[i] is either 7 or 9 then we can add dp[i-4] also. \\t\\t\\n\\t\\t\\tint max;\\n            if(pK.charAt(i)==\\'7\\' || pK.charAt(i)==\\'9\\') max = i+4;\\n            else max = i+3;\\n\\t\\t\\t// If max goes beyond length then iterate till n. \\n            if(max>n) max=n;\\n            for(int j =i;j<max && pK.charAt(i)==pK.charAt(j);j++){\\n\\t\\t\\t // Since array is circular for dp[i], dp[i-1],dp[i-2],dp[i-3] will be dp[i+2],dp[i+3],dp[i+4], hence j+1 while adding.\\n                dp[i%5] = (dp[i%5] + dp[(j+1)%5])%mod;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018212,
                "title": "python-top-down-dp",
                "content": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tmod = 10 ** 9 + 7\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i):\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tcnt = dfs(i - 1)\\n\\t\\t\\t\\tif i >= 2 and pressedKeys[i - 1] == pressedKeys[i - 2]:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 2)\\n\\t\\t\\t\\tif i >= 3 and pressedKeys[i - 3:i] == pressedKeys[i - 3] * 3:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 3)\\n\\t\\t\\t\\tif pressedKeys[i - 1] == \"7\" or pressedKeys[i - 1] == \"9\":\\n\\t\\t\\t\\t\\tif i >= 4 and pressedKeys[i - 4:i] == pressedKeys[i - 4] * 4:\\n\\t\\t\\t\\t\\t\\tcnt += dfs(i - 4)\\n\\t\\t\\t\\treturn cnt % mod\\n\\t\\t\\treturn dfs(len(pressedKeys)) % mod",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tmod = 10 ** 9 + 7\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i):\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tcnt = dfs(i - 1)\\n\\t\\t\\t\\tif i >= 2 and pressedKeys[i - 1] == pressedKeys[i - 2]:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 2)\\n\\t\\t\\t\\tif i >= 3 and pressedKeys[i - 3:i] == pressedKeys[i - 3] * 3:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 3)\\n\\t\\t\\t\\tif pressedKeys[i - 1] == \"7\" or pressedKeys[i - 1] == \"9\":\\n\\t\\t\\t\\t\\tif i >= 4 and pressedKeys[i - 4:i] == pressedKeys[i - 4] * 4:\\n\\t\\t\\t\\t\\t\\tcnt += dfs(i - 4)\\n\\t\\t\\t\\treturn cnt % mod\\n\\t\\t\\treturn dfs(len(pressedKeys)) % mod",
                "codeTag": "Java"
            },
            {
                "id": 2018036,
                "title": "o-n-with-detail-explanation-for-dp",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/a30713df-3f1e-4b26-96c5-8c5194e5d738_1651983880.0719159.png)\\n\\n\\n**only digit 7 and 9 has 4 consecutive press \\nwhich we need to characters from i-3 , i-2, i-1 and i\\nrest will be maximum 3 index characters from i-2,i-1 and i**\\n\\n\\n\\n```\\nlong M=(long)(1e9)+7;\\n    String[] PAD=new String[]{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public int countTexts(String s) {        \\n        int n=s.length();\\n        long[] res = new long[n];\\n        res[0]=1;        \\n        \\n        for(int i=1;i<n;i++){\\n             res[i]=res[i-1];             \\n             res[i]%=M;\\n            \\n             if(i-1>=0 && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-2<0?1:res[i-2];            \\n                 res[i]%=M;\\n             }\\n                        \\n             if(i-2>=0 && s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-3<0?1:res[i-3];                   \\n                 res[i]%=M;\\n             }            \\n            \\n            if(i-3>=0 && (s.charAt(i)==\\'7\\'||s.charAt(i)==\\'9\\') && s.charAt(i-3)==s.charAt(i-2) &&s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                res[i]+=i-4<0?1:res[i-4];\\n                res[i]%=M;\\n            }            \\n        }        \\n        return (int)res[n-1];\\n        \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nlong M=(long)(1e9)+7;\\n    String[] PAD=new String[]{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public int countTexts(String s) {        \\n        int n=s.length();\\n        long[] res = new long[n];\\n        res[0]=1;        \\n        \\n        for(int i=1;i<n;i++){\\n             res[i]=res[i-1];             \\n             res[i]%=M;\\n            \\n             if(i-1>=0 && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-2<0?1:res[i-2];            \\n                 res[i]%=M;\\n             }\\n                        \\n             if(i-2>=0 && s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-3<0?1:res[i-3];                   \\n                 res[i]%=M;\\n             }            \\n            \\n            if(i-3>=0 && (s.charAt(i)==\\'7\\'||s.charAt(i)==\\'9\\') && s.charAt(i-3)==s.charAt(i-2) &&s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                res[i]+=i-4<0?1:res[i-4];\\n                res[i]%=M;\\n            }            \\n        }        \\n        return (int)res[n-1];\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018024,
                "title": "c-recursive-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    #define LL long long\\n    const LL MOD = 1000000000 + 7;\\n    \\n    LL dp[100001][5];\\n    \\n    LL ans_me(int ix, int jump) {\\n        if (ix == 0) return 1;\\n        LL &ret = dp[ix][jump];\\n        if (ret != -1) return ret;\\n        ret = 0;\\n        for (int i = 1; i <= jump; i++) {\\n            if (ix - i >= 0) {\\n                ret = (ret + ans_me(ix - i, jump)) % MOD;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int map_to_dig[10];\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof dp);\\n        for (int i = 2; i < 10; i++) map_to_dig[i] = 3;\\n        map_to_dig[7] = map_to_dig[9] = 4;\\n        LL res = 1;\\n        for (int i = 0; i < pressedKeys.size(); i++) {\\n            int ix = i;\\n            while(ix < pressedKeys.size() && pressedKeys[i] == pressedKeys[ix]) {\\n                ix++;\\n            }\\n            int typ = map_to_dig[ pressedKeys[i] - \\'0\\' ];\\n            res = (res * ans_me(ix - i, typ)) % MOD;\\n            i = ix - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define LL long long\\n    const LL MOD = 1000000000 + 7;\\n    \\n    LL dp[100001][5];\\n    \\n    LL ans_me(int ix, int jump) {\\n        if (ix == 0) return 1;\\n        LL &ret = dp[ix][jump];\\n        if (ret != -1) return ret;\\n        ret = 0;\\n        for (int i = 1; i <= jump; i++) {\\n            if (ix - i >= 0) {\\n                ret = (ret + ans_me(ix - i, jump)) % MOD;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int map_to_dig[10];\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof dp);\\n        for (int i = 2; i < 10; i++) map_to_dig[i] = 3;\\n        map_to_dig[7] = map_to_dig[9] = 4;\\n        LL res = 1;\\n        for (int i = 0; i < pressedKeys.size(); i++) {\\n            int ix = i;\\n            while(ix < pressedKeys.size() && pressedKeys[i] == pressedKeys[ix]) {\\n                ix++;\\n            }\\n            int typ = map_to_dig[ pressedKeys[i] - \\'0\\' ];\\n            res = (res * ans_me(ix - i, typ)) % MOD;\\n            i = ix - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017980,
                "title": "easy-java-dp-solution-similar-to-decode-ways-memoization",
                "content": "Consider taking a hashmap to store the characters corresponding to number of keypresses. Say if we press 3 twice, we store e in the hashmap as 33 => \\'e\\'.  Now we have put all the possible characters in the hashmap. \\n\\nWe now solve the problem like we did in [Decode Ways I](https://leetcode.com/problems/decode-ways/) and maintain the count, before storing the count in the DP make sure to take mod of the answer by 10^9 + 7.\\n\\n```\\nclass Solution {\\n    \\n        int mod = (int)1e9 + 7;\\n    public int countTexts(String keys, int idx, HashMap<Integer, Character> map, int[] dp) {\\n        \\n        \\n        if(idx >= keys.length()) {\\n            return 1;\\n        }   \\n        \\n        if(dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n        \\n        int count = 0;\\n        char ch = keys.charAt(idx);\\n        \\n        if(ch != \\'0\\' || ch != \\'1\\') {\\n            count = (count + countTexts(keys, idx + 1, map, dp)) % mod;\\n        }\\n        \\n        if(idx < keys.length() - 1) {\\n            int num = (ch - \\'0\\') * 10 + (keys.charAt(idx + 1) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 2, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 2) {\\n            int num = (ch - \\'0\\') * 100 + (keys.charAt(idx + 1) - \\'0\\') * 10 + (keys.charAt(idx + 2) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 3, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 3) {\\n            int num = (ch - \\'0\\') * 1000 + (keys.charAt(idx + 1) - \\'0\\') * 100 + (keys.charAt(idx + 2) - \\'0\\') * 10 + (keys.charAt(idx + 3) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 4, map, dp)) % mod;\\n            }\\n        }\\n        \\n        return dp[idx] = count % mod;\\n    }\\n    \\n    public int countTexts(String pressedKeys) {\\n        \\n        HashMap<Integer, Character> map = new HashMap<>();\\n        map.put(2, \\'a\\');\\n        map.put(22, \\'b\\');\\n        map.put(222, \\'c\\');\\n        map.put(3, \\'d\\');\\n        map.put(33, \\'e\\');\\n        map.put(333, \\'f\\');\\n        map.put(4, \\'g\\');\\n        map.put(44, \\'h\\');\\n        map.put(444, \\'i\\');\\n        map.put(5, \\'j\\');\\n        map.put(55, \\'k\\');\\n        map.put(555, \\'l\\');\\n        map.put(6, \\'m\\');\\n        map.put(66, \\'n\\');\\n        map.put(666, \\'o\\');\\n        map.put(7, \\'p\\');\\n        map.put(77, \\'q\\');\\n        map.put(777, \\'r\\');\\n        map.put(7777, \\'s\\');\\n        map.put(8, \\'t\\');\\n        map.put(88, \\'u\\');\\n        map.put(888, \\'v\\');\\n        map.put(9, \\'w\\');\\n        map.put(99, \\'x\\');\\n        map.put(999, \\'y\\');\\n        map.put(9999, \\'z\\');\\n        \\n        int[] dp = new int[pressedKeys.length() + 1];\\n        Arrays.fill(dp, -1);\\n        return countTexts(pressedKeys, 0, map, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n        int mod = (int)1e9 + 7;\\n    public int countTexts(String keys, int idx, HashMap<Integer, Character> map, int[] dp) {\\n        \\n        \\n        if(idx >= keys.length()) {\\n            return 1;\\n        }   \\n        \\n        if(dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n        \\n        int count = 0;\\n        char ch = keys.charAt(idx);\\n        \\n        if(ch != \\'0\\' || ch != \\'1\\') {\\n            count = (count + countTexts(keys, idx + 1, map, dp)) % mod;\\n        }\\n        \\n        if(idx < keys.length() - 1) {\\n            int num = (ch - \\'0\\') * 10 + (keys.charAt(idx + 1) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 2, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 2) {\\n            int num = (ch - \\'0\\') * 100 + (keys.charAt(idx + 1) - \\'0\\') * 10 + (keys.charAt(idx + 2) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 3, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 3) {\\n            int num = (ch - \\'0\\') * 1000 + (keys.charAt(idx + 1) - \\'0\\') * 100 + (keys.charAt(idx + 2) - \\'0\\') * 10 + (keys.charAt(idx + 3) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 4, map, dp)) % mod;\\n            }\\n        }\\n        \\n        return dp[idx] = count % mod;\\n    }\\n    \\n    public int countTexts(String pressedKeys) {\\n        \\n        HashMap<Integer, Character> map = new HashMap<>();\\n        map.put(2, \\'a\\');\\n        map.put(22, \\'b\\');\\n        map.put(222, \\'c\\');\\n        map.put(3, \\'d\\');\\n        map.put(33, \\'e\\');\\n        map.put(333, \\'f\\');\\n        map.put(4, \\'g\\');\\n        map.put(44, \\'h\\');\\n        map.put(444, \\'i\\');\\n        map.put(5, \\'j\\');\\n        map.put(55, \\'k\\');\\n        map.put(555, \\'l\\');\\n        map.put(6, \\'m\\');\\n        map.put(66, \\'n\\');\\n        map.put(666, \\'o\\');\\n        map.put(7, \\'p\\');\\n        map.put(77, \\'q\\');\\n        map.put(777, \\'r\\');\\n        map.put(7777, \\'s\\');\\n        map.put(8, \\'t\\');\\n        map.put(88, \\'u\\');\\n        map.put(888, \\'v\\');\\n        map.put(9, \\'w\\');\\n        map.put(99, \\'x\\');\\n        map.put(999, \\'y\\');\\n        map.put(9999, \\'z\\');\\n        \\n        int[] dp = new int[pressedKeys.length() + 1];\\n        Arrays.fill(dp, -1);\\n        return countTexts(pressedKeys, 0, map, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017961,
                "title": "memo-dp-easy-to-understand",
                "content": "intution->we have to count how much combinations are possible from a number\\neg abc->2,22,222\\nif (2222)->not valid;break\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int mod = 1000000007;\\n    map<int,int> index;\\n    vector<string>mp{\"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    map<int,int> dp;\\n    int solve(string &s, int i){\\n        if (i>=s.size()){\\n            return 1;\\n        }\\n        if (dp.find(i)!=dp.end()){\\n            return dp[i];\\n        }\\n        int ways= 0;\\n        int sz = index[s[i]-\\'0\\'];\\n        int count = 0;\\n        for (int j =i; j<s.size(); j++){\\n            count++;\\n            if (s[i]==s[j] && count<=sz){\\n                ways+=solve(s,j+1);\\n            }\\n            else{\\n                break;\\n            }\\n            \\n            ways%=mod;\\n        }\\n         return dp[i] = ways%mod;\\n        \\n    }\\n    int countTexts(string s) {\\n        int count = 0;\\n        for (auto it:mp){\\n            string temp = it;\\n            count++;\\n            for (int i =0; i<temp.size(); i++){\\n                index[count] = temp.size();\\n            }\\n        }\\n        \\n        return solve(s,0);\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int mod = 1000000007;\\n    map<int,int> index;\\n    vector<string>mp{\"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    map<int,int> dp;\\n    int solve(string &s, int i){\\n        if (i>=s.size()){\\n            return 1;\\n        }\\n        if (dp.find(i)!=dp.end()){\\n            return dp[i];\\n        }\\n        int ways= 0;\\n        int sz = index[s[i]-\\'0\\'];\\n        int count = 0;\\n        for (int j =i; j<s.size(); j++){\\n            count++;\\n            if (s[i]==s[j] && count<=sz){\\n                ways+=solve(s,j+1);\\n            }\\n            else{\\n                break;\\n            }\\n            \\n            ways%=mod;\\n        }\\n         return dp[i] = ways%mod;\\n        \\n    }\\n    int countTexts(string s) {\\n        int count = 0;\\n        for (auto it:mp){\\n            string temp = it;\\n            count++;\\n            for (int i =0; i<temp.size(); i++){\\n                index[count] = temp.size();\\n            }\\n        }\\n        \\n        return solve(s,0);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017930,
                "title": "c-recursive-o-n-solution",
                "content": "```\\nclass Solution {\\n    \\n    #define ll long long \\n    int mod = 1000000007 ;\\n    \\n    int go( string &A , int i , ll t[] )\\n    {\\n        int N = A.size();\\n        if(t[i] != -1 ) return t[i] ;\\n        \\n        ll res = go( A , i+1 , t )%mod ;  // default case \\n        \\n        if( i+1 < N && A[i+1] == A[i] )\\n            res += go( A , i+2 , t );  // two consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( i+2 < N && A[i+1] == A[i] && A[i+2] == A[i] )\\n            res += go( A , i+3 , t ); // three consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( A[i] == \\'7\\' || A[i] == \\'9\\' ) // special cases \\n        {\\n            if( i+3 < N && A[i+1] == A[i] && A[i+2] == A[i] && A[i+3] == A[i] )\\n                res += go( A , i+4 , t ); // 4 consecutive can be grouped \\n        }\\n        \\n        return t[i] = res%mod ;\\n    }\\n    \\npublic:\\n    int countTexts(string A ) {\\n        \\n        int N = A.size();\\n        ll t[N+1];\\n        memset( t , -1 , sizeof t );\\n        t[N] = 1 ;\\n        \\n        return go( A , 0 , t )%mod ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    #define ll long long \\n    int mod = 1000000007 ;\\n    \\n    int go( string &A , int i , ll t[] )\\n    {\\n        int N = A.size();\\n        if(t[i] != -1 ) return t[i] ;\\n        \\n        ll res = go( A , i+1 , t )%mod ;  // default case \\n        \\n        if( i+1 < N && A[i+1] == A[i] )\\n            res += go( A , i+2 , t );  // two consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( i+2 < N && A[i+1] == A[i] && A[i+2] == A[i] )\\n            res += go( A , i+3 , t ); // three consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( A[i] == \\'7\\' || A[i] == \\'9\\' ) // special cases \\n        {\\n            if( i+3 < N && A[i+1] == A[i] && A[i+2] == A[i] && A[i+3] == A[i] )\\n                res += go( A , i+4 , t ); // 4 consecutive can be grouped \\n        }\\n        \\n        return t[i] = res%mod ;\\n    }\\n    \\npublic:\\n    int countTexts(string A ) {\\n        \\n        int N = A.size();\\n        ll t[N+1];\\n        memset( t , -1 , sizeof t );\\n        t[N] = 1 ;\\n        \\n        return go( A , 0 , t )%mod ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017868,
                "title": "updated-can-someone-please-explain-how-to-make-it-memory-efficient",
                "content": "update: found my mistake , i missed an &  with the string due to which it was copied again and again with every recursion \\uD83E\\uDD72. \\n```\\nclass Solution {\\npublic:\\n    int dp(int i,string pk,vector<int> &lim,vector<int> &v)\\n    {if(i==pk.size()){return 1;}\\n     if(v[i]!=-1){return v[i];}\\n        int ways=0,cnt=0;\\n        for(int j=i;j<pk.size();j++)\\n        {cnt++;\\n            \\n            ways=(ways+dp(j+1,pk,lim,v))%1000000007;\\n            if(pk[j]!=pk[j+1]||cnt>=lim[pk[j]-\\'0\\']){break;}\\n        }\\n     return v[i]=ways;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> lim(10,3);lim[7]++;lim[9]++;\\n        vector<int> v(pressedKeys.size(),-1);\\n        return dp(0,pressedKeys,lim,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp(int i,string pk,vector<int> &lim,vector<int> &v)\\n    {if(i==pk.size()){return 1;}\\n     if(v[i]!=-1){return v[i];}\\n        int ways=0,cnt=0;\\n        for(int j=i;j<pk.size();j++)\\n        {cnt++;\\n            \\n            ways=(ways+dp(j+1,pk,lim,v))%1000000007;\\n            if(pk[j]!=pk[j+1]||cnt>=lim[pk[j]-\\'0\\']){break;}\\n        }\\n     return v[i]=ways;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> lim(10,3);lim[7]++;lim[9]++;\\n        vector<int> v(pressedKeys.size(),-1);\\n        return dp(0,pressedKeys,lim,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017769,
                "title": "java-count-dp-bottom-up",
                "content": "1, count the numbers in the given string, \\npressedKeys 22235555\\ncompressed  3 of 2s ; 1 of 3s, 4 of 5s\\n\\n2, calculate 2 dp arrays for the number with 3 possible letters and 4 possible letters till the maximum \\ndp3[m] is the possible ways of keys for m same numbers (which has 3 letters on the button)\\ndp4[m] is the possible ways of keys for m same numbers (which has 4 letters on the button)\\n\\ndp3: 0,1,2,4,7,...\\ndp4: 1,1,2,4,8,...\\n\\n3, multiply the possibilitis to get the result.\\n\\n\\n```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        int maxLen = 0;\\n        char prevCh = \\'a\\';\\n        int curLen = 0;\\n        for(int i=0;i<pressedKeys.length();i++){\\n            if(pressedKeys.charAt(i) == prevCh){\\n                curLen++;\\n                maxLen = Math.max(maxLen,curLen);\\n            }else{\\n                if(curLen >0){\\n                    list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n                }\\n                curLen = 1;\\n                prevCh = pressedKeys.charAt(i);\\n            }\\n        }\\n        list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n        \\n       // System.out.println(list);        \\n        \\n        long[] dp3 = new long[Math.max(maxLen+1,5)];\\n        long[] dp4 = new long[Math.max(maxLen+1,5)];             \\n        \\n        dp3[1] = 1;\\n        dp3[2] = 2;\\n        dp3[3] = 4;\\n        \\n        dp4[0] = 1;\\n        dp4[1] = 1;\\n        dp4[2] = 2;\\n        dp4[3] = 4;\\n\\n        for(int i=4;i<dp3.length;i++){            \\n            dp3[i] = ((long)dp3[i-1]+dp3[i-2]+dp3[i-3])%MOD;\\n            dp4[i] = ((long)dp4[i-1]+dp4[i-2]+dp4[i-3]+dp4[i-4])%MOD;\\n        }\\n        \\n        //System.out.println(Arrays.toString(dp3));\\n        //System.out.println(Arrays.toString(dp4));\\n        \\n        long ret = 1;\\n        for(List<Integer> num:list){\\n            long nextVal = 1;\\n            if(num.get(1)==7 || num.get(1)==9){\\n                nextVal = dp4[num.get(0)];\\n            }else            {\\n                nextVal = dp3[num.get(0)];\\n            }\\n            ret =  (ret*nextVal)%MOD;\\n        }\\n        \\n        return (int)ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        int maxLen = 0;\\n        char prevCh = \\'a\\';\\n        int curLen = 0;\\n        for(int i=0;i<pressedKeys.length();i++){\\n            if(pressedKeys.charAt(i) == prevCh){\\n                curLen++;\\n                maxLen = Math.max(maxLen,curLen);\\n            }else{\\n                if(curLen >0){\\n                    list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n                }\\n                curLen = 1;\\n                prevCh = pressedKeys.charAt(i);\\n            }\\n        }\\n        list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n        \\n       // System.out.println(list);        \\n        \\n        long[] dp3 = new long[Math.max(maxLen+1,5)];\\n        long[] dp4 = new long[Math.max(maxLen+1,5)];             \\n        \\n        dp3[1] = 1;\\n        dp3[2] = 2;\\n        dp3[3] = 4;\\n        \\n        dp4[0] = 1;\\n        dp4[1] = 1;\\n        dp4[2] = 2;\\n        dp4[3] = 4;\\n\\n        for(int i=4;i<dp3.length;i++){            \\n            dp3[i] = ((long)dp3[i-1]+dp3[i-2]+dp3[i-3])%MOD;\\n            dp4[i] = ((long)dp4[i-1]+dp4[i-2]+dp4[i-3]+dp4[i-4])%MOD;\\n        }\\n        \\n        //System.out.println(Arrays.toString(dp3));\\n        //System.out.println(Arrays.toString(dp4));\\n        \\n        long ret = 1;\\n        for(List<Integer> num:list){\\n            long nextVal = 1;\\n            if(num.get(1)==7 || num.get(1)==9){\\n                nextVal = dp4[num.get(0)];\\n            }else            {\\n                nextVal = dp3[num.get(0)];\\n            }\\n            ret =  (ret*nextVal)%MOD;\\n        }\\n        \\n        return (int)ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017767,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int n=pressedKeys.length();\\n        \\n        long [] dp = new long[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            char ch=pressedKeys.charAt(i);\\n            int j=i;\\n            if(ch!=\\'7\\' && ch!=\\'9\\'){\\n                while(j>0 && j>=i-2 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-3){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }else{\\n                while(j>0 && j>=i-3 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-4){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }\\n        }\\n        return (int) (dp[n]%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int n=pressedKeys.length();\\n        \\n        long [] dp = new long[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            char ch=pressedKeys.charAt(i);\\n            int j=i;\\n            if(ch!=\\'7\\' && ch!=\\'9\\'){\\n                while(j>0 && j>=i-2 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-3){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }else{\\n                while(j>0 && j>=i-3 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-4){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }\\n        }\\n        return (int) (dp[n]%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017766,
                "title": "c-dp-o-n-solution",
                "content": "```\\nlong long mod=1000000007;\\n    \\n    long long ans[100001];\\n    \\n    long long solve(string &s,int i)\\n    {\\n        if(i==s.size())\\n        {\\n            return 1;\\n        }\\n        \\n        if(ans[i]!=-1)\\n        {\\n            return ans[i];\\n        }\\n        \\n        long long cnt=0;\\n        \\n        if(s[i]==\\'9\\'||s[i]==\\'7\\')\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+4;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+3;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        ans[i]=cnt%mod;\\n        return ans[i];\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(ans,-1,sizeof(ans));\\n        \\n        long long fans=solve(pressedKeys,0);\\n        return fans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nlong long mod=1000000007;\\n    \\n    long long ans[100001];\\n    \\n    long long solve(string &s,int i)\\n    {\\n        if(i==s.size())\\n        {\\n            return 1;\\n        }\\n        \\n        if(ans[i]!=-1)\\n        {\\n            return ans[i];\\n        }\\n        \\n        long long cnt=0;\\n        \\n        if(s[i]==\\'9\\'||s[i]==\\'7\\')\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+4;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+3;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        ans[i]=cnt%mod;\\n        return ans[i];\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(ans,-1,sizeof(ans));\\n        \\n        long long fans=solve(pressedKeys,0);\\n        return fans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084399,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string>v={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\\n                    \"tuv\",\"wxyz\"};\\n    vector<int>dp;\\n    const int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.length(),-1);\\n        return fun(s,0);\\n    }\\n    int fun(string &s,int idx)\\n    {\\n        if(idx==s.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        // cout<<idx<<endl;\\n        int num=s[idx]-\\'0\\';\\n        int count=0;\\n        for(int i=0;i<v[num].length();i++)\\n        {\\n            if((idx+i)<s.length() and s[idx]==s[idx+i])\\n            {\\n                count+=fun(s,idx+i+1);\\n                count=count%mod;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[idx]=count%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\\n                    \"tuv\",\"wxyz\"};\\n    vector<int>dp;\\n    const int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.length(),-1);\\n        return fun(s,0);\\n    }\\n    int fun(string &s,int idx)\\n    {\\n        if(idx==s.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        // cout<<idx<<endl;\\n        int num=s[idx]-\\'0\\';\\n        int count=0;\\n        for(int i=0;i<v[num].length();i++)\\n        {\\n            if((idx+i)<s.length() and s[idx]==s[idx+i])\\n            {\\n                count+=fun(s,idx+i+1);\\n                count=count%mod;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[idx]=count%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4067699,
                "title": "c-beats-93-using-combination-sum-iv",
                "content": "![Sighhhhhhhhhhhh 2023-09-20 at 17.39.06.png](https://assets.leetcode.com/users/images/785614dc-1c1f-4df9-815a-15654ac45cba_1695199155.8621168.png)\\n\\nThis problem can use the same algorithm from [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/).\\n\\nEg if there is a string of three 4s, \"444\"\\nThen we need to know how many ways she could have pressed them\\neg (1,1,1) or (1,2) or (2,1) or (3)\\nThis is Combination Sum IV.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n\\n    // September 20 2023\\n    int countTexts(const string& pressedKeys) {\\n        unsigned long long total = 1;\\n        for (int i = 0; i < pressedKeys.length(); i++) {\\n            char c = pressedKeys[i];\\n            int j = i + 1;\\n            while (j < pressedKeys.length() && c == pressedKeys[j]) j++;\\n            int numLetters = (c == \\'7\\' || c == \\'9\\') ? 4 : 3;\\n            total *= (combinationSum4(numLetters, j - i) % MOD);\\n            total %= MOD;\\n            i = j - 1;\\n        }\\n        return total;\\n    }\\nprivate:\\n    // numLetters = 4 for 7 or 9, 3 otherwise\\n    unsigned long long combinationSum4(const int numLetters, const int target) {\\n        unsigned long long dp[target + 1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[target] = 1;\\n        for (int i = target - 1; i >= 0; i--) {\\n            for (int j = 1; j <= numLetters; j++) { // can press 1,2,3, or 4 times\\n                if (j + i <= target) {\\n                    dp[i] += dp[j + i] % MOD;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n\\n    // September 20 2023\\n    int countTexts(const string& pressedKeys) {\\n        unsigned long long total = 1;\\n        for (int i = 0; i < pressedKeys.length(); i++) {\\n            char c = pressedKeys[i];\\n            int j = i + 1;\\n            while (j < pressedKeys.length() && c == pressedKeys[j]) j++;\\n            int numLetters = (c == \\'7\\' || c == \\'9\\') ? 4 : 3;\\n            total *= (combinationSum4(numLetters, j - i) % MOD);\\n            total %= MOD;\\n            i = j - 1;\\n        }\\n        return total;\\n    }\\nprivate:\\n    // numLetters = 4 for 7 or 9, 3 otherwise\\n    unsigned long long combinationSum4(const int numLetters, const int target) {\\n        unsigned long long dp[target + 1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[target] = 1;\\n        for (int i = target - 1; i >= 0; i--) {\\n            for (int j = 1; j <= numLetters; j++) { // can press 1,2,3, or 4 times\\n                if (j + i <= target) {\\n                    dp[i] += dp[j + i] % MOD;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067382,
                "title": "ruby-solution-inspired-by-owen1605",
                "content": "# Intuition\\nAll credits to https://leetcode.com/problems/count-number-of-texts/solutions/2018336/python-dp-with-diagrams-for-beginners/\\nRewrite in Ruby to help ruby devs read the code easier\\n\\n\\n# Code\\n```\\n# @param {String} pressed_keys\\n# @return {Integer}\\ndef count_texts(pressed_keys) # \"22233\"\\n    dp = [1] + Array.new(pressed_keys.size, 0) # [1, 0, 0, 0, 0, 0]\\n\\n    pressed_keys.chars.each_with_index do |key, i|\\n        dp[i + 1] = dp[i]\\n\\n        # index 0 [1, 1, 0, 0, 0, 0]\\n        # index 1 [1, 1, 1, 0, 0, 0]\\n        # index 2 [1, 1, 2, 2, 0, 0]\\n        # 3   [1, 1, 2, 4, 4, 0]\\n        # 4   [1, 1, 2, 4, 4, 4]\\n\\n        # check if the current number is the same as previous one, eg: 22 \\n        if i >= 1 && pressed_keys[i - 1] == key\\n            dp[i + 1] += dp[i -1]\\n\\n            if i >= 2 && pressed_keys[i - 2] == key\\n                dp[i + 1] += dp[i - 2]\\n\\n                # 7 and 9 can have 4 possible letters\\n                if i >= 3 && pressed_keys[i-3] == key && [\"9\", \"7\"].include?(key)\\n                    dp[i+1] += dp[i-3]\\n                end\\n            end    \\n        end\\n\\n        dp[i+1] %= 10**9 + 7    \\n    end\\n\\n    dp[-1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} pressed_keys\\n# @return {Integer}\\ndef count_texts(pressed_keys) # \"22233\"\\n    dp = [1] + Array.new(pressed_keys.size, 0) # [1, 0, 0, 0, 0, 0]\\n\\n    pressed_keys.chars.each_with_index do |key, i|\\n        dp[i + 1] = dp[i]\\n\\n        # index 0 [1, 1, 0, 0, 0, 0]\\n        # index 1 [1, 1, 1, 0, 0, 0]\\n        # index 2 [1, 1, 2, 2, 0, 0]\\n        # 3   [1, 1, 2, 4, 4, 0]\\n        # 4   [1, 1, 2, 4, 4, 4]\\n\\n        # check if the current number is the same as previous one, eg: 22 \\n        if i >= 1 && pressed_keys[i - 1] == key\\n            dp[i + 1] += dp[i -1]\\n\\n            if i >= 2 && pressed_keys[i - 2] == key\\n                dp[i + 1] += dp[i - 2]\\n\\n                # 7 and 9 can have 4 possible letters\\n                if i >= 3 && pressed_keys[i-3] == key && [\"9\", \"7\"].include?(key)\\n                    dp[i+1] += dp[i-3]\\n                end\\n            end    \\n        end\\n\\n        dp[i+1] %= 10**9 + 7    \\n    end\\n\\n    dp[-1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4046080,
                "title": "python-dp-o-n-o-1-memory-100-runtime-91-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing \"dp[e] = dp[e-1] << 1\" and optimizing space complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)**\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1,0,0,0,0]\\n        mod = 10**9 + 7\\n        count = 1\\n        for i in range(1,len(pressedKeys)):\\n            e = i%5\\n            if pressedKeys[i] != pressedKeys[i-1]:\\n                dp[e] = dp[e-1] % mod\\n                count = 1\\n            else:\\n                count += 1\\n                if count <= 3 and pressedKeys[i] in \"234568\" or count <= 4 and pressedKeys[i] in \"79\":\\n                    dp[e] = (dp[e-1] <<1 ) % mod\\n                else:\\n                    dp[e] = (dp[e-1] + dp[e-2] + dp[e-3]) % mod\\n                    if pressedKeys[i] in \"79\":\\n                        dp[e] = (dp[e] + dp[e-4]) % mod\\n        \\n        return dp[(len(pressedKeys)-1) % 5]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1,0,0,0,0]\\n        mod = 10**9 + 7\\n        count = 1\\n        for i in range(1,len(pressedKeys)):\\n            e = i%5\\n            if pressedKeys[i] != pressedKeys[i-1]:\\n                dp[e] = dp[e-1] % mod\\n                count = 1\\n            else:\\n                count += 1\\n                if count <= 3 and pressedKeys[i] in \"234568\" or count <= 4 and pressedKeys[i] in \"79\":\\n                    dp[e] = (dp[e-1] <<1 ) % mod\\n                else:\\n                    dp[e] = (dp[e-1] + dp[e-2] + dp[e-3]) % mod\\n                    if pressedKeys[i] in \"79\":\\n                        dp[e] = (dp[e] + dp[e-4]) % mod\\n        \\n        return dp[(len(pressedKeys)-1) % 5]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984152,
                "title": "python-2-liner",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`F(a,b)` function recursively counts number of alternatives when you pressed a number that includes `b` character `a` times. \\n`K` list holds number of characters in every number from 2 to 9. \\nWe return multiplication of number of alternatives for every number group in `P` string with using `groupby`. \\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, P, m = 10**9+7, K = [0,0,3,3,3,3,3,4,3,4], c = cache):\\n        F = c(lambda a,b:1 if a<2 else sum(F(a-i,b) for i in range(1,min(a+1,b+1))) % m)\\n        return prod(F(len(list(v)),K[int(k)]) for k,v in groupby(P)) % m\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, P, m = 10**9+7, K = [0,0,3,3,3,3,3,4,3,4], c = cache):\\n        F = c(lambda a,b:1 if a<2 else sum(F(a-i,b) for i in range(1,min(a+1,b+1))) % m)\\n        return prod(F(len(list(v)),K[int(k)]) for k,v in groupby(P)) % m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951663,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countTexts(string s) \\n    {\\n        int ct;\\n        ct=1;\\n\\n        long long ans;\\n        ans=1;\\n\\n        vector<long long> count1(s.size()+3);\\n        count1[1]=1;\\n        count1[2]=2;\\n        count1[3]=4;\\n\\n        vector<long long> count2(s.size()+4);\\n        count2[1]=1;\\n        count2[2]=2;\\n        count2[3]=4;\\n        count2[4]=8;\\n\\n        for(int i=4;i<=s.size();i++)\\n        {\\n            count1[i]=count1[i-1]+count1[i-2]+count1[i-3];\\n            count1[i]%=1000000007;\\n        }\\n\\n        for(int i=5;i<=s.size();i++)\\n        {\\n            count2[i]=count2[i-1]+count2[i-2]+count2[i-3]+count2[i-4];\\n            count2[i]%=1000000007;\\n        }\\n\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                ct++;\\n            }\\n\\n            else\\n            {\\n                if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                {\\n                    ans*=count2[ct];\\n                }\\n\\n                else\\n                {\\n                    ans*=count1[ct];\\n                }\\n\\n                ans%=1000000007;\\n                ct=1;\\n            }\\n        }\\n\\n        if(s[s.size()-1]==\\'7\\' || s[s.size()-1]==\\'9\\')\\n        {\\n            ans*=count2[ct];\\n        }\\n\\n        else\\n        {\\n            ans*=count1[ct];\\n        }\\n\\n        ans%=1000000007;\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countTexts(string s) \\n    {\\n        int ct;\\n        ct=1;\\n\\n        long long ans;\\n        ans=1;\\n\\n        vector<long long> count1(s.size()+3);\\n        count1[1]=1;\\n        count1[2]=2;\\n        count1[3]=4;\\n\\n        vector<long long> count2(s.size()+4);\\n        count2[1]=1;\\n        count2[2]=2;\\n        count2[3]=4;\\n        count2[4]=8;\\n\\n        for(int i=4;i<=s.size();i++)\\n        {\\n            count1[i]=count1[i-1]+count1[i-2]+count1[i-3];\\n            count1[i]%=1000000007;\\n        }\\n\\n        for(int i=5;i<=s.size();i++)\\n        {\\n            count2[i]=count2[i-1]+count2[i-2]+count2[i-3]+count2[i-4];\\n            count2[i]%=1000000007;\\n        }\\n\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                ct++;\\n            }\\n\\n            else\\n            {\\n                if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                {\\n                    ans*=count2[ct];\\n                }\\n\\n                else\\n                {\\n                    ans*=count1[ct];\\n                }\\n\\n                ans%=1000000007;\\n                ct=1;\\n            }\\n        }\\n\\n        if(s[s.size()-1]==\\'7\\' || s[s.size()-1]==\\'9\\')\\n        {\\n            ans*=count2[ct];\\n        }\\n\\n        else\\n        {\\n            ans*=count1[ct];\\n        }\\n\\n        ans%=1000000007;\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949119,
                "title": "iterative-dynamic-programming-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  int countTexts(string s) {\\n    int n = s.size();\\n    vector<int> dp(n + 1);\\n    dp[0] = 1;\\n    const int mod = 1000000007;\\n    for(int i = 0; i < n; i++)  {\\n      if(s[i] == \\'7\\' || s[i] == \\'9\\')  {\\n        for(int j = 1; j < 5; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      } else  {\\n        for(int j = 1; j < 4; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return dp[n];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countTexts(string s) {\\n    int n = s.size();\\n    vector<int> dp(n + 1);\\n    dp[0] = 1;\\n    const int mod = 1000000007;\\n    for(int i = 0; i < n; i++)  {\\n      if(s[i] == \\'7\\' || s[i] == \\'9\\')  {\\n        for(int j = 1; j < 5; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      } else  {\\n        for(int j = 1; j < 4; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return dp[n];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941922,
                "title": "c-dp-more-readable-class",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        _keys = pressedKeys;\\n        for (int i = 0; i < (int) _keys.size(); i ++) {\\n            countTextsInternal(i);\\n        }\\n        return _result.back() % maxVal;\\n    }\\nprivate:\\n    const int maxVal = 1000000007;\\n    const int maxDeq = 4;\\n    deque<int> _result;\\n    int _deqStartIndex {0};\\n    string _keys;\\n\\n    void countTextsInternal(const int index) {\\n        const int startIndex = _keys.size() - index - 1; // string\\'s start index\\n        const int maxSeq = maxSequence(_keys[startIndex]);\\n        int seq = 1;\\n\\n        for (int i = 1; i < maxSeq && (index - i >= 0); i ++) {\\n            if (_keys[i + startIndex] == _keys[startIndex]) {\\n                seq ++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        int count = 0; \\n        if (index == 0) {\\n            count = 1;\\n        } else if (seq == 1) {\\n            count = getPrevResult(index - 1);\\n        } else {\\n            for (int i = 0; i < seq; i ++) {\\n                count += getPrevResult(index - i - 1);\\n                if (count > maxVal) {\\n                    count -= maxVal;\\n                }\\n            }\\n        }\\n\\n        setCurrentResult(count);\\n    }\\n\\n    void setCurrentResult(int value) {\\n        _result.push_back(value);\\n        if (_result.size() > maxDeq) {\\n            _result.pop_front();\\n            _deqStartIndex++;\\n        }\\n    }\\n\\n    int getPrevResult(int index) {\\n        if (index < 0) {\\n            return 1; // it\\'s the case itself\\n        }\\n        return _result[index - _deqStartIndex];\\n    }\\n\\n    int maxSequence(char c) {\\n\\n        switch (c) {\\n            case \\'8\\' :\\n            case \\'6\\' :\\n            case \\'5\\' :\\n            case \\'4\\' :\\n            case \\'3\\' :\\n            case \\'2\\' : return 3;\\n            case \\'9\\' :\\n            case \\'7\\' : return 4;\\n        }\\n        printf(\"Unrecognised digit [%c] (%d)\\\\n\", c, c);\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        _keys = pressedKeys;\\n        for (int i = 0; i < (int) _keys.size(); i ++) {\\n            countTextsInternal(i);\\n        }\\n        return _result.back() % maxVal;\\n    }\\nprivate:\\n    const int maxVal = 1000000007;\\n    const int maxDeq = 4;\\n    deque<int> _result;\\n    int _deqStartIndex {0};\\n    string _keys;\\n\\n    void countTextsInternal(const int index) {\\n        const int startIndex = _keys.size() - index - 1; // string\\'s start index\\n        const int maxSeq = maxSequence(_keys[startIndex]);\\n        int seq = 1;\\n\\n        for (int i = 1; i < maxSeq && (index - i >= 0); i ++) {\\n            if (_keys[i + startIndex] == _keys[startIndex]) {\\n                seq ++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        int count = 0; \\n        if (index == 0) {\\n            count = 1;\\n        } else if (seq == 1) {\\n            count = getPrevResult(index - 1);\\n        } else {\\n            for (int i = 0; i < seq; i ++) {\\n                count += getPrevResult(index - i - 1);\\n                if (count > maxVal) {\\n                    count -= maxVal;\\n                }\\n            }\\n        }\\n\\n        setCurrentResult(count);\\n    }\\n\\n    void setCurrentResult(int value) {\\n        _result.push_back(value);\\n        if (_result.size() > maxDeq) {\\n            _result.pop_front();\\n            _deqStartIndex++;\\n        }\\n    }\\n\\n    int getPrevResult(int index) {\\n        if (index < 0) {\\n            return 1; // it\\'s the case itself\\n        }\\n        return _result[index - _deqStartIndex];\\n    }\\n\\n    int maxSequence(char c) {\\n\\n        switch (c) {\\n            case \\'8\\' :\\n            case \\'6\\' :\\n            case \\'5\\' :\\n            case \\'4\\' :\\n            case \\'3\\' :\\n            case \\'2\\' : return 3;\\n            case \\'9\\' :\\n            case \\'7\\' : return 4;\\n        }\\n        printf(\"Unrecognised digit [%c] (%d)\\\\n\", c, c);\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873773,
                "title": "python-dp",
                "content": "# Intuition\\n- We cant count the ways using permutations and combinations if you think about it, we will need the ones that come next\\n- Hence recursion and DP\\n- Choose Each possibility and add it up\\n\\n# Approach\\n- Count possibilities using recursion\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        @cache\\n        def solve(index):\\n            if index >= len(pressedKeys):\\n                return 1\\n            else:\\n                i = index\\n                total = 0\\n                counter = 0\\n                while i<len(pressedKeys) and pressedKeys[i] == pressedKeys[index] and ((counter < 3 and pressedKeys[index] !=\\'7\\' and pressedKeys[index] !=\\'9\\') or (counter < 4 and (pressedKeys[index] ==\\'7\\' or pressedKeys[index] ==\\'9\\'))) :\\n                    total+=solve(i+1)\\n                    counter+=1\\n                    i+=1\\n                return total%((10**9)+7)\\n        return solve(0)\\n        # return 2\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        @cache\\n        def solve(index):\\n            if index >= len(pressedKeys):\\n                return 1\\n            else:\\n                i = index\\n                total = 0\\n                counter = 0\\n                while i<len(pressedKeys) and pressedKeys[i] == pressedKeys[index] and ((counter < 3 and pressedKeys[index] !=\\'7\\' and pressedKeys[index] !=\\'9\\') or (counter < 4 and (pressedKeys[index] ==\\'7\\' or pressedKeys[index] ==\\'9\\'))) :\\n                    total+=solve(i+1)\\n                    counter+=1\\n                    i+=1\\n                return total%((10**9)+7)\\n        return solve(0)\\n        # return 2\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864462,
                "title": "python-easy-to-read-and-understand-dp",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        t = [0]*(n+1)\\n        t[0] = 1\\n        \\n        for i in range(1, n+1):\\n            t[i] = t[i-1]\\n            if i-2 >= 0 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                t[i] += t[i-2]\\n            if i-3 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                t[i] += t[i-3]\\n            if pressedKeys[i-1] == \\'7\\' or pressedKeys[i-1] == \\'9\\':\\n                if i-4 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    t[i] += t[i-4]\\n        \\n        return t[n]%(10**9 + 7)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        t = [0]*(n+1)\\n        t[0] = 1\\n        \\n        for i in range(1, n+1):\\n            t[i] = t[i-1]\\n            if i-2 >= 0 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                t[i] += t[i-2]\\n            if i-3 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                t[i] += t[i-3]\\n            if pressedKeys[i-1] == \\'7\\' or pressedKeys[i-1] == \\'9\\':\\n                if i-4 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    t[i] += t[i-4]\\n        \\n        return t[n]%(10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 3863369,
                "title": "best-dp-question-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int f(int ind,string &s,vector<int>&dp){\\n        if(ind == s.size())return 1;\\n\\n        if(dp[ind]!=-1)return dp[ind]%mod;\\n\\n\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int ans3 = 0;\\n        int ans4 = 0;\\n        ans1 = f(ind+1,s,dp);\\n        if(ind+1<s.size() && s[ind] == s[ind+1]){\\n            ans2+=f(ind+2,s,dp);\\n        }\\n        if(ind+2<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2]){\\n            ans3+=f(ind+3,s,dp);\\n        }\\n        if(ind+3<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2] && s[ind+2] == s[ind+3] \\n         && (s[ind] == \\'7\\' || s[ind] == \\'9\\'))ans4+=f(ind+4,s,dp);\\n\\n        return dp[ind] = (((ans1+ans2)%mod+ans3)%mod + ans4)%mod;\\n    }\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n,-1);\\n        return f(0,pressedKeys,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int f(int ind,string &s,vector<int>&dp){\\n        if(ind == s.size())return 1;\\n\\n        if(dp[ind]!=-1)return dp[ind]%mod;\\n\\n\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int ans3 = 0;\\n        int ans4 = 0;\\n        ans1 = f(ind+1,s,dp);\\n        if(ind+1<s.size() && s[ind] == s[ind+1]){\\n            ans2+=f(ind+2,s,dp);\\n        }\\n        if(ind+2<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2]){\\n            ans3+=f(ind+3,s,dp);\\n        }\\n        if(ind+3<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2] && s[ind+2] == s[ind+3] \\n         && (s[ind] == \\'7\\' || s[ind] == \\'9\\'))ans4+=f(ind+4,s,dp);\\n\\n        return dp[ind] = (((ans1+ans2)%mod+ans3)%mod + ans4)%mod;\\n    }\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n,-1);\\n        return f(0,pressedKeys,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861489,
                "title": "tabulation-java-bottom-up-explanation-in-comments-line-wise",
                "content": "COMMENTED PRECISELY\\n\\n# Code TABULATION (BOTTOM UP )\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n\\n        int [] key = new int[] { 0 , 0 , 3 , 3 , 3 , 3 , 3  , 4 , 3 , 4 }; //number of alphabets available at any pressed digit \\n\\n        int n = pressedKeys.length();\\n\\n        int [] dp = new int [n+1];  // n + 1 bcz dp[n] = 1 is set to be one to include \"\" case which returns 1 possible message is sent .. \\n        //forming condition for memoization\\n\\n        dp[n] = 1; // note n index is the not the part of string ..\\n        //string has length n , means n-1 is the last index of string \\n\\n\\n        for(int ind = n - 1 ; ind >= 0 ; ind--){\\n\\n            int count = 0 ;\\n            int num = pressedKeys.charAt(ind) - \\'0\\'; // retreiving the number pressed from the inout string \\n\\n            int rep =  key[num]; // getting the number of alphabets \\n            //that are stored along the digit at the phone dial pad \\n\\n            for(int i = 0 ; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i ) ; i++){\\n             // the for loop condition \\n             // preesedKeys.charAt(ind) == pressedKeys.charAt(ind + i) and i = 0 for the start ..so compares itself to itself only  in 1st iteration \\n\\n             \\n\\n                count += dp[ind + i + 1];\\n                count %= mod;\\n\\n                // for eg  n = 7  and \"3334444\"\\n                //dp[] of size 7+1 is initialized\\n\\n                // dp[7] = 1 \\n                // dp[6] = dp[7] = 1\\n\\n                // dp[5] = dp[6] + dp[7] = 1 + 1 = 2\\n                //dp[4] = dp[7] + dp[6] + dp[5] = 1 + 1 + 2 = 4 \\n            }\\n\\n            dp[ind] = count;\\n        }\\n         return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n\\n        int [] key = new int[] { 0 , 0 , 3 , 3 , 3 , 3 , 3  , 4 , 3 , 4 }; //number of alphabets available at any pressed digit \\n\\n        int n = pressedKeys.length();\\n\\n        int [] dp = new int [n+1];  // n + 1 bcz dp[n] = 1 is set to be one to include \"\" case which returns 1 possible message is sent .. \\n        //forming condition for memoization\\n\\n        dp[n] = 1; // note n index is the not the part of string ..\\n        //string has length n , means n-1 is the last index of string \\n\\n\\n        for(int ind = n - 1 ; ind >= 0 ; ind--){\\n\\n            int count = 0 ;\\n            int num = pressedKeys.charAt(ind) - \\'0\\'; // retreiving the number pressed from the inout string \\n\\n            int rep =  key[num]; // getting the number of alphabets \\n            //that are stored along the digit at the phone dial pad \\n\\n            for(int i = 0 ; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i ) ; i++){\\n             // the for loop condition \\n             // preesedKeys.charAt(ind) == pressedKeys.charAt(ind + i) and i = 0 for the start ..so compares itself to itself only  in 1st iteration \\n\\n             \\n\\n                count += dp[ind + i + 1];\\n                count %= mod;\\n\\n                // for eg  n = 7  and \"3334444\"\\n                //dp[] of size 7+1 is initialized\\n\\n                // dp[7] = 1 \\n                // dp[6] = dp[7] = 1\\n\\n                // dp[5] = dp[6] + dp[7] = 1 + 1 = 2\\n                //dp[4] = dp[7] + dp[6] + dp[5] = 1 + 1 + 2 = 4 \\n            }\\n\\n            dp[ind] = count;\\n        }\\n         return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857665,
                "title": "used-brute-force-and-memoized-it-but-gives-mle-can-help-me-to-optimize-it-please",
                "content": "```\\nclass Solution:\\n    def isValidKey(self, key, mp):\\n        length = len(key)\\n        stk = []\\n        stk.append(key[0])\\n        for i in key[1:]:\\n            if(stk[-1] == i):\\n                continue\\n            else:\\n                stk.append(i)\\n        if(len(stk) > 1):\\n            return False\\n        key = stk[0]\\n        if(length > mp[key]):\\n            return False\\n        return True\\n    \\n    def helper(self, pressedKeys, mp, dp):\\n        if( not pressedKeys):\\n            return 1\\n        if pressedKeys in dp:\\n            return dp[pressedKeys]\\n        res = 0\\n        for i in range(0, len(pressedKeys)):\\n            ch = pressedKeys[:i+1]\\n            if(self.isValidKey(ch, mp)):\\n                res += self.helper(pressedKeys[i+1:], mp, dp) % 1000000007\\n            else:\\n                break\\n        dp[pressedKeys] = res % 1000000007\\n        return dp[pressedKeys]\\n    \\n    def countTexts(self, pressedKeys: str) -> int:\\n        mp = {\\'2\\' : 3,\\n             \\'3\\' : 3, \\n             \\'4\\' : 3, \\n             \\'5\\' : 3, \\n             \\'6\\' : 3, \\n             \\'7\\' : 4,\\n             \\'8\\' : 3,\\n             \\'9\\' : 4}\\n        dp = {}\\n        return self.helper(pressedKeys, mp, dp) % 1000000007\\n                \\n        \\n        \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def isValidKey(self, key, mp):\\n        length = len(key)\\n        stk = []\\n        stk.append(key[0])\\n        for i in key[1:]:\\n            if(stk[-1] == i):\\n                continue\\n            else:\\n                stk.append(i)\\n        if(len(stk) > 1):\\n            return False\\n        key = stk[0]\\n        if(length > mp[key]):\\n            return False\\n        return True\\n    \\n    def helper(self, pressedKeys, mp, dp):\\n        if( not pressedKeys):\\n            return 1\\n        if pressedKeys in dp:\\n            return dp[pressedKeys]\\n        res = 0\\n        for i in range(0, len(pressedKeys)):\\n            ch = pressedKeys[:i+1]\\n            if(self.isValidKey(ch, mp)):\\n                res += self.helper(pressedKeys[i+1:], mp, dp) % 1000000007\\n            else:\\n                break\\n        dp[pressedKeys] = res % 1000000007\\n        return dp[pressedKeys]\\n    \\n    def countTexts(self, pressedKeys: str) -> int:\\n        mp = {\\'2\\' : 3,\\n             \\'3\\' : 3, \\n             \\'4\\' : 3, \\n             \\'5\\' : 3, \\n             \\'6\\' : 3, \\n             \\'7\\' : 4,\\n             \\'8\\' : 3,\\n             \\'9\\' : 4}",
                "codeTag": "Java"
            },
            {
                "id": 3857007,
                "title": "dp-faster-than-99-22-optimized-solution",
                "content": "![Screenshot 2023-08-02 100332.png](https://assets.leetcode.com/users/images/2b3c8307-b6f2-47f7-9001-08cf5692b6c7_1691049413.8140266.png)\\n\\n# Intuition\\nIf continuous occurence for 2,3,4,5,6,8 is till 3 we can use $$dp[i] = dp[i-1]<<1 $$ and same for 7,9 until continuous occurence of 4. Using a variable while iterating to keep count of same numbers occuring together.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, k: str) -> int:\\n        n = len(k)\\n        dp = [0 for _ in range(n)]\\n        dp[0] = 1\\n        mod = 10 ** 9 + 7\\n        count = 1\\n        for i in range(1, n):\\n            if k[i-1]!=k[i]:\\n                dp[i] = dp[i-1]\\n                count = 1\\n            else:\\n                count+=1\\n                if count <=3 and k[i] in \"234568\" or  count <= 4 and k[i] in \"79\":\\n                    dp[i] = (dp[i-1]<<1)%mod\\n                else:\\n                    dp[i] = (dp[i-1] + dp[i-2] + dp[i-3])%mod\\n                    if k[i] in \"79\":\\n                        dp[i] = (dp[i] + dp[i-4])%mod\\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, k: str) -> int:\\n        n = len(k)\\n        dp = [0 for _ in range(n)]\\n        dp[0] = 1\\n        mod = 10 ** 9 + 7\\n        count = 1\\n        for i in range(1, n):\\n            if k[i-1]!=k[i]:\\n                dp[i] = dp[i-1]\\n                count = 1\\n            else:\\n                count+=1\\n                if count <=3 and k[i] in \"234568\" or  count <= 4 and k[i] in \"79\":\\n                    dp[i] = (dp[i-1]<<1)%mod\\n                else:\\n                    dp[i] = (dp[i-1] + dp[i-2] + dp[i-3])%mod\\n                    if k[i] in \"79\":\\n                        dp[i] = (dp[i] + dp[i-4])%mod\\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856389,
                "title": "c-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<long long> dp(n+1);\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1];\\n            if(i-2>=0 && s[i-1]==s[i-2])\\n            dp[i]+=dp[i-2];\\n            if(i-3>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3])\\n            dp[i]+=dp[i-3];\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && i-4>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3] && s[i-1]==s[i-4])\\n            dp[i]+=dp[i-4];\\n            dp[i]%=mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<long long> dp(n+1);\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1];\\n            if(i-2>=0 && s[i-1]==s[i-2])\\n            dp[i]+=dp[i-2];\\n            if(i-3>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3])\\n            dp[i]+=dp[i-3];\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && i-4>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3] && s[i-1]==s[i-4])\\n            dp[i]+=dp[i-4];\\n            dp[i]%=mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829619,
                "title": "o-n-1d-dp-top-down-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<long long> dp;\\n    long long solve(string& pressedKeys,int i){\\n        if(i==pressedKeys.size()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long totalWays=0;\\n        int j=i;\\n        while(j<pressedKeys.size() && pressedKeys[i]==pressedKeys[j]){\\n            if(j-i==3 && (pressedKeys[i]!=\\'7\\' && pressedKeys[i]!=\\'9\\')){\\n                break;\\n            }else if(j-i==4) break;\\n            totalWays+=solve(pressedKeys,j+1);\\n            totalWays%=mod;\\n            j++;\\n        }\\n        return dp[i]=totalWays%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        dp.resize(pressedKeys.size(),-1);\\n        return solve(pressedKeys,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<long long> dp;\\n    long long solve(string& pressedKeys,int i){\\n        if(i==pressedKeys.size()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long totalWays=0;\\n        int j=i;\\n        while(j<pressedKeys.size() && pressedKeys[i]==pressedKeys[j]){\\n            if(j-i==3 && (pressedKeys[i]!=\\'7\\' && pressedKeys[i]!=\\'9\\')){\\n                break;\\n            }else if(j-i==4) break;\\n            totalWays+=solve(pressedKeys,j+1);\\n            totalWays%=mod;\\n            j++;\\n        }\\n        return dp[i]=totalWays%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        dp.resize(pressedKeys.size(),-1);\\n        return solve(pressedKeys,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821220,
                "title": "python-single-pass-o-n-solution-with-o-1-space",
                "content": "```\\nclass Solution:\\n    # Time: O(N), Space: O(1)\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # we can identify the groups of similar digits and then for each group we find the number of ways and finally multiply\\n        # the ways of each group together to find the answer\\n        # Example: 22233\\n        # in this example there are two groups 222 and 33\\n        # 222 can be split in 4 ways => 2 2 2, 22 2, 2 22, 222\\n        # 33 can be split in 2 ways => 3 3, 33 \\n        # so total ways are 4*2 = 8\\n        \\n        # Example 2: 2222\\n        # there is only one group\\n        # ways = 2 2 2 2, 22 2 2, 222 2, 2 2 22, 2 22 2, 2 222, 22 22\\n        # not that 2222 is not valid in this case as 2 can only be pressed max 3 times so we cannot take more than 3 2\\'s\\n        # as one unit\\n        \\n        # now we try to find the pattern here\\n        # for single 2 there is 1 way\\n        # for two 2\\'s there are 1*2=2 ways => 2 2, 22\\n        # for three 2\\'s there are 2*2=4 ways\\n        # for four ways there are 4*2-1=7 ways\\n        # for each next length the number of ways are increasing by a factor of 2\\n        # but for lengths larger than 3 it is not increasing by a factor of 2 as at max we can take 3 digits as one unit\\n        # so for each length larger than 3 we subtract the ways at cur_length - 3 from current length ways\\n        \\n        # Look at the below example \\n        # the combinations for the lengths from 1 to 14\\n        # length = 1,2,3,4,5 ,6 ,7 ,8 ,9  ,10 ,11 ,12 ,13  ,14\\n        # ways   = 1,2,4,7,13,24,44,81,149,274,504,927,1705,3136\\n        # now we can find some pattern in this series\\n        # we keep the first 3 elements in an array as we know the combinations for 3 digits. so for 3 \\n        # letter digits we store 1,2,4,7 and for 4 letter digits we store 1,2,4,8,15 \\n        # now to calculate the combinations for all lengths above 4 we use the formula ways[i-1]*2-ways[i-3]\\n        # as for 3 letter digits we cannot use more than 3 digits as one unit so we need to subtract the\\n        # combinations we had at length i-3\\n        # we do the same for four length digits but for four length digits we subtract i-4\\n        \\n        # to save the space we do not need to store every length in an array of length N, as each length is \\n        # depenedent on last 4 lengths only so we can use an array of length 4 to optimize space to O(1)\\n        \\n        \\n        three_letter_digits = set([\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\'])\\n        four_letter_digits = set([\\'7\\',\\'9\\'])\\n        \\n        three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n        cur_group_length = 1\\n        total_combinations = prev_group_combinations = 1\\n        \\n        for i in range(1, len(pressedKeys)):\\n            char = pressedKeys[i]\\n            if char != pressedKeys[i-1]:\\n                # new group started so we reset all variables\\n                total_combinations *= prev_group_combinations\\n                cur_group_length = 1\\n                prev_group_combinations = 1\\n                three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n            else:\\n                cur_group_length += 1\\n                index = (cur_group_length-1)%4 if char in three_letter_digits else (cur_group_length-1)%5\\n                if char in three_letter_digits and cur_group_length > 4:\\n                    last_length_combs = max(three_letters_dp)\\n                    three_letters_dp[index] = last_length_combs*2 - three_letters_dp[index]\\n                elif char in four_letter_digits and cur_group_length > 5:\\n                    last_length_combs = max(four_letters_dp)\\n                    four_letters_dp[index] = last_length_combs*2 - four_letters_dp[index]\\n                \\n                prev_group_combinations = three_letters_dp[index] if char in three_letter_digits else four_letters_dp[index]\\n        \\n        total_combinations *= prev_group_combinations\\n        \\n        return total_combinations % (pow(10,9) + 7)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Time: O(N), Space: O(1)\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # we can identify the groups of similar digits and then for each group we find the number of ways and finally multiply\\n        # the ways of each group together to find the answer\\n        # Example: 22233\\n        # in this example there are two groups 222 and 33\\n        # 222 can be split in 4 ways => 2 2 2, 22 2, 2 22, 222\\n        # 33 can be split in 2 ways => 3 3, 33 \\n        # so total ways are 4*2 = 8\\n        \\n        # Example 2: 2222\\n        # there is only one group\\n        # ways = 2 2 2 2, 22 2 2, 222 2, 2 2 22, 2 22 2, 2 222, 22 22\\n        # not that 2222 is not valid in this case as 2 can only be pressed max 3 times so we cannot take more than 3 2\\'s\\n        # as one unit\\n        \\n        # now we try to find the pattern here\\n        # for single 2 there is 1 way\\n        # for two 2\\'s there are 1*2=2 ways => 2 2, 22\\n        # for three 2\\'s there are 2*2=4 ways\\n        # for four ways there are 4*2-1=7 ways\\n        # for each next length the number of ways are increasing by a factor of 2\\n        # but for lengths larger than 3 it is not increasing by a factor of 2 as at max we can take 3 digits as one unit\\n        # so for each length larger than 3 we subtract the ways at cur_length - 3 from current length ways\\n        \\n        # Look at the below example \\n        # the combinations for the lengths from 1 to 14\\n        # length = 1,2,3,4,5 ,6 ,7 ,8 ,9  ,10 ,11 ,12 ,13  ,14\\n        # ways   = 1,2,4,7,13,24,44,81,149,274,504,927,1705,3136\\n        # now we can find some pattern in this series\\n        # we keep the first 3 elements in an array as we know the combinations for 3 digits. so for 3 \\n        # letter digits we store 1,2,4,7 and for 4 letter digits we store 1,2,4,8,15 \\n        # now to calculate the combinations for all lengths above 4 we use the formula ways[i-1]*2-ways[i-3]\\n        # as for 3 letter digits we cannot use more than 3 digits as one unit so we need to subtract the\\n        # combinations we had at length i-3\\n        # we do the same for four length digits but for four length digits we subtract i-4\\n        \\n        # to save the space we do not need to store every length in an array of length N, as each length is \\n        # depenedent on last 4 lengths only so we can use an array of length 4 to optimize space to O(1)\\n        \\n        \\n        three_letter_digits = set([\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\'])\\n        four_letter_digits = set([\\'7\\',\\'9\\'])\\n        \\n        three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n        cur_group_length = 1\\n        total_combinations = prev_group_combinations = 1\\n        \\n        for i in range(1, len(pressedKeys)):\\n            char = pressedKeys[i]\\n            if char != pressedKeys[i-1]:\\n                # new group started so we reset all variables\\n                total_combinations *= prev_group_combinations\\n                cur_group_length = 1\\n                prev_group_combinations = 1\\n                three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n            else:\\n                cur_group_length += 1\\n                index = (cur_group_length-1)%4 if char in three_letter_digits else (cur_group_length-1)%5\\n                if char in three_letter_digits and cur_group_length > 4:\\n                    last_length_combs = max(three_letters_dp)\\n                    three_letters_dp[index] = last_length_combs*2 - three_letters_dp[index]\\n                elif char in four_letter_digits and cur_group_length > 5:\\n                    last_length_combs = max(four_letters_dp)\\n                    four_letters_dp[index] = last_length_combs*2 - four_letters_dp[index]\\n                \\n                prev_group_combinations = three_letters_dp[index] if char in three_letter_digits else four_letters_dp[index]\\n        \\n        total_combinations *= prev_group_combinations\\n        \\n        return total_combinations % (pow(10,9) + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807863,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp3;\\n    vector<int> dp4;\\n    long long mod;\\n    vector<int> available;\\n    long long getCount(int available, int n, vector<int> &dp) {\\n        if (dp[n]) return dp[n];\\n        long long answer = 0; \\n        for (int i = 1; i <= available; ++i) {\\n            if (n - i >= 0)answer += getCount(available, n - i, dp);\\n        }\\n        answer %= mod;\\n        dp[n] = answer;\\n        return answer;\\n    }\\n    int countTexts(string pressedKeys) {\\n        \\n        long long answer = 1;\\n        int size = std::max(int(pressedKeys.size() + 1),10);\\n        dp3.resize(size, 0);\\n        dp4.resize(size, 0);\\n        mod = 1E9 + 7;\\n        available = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n\\n        dp3[0] = dp4[0] = 1;\\n        dp3[1] = dp4[1] = 1;\\n        dp3[2] = dp4[2] = 2;\\n        dp3[3] = dp4[3] = 4;\\n        dp3[4] = 7;\\n        dp4[4] = 8;\\n\\n        char ch = pressedKeys[0];\\n        int count = 0;\\n        for (char x : pressedKeys) {\\n            if (x == ch) ++count;\\n            else {\\n                int number = ch - \\'0\\';\\n                if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n                else answer *= getCount(available[number], count, dp3);\\n                answer %= mod;\\n                count = 1;\\n                ch = x;\\n            }\\n        }\\n        int number = ch - \\'0\\';\\n        if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n        else answer *= getCount(available[number], count, dp3);\\n        answer %= mod;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp3;\\n    vector<int> dp4;\\n    long long mod;\\n    vector<int> available;\\n    long long getCount(int available, int n, vector<int> &dp) {\\n        if (dp[n]) return dp[n];\\n        long long answer = 0; \\n        for (int i = 1; i <= available; ++i) {\\n            if (n - i >= 0)answer += getCount(available, n - i, dp);\\n        }\\n        answer %= mod;\\n        dp[n] = answer;\\n        return answer;\\n    }\\n    int countTexts(string pressedKeys) {\\n        \\n        long long answer = 1;\\n        int size = std::max(int(pressedKeys.size() + 1),10);\\n        dp3.resize(size, 0);\\n        dp4.resize(size, 0);\\n        mod = 1E9 + 7;\\n        available = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n\\n        dp3[0] = dp4[0] = 1;\\n        dp3[1] = dp4[1] = 1;\\n        dp3[2] = dp4[2] = 2;\\n        dp3[3] = dp4[3] = 4;\\n        dp3[4] = 7;\\n        dp4[4] = 8;\\n\\n        char ch = pressedKeys[0];\\n        int count = 0;\\n        for (char x : pressedKeys) {\\n            if (x == ch) ++count;\\n            else {\\n                int number = ch - \\'0\\';\\n                if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n                else answer *= getCount(available[number], count, dp3);\\n                answer %= mod;\\n                count = 1;\\n                ch = x;\\n            }\\n        }\\n        int number = ch - \\'0\\';\\n        if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n        else answer *= getCount(available[number], count, dp3);\\n        answer %= mod;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793062,
                "title": "recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s, int i, int n, vector<int> &dp){\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\')){\\n                    ans+=func(s,i+4,n,dp);\\n                    ans=ans%mod;\\n                }\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s, int i, int n, vector<int> &dp){\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\')){\\n                    ans+=func(s,i+4,n,dp);\\n                    ans=ans%mod;\\n                }\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780208,
                "title": "c-o-n-faster-than-100-solutions-simple-dp-single-pass-solution-7ms",
                "content": "```\\nint val[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nvector<long long> th((int)1e5+1), f((int)1e5+2);\\nint mod = 1e9+7;\\nconst int fast = [](){\\n    th[0] = 1;\\n    th[1] = 1;\\n    th[2] = 2;\\n    \\n    f[0] = 1;\\n    f[1] = 1;\\n    f[2] = 2;\\n    f[3] = 4;\\n    \\n    for(int i=3;i<th.size();i++)\\n    {\\n        th[i] = (th[i-1]+th[i-2]+th[i-3])%mod;\\n        f[i+1] = (f[i] + f[i-1]+f[i-2]+f[i-3])%mod;\\n    }\\n    \\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    \\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int ans = 1;\\n        \\n        for(int i=0;i<pressedKeys.length();i++)\\n        {\\n            int j = i+1;\\n            for(;j<pressedKeys.size();j++)\\n            {\\n                if(pressedKeys[j]!=pressedKeys[i])break;\\n            }\\n            \\n            ans = (1LL*ans*((val[pressedKeys[i]-\\'0\\']==3)?th[j-i]:f[j-i]))%mod;\\n            i = j-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\tWe first stored the number of alphabets on that are possible for each each number, e.g. 3 characters (a,b,c) are possible using 2 and 4 characters (p,q,r,s) are possible using number 7.\\n\\t\\n\\tThen I make the arrays th (for numbers which can produce 3 characters) and f (for 4 characters).\\n\\nThese arrays store the number of ways to make a string if there are contiguous numbers which are same.\\n\\nFor e.g. if 2 comes 5 times conitnuosly, and we know two can make 3 characters:\\n\\twe simply use th[5].\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint val[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nvector<long long> th((int)1e5+1), f((int)1e5+2);\\nint mod = 1e9+7;\\nconst int fast = [](){\\n    th[0] = 1;\\n    th[1] = 1;\\n    th[2] = 2;\\n    \\n    f[0] = 1;\\n    f[1] = 1;\\n    f[2] = 2;\\n    f[3] = 4;\\n    \\n    for(int i=3;i<th.size();i++)\\n    {\\n        th[i] = (th[i-1]+th[i-2]+th[i-3])%mod;\\n        f[i+1] = (f[i] + f[i-1]+f[i-2]+f[i-3])%mod;\\n    }\\n    \\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    \\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int ans = 1;\\n        \\n        for(int i=0;i<pressedKeys.length();i++)\\n        {\\n            int j = i+1;\\n            for(;j<pressedKeys.size();j++)\\n            {\\n                if(pressedKeys[j]!=pressedKeys[i])break;\\n            }\\n            \\n            ans = (1LL*ans*((val[pressedKeys[i]-\\'0\\']==3)?th[j-i]:f[j-i]))%mod;\\n            i = j-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770330,
                "title": "cpp-2-dp-approaches-recursion-with-memoization-memoization-o-4-n-solution",
                "content": "* ### Recursion With Memoization Approach\\n```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int solve(int i,string &s, vector<int> &dp){\\n        int n = s.size();\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n        int take=0;\\n        for(int k=0;k<tot;k++){\\n            if(i+k<n and s[i+k]==s[i]) take = (take%mod + solve(i+k+1,s,dp)%mod)%mod;\\n            else break;\\n        }\\n        \\n        return dp[i] = take%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size()+1,-1);\\n        return solve(0,pressedKeys,dp);\\n    }\\n};\\n```\\n* ### Tabulation Approach\\n```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<int> dp(s.size()+1,0);\\n        dp[n]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n            int take=0;\\n            for(int k=0;k<tot;k++){\\n                if(i+k<n and s[i+k]==s[i]) take = (take%mod + dp[i+k+1]%mod)%mod;\\n                else break;\\n            }\\n\\n            dp[i] = take%mod;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int solve(int i,string &s, vector<int> &dp){\\n        int n = s.size();\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n        int take=0;\\n        for(int k=0;k<tot;k++){\\n            if(i+k<n and s[i+k]==s[i]) take = (take%mod + solve(i+k+1,s,dp)%mod)%mod;\\n            else break;\\n        }\\n        \\n        return dp[i] = take%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size()+1,-1);\\n        return solve(0,pressedKeys,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<int> dp(s.size()+1,0);\\n        dp[n]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n            int take=0;\\n            for(int k=0;k<tot;k++){\\n                if(i+k<n and s[i+k]==s[i]) take = (take%mod + dp[i+k+1]%mod)%mod;\\n                else break;\\n            }\\n\\n            dp[i] = take%mod;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756626,
                "title": "java-dp-31ms-beats-91",
                "content": "# Approach\\n1. Use an  int[] values to store the values/count of texts that can be formed backwords. values[n -1] = 1;\\n2. Look at each number: \\n    - key 4 can form 3 sequences: pressed once, twice, three times\\n    - key 9 can form 4 sequences: pressed once, twice, three, four times.\\n3. Create a simple mapping for max number of presses for each number: 3 -> 2, 9 > 3 means that digit 3 can take up at most 2 other chars at its right (current, next and next so an offset of 2) \\n4. Let\\'s look at the exmple 333 : values[0,0,1] (values[n-1] = 1 as last digit can form just 1 single number:itself)\\n    - i = 1: 33: \\n    - we can have one sequence of 1 press (d), thus the word is dd\\n    - we can have one sequence of 2 presses: (e) thus the word is e\\n    so values is [0,2,1]\\n    - i = 0: 333\\n    - if we press 3 once, then we form the text/word count given by values[1] = 2\\n    - if we press two times we form the text/word count given by values[2] = 1  \\n    - if we press it 3 times, we form the text f, thus just 1 word\\n    - total = 2+1+1 = 4;            \\n5. Starting from index i = n-2 to 0\\n    - loop with j from current index and stop when j reaches the max number of allowed keys for that number OR > n\\n    - sum up the indices/values represented by values[i+j+1] for each loop of j,\\n    - set values[i] = that sum.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int[] maxKeys = {0,0,2,2,2,2,2,3,2,3};\\n    public int countTexts(String pressedKeys) {\\n        char[] chars = pressedKeys.toCharArray();\\n        int[] values = new int[chars.length];\\n        values[chars.length - 1] = 1;\\n        int sum;\\n        int digit, j;\\n        for (int i = chars.length - 2; i >= 0; i--) {\\n            sum = 0;\\n            j = 0;\\n            digit = chars[i] - \\'0\\';\\n            for (; j <= maxKeys[digit] && i + j < chars.length && chars[i] == chars[i + j]; j++) {\\n                sum = (sum + (i + j + 1 > chars.length - 1 ? 1 : values[i + j + 1])) % 1_000_000_007;\\n            }\\n            values[i] = sum;\\n        }\\n        return values[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[] maxKeys = {0,0,2,2,2,2,2,3,2,3};\\n    public int countTexts(String pressedKeys) {\\n        char[] chars = pressedKeys.toCharArray();\\n        int[] values = new int[chars.length];\\n        values[chars.length - 1] = 1;\\n        int sum;\\n        int digit, j;\\n        for (int i = chars.length - 2; i >= 0; i--) {\\n            sum = 0;\\n            j = 0;\\n            digit = chars[i] - \\'0\\';\\n            for (; j <= maxKeys[digit] && i + j < chars.length && chars[i] == chars[i + j]; j++) {\\n                sum = (sum + (i + j + 1 > chars.length - 1 ? 1 : values[i + j + 1])) % 1_000_000_007;\\n            }\\n            values[i] = sum;\\n        }\\n        return values[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709203,
                "title": "simple-dp-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[100000];\\n    int solve(int index,string &str){\\n        if(index>=str.size())\\n            return 1;\\n        \\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int ans=0;\\n        if(str[index]==\\'9\\'||str[index]==\\'7\\'){\\n            for(int i=index;i<str.size()&&i<index+4;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        else{\\n            \\n             for(int i=index;i<str.size()&&i<index+3;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        \\n        return dp[index]=ans;\\n            \\n        }\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,pressedKeys);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[100000];\\n    int solve(int index,string &str){\\n        if(index>=str.size())\\n            return 1;\\n        \\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int ans=0;\\n        if(str[index]==\\'9\\'||str[index]==\\'7\\'){\\n            for(int i=index;i<str.size()&&i<index+4;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        else{\\n            \\n             for(int i=index;i<str.size()&&i<index+3;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        \\n        return dp[index]=ans;\\n            \\n        }\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,pressedKeys);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696036,
                "title": "easy-accepted-c-recursive-and-memoized-solution-similar-to-phone-keypad-problem",
                "content": "# Intuition\\nRecursion and Memoization\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int solve(string &s,int idx,vector<string> &phone,vector<int> &dp){\\n        if(idx==s.length()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        string mapped=phone[s[idx]-\\'0\\'];\\n        int len=mapped.length();\\n\\n        int instance=0;\\n\\n        int index=idx;\\n\\n        while(index<s.length() && s[index]==s[idx]){\\n            instance++;\\n            if(instance==len){\\n                break;\\n            }\\n            index++;\\n        }\\n\\n        int mini=min(instance,len);\\n\\n        int ans=0;\\n\\n        for(int i=1;i<=mini && i+idx<=s.length();i++){\\n            ans+=solve(s,idx+i,phone,dp)%mod;\\n            ans=ans%mod;\\n        }\\n\\n        return dp[idx]=ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        vector<string> phone={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        int n=pressedKeys.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(pressedKeys,0,phone,dp)%mod;\\n    }\\n};\\n\\n// \"2 2 2 3 3 \" \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int solve(string &s,int idx,vector<string> &phone,vector<int> &dp){\\n        if(idx==s.length()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        string mapped=phone[s[idx]-\\'0\\'];\\n        int len=mapped.length();\\n\\n        int instance=0;\\n\\n        int index=idx;\\n\\n        while(index<s.length() && s[index]==s[idx]){\\n            instance++;\\n            if(instance==len){\\n                break;\\n            }\\n            index++;\\n        }\\n\\n        int mini=min(instance,len);\\n\\n        int ans=0;\\n\\n        for(int i=1;i<=mini && i+idx<=s.length();i++){\\n            ans+=solve(s,idx+i,phone,dp)%mod;\\n            ans=ans%mod;\\n        }\\n\\n        return dp[idx]=ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        vector<string> phone={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        int n=pressedKeys.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(pressedKeys,0,phone,dp)%mod;\\n    }\\n};\\n\\n// \"2 2 2 3 3 \" \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676641,
                "title": "c-solution-using-dp-easy-to-understand",
                "content": "\\n```\\npublic class Solution {\\n    public int CountTexts(string s) {\\n        int mod = ((int)1e9) + 7;\\n        int[] dp = new int[s.Length + 1];\\n        Array.Fill(dp,-1);\\n        int solve(int idx){\\n            if(idx >= s.Length) return 1;\\n            if(dp[idx] != -1) return dp[idx];\\n            int options = (s[idx] == \\'7\\' || s[idx] == \\'9\\') ? 4 : 3;\\n            \\n            int right = idx;\\n            while(right < s.Length && (right - idx) < options && s[right] == s[idx])\\n                right++;\\n\\n            long res = 0;\\n            for (int j = idx + 1; j <= right; j++) res += (solve(j) % mod);\\n            return dp[idx] = ((int)(res % mod));\\n        }\\n        return solve(0) % mod;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountTexts(string s) {\\n        int mod = ((int)1e9) + 7;\\n        int[] dp = new int[s.Length + 1];\\n        Array.Fill(dp,-1);\\n        int solve(int idx){\\n            if(idx >= s.Length) return 1;\\n            if(dp[idx] != -1) return dp[idx];\\n            int options = (s[idx] == \\'7\\' || s[idx] == \\'9\\') ? 4 : 3;\\n            \\n            int right = idx;\\n            while(right < s.Length && (right - idx) < options && s[right] == s[idx])\\n                right++;\\n\\n            long res = 0;\\n            for (int j = idx + 1; j <= right; j++) res += (solve(j) % mod);\\n            return dp[idx] = ((int)(res % mod));\\n        }\\n        return solve(0) % mod;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671545,
                "title": "pyhton3-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0]*len(pressedKeys)\\n        spes = set({\\'7\\', \\'9\\'})\\n        dp[0] = 1\\n\\n        mod = 10**9+7\\n\\n        cnt = 1\\n        for i in range(1 , len(pressedKeys)):\\n    \\n            if pressedKeys[i] not in spes:\\n                if pressedKeys[i]== pressedKeys[i-1]:\\n                    if cnt < 3:\\n                        dp[i]= 2*dp[i-1]\\n                        cnt+=1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            else:\\n                if pressedKeys[i-1] == pressedKeys[i]:\\n                    if cnt<4:\\n                        dp[i] = dp[i-1]*2\\n                        cnt += 1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            \\n            dp[i] = dp[i]%mod\\n    \\n    \\n        return(dp[-1])\\n        \\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0]*len(pressedKeys)\\n        spes = set({\\'7\\', \\'9\\'})\\n        dp[0] = 1\\n\\n        mod = 10**9+7\\n\\n        cnt = 1\\n        for i in range(1 , len(pressedKeys)):\\n    \\n            if pressedKeys[i] not in spes:\\n                if pressedKeys[i]== pressedKeys[i-1]:\\n                    if cnt < 3:\\n                        dp[i]= 2*dp[i-1]\\n                        cnt+=1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            else:\\n                if pressedKeys[i-1] == pressedKeys[i]:\\n                    if cnt<4:\\n                        dp[i] = dp[i-1]*2\\n                        cnt += 1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            \\n            dp[i] = dp[i]%mod\\n    \\n    \\n        return(dp[-1])\\n        \\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657619,
                "title": "simple-memoization",
                "content": "```\\nclass Solution {\\nint solve(int index, string &s){\\n    if(index==s.size()) return 1;\\n    int count=0;\\n    int limit=3;\\n    if(dp[index]!=-1) return dp[index];\\n    if(s[index]-\\'0\\'==7 || s[index]-\\'0\\'==9) limit++;\\n\\t\\n    for(int i=index;i<s.size() && i-index+1<=limit;i++){ // (i-index+1) sets the limit for the length of the consecutive same letters\\n        if(s[i]==s[index]){\\n            count=(count+solve(i+1,s))%mod;\\n        }\\n        else break;\\n    }\\n    return dp[index]= count%mod;\\n}\\n    \\n    \\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return solve(0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nint solve(int index, string &s){\\n    if(index==s.size()) return 1;\\n    int count=0;\\n    int limit=3;\\n    if(dp[index]!=-1) return dp[index];\\n    if(s[index]-\\'0\\'==7 || s[index]-\\'0\\'==9) limit++;\\n\\t\\n    for(int i=index;i<s.size() && i-index+1<=limit;i++){ // (i-index+1) sets the limit for the length of the consecutive same letters\\n        if(s[i]==s[index]){\\n            count=(count+solve(i+1,s))%mod;\\n        }\\n        else break;\\n    }\\n    return dp[index]= count%mod;\\n}\\n    \\n    \\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return solve(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599494,
                "title": "dp-solutions",
                "content": "\\n\\n# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    /* Top Down */\\n    /* int solve(int ind, string &s, vector<int> &dp) {\\n        if(ind == s.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int maxPress = (s[ind] == \\'7\\' or s[ind] == \\'9\\') ? 4 : 3;\\n        int pressed = 1, count = 0, curr = ind;\\n        while(pressed <= maxPress and s[curr] == s[ind]) {\\n            pressed++;\\n            curr++;\\n            count = (count + solve(curr, s, dp)) % mod;\\n        }\\n\\n        return dp[ind] = count % mod;\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1, -1);\\n        return solve(0, pressedKeys, dp) % mod;\\n    } */\\n\\n    /* Bottom Up */\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1);\\n        dp[n] = 1;\\n        for(int i = n - 1; i >= 0; i--) {\\n            int maxPress = pressedKeys[i] == \\'7\\' or pressedKeys[i] == \\'9\\' ? 4 : 3;\\n            int pressed = 1, curr = i, count = 0;\\n\\n            while(pressed <= maxPress and pressedKeys[curr] == pressedKeys[i]) {\\n                pressed++;\\n                curr++;\\n                count = (count + dp[curr]) % mod;\\n            }\\n\\n            dp[i] = count % mod;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    /* Top Down */\\n    /* int solve(int ind, string &s, vector<int> &dp) {\\n        if(ind == s.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int maxPress = (s[ind] == \\'7\\' or s[ind] == \\'9\\') ? 4 : 3;\\n        int pressed = 1, count = 0, curr = ind;\\n        while(pressed <= maxPress and s[curr] == s[ind]) {\\n            pressed++;\\n            curr++;\\n            count = (count + solve(curr, s, dp)) % mod;\\n        }\\n\\n        return dp[ind] = count % mod;\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1, -1);\\n        return solve(0, pressedKeys, dp) % mod;\\n    } */\\n\\n    /* Bottom Up */\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1);\\n        dp[n] = 1;\\n        for(int i = n - 1; i >= 0; i--) {\\n            int maxPress = pressedKeys[i] == \\'7\\' or pressedKeys[i] == \\'9\\' ? 4 : 3;\\n            int pressed = 1, curr = i, count = 0;\\n\\n            while(pressed <= maxPress and pressedKeys[curr] == pressedKeys[i]) {\\n                pressed++;\\n                curr++;\\n                count = (count + dp[curr]) % mod;\\n            }\\n\\n            dp[i] = count % mod;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555360,
                "title": "c-recursion-memoization-tabulation-bottom-up-dp",
                "content": "we are finding every pattern possible like for example when \\na person pressed 333\\n\\nthen the total number of patters we can take ot perceive this is,\\n\\n3,3,3\\n3,33\\n33,3\\n333\\n\\nthat is 4.\\n\\nthis is what is carried out for each char in our string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int ans(int ind,string s,vector<int> &keys,vector<int>&dp){\\n        if(ind==s.length())return 1;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int count=0;\\n        int num=s[ind]-\\'0\\';\\n        int res=keys[num];\\n\\n        for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n            count+=ans(ind+1+i,s,keys,dp);\\n            count%=mod;\\n        }\\n        return dp[ind]=count;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> keys={0,0,3,3,3,3,3,4,3,4};\\n        \\n        int n=pressedKeys.size();\\n        vector<int> dp(n+1,0);\\n        string s=pressedKeys;\\n        dp[n]=1;\\n        for(int ind=n-1;ind>=0;ind--){\\n            int count=0;\\n            int num=s[ind]-\\'0\\';\\n            int res=keys[num];\\n\\n            for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n                count+=dp[ind+1+i];\\n                count%=mod;\\n            }\\n                dp[ind]=count;\\n            }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int ans(int ind,string s,vector<int> &keys,vector<int>&dp){\\n        if(ind==s.length())return 1;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int count=0;\\n        int num=s[ind]-\\'0\\';\\n        int res=keys[num];\\n\\n        for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n            count+=ans(ind+1+i,s,keys,dp);\\n            count%=mod;\\n        }\\n        return dp[ind]=count;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> keys={0,0,3,3,3,3,3,4,3,4};\\n        \\n        int n=pressedKeys.size();\\n        vector<int> dp(n+1,0);\\n        string s=pressedKeys;\\n        dp[n]=1;\\n        for(int ind=n-1;ind>=0;ind--){\\n            int count=0;\\n            int num=s[ind]-\\'0\\';\\n            int res=keys[num];\\n\\n            for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n                count+=dp[ind+1+i];\\n                count%=mod;\\n            }\\n                dp[ind]=count;\\n            }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552473,
                "title": "simple-dart-solution",
                "content": "\\n# Approach\\nMy first solution used recursion, but no matter how I did it I would always get a stack overflow error due to too much reucrsion so I made this solution using tabulation.\\n\\n# Code\\n```\\nclass Solution {\\n  int mod = 1000000007;\\n\\n  int countTexts(String pressedKeys) {\\n    List<int> key = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4];\\n    int n = pressedKeys.length;\\n    List<int> dp = List<int>.filled(n + 1, 0);\\n    dp[n] = 1;\\n\\n    for (int ind = n - 1; ind >= 0; ind--) {\\n      int count = 0;\\n      int num = pressedKeys.codeUnitAt(ind) - \\'0\\'.codeUnitAt(0);\\n      int rep = key[num];\\n      for (int i = 0; i < rep && ind + i < pressedKeys.length && pressedKeys[ind] == pressedKeys[ind + i]; i++) {\\n        count += dp[ind + i + 1];\\n        count %= mod;\\n      }\\n      dp[ind] = count;\\n    }\\n    return dp[0];\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int mod = 1000000007;\\n\\n  int countTexts(String pressedKeys) {\\n    List<int> key = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4];\\n    int n = pressedKeys.length;\\n    List<int> dp = List<int>.filled(n + 1, 0);\\n    dp[n] = 1;\\n\\n    for (int ind = n - 1; ind >= 0; ind--) {\\n      int count = 0;\\n      int num = pressedKeys.codeUnitAt(ind) - \\'0\\'.codeUnitAt(0);\\n      int rep = key[num];\\n      for (int i = 0; i < rep && ind + i < pressedKeys.length && pressedKeys[ind] == pressedKeys[ind + i]; i++) {\\n        count += dp[ind + i + 1];\\n        count %= mod;\\n      }\\n      dp[ind] = count;\\n    }\\n    return dp[0];\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520900,
                "title": "dp-memoization-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    long mod = (long)1e9+7;\\n    long[] dp = new long[100001];\\n    public long helper(String s,int idx,long[] dp){\\n        if(idx>=s.length()) return 1;\\n        if(dp[idx]!=-1) return dp[idx];\\n        long ans = 0;\\n            ans += (helper(s,idx+1,dp)%mod);\\n            if(idx+1<s.length() && s.charAt(idx)==s.charAt(idx+1)) ans += (helper(s,idx+2,dp)%mod);\\n            if(idx+2<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1)) ans += (helper(s,idx+3,dp)%mod);\\n            if(s.charAt(idx)==\\'7\\' || s.charAt(idx)==\\'9\\'){\\n    if(idx+3<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+3)) ans += (helper(s,idx+4,dp)%mod);\\n            }\\n        ans %= mod;\\n        return dp[idx]=ans;\\n    }\\n    public int countTexts(String pressedKeys) {\\n        Arrays.fill(dp,-1);\\n        return (int)helper(pressedKeys,0,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long mod = (long)1e9+7;\\n    long[] dp = new long[100001];\\n    public long helper(String s,int idx,long[] dp){\\n        if(idx>=s.length()) return 1;\\n        if(dp[idx]!=-1) return dp[idx];\\n        long ans = 0;\\n            ans += (helper(s,idx+1,dp)%mod);\\n            if(idx+1<s.length() && s.charAt(idx)==s.charAt(idx+1)) ans += (helper(s,idx+2,dp)%mod);\\n            if(idx+2<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1)) ans += (helper(s,idx+3,dp)%mod);\\n            if(s.charAt(idx)==\\'7\\' || s.charAt(idx)==\\'9\\'){\\n    if(idx+3<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+3)) ans += (helper(s,idx+4,dp)%mod);\\n            }\\n        ans %= mod;\\n        return dp[idx]=ans;\\n    }\\n    public int countTexts(String pressedKeys) {\\n        Arrays.fill(dp,-1);\\n        return (int)helper(pressedKeys,0,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436420,
                "title": "o-n-solution-beats-100-time",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        frequency_map = self.get_frequency_map(pressedKeys)\\n        tribo_max, quadro_max = self.get_max_tribo_an_quadro(frequency_map)\\n        tribos = self.get_all_tribos(tribo_max+1)\\n        quadros = self.get_all_quadros(quadro_max+1)\\n        combinations = self.get_all_combinations(tribos, quadros, frequency_map)\\n        return combinations\\n    \\n    def get_frequency_map(self, pressedKeys):\\n        frequency_map = []\\n        index = 0\\n        while index < len(pressedKeys):\\n            curr_char = pressedKeys[index]\\n            curr_count = 0\\n            while index < len(pressedKeys) and pressedKeys[index] == curr_char:\\n                curr_count+=1\\n                index+=1\\n            frequency_map.append([ord(curr_char)-ord(\\'0\\'), curr_count])\\n        \\n        return frequency_map\\n    \\n    def get_max_tribo_an_quadro(self, frequency_map):\\n        tribo_max = 3\\n        quadro_max = 4\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                tribo_max = max(tribo_max, freq)\\n            else:\\n               quadro_max = max(quadro_max, freq)\\n        return tribo_max, quadro_max\\n    \\n    def get_all_tribos(self, n):\\n        tribos = [0]*n\\n        tribos[0]=1\\n        tribos[1]=1\\n        tribos[2]=2\\n        for index in range(3, n):\\n            tribos[index] = self.add_all([tribos[index - 1],tribos[index - 2],tribos[index - 3]])\\n        return tribos\\n    \\n    def get_all_quadros(self, n):\\n        quadros=[0]*n\\n        quadros[0]=1\\n        quadros[1]=1\\n        quadros[2]=2\\n        quadros[3]=4\\n        for index in range(4, n):\\n            quadros[index] = self.add_all([quadros[index - 1],quadros[index - 2],quadros[index - 3],quadros[index - 4]])\\n        return quadros\\n    \\n    def get_all_combinations(self, tribos, quadros, frequency_map):\\n        combinations = 1\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                count = tribos[freq]\\n            else:\\n                count = quadros[freq]\\n            combinations = (combinations * count)%(1000000007)\\n        return combinations\\n\\n    \\n    def add_all(self, numbers):\\n        result = 0\\n        for num in numbers:\\n            result = (result + num)%(1000000007)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        frequency_map = self.get_frequency_map(pressedKeys)\\n        tribo_max, quadro_max = self.get_max_tribo_an_quadro(frequency_map)\\n        tribos = self.get_all_tribos(tribo_max+1)\\n        quadros = self.get_all_quadros(quadro_max+1)\\n        combinations = self.get_all_combinations(tribos, quadros, frequency_map)\\n        return combinations\\n    \\n    def get_frequency_map(self, pressedKeys):\\n        frequency_map = []\\n        index = 0\\n        while index < len(pressedKeys):\\n            curr_char = pressedKeys[index]\\n            curr_count = 0\\n            while index < len(pressedKeys) and pressedKeys[index] == curr_char:\\n                curr_count+=1\\n                index+=1\\n            frequency_map.append([ord(curr_char)-ord(\\'0\\'), curr_count])\\n        \\n        return frequency_map\\n    \\n    def get_max_tribo_an_quadro(self, frequency_map):\\n        tribo_max = 3\\n        quadro_max = 4\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                tribo_max = max(tribo_max, freq)\\n            else:\\n               quadro_max = max(quadro_max, freq)\\n        return tribo_max, quadro_max\\n    \\n    def get_all_tribos(self, n):\\n        tribos = [0]*n\\n        tribos[0]=1\\n        tribos[1]=1\\n        tribos[2]=2\\n        for index in range(3, n):\\n            tribos[index] = self.add_all([tribos[index - 1],tribos[index - 2],tribos[index - 3]])\\n        return tribos\\n    \\n    def get_all_quadros(self, n):\\n        quadros=[0]*n\\n        quadros[0]=1\\n        quadros[1]=1\\n        quadros[2]=2\\n        quadros[3]=4\\n        for index in range(4, n):\\n            quadros[index] = self.add_all([quadros[index - 1],quadros[index - 2],quadros[index - 3],quadros[index - 4]])\\n        return quadros\\n    \\n    def get_all_combinations(self, tribos, quadros, frequency_map):\\n        combinations = 1\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                count = tribos[freq]\\n            else:\\n                count = quadros[freq]\\n            combinations = (combinations * count)%(1000000007)\\n        return combinations\\n\\n    \\n    def add_all(self, numbers):\\n        result = 0\\n        for num in numbers:\\n            result = (result + num)%(1000000007)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395306,
                "title": "python-easy-dp",
                "content": "\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        mod, i, res = 10**9 + 7, 0, 1\\n        def solveDp(n: int, x: int):\\n            nonlocal mod\\n            dp = [0 for _ in range(n + 1)]\\n            dp[0] = 1\\n            for i in range(1, n + 1):\\n                for j in range(x):\\n                    if i - j - 1 >= 0:\\n                        dp[i] = (dp[i] + dp[i - j - 1])%mod\\n            return dp[-1]\\n        mp = {\\'2\\': 3, \\'3\\':3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        while i < len(pressedKeys):\\n            j = i + 1\\n            while j < len(pressedKeys) and pressedKeys[i] == pressedKeys[j]: j+=1\\n            res = (res * (solveDp(j - i, mp[pressedKeys[i]])))%mod\\n            i = j\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        mod, i, res = 10**9 + 7, 0, 1\\n        def solveDp(n: int, x: int):\\n            nonlocal mod\\n            dp = [0 for _ in range(n + 1)]\\n            dp[0] = 1\\n            for i in range(1, n + 1):\\n                for j in range(x):\\n                    if i - j - 1 >= 0:\\n                        dp[i] = (dp[i] + dp[i - j - 1])%mod\\n            return dp[-1]\\n        mp = {\\'2\\': 3, \\'3\\':3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        while i < len(pressedKeys):\\n            j = i + 1\\n            while j < len(pressedKeys) and pressedKeys[i] == pressedKeys[j]: j+=1\\n            res = (res * (solveDp(j - i, mp[pressedKeys[i]])))%mod\\n            i = j\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389029,
                "title": "simple-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    long long mod = 1e9+7;\\n    int f(string &s,int ind,int n){\\n\\n        if(ind==n){\\n            return 1;\\n        }\\n\\n        if(ind>n) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind]%mod;\\n\\n        if(s[ind]==\\'7\\' or s[ind]==\\'9\\'){\\n            long long ans = 0;\\n            for(int i = ind;i<ind+4;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n        else{\\n            long long ans = 0;\\n            for(int i = ind;i<ind+3;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n    }\\n\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return f(s,0,s.size())%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    long long mod = 1e9+7;\\n    int f(string &s,int ind,int n){\\n\\n        if(ind==n){\\n            return 1;\\n        }\\n\\n        if(ind>n) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind]%mod;\\n\\n        if(s[ind]==\\'7\\' or s[ind]==\\'9\\'){\\n            long long ans = 0;\\n            for(int i = ind;i<ind+4;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n        else{\\n            long long ans = 0;\\n            for(int i = ind;i<ind+3;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n    }\\n\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return f(s,0,s.size())%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385783,
                "title": "python-dp",
                "content": "```\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        DP = [0] * (len(pressedKeys)+1)\\n        DP[0] = 1\\n        for i in range(1, len(DP)):\\n            DP[i] = DP[i-1]\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                DP[i] += DP[i-2]\\n                DP[i] %= (10**9 + 7)\\n                if i > 2 and pressedKeys[i-1] == pressedKeys[i-3]:\\n                    DP[i] += DP[i-3]                     \\n                    DP[i] %= (10**9 + 7)     \\n                    if i > 3 and pressedKeys[i-1] in [\\'7\\', \\'9\\'] and pressedKeys[i-1] == pressedKeys[i-4]:\\n                        DP[i] += DP[i-4]\\n                        DP[i] %= (10**9 + 7)\\n        return DP[-1]\\n\\n\"\"\"\\n# Memoization and combinatorics\\n\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\'2\\':3,\\'3\\':3,\\'4\\':3,\\'5\\':3,\\'6\\':3,\\'7\\':4,\\'8\\':3,\\'9\\':4}\\n    \\n        cache = dict()\\n        def cache_count(v, i):\\n            if i < 0:\\n                return 0\\n            if i == 0:\\n                return 1\\n\\n            if (v, i) in cache:\\n                return cache[(v, i)]\\n            \\n            cache[(v, i)] = sum(cache_count(v, i-j) for j in range(1, v+1))\\n            return cache[(v, i)]\\n\\n        t = 1\\n\\n        c = pressedKeys[0]\\n        l = 1\\n        for k in pressedKeys[1:]:\\n            if k == c:\\n                l += 1\\n            else:     \\n                t *= cache_count(d[c],l)\\n                t %= (10**9 + 7)\\n                l = 1\\n                c = k\\n        t *= cache_count(d[c],l)\\n        t %= (10**9 + 7)\\n        return t\\n\"\"\"\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        DP = [0] * (len(pressedKeys)+1)\\n        DP[0] = 1\\n        for i in range(1, len(DP)):\\n            DP[i] = DP[i-1]\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                DP[i] += DP[i-2]\\n                DP[i] %= (10**9 + 7)\\n                if i > 2 and pressedKeys[i-1] == pressedKeys[i-3]:\\n                    DP[i] += DP[i-3]                     \\n                    DP[i] %= (10**9 + 7)     \\n                    if i > 3 and pressedKeys[i-1] in [\\'7\\', \\'9\\'] and pressedKeys[i-1] == pressedKeys[i-4]:\\n                        DP[i] += DP[i-4]\\n                        DP[i] %= (10**9 + 7)\\n        return DP[-1]\\n\\n\"\"\"\\n# Memoization and combinatorics\\n\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\'2\\':3,\\'3\\':3,\\'4\\':3,\\'5\\':3,\\'6\\':3,\\'7\\':4,\\'8\\':3,\\'9\\':4}\\n    \\n        cache = dict()\\n        def cache_count(v, i):\\n            if i < 0:\\n                return 0\\n            if i == 0:\\n                return 1\\n\\n            if (v, i) in cache:\\n                return cache[(v, i)]\\n            \\n            cache[(v, i)] = sum(cache_count(v, i-j) for j in range(1, v+1))\\n            return cache[(v, i)]\\n\\n        t = 1\\n\\n        c = pressedKeys[0]\\n        l = 1\\n        for k in pressedKeys[1:]:\\n            if k == c:\\n                l += 1\\n            else:     \\n                t *= cache_count(d[c],l)\\n                t %= (10**9 + 7)\\n                l = 1\\n                c = k\\n        t *= cache_count(d[c],l)\\n        t %= (10**9 + 7)\\n        return t\\n\"\"\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374672,
                "title": "pam-parar",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} pressedKeys\\n * @return {number}\\n */\\nfunction countTexts (pressedKeys) {\\n   const strLength = pressedKeys.length;\\n   const bigInt = 10 ** 9 + 7;\\n   const fibonacci = new Array(strLength + 1).fill(0);\\n   fibonacci[0] = 1;\\n   \\n   let last = 0;\\n   let count = 0;\\n   \\n   for (let i = 1; i <= strLength; ++i) {\\n      const currient = pressedKeys[i - 1];\\n      \\n      if (currient !== last) count = 0;\\n      \\n      last = currient;\\n      count += 1;\\n      \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 1]) % bigInt;\\n      \\n      if (i >= 2 && count >= 2) fibonacci[i] = (fibonacci[i] + fibonacci[i - 2]) % bigInt;\\n      if (i >= 3 && count >= 3) fibonacci[i] = (fibonacci[i] + fibonacci[i - 3]) % bigInt;\\n      if ((currient == \"7\"  || currient == \"9\") && i >= 4 && count >= 4) \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 4]) % bigInt;\\n   }\\n\\n   return fibonacci[strLength];\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} pressedKeys\\n * @return {number}\\n */\\nfunction countTexts (pressedKeys) {\\n   const strLength = pressedKeys.length;\\n   const bigInt = 10 ** 9 + 7;\\n   const fibonacci = new Array(strLength + 1).fill(0);\\n   fibonacci[0] = 1;\\n   \\n   let last = 0;\\n   let count = 0;\\n   \\n   for (let i = 1; i <= strLength; ++i) {\\n      const currient = pressedKeys[i - 1];\\n      \\n      if (currient !== last) count = 0;\\n      \\n      last = currient;\\n      count += 1;\\n      \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 1]) % bigInt;\\n      \\n      if (i >= 2 && count >= 2) fibonacci[i] = (fibonacci[i] + fibonacci[i - 2]) % bigInt;\\n      if (i >= 3 && count >= 3) fibonacci[i] = (fibonacci[i] + fibonacci[i - 3]) % bigInt;\\n      if ((currient == \"7\"  || currient == \"9\") && i >= 4 && count >= 4) \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 4]) % bigInt;\\n   }\\n\\n   return fibonacci[strLength];\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3373550,
                "title": "a-brute-weird-solution-c-memoization",
                "content": "```\\nclass Solution\\n{\\n    const int M = 1e9 + 7;\\n    long long help(string &s, int cur, map<string, char> &mp, vector<int> &dp)\\n    {\\n        if (cur >= s.length()) return 1;\\n\\n        long long one = 0, two = 0, three = 0, four = 0;\\n\\n        if (dp[cur] != -1) return dp[cur];\\n\\n        if (cur < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            if (mp.find(temp) != mp.end())\\n            {\\n                one = help(s, cur + 1, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 1 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                two = help(s, cur + 2, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 2 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                three = help(s, cur + 3, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 3 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n            temp.push_back(s[cur + 3]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                four = help(s, cur + 4, mp, dp) % M;\\n            }\\n        }\\n        return dp[cur] = (one + two + three + four) % M;\\n    }\\n\\n    public:\\n        int countTexts(string s)\\n        {\\n            map<string, char> mp;\\n            mp[\"2\"] = \\'a\\';\\n            mp[\"22\"] = \\'b\\';\\n            mp[\"222\"] = \\'c\\';\\n            mp[\"3\"] = \\'d\\';\\n            mp[\"33\"] = \\'e\\';\\n            mp[\"333\"] = \\'f\\';\\n            mp[\"4\"] = \\'g\\';\\n            mp[\"44\"] = \\'h\\';\\n            mp[\"444\"] = \\'i\\';\\n            mp[\"5\"] = \\'j\\';\\n            mp[\"55\"] = \\'k\\';\\n            mp[\"555\"] = \\'l\\';\\n            mp[\"6\"] = \\'m\\';\\n            mp[\"66\"] = \\'n\\';\\n            mp[\"666\"] = \\'o\\';\\n            mp[\"7\"] = \\'p\\';\\n            mp[\"77\"] = \\'q\\';\\n            mp[\"777\"] = \\'r\\';\\n            mp[\"7777\"] = \\'s\\';\\n            mp[\"8\"] = \\'t\\';\\n            mp[\"88\"] = \\'u\\';\\n            mp[\"888\"] = \\'v\\';\\n            mp[\"9\"] = \\'w\\';\\n            mp[\"99\"] = \\'x\\';\\n            mp[\"999\"] = \\'y\\';\\n            mp[\"9999\"] = \\'z\\';\\n\\n            int n = s.length();\\n            vector<int> dp(n, -1);\\n            return help(s, 0, mp, dp);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    const int M = 1e9 + 7;\\n    long long help(string &s, int cur, map<string, char> &mp, vector<int> &dp)\\n    {\\n        if (cur >= s.length()) return 1;\\n\\n        long long one = 0, two = 0, three = 0, four = 0;\\n\\n        if (dp[cur] != -1) return dp[cur];\\n\\n        if (cur < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            if (mp.find(temp) != mp.end())\\n            {\\n                one = help(s, cur + 1, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 1 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                two = help(s, cur + 2, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 2 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                three = help(s, cur + 3, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 3 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n            temp.push_back(s[cur + 3]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                four = help(s, cur + 4, mp, dp) % M;\\n            }\\n        }\\n        return dp[cur] = (one + two + three + four) % M;\\n    }\\n\\n    public:\\n        int countTexts(string s)\\n        {\\n            map<string, char> mp;\\n            mp[\"2\"] = \\'a\\';\\n            mp[\"22\"] = \\'b\\';\\n            mp[\"222\"] = \\'c\\';\\n            mp[\"3\"] = \\'d\\';\\n            mp[\"33\"] = \\'e\\';\\n            mp[\"333\"] = \\'f\\';\\n            mp[\"4\"] = \\'g\\';\\n            mp[\"44\"] = \\'h\\';\\n            mp[\"444\"] = \\'i\\';\\n            mp[\"5\"] = \\'j\\';\\n            mp[\"55\"] = \\'k\\';\\n            mp[\"555\"] = \\'l\\';\\n            mp[\"6\"] = \\'m\\';\\n            mp[\"66\"] = \\'n\\';\\n            mp[\"666\"] = \\'o\\';\\n            mp[\"7\"] = \\'p\\';\\n            mp[\"77\"] = \\'q\\';\\n            mp[\"777\"] = \\'r\\';\\n            mp[\"7777\"] = \\'s\\';\\n            mp[\"8\"] = \\'t\\';\\n            mp[\"88\"] = \\'u\\';\\n            mp[\"888\"] = \\'v\\';\\n            mp[\"9\"] = \\'w\\';\\n            mp[\"99\"] = \\'x\\';\\n            mp[\"999\"] = \\'y\\';\\n            mp[\"9999\"] = \\'z\\';\\n\\n            int n = s.length();\\n            vector<int> dp(n, -1);\\n            return help(s, 0, mp, dp);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345505,
                "title": "c-golang-dp",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    const int mod = 1e9 + 7; \\npublic:\\n    int countTexts(string pressedKeys) {\\n        int j, n = pressedKeys.size();\\n        vector<int> DP(n, 1);\\n        long long ans = 1;\\n        for(int i = 0; i < n; i = j) {\\n            for(j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++) {\\n                if(j - i == 1) {\\n                    DP[j] = 2; continue;\\n                } else if(j - i == 2) {\\n                    DP[j] = 4; continue;\\n                }\\n                DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod;\\n                if(pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\') {\\n                    if(j - i == 3) {\\n                        DP[j] = 8; continue;\\n                    }\\n                    DP[j] = (DP[j] + DP[j - 4]) % mod;\\n                }\\n            }\\n            ans = (ans * DP[j - 1]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nconst mod int = 1e9 + 7\\nfunc countTexts(pressedKeys string) int {\\n    var j, n int = 1, len(pressedKeys)\\n    DP := make([]int, n)\\n    var ans int = 1\\n    for i := 0; i < n; i = j {\\n        DP[i] = 1\\n        for j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++ {\\n            if j - i == 1 {\\n                DP[j] = 2\\n                continue\\n            } else if j - i == 2 {\\n                DP[j] = 4 \\n                continue\\n            }\\n            DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod\\n            if pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\' {\\n                if j - i == 3 {\\n                    DP[j] = 8\\n                    continue\\n                }\\n                DP[j] = (DP[j] + DP[j - 4]) % mod\\n            }\\n        }\\n        ans = (ans * DP[j - 1]) % mod\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    const int mod = 1e9 + 7; \\npublic:\\n    int countTexts(string pressedKeys) {\\n        int j, n = pressedKeys.size();\\n        vector<int> DP(n, 1);\\n        long long ans = 1;\\n        for(int i = 0; i < n; i = j) {\\n            for(j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++) {\\n                if(j - i == 1) {\\n                    DP[j] = 2; continue;\\n                } else if(j - i == 2) {\\n                    DP[j] = 4; continue;\\n                }\\n                DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod;\\n                if(pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\') {\\n                    if(j - i == 3) {\\n                        DP[j] = 8; continue;\\n                    }\\n                    DP[j] = (DP[j] + DP[j - 4]) % mod;\\n                }\\n            }\\n            ans = (ans * DP[j - 1]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nconst mod int = 1e9 + 7\\nfunc countTexts(pressedKeys string) int {\\n    var j, n int = 1, len(pressedKeys)\\n    DP := make([]int, n)\\n    var ans int = 1\\n    for i := 0; i < n; i = j {\\n        DP[i] = 1\\n        for j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++ {\\n            if j - i == 1 {\\n                DP[j] = 2\\n                continue\\n            } else if j - i == 2 {\\n                DP[j] = 4 \\n                continue\\n            }\\n            DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod\\n            if pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\' {\\n                if j - i == 3 {\\n                    DP[j] = 8\\n                    continue\\n                }\\n                DP[j] = (DP[j] + DP[j - 4]) % mod\\n            }\\n        }\\n        ans = (ans * DP[j - 1]) % mod\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333515,
                "title": "easy-dp-approach-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)+extra stack space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(string &s,int index,vector<int> &dp)\\n    {\\n        if(index>=s.length()){\\n            return 1;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        long long ans=0;\\n        //case 1\\n        ans=ans+solve(s,index+1,dp);\\n\\n        //case 2\\n        if(index+1<s.length()){\\n            if(s[index]==s[index+1]){\\n                ans=ans+solve(s,index+2,dp);\\n            }\\n        }\\n\\n        //case 3\\n        if(index+2<s.length()){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])){\\n                ans=ans+solve(s,index+3,dp);\\n            }\\n        }\\n\\n        //case 4\\n        if(index+3<s.length() &&(s[index]==\\'7\\' || s[index]==\\'9\\')){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])&&(s[index]==s[index+3])){\\n                ans=ans+solve(s,index+4,dp);\\n            }\\n        }\\n        return dp[index]=ans%mod;\\n    }\\n    int countTexts(string s) \\n    {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(string &s,int index,vector<int> &dp)\\n    {\\n        if(index>=s.length()){\\n            return 1;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        long long ans=0;\\n        //case 1\\n        ans=ans+solve(s,index+1,dp);\\n\\n        //case 2\\n        if(index+1<s.length()){\\n            if(s[index]==s[index+1]){\\n                ans=ans+solve(s,index+2,dp);\\n            }\\n        }\\n\\n        //case 3\\n        if(index+2<s.length()){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])){\\n                ans=ans+solve(s,index+3,dp);\\n            }\\n        }\\n\\n        //case 4\\n        if(index+3<s.length() &&(s[index]==\\'7\\' || s[index]==\\'9\\')){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])&&(s[index]==s[index+3])){\\n                ans=ans+solve(s,index+4,dp);\\n            }\\n        }\\n        return dp[index]=ans%mod;\\n    }\\n    int countTexts(string s) \\n    {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268843,
                "title": "c-easy-solution-using-dp-and-memoization",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //using dp and memoization\\n    //partition and not partition variation\\n    //TC=O(N)\\n    //SC=O(N)+O(stack space)\\n    int mod=1e9+7;\\n    int find(int i,int c,string& s,vector<vector<int>>& dp,int n){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(dp[i][c]!=-1){\\n            return dp[i][c]%mod;\\n        }\\n        int ways=0;\\n        if((s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(i+1<n && (s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        if(i+1<n && s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        return dp[i][c]=ways%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        vector<vector<int>> dp(n,vector<int>(6,-1));\\n        return find(0,0,pressedKeys,dp,n);\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //using dp and memoization\\n    //partition and not partition variation\\n    //TC=O(N)\\n    //SC=O(N)+O(stack space)\\n    int mod=1e9+7;\\n    int find(int i,int c,string& s,vector<vector<int>>& dp,int n){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(dp[i][c]!=-1){\\n            return dp[i][c]%mod;\\n        }\\n        int ways=0;\\n        if((s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(i+1<n && (s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        if(i+1<n && s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        return dp[i][c]=ways%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        vector<vector<int>> dp(n,vector<int>(6,-1));\\n        return find(0,0,pressedKeys,dp,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262905,
                "title": "recursion-memoization-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int mod=1e9+7;\\n    int dp[100005][5];\\n    int f(int count, int maxGrouping)\\n    {\\n        if(count==0) return 1;\\n        if(count<0) return 0;\\n        if(dp[count][maxGrouping]!=-1) return dp[count][maxGrouping];\\n        int ans=0;\\n        for(int x=1; x<=min(count,maxGrouping); x++)\\n        {\\n            ans=(ans%mod+f(count-x,maxGrouping)%mod)%mod;\\n        }\\n        return dp[count][maxGrouping]=ans%mod;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        map<int,int> m;\\n        int ans=1;\\n        m[2]=3; m[3]=3; m[4]=3; m[5]=3; m[6]=3; m[7]=4; m[8]=3; m[9]=4;\\n        int n=pressedKeys.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            int i=x+1;\\n            int count=1;\\n            while(i<n && pressedKeys[x]==pressedKeys[i])\\n            {\\n                i++; count++;\\n            }\\n            ans=((long long)ans%mod*f(count,m[pressedKeys[x]-48])%mod)%mod;\\n            x=i-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int mod=1e9+7;\\n    int dp[100005][5];\\n    int f(int count, int maxGrouping)\\n    {\\n        if(count==0) return 1;\\n        if(count<0) return 0;\\n        if(dp[count][maxGrouping]!=-1) return dp[count][maxGrouping];\\n        int ans=0;\\n        for(int x=1; x<=min(count,maxGrouping); x++)\\n        {\\n            ans=(ans%mod+f(count-x,maxGrouping)%mod)%mod;\\n        }\\n        return dp[count][maxGrouping]=ans%mod;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        map<int,int> m;\\n        int ans=1;\\n        m[2]=3; m[3]=3; m[4]=3; m[5]=3; m[6]=3; m[7]=4; m[8]=3; m[9]=4;\\n        int n=pressedKeys.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            int i=x+1;\\n            int count=1;\\n            while(i<n && pressedKeys[x]==pressedKeys[i])\\n            {\\n                i++; count++;\\n            }\\n            ans=((long long)ans%mod*f(count,m[pressedKeys[x]-48])%mod)%mod;\\n            x=i-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210334,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const unsigned int M = pow(10,9)+7; \\n    void dpf(string& pressedKeys, int curr, vector<int>& dp){\\n        char t = pressedKeys[curr];\\n        int num;\\n        if(t==\\'7\\'|| t==\\'9\\') num = 4;\\n        else num=3; \\n        for(int i = curr; i<dp.size() && i-curr<num && pressedKeys[i]==t; i++){\\n            if(i+1<dp.size()) dp[curr] = (dp[curr]+dp[i+1])%M; \\n            else dp[curr] = (dp[curr]+1)%M; \\n        }\\n    }\\n    int countTexts(string pressedKeys) {\\n        //dp   \\n        int len = pressedKeys.length(); \\n        vector<int> dp(len, 0);\\n        dp[len-1] = 1; \\n        for(int i = len-2; i >=0; i--)\\n            dpf(pressedKeys, i, dp); \\n        return dp[0]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const unsigned int M = pow(10,9)+7; \\n    void dpf(string& pressedKeys, int curr, vector<int>& dp){\\n        char t = pressedKeys[curr];\\n        int num;\\n        if(t==\\'7\\'|| t==\\'9\\') num = 4;\\n        else num=3; \\n        for(int i = curr; i<dp.size() && i-curr<num && pressedKeys[i]==t; i++){\\n            if(i+1<dp.size()) dp[curr] = (dp[curr]+dp[i+1])%M; \\n            else dp[curr] = (dp[curr]+1)%M; \\n        }\\n    }\\n    int countTexts(string pressedKeys) {\\n        //dp   \\n        int len = pressedKeys.length(); \\n        vector<int> dp(len, 0);\\n        dp[len-1] = 1; \\n        for(int i = len-2; i >=0; i--)\\n            dpf(pressedKeys, i, dp); \\n        return dp[0]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173333,
                "title": "bottom-up-dp-python-o-n-image-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith each new press is a potential double, triple, quad grouping (aka potential letter) that could be appended. \\n\\nLook back at the previous DP solution ***before that grouping (or letter) was considered*** and add to current DP[i].\\n![image.png](https://assets.leetcode.com/users/images/a8eb9f79-7d9e-4f10-88f4-be58d63eb63f_1676143680.0307488.png)\\n\\nie. \\n   7777\\n\\n   When adding that i=3 char 7, we open the possibility to append the following (4) letters to the path:\\n   - Adding P (+7) to series: DP[i-1] \\n   - Adding Q (+77) to series: DP[i-2]\\n   - Adding R (+777) to series: DP[i-3]\\n   - Adding S (+7777) to series: DP[i-4]\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuilding up the solution (tabulation), we\\'ll consider any potential letters formed when adding the latest button press.\\n\\nThe subproblem we\\'ll choose is this:\\n\\n> DP[i] = number of pathways up to AND including the i-th button press\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - run through array once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - storing DP state \\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n\\n\\n        s = pressedKeys\\n\\n        n = len(pressedKeys)\\n        \\n        DP = [0] * (n+1)\\n        if n ==1 :\\n            return 1\\n\\n        DP[0] = 1\\n        offset = 1 # offset b/c DP[i] refers to s[i-1]\\n        for i in range(1,len(DP)):\\n            # single unique character press\\n            DP[i] = DP[i-1]\\n                    \\n            # char double press\\n            if s[i-offset] == s[i-offset-1]:\\n                DP[i] += DP[i-2]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # triple press\\n            if i> 2 and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2]:\\n                DP[i] += DP[i-3]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # quad press of the button\\n            if i>3 and (s[i-offset] == \"7\" or s[i-offset]==\"9\") and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2] and s[i-offset-2] == s[i-offset-3]:\\n                DP[i] += DP[i-4] \\n                DP[i] = (DP[i] % (10**9 + 7))\\n\\n        print(DP)\\n\\n        return DP[n] % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n\\n\\n        s = pressedKeys\\n\\n        n = len(pressedKeys)\\n        \\n        DP = [0] * (n+1)\\n        if n ==1 :\\n            return 1\\n\\n        DP[0] = 1\\n        offset = 1 # offset b/c DP[i] refers to s[i-1]\\n        for i in range(1,len(DP)):\\n            # single unique character press\\n            DP[i] = DP[i-1]\\n                    \\n            # char double press\\n            if s[i-offset] == s[i-offset-1]:\\n                DP[i] += DP[i-2]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # triple press\\n            if i> 2 and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2]:\\n                DP[i] += DP[i-3]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # quad press of the button\\n            if i>3 and (s[i-offset] == \"7\" or s[i-offset]==\"9\") and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2] and s[i-offset-2] == s[i-offset-3]:\\n                DP[i] += DP[i-4] \\n                DP[i] = (DP[i] % (10**9 + 7))\\n\\n        print(DP)\\n\\n        return DP[n] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141053,
                "title": "tribonacci-and-quad-fibonacci-python-solution",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        res = 1\\n        \\n        @cache\\n        def dp3(i):\\n            prev_1, prev_2, curr = 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, curr = prev_2, curr, curr+prev_1+prev_2\\n                \\n            return curr\\n        \\n        @cache\\n        def dp4(i):\\n            prev_1, prev_2, prev_3, curr = 0, 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, prev_3, curr = prev_2, prev_3, curr, prev_1 + prev_2 + prev_3 + curr\\n                \\n            return curr\\n                \\n        for k,v in groupby(pressedKeys):\\n            if k == \\'7\\' or k == \\'9\\': \\n                res *= dp4(sum(1 for _ in v))\\n            else:\\n                res *= dp3(sum(1 for _ in v))\\n            \\n        return res%(1000000007)        \\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        res = 1\\n        \\n        @cache\\n        def dp3(i):\\n            prev_1, prev_2, curr = 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, curr = prev_2, curr, curr+prev_1+prev_2\\n                \\n            return curr\\n        \\n        @cache\\n        def dp4(i):\\n            prev_1, prev_2, prev_3, curr = 0, 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, prev_3, curr = prev_2, prev_3, curr, prev_1 + prev_2 + prev_3 + curr\\n                \\n            return curr\\n                \\n        for k,v in groupby(pressedKeys):\\n            if k == \\'7\\' or k == \\'9\\': \\n                res *= dp4(sum(1 for _ in v))\\n            else:\\n                res *= dp3(sum(1 for _ in v))\\n            \\n        return res%(1000000007)        \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3130372,
                "title": "based-on-climbing-stairs-dp-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   long  climbingStairs3(int n){\\n       if(n == 0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       for(int i=3; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007) + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007);\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n   long  climbingStairs4(int n){\\n       if(n==0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       if(n == 4) return 8;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       dp[3] = 8;\\n       for(int i=4; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007)  + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007) + (dp[i-4] % 1000000007 );\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n    int countTexts(string pressedKeys) {\\n        if(pressedKeys.size() == 0) return 0;\\n        if(pressedKeys.size() == 1) return 1;\\n        unordered_map<char, vector<int>> m;\\n        int counter = 0;\\n        int prev = pressedKeys[0];\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            while(pressedKeys[i] == prev){\\n                counter++;\\n                i++;\\n            }\\n            m[prev].push_back(counter);\\n            prev = pressedKeys[i];\\n            counter = 0;\\n            i--;\\n        }\\n        \\n        long  ans = 1;\\n\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            if(m[pressedKeys[i]].size() > 0){\\n                for(int j=0; j<m[pressedKeys[i]].size(); j++){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(m[pressedKeys[i]][j]);\\n                else\\n                 ans = ans*climbingStairs3(m[pressedKeys[i]][j]);\\n                 ans = ans%1000000007;\\n            }\\n                \\n                m.erase(pressedKeys[i]);\\n            }\\n        }\\n        /*for(int i=0; i<pressedKeys.size(); i++){\\n            if(map[pressedKeys[i]] > 0){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(map[pressedKeys[i]]);\\n                else\\n                 ans = ans*climbingStairs3(map[pressedKeys[i]]);\\n                ans = ans%1000000007;\\n                map[pressedKeys[i]] = 0;\\n            }\\n        }*/\\n        return ans % 1000000007;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   long  climbingStairs3(int n){\\n       if(n == 0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       for(int i=3; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007) + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007);\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n   long  climbingStairs4(int n){\\n       if(n==0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       if(n == 4) return 8;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       dp[3] = 8;\\n       for(int i=4; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007)  + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007) + (dp[i-4] % 1000000007 );\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n    int countTexts(string pressedKeys) {\\n        if(pressedKeys.size() == 0) return 0;\\n        if(pressedKeys.size() == 1) return 1;\\n        unordered_map<char, vector<int>> m;\\n        int counter = 0;\\n        int prev = pressedKeys[0];\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            while(pressedKeys[i] == prev){\\n                counter++;\\n                i++;\\n            }\\n            m[prev].push_back(counter);\\n            prev = pressedKeys[i];\\n            counter = 0;\\n            i--;\\n        }\\n        \\n        long  ans = 1;\\n\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            if(m[pressedKeys[i]].size() > 0){\\n                for(int j=0; j<m[pressedKeys[i]].size(); j++){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(m[pressedKeys[i]][j]);\\n                else\\n                 ans = ans*climbingStairs3(m[pressedKeys[i]][j]);\\n                 ans = ans%1000000007;\\n            }\\n                \\n                m.erase(pressedKeys[i]);\\n            }\\n        }\\n        /*for(int i=0; i<pressedKeys.size(); i++){\\n            if(map[pressedKeys[i]] > 0){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(map[pressedKeys[i]]);\\n                else\\n                 ans = ans*climbingStairs3(map[pressedKeys[i]]);\\n                ans = ans%1000000007;\\n                map[pressedKeys[i]] = 0;\\n            }\\n        }*/\\n        return ans % 1000000007;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126727,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        int mod=1e9+7;\\n        vector<int>dp(n+1);\\n        dp[0]=1;\\n        for (int i=1;i<=n;i++)\\n        {\\n            char ch=pressedKeys[i-1];\\n            dp[i]=dp[i-1];\\n            if (i>=2 && pressedKeys[i-2]==ch)\\n            dp[i]=(dp[i-2]+dp[i])%mod;\\n            else continue;\\n            if (i>=3 && pressedKeys[i-3]==ch)\\n            dp[i]=(dp[i]+dp[i-3])%mod;\\n            else continue;\\n            if (ch==\\'7\\' || ch==\\'9\\')\\n            {\\n                if (i>=4 && ch==pressedKeys[i-4]) dp[i]=(dp[i]+dp[i-4])%mod;\\n            }\\n        }\\n        return (dp[n])%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        int mod=1e9+7;\\n        vector<int>dp(n+1);\\n        dp[0]=1;\\n        for (int i=1;i<=n;i++)\\n        {\\n            char ch=pressedKeys[i-1];\\n            dp[i]=dp[i-1];\\n            if (i>=2 && pressedKeys[i-2]==ch)\\n            dp[i]=(dp[i-2]+dp[i])%mod;\\n            else continue;\\n            if (i>=3 && pressedKeys[i-3]==ch)\\n            dp[i]=(dp[i]+dp[i-3])%mod;\\n            else continue;\\n            if (ch==\\'7\\' || ch==\\'9\\')\\n            {\\n                if (i>=4 && ch==pressedKeys[i-4]) dp[i]=(dp[i]+dp[i-4])%mod;\\n            }\\n        }\\n        return (dp[n])%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056386,
                "title": "python-dynamic-programming",
                "content": "\\tclass Solution(object):\\n\\t\\tdef countTexts(self, pressedKeys):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type pressedKeys: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tL = len(pressedKeys)\\n\\n\\t\\t\\ti, j = 0, 0\\n\\t\\t\\tCount = []\\n\\t\\t\\tMax_len = 0\\n\\t\\t\\twhile j < L and i < L:\\n\\t\\t\\t\\twhile j < L and pressedKeys[i] == pressedKeys[j]:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\tCount.append( [pressedKeys[i],j-i])\\n\\t\\t\\t\\tMax_len = max(Max_len, j-i)\\n\\t\\t\\t\\ti = j\\n\\n\\t\\t\\tN = Max_len\\n\\t\\t\\tf = [1 for i in range(N+1)]\\n\\t\\t\\tg = [1 for i in range(N+1)]\\n\\n\\t\\t\\tif N >=2: \\n\\t\\t\\t\\tf[2], g[2] = 2, 2 \\n\\t\\t\\tif N >= 3:\\n\\t\\t\\t\\tg[3] = 4\\n\\n\\t\\t\\tfor i in range(3, N+1):\\n\\t\\t\\t\\tf[i] =  (f[i-1] + f[i-2] + f[i-3])% (10**9 + 7)\\n\\n\\t\\t\\tfor i in range(4, N+1):\\n\\t\\t\\t\\tg[i] =  (g[i-1] + g[i-2] + g[i-3] + g[i-4]) % (10**9 + 7) \\n\\n\\n\\t\\t\\tres = 1\\n\\t\\t\\tfor x in Count:\\n\\t\\t\\t\\tif int(x[0]) == 7 or int(x[0]) == 9:\\n\\t\\t\\t\\t\\tres *= g[x[1]]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres *= f[x[1]]\\n\\n\\t\\t\\treturn res % (10**9 + 7)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef countTexts(self, pressedKeys):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type pressedKeys: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tL = len(pressedKeys)\\n\\n\\t\\t\\ti, j = 0, 0\\n\\t\\t\\tCount = []\\n\\t\\t\\tMax_len = 0\\n\\t\\t\\twhile j < L and i < L:\\n\\t\\t\\t\\twhile j < L and pressedKeys[i] == pressedKeys[j]:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\tCount.append( [pressedKeys[i],j-i])\\n\\t\\t\\t\\tMax_len = max(Max_len, j-i)\\n\\t\\t\\t\\ti = j\\n\\n\\t\\t\\tN = Max_len\\n\\t\\t\\tf = [1 for i in range(N+1)]\\n\\t\\t\\tg = [1 for i in range(N+1)]\\n\\n\\t\\t\\tif N >=2: \\n\\t\\t\\t\\tf[2], g[2] = 2, 2 \\n\\t\\t\\tif N >= 3:\\n\\t\\t\\t\\tg[3] = 4\\n\\n\\t\\t\\tfor i in range(3, N+1):\\n\\t\\t\\t\\tf[i] =  (f[i-1] + f[i-2] + f[i-3])% (10**9 + 7)\\n\\n\\t\\t\\tfor i in range(4, N+1):\\n\\t\\t\\t\\tg[i] =  (g[i-1] + g[i-2] + g[i-3] + g[i-4]) % (10**9 + 7) \\n\\n\\n\\t\\t\\tres = 1\\n\\t\\t\\tfor x in Count:\\n\\t\\t\\t\\tif int(x[0]) == 7 or int(x[0]) == 9:\\n\\t\\t\\t\\t\\tres *= g[x[1]]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres *= f[x[1]]\\n\\n\\t\\t\\treturn res % (10**9 + 7)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3054007,
                "title": "c",
                "content": "```\\nint countTexts(char * pressedKeys){\\n    int mod = 1e9 + 7 ;\\n    int n = strlen(pressedKeys) ;\\n    long long * dp = malloc((n+1) * sizeof(long long)) ;\\n    dp[n] = 1;\\n    bool* hash = calloc(100000, sizeof(bool)) ;\\n    int trip[] = {2, 3, 4, 5, 6, 8};\\n    int four[] = {7, 9} ;\\n    for(int i = 0; i < 6; i++){\\n        int d = trip[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 3; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n    \\n    for(int i = 0; i < 2; i++){\\n        int d = four[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 4; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n\\n    dp[n] = 1;\\n    dp[n-1] = 1;\\n    pressedKeys[n] = \\'0\\' ;\\n    for(int i = n-2 ; i >= 0 ; i--){\\n        int val = pressedKeys[i] - \\'0\\' ;\\n        dp[i] = 0;\\n        int k = 1 ;\\n        while( hash[val] ){\\n            dp[i] = (dp[i] + dp[i+k]) % mod;\\n            val = val* 10 + pressedKeys[i+k] - \\'0\\' ;\\n            k++;  \\n        }\\n    }\\n    pressedKeys[n] = \\'\\\\0\\' ;  //rollback\\n    int ans =  dp[0];\\n    free(hash) ;\\n    free(dp) ;\\n    return ans;\\n }\\n```",
                "solutionTags": [],
                "code": "```\\nint countTexts(char * pressedKeys){\\n    int mod = 1e9 + 7 ;\\n    int n = strlen(pressedKeys) ;\\n    long long * dp = malloc((n+1) * sizeof(long long)) ;\\n    dp[n] = 1;\\n    bool* hash = calloc(100000, sizeof(bool)) ;\\n    int trip[] = {2, 3, 4, 5, 6, 8};\\n    int four[] = {7, 9} ;\\n    for(int i = 0; i < 6; i++){\\n        int d = trip[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 3; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n    \\n    for(int i = 0; i < 2; i++){\\n        int d = four[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 4; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n\\n    dp[n] = 1;\\n    dp[n-1] = 1;\\n    pressedKeys[n] = \\'0\\' ;\\n    for(int i = n-2 ; i >= 0 ; i--){\\n        int val = pressedKeys[i] - \\'0\\' ;\\n        dp[i] = 0;\\n        int k = 1 ;\\n        while( hash[val] ){\\n            dp[i] = (dp[i] + dp[i+k]) % mod;\\n            val = val* 10 + pressedKeys[i+k] - \\'0\\' ;\\n            k++;  \\n        }\\n    }\\n    pressedKeys[n] = \\'\\\\0\\' ;  //rollback\\n    int ans =  dp[0];\\n    free(hash) ;\\n    free(dp) ;\\n    return ans;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2974724,
                "title": "python3-java-top-down-dp",
                "content": "Intuition is we can combine upto limit character together where limit is 4 for digit -> (7,9) and 3 for other digits and check for each combination , if string is 222, then you possible combination will be \\n(2,2,2) -> a,a,a\\n(2,22)  -> a,b\\n(22,2)  -> b,a\\n(222)  ->  c\\n```\\nPython3\\n\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mod = 1_00_00_00_007\\n        n = len(A)\\n        dp = [-1 for i in range(n)]\\n        def dfs(ind):\\n            if ind == n:\\n                return 1\\n            if dp[ind] != -1:\\n                return dp[ind]\\n            limit = 4 if A[ind] == \\'7\\' or A[ind] == \\'9\\' else 3\\n            val = 0\\n            for i in range(1,limit + 1):\\n                if ind + i <= n and A[ind + i - 1] == A[ind]:\\n                    val = val % mod + dfs(ind + i) % mod\\n                else:\\n                    break\\n            dp[ind] = val\\n            return dp[ind]\\n        return dfs(0) % mod\\n```\\n```\\nJava\\n\\nclass Solution {\\n    int dfs(int ind,int n,int[] dp,char[] A,int mod){\\n        if (ind == n){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        int limit = A[ind] == \\'7\\' || A[ind] ==\\'9\\' ? 4 : 3;\\n        int val = 0;\\n        for(int i = 1 ; i <= limit ; i++){\\n            if(ind + i <= n && A[ind + i - 1] == A[ind]){\\n                val = val % mod + dfs(ind + i,n,dp,A,mod) % mod;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return dp[ind] = val;\\n    }\\n    public int countTexts(String A) {\\n        char[] arr = A.toCharArray();\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n        int mod = 1_00_00_00_007;\\n        return dfs(0,n,dp,arr,mod) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nPython3\\n\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mod = 1_00_00_00_007\\n        n = len(A)\\n        dp = [-1 for i in range(n)]\\n        def dfs(ind):\\n            if ind == n:\\n                return 1\\n            if dp[ind] != -1:\\n                return dp[ind]\\n            limit = 4 if A[ind] == \\'7\\' or A[ind] == \\'9\\' else 3\\n            val = 0\\n            for i in range(1,limit + 1):\\n                if ind + i <= n and A[ind + i - 1] == A[ind]:\\n                    val = val % mod + dfs(ind + i) % mod\\n                else:\\n                    break\\n            dp[ind] = val\\n            return dp[ind]\\n        return dfs(0) % mod\\n```\n```\\nJava\\n\\nclass Solution {\\n    int dfs(int ind,int n,int[] dp,char[] A,int mod){\\n        if (ind == n){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        int limit = A[ind] == \\'7\\' || A[ind] ==\\'9\\' ? 4 : 3;\\n        int val = 0;\\n        for(int i = 1 ; i <= limit ; i++){\\n            if(ind + i <= n && A[ind + i - 1] == A[ind]){\\n                val = val % mod + dfs(ind + i,n,dp,A,mod) % mod;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return dp[ind] = val;\\n    }\\n    public int countTexts(String A) {\\n        char[] arr = A.toCharArray();\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n        int mod = 1_00_00_00_007;\\n        return dfs(0,n,dp,arr,mod) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912092,
                "title": "java-dynamic-programming-top-down-dp-recursion-memization-faster",
                "content": "```\\nclass Solution {\\n\\n    int MOD = 1000000007;\\n    String key;\\n    Integer[] dp;\\n    int[] count;\\n\\t\\n    private int solve(int i) {\\n\\t\\n        if(i >= key.length())\\n            return 1;\\n        \\n        if(dp[i] != null) \\n            return dp[i];\\n       \\n        char first = key.charAt(i);\\n        int res = 0, cnt = 1, mxCnt = count[first - \\'0\\'], j = i;\\n        \\n        while(i < key.length() && key.charAt(i) == first && cnt <= mxCnt) {\\n            res = (((res%MOD) + (solve(i+1)%MOD)) % MOD);\\n            i++; cnt++;\\n        }\\n\\t\\t\\n        return dp[j] = res;\\n    }\\n\\t\\n    public int countTexts(String pressedKeys) {\\n\\t\\n        this.key = pressedKeys;\\n        this.count = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        this.dp = new Integer[pressedKeys.length()+1];\\n        return solve(0);\\n\\t\\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    int MOD = 1000000007;\\n    String key;\\n    Integer[] dp;\\n    int[] count;\\n\\t\\n    private int solve(int i) {\\n\\t\\n        if(i >= key.length())\\n            return 1;\\n        \\n        if(dp[i] != null) \\n            return dp[i];\\n       \\n        char first = key.charAt(i);\\n        int res = 0, cnt = 1, mxCnt = count[first - \\'0\\'], j = i;\\n        \\n        while(i < key.length() && key.charAt(i) == first && cnt <= mxCnt) {\\n            res = (((res%MOD) + (solve(i+1)%MOD)) % MOD);\\n            i++; cnt++;\\n        }\\n\\t\\t\\n        return dp[j] = res;\\n    }\\n\\t\\n    public int countTexts(String pressedKeys) {\\n\\t\\n        this.key = pressedKeys;\\n        this.count = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        this.dp = new Integer[pressedKeys.length()+1];\\n        return solve(0);\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877811,
                "title": "easy-and-clean-2-approaches-from-recursion-to-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = (int)(Math.pow(10,9)+7);\\n    public int countTexts(String pressedKeys) {\\n        //Way 1 Recursion\\n        int [] dp = new int[pressedKeys.length()];\\n        Arrays.fill(dp, -1);\\n        return GetCT(pressedKeys, 0, dp);\\n        //Way 2\\n        int [] dp = new int[pressedKeys.length()+1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= pressedKeys.length();i++)\\n        {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-2))\\n            {\\n                dp[i] = (dp[i] + dp[i-2] % mod)%mod;\\n                if(i > 2 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-3))\\n                {\\n                    dp[i] = (dp[i] + dp[i-3] % mod)%mod;\\n                    if(i > 3  && (pressedKeys.charAt(i-1) == \\'7\\' \\n                     || pressedKeys.charAt(i-1) == \\'9\\') \\n                    && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-4))\\n                        dp[i] = (dp[i] + dp[i-4] % mod)%mod;\\n                }\\n            }\\n        }\\n        return dp[pressedKeys.length()];\\n    }\\n\\n    public int GetCT(String s, int idx, int [] dp)\\n    {\\n        if(idx == s.length())\\n        return 1;\\n\\n        if(dp[idx] != -1)\\n        return dp[idx];\\n\\n        int maxPKeys = (s.charAt(idx) == \\'7\\' || s.charAt(idx) == \\'9\\') ? 4 : 3;\\n        int ans = 0;\\n        int pressedKey = 1;\\n        int curIdx = idx;\\n        while(curIdx < s.length() && pressedKey <= maxPKeys && \\n        s.charAt(curIdx) == s.charAt(idx))\\n        {\\n            curIdx++;\\n            pressedKey++;\\n            ans = (ans + GetCT(s, curIdx, dp)%mod)%mod;\\n        }\\n        return dp[idx] = ans%mod;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)(Math.pow(10,9)+7);\\n    public int countTexts(String pressedKeys) {\\n        //Way 1 Recursion\\n        int [] dp = new int[pressedKeys.length()];\\n        Arrays.fill(dp, -1);\\n        return GetCT(pressedKeys, 0, dp);\\n        //Way 2\\n        int [] dp = new int[pressedKeys.length()+1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= pressedKeys.length();i++)\\n        {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-2))\\n            {\\n                dp[i] = (dp[i] + dp[i-2] % mod)%mod;\\n                if(i > 2 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-3))\\n                {\\n                    dp[i] = (dp[i] + dp[i-3] % mod)%mod;\\n                    if(i > 3  && (pressedKeys.charAt(i-1) == \\'7\\' \\n                     || pressedKeys.charAt(i-1) == \\'9\\') \\n                    && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-4))\\n                        dp[i] = (dp[i] + dp[i-4] % mod)%mod;\\n                }\\n            }\\n        }\\n        return dp[pressedKeys.length()];\\n    }\\n\\n    public int GetCT(String s, int idx, int [] dp)\\n    {\\n        if(idx == s.length())\\n        return 1;\\n\\n        if(dp[idx] != -1)\\n        return dp[idx];\\n\\n        int maxPKeys = (s.charAt(idx) == \\'7\\' || s.charAt(idx) == \\'9\\') ? 4 : 3;\\n        int ans = 0;\\n        int pressedKey = 1;\\n        int curIdx = idx;\\n        while(curIdx < s.length() && pressedKey <= maxPKeys && \\n        s.charAt(curIdx) == s.charAt(idx))\\n        {\\n            curIdx++;\\n            pressedKey++;\\n            ans = (ans + GetCT(s, curIdx, dp)%mod)%mod;\\n        }\\n        return dp[idx] = ans%mod;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877317,
                "title": "easy-python-recursion-memoization-top-down-approach",
                "content": "**leetcode 2266 : Count Number of Texts\\nEasy Understanding\\nDp Recursion with Memoization\\nTop down Approach**\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dic = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n        s = pressedKeys\\n        mod = (10**9)+7\\n        \\n        def f(i):\\n            if i == len(s):\\n                return 1\\n            ## optimization \\n            ## if i already found in dp \\n            ## then return dp[i] \\n            if i in dp:\\n                return dp[i]\\n            total = 0\\n            ## current index in s is i \\n            ## so current digit is s[i]\\n            ## letters of that digit is dic[s[i]]\\n\\n            for j in range(len(dic[s[i]])):\\n                k = i + j + 1\\n                ## k is the position where next iteration will be called\\n                ## k must be next position of i, k==i+1\\n                if k > len(s) or s[k-1] != s[i] :\\n                    break\\n                ## optimization \\n                if k in dp:\\n                    total += dp[k]\\n                else:\\n                    total += f(k)\\n            ## keep a copy of the result of i in dp\\n            dp[i] = total % mod\\n            return dp[i]\\n        dp = {}\\n        return f(0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dic = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n        s = pressedKeys\\n        mod = (10**9)+7\\n        \\n        def f(i):\\n            if i == len(s):\\n                return 1\\n            ## optimization \\n            ## if i already found in dp \\n            ## then return dp[i] \\n            if i in dp:\\n                return dp[i]\\n            total = 0\\n            ## current index in s is i \\n            ## so current digit is s[i]\\n            ## letters of that digit is dic[s[i]]\\n\\n            for j in range(len(dic[s[i]])):\\n                k = i + j + 1\\n                ## k is the position where next iteration will be called\\n                ## k must be next position of i, k==i+1\\n                if k > len(s) or s[k-1] != s[i] :\\n                    break\\n                ## optimization \\n                if k in dp:\\n                    total += dp[k]\\n                else:\\n                    total += f(k)\\n            ## keep a copy of the result of i in dp\\n            dp[i] = total % mod\\n            return dp[i]\\n        dp = {}\\n        return f(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869579,
                "title": "c-dp-memoization-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    long solve(string &s,int idx)\\n    {\\n        if(idx>=s.size())\\n            return 1;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        int maxpress=(s[idx]==\\'7\\'||s[idx]==\\'9\\')?4:3;\\n        int curr_idx=idx,press=1;\\n        long ans=0;\\n        while(press<=maxpress&&s[curr_idx]==s[idx])\\n        {\\n            press++;\\n            curr_idx++;\\n            ans+=(solve(s,curr_idx))%mod;\\n        }\\n        return dp[idx]=ans%mod;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        int n=pressedKeys.size();\\n        dp.resize(n+1,-1);\\n        return solve(pressedKeys,0);\\n        \\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    long solve(string &s,int idx)\\n    {\\n        if(idx>=s.size())\\n            return 1;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        int maxpress=(s[idx]==\\'7\\'||s[idx]==\\'9\\')?4:3;\\n        int curr_idx=idx,press=1;\\n        long ans=0;\\n        while(press<=maxpress&&s[curr_idx]==s[idx])\\n        {\\n            press++;\\n            curr_idx++;\\n            ans+=(solve(s,curr_idx))%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2841733,
                "title": "python3-dp",
                "content": "class Solution:\\n\\n    def countTexts(self, pressedKeys: str) -> int:\\n        N = len(pressedKeys) + 1\\n        MOD = 10**9+7\\n        dp = [0]*N\\n        dp[0] = 1\\n    \\n        for i in range(1,N):\\n            currChar = pressedKeys[i-1]\\n            dp[i] = dp[i-1]\\n            if i>=2 and currChar ==  pressedKeys[i-2]:\\n                dp[i] = (dp[i]+dp[i-2])%MOD\\n            else:\\n                continue\\n            if i>=3 and currChar ==  pressedKeys[i-3]:\\n                dp[i] = (dp[i]+dp[i-3])%MOD\\n            else:\\n                continue\\n            \\n            if i>=4 and currChar in \"79\" and currChar ==  pressedKeys[i-4]:\\n                dp[i] = (dp[i]+dp[i-4])%MOD\\n                \\n        return dp[-1]",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def countTexts(self, pressedKeys: str) -> int:\\n        N = len(pressedKeys) + 1\\n        MOD = 10**9+7\\n        dp = [0]*N\\n        dp[0] = 1\\n    \\n        for i in range(1,N):\\n            currChar = pressedKeys[i-1]\\n            dp[i] = dp[i-1]\\n            if i>=2 and currChar ==  pressedKeys[i-2]:\\n                dp[i] = (dp[i]+dp[i-2])%MOD\\n            else:\\n                continue\\n            if i>=3 and currChar ==  pressedKeys[i-3]:\\n                dp[i] = (dp[i]+dp[i-3])%MOD\\n            else:\\n                continue\\n            \\n            if i>=4 and currChar in \"79\" and currChar ==  pressedKeys[i-4]:\\n                dp[i] = (dp[i]+dp[i-4])%MOD\\n                \\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 2840945,
                "title": "python-cached-recursive-dp-approach",
                "content": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # dp(n, lmt): possibilities pressing a number of lmt charaters n times\\n        @cache\\n        def dp(n, lmt):\\n            if n == 0:\\n                return 1\\n            ans = 0\\n            for i in range(max(0, n - lmt), n):\\n                ans += dp(i, lmt)\\n            return ans % int(1e9 + 7)\\n        \\n        i, j = 0, 0\\n        s = pressedKeys + \"-\"\\n        ans = 1\\n        while j < len(s) - 1:\\n            j += 1\\n            if s[j] != s[i]:\\n                ans *= dp(j - i, 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n                ans %= int(1e9 + 7)\\n                i = j\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # dp(n, lmt): possibilities pressing a number of lmt charaters n times\\n        @cache\\n        def dp(n, lmt):\\n            if n == 0:\\n                return 1\\n            ans = 0\\n            for i in range(max(0, n - lmt), n):\\n                ans += dp(i, lmt)\\n            return ans % int(1e9 + 7)\\n        \\n        i, j = 0, 0\\n        s = pressedKeys + \"-\"\\n        ans = 1\\n        while j < len(s) - 1:\\n            j += 1\\n            if s[j] != s[i]:\\n                ans *= dp(j - i, 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n                ans %= int(1e9 + 7)\\n                i = j\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831929,
                "title": "java-top-down-dp-memoization",
                "content": "class Solution {\\n\\n    int res=0;\\n    int mod = 1000000007;\\n    Map<Integer,Integer> mp=new HashMap<Integer,Integer>();\\n    Map<Integer,Integer> cache=new HashMap<Integer,Integer>();\\n    \\n    public int recur(String keys,int index){\\n        if(index==keys.length()){\\n            return 1;\\n        }\\n        if(cache.containsKey(index)){\\n            return cache.get(index);\\n        }\\n        char x = keys.charAt(index);\\n        int mappingSize = mp.get(x-\\'0\\');\\n        int i=index;\\n        int sum=0;\\n        while(i<keys.length() && keys.charAt(i)==x && i-index<mappingSize){\\n            int count=0;\\n            count=recur(keys,i+1);\\n            sum=(sum+count)%mod;\\n            i++;\\n        }\\n        \\n        cache.put(index,sum);\\n        return sum;\\n        \\n    }\\n    public int countTexts(String pressedKeys) {\\n        mp.put(2,3);\\n        mp.put(3,3);\\n        mp.put(4,3);\\n        mp.put(5,3);\\n        mp.put(6,3);\\n        mp.put(7,4);\\n        mp.put(8,3);\\n        mp.put(9,4);\\n        return recur(pressedKeys,0);  \\n    }\\n}",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "class Solution {\\n\\n    int res=0;\\n    int mod = 1000000007;\\n    Map<Integer,Integer> mp=new HashMap<Integer,Integer>();\\n    Map<Integer,Integer> cache=new HashMap<Integer,Integer>();\\n    \\n    public int recur(String keys,int index){\\n        if(index==keys.length()){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2828735,
                "title": "video-walkthrough-python-easy-five-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/n82BgEqSCkg)\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        count, char,lastFour = 0, -1, [1,1,1,1]\\n        for key in pressedKeys:\\n            count, char =  min(count * int(char == key) + 1, 3 + int(char==\\'7\\' or char==\\'9\\')), key\\n            lastFour = [sum(lastFour[:count]) % (10 ** 9 + 7)] + lastFour[:-1]\\n        return lastFour[0] % (10 ** 9 + 7)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        count, char,lastFour = 0, -1, [1,1,1,1]\\n        for key in pressedKeys:\\n            count, char =  min(count * int(char == key) + 1, 3 + int(char==\\'7\\' or char==\\'9\\')), key\\n            lastFour = [sum(lastFour[:count]) % (10 ** 9 + 7)] + lastFour[:-1]\\n        return lastFour[0] % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827628,
                "title": "simple-easy-to-understand-solution-c-hashing-dp-o-n-o-n",
                "content": "\\'\\'\\'\\n unordered_map< int , int >mp1 , mp2 ;\\n    \\n   int solve( pair< int  , char  >p )\\n    {\\n           int a = p.first ;\\n           char b = p.second ;\\n       \\n           int mod = pow( 10 , 9 ) + 7 ;\\n       \\n           int arr[a+1] ;\\n       \\n       \\n          if( b == \\'7\\' || b == \\'9\\' )\\n          {\\n              if( mp1.find(a) != mp1.end() )  return mp1[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n              if( a == 4 )  return 8 ;\\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n              arr[4] = 8 ;\\n              \\n              for( int i = 5 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  + (arr[i-3] + arr[i-4] )%mod )%mod ;\\n              }\\n              \\n              mp1[a] = arr[a] ;\\n              \\n          }\\n          else{\\n              \\n             if( mp2.find(a) != mp2.end() )  return mp2[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n             \\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n             \\n              \\n              for( int i = 4 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  +  arr[i-3] )%mod ;\\n              }\\n              \\n              mp2[a] = arr[a] ; \\n          }\\n       \\n          return arr[a] ;\\n    }\\n    int countTexts(string pk ) {\\n        \\n         if( pk == \"\")\\n        {\\n            return 0 ;\\n        }\\n        \\n        \\n        vector< pair<int , char >>mp ;\\n       \\n        string temp = \"\" ;\\n        \\n        int n = pk.size()  ;\\n        \\n            temp += pk[0] ;\\n                \\n            \\n        \\n        for( int i = 1 ; i < n ; i++ )\\n        {\\n            \\n            \\n            if( pk[i] == pk[i-1] )\\n            {\\n                temp += pk[i] ;\\n            }\\n            else{\\n                \\n                mp.push_back({ temp.size() , temp[0] }) ;\\n                // cout<<temp.size()<<\" \"<<temp[0]<<endl ;\\n                temp = pk[i] ;\\n            }\\n        }\\n        \\n        if( !temp.empty())\\n        {\\n            mp.push_back({ temp.size() , temp[0] }) ;\\n        }\\n        \\n        long long int ans = 1 ;\\n        \\n        int mod = pow( 10 , 9 ) + 7 ;\\n        \\n        for( int i = 0 ; i < mp.size() ; i++ )\\n        {\\n            ans = (ans*solve(mp[i]))%mod ;\\n        }\\n        \\n        return ans%mod ;\\n    }\\n\\t\\'\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n unordered_map< int , int >mp1 , mp2 ;\\n    \\n   int solve( pair< int  , char  >p )\\n    {\\n           int a = p.first ;\\n           char b = p.second ;\\n       \\n           int mod = pow( 10 , 9 ) + 7 ;\\n       \\n           int arr[a+1] ;\\n       \\n       \\n          if( b == \\'7\\' || b == \\'9\\' )\\n          {\\n              if( mp1.find(a) != mp1.end() )  return mp1[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n              if( a == 4 )  return 8 ;\\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n              arr[4] = 8 ;\\n              \\n              for( int i = 5 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  + (arr[i-3] + arr[i-4] )%mod )%mod ;\\n              }\\n              \\n              mp1[a] = arr[a] ;\\n              \\n          }\\n          else{\\n              \\n             if( mp2.find(a) != mp2.end() )  return mp2[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n             \\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n             \\n              \\n              for( int i = 4 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  +  arr[i-3] )%mod ;\\n              }\\n              \\n              mp2[a] = arr[a] ; \\n          }\\n       \\n          return arr[a] ;\\n    }\\n    int countTexts(string pk ) {\\n        \\n         if( pk == \"\")\\n        {\\n            return 0 ;\\n        }\\n        \\n        \\n        vector< pair<int , char >>mp ;\\n       \\n        string temp = \"\" ;\\n        \\n        int n = pk.size()  ;\\n        \\n            temp += pk[0] ;\\n                \\n            \\n        \\n        for( int i = 1 ; i < n ; i++ )\\n        {\\n            \\n            \\n            if( pk[i] == pk[i-1] )\\n            {\\n                temp += pk[i] ;\\n            }\\n            else{\\n                \\n                mp.push_back({ temp.size() , temp[0] }) ;\\n                // cout<<temp.size()<<\" \"<<temp[0]<<endl ;\\n                temp = pk[i] ;\\n            }\\n        }\\n        \\n        if( !temp.empty())\\n        {\\n            mp.push_back({ temp.size() , temp[0] }) ;\\n        }\\n        \\n        long long int ans = 1 ;\\n        \\n        int mod = pow( 10 , 9 ) + 7 ;\\n        \\n        for( int i = 0 ; i < mp.size() ; i++ )\\n        {\\n            ans = (ans*solve(mp[i]))%mod ;\\n        }\\n        \\n        return ans%mod ;\\n    }\\n\\t\\'\\'\\'\\'",
                "codeTag": "C++"
            },
            {
                "id": 2819325,
                "title": "faster-than-97-96-solution-without-dp",
                "content": "```\\n    int modNum = 1e9 + 7;\\n\\n\\tint countTexts(string pressedKeys)\\n\\t{\\n\\t\\tlong long sum = 1;\\n\\t\\tint lenSame = 1;\\n\\t\\tfor (int i = 1; i < pressedKeys.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (pressedKeys[i] == pressedKeys[i - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tlenSame++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum *= multiThem(pressedKeys[i - 1], lenSame) ;\\n\\t\\t\\t\\tsum %= modNum;\\n\\t\\t\\t\\tlenSame = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsum *= multiThem(pressedKeys[pressedKeys.length() - 1], lenSame);\\n\\t\\tsum %= modNum;\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint multiThem(char key, int len)\\n\\t{\\n\\t\\tint sum = 1;\\n\\t\\tif (len == 2)\\n\\t\\t\\tsum *= 2;\\n\\t\\telse if (len == 3)\\n\\t\\t\\tsum *= 4;\\n\\t\\telse if (len > 3)\\n\\t\\t\\tsum *= sumPossiblity(key, len);\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint sumPossiblity(char key, int len)\\n\\t{\\n\\t\\tint *index = new int[len + 1];\\n\\t\\tindex[0] = 1;\\n\\t\\tindex[1] = 1;\\n\\t\\tindex[2] = 2;\\n\\t\\tindex[3] = 4;\\n\\t\\tfor (int i = 4; i <= len; i++)\\n\\t\\t{\\n\\t\\t\\tlong long x = index[i - 1];\\n\\t\\t\\tx += index[i - 2];\\n\\t\\t\\tx += index[i - 3];\\n\\t\\t\\t\\n\\t\\t\\tif (key == \\'7\\' || key == \\'9\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tx += index[i - 4];\\n\\t\\t\\t}\\n\\t\\t\\tx %= modNum;\\n\\t\\t\\tindex[i] = x;\\n\\t\\t}\\n\\n\\t\\tint sum = index[len];\\n\\t\\tdelete[] index;\\n\\t\\treturn sum;\\n\\t}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int modNum = 1e9 + 7;\\n\\n\\tint countTexts(string pressedKeys)\\n\\t{\\n\\t\\tlong long sum = 1;\\n\\t\\tint lenSame = 1;\\n\\t\\tfor (int i = 1; i < pressedKeys.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (pressedKeys[i] == pressedKeys[i - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tlenSame++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum *= multiThem(pressedKeys[i - 1], lenSame) ;\\n\\t\\t\\t\\tsum %= modNum;\\n\\t\\t\\t\\tlenSame = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsum *= multiThem(pressedKeys[pressedKeys.length() - 1], lenSame);\\n\\t\\tsum %= modNum;\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint multiThem(char key, int len)\\n\\t{\\n\\t\\tint sum = 1;\\n\\t\\tif (len == 2)\\n\\t\\t\\tsum *= 2;\\n\\t\\telse if (len == 3)\\n\\t\\t\\tsum *= 4;\\n\\t\\telse if (len > 3)\\n\\t\\t\\tsum *= sumPossiblity(key, len);\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint sumPossiblity(char key, int len)\\n\\t{\\n\\t\\tint *index = new int[len + 1];\\n\\t\\tindex[0] = 1;\\n\\t\\tindex[1] = 1;\\n\\t\\tindex[2] = 2;\\n\\t\\tindex[3] = 4;\\n\\t\\tfor (int i = 4; i <= len; i++)\\n\\t\\t{\\n\\t\\t\\tlong long x = index[i - 1];\\n\\t\\t\\tx += index[i - 2];\\n\\t\\t\\tx += index[i - 3];\\n\\t\\t\\t\\n\\t\\t\\tif (key == \\'7\\' || key == \\'9\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tx += index[i - 4];\\n\\t\\t\\t}\\n\\t\\t\\tx %= modNum;\\n\\t\\t\\tindex[i] = x;\\n\\t\\t}\\n\\n\\t\\tint sum = index[len];\\n\\t\\tdelete[] index;\\n\\t\\treturn sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797745,
                "title": "python-simple-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys):\\n        n = len(pressedKeys)\\n\\n        dp = [0]*(n+1)\\n\\n        dp[0], dp[1] = 1, 1\\n\\n        for i in range(2,n+1):\\n            dp[i] += dp[i-1]\\n\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                dp[i] += dp[i-2]\\n\\n            if i > 2 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                dp[i] += dp[i-3]\\n\\n            if pressedKeys[i-1] == \"7\" or pressedKeys[i-1] == \"9\":\\n                if i > 3 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    dp[i] += dp[i-4]\\n\\n        return dp[-1]%(10**9+7)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys):\\n        n = len(pressedKeys)\\n\\n        dp = [0]*(n+1)\\n\\n        dp[0], dp[1] = 1, 1\\n\\n        for i in range(2,n+1):\\n            dp[i] += dp[i-1]\\n\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                dp[i] += dp[i-2]\\n\\n            if i > 2 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                dp[i] += dp[i-3]\\n\\n            if pressedKeys[i-1] == \"7\" or pressedKeys[i-1] == \"9\":\\n                if i > 3 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    dp[i] += dp[i-4]\\n\\n        return dp[-1]%(10**9+7)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792224,
                "title": "java-easy-to-understand-code",
                "content": "```\\nchar[] arr;\\nint brr[], dp[], mod = 1_000_000_007;\\n\\npublic int countTexts(String pressedKeys){\\n\\tarr = pressedKeys.toCharArray();\\n\\tdp = new int[arr.length + 1];\\n\\tbrr = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n\\tdp[0] = 1;\\n\\tfor(int i = 1; i <= arr.length; i++){\\n\\n\\t\\tint freq = brr[arr[i - 1] - \\'0\\'], count = 0;\\n\\t\\tfor (int j = 0; i - j - 1 >= 0 && j < freq && arr[i - 1] == arr[i - j - 1]; j++) {\\n\\t\\t\\tcount = (count % mod + dp[i - j - 1] % mod) % mod;\\n\\t\\t}\\n\\t\\tdp[i] = count;\\n\\t}\\n\\treturn dp[arr.length];\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nchar[] arr;\\nint brr[], dp[], mod = 1_000_000_007;\\n\\npublic int countTexts(String pressedKeys){\\n\\tarr = pressedKeys.toCharArray();\\n\\tdp = new int[arr.length + 1];\\n\\tbrr = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n\\tdp[0] = 1;\\n\\tfor(int i = 1; i <= arr.length; i++){\\n\\n\\t\\tint freq = brr[arr[i - 1] - \\'0\\'], count = 0;\\n\\t\\tfor (int j = 0; i - j - 1 >= 0 && j < freq && arr[i - 1] == arr[i - j - 1]; j++) {\\n\\t\\t\\tcount = (count % mod + dp[i - j - 1] % mod) % mod;\\n\\t\\t}\\n\\t\\tdp[i] = count;\\n\\t}\\n\\treturn dp[arr.length];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2737477,
                "title": "c-o-n-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        pressedKeys += \\'*\\';\\n        long long res = 1, mod = 1e9+7;\\n        vector<int> vNumChar = {1,0,3,3,3,3,3,4,3,4};\\n        char pre = \\'0\\';\\n        int len = 0;\\n        for(auto c:pressedKeys){\\n            if(c != pre){\\n                res = count(len, vNumChar[pre-\\'0\\']) % mod * res % mod;\\n                pre = c;\\n                len = 1;\\n            }\\n            else{\\n                len++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int count(int n, int numChar){\\n        const long long mod = 1e9+7;\\n        vector<long long> dp(n+1, 0);\\n        dp[0] = 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<=numChar;j++){\\n                if(i+1-j >= 0) dp[i+1] += dp[i+1-j];\\n            }\\n            dp[i+1] %= mod;\\n        }\\n        return dp.back();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        pressedKeys += \\'*\\';\\n        long long res = 1, mod = 1e9+7;\\n        vector<int> vNumChar = {1,0,3,3,3,3,3,4,3,4}",
                "codeTag": "Java"
            },
            {
                "id": 2717929,
                "title": "c-concise-intuitive-easy-to-understand-dynamic-programming-solution-o-n",
                "content": "My personal struggle has always been, my brain looping in cataclysms of understanding \\'# of ways\\', so I often get the tansition from one state to another wrong.\\nI do things like initialising dp tables with 1 or adding 1 while transitioning which is clearly wrong. \\n\\nFor example in for input 2223 transitioning from \"222\"-> \"2223\" will not resullt in increase in the # of ways.\\nAlso it is important to understand the base condition dp[0] = 1;\\nBasically dp[n] denotes the number of ways of decoding the test of length n, the number of ways of decoding an empty message is 1.\\n\\n```\\nint countTexts(string pk) {\\n        int n = pk.size(), m = 1e9 + 7, k;\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            k = (pk[i] == \\'7\\' || pk[i] == \\'9\\') ? 4 : 3;\\n            for (int j = 0; j < k && i - j >= 0 && pk[i] == pk[i - j]; j++) \\n                dp[i + 1] = (dp[i + 1] + dp[i - j]) % m;\\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint countTexts(string pk) {\\n        int n = pk.size(), m = 1e9 + 7, k;\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            k = (pk[i] == \\'7\\' || pk[i] == \\'9\\') ? 4 : 3;\\n            for (int j = 0; j < k && i - j >= 0 && pk[i] == pk[i - j]; j++) \\n                dp[i + 1] = (dp[i + 1] + dp[i - j]) % m;\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692639,
                "title": "java-o-n-memoization-easy-intiution-faster",
                "content": "\\tpublic int mod = 1000000007;\\n    public int[] dp;\\n   \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        dp = new int[n+1];\\n        dp[n]=1;\\n        for(int index=n-1; index>=0; index--){\\n            char ch = s.charAt(index);\\n            int keylen=(ch==\\'7\\' || ch==\\'9\\')?4:3;\\n            for(int i=1; i<=keylen; i++){\\n                if(index+i > n) break;\\n                if(ch!=s.charAt(index+i-1)) break;\\n\\n                dp[index] += dp[index+i];\\n                dp[index] = dp[index]%mod;\\n            }\\n        }\\n        return dp[0];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\tpublic int mod = 1000000007;\\n    public int[] dp;\\n   \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        dp = new int[n+1];\\n        dp[n]=1;\\n        for(int index=n-1; index>=0; index--){\\n            char ch = s.charAt(index);\\n            int keylen=(ch==\\'7\\' || ch==\\'9\\')?4:3;\\n            for(int i=1; i<=keylen; i++){\\n                if(index+i > n) break;\\n                if(ch!=s.charAt(index+i-1)) break;\\n\\n                dp[index] += dp[index+i];\\n                dp[index] = dp[index]%mod;\\n            }\\n        }\\n        return dp[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2679674,
                "title": "python-short-solution",
                "content": "```\\ndef countTexts(self, strs: str) -> int:\\n\\tmod = 10**9+7\\n\\t\\n\\t@lru_cache(None)\\n\\tdef dfs(x, k):\\n\\t\\tif x==0:\\n\\t\\t\\treturn 1\\n\\t\\treturn sum(dfs(x-i, k) for i in range(1, min(x, k)+1))%mod\\n\\n\\td = {str(c):3 for c in range(2, 10)}\\n\\td[\\'7\\'], d[\\'9\\'] = 4, 4\\n\\treturn reduce(mul, [dfs(len(list(g)), d[k]) for k, g in groupby(strs)])%mod    \\n```",
                "solutionTags": [],
                "code": "```\\ndef countTexts(self, strs: str) -> int:\\n\\tmod = 10**9+7\\n\\t\\n\\t@lru_cache(None)\\n\\tdef dfs(x, k):\\n\\t\\tif x==0:\\n\\t\\t\\treturn 1\\n\\t\\treturn sum(dfs(x-i, k) for i in range(1, min(x, k)+1))%mod\\n\\n\\td = {str(c):3 for c in range(2, 10)}\\n\\td[\\'7\\'], d[\\'9\\'] = 4, 4\\n\\treturn reduce(mul, [dfs(len(list(g)), d[k]) for k, g in groupby(strs)])%mod    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2672218,
                "title": "python-easiest-memoization",
                "content": "```\\nclass Solution(object):\\n    def countTexts(self, pressed):\\n        def dfs(i,s):\\n            if i in dp:\\n                return dp[i]\\n            if i>=len(s):\\n                return 1\\n            count = 0\\n            n = 3\\n            if s[i] == \\'7\\' or s[i] == \\'9\\':\\n                n = 4\\n            # number of times we can press the buttons \\n            for k in range(1, n+1):\\n                if i+k<=len(s):\\n                    count+= dfs(i+k,s)\\n            dp[i] = count\\n            return dp[i]\\n        ans = 1\\n        i= 0\\n        j = 0\\n        while j<len(pressed):\\n            while j<len(pressed) and pressed[i] == pressed[j]:\\n                j+=1\\n            s = pressed[i:j]\\n            dp = {}\\n            ans *= dfs(0,s)\\n            i = j\\n        return ans%(10**9+7)\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def countTexts(self, pressed):\\n        def dfs(i,s):\\n            if i in dp:\\n                return dp[i]\\n            if i>=len(s):\\n                return 1\\n            count = 0\\n            n = 3\\n            if s[i] == \\'7\\' or s[i] == \\'9\\':\\n                n = 4\\n            # number of times we can press the buttons \\n            for k in range(1, n+1):\\n                if i+k<=len(s):\\n                    count+= dfs(i+k,s)\\n            dp[i] = count\\n            return dp[i]\\n        ans = 1\\n        i= 0\\n        j = 0\\n        while j<len(pressed):\\n            while j<len(pressed) and pressed[i] == pressed[j]:\\n                j+=1\\n            s = pressed[i:j]\\n            dp = {}\\n            ans *= dfs(0,s)\\n            i = j\\n        return ans%(10**9+7)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664936,
                "title": "c-easy-recursive-and-memoized-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int MOD = 1e9 + 7;\\n    int countTexts(string keys) {\\n        dp.resize(keys.size(), -1);\\n        \\n        return recurse(keys, 0);\\n    }\\n    int recurse(string &keys, int ind){\\n        if(ind >= keys.size()){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind] % MOD;\\n        }\\n        \\n        long long ans = 0;\\n        \\n        //take one char at a time\\n        ans += recurse(keys, ind + 1);\\n            \\n        if(ind + 1 < keys.size() and keys[ind] == keys[ind + 1]){\\n            //take two char at a time if they\\'re identical\\n            ans += recurse(keys, ind + 2);\\n\\n            if(ind + 2 < keys.size() and keys[ind] == keys[ind + 2]){\\n                //take three char at a time if they\\'re identical\\n                ans += recurse(keys, ind + 3);\\n                \\n                //take four char at a time if they\\'re identical and they\\'re either 7 or 9\\n                if(ind + 3 < keys.size() and keys[ind] == keys[ind + 3] and \\n                  (keys[ind + 3] == \\'7\\' or keys[ind + 3] == \\'9\\')){\\n                    \\n                    ans += recurse(keys, ind + 4);\\n                }\\n            }\\n        }\\n        return dp[ind] = ans % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int MOD = 1e9 + 7;\\n    int countTexts(string keys) {\\n        dp.resize(keys.size(), -1);\\n        \\n        return recurse(keys, 0);\\n    }\\n    int recurse(string &keys, int ind){\\n        if(ind >= keys.size()){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind] % MOD;\\n        }\\n        \\n        long long ans = 0;\\n        \\n        //take one char at a time\\n        ans += recurse(keys, ind + 1);\\n            \\n        if(ind + 1 < keys.size() and keys[ind] == keys[ind + 1]){\\n            //take two char at a time if they\\'re identical\\n            ans += recurse(keys, ind + 2);\\n\\n            if(ind + 2 < keys.size() and keys[ind] == keys[ind + 2]){\\n                //take three char at a time if they\\'re identical\\n                ans += recurse(keys, ind + 3);\\n                \\n                //take four char at a time if they\\'re identical and they\\'re either 7 or 9\\n                if(ind + 3 < keys.size() and keys[ind] == keys[ind + 3] and \\n                  (keys[ind + 3] == \\'7\\' or keys[ind + 3] == \\'9\\')){\\n                    \\n                    ans += recurse(keys, ind + 4);\\n                }\\n            }\\n        }\\n        return dp[ind] = ans % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661593,
                "title": "python-using-groupby",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        @cache\\n        def dfs(cur: int, options: int) -> int:\\n            if cur < 0:\\n                return 0\\n            if cur == 0:\\n                return 1\\n            \\n            res = 0\\n            for ind in range(1, options + 1):\\n                res += dfs(cur - ind, options)\\n            return res % MOD\\n        \\n        res = 1\\n        \\n        for key, curgroup in groupby(pressedKeys):\\n            options = 4 if key in \"79\" else 3\\n            res *= dfs(len(list(curgroup)), options)\\n            res %= MOD\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        @cache\\n        def dfs(cur: int, options: int) -> int:\\n            if cur < 0:\\n                return 0\\n            if cur == 0:\\n                return 1\\n            \\n            res = 0\\n            for ind in range(1, options + 1):\\n                res += dfs(cur - ind, options)\\n            return res % MOD\\n        \\n        res = 1\\n        \\n        for key, curgroup in groupby(pressedKeys):\\n            options = 4 if key in \"79\" else 3\\n            res *= dfs(len(list(curgroup)), options)\\n            res %= MOD\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654278,
                "title": "python-solution-dynamic-programming-faster-than-96-time-o-n-space-o-n",
                "content": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tpressedKeys_len = len(pressedKeys)\\n\\t\\t\\tif pressedKeys_len == 0: \\n\\t\\t\\t\\treturn 0 \\n\\t\\t\\telif pressedKeys_len == 1: \\n\\t\\t\\t\\treturn 1 \\n\\t\\t\\tif \\'0\\' in pressedKeys or \\'1\\' in pressedKeys: \\n\\t\\t\\t\\treturn False\\n\\t\\t\\tqueue = list()\\n\\t\\t\\tcontinue_count = 1\\n\\t\\t\\tprev_num_of_text = pressedKeys[0]\\n\\t\\t\\ti = 1\\n\\t\\t\\tmax_continue_count = 1\\n\\t\\t\\twhile i<pressedKeys_len:\\n\\t\\t\\t\\tcurr_num_of_text = pressedKeys[i]\\n\\t\\t\\t\\tif curr_num_of_text == prev_num_of_text: \\n\\t\\t\\t\\t\\tcontinue_count += 1                \\n\\t\\t\\t\\telif curr_num_of_text != prev_num_of_text: \\n\\t\\t\\t\\t\\tqueue.append([prev_num_of_text, continue_count])\\n\\t\\t\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t\\t\\tcontinue_count = 1\\n\\t\\t\\t\\tprev_num_of_text = curr_num_of_text\\n\\t\\t\\t\\ti += 1 \\n\\t\\t\\tqueue.append((prev_num_of_text, continue_count))\\n\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t# print(queue)\\n\\t\\t\\tdp3 = [0 for _ in range(1+max_continue_count)]\\n\\t\\t\\tdp3[1] = 1 \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i>=4: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + dp3[i-3]) % (10**9 + 7)  \\n\\n\\t\\t\\tdp4 = [0 for _ in range(1+max_continue_count)]         \\n\\t\\t\\tdp4[1] = 1         \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==4: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + 1) % (10**9 + 7)                \\n\\t\\t\\t\\telif i>=5: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % (10**9 + 7)                  \\n\\t\\t\\tres = 1 \\n\\t\\t\\titems_num = len(queue)\\n\\t\\t\\tfor i in range(items_num): \\n\\t\\t\\t\\tcurr_item = queue[i]\\n\\t\\t\\t\\tdigit_num, curr_continue_num_count = curr_item \\n\\t\\t\\t\\t# print(curr_item, digit_num, curr_continue_num_count)\\n\\t\\t\\t\\tif digit_num in \\'234568\\': \\n\\t\\t\\t\\t\\tres *= dp3[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\t\\telif digit_num in \\'79\\':  \\n\\t\\t\\t\\t\\tres *= dp4[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\treturn res % (10**9 + 7)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tpressedKeys_len = len(pressedKeys)\\n\\t\\t\\tif pressedKeys_len == 0: \\n\\t\\t\\t\\treturn 0 \\n\\t\\t\\telif pressedKeys_len == 1: \\n\\t\\t\\t\\treturn 1 \\n\\t\\t\\tif \\'0\\' in pressedKeys or \\'1\\' in pressedKeys: \\n\\t\\t\\t\\treturn False\\n\\t\\t\\tqueue = list()\\n\\t\\t\\tcontinue_count = 1\\n\\t\\t\\tprev_num_of_text = pressedKeys[0]\\n\\t\\t\\ti = 1\\n\\t\\t\\tmax_continue_count = 1\\n\\t\\t\\twhile i<pressedKeys_len:\\n\\t\\t\\t\\tcurr_num_of_text = pressedKeys[i]\\n\\t\\t\\t\\tif curr_num_of_text == prev_num_of_text: \\n\\t\\t\\t\\t\\tcontinue_count += 1                \\n\\t\\t\\t\\telif curr_num_of_text != prev_num_of_text: \\n\\t\\t\\t\\t\\tqueue.append([prev_num_of_text, continue_count])\\n\\t\\t\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t\\t\\tcontinue_count = 1\\n\\t\\t\\t\\tprev_num_of_text = curr_num_of_text\\n\\t\\t\\t\\ti += 1 \\n\\t\\t\\tqueue.append((prev_num_of_text, continue_count))\\n\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t# print(queue)\\n\\t\\t\\tdp3 = [0 for _ in range(1+max_continue_count)]\\n\\t\\t\\tdp3[1] = 1 \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i>=4: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + dp3[i-3]) % (10**9 + 7)  \\n\\n\\t\\t\\tdp4 = [0 for _ in range(1+max_continue_count)]         \\n\\t\\t\\tdp4[1] = 1         \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==4: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + 1) % (10**9 + 7)                \\n\\t\\t\\t\\telif i>=5: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % (10**9 + 7)                  \\n\\t\\t\\tres = 1 \\n\\t\\t\\titems_num = len(queue)\\n\\t\\t\\tfor i in range(items_num): \\n\\t\\t\\t\\tcurr_item = queue[i]\\n\\t\\t\\t\\tdigit_num, curr_continue_num_count = curr_item \\n\\t\\t\\t\\t# print(curr_item, digit_num, curr_continue_num_count)\\n\\t\\t\\t\\tif digit_num in \\'234568\\': \\n\\t\\t\\t\\t\\tres *= dp3[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\t\\telif digit_num in \\'79\\':  \\n\\t\\t\\t\\t\\tres *= dp4[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\treturn res % (10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 2651611,
                "title": "c-dp-single-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSingle pass using dynamic programming similar to decode ways question\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        \\n        int n = pressedKeys.length();\\n        // int* dp = new int[n];\\n        vector<long> dp(n);\\n        \\n        dp[0] = 1;\\n        int mod  = pow(10, 9) + 7;\\n\\n        for(int i=1; i<n; i++){\\n            dp[i] = dp[i-1];\\n            char ch = pressedKeys.at(i);\\n\\n            if((i>=1) && ch == pressedKeys.at(i-1)) dp[i]= i>=2 ?(dp[i] + dp[i-2]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=2) && ch == pressedKeys.at(i-2)) dp[i]= i>=3 ? (dp[i] + dp[i-3]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=3) && (ch == \\'7\\' || ch == \\'9\\') && ch == pressedKeys.at(i-3)) \\n            dp[i]= i>=4 ? (dp[i] + dp[i-4]) % mod : dp[i] + 1;\\n        }\\n       \\n        return (int)dp[n-1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        \\n        int n = pressedKeys.length();\\n        // int* dp = new int[n];\\n        vector<long> dp(n);\\n        \\n        dp[0] = 1;\\n        int mod  = pow(10, 9) + 7;\\n\\n        for(int i=1; i<n; i++){\\n            dp[i] = dp[i-1];\\n            char ch = pressedKeys.at(i);\\n\\n            if((i>=1) && ch == pressedKeys.at(i-1)) dp[i]= i>=2 ?(dp[i] + dp[i-2]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=2) && ch == pressedKeys.at(i-2)) dp[i]= i>=3 ? (dp[i] + dp[i-3]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=3) && (ch == \\'7\\' || ch == \\'9\\') && ch == pressedKeys.at(i-3)) \\n            dp[i]= i>=4 ? (dp[i] + dp[i-4]) % mod : dp[i] + 1;\\n        }\\n       \\n        return (int)dp[n-1] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650844,
                "title": "python-easy-to-understand-solution-with-memoization",
                "content": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n\\n        @cache\\n        def dfs(i):\\n            if i == len(pressedKeys):\\n                return 1\\n \\n            total = 0\\n    \\n            for j in range(len(d[pressedKeys[i]])):\\n                k = i + j + 1 \\n\\n                if k > len(pressedKeys) or pressedKeys[i] != pressedKeys[k - 1]:\\n                    break\\n\\n                total += dfs(k)\\n\\n            return total % (10**9 + 7)\\n\\n        return dfs(0) \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n\\n        @cache\\n        def dfs(i):\\n            if i == len(pressedKeys):\\n                return 1\\n \\n            total = 0\\n    \\n            for j in range(len(d[pressedKeys[i]])):\\n                k = i + j + 1 \\n\\n                if k > len(pressedKeys) or pressedKeys[i] != pressedKeys[k - 1]:\\n                    break\\n\\n                total += dfs(k)\\n\\n            return total % (10**9 + 7)\\n\\n        return dfs(0) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649367,
                "title": "java-recursion",
                "content": "\\tclass Solution {\\n    int mod=(int)1e9+7;\\n    public int countTexts(String pk) {\\n        HashMap<String,Character>hm=new HashMap<>();\\n        \\n        hm.put(\"2\", \\'a\\'); hm.put(\"22\",\\'b\\'); hm.put(\"222\",\\'c\\');\\n        hm.put(\"3\",\\'d\\'); hm.put(\"33\",\\'e\\'); hm.put(\"333\",\\'f\\');\\n        hm.put(\"4\",\\'g\\'); hm.put(\"44\",\\'h\\'); hm.put(\"444\",\\'i\\');\\n        hm.put(\"5\",\\'j\\'); hm.put(\"55\",\\'k\\'); hm.put(\"555\",\\'l\\');\\n        hm.put(\"6\",\\'m\\'); hm.put(\"66\",\\'n\\'); hm.put(\"666\",\\'o\\');\\n        hm.put(\"7\",\\'p\\'); hm.put(\"77\",\\'q\\'); hm.put(\"777\",\\'r\\'); hm.put(\"7777\",\\'s\\');\\n        hm.put(\"8\",\\'t\\'); hm.put(\"88\",\\'u\\'); hm.put(\"888\",\\'v\\');\\n        hm.put(\"9\",\\'w\\'); hm.put(\"99\",\\'x\\'); hm.put(\"999\",\\'y\\');\\n        hm.put(\"9999\",\\'z\\');\\n        int []dp=new int[pk.length()+1]; Arrays.fill(dp,-1);\\n        return call(0, pk, hm,dp);\\n    }\\n    \\n    public int call(int i, String s, HashMap<String, Character>hm, int[]dp)\\n    {\\n        if(i==s.length()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=0;\\n        for(int j=i+1;j<=s.length()&&j<=i+4 ;j++)\\n        {\\n            if(hm.containsKey(s.substring(i,j)))\\n            {\\n                ans=(ans+call(j, s, hm,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[i]=ans%mod;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int mod=(int)1e9+7;\\n    public int countTexts(String pk) {\\n        HashMap<String,Character>hm=new HashMap<>();\\n        \\n        hm.put(\"2\", \\'a\\'); hm.put(\"22\",\\'b\\'); hm.put(\"222\",\\'c\\');\\n        hm.put(\"3\",\\'d\\'); hm.put(\"33\",\\'e\\'); hm.put(\"333\",\\'f\\');\\n        hm.put(\"4\",\\'g\\'); hm.put(\"44\",\\'h\\'); hm.put(\"444\",\\'i\\');\\n        hm.put(\"5\",\\'j\\'); hm.put(\"55\",\\'k\\'); hm.put(\"555\",\\'l\\');\\n        hm.put(\"6\",\\'m\\'); hm.put(\"66\",\\'n\\'); hm.put(\"666\",\\'o\\');\\n        hm.put(\"7\",\\'p\\'); hm.put(\"77\",\\'q\\'); hm.put(\"777\",\\'r\\'); hm.put(\"7777\",\\'s\\');\\n        hm.put(\"8\",\\'t\\'); hm.put(\"88\",\\'u\\'); hm.put(\"888\",\\'v\\');\\n        hm.put(\"9\",\\'w\\'); hm.put(\"99\",\\'x\\'); hm.put(\"999\",\\'y\\');\\n        hm.put(\"9999\",\\'z\\');\\n        int []dp=new int[pk.length()+1]; Arrays.fill(dp,-1);\\n        return call(0, pk, hm,dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2648290,
                "title": "java-clean-dp-solution-for-both-topdown-and-bottom-up-beat-88",
                "content": "1. top-down + memorization (beat 18%)\\n2. bottom-up (beat 88%)\\n```\\nclass Solution {\\n    int[] dp, count;\\n    int mod = 100_000_000_7;\\n    public int countTextsTD(String pressedKeys) {\\n        //need store max length of repeat number that can form a char.    \\n        if(pressedKeys == null || pressedKeys.isEmpty()) return 0;\\n        int n = pressedKeys.length();\\n        count = new int[] {0,0,3,3,3,3,3,4,3,4};\\n        dp = new int[n];        \\n        Arrays.fill(dp, -1);\\n        return dp(pressedKeys, 0, n);\\n    }\\n    //calculated reversely, start from [idx...n] can form how many \\n    private int dp(String s, int idx, int n) {\\n        if(idx == n) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int res = 0;\\n        char c = s.charAt(idx);\\n        int len = count[c-\\'0\\'];\\n        \\n        for(int i = 0; i < len && idx + i < n && s.charAt(idx + i) == s.charAt(idx); i++) {\\n            // i start with 0, will consider number idx do not combine with previous char.\\n            // i > 1 means, it can be combined with previous number to form a char.\\n            res += dp(s, idx + i + 1, n);\\n            res %= mod;\\n        }\\n        return dp[idx] = res;    \\n    }\\n    \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && s.charAt(i-1) == s.charAt(i-2)) {\\n                dp[i] += dp[i-2];\\n                dp[i] %= mod;\\n                if(i > 2 && s.charAt(i-1) == s.charAt(i-3)) {\\n                    dp[i] += dp[i-3];\\n                    dp[i] %= mod;\\n                    if(i > 3 && (s.charAt(i-1) == \\'7\\' || s.charAt(i-1) == \\'9\\') && s.charAt(i-1) == s.charAt(i-4)) {\\n                        dp[i] += dp[i-4];\\n                        dp[i] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[] dp, count;\\n    int mod = 100_000_000_7;\\n    public int countTextsTD(String pressedKeys) {\\n        //need store max length of repeat number that can form a char.    \\n        if(pressedKeys == null || pressedKeys.isEmpty()) return 0;\\n        int n = pressedKeys.length();\\n        count = new int[] {0,0,3,3,3,3,3,4,3,4};\\n        dp = new int[n];        \\n        Arrays.fill(dp, -1);\\n        return dp(pressedKeys, 0, n);\\n    }\\n    //calculated reversely, start from [idx...n] can form how many \\n    private int dp(String s, int idx, int n) {\\n        if(idx == n) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int res = 0;\\n        char c = s.charAt(idx);\\n        int len = count[c-\\'0\\'];\\n        \\n        for(int i = 0; i < len && idx + i < n && s.charAt(idx + i) == s.charAt(idx); i++) {\\n            // i start with 0, will consider number idx do not combine with previous char.\\n            // i > 1 means, it can be combined with previous number to form a char.\\n            res += dp(s, idx + i + 1, n);\\n            res %= mod;\\n        }\\n        return dp[idx] = res;    \\n    }\\n    \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && s.charAt(i-1) == s.charAt(i-2)) {\\n                dp[i] += dp[i-2];\\n                dp[i] %= mod;\\n                if(i > 2 && s.charAt(i-1) == s.charAt(i-3)) {\\n                    dp[i] += dp[i-3];\\n                    dp[i] %= mod;\\n                    if(i > 3 && (s.charAt(i-1) == \\'7\\' || s.charAt(i-1) == \\'9\\') && s.charAt(i-1) == s.charAt(i-4)) {\\n                        dp[i] += dp[i-4];\\n                        dp[i] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647673,
                "title": "dp-linear",
                "content": "class Solution {\\npublic:\\n    \\n    vector <int> sf;\\n    int mod = 1e9+7;\\n    \\n    int dp[100009];\\n    \\n    int rec(int i,int n,string& s){\\n        \\n        if(i>n)return 0;\\n        if(i==n)return 1;\\n        \\n        if(dp[i]!=-1)return dp[i];\\n        \\n        int ans=0;\\n        \\n        bool flag = (s[i]==\\'2\\') || (s[i]==\\'3\\') || (s[i]==\\'4\\') || (s[i]==\\'5\\') || (s[i]==\\'6\\') || (s[i]==\\'8\\');\\n        \\n        if(flag){\\n            int x = sf[i];\\n            for(int j=1;j<=min(x,3);j++){\\n                ans += rec(i+j,n,s);\\n                ans %= mod;\\n            }\\n        }\\n        \\n        else{\\n                int x = sf[i];\\n            for(int j=1;j<=min(x,4);j++){\\n                ans += rec(i+j,n,s);\\n                ans %= mod;\\n            }  \\n        }\\n        return dp[i]=ans; \\n    }\\n    \\n    int countTexts(string s) {\\n        int n = s.size();\\n        sf = vector <int> (n,0);\\n        sf[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==s[i+1])sf[i]=sf[i+1]+1;\\n            else sf[i]=1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n       int ans = rec(0,n,s);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector <int> sf;\\n    int mod = 1e9+7;\\n    \\n    int dp[100009];\\n    \\n    int rec(int i,int n,string& s){\\n        \\n        if(i>n)return 0;\\n        if(i==n)return 1;\\n        \\n        if(dp[i]!=-1)return dp[i];\\n        \\n        int ans=0;\\n        \\n        bool flag = (s[i]==\\'2\\') || (s[i]==\\'3\\') || (s[i]==\\'4\\') || (s[i]==\\'5\\') || (s[i]==\\'6\\') || (s[i]==\\'8\\');\\n        \\n        if(flag){\\n            int x = sf[i];\\n            for(int j=1;j<=min(x,3);j++){\\n                ans += rec(i+j,n,s);\\n                ans %= mod;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576725,
                "content": [
                    {
                        "username": "snady",
                        "content": "the descrpition says \"Since the answer may be very large, return it modulo 10^9 + 7.\"\\nfellow python users might think to just return the answer % 10^9 + 7 at the end but this produces an incorrect result, the count should be modded at each iteration... \\n\\nI think the wording of the problem could be improved, unless I\\'m the only one who made this error \\uD83D\\uDE05"
                    },
                    {
                        "username": "joyparikh",
                        "content": "It is a well known result that (a+b)%c = (a%c + b%c)%c. So if you took mod only at the end, or you took mod at intermediate steps and then at the end should give the same result"
                    },
                    {
                        "username": "VehicleOfPuzzle",
                        "content": "I\\'m not sure what solution approach you\\'d be using such that modulo at the end would be an incorrect result. It may lead to very large intermediate calculations but the end result should be the same."
                    },
                    {
                        "username": "lolipop_",
                        "content": "When I run one of the testcases containing a large number of 3s as one of my trial test case, it works. But the same testcase fails when I submit the solution"
                    }
                ]
            },
            {
                "id": 1829036,
                "content": [
                    {
                        "username": "snady",
                        "content": "the descrpition says \"Since the answer may be very large, return it modulo 10^9 + 7.\"\\nfellow python users might think to just return the answer % 10^9 + 7 at the end but this produces an incorrect result, the count should be modded at each iteration... \\n\\nI think the wording of the problem could be improved, unless I\\'m the only one who made this error \\uD83D\\uDE05"
                    },
                    {
                        "username": "joyparikh",
                        "content": "It is a well known result that (a+b)%c = (a%c + b%c)%c. So if you took mod only at the end, or you took mod at intermediate steps and then at the end should give the same result"
                    },
                    {
                        "username": "VehicleOfPuzzle",
                        "content": "I\\'m not sure what solution approach you\\'d be using such that modulo at the end would be an incorrect result. It may lead to very large intermediate calculations but the end result should be the same."
                    },
                    {
                        "username": "lolipop_",
                        "content": "When I run one of the testcases containing a large number of 3s as one of my trial test case, it works. But the same testcase fails when I submit the solution"
                    }
                ]
            }
        ]
    }
]