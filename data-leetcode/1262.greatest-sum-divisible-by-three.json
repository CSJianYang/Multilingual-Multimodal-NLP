[
    {
        "title": "Shift 2D Grid",
        "question_content": "Given a 2D grid of size m x n&nbsp;and an integer k. You need to shift the grid&nbsp;k times.\nIn one shift operation:\n\n\tElement at grid[i][j] moves to grid[i][j + 1].\n\tElement at grid[i][n - 1] moves to grid[i + 1][0].\n\tElement at grid[m&nbsp;- 1][n - 1] moves to grid[0][0].\n\nReturn the 2D grid after applying shift operation k times.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1\nOutput: [[9,1,2],[3,4,5],[6,7,8]]\n\nExample 2:\n\nInput: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\nOutput: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n\nExample 3:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9\nOutput: [[1,2,3],[4,5,6],[7,8,9]]\n\n&nbsp;\nConstraints:\n\n\tm ==&nbsp;grid.length\n\tn ==&nbsp;grid[i].length\n\t1 <= m <= 50\n\t1 <= n <= 50\n\t-1000 <= grid[i][j] <= 1000\n\t0 <= k <= 100",
        "solutions": [
            {
                "id": 1934961,
                "title": "c-simple-clean-code-with-explanation",
                "content": "***It is a observation based question.***\\n\\nIf **k** is **1** then new column is **(j+1)** and if **k** is **k** then new column is **(j+k)** and new column should in range **[0,m-1]**. So new column is **(j+k)%m**.\\n\\nFor row, we have to first **find the number of rows added to previous row** which is equal to the **number of times (j+k) exceeds m**. So, number of rows added is **(j+k)/m**.\\n\\nSo, new row is **(i + (j+k)/m)** and new row should in range **[0,n-1]**. So new row is **(i + (j+k)/m)%n**.\\n\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; // (j + numbers of columns added)%m\\n                \\n                int newI=(i+(j+k)/m)%n; // (i + numbers of rows added)%n \\n                \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; // (j + numbers of columns added)%m\\n                \\n                int newI=(i+(j+k)/m)%n; // (i + numbers of rows added)%n \\n                \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934848,
                "title": "easy-java-code-with-explanation",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> result = new ArrayList();\\n        int rows = grid.length, col = grid[0].length;\\n\\n        for (int r = 0; r < rows; r++)// filling all the rows of result with empty lists\\n            result.add(new ArrayList());\\n        k %= (rows * col);// every rows*col shifts grid became the same, skipping the similar shifts\\n        int dimension = rows * col;\\n        int begin = dimension - k;// element at (begin) will be at 0,0 in new grid\\n        int x = 0;// counter variable\\n        for (int i = begin; i < begin + dimension; i++) {\\n            int r = (i / col) % rows, c = i % col;// calculating row and cell for new grid\\n            result.get(x / col).add(grid[r][c]);// adding new element in new row\\n            x++;\\n        }\\n        return result;// returning result list\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time Complexity =O(N+N)=O(2N)=O(N)\\nSpace Complexity=O(N)***\\n\\n<hr>\\n<hr>\\n\\n***UPVOTE if you like the post(^///^)***\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> result = new ArrayList();\\n        int rows = grid.length, col = grid[0].length;\\n\\n        for (int r = 0; r < rows; r++)// filling all the rows of result with empty lists\\n            result.add(new ArrayList());\\n        k %= (rows * col);// every rows*col shifts grid became the same, skipping the similar shifts\\n        int dimension = rows * col;\\n        int begin = dimension - k;// element at (begin) will be at 0,0 in new grid\\n        int x = 0;// counter variable\\n        for (int i = begin; i < begin + dimension; i++) {\\n            int r = (i / col) % rows, c = i % col;// calculating row and cell for new grid\\n            result.get(x / col).add(grid[r][c]);// adding new element in new row\\n            x++;\\n        }\\n        return result;// returning result list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431225,
                "title": "python-functional-programming-3-lines",
                "content": "shift all the numbers `k` steps, is the same idea as, moving last `k` numbers to head of the list: `nums = nums[-k:] + nums[:-k]`\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        col, nums = len(grid[0]), sum(grid, [])\\n        k = k % len(nums)\\n        nums = nums[-k:] + nums[:-k]\\n        return [nums[i:i+col] for i in range(0, len(nums), col)]\\n```\\n# Functional Programming, 3 lines:\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        f1 = lambda col, nums: [nums[i:i+col] for i in range(0, len(nums), col)]\\n        f2 = lambda nums, k: nums[-k%len(nums):] + nums[:-k%len(nums)]\\n        return f1(len(grid[0]), f2(sum(grid, []), k))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        col, nums = len(grid[0]), sum(grid, [])\\n        k = k % len(nums)\\n        nums = nums[-k:] + nums[:-k]\\n        return [nums[i:i+col] for i in range(0, len(nums), col)]\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        f1 = lambda col, nums: [nums[i:i+col] for i in range(0, len(nums), col)]\\n        f2 = lambda nums, k: nums[-k%len(nums):] + nums[:-k%len(nums)]\\n        return f1(len(grid[0]), f2(sum(grid, []), k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458848,
                "title": "c-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m * n; ++i) {\\n            int ori_y = i / n;\\n            int ori_x = i % n;\\n            int new_y = (ori_y + (ori_x + k) / n) % m;\\n            int new_x = (ori_x + k) % n;\\n            \\n            ans[new_y][new_x] = grid[ori_y][ori_x];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere are some similar matrix(2D Grid) problems.\\n* 498 [Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/)\\n* 566 [Reshape the Matrix](https://leetcode.com/problems/reshape-the-matrix/)\\n* 867 [Transpose Matrix](https://leetcode.com/problems/transpose-matrix/)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m * n; ++i) {\\n            int ori_y = i / n;\\n            int ori_x = i % n;\\n            int new_y = (ori_y + (ori_x + k) / n) % m;\\n            int new_x = (ori_x + k) % n;\\n            \\n            ans[new_y][new_x] = grid[ori_y][ori_x];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934852,
                "title": "python-3-lines-3-steps-clean-and-simple-solution",
                "content": "\\n**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n```\\nclass Solution(object):\\n    def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  # grid to list\\n        l = l[-k:] + l[:-k]  # shift k times\\n        return [l[i * n: i * n + n] for i in range(m)]  # list to grid\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  # grid to list\\n        l = l[-k:] + l[:-k]  # shift k times\\n        return [l[i * n: i * n + n] for i in range(m)]  # list to grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060180,
                "title": "java-100-1ms-o-m-n-matrix-to-matrix-copy-optimized-for-speed-explanation",
                "content": "This code is optimized for speed.  It usually runs in 1ms, although sometimes 2ms, as of Feb 10, 2021.  May be slower in future years if more test cases are added or running on different server.\\n\\nThis algorithm first creates a result matrix the same size as `grid[][]`, then uses two loops to copy-and-shift from `grid[][]` to the result matrix.  The result matrix is converted to a `List<List<Integer>>` in the return statement, by using the `Arrays.asList()` method.\\n\\nFor copying from the input matrix `grid[][]` to the output `result[][]` matrix, first calculate the row and column of the `grid[][]` value that will be copied to `result[0][0]` in the output result matrix.  The start row and column to copy from `grid[][]` with be the `k`th value from the rottom right end of the `grid[][]` matrix.  This start row and column are the variables `kRow` and `kCol`.  The start row and column to the output `result[][]` matrix, are `r=0` and `c=0`.  While copying, `kCol` will advance along the columns in a row, until the end of the row, then start copying from column 0 in the next row.\\n![image](https://assets.leetcode.com/users/images/16a7cd10-62f3-4410-b697-bbe760e4bbd3_1614849399.1848493.png)\\n\\nTo make the copying of each numeric value faster, the current rows of `grid` and `result` are referenced by one-dimensional array variables.  The one-dimensional array variables `innRow[]` and `outRow` are references to a single row of the matrix `grid[][]` and `result[][]` respectively.  So changing a value in `outRow[]` also changes the corresponding value in a row of `result[][]` because the changed value is actually the same memory location within both variables.  The one-dimensional arrays `innRow[]` and `outRow[]` are simply short-cuts to a single row of `grid[][]` or `result[][]`.   These one-dimensional array variables for the current rows are changed when advancing to a new row in either `grid` or `result`.  The one-dimensional array variables make the copying faster because each time a single numeric value is copied from `grid` to `result`, the compiled code only has to calculate one-dimensional references within the rows (i.e. `innRow[kCol]` or `outRow[r]`), instead repeatedly calculating two-dimensional references within a matrix (i.e. `grid[kRow][kCol]` or `result[r][c]`).\\n\\nIf useful, please upvote.\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int rowCount = grid.length;                         // Number of rows in grid.\\n        int colCount = grid[0].length;                      // Number of columns in grid.\\n        int gridCount = rowCount * colCount;                // Number of cells (i.e. values) in grid.\\n        k = k % gridCount;                                  // Limit k to max number of cells in grid.  Avoid negatives in next lines.\\n        int kCol = (gridCount - k) % colCount;              // Column to start copying from.\\n        int kRow = ((gridCount - k) % gridCount) / colCount;// Row to start copying from.\\n        int[] innRow = grid[kRow];                          // Array for the row to start copying from.\\n        int[][] result = new int[rowCount][colCount];       // Create result matrix, to hold shifted values.\\n        for (int r = 0; r < rowCount; r++) {                // Loop through \"to\" rows.\\n            int[] outRow = result[r];                       // Get row array to copy into, so only faster 1D reference in inner loop.\\n            for (int c = 0; c < colCount; c++) {            // Loop through \"to\" columns.\\n                outRow[c] = innRow[kCol];                   // Copy value from grid to result, shifting by copying.\\n                if (++kCol >= colCount) {                   // Next \"from\" column.  If at end of row...\\n                    kCol = 0;                               // Then start \"from\" columns at first column.\\n                    if (++kRow >= rowCount)                 // When starting new column, next \"from\" row.  If at end of grid...\\n                        kRow = 0;                           // Then start \"from\" rows at first row.\\n                    innRow = grid[kRow];                    // Get row array to copy from, so only faster 1D reference when copying.\\n                }\\n            }\\n        }\\n        return (List)Arrays.asList(result);                 // Return result matrix, converting it to a List<List<Integer>>.\\n    }\\n}\\n```\\n--- Update ---:\\nAfter a question about the `\"return (List)Arrays.asList(result);\"` statement in the above code, asking how this statement works, I decided to explain this further.  The `Arrays.asList(result)` is used to supposedly create a List from `result`, by creating a `List<List<Integer>>` from the `int[][] result`.  But the `List<List<Integer>>` is **not** a copy of the `result` array, but instead is a `List` that contains **references into** the `result` array.  Changing a value in the `result` array will change the corresponding value in the `List`, and changing a value in the `List` will change the corresponding value in `result`, because both of these are the same value stored in a single memory location, with two different paths to access that value.  The `List` created by `Arrays.asList(...)` is also a **fixed** size `List` which cannot be added to and cannot be removed from.  In other words, the `List` resulting from `Arrays.asList(...)` is not a normal simple `List`.\\n\\nI am not completely sure why the cast `(List)` is needed before the `Arrays.asList`, but the compiler is unhappy without this cast.\\n\\nI used `(List)Arrays.asList(result)` because I assumed `Arrays.asList` could create the List of Lists faster than writing my own code to create the Lists one value at a time.  I have not tested to see if this method is faster than writing my own code to create the List of Lists.\\n\\nAnother curious thing is inserting the following lines before the `return` statement in the code above:\\n```\\n        System.out.println((Arrays.asList(result)).getClass().getName());\\n        System.out.println(((List)Arrays.asList(result)).getClass().getName());\\n        List<List<Integer>> test = new ArrayList();\\n        System.out.println(test.getClass().getName());\\n```\\nThese inserted lines of code will print the following output:\\n\\n ` ` ` ` ` ` `java.util.Arrays$ArrayList`\\n ` ` ` ` ` ` `java.util.Arrays$ArrayList`\\n ` ` ` ` ` ` `java.util.ArrayList`\\n\\nWhich shows that the `List` created by `Arrays.asList` is not quite the same as a `List` created in the more normal way.  I do not yet understand enough of the internal details of Java to explain this difference, and I cannot explain why the cast of `(List)` is needed to make the compiler happy.  If someone knows why the cast `(List)` is needed, or how Lists created by `Arrays.asList(...)` are different than normal Lists, please inform us in the comments.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int rowCount = grid.length;                         // Number of rows in grid.\\n        int colCount = grid[0].length;                      // Number of columns in grid.\\n        int gridCount = rowCount * colCount;                // Number of cells (i.e. values) in grid.\\n        k = k % gridCount;                                  // Limit k to max number of cells in grid.  Avoid negatives in next lines.\\n        int kCol = (gridCount - k) % colCount;              // Column to start copying from.\\n        int kRow = ((gridCount - k) % gridCount) / colCount;// Row to start copying from.\\n        int[] innRow = grid[kRow];                          // Array for the row to start copying from.\\n        int[][] result = new int[rowCount][colCount];       // Create result matrix, to hold shifted values.\\n        for (int r = 0; r < rowCount; r++) {                // Loop through \"to\" rows.\\n            int[] outRow = result[r];                       // Get row array to copy into, so only faster 1D reference in inner loop.\\n            for (int c = 0; c < colCount; c++) {            // Loop through \"to\" columns.\\n                outRow[c] = innRow[kCol];                   // Copy value from grid to result, shifting by copying.\\n                if (++kCol >= colCount) {                   // Next \"from\" column.  If at end of row...\\n                    kCol = 0;                               // Then start \"from\" columns at first column.\\n                    if (++kRow >= rowCount)                 // When starting new column, next \"from\" row.  If at end of grid...\\n                        kRow = 0;                           // Then start \"from\" rows at first row.\\n                    innRow = grid[kRow];                    // Get row array to copy from, so only faster 1D reference when copying.\\n                }\\n            }\\n        }\\n        return (List)Arrays.asList(result);                 // Return result matrix, converting it to a List<List<Integer>>.\\n    }\\n}\\n```\n```\\n        System.out.println((Arrays.asList(result)).getClass().getName());\\n        System.out.println(((List)Arrays.asList(result)).getClass().getName());\\n        List<List<Integer>> test = new ArrayList();\\n        System.out.println(test.getClass().getName());\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734727,
                "title": "javascript-es6-simple-solution",
                "content": "Brief explanation: \\n1. Convert the matrix to an array \\n2. Move the array bottom to the start K times\\n3. Convert the array back to a matrix and return \\n\\n```\\nvar shiftGrid = function (grid, k) {\\n  var arr = grid.flat(),\\n    len = grid[0].length,\\n    res = [];\\n\\n  while (k--) {\\n    arr.unshift(arr.pop());\\n  }\\n\\n  while (arr.length) {\\n    res.push(arr.splice(0, len));\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function (grid, k) {\\n  var arr = grid.flat(),\\n    len = grid[0].length,\\n    res = [];\\n\\n  while (k--) {\\n    arr.unshift(arr.pop());\\n  }\\n\\n  while (arr.length) {\\n    res.push(arr.splice(0, len));\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434335,
                "title": "python3-2-simple-approaches-with-explanations-by-creating-a-vector",
                "content": "# **Algorithm:**\\n1)  put the matrix row by row to a vector.\\n2)  rotate the vector k times.\\n3)  put the vector to the matrix back the same way.\\n\\nThe **second step** is the same as problem [#189 (Rotate an Array)](https://leetcode.com/problems/rotate-array/), and can be solved in many ways, but here we consider **two approaches** that are simple and have reasonable time and space complexities: \\n**(a) direct shift approach**\\n**(b) reverse approach**\\n\\nAs an example of **Approach (a)**, imagine we want to rotate the vector [1, 2, 3, 4, 5, 6, 7] for k = 3 times. We just need to add these two subsets of the vector, respectively: last k elements and first len(vec)-k elements:\\n[5, 6, 7] +  [1, 2, 3, 4] = [5, 6, 7, 1, 2, 3, 4]\\n\\nAn example of **Approach (b)**:\\nreverse all elements     : [7, 6, 5, 4, 3, 2, 1]\\nreverse first k elements : [5, 6, 7, 4, 3, 2, 1]\\nreverse last len(vec)-k elements : [5, 6, 7, 1, 2, 3, 4]\\n\\nAlthough approach (a) seems simpler, it take additional space (needs an extra vector in addition to the vector created in step 1). Approach (b) might need extra code lines, but does not take additional space.\\n\\n# **Python3 codes:**\\n\\n**Approach (a), direct shift:**\\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        #dimensions:\\n\\t\\tNR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        #If k is greater than the length of vector, \\n\\t\\t#the shift will repeat itself in a cycle; \\n\\t\\t#hence, we only care about the remainder.\\n        k = k % (NR * NC)  \\n        \\n\\t\\t#step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by direct shift approach\\n        vec = vec[-k:] + vec[:-k]\\n\\t\\t\\n        # step 3: put vector to matrix back the same way\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n```\\n\\n\\n**Approach (b), reverse method**: (Note that only step 2 has changed):\\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        # dimensions:\\n        NR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        # If k is greater than the length of vector, \\n\\t\\t# the shift will repeat itself in a cycle; \\n\\t\\t# hence, we only care about the remainder.\\n        k = k % (NR * NC)\\n\\t\\t\\n        #step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by reverse approach.\\n        self.Rev(vec, 0, NR * NC - 1) #reverse all elements.\\n        self.Rev(vec, 0, k-1)       #reverse first k elements.\\n        self.Rev(vec, k, NR * NC - 1) #revere last len(vec)-k elements. \\n        \\n        #step 3: put the vector to the matrix back the same way.\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n\\t\\t\\n    # This function returns the reverse a subset of the vector,\\n\\t# bound by \"left\" and \"right\" elements\\n    def Rev(self, vec, left, right):\\n        while left < right:\\n            vec[left], vec[right] = vec[right], vec[left]\\n            left += 1 \\n            right -= 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        #dimensions:\\n\\t\\tNR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        #If k is greater than the length of vector, \\n\\t\\t#the shift will repeat itself in a cycle; \\n\\t\\t#hence, we only care about the remainder.\\n        k = k % (NR * NC)  \\n        \\n\\t\\t#step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by direct shift approach\\n        vec = vec[-k:] + vec[:-k]\\n\\t\\t\\n        # step 3: put vector to matrix back the same way\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n```\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        # dimensions:\\n        NR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        # If k is greater than the length of vector, \\n\\t\\t# the shift will repeat itself in a cycle; \\n\\t\\t# hence, we only care about the remainder.\\n        k = k % (NR * NC)\\n\\t\\t\\n        #step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by reverse approach.\\n        self.Rev(vec, 0, NR * NC - 1) #reverse all elements.\\n        self.Rev(vec, 0, k-1)       #reverse first k elements.\\n        self.Rev(vec, k, NR * NC - 1) #revere last len(vec)-k elements. \\n        \\n        #step 3: put the vector to the matrix back the same way.\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n\\t\\t\\n    # This function returns the reverse a subset of the vector,\\n\\t# bound by \"left\" and \"right\" elements\\n    def Rev(self, vec, left, right):\\n        while left < right:\\n            vec[left], vec[right] = vec[right], vec[left]\\n            left += 1 \\n            right -= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1934644,
                "title": "c-flatten-array-then-convert-back-to-2d-struggled-live-on-stream",
                "content": "This one was tricky for me, had to get lots of help from chat.\\n\\nWe stream everyday 6PM PT.  There are dozens of us.  Link in profile.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ROWS = grid.size();\\n        int COLS = grid[0].size();\\n        \\n        int total = ROWS * COLS;\\n        \\n        vector<vector<int>> ans(ROWS, vector<int>(COLS, 0));\\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int flatI = r * COLS + c;\\n                \\n                int newFlatI = (flatI + k) % total;\\n                \\n                int nr = newFlatI / COLS;\\n                int nc = newFlatI % COLS;\\n                ans[nr][nc] = grid[r][c];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ROWS = grid.size();\\n        int COLS = grid[0].size();\\n        \\n        int total = ROWS * COLS;\\n        \\n        vector<vector<int>> ans(ROWS, vector<int>(COLS, 0));\\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int flatI = r * COLS + c;\\n                \\n                int newFlatI = (flatI + k) % total;\\n                \\n                int nr = newFlatI / COLS;\\n                int nc = newFlatI % COLS;\\n                ans[nr][nc] = grid[r][c];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937723,
                "title": "python-2-solutions-clean-concise-easy-o-1-in-space-complexity",
                "content": "- If we treat grid as an array, we can solve this problem as the same idea with **[189. Rotate Array](https://leetcode.com/problems/rotate-array/discuss/258789/)** problem.\\n- That is, the index of the array `idx`, will be map with the grid cell at `grid[idx // nCols][idx % nCols]`.\\n\\n**\\u2714\\uFE0F Solution 1: Using Extra Space**\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        \\n        n = nRows * nCols\\n        arr = [0] * n\\n        for i in range(n):\\n            idx = (i + n - k) % n\\n            arr[i] = grid[idx // nCols][idx % nCols]\\n        \\n        for i in range(len(arr)):\\n            grid[i // nCols][i % nCols] = arr[i]\\n        return grid\\n```\\nComplexity:\\n- Time: `O(nRows * nCols)`\\n- Space: `O(nRows * nCols)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Reverse in splace**\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        n = nRows * nCols\\n        \\n        def reverse(grid, left, right):\\n            while left < right:\\n                grid[left//nCols][left%nCols], grid[right//nCols][right%nCols] = grid[right//nCols][right%nCols], grid[left//nCols][left%nCols]\\n                left += 1\\n                right -= 1\\n                \\n        reverse(grid, 0, n-1)\\n        reverse(grid, 0, k-1)\\n        reverse(grid, k, n-1)\\n        return grid\\n```\\nComplexity:\\n- Time: `O(nRows * nCols)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        \\n        n = nRows * nCols\\n        arr = [0] * n\\n        for i in range(n):\\n            idx = (i + n - k) % n\\n            arr[i] = grid[idx // nCols][idx % nCols]\\n        \\n        for i in range(len(arr)):\\n            grid[i // nCols][i % nCols] = arr[i]\\n        return grid\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        n = nRows * nCols\\n        \\n        def reverse(grid, left, right):\\n            while left < right:\\n                grid[left//nCols][left%nCols], grid[right//nCols][right%nCols] = grid[right//nCols][right%nCols], grid[left//nCols][left%nCols]\\n                left += 1\\n                right -= 1\\n                \\n        reverse(grid, 0, n-1)\\n        reverse(grid, 0, k-1)\\n        reverse(grid, k, n-1)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934795,
                "title": "c-two-approaches-with-intuition",
                "content": "# Shift 2D Grid\\nThe problem at hand requires us to shift a 2D grid to the right cyclically k times. It is the equivalent of applying right shift operation k times.\\nOne right shift operation does the following:\\n(i,j) becomes (i, j+1)\\nif j == n-1, then it becomes (i+1, 0)\\nif j == n-1 and i == m-1, then it becomes (0, 0)\\n\\n## Approach 1 Calculate Indices for each element\\nIn this approach, we make a copy of the entire matrix, and then fill it with the corresponding elements according to the shifted coordinates.\\n```\\npair<int, int> shift(int i, int j, int k) {\\n\\tj+=k;\\n\\tif(j >= n) {\\n\\t\\ti += j/n;\\n\\t\\tj = j%n;\\n\\t}\\n\\tif(i >= m) {\\n\\t\\ti = i%m;\\n\\t}\\n\\treturn {i,j};\\n}\\n```\\nThe above function gives the shifted coordinates given the original coordinates and the shifted amount. We could call this function at every (i,j) in the matrix and fill the corresponding place.\\n\\nBut this approach would be slow, as we would have to make O(m*n) calls just to this function.\\nA better way to do this is to just call it once for the starting point, and then keep right shifting once for every subsequent element.\\n\\n```\\nnj++;\\nif(nj == n) {\\n\\tni++;\\n\\tnj = 0;\\n}\\nif(ni == m) {\\n\\tni = 0;\\n}\\n```\\n\\nThis code calculates the next position given the new position of the previous point (ni, nj)\\n\\nSo the full code for this approach is as follows:\\n### Code (C++)\\n```\\nclass Solution {\\n    int m, n;\\n    pair<int, int> shift(int i, int j, int k) {\\n        j+=k;\\n        if(j >= n) {\\n            i += j/n;\\n            j = j%n;\\n        }\\n        if(i >= m) {\\n            i = i%m;\\n        }\\n        return {i,j};\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> newGrid(m, vector<int>(n));\\n        auto [ni, nj] = shift(0, 0, k);\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                newGrid[ni][nj] = grid[i][j];\\n                nj++;\\n                if(nj == n) {\\n                    ni++;\\n                    nj = 0;\\n                }\\n                if(ni == m) {\\n                    ni = 0;\\n                }\\n            }\\n        }\\n        return newGrid;\\n    }\\n};\\n```\\n\\n### Complexity\\n**Time Complexity:** O(m * n)\\n**Space Complexity:** O(m * n) (for returning the new matrix)\\n\\n## Approach 2: Treat Matrix as Array and Right Shift k Times\\nWe already have a good approach for right shifting an array k times;\\n```\\nreverse(arr, 0, n-1);\\nreverse(arr, 0, k-1);\\nreverse(arr, k, n-1);\\n```\\nIf we can treat the whole matrix as a flat array, we can apply the same algorithm and solve this question very easily.\\nTo do this, we can\\'t use the normal reverse function, as it warrants flattening the matrix, which we actually don\\'t need. We just need to *pretend* that the matrix is flattened..\\nThis is accomplished by taking the array coordinates and mapping them to row and column indices underneath.\\n```\\nvoid reverse(vector<vector<int>>& grid, int l, int r) {\\n\\twhile(l<r) {\\n\\t\\tint lr = l/n, lc = l%n;\\n\\t\\tint rr = r/n, rc = r%n;\\n\\t\\tif(rr == m) rr = 0;\\n\\t\\tswap(grid[lr][lc], grid[rr][rc]);\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n}\\n```\\nOnce this modification is made, the whole problem reduces to just three more statements\\n```\\nreverse(grid, 0, m*n-1);\\nreverse(grid, 0, k-1);\\nreverse(grid, k, m*n-1);\\n```\\n\\n### Code (C++) \\n```\\nclass Solution {\\n    int m, n;\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l<r) {\\n            int lr = l/n, lc = l%n;\\n            int rr = r/n, rc = r%n;\\n            if(rr == m) rr = 0;\\n            swap(grid[lr][lc], grid[rr][rc]);\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n);\\n        if(k == 0) return grid;\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        return grid;\\n    }\\n};\\n```\\n\\n### Caution!\\nThis code modifies the input matrix itself.\\nI regard this as a *hacky* way of achieving O(1) extra space, since one is bound to require some space for storing the output of the program. Plus this approach can lead to loss of information if implemented incorrectly. So take care while using it, or just make a copy of the input matrix and apply this algorithm on it instead.\\n\\n### Complexity\\n**Time Complexity:** O(m * n)\\n**Space Complexity:** O(1) (see above Caution)\\n\\n\\n**Upvote** if you liked this post and would like to see more of these in the future. Leave any doubts or suggestions in the comments.\\nDo you agree with the notion of modifying the input itself in order to get O(1) space?",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npair<int, int> shift(int i, int j, int k) {\\n\\tj+=k;\\n\\tif(j >= n) {\\n\\t\\ti += j/n;\\n\\t\\tj = j%n;\\n\\t}\\n\\tif(i >= m) {\\n\\t\\ti = i%m;\\n\\t}\\n\\treturn {i,j};\\n}\\n```\n```\\nnj++;\\nif(nj == n) {\\n\\tni++;\\n\\tnj = 0;\\n}\\nif(ni == m) {\\n\\tni = 0;\\n}\\n```\n```\\nclass Solution {\\n    int m, n;\\n    pair<int, int> shift(int i, int j, int k) {\\n        j+=k;\\n        if(j >= n) {\\n            i += j/n;\\n            j = j%n;\\n        }\\n        if(i >= m) {\\n            i = i%m;\\n        }\\n        return {i,j};\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> newGrid(m, vector<int>(n));\\n        auto [ni, nj] = shift(0, 0, k);\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                newGrid[ni][nj] = grid[i][j];\\n                nj++;\\n                if(nj == n) {\\n                    ni++;\\n                    nj = 0;\\n                }\\n                if(ni == m) {\\n                    ni = 0;\\n                }\\n            }\\n        }\\n        return newGrid;\\n    }\\n};\\n```\n```\\nreverse(arr, 0, n-1);\\nreverse(arr, 0, k-1);\\nreverse(arr, k, n-1);\\n```\n```\\nvoid reverse(vector<vector<int>>& grid, int l, int r) {\\n\\twhile(l<r) {\\n\\t\\tint lr = l/n, lc = l%n;\\n\\t\\tint rr = r/n, rc = r%n;\\n\\t\\tif(rr == m) rr = 0;\\n\\t\\tswap(grid[lr][lc], grid[rr][rc]);\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n}\\n```\n```\\nreverse(grid, 0, m*n-1);\\nreverse(grid, 0, k-1);\\nreverse(grid, k, m*n-1);\\n```\n```\\nclass Solution {\\n    int m, n;\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l<r) {\\n            int lr = l/n, lc = l%n;\\n            int rr = r/n, rc = r%n;\\n            if(rr == m) rr = 0;\\n            swap(grid[lr][lc], grid[rr][rc]);\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n);\\n        if(k == 0) return grid;\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708897,
                "title": "java-simple-one-loop",
                "content": "```\\n    public List<List<Integer>> shiftGrid(int[][] g, int k) {\\n        int m = g.length, n = g[0].length, tot = m * n;\\n        List<List<Integer>> res= new ArrayList<>();\\n        k = k % tot;\\n        for (int i = 0; i < m; i++) res.add(new ArrayList<>());\\n        for (int l = 0; l < tot; l++) {\\n            int idx = (l - k + tot) % tot;\\n            res.get(l / n).add(g[idx / n][idx % n]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> shiftGrid(int[][] g, int k) {\\n        int m = g.length, n = g[0].length, tot = m * n;\\n        List<List<Integer>> res= new ArrayList<>();\\n        k = k % tot;\\n        for (int i = 0; i < m; i++) res.add(new ArrayList<>());\\n        for (int l = 0; l < tot; l++) {\\n            int idx = (l - k + tot) % tot;\\n            res.get(l / n).add(g[idx / n][idx % n]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935498,
                "title": "c-intuitive-approach-clean-solution-with-comments",
                "content": "Make a 1-D vector and push all element in that\\nNow calculate the index from which the modified grid will be started and then update the grid\\n| PLEASE UPVOTE IF YOU LIKE THE SOLUTION |\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>temp;\\n        int mod=m*n;\\n        \\n        //push all elements in a 1-d array\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        k=k%mod;\\n        \\n        // if k==0 then no shifting is done so return original grid\\n        if(k==0)return grid;\\n        \\n        // elements in last row are shifted to 1st row that\\'s why we start from mod-k index i.e kth element from last\\n        \\n        int idx=mod-k;\\n        \\n        // now update grid according to shifting\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j]=temp[idx];\\n                idx=(idx+1)%mod;\\n            }\\n        }      \\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>temp;\\n        int mod=m*n;\\n        \\n        //push all elements in a 1-d array\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        k=k%mod;\\n        \\n        // if k==0 then no shifting is done so return original grid\\n        if(k==0)return grid;\\n        \\n        // elements in last row are shifted to 1st row that\\'s why we start from mod-k index i.e kth element from last\\n        \\n        int idx=mod-k;\\n        \\n        // now update grid according to shifting\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j]=temp[idx];\\n                idx=(idx+1)%mod;\\n            }\\n        }      \\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934690,
                "title": "very-simple-solution",
                "content": "```\\n// Please upvote if you like my solution :)\\nvoid reverse(vector<int> &nums,int start,int end){\\n        for(int i=start,j=end;i<j;i++,j--){\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ro = grid.size();\\n        int col = grid[0].size();\\n        vector<int> v;\\n        for(auto &gri:grid){\\n            for(auto &val:gri){\\n                v.push_back(val);\\n            }\\n        }\\n        k = k % v.size();\\n        reverse(v,0,v.size()-k-1);\\n        reverse(v,v.size()-k,v.size()-1);\\n        reverse(v,0,v.size()-1);\\n        int vec = 0;\\n        for(int i=0;i<ro;i++){\\n            for(int j=0;j<col;j++){\\n                grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n// Please upvote if you like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n// Please upvote if you like my solution :)\\nvoid reverse(vector<int> &nums,int start,int end){\\n        for(int i=start,j=end;i<j;i++,j--){\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ro = grid.size();\\n        int col = grid[0].size();\\n        vector<int> v;\\n        for(auto &gri:grid){\\n            for(auto &val:gri){\\n                v.push_back(val);\\n            }\\n        }\\n        k = k % v.size();\\n        reverse(v,0,v.size()-k-1);\\n        reverse(v,v.size()-k,v.size()-1);\\n        reverse(v,0,v.size()-1);\\n        int vec = 0;\\n        for(int i=0;i<ro;i++){\\n            for(int j=0;j<col;j++){\\n                grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n// Please upvote if you like my solution :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516488,
                "title": "c-clean-code-98-runtime-100-space",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res (m, vector<int> (n, 0));\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                int newCol = (j+k)%n;\\n                int countWrapArounds = (j+k)/n;\\n                int newRow = (i+countWrapArounds)%m;\\n                res[newRow][newCol] = grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res (m, vector<int> (n, 0));\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                int newCol = (j+k)%n;\\n                int countWrapArounds = (j+k)/n;\\n                int newRow = (i+countWrapArounds)%m;\\n                res[newRow][newCol] = grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934572,
                "title": "java-simple-solution-time-o-n-space-o-1-faster-than-95-74",
                "content": "If the return ArrayList does not count space then its space complexity is O(1).\\nThe time complexity is O(n) where n is the count of all grid items.\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m * n;\\n        // if shifting total times, it shifts back to orignal state\\n        k = k % (total);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i = 0; i < m; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            result.add(list);\\n            for (int j = 0; j < n; j++) {   \\n                // i * n + j original place index in 1D array\\n                // i * n + j - k  is to get value k steps before                 \\n                int index = ((i * n + j) - k + total) % total;\\n                list.add(grid[index / n][index % n]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m * n;\\n        // if shifting total times, it shifts back to orignal state\\n        k = k % (total);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i = 0; i < m; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            result.add(list);\\n            for (int j = 0; j < n; j++) {   \\n                // i * n + j original place index in 1D array\\n                // i * n + j - k  is to get value k steps before                 \\n                int index = ((i * n + j) - k + total) % total;\\n                list.add(grid[index / n][index % n]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936908,
                "title": "conceptually-straightforward-javascript-solution-nested-unshift-pop-76ms",
                "content": "My first concrete idea was a map adding each element by k % n or some sort of length but then the pop push shift came to mind and was more straight forward for me to implement. \\n\\nIt works the way I visualize the matrix to shift in the example. The element at the end of each row is popped off and unshifted to the beginning of the next. The last row wraps around to the first row with the modulo. \\n\\nMy fastest submission was 68ms - 100% \\n```javascript\\nvar shiftGrid = function(grid, k) {\\n    m = grid.length;\\n    n = grid[0].length;\\n\\n    for(let j = 0; j < k; j++){\\n        for(let i = 0; i < (m); i++){\\n            grid[i].unshift(grid[((m + i -1) % (m))].pop()); \\n        }\\n    }\\n    return grid;\\n};\\n```\\n\\nMy fastest submission was 78ms -- 100% as of 4/11\\n\\n![image](https://assets.leetcode.com/users/images/794f6eed-1983-4020-8bd8-68d7cb788a37_1649695793.5833466.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar shiftGrid = function(grid, k) {\\n    m = grid.length;\\n    n = grid[0].length;\\n\\n    for(let j = 0; j < k; j++){\\n        for(let i = 0; i < (m); i++){\\n            grid[i].unshift(grid[((m + i -1) % (m))].pop()); \\n        }\\n    }\\n    return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934734,
                "title": "python-in-place-solution-with-explanation",
                "content": "### Introduction\\n\\nGiven a 2D array `grid`, we want to return the array after its elements have been shifted to the right (wrapped by rows) by `k` positions.\\n\\nMany solutions involve initialising the resultant array and mapping each element in the original array to its final position in the resultant array. However, these solutions require O(mn) space (note: O(1) auxiliary space, but O(mn) space), where `m` is the number of rows in `grid` and `n` is the number of columns in `grid`.\\n\\nThis post presents an in-place solution; we are able to get the resultant array by modifying the original array. And yes, this will be done in the most optimal way possible; the time complexity for this solution is O(mn), which is comparable to many other solutions.\\n\\n---\\n\\n### Explanation\\n\\nThe main logic behind how the code operates is as follows: Upon mapping an element from its original index to its resultant index, **we will swap the element at the current index with the resultant element, and continue by finding the resultant index for the new element**. We do this until either 1) all the elements have been swapped; or 2) we reaxh the initial index. To illustrate, the following sequence is for one shift operation, i.e., `k = 1`:\\n\\n```text\\n1 2 3    _ 2 3    _ 1 3    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    9 1 2\\n4 5 6 -> 4 5 6 -> 4 5 6 -> 4 5 6 -> 3 5 6 -> 3 4 6 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5\\n7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    6 8 9    6 7 9    6 7 8    6 7 8\\nstart    cur=1    cur=2    cur=3    cur=4    cur=5    cur=6    cur=7    cur=8    cur=9     end\\n```\\n\\nSometimes, we will end up on the initial index before all the elements have been successfully swapped. Take for example:\\n\\n```text\\nk = 4\\n1 2 3    _ 2 3    _ 2 3    _ 2 5    3 2 5\\n4 5 6 -> 4 5 6 -> 4 1 6 -> 4 1 6 -> 4 1 6\\nstart    cur=1    cur=5    cur=3    cur=_\\n```\\n\\nIn such instances, **we would need to increment the initial index by 1 and continue with the next element**. Note that if we know that some elements have not yet been swapped, then we know that the element after the index has incremented by 1 has not been swapped, since if `k = 1`, all the elements would have been swapped before the initial index has been reached.\\n\\n---\\n\\n### Approach 1: GCD\\n\\nHow then do we know if the loop will reach the initial index before all elements are swapped, and how many times do we need to increment the initial index? **One way is to use the greatest common divisor (GCD) between the number of elements in `grid` and `k`, which gives us the number of times we need to increment the initial index**.\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:  # after k shifts, final array = grid\\n            return grid\\n        div = gcd(m*n, k)  # math.gcd\\n        for i in range(div):\\n            r, c = divmod(i, n)\\n            curr = grid[r][c]  # obtain initial element\\n            for j in range(m*n//div):\\n                r, c = divmod((i+k*(j+1))%(m*n), n)  # get the resultant index\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n        return grid\\n ```\\n \\n **TC: O(mn)**, since each index is looped through only once.\\n Note: for time complexity of `math.gcd()`, you can read more [here](https://codility.com/media/train/10-Gcd.pdf).\\n **SC: O(1)**, as discussed previously.\\n \\n ---\\n \\n ### Approach 2: Counter\\n \\n A simpler way to determine if all elements have been swapped is to **have a counter for the number of elements that have been swapped so far**. If there are elements left to swap, increment the initial index; otherwise, return the resultant array.\\n \\n ```python\\n class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:\\n            return grid\\n        count = i = 0\\n        while count < m*n:\\n            r, c = divmod(i, n)\\n            curr, j = grid[r][c], (i+k)%(m*n)  # get initial element and its final position\\n            while True:\\n                r, c = divmod(j, n)\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n                count += 1  # increment swap counter\\n                if j == i:  # initial index reached\\n                    break\\n                j = (j+k)%(m*n)\\n            i += 1  # increment initial index if not all elements have been swapped\\n        return grid\\n```\\n\\n**TC: O(mn)**, as discussed previously.\\n**SC: O(1)**, as discussed previously.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [],
                "code": "```text\\n1 2 3    _ 2 3    _ 1 3    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    9 1 2\\n4 5 6 -> 4 5 6 -> 4 5 6 -> 4 5 6 -> 3 5 6 -> 3 4 6 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5\\n7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    6 8 9    6 7 9    6 7 8    6 7 8\\nstart    cur=1    cur=2    cur=3    cur=4    cur=5    cur=6    cur=7    cur=8    cur=9     end\\n```\n```text\\nk = 4\\n1 2 3    _ 2 3    _ 2 3    _ 2 5    3 2 5\\n4 5 6 -> 4 5 6 -> 4 1 6 -> 4 1 6 -> 4 1 6\\nstart    cur=1    cur=5    cur=3    cur=_\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:  # after k shifts, final array = grid\\n            return grid\\n        div = gcd(m*n, k)  # math.gcd\\n        for i in range(div):\\n            r, c = divmod(i, n)\\n            curr = grid[r][c]  # obtain initial element\\n            for j in range(m*n//div):\\n                r, c = divmod((i+k*(j+1))%(m*n), n)  # get the resultant index\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n        return grid\\n ```\n```python\\n class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:\\n            return grid\\n        count = i = 0\\n        while count < m*n:\\n            r, c = divmod(i, n)\\n            curr, j = grid[r][c], (i+k)%(m*n)  # get initial element and its final position\\n            while True:\\n                r, c = divmod(j, n)\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n                count += 1  # increment swap counter\\n                if j == i:  # initial index reached\\n                    break\\n                j = (j+k)%(m*n)\\n            i += 1  # increment initial index if not all elements have been swapped\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431311,
                "title": "easy-solution-with-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> temp;\\n        temp = grid;\\n        int n = grid.size(), m = grid[0].size();\\n        while(k--){\\n            for(int i = 0; i < n; ++i){\\n                for(int j = 1; j < m; ++j){\\n                    temp[i][j] = grid[i][j-1];\\n                }\\n                    \\n            }\\n            for(int i = 0; i < n-1; ++i){\\n                temp[i+1][0] = grid[i][m-1];\\n            }\\n            temp[0][0] = grid[n-1][m-1]; // special case\\n            grid = temp;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> temp;\\n        temp = grid;\\n        int n = grid.size(), m = grid[0].size();\\n        while(k--){\\n            for(int i = 0; i < n; ++i){\\n                for(int j = 1; j < m; ++j){\\n                    temp[i][j] = grid[i][j-1];\\n                }\\n                    \\n            }\\n            for(int i = 0; i < n-1; ++i){\\n                temp[i+1][0] = grid[i][m-1];\\n            }\\n            temp[0][0] = grid[n-1][m-1]; // special case\\n            grid = temp;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934602,
                "title": "4-liner-code-of-c-without-k-times-rotation",
                "content": "**C++ Easy Solution Without Actually Rotating Matrix K times \\n4 Liner Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>>arr(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                arr[(i+(j+k)/grid[i].size())%grid.size()][(j+k)%grid[i].size()]=grid[i][j];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```\\n**Please Upvote and Like**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>>arr(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                arr[(i+(j+k)/grid[i].size())%grid.size()][(j+k)%grid[i].size()]=grid[i][j];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935964,
                "title": "python-o-mn-solution-explained",
                "content": "Let us create `ans` with zeroes. Then for each element we calculate where it should go and fill this element.\\n\\n#### Complexity\\nIt is `O(mn)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def shiftGrid(self, G, k):\\n        m, n = len(G), len(G[0])\\n        ans = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                delta, c2 = divmod(c + k, n)\\n                ans[(r + delta) % m][c2] = G[r][c]\\n                \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, G, k):\\n        m, n = len(G), len(G[0])\\n        ans = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                delta, c2 = divmod(c + k, n)\\n                ans[(r + delta) % m][c2] = G[r][c]\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935910,
                "title": "just-flatten-and-rotate-the-array",
                "content": "**OBSERVATION:**\\nIf we trace the path of any number/index as we do the operation multiple times we find that the number is merely traversing the matrix row-wise. Take 1 for example and look at its path.\\n\\n1. This gives us an idea to flatten out the array and rotate it k times to get the final matrix in Row Major Order. \\n2. One other thing to notice is that after M X N number of operations, the resulting matrix is the original matrix. Hence we can update k as **`k = k % ( m * n )`.** \\n3. The rotation algorithm can be practiced from [Leetcode 189. Rotate Array](https://leetcode.com/problems/rotate-array/).\\n\\n![image](https://assets.leetcode.com/users/images/9d02625d-10dc-4598-88d5-0ae7d26efc96_1649671829.3801272.png)\\n\\n**STEPS:**\\n1. Flatten out the array.\\n2. Rotate the array k times.\\n3. Resulting list is a Row Major representation of our answer array. So convert this 1d Array to 2d Matrix.\\n\\n\\n**CODE:**\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array\\n        n = len(nums)\\n        k = k % n\\n        nums[:] = nums[n - k:] + nums[:n - k]\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        arr = [i for sublist in grid for i in sublist] # Flatten out the array\\n        self.rotate(arr,k) # Rotate the array \\n        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix\\n        return grid # Return 2d Result\\n```\\n**NOTE:** \\n**`grid = [[arr[i*n+j] for j in range(n)] for i in range(m)]`** is just a shorter way for doing the following:\\n```\\ngrid = []\\nfor i in range(m):\\n    temp = []\\n    for j in range(n):\\n        temp.append(arr[i*n+j])\\n    grid.append(temp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array\\n        n = len(nums)\\n        k = k % n\\n        nums[:] = nums[n - k:] + nums[:n - k]\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        arr = [i for sublist in grid for i in sublist] # Flatten out the array\\n        self.rotate(arr,k) # Rotate the array \\n        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix\\n        return grid # Return 2d Result\\n```\n```\\ngrid = []\\nfor i in range(m):\\n    temp = []\\n    for j in range(n):\\n        temp.append(arr[i*n+j])\\n    grid.append(temp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598647,
                "title": "c-neat-easily-understandable-indented-code",
                "content": "I have used deque from the STL library.\\n\\n```\\nauto speedup=[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& G, int k) \\n    {\\n        int m= G.size();\\n        int n= G[0].size();\\n        \\n        deque <int> tmp {};\\n\\n        for(auto i=0; i<m; i++)\\n\\t        for(auto j=0; j<n; j++)\\n                tmp.push_back(G[i][j]);\\n    \\n        while(k--)\\n\\t    {\\n            int b= tmp.back();\\n            tmp.pop_back();\\n            tmp.push_front(b);\\n        }\\n\\n        for(auto i=0; i<m; i++)\\n        {\\n\\t        for(auto j=0; j<n; j++)\\n\\t        { \\n                G[i][j]= tmp.front();\\n                tmp.pop_front();\\n\\t        }\\n        }\\n        return G;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto speedup=[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& G, int k) \\n    {\\n        int m= G.size();\\n        int n= G[0].size();\\n        \\n        deque <int> tmp {};\\n\\n        for(auto i=0; i<m; i++)\\n\\t        for(auto j=0; j<n; j++)\\n                tmp.push_back(G[i][j]);\\n    \\n        while(k--)\\n\\t    {\\n            int b= tmp.back();\\n            tmp.pop_back();\\n            tmp.push_front(b);\\n        }\\n\\n        for(auto i=0; i<m; i++)\\n        {\\n\\t        for(auto j=0; j<n; j++)\\n\\t        { \\n                G[i][j]= tmp.front();\\n                tmp.pop_front();\\n\\t        }\\n        }\\n        return G;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 488404,
                "title": "python-simple-o-m-n-95-100-extra-space-used",
                "content": "```\\n    def shiftGrid(self, grid, k):\\n        \\n        k = k % (len(grid) * len(grid[0]))\\n        \\n        linear = []\\n        for level in grid :\\n            linear.extend(level)\\n        \\n        linear = linear[-k:] + linear[:-k]\\n        l = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j] = linear[l]\\n                l += 1\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def shiftGrid(self, grid, k):\\n        \\n        k = k % (len(grid) * len(grid[0]))\\n        \\n        linear = []\\n        for level in grid :\\n            linear.extend(level)\\n        \\n        linear = linear[-k:] + linear[:-k]\\n        l = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j] = linear[l]\\n                l += 1\\n        \\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 433298,
                "title": "javascript-solution-with-comments",
                "content": "this might not be the most efficient way but at least makes sence:\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    if(!grid.length || k < 1) return grid\\n    \\n    // first flatten the array \\n    let flattened = grid.reduce((acc, el) => {\\n        return acc.concat(el)\\n    },[])\\n    \\n    // now that we have one array, just rotate it k times\\n    for(let i = 0; i < k; i++) {\\n        flattened.unshift(flattened.pop())\\n    }\\n    \\n    // turn it back into a grid\\n    let res = []\\n    let size = grid[0].length\\n      for(let i = 0; i < flattened.length; i = i+size)\\n      res.push(flattened.slice(i,i+size));\\n      return res;\\n};",
                "solutionTags": [],
                "code": "this might not be the most efficient way but at least makes sence:\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    if(!grid.length || k < 1) return grid\\n    \\n    // first flatten the array \\n    let flattened = grid.reduce((acc, el) => {\\n        return acc.concat(el)\\n    },[])\\n    \\n    // now that we have one array, just rotate it k times\\n    for(let i = 0; i < k; i++) {\\n        flattened.unshift(flattened.pop())\\n    }\\n    \\n    // turn it back into a grid\\n    let res = []\\n    let size = grid[0].length\\n      for(let i = 0; i < flattened.length; i = i+size)\\n      res.push(flattened.slice(i,i+size));\\n      return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1937275,
                "title": "c-very-easy-to-logic",
                "content": "I would suggest just dry run the code and you will get the intution.\\n\\n```class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<row;i++)\\n            {\\n                for(int j=col-1;j>=1;j--)\\n                {\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n            for(int i=row-1;i>=1;i--)\\n            {\\n                swap(grid[i][0],grid[i-1][0]);\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<row;i++)\\n            {\\n                for(int j=col-1;j>=1;j--)\\n                {\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1934777,
                "title": "java-easy-to-understand-explanation-iterate-and-add-as-though-a-1d-array",
                "content": "**Understanding the fundamentals**\\n\\nConsider a single dimensional array of size n :\\na[[1,2,3,4,5,6,7,8,9]. Here n = 9\\nFor instance, we have k=2 which means that the array should rotate clockwise twice,\\nthen array would become\\n[8,9,1,2,3,4,5,6,7]\\nyou would notice that there is a pattern while rotating.\\na[0] will be a[7] which can also be written as a[9 - 2 + 0]\\na[1] will be a[8], which can also be written as a[9 - 2 + 1]\\na[2] will be a[0] , which can also be written as a[9 - 2 + 2] - but a[9] is not there, so we need to do a modulus on 9 to get a[0]\\n... and so on,\\n\\nWe need to concentrate on the pivot position to arrive at the generalized formula to find the value at given index after rotation\\nIn a nutshell, if you need to rotate an array k elements in clockwise direction, you need to apply the formula\\n*a[i] = a[(n - k + i) % n] ---- > formula 1*\\n\\nSimilarly, if you need to rotate the array in anticlockwise direction, that is left shift twice in the above example, \\n\\nthe array [1,2,3,4,5,6,7,8,9] would become [3,4,5,6,7,8,9,1,2]\\nHere a[0] = a[2] which can also be written as a[(9 + 2 + 0) % 9]\\na[1] = a[3], which can also be written as a[(9 + 2 + 1)% 9]...\\nand so on,\\na[7] = a[0] which can also be written as a[(9 + 2 + 7) % 9]\\nthus, general formula in this case can be written as \\n*a[i] = a[(n + k + i ) % n]*\\n\\n**Applying 1D array rotation  logic to 2D array**\\nNow that you have understood how the array rotation in 1D array works, lets apply the logic on 2D array of size m*n;\\nHere, total number of elements would be m * n\\neach row will contain n elements\\nSo, to find out where the xth element in the 1D representation would fit in,\\n*m = x/n; --- > formula 2*\\n*n = x%n; ---- > formula 3*\\n\\nNow in the given question, you are expecting an arraylist which in turn contains arraylist representing each row,\\n\\nSo, first we create the arraylist for each row.\\n\\nNow we apply formula 1 to get the index variable value.\\n\\nThen we use formula for getting the mth arraylist to add the grid item calculated using formula 2 and formula 3.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m*n;\\n        // the following is done to make sure that you dont rotate more than total number of times.\\n        k = k % total;\\n        List<List<Integer>> list = new ArrayList<>();\\n        // create arraylist for each row.\\n        for(int i = 0; i < m; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < total; i++) {\\n            // the index below is used to calculate m and n position\\n            // for a given row, m = index/n, n = index%n\\n            // this is while trying to iterate the array as a 1D array\\n            // with index pointing to current index of the imaginary single dimension array\\n            int index = (total - k + i) % total;\\n            // i%n gives you the list bucket to which the element should be added.\\n            list.get(i/n).add(grid[index/n][index%n]);\\n            \\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m*n;\\n        // the following is done to make sure that you dont rotate more than total number of times.\\n        k = k % total;\\n        List<List<Integer>> list = new ArrayList<>();\\n        // create arraylist for each row.\\n        for(int i = 0; i < m; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < total; i++) {\\n            // the index below is used to calculate m and n position\\n            // for a given row, m = index/n, n = index%n\\n            // this is while trying to iterate the array as a 1D array\\n            // with index pointing to current index of the imaginary single dimension array\\n            int index = (total - k + i) % total;\\n            // i%n gives you the list bucket to which the element should be added.\\n            list.get(i/n).add(grid[index/n][index%n]);\\n            \\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934646,
                "title": "java-brute-froce-slow-but-intuitive",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] temp = grid;\\n        \\n        while (k-- > 0) {\\n            // init for each loop\\n            temp = new int[n][m];\\n            \\n            // 1. shift right\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 1; j < m; j++) {\\n                    temp[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            \\n            // 2. move last one in this row to the next row\\n            for (int i = 1; i < n; i++) {\\n                temp[i][0] = grid[i - 1][m - 1];\\n            }\\n            \\n            // 3. move the last one to the first place\\n            temp[0][0] = grid[n - 1][m - 1];\\n            \\n            // repeat\\n            grid = temp;\\n        }\\n        \\n        return (List)Arrays.asList(temp);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] temp = grid;\\n        \\n        while (k-- > 0) {\\n            // init for each loop\\n            temp = new int[n][m];\\n            \\n            // 1. shift right\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 1; j < m; j++) {\\n                    temp[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            \\n            // 2. move last one in this row to the next row\\n            for (int i = 1; i < n; i++) {\\n                temp[i][0] = grid[i - 1][m - 1];\\n            }\\n            \\n            // 3. move the last one to the first place\\n            temp[0][0] = grid[n - 1][m - 1];\\n            \\n            // repeat\\n            grid = temp;\\n        }\\n        \\n        return (List)Arrays.asList(temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462152,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for(int i=0; i<n*m; i++){\\n           int temp=(i+k)%(n*m);\\n           ans[temp/n][temp%n]=grid[i/n][i%n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for(int i=0; i<n*m; i++){\\n           int temp=(i+k)%(n*m);\\n           ans[temp/n][temp%n]=grid[i/n][i%n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506983,
                "title": "easy-to-follow-go-solution",
                "content": "```\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n\\tn := len(grid)\\n\\tm := len(grid[0])\\n\\n\\tans := make([][]int, n)\\n\\tfor i := 0; i < len(ans); i++ {\\n\\t\\tans[i] = make([]int, m)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tx := (k / m) % n\\n\\t\\t\\ty := k % m\\n\\n\\t\\t\\tans[x][y] = grid[i][j]\\n\\t\\t\\tk++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n\\tn := len(grid)\\n\\tm := len(grid[0])\\n\\n\\tans := make([][]int, n)\\n\\tfor i := 0; i < len(ans); i++ {\\n\\t\\tans[i] = make([]int, m)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tx := (k / m) % n\\n\\t\\t\\ty := k % m\\n\\n\\t\\t\\tans[x][y] = grid[i][j]\\n\\t\\t\\tk++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1639737,
                "title": "99-time-99-21-memory-flatten-the-matrix-and-then-use-rotate-c",
                "content": "Space and time-complexity: O(N)\\nThis algorithm is significantly fast due to fewer cache misses/crimes. \\n\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint r=grid.size(), c=grid[0].size();\\n\\tvector<int> data(r*c);\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tdata[i*c+j] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tk %= (r*c);\\n\\trotate(data.rbegin(), data.rbegin()+k, data.rend());\\n\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tgrid[i][j] = data[i*c+j];\\n\\t\\t}\\n\\t}\\n\\treturn move(grid);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint r=grid.size(), c=grid[0].size();\\n\\tvector<int> data(r*c);\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tdata[i*c+j] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tk %= (r*c);\\n\\trotate(data.rbegin(), data.rbegin()+k, data.rend());\\n\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tgrid[i][j] = data[i*c+j];\\n\\t\\t}\\n\\t}\\n\\treturn move(grid);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462852,
                "title": "java-99-100-17-lines-solution",
                "content": "```\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int row=grid.length, col=grid[0].length;\\n        int newK=k%(row*col);\\n        List<List<Integer>> ret=new LinkedList<List<Integer>>();\\n        int endPoint= newK==0? 0:row*col-newK;\\n        int boundry=row*col;\\n        Integer newGrid[][]=new Integer[row][col];\\n        for(int i=0,j=endPoint;i<boundry;i++,j++)\\n        {\\n            if(j==boundry)\\n                j=0;\\n            newGrid[i/col][i%col]=grid[j/col][j%col];\\n        }\\n        for(Integer[] a:newGrid)\\n            ret.add(Arrays.asList(a));\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int row=grid.length, col=grid[0].length;\\n        int newK=k%(row*col);\\n        List<List<Integer>> ret=new LinkedList<List<Integer>>();\\n        int endPoint= newK==0? 0:row*col-newK;\\n        int boundry=row*col;\\n        Integer newGrid[][]=new Integer[row][col];\\n        for(int i=0,j=endPoint;i<boundry;i++,j++)\\n        {\\n            if(j==boundry)\\n                j=0;\\n            newGrid[i/col][i%col]=grid[j/col][j%col];\\n        }\\n        for(Integer[] a:newGrid)\\n            ret.add(Arrays.asList(a));\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431111,
                "title": "simple-to-understand-java",
                "content": "```\\n  public static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int[][] temp = new int[grid.length][grid[0].length]; // took temp grid\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int mod = n * m;\\n        k = k % mod; // minimize the k value\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int p = j + k; // defines which col\\n                int r = p / (m); // defines which row\\n                if (p < m) {\\n                    temp[i][p] = grid[i][j];\\n                } else {\\n                    temp[(i + r) % n][p % m] = grid[i][j];\\n                }\\n            }\\n        }\\n\\t\\t// making temp grid into list\\n        List<List<Integer>> result = new LinkedList<>();\\n        for (int[] t : temp) {\\n            LinkedList<Integer> c = new LinkedList<>();\\n            for (int i : t) {\\n                c.add(i);\\n            }\\n            result.add(c);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int[][] temp = new int[grid.length][grid[0].length]; // took temp grid\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int mod = n * m;\\n        k = k % mod; // minimize the k value\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int p = j + k; // defines which col\\n                int r = p / (m); // defines which row\\n                if (p < m) {\\n                    temp[i][p] = grid[i][j];\\n                } else {\\n                    temp[(i + r) % n][p % m] = grid[i][j];\\n                }\\n            }\\n        }\\n\\t\\t// making temp grid into list\\n        List<List<Integer>> result = new LinkedList<>();\\n        for (int[] t : temp) {\\n            LinkedList<Integer> c = new LinkedList<>();\\n            for (int i : t) {\\n                c.add(i);\\n            }\\n            result.add(c);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937480,
                "title": "c-matrix-o-mxn-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                //for k=1 new column is (j+1), similarly for k=k new column is (j+k) \\n                //(j+k)%c for maintain total no. of columns\\n                int newj = (j+k)%c;\\n                \\n                //divide (j+k) with c to maintain no. of columns and move to next row\\n                //(i+(j+k)/c)%r for maintain no. of rows and if all rows end\\n                //we start from beginning\\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                //for k=1 new column is (j+1), similarly for k=k new column is (j+k) \\n                //(j+k)%c for maintain total no. of columns\\n                int newj = (j+k)%c;\\n                \\n                //divide (j+k) with c to maintain no. of columns and move to next row\\n                //(i+(j+k)/c)%r for maintain no. of rows and if all rows end\\n                //we start from beginning\\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936023,
                "title": "cpp-easy-manipulation-without-mod-with-intuition",
                "content": "```\\n step 1:  for k=1, store the last column in vector.\\n step 2:  take temp variable to store bottom right corner element \\n step 3:  simply right rotate every row of the \\n\\t\\t\\t matrix by 1.\\n step 4: copy temp variable to top left element.\\n step 5: copy the elements stored in vector in the first column\\n step 6: repeat the above steps k times.\\n\\t\\t\\t \\nclass Solution {\\npublic:\\n      \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int temp = 0;\\n        for(int t=0;t<k;t++){\\n            vector<int> v;\\n            for(int p=0;p<n;p++){\\n                v.push_back(grid[p][m-1]);\\n            }\\n            int temp = grid[n-1][m-1];\\n        for(int i=0;i<n;i++){\\n            for(int j=m-1;j>0;j--){\\n                grid[i][j] = grid[i][j-1];\\n            }\\n        }\\n        grid[0][0] = temp;\\n        for(int r=1;r<n;r++){\\n            grid[r][0] = v[r-1];\\n        }\\n        }  \\n        return grid;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n      \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int temp = 0;\\n        for(int t=0;t<k;t++){\\n            vector<int> v;\\n            for(int p=0;p<n;p++){\\n                v.push_back(grid[p][m-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1934599,
                "title": "python-easy-to-understand",
                "content": "We compute the new dimensions for every character and insert it there.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        res=[[0]*n for _ in range(m)]\\n        for c in range(n):\\n            c2=(c+k)%n\\n            for r in range(m):\\n                r2=(r+(c+k)//n)%m\\n                res[r2][c2]=grid[r][c]        \\n        return res",
                "solutionTags": [],
                "code": "We compute the new dimensions for every character and insert it there.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        res=[[0]*n for _ in range(m)]\\n        for c in range(n):\\n            c2=(c+k)%n\\n            for r in range(m):\\n                r2=(r+(c+k)//n)%m\\n                res[r2][c2]=grid[r][c]        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1934598,
                "title": "python-2-approach-with-example-shown",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # m*n space:\\n#         ans = [[0]*n for _ in range(m)]  \\n#         for i in range(m):\\n#             for j in range(n):\\n#                 ix = (i*n + j + k)%(m*n)\\n#                 ans[ix//n][ix%n] = grid[i][j]     \\n#         return ans\\n\\n\\n# 0(1) space\\n        def reverse(l,r):\\n            while l <= r:\\n                lr, lc = l//n, l%n\\n                rr, rc = r//n, r%n\\n                grid[lr][lc], grid[rr][rc] = grid[rr][rc], grid[lr][lc]\\n                l += 1\\n                r -= 1\\n        \\n        k = k%(m*n)\\n        reverse(0, m*n-1)\\n        reverse(0,k-1)\\n        reverse(k, m*n-1)\\n        return grid\\n                                \\n# case --> k ==2\\n\\n#     123\\n#     456\\n#     789\\n\\n#     891\\n#     234\\n#     567\\n\\n# 123456789\\n# (reverse whole) becomes -->\\n# 98|7654321\\n# (reverse 0:k) and (reverse k:) becomes -->\\n# 89|1234567\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # m*n space:\\n#         ans = [[0]*n for _ in range(m)]  \\n#         for i in range(m):\\n#             for j in range(n):\\n#                 ix = (i*n + j + k)%(m*n)\\n#                 ans[ix//n][ix%n] = grid[i][j]     \\n#         return ans\\n\\n\\n# 0(1) space\\n        def reverse(l,r):\\n            while l <= r:\\n                lr, lc = l//n, l%n\\n                rr, rc = r//n, r%n\\n                grid[lr][lc], grid[rr][rc] = grid[rr][rc], grid[lr][lc]\\n                l += 1\\n                r -= 1\\n        \\n        k = k%(m*n)\\n        reverse(0, m*n-1)\\n        reverse(0,k-1)\\n        reverse(k, m*n-1)\\n        return grid\\n                                \\n# case --> k ==2\\n\\n#     123\\n#     456\\n#     789\\n\\n#     891\\n#     234\\n#     567\\n\\n# 123456789\\n# (reverse whole) becomes -->\\n# 98|7654321\\n# (reverse 0:k) and (reverse k:) becomes -->\\n# 89|1234567\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660025,
                "title": "c-linear-2-pointer-in-place-solution-explained-99-time-16ms-100-space-13-7mb",
                "content": "Really funny problem; and a bit more challenge can be given to us if we try to do it in linear time and in place - is it possible to do both at once?\\n\\nI would say so; let\\'s consider the problem with a 1D array for simplicity first, assuming we have `{1,2,3,4,5,6,7}` as an array to shift by `4` positions. In order to do it linearly and in constant space, we can keep writing a value in its future place, keeping track of the previous value of the target slot and then repeat the operation over and over again with the value we stored.\\n\\nIn our example, we would have (the commented number is the one we store somewhere and write at the next round):\\n\\n```cpp\\n1 2 3 4 1 6 7 // 5\\n1 5 3 4 1 6 7 // 2\\n1 5 3 4 1 2 7 // 6\\n1 5 6 4 1 2 7 // 3\\n1 5 6 4 1 2 3 // 7\\n1 5 6 7 1 2 3 // 4\\n4 5 6 7 1 2 3 // 1\\n```\\n\\nA tricky part here is to notice that once the length of our array and `k` are not co-primes, we will have some loop that will NOT include all the elements as it happened before (try for example with `k` still equal to `4`, but with `8` elements to shift); we can easily fix it running our main shifting algorithm `gcd(nums.size(), k)` times, with a starting value of `0` and it will just work fine :)\\n\\nAnother optimisation trick might be to reduce `k` by the total of all the elements (shifting a grid of `100` elements by `100` will just give us the starting grid!) and, of course, to return the base grid itself for `k == 0`.\\n\\nNow, time to put all of this into code, first of all with a few support variables to help us:\\n* `w` and `h` will store the width (number of columns) and height (numbers of rows) of the grid, respectively;\\n* `tot`, computed as the product of the above variables, to store the overall number of elements;\\n* `target`, of type `div_t` (an object that will store `quot`ient and `rem`inder of a division with `div`), which will help us move later in our shifting/juggling logic.\\n\\nWe will then potentially reduce `k` to be the modulo of `tot`, and, in case it is `0`, directly `return` `grid`, as explained above.\\n\\nTime for our main loop, that will go with `i` as our starting point from `0` to `gcd(tot, k)` (excluded), using also `tmp` and `j` as loop variables; we will then:\\n* assign `i` as initial value to `j`;\\n* the result of `div(j, w)` to target, since we will have to convert our 1D example above to a 2D scenario, where each index will be converted to be the row number (`target.quot`) and the column number (`target.rem`) - in a grid of `3` rows and `4` columns, for example, the index `7` would give us `1` as a row number (the quotient) and `3` as column number (the reminder);\\n* get the initial value of `tmp`, taken as the `j`th element in our grid, using `target.quot` and `target.rem` as explained in the bullet point above;\\n* loop while`j != i` (but it is a do...while, so we will ignore the condition at the first run) and:\\n\\t* increase `j` by `k`;\\n\\t* check if `j` went over `tot`, in which case we will subtract it from `j` (which is basically equivalent of doing `j &= tot`, just way cheaper);\\n\\t* update `target` to be the current result of `div(j, w)`;\\n\\t* `swap` `tmp` and `grid[target.quot][target.rem]`.\\n\\nOnce done, we can just `return` `grid` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```\\n\\nAnd since I forgot about having solved this problem already, I came up with a slightly different solution today, that I prefer somehow a bit more; also, not using modulo boosted the speed significantly:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int maxX = grid[0].size(), maxY = grid.size(), tot = maxX * maxY, tmp;\\n        // normalising k\\n        k %= tot;\\n        // edge case\\n        if (!k) return grid;\\n        // main loop, running gcd(k, tot) times\\n        for (int i = 0, lmtI = gcd(k, tot), x, y; i < lmtI; i++) {\\n            // initialising pointers and starting value\\n            x = i, y = 0;\\n            while (x >= maxX) x -= maxX, y++;\\n            tmp = grid[y][x];\\n            // inner loop, advancing every k elements from i\\n            for (int j = 0, lmtJ = tot / lmtI; j < lmtJ; j++) {\\n                // advancing pointers\\n                x += k;\\n                while (x >= maxX) x -= maxX, y++;\\n                if (y >= maxY) y -= maxY;\\n                // updating values\\n                swap(tmp, grid[y][x]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\n1 2 3 4 1 6 7 // 5\\n1 5 3 4 1 6 7 // 2\\n1 5 3 4 1 2 7 // 6\\n1 5 6 4 1 2 7 // 3\\n1 5 6 4 1 2 3 // 7\\n1 5 6 7 1 2 3 // 4\\n4 5 6 7 1 2 3 // 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int maxX = grid[0].size(), maxY = grid.size(), tot = maxX * maxY, tmp;\\n        // normalising k\\n        k %= tot;\\n        // edge case\\n        if (!k) return grid;\\n        // main loop, running gcd(k, tot) times\\n        for (int i = 0, lmtI = gcd(k, tot), x, y; i < lmtI; i++) {\\n            // initialising pointers and starting value\\n            x = i, y = 0;\\n            while (x >= maxX) x -= maxX, y++;\\n            tmp = grid[y][x];\\n            // inner loop, advancing every k elements from i\\n            for (int j = 0, lmtJ = tot / lmtI; j < lmtJ; j++) {\\n                // advancing pointers\\n                x += k;\\n                while (x >= maxX) x -= maxX, y++;\\n                if (y >= maxY) y -= maxY;\\n                // updating values\\n                swap(tmp, grid[y][x]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491883,
                "title": "python-3-in-one-line",
                "content": "# Explanation\\n\\nThere is a clear one-to-one mapping for every element in the grid to its new location. We just need to figure out that mapping.. it\\'s a bit of math involving modulo and division.\\n\\nFrom grid -> shifted location:\\n```\\nx := (x + k) % w\\ny := (y + ((x + k) / w)) % h\\n```\\nIn reverse, from shifted location -> original location:\\n```\\nx := (x - k) % w\\ny := (y - (((k - x - 1) / w) + 1)) % h\\n```\\nNote that in Python, `-1 % 3` is `2` and not `-1` like in Java / C / etc.\\n\\n# Two lines\\n\\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    return [[grid[(y - (((k - x - 1) // w) + 1)) % h][(x - k) % w] for x in range(w)] for y in range(h)]\\n```\\n\\n# One line\\n\\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    return [[grid[(y - (((k - x - 1) // len(grid[0])) + 1)) % len(grid)][(x - k) % len(grid[0])] for x in range(len(grid[0]))] for y in range(len(grid))]\\n```",
                "solutionTags": [],
                "code": "```\\nx := (x + k) % w\\ny := (y + ((x + k) / w)) % h\\n```\n```\\nx := (x - k) % w\\ny := (y - (((k - x - 1) / w) + 1)) % h\\n```\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    return [[grid[(y - (((k - x - 1) // w) + 1)) % h][(x - k) % w] for x in range(w)] for y in range(h)]\\n```\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    return [[grid[(y - (((k - x - 1) // len(grid[0])) + 1)) % len(grid)][(x - k) % len(grid[0])] for x in range(len(grid[0]))] for y in range(len(grid))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452350,
                "title": "straight-forward-c-with-linq",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n        var values = grid.SelectMany(x => x);\\n        var mod = k % (n * m);  \\n\\t\\t\\n        var flattened = values.Skip(n * m - mod).Concat(values.Take(n * m - mod));\\n        return Enumerable\\n            .Range(0, n)\\n            .Select(x => flattened.Skip(x * m).Take(m).ToList())\\n            .ToList<IList<int>>();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n        var values = grid.SelectMany(x => x);\\n        var mod = k % (n * m);  \\n\\t\\t\\n        var flattened = values.Skip(n * m - mod).Concat(values.Take(n * m - mod));\\n        return Enumerable\\n            .Range(0, n)\\n            .Select(x => flattened.Skip(x * m).Take(m).ToList())\\n            .ToList<IList<int>>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432357,
                "title": "fast-java-with-reverse-function",
                "content": "Shift by k is equivalent with the following:\\n1. reverse whole array\\n2. reverse first subarray of k elements\\n3. reverse the remaining subarray\\n\\nCheck out similar question: https://leetcode.com/problems/rotate-array/\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n    \\n        int m = grid.length, n = grid[0].length;\\n        k = k % (m*n);\\n        int[] arr = new int[m*n];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                arr[i*n+j] = grid[i][j];\\n            }\\n        }\\n\\n        reverseArray(arr, 0, m*n-1);\\n        reverseArray(arr, 0, k-1);\\n        reverseArray(arr, k, m*n-1);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++){\\n            List<Integer> row = new ArrayList<>();\\n            for (int j = 0; j < n; j++){\\n                row.add(arr[i*n+j]);\\n            }\\n            res.add(row);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void reverseArray(int[] arr, int start, int end) {\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n    \\n        int m = grid.length, n = grid[0].length;\\n        k = k % (m*n);\\n        int[] arr = new int[m*n];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                arr[i*n+j] = grid[i][j];\\n            }\\n        }\\n\\n        reverseArray(arr, 0, m*n-1);\\n        reverseArray(arr, 0, k-1);\\n        reverseArray(arr, k, m*n-1);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++){\\n            List<Integer> row = new ArrayList<>();\\n            for (int j = 0; j < n; j++){\\n                row.add(arr[i*n+j]);\\n            }\\n            res.add(row);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void reverseArray(int[] arr, int start, int end) {\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516657,
                "title": "c-no-extra-memory-solution",
                "content": "This is slow, but if you want in-place (no extra memory), then this is viable solution.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int col = grid[0].size();\\n        int n = grid.size() * col;\\n\\n        k = k % n;\\n        if (k == 0) return grid;\\n\\n        while (k-- > 0) {\\n            int prev = grid[0][0];\\n            \\n            for (int i = 0; i < n-1; i++) {\\n                int idx = (i + 1) % n;\\n                int tmp = grid[idx / col][idx % col];\\n                grid[idx / col][idx % col] = prev;\\n                prev = tmp;\\n            }\\n    \\n            grid[0][0] = prev;\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int col = grid[0].size();\\n        int n = grid.size() * col;\\n\\n        k = k % n;\\n        if (k == 0) return grid;\\n\\n        while (k-- > 0) {\\n            int prev = grid[0][0];\\n            \\n            for (int i = 0; i < n-1; i++) {\\n                int idx = (i + 1) % n;\\n                int tmp = grid[idx / col][idx % col];\\n                grid[idx / col][idx % col] = prev;\\n                prev = tmp;\\n            }\\n    \\n            grid[0][0] = prev;\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099596,
                "title": "best-o-m-n-time-complexity-o-m-n-space-complexity-approach-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSeemed Truly Easy At First, Turned Out To Be Easier.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach Taken Is Explained Below :-\\n\\n(1) Initialise A Single Dimensional Array Of Size m*n and Pass Each Value Of The Matrix Sequentially Into The Single Dimensional Array.\\n\\n(2) Rotate The Array K Times Using The Following Algorithm :-\\n\\nStep (i) - Reverse The Entire Array\\nStep (ii) - Reverse The First K Elements (From Indexes 0 To K-1)\\nStep (iii) - Reverse The Rest of The Elements (From Indexes K To arr.length-1)\\n\\n(3) Store Each Element Of The Rotated Array In an ArrayList Of Size Equal To Number of Columns In Each Row. After Each Row, Pass The ArrayList Into an ArrayList<ArrayList<Integer>> Which Will Hold The Values Of All Rows Respectively.\\n\\n(4) Return The ArrayList<ArrayList<Integer>>.\\n\\nGood Luck!\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> Final_List=new ArrayList<List<Integer>>();\\n        k = k % (grid.length*grid[0].length);\\n        int[] arr=new int[grid.length*grid[0].length];\\n        int index=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                arr[index++]=grid[i][j];\\n            }\\n        }\\n        //Reverse The Entire Array\\n        reverseArray(arr,0,arr.length-1);\\n        //Reverse First K Elements\\n        reverseArray(arr,0,k-1);\\n        //Reverse Rest Elements\\n        reverseArray(arr,k,arr.length-1);\\n        int index1=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            ArrayList<Integer> list=new ArrayList<Integer>();\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                list.add(arr[index1++]);\\n            }\\n            Final_List.add(list);\\n        }\\n        return Final_List;\\n    }\\n    public static void reverseArray(int[] arr,int start, int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=arr[start];\\n            arr[start]=arr[end];\\n            arr[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> Final_List=new ArrayList<List<Integer>>();\\n        k = k % (grid.length*grid[0].length);\\n        int[] arr=new int[grid.length*grid[0].length];\\n        int index=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                arr[index++]=grid[i][j];\\n            }\\n        }\\n        //Reverse The Entire Array\\n        reverseArray(arr,0,arr.length-1);\\n        //Reverse First K Elements\\n        reverseArray(arr,0,k-1);\\n        //Reverse Rest Elements\\n        reverseArray(arr,k,arr.length-1);\\n        int index1=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            ArrayList<Integer> list=new ArrayList<Integer>();\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                list.add(arr[index1++]);\\n            }\\n            Final_List.add(list);\\n        }\\n        return Final_List;\\n    }\\n    public static void reverseArray(int[] arr,int start, int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=arr[start];\\n            arr[start]=arr[end];\\n            arr[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937545,
                "title": "python-solution-using-simple-methods-just-8-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(grid), len(grid[0])\\n        k%=n*m\\n        new_grid = [[False for j in range(m)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                i0, j0 = ((i*m+j+k)//m)%n, (i*m+j+k)%m\\n                new_grid[i0][j0]=grid[i][j]       \\n        return new_grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(grid), len(grid[0])\\n        k%=n*m\\n        new_grid = [[False for j in range(m)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                i0, j0 = ((i*m+j+k)//m)%n, (i*m+j+k)%m\\n                new_grid[i0][j0]=grid[i][j]       \\n        return new_grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720118,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; \\n                \\n                int newI=(i+(j+k)/m)%n; \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; \\n                \\n                int newI=(i+(j+k)/m)%n; \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937662,
                "title": "c-1-liner-just-for-fun",
                "content": "This is actually pretty efficient due to lazy evaluation, but admittingly not the most intuitive solution. Commented for readability.\\n\\n```cs\\npublic IList<IList<int>> ShiftGrid(int[][] grid, int k) => grid\\n    // flatten the grid to a list\\n    .SelectMany(x => x)\\n    // we need 2 lists and we are going to select a window of numbers\\n    .Concat(grid.SelectMany(x => x))\\n    // calculate the offset of charcters to skip\\n    .Skip(grid.Length * grid[0].Length - k % (grid.Length * grid[0].Length))\\n    // chunk the flat list into rows\\n    .Chunk(grid[0].Length)\\n    // the number of rows should be unchanged\\n    .Take(grid.Length)\\n    // we need a type compatiable with IList\\n    .ToArray();\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [],
                "code": "```cs\\npublic IList<IList<int>> ShiftGrid(int[][] grid, int k) => grid\\n    // flatten the grid to a list\\n    .SelectMany(x => x)\\n    // we need 2 lists and we are going to select a window of numbers\\n    .Concat(grid.SelectMany(x => x))\\n    // calculate the offset of charcters to skip\\n    .Skip(grid.Length * grid[0].Length - k % (grid.Length * grid[0].Length))\\n    // chunk the flat list into rows\\n    .Chunk(grid[0].Length)\\n    // the number of rows should be unchanged\\n    .Take(grid.Length)\\n    // we need a type compatiable with IList\\n    .ToArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936825,
                "title": "kotlin-beats-98-april-2022",
                "content": "\\n\\tclass Solution {\\n    \\n\\tfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n\\t\\n\\t\\tval result = MutableList(grid.size) { MutableList<Int>(grid[0].size) { 0 } } \\n\\t\\t\\n        for (i in grid.indices) { \\n            for (j in grid[0].indices) {\\n                val n = (i + (j + k) / grid[0].size) % grid.size\\n                val m = (j + k) % grid[0].size\\n\\n                result[n][m] = grid[i][j]\\n            }\\n        }\\n        \\n        return result\\n    }\\n\\t}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    \\n\\tfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n\\t\\n\\t\\tval result = MutableList(grid.size) { MutableList<Int>(grid[0].size) { 0 }",
                "codeTag": "Java"
            },
            {
                "id": 1936818,
                "title": "c-29ms-faster-than-80-easy-solution",
                "content": "I just created a vector and stored all values of matrix in that vector.\\n\\n        vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n\\t\\t\\nThen I create a int x from which the values to be filled in matrix from the vector.\\n\\t\\t\\n        int x;\\n        if(k<=ans.size())\\n             x = ans.size()-k;\\n        else \\n            x = ans.size()-(k%ans.size());\\n\\t\\t\\t\\nNow just filling values from vector to matrix(grid).\\nand if x>=vector size\\nx=0;\\n\\t\\t\\t\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(x>=ans.size())\\n                    x=0;\\n                grid[i][j] = ans[x];\\n                x++;\\n                \\n            }\\n                  \\n        }\\n        return grid;\\n    }",
                "solutionTags": [
                    "Array",
                    "Matrix"
                ],
                "code": "I just created a vector and stored all values of matrix in that vector.\\n\\n        vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n\\t\\t\\nThen I create a int x from which the values to be filled in matrix from the vector.\\n\\t\\t\\n        int x;\\n        if(k<=ans.size())\\n             x = ans.size()-k;\\n        else \\n            x = ans.size()-(k%ans.size());\\n\\t\\t\\t\\nNow just filling values from vector to matrix(grid).\\nand if x>=vector size\\nx=0;\\n\\t\\t\\t\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(x>=ans.size())\\n                    x=0;\\n                grid[i][j] = ans[x];\\n                x++;\\n                \\n            }\\n                  \\n        }\\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1936444,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/924e5ed5-c56a-4f93-bfd3-5cad4ddedd6a_1649685169.9793317.png)\\n\\n```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes) {\\n    int RowSize = gridSize, ColSize = gridColSize[0], totalSize = RowSize * ColSize, shift = k % totalSize;\\n    *returnSize = gridSize;\\n    *returnColumnSizes = gridColSize;\\n    if(shift == 0) return grid;\\n    \\n    int arridx = 0;\\n    int* arr = (int*) malloc(2 * totalSize * sizeof(int));\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            arr[arridx] = grid[i][j];\\n            arr[arridx + totalSize] = grid[i][j];\\n            arridx++;\\n        }\\n    }\\n    \\n    arridx = totalSize - shift;\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            grid[i][j] = arr[arridx];\\n            arridx++;\\n        }\\n    }\\n    free(arr);\\n    return grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes) {\\n    int RowSize = gridSize, ColSize = gridColSize[0], totalSize = RowSize * ColSize, shift = k % totalSize;\\n    *returnSize = gridSize;\\n    *returnColumnSizes = gridColSize;\\n    if(shift == 0) return grid;\\n    \\n    int arridx = 0;\\n    int* arr = (int*) malloc(2 * totalSize * sizeof(int));\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            arr[arridx] = grid[i][j];\\n            arr[arridx + totalSize] = grid[i][j];\\n            arridx++;\\n        }\\n    }\\n    \\n    arridx = totalSize - shift;\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            grid[i][j] = arr[arridx];\\n            arridx++;\\n        }\\n    }\\n    free(arr);\\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936378,
                "title": "c-solution-runtime-160-ms-faster-than-96-00-of-c-online-submissions",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        if (k % (n*m) == 0) return grid;\\n        \\n        var result = new int[m][];\\n        for (var i=0; i<m; i++) result[i] = new int[n];\\n        var mn = m*n;\\n        for (var i=0; i < mn; i++) {\\n            var c = (i + k) % mn;\\n            result[c/n][c%n] = grid[i/n][i%n];\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        if (k % (n*m) == 0) return grid;\\n        \\n        var result = new int[m][];\\n        for (var i=0; i<m; i++) result[i] = new int[n];\\n        var mn = m*n;\\n        for (var i=0; i < mn; i++) {\\n            var c = (i + k) % mn;\\n            result[c/n][c%n] = grid[i/n][i%n];\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936052,
                "title": "c-time-o-n-space-o-1-explanation",
                "content": "The final solution is here. \\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>>& shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        int r = gcd(n,k);\\n        for(int i = 0; i<r;i++) {\\n            int temp = grid[i/cols][i%cols];\\n            int curr_idx = i;\\n            for(int j = 0;j<n/r;j++) {\\n                int next_idx = (curr_idx+k)%n;\\n                int prev_temp = temp;\\n                temp = grid[next_idx/cols][next_idx%cols];\\n                grid[next_idx/cols][next_idx%cols] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        } \\n        return grid;\\n    }    \\n};\\n```\\nspace complexity O (1), time complexity O(N).  \\nN is mean rows * cols  here. \\n\\n# Explanation\\n\\nThe above solution is optimized from following code\\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> answer1(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> ans = grid;\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        for(int curr = 0; curr < n;curr++) { \\n            int next = (curr+k)%n;\\n            ans[next/cols][next%cols]= grid[curr/cols][curr%cols];\\n        }\\n        return ans;\\n    } \\n};\\n```\\nThis code using time O(N) and space O(N). \\nAnd the idea of this code is to represent two dimension into one dimension array. \\nProcess it in. one dimension array and problem become easy. \\n\\nAnd this is a rorate array problem now. \\nThen we need to optimize this solution from this article\\nhttps://leetcode.com/problems/rotate-array/discuss/1729976/C%2B%2B-or-O(N)-or-GCD\\nIn this article, it solve rorate array problem by this way. \\n```C++\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```\\nThen I adjust this code to become our solution.  \\nThat\\'s how I solve this problem in Time O(N) & Space O(1) in the final solution.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>>& shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        int r = gcd(n,k);\\n        for(int i = 0; i<r;i++) {\\n            int temp = grid[i/cols][i%cols];\\n            int curr_idx = i;\\n            for(int j = 0;j<n/r;j++) {\\n                int next_idx = (curr_idx+k)%n;\\n                int prev_temp = temp;\\n                temp = grid[next_idx/cols][next_idx%cols];\\n                grid[next_idx/cols][next_idx%cols] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        } \\n        return grid;\\n    }    \\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> answer1(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> ans = grid;\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        for(int curr = 0; curr < n;curr++) { \\n            int next = (curr+k)%n;\\n            ans[next/cols][next%cols]= grid[curr/cols][curr%cols];\\n        }\\n        return ans;\\n    } \\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935848,
                "title": "convert-grid-into-1d-list-and-then-make-it-simpler",
                "content": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> temp=new ArrayList<>();\\n        \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp.add(grid[i][j]);\\n            }\\n        }\\n        Collections.rotate(temp,k);\\n        \\n        for(int j=0;j<m*n;j+=n){\\n            List<Integer> my=new ArrayList<>();\\n            for(int p=j;p<j+n;p++){\\n                my.add(temp.get(p));\\n            }\\n            ans.add(my);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> temp=new ArrayList<>();\\n        \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp.add(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1935176,
                "title": "c-easy-understanding",
                "content": "\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();        \\n        for(int k=0;k<x;k++){\\n            int temp;\\n            for (int i=n-1;i>=0;i--){\\n                for(int j=m-1;j>=0;j--){\\n                    if(i==n-1 && j==m-1) temp=grid[i][j];\\n                    else if(j==m-1){\\n                        grid[i+1][0]=grid[i][j];\\n                    }\\n                    else{\\n                        grid[i][j+1]=grid[i][j];\\n                    }\\n                }\\n            }\\n            grid[0][0]=temp;\\n        }\\n        \\n        return grid;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();        \\n        for(int k=0;k<x;k++){\\n            int temp;\\n            for (int i=n-1;i>=0;i--){\\n                for(int j=m-1;j>=0;j--){\\n                    if(i==n-1 && j==m-1) temp=grid[i][j];\\n                    else if(j==m-1){\\n                        grid[i+1][0]=grid[i][j];\\n                    }\\n                    else{\\n                        grid[i][j+1]=grid[i][j];\\n                    }\\n                }\\n            }\\n            grid[0][0]=temp;\\n        }\\n        \\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1934883,
                "title": "javascript",
                "content": "```\\nvar shiftGrid = function(g, k, arr1=[],arr2=[],arr3=[], res=[]) {\\n    arr1=g.flat()\\n    k=k%arr1.length\\n    arr2=arr1.splice(-k,k)\\n    arr3=[...arr2, ...arr1]\\n    for(let q=0;q<g.length;q++){\\n        res.push(arr3.splice(0,g[0].length))\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(g, k, arr1=[],arr2=[],arr3=[], res=[]) {\\n    arr1=g.flat()\\n    k=k%arr1.length\\n    arr2=arr1.splice(-k,k)\\n    arr3=[...arr2, ...arr1]\\n    for(let q=0;q<g.length;q++){\\n        res.push(arr3.splice(0,g[0].length))\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 756166,
                "title": "python3-simple-solution-linear-index-to-array-index",
                "content": "class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        # figure out the number of rows and columns, m by n\\n        m = len(grid)\\n        n = len(grid[0])\\n        tot_len = m * n\\n        # new grid\\n        new_grid = [[0 for i in range(n)] for j in range(m)]\\n        # \\n        for i in range(tot_len):\\n            new_linear_index = (i + k) % (tot_len)\\n            new_row_index, new_column_index = divmod(new_linear_index, n)\\n            old_row_index, old_column_index = divmod(i, n)\\n            new_grid[new_row_index][new_column_index] = grid[old_row_index][old_column_index]\\n        return(new_grid)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        # figure out the number of rows and columns, m by n\\n        m = len(grid)\\n        n = len(grid[0])\\n        tot_len = m * n\\n        # new grid\\n        new_grid = [[0 for i in range(n)] for j in range(m)]\\n        # \\n        for i in range(tot_len):\\n            new_linear_index = (i + k) % (tot_len)\\n            new_row_index, new_column_index = divmod(new_linear_index, n)\\n            old_row_index, old_column_index = divmod(i, n)\\n            new_grid[new_row_index][new_column_index] = grid[old_row_index][old_column_index]\\n        return(new_grid)",
                "codeTag": "Java"
            },
            {
                "id": 529823,
                "title": "1260-javascript-solution-with-comments",
                "content": "I tried *other* ways of doing it, but none of them seemed really *better*.\\n\\nThis isn\\'t a 1-line solution, but each operation in the solution is only 1 line.\\n\\n> Runtime: **92 ms**, faster than *100.00%* of JavaScript online submissions\\n> Memory Usage: **45.3 MB**, less than *35.62%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nconst shiftGrid = (grid, k) => {\\n  // Store the width and the height of the grid\\n  const [w, h] = [grid[0].length, grid.length];\\n  // Calculate the total items in the grid\\n  const t = w * h;\\n  // Use the total to avoid extraneous whole-grid shifts\\n  k %= t;\\n  // Flatten the grid for easy shifting\\n  const flattened = grid.flat();\\n  // Shift the grid using slice for speed\\n  const sFlattened = [...flattened.slice(-k), ...flattened.slice(0, -k)];\\n  // Make a new two-dimensional shifted grid\\n  const shifted = []; // The second dimension is added on the next line\\n  // Store the flat shifted grid in the new two-dimensional shifted grid\\n  for (let i = 0; i < t; i += w) shifted.push(sFlattened.slice(i, i + w));\\n  // Return the new two-dimensional shifted grid\\n  return shifted;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nconst shiftGrid = (grid, k) => {\\n  // Store the width and the height of the grid\\n  const [w, h] = [grid[0].length, grid.length];\\n  // Calculate the total items in the grid\\n  const t = w * h;\\n  // Use the total to avoid extraneous whole-grid shifts\\n  k %= t;\\n  // Flatten the grid for easy shifting\\n  const flattened = grid.flat();\\n  // Shift the grid using slice for speed\\n  const sFlattened = [...flattened.slice(-k), ...flattened.slice(0, -k)];\\n  // Make a new two-dimensional shifted grid\\n  const shifted = []; // The second dimension is added on the next line\\n  // Store the flat shifted grid in the new two-dimensional shifted grid\\n  for (let i = 0; i < t; i += w) shifted.push(sFlattened.slice(i, i + w));\\n  // Return the new two-dimensional shifted grid\\n  return shifted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437060,
                "title": "python-o-1-space-rotate-virtual-1d-array",
                "content": "Assuming you already know how to rotate a 1D array by \"k\" steps in O(1) space:\\n1. Swap all elements on the left side: arr[:k], \\n2. Swap all element on the right side: arr[k:]\\n3. Swap all element in the whole array: arr[::]\\n\\nThis problem is 2D array, not 1D array. But we can solve it the same way as 1D array, just by presenting the 2D array as a \"virtual\" 1D array.\\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n=len(grid)\\n        m=len(grid[0]) if grid else 0\\n        nm=n*m\\n        k=-k%nm\\n        def getAt(i):\\n            x,y=divmod(i,m)\\n            return grid[x][y]\\n        def setAt(i,v):\\n            x,y=divmod(i,m)\\n            grid[x][y]=v\\n        def reverse(start,end):\\n            for i in range((end-start+1)//2):\\n                a=getAt(start+i)\\n                setAt(start+i,getAt(end-i))\\n                setAt(end-i,a)\\n        reverse(0,k-1)\\n        reverse(k,nm-1)\\n        reverse(0,nm-1)\\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n=len(grid)\\n        m=len(grid[0]) if grid else 0\\n        nm=n*m\\n        k=-k%nm\\n        def getAt(i):\\n            x,y=divmod(i,m)\\n            return grid[x][y]\\n        def setAt(i,v):\\n            x,y=divmod(i,m)\\n            grid[x][y]=v\\n        def reverse(start,end):\\n            for i in range((end-start+1)//2):\\n                a=getAt(start+i)\\n                setAt(start+i,getAt(end-i))\\n                setAt(end-i,a)\\n        reverse(0,k-1)\\n        reverse(k,nm-1)\\n        reverse(0,nm-1)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431163,
                "title": "c-brute-force-o-k-m-n-by-storing-prev",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int K) {\\n        for(int k = 0; k < K; k++) {\\n            int n = grid.size(), m = grid[0].size();\\n            int prev = grid[0][0]; grid[0][0] = grid[n - 1][m - 1];\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < m; j++) {\\n                    if(i == 0 && j == 0)\\n                        continue;\\n                    int temp = grid[i][j];\\n                    grid[i][j] = prev;\\n                    prev = temp;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int K) {\\n        for(int k = 0; k < K; k++) {\\n            int n = grid.size(), m = grid[0].size();\\n            int prev = grid[0][0]; grid[0][0] = grid[n - 1][m - 1];\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < m; j++) {\\n                    if(i == 0 && j == 0)\\n                        continue;\\n                    int temp = grid[i][j];\\n                    grid[i][j] = prev;\\n                    prev = temp;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848373,
                "title": "easiest-solution-c-plusplus-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n        while(k--){\\n            int a = ans.back();\\n            ans.pop_back();\\n            ans.insert(ans.begin(),a);\\n        }\\n        int ind = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=ans[ind++];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n        while(k--){\\n            int a = ans.back();\\n            ans.pop_back();\\n            ans.insert(ans.begin(),a);\\n        }\\n        int ind = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=ans[ind++];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658087,
                "title": "js-very-easy-solution",
                "content": "```\\nvar shiftGrid = function(grid, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const move = (grid) => {\\n        for (let i = 0; i < m; i++) {\\n            const current = [];\\n            for (let j = 0; j < n; j++) {\\n                current[j] = grid[i][j];\\n                grid[i][j] = j === 0 ? grid[i][n - 1] : current[j - 1];\\n            }\\n        }\\n        \\n        const current = [];\\n        for (let i = 0; i < m; i++) {\\n            current[i] = grid[i][0];\\n            grid[i][0] = i === 0 ? grid[m - 1][0] : current[i - 1];\\n        }\\n    }\\n    \\n    for (let i = 1; i <= k; i++) {\\n        move(grid);\\n    }\\n    \\n    return grid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(grid, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const move = (grid) => {\\n        for (let i = 0; i < m; i++) {\\n            const current = [];\\n            for (let j = 0; j < n; j++) {\\n                current[j] = grid[i][j];\\n                grid[i][j] = j === 0 ? grid[i][n - 1] : current[j - 1];\\n            }\\n        }\\n        \\n        const current = [];\\n        for (let i = 0; i < m; i++) {\\n            current[i] = grid[i][0];\\n            grid[i][0] = i === 0 ? grid[m - 1][0] : current[i - 1];\\n        }\\n    }\\n    \\n    for (let i = 1; i <= k; i++) {\\n        move(grid);\\n    }\\n    \\n    return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937545,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int i=grid.size();\\n        int j=grid[i-1].size();\\n        while(k--){\\n            int last_element=grid[i-1][j-1];\\n            for(int a=i-1;a>=0;a--){\\n                for(int b=j-1;b>=0;b--){\\n                    \\n                    if(a==0&&b==0)\\n                        grid[a][b]=last_element;\\n                    else if(b==0)\\n                        grid[a][b]=grid[a-1][j-1];\\n                    else\\n                        grid[a][b]=grid[a][b-1];\\n                }\\n            }\\n        }\\n        return grid;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int i=grid.size();\\n        int j=grid[i-1].size();\\n        while(k--){\\n            int last_element=grid[i-1][j-1];\\n            for(int a=i-1;a>=0;a--){\\n                for(int b=j-1;b>=0;b--){\\n                    \\n                    if(a==0&&b==0)\\n                        grid[a][b]=last_element;\\n                    else if(b==0)\\n                        grid[a][b]=grid[a-1][j-1];\\n                    else\\n                        grid[a][b]=grid[a][b-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1937314,
                "title": "c-simple-solution",
                "content": "```\\n void op(vector<vector<int>>& grid){\\n    for(int i=0;i<grid.size();i++){\\n        swap(grid[i][0],grid[i][grid[0].size()-1]);\\n    }\\n  \\n    for(int j=grid[0].size()-1;j>=2;j--){\\n        \\n        for(int i=0;i<grid.size();i++){\\n            swap(grid[i][j],grid[i][j-1]);\\n        }\\n    }\\n        \\n    for(int i=grid.size()-1;i>=1;i--){\\n        swap(grid[i][0],grid[i-1][0]);\\n    }\\n        \\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        for(int j=0;j<k;j++){\\n            op(grid);\\n        }\\n        \\n        return grid;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n void op(vector<vector<int>>& grid){\\n    for(int i=0;i<grid.size();i++){\\n        swap(grid[i][0],grid[i][grid[0].size()-1]);\\n    }\\n  \\n    for(int j=grid[0].size()-1;j>=2;j--){\\n        \\n        for(int i=0;i<grid.size();i++){\\n            swap(grid[i][j],grid[i][j-1]);\\n        }\\n    }\\n        \\n    for(int i=grid.size()-1;i>=1;i--){\\n        swap(grid[i][0],grid[i-1][0]);\\n    }\\n        \\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        for(int j=0;j<k;j++){\\n            op(grid);\\n        }\\n        \\n        return grid;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937282,
                "title": "python-super-simple-solution",
                "content": "Here is a simple intuitve implementation of mine. **Upvote** if you find this helpful.\\nI am looking to make it more efficient, any suggestions?\\n\\n```class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for foo in range(k):\\n            for i in range(len(grid)-1):\\n                grid[i+1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop(-1))\\n        return(grid)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here is a simple intuitve implementation of mine. **Upvote** if you find this helpful.\\nI am looking to make it more efficient, any suggestions?\\n\\n```class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for foo in range(k):\\n            for i in range(len(grid)-1):\\n                grid[i+1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop(-1))\\n        return(grid)",
                "codeTag": "Java"
            },
            {
                "id": 1937050,
                "title": "two-js-solutions",
                "content": "1. Flatten the matrix and move k elements from the back to the front\\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.splice(0, 0, ...nums.slice(nums.length - k, nums.length));\\n\\tnums.splice(-k, k);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n```\\n2. Flatten and reverse the array, reverse the first k elements, and then reverse the rest\\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.reverse();\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, nums.length - 1);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n\\nfunction reverse(arr, start, end) {\\n\\twhile (start <= end) {\\n\\t\\tconst temp = arr[start];\\n\\t\\tarr[start] = arr[end];\\n\\t\\tarr[end] = temp;\\n\\t\\tstart++;\\n\\t\\tend--;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.splice(0, 0, ...nums.slice(nums.length - k, nums.length));\\n\\tnums.splice(-k, k);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n```\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.reverse();\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, nums.length - 1);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n\\nfunction reverse(arr, start, end) {\\n\\twhile (start <= end) {\\n\\t\\tconst temp = arr[start];\\n\\t\\tarr[start] = arr[end];\\n\\t\\tarr[end] = temp;\\n\\t\\tstart++;\\n\\t\\tend--;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936979,
                "title": "extremely-easy-and-clean-code-c-recursive",
                "content": "[](http://)\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        if(k == 0)\\n            return grid;\\n        \\n        int temp = INT_MAX;\\n        \\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                swap(temp, grid[i][j]);\\n            }\\n        }\\n        \\n        swap(temp, grid[0][0]);\\n        \\n        return shiftGrid(grid, k - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        if(k == 0)\\n            return grid;\\n        \\n        int temp = INT_MAX;\\n        \\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                swap(temp, grid[i][j]);\\n            }\\n        }\\n        \\n        swap(temp, grid[0][0]);\\n        \\n        return shiftGrid(grid, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936822,
                "title": "c-with-diagram-simple-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n       \\n        if(k==row*col || k==0){\\n            return grid;\\n        }\\n        \\n        \\n        int last;\\n        int temp;\\n        while(k--){\\n            last = grid[row-1][col-1];\\n            for(int i=0;i<row;i++){\\n                temp=grid[i][col-1];\\n                for(int j=col-1;j>0;j--){\\n                    grid[i][j]=grid[i][j-1];\\n                }\\n                grid[i][0]=last;\\n                last=temp;\\n            }\\n            \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8ac1f774-8ece-41ea-be5b-7f6ddfa9a71a_1649693338.3010826.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n       \\n        if(k==row*col || k==0){\\n            return grid;\\n        }\\n        \\n        \\n        int last;\\n        int temp;\\n        while(k--){\\n            last = grid[row-1][col-1];\\n            for(int i=0;i<row;i++){\\n                temp=grid[i][col-1];\\n                for(int j=col-1;j>0;j--){\\n                    grid[i][j]=grid[i][j-1];\\n                }\\n                grid[i][0]=last;\\n                last=temp;\\n            }\\n            \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936721,
                "title": "c-simple-clean-code-with-explanation",
                "content": "\\n1. Convert (row,col) into 1d array. `index =  (currRow * number of elements in each column + currentColum)`\\n2. Now add k to index and mod it by number of elements in matrix to avoid going out of bounds. `index = (index + k) % (no of rows * no of cols)`\\n3. now we have calculated the index, we just have to convert this index to (row,col) format. `newRow = (index / no of columns)`\\nand `newCol = (index %  no of columns)`\\n4. now copy (row,col) to (newRow,newCol).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        k = k % (n * m);\\n        int counter = 0;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int index = m * i + j;\\n                \\n                int shiftedPosition = (index + k)%(m*n);\\n                \\n                int row = (shiftedPosition/m);\\n                int col = (shiftedPosition % m);\\n                ans[row][col] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity = O(n * m)\\nSpace Complexity = O(n * m)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        k = k % (n * m);\\n        int counter = 0;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int index = m * i + j;\\n                \\n                int shiftedPosition = (index + k)%(m*n);\\n                \\n                int row = (shiftedPosition/m);\\n                int col = (shiftedPosition % m);\\n                ans[row][col] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936433,
                "title": "c-easy-solution-explaining-similar-to-1-d-shifting-clean-code-with-explanation",
                "content": "**Solution using 1-D array Rotation Tricks in the 2-D Like we Did in *Search in 2-D Matrix* (Binary Search Solution)**\\n\\n**TC :** ***O(n x m)***\\n**SC :** ***O(1)***\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid. size(), m = grid[0].size();\\n        vector<vector<int>> resGrid(n,vector<int> (m));\\n        int total = n * m; //total distance we need to move is this\\n        for(int i = 0; i< total ; i++){\\n          int row = i/m, col = i%m;//easy trick to find indices via 1-D array trick in 2-D arrays\\n\\t\\t  \\n         /*now if the value shifts to the k times then for K > N*M we need to do k  % total \\n\\t\\t taking example of K = 3 and n = 3 , m= 3 then for index (i = 8) in 1-D \\n\\t\\t will equal to (i = 8+3 =11) which crosses the n*m(total) so for preventing this rotation we do modulo */\\n            \\n\\t\\t\\tint shift = (i+k)%total;  /*this is the final place (for 1-D representation where value need to \\n\\t\\t\\tbe shift now this the index in 1-D representationnow again we need to \\n\\t\\t\\tfind the right index for 2-D grid via 1-D array using same operation as we did above)*/\\n            int newRow = shift/m , newCol = shift%m;\\n\\t\\t\\t\\n\\t\\t\\t//put these values after shifting into the grid\\n            resGrid[newRow][newCol] = grid[row][col];\\n        }\\n        return resGrid;\\n    }\\n};\\n```\\n\\n**Please UPVOTE If you Like the Clear Solution With Simple Explained Intuition**\\n\\n***Thank You***\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid. size(), m = grid[0].size();\\n        vector<vector<int>> resGrid(n,vector<int> (m));\\n        int total = n * m; //total distance we need to move is this\\n        for(int i = 0; i< total ; i++){\\n          int row = i/m, col = i%m;//easy trick to find indices via 1-D array trick in 2-D arrays\\n\\t\\t  \\n         /*now if the value shifts to the k times then for K > N*M we need to do k  % total \\n\\t\\t taking example of K = 3 and n = 3 , m= 3 then for index (i = 8) in 1-D \\n\\t\\t will equal to (i = 8+3 =11) which crosses the n*m(total) so for preventing this rotation we do modulo */\\n            \\n\\t\\t\\tint shift = (i+k)%total;  /*this is the final place (for 1-D representation where value need to \\n\\t\\t\\tbe shift now this the index in 1-D representationnow again we need to \\n\\t\\t\\tfind the right index for 2-D grid via 1-D array using same operation as we did above)*/\\n            int newRow = shift/m , newCol = shift%m;\\n\\t\\t\\t\\n\\t\\t\\t//put these values after shifting into the grid\\n            resGrid[newRow][newCol] = grid[row][col];\\n        }\\n        return resGrid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935977,
                "title": "python-fastest-solution-using-simple-mathematical-formulation-o-n-m-time",
                "content": "Please UPVOTE if you LIKE! \\uD83D\\uDE01 This solution beats 100% of the approaches submitted till now.\\n\\nI have provided hints for you to try it out once more. Please do so if you have time. Hints:\\n1) Is there a repetition in your code based on \"k\"? How would you simplify this? Try to find out the pattern there.\\n2) Once you remove the repetition, Can you simplify the next process by creating some mathematical formula.\\n\\nI hope you have tried the problem once more before looking at the below solution. \\nThere are two critical steps to look for here. let m = num of columns, n = num of rows\\n1) If K >= m that means you can simply the problem by doing row transformation depending on k//m\\n2) Now for k % m, you can simply open up the matrix and rotate the list by k and then again convert it into matrix. For example, suppose k%m = 3 and matrix is [ [ 1,2,3,4], [5,6,7,8], [9,10,11,12] ] then opening the list would be like [1,2,3,4,5,6,7,8,9,10,11,12 ] and then rotate the list would result this list to become [10,11,12,1,2,3,4,5,6,7,8,9] and again convert it into matrix like this [ [10,11,12,1], [2,3,4,5], [6,7,8,9] ].\\n\\nWorking code is as follows:\\n\\n\\n\\tdef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        row_trans = k // m\\n        for i in range(row_trans):\\n            grid = [ grid[n-1] ] + grid[:n-1]\\n        \\n        k = k % m\\n        \\n        arr = [ grid[i][j] for i in range(n) for j in range(m)]\\n        \\n        arr = arr[-k:] + arr[:-k]\\n        grid = []\\n        for i in range(n):\\n            grid.append(arr[m*i:m*(i+1)])\\n        return grid\\n\\nIf you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "Please UPVOTE if you LIKE! \\uD83D\\uDE01 This solution beats 100% of the approaches submitted till now.\\n\\nI have provided hints for you to try it out once more. Please do so if you have time. Hints:\\n1) Is there a repetition in your code based on \"k\"? How would you simplify this? Try to find out the pattern there.\\n2) Once you remove the repetition, Can you simplify the next process by creating some mathematical formula.\\n\\nI hope you have tried the problem once more before looking at the below solution. \\nThere are two critical steps to look for here. let m = num of columns, n = num of rows\\n1) If K >= m that means you can simply the problem by doing row transformation depending on k//m\\n2) Now for k % m, you can simply open up the matrix and rotate the list by k and then again convert it into matrix. For example, suppose k%m = 3 and matrix is [ [ 1,2,3,4], [5,6,7,8], [9,10,11,12] ] then opening the list would be like [1,2,3,4,5,6,7,8,9,10,11,12 ] and then rotate the list would result this list to become [10,11,12,1,2,3,4,5,6,7,8,9] and again convert it into matrix like this [ [10,11,12,1], [2,3,4,5], [6,7,8,9] ].\\n\\nWorking code is as follows:\\n\\n\\n\\tdef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        row_trans = k // m\\n        for i in range(row_trans):\\n            grid = [ grid[n-1] ] + grid[:n-1]\\n        \\n        k = k % m\\n        \\n        arr = [ grid[i][j] for i in range(n) for j in range(m)]\\n        \\n        arr = arr[-k:] + arr[:-k]\\n        grid = []\\n        for i in range(n):\\n            grid.append(arr[m*i:m*(i+1)])\\n        return grid\\n\\nIf you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1935716,
                "title": "c-vector-push-pop-simple-solution-explained",
                "content": "1. `` First of all I just convert the matrix into a linear vector``\\n2. `` Then the last element have inserted into the first position of the vector and poped out the last element from it``\\n3. `` Then again have made the matrix from the vector and returned it``\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int mod = row*col;\\n        vector<int>vec;\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                vec.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0; i<k%mod; i++){\\n            vec.insert(vec.begin(), vec.back());\\n            vec.pop_back();\\n        }\\n        int x=0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = vec[x++];\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int mod = row*col;\\n        vector<int>vec;\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                vec.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0; i<k%mod; i++){\\n            vec.insert(vec.begin(), vec.back());\\n            vec.pop_back();\\n        }\\n        int x=0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = vec[x++];\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1935669,
                "title": "c-simple-observation-based-solution-with-explanation",
                "content": "To solve this question we required two observations.\\n**Observation 1:-** If k is linear multiple of row(r in code) and column(c in code) than we get initial grid after shifting.Means answer after k shift=answer after k%(r*c).\\n**Observation 2:-**  At every n * c shifting(linear multiple of length of column) , we are shifting  whole row with other row.\\n\\nAfter these two observations only column shifting is remain.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //for number of raw\\n        int r=grid.size();\\n\\t\\t\\n        //for number of column\\n        int c=grid[0].size();\\n        \\n        //to make the copy of the grid\\n        vector<vector<int>>ans=grid;\\n        \\n        k=k%(r*c);//by observation 1\\n        \\n        //to calculate the number of row shift required.\\n        int r_shift=k/c;\\n        \\n        //to calculate the total column shift required .\\n        int c_shift=k%c;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            grid[(i+r_shift)%r]=ans[i];//row shift by observation 2.\\n        }\\n        \\n        ans=grid;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                grid[(i+(j+c_shift)/c)%r][(j+c_shift)%c]=ans[i][j];//coloumn shift.\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n//If you like my approach than plz upvote me.\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //for number of raw\\n        int r=grid.size();\\n\\t\\t\\n        //for number of column\\n        int c=grid[0].size();\\n        \\n        //to make the copy of the grid\\n        vector<vector<int>>ans=grid;\\n        \\n        k=k%(r*c);//by observation 1\\n        \\n        //to calculate the number of row shift required.\\n        int r_shift=k/c;\\n        \\n        //to calculate the total column shift required .\\n        int c_shift=k%c;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            grid[(i+r_shift)%r]=ans[i];//row shift by observation 2.\\n        }\\n        \\n        ans=grid;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                grid[(i+(j+c_shift)/c)%r][(j+c_shift)%c]=ans[i][j];//coloumn shift.\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n//If you like my approach than plz upvote me.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935303,
                "title": "easy-c-solution-o-1-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=n-1;j>0;j--){\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n             for(int i=m-1;i>0;i--){\\n            swap(grid[i][0],grid[i-1][0]);\\n        }\\n        }\\n       \\n        return grid;\\n    }\\n};\\n```\\n**PLEASE DO UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=n-1;j>0;j--){\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n             for(int i=m-1;i>0;i--){\\n            swap(grid[i][0],grid[i-1][0]);\\n        }\\n        }\\n       \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935270,
                "title": "easy-to-understand-cpp-solution-same-concept-as-rotate-array-problem",
                "content": "```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> v;\\n        for(int i = 0 ; i<grid.size() ; i++)\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n                v.push_back(grid[i][j]);\\n        \\n          k%=v.size();\\n        reverse(v.begin() , v.end());\\n        reverse(v.begin() , v.begin()+k);\\n        reverse(v.begin()+k , v.end());\\n        int x=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=v[x];\\n                x++;\\n            }\\n        }\\n        return grid;     \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> v;\\n        for(int i = 0 ; i<grid.size() ; i++)\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n                v.push_back(grid[i][j]);\\n        \\n          k%=v.size();\\n        reverse(v.begin() , v.end());\\n        reverse(v.begin() , v.begin()+k);\\n        reverse(v.begin()+k , v.end());\\n        int x=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=v[x];\\n                x++;\\n            }\\n        }\\n        return grid;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935255,
                "title": "most-simplest-and-easiest-solution-c-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n       int n=grid[0].size();\\n        int m=grid.size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            { \\n                for(int j=0;j<n;j++)\\n                {\\n                    if(j==(n-1))\\n                {\\n                    if(i==(m-1))\\n                    {\\n                        ans[0][0]=grid[i][j];\\n                    }\\n                    else\\n                    {\\n                        ans[i+1][0]=grid[i][j];\\n                }\\n                }\\n                 else\\n                 {\\n                        ans[i][j+1]=grid[i][j];\\n                    \\n                }\\n            }\\n        }\\n        grid=ans;\\n        }\\n        return grid;\\n    }\\n};\\n```\\n**IF YOU FOUND THIS HELPFUL , PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n       int n=grid[0].size();\\n        int m=grid.size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            { \\n                for(int j=0;j<n;j++)\\n                {\\n                    if(j==(n-1))\\n                {\\n                    if(i==(m-1))\\n                    {\\n                        ans[0][0]=grid[i][j];\\n                    }\\n                    else\\n                    {\\n                        ans[i+1][0]=grid[i][j];\\n                }\\n                }\\n                 else\\n                 {\\n                        ans[i][j+1]=grid[i][j];\\n                    \\n                }\\n            }\\n        }\\n        grid=ans;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935247,
                "title": "c-brute-force-approach-dlc-april-11",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        //push all elements to vector\\n        for(auto i: grid){\\n            for(auto j: i){\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        //put k%n elements in the starting of the vector\\n        int n = temp.size();\\n        k = k % n;\\n        vector<int> res;    //to store correct sequence\\n        for(int i= n-k; i<n; i++){\\n            res.push_back(temp[i]);\\n        }\\n            \\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n           \\n        //make rows of size m and put in grid\\n        int m = grid[0].size();\\n        grid.clear();\\n        temp.clear();\\n        for(int i=0; i<res.size(); i++){\\n            cout<<res[i]<<\"\\\\t\";\\n            if(temp.size() < m)\\n                 temp.push_back(res[i]);\\n            \\n            if(temp.size()== m){\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n                \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        //push all elements to vector\\n        for(auto i: grid){\\n            for(auto j: i){\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        //put k%n elements in the starting of the vector\\n        int n = temp.size();\\n        k = k % n;\\n        vector<int> res;    //to store correct sequence\\n        for(int i= n-k; i<n; i++){\\n            res.push_back(temp[i]);\\n        }\\n            \\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n           \\n        //make rows of size m and put in grid\\n        int m = grid[0].size();\\n        grid.clear();\\n        temp.clear();\\n        for(int i=0; i<res.size(); i++){\\n            cout<<res[i]<<\"\\\\t\";\\n            if(temp.size() < m)\\n                 temp.push_back(res[i]);\\n            \\n            if(temp.size()== m){\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n                \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1934978,
                "title": "simple-self-understanding-c-solution",
                "content": "If we linearly arrange all the elements of each row of a matrix , we will have an array. \\nAdd k to the current index of the array and convert that index to represent grid indices.\\n\\nA m*n matrix can be converted into an array or matrix can be represented in the form of a long array\\n\\t\\t\\tmatrix[ i ][ j ] = arr[ i*n + j ]\\nAn element in the long array of size m*n , can be taken into the form of matrix or into matrices indices using\\n\\t\\t\\tarr[ i ] = matrix[ i / n ][ i % n ];\\nTime Complexity of below code: O( m * n )\\nSpace Complexity of below code : O( m * n )\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res(m, vector<int>(n, -1));\\n        \\n        int low = 0, high = m*n;\\n        for(int i = 0; i < high; i++){\\n            int ni = ( (i+k)%high ) / n;\\n            int nj = ( (i+k)%high ) % n;\\n            \\n            res[ni][nj] = grid[i/n][i%n];\\n        }\\n        return res;\\n    }\\n```\\nPlease upvote if u find it helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res(m, vector<int>(n, -1));\\n        \\n        int low = 0, high = m*n;\\n        for(int i = 0; i < high; i++){\\n            int ni = ( (i+k)%high ) / n;\\n            int nj = ( (i+k)%high ) % n;\\n            \\n            res[ni][nj] = grid[i/n][i%n];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934975,
                "title": "c-time-o-n-and-space-o-1-in-place-solution",
                "content": "It\\'s same idea as 189.rotate array, just convert to grid type!\\n\\nif we want to take the k last to the begin, we have to do 3 steps:\\n(1) rotate  whole list\\n(2) rotate the first k elements\\n(3) rotate else elements\\n\\nWe can change the position in list to grid by simply divide column number and module column number.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k %= n * m;\\n\\t\\t// (1) rotate whole list (First half swap with last half)\\n        for (int i = 0; i < n * m / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1-i)/m][(n*m-1-i)%m]);\\n\\t\\t// (2)  rotate the first k elements\\n        for (int i = 0; i < k / 2; i++) swap(grid[i/m][i%m], grid[(k-1-i)/m][(k-1-i)%m]);\\n\\t\\t// (3) rotate else elements\\n        for (int i = k; i < k + (n * m - k) / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1+k-i)/m][(n*m-1+k-i)%m]);\\n        return grid;\\n    }\\n};\\n```\\n\\nIf this solution is helpful, please upvote!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k %= n * m;\\n\\t\\t// (1) rotate whole list (First half swap with last half)\\n        for (int i = 0; i < n * m / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1-i)/m][(n*m-1-i)%m]);\\n\\t\\t// (2)  rotate the first k elements\\n        for (int i = 0; i < k / 2; i++) swap(grid[i/m][i%m], grid[(k-1-i)/m][(k-1-i)%m]);\\n\\t\\t// (3) rotate else elements\\n        for (int i = k; i < k + (n * m - k) / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1+k-i)/m][(n*m-1+k-i)%m]);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934967,
                "title": "c-simple-approach-beginner-friendly-neat-and-clean-code",
                "content": "\\t\\t int n = grid.size();\\n        int m = grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<m;j++)\\n                {\\n                    swap(grid[i][0],grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=1; i<n; i++)\\n            {\\n                swap(grid[0][0], grid[i][0]);\\n            }\\n        }\\n       \\n        return grid;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\t int n = grid.size();\\n        int m = grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<m;j++)\\n                {\\n                    swap(grid[i][0],grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=1; i<n; i++)\\n            {\\n                swap(grid[0][0], grid[i][0]);\\n            }\\n        }\\n       \\n        return grid;",
                "codeTag": "Unknown"
            },
            {
                "id": 1934551,
                "title": "python",
                "content": "```python\\n        rows, cols = len(grid), len(grid[0])\\n        res = [[0] * cols for _ in range(rows)]\\n\\t\\t\\n        for r in range(rows):\\n            for c in range(cols):\\n                pos = (r * cols + c + k) % (rows * cols)\\n                _r, _c = divmod(pos, cols)\\n                res[_r][_c] = grid[r][c]\\n\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        rows, cols = len(grid), len(grid[0])\\n        res = [[0] * cols for _ in range(rows)]\\n\\t\\t\\n        for r in range(rows):\\n            for c in range(cols):\\n                pos = (r * cols + c + k) % (rows * cols)\\n                _r, _c = divmod(pos, cols)\\n                res[_r][_c] = grid[r][c]\\n\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934534,
                "title": "easy-to-comprehend-js-solution",
                "content": "Going backwards column wise shift one time over.\\nThen going backwards row wise move one up.\\nThats one rotation.\\nThen increment down k, do that however many times.\\nThere can be probably be a check for k where it would return the same solutions if its a a certian mod of a the size of the \\ngrid.\\n```\\nvar shiftGrid = function(g, k) {\\n    while(k>0){\\n        for(let i=0;i<g.length;i++){\\n            for(let j=g[0].length-1;j>0;j--){\\n                [g[i][j],g[i][j-1]]= [g[i][j-1],g[i][j]]\\n            }\\n        }\\n    \\n        for(let i=g.length-1;i>0;i--){\\n            [g[i][0],g[i-1][0]]= [g[i-1][0],g[i][0]]\\n        }\\n        k--\\n    }\\n    return g\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(g, k) {\\n    while(k>0){\\n        for(let i=0;i<g.length;i++){\\n            for(let j=g[0].length-1;j>0;j--){\\n                [g[i][j],g[i][j-1]]= [g[i][j-1],g[i][j]]\\n            }\\n        }\\n    \\n        for(let i=g.length-1;i>0;i--){\\n            [g[i][0],g[i-1][0]]= [g[i-1][0],g[i][0]]\\n        }\\n        k--\\n    }\\n    return g\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1615647,
                "title": "java-easy-to-understand-using-modulo-arithmetic",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length, size = m * n;\\n        k = (size - k % size) % size;\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            List<Integer> tmp = new ArrayList<>();\\n            for (int j = 0; j < n; j++) {\\n                int x = k / n, y = k % n;\\n                tmp.add(grid[x][y]);\\n                k = (k + 1) % size;\\n            }\\n            res.add(tmp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length, size = m * n;\\n        k = (size - k % size) % size;\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            List<Integer> tmp = new ArrayList<>();\\n            for (int j = 0; j < n; j++) {\\n                int x = k / n, y = k % n;\\n                tmp.add(grid[x][y]);\\n                k = (k + 1) % size;\\n            }\\n            res.add(tmp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451785,
                "title": "c-inplace",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        k %= m * n;\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c += 1000;\\n        for (int i = 0; i < m * n; i++) {\\n            int j = (i + k) % (m * n);\\n            grid[j / n][j % n] |= (grid[i / n][i % n] & 2047) << 11;\\n        }\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c = (c >> 11) - 1000;\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        k %= m * n;\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c += 1000;\\n        for (int i = 0; i < m * n; i++) {\\n            int j = (i + k) % (m * n);\\n            grid[j / n][j % n] |= (grid[i / n][i % n] & 2047) << 11;\\n        }\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c = (c >> 11) - 1000;\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419979,
                "title": "ez-solution-c-single-loop-sanyam-shah",
                "content": "# EZ Solution C++\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        for(int i = 0; i < n*m; i++){\\n             int temp = (i+k)%(n*m);\\n             ans[temp/m][temp%m] = grid[i/m][i%m];\\n        }\\n        return ans;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        for(int i = 0; i < n*m; i++){\\n             int temp = (i+k)%(n*m);\\n             ans[temp/m][temp%m] = grid[i/m][i%m];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269002,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         vector<vector<int>>grid1=grid;\\n        while(k--)\\n        {\\n            int n=grid.size();\\n            int m=grid[0].size();\\n            \\n            for(int i=0;i<grid.size();i++)\\n            {\\n                for(int j=0;j<grid[0].size();j++)\\n                {\\n                       \\n                    if(j+1<m)\\n                    {\\n                      grid1[i][j+1]=grid[i][j]; \\n                    }\\n\\n                    if(i+1<n)\\n                    {\\n                     grid1[i+1][0]=grid[i][m-1];   \\n                    }\\n                     \\n                }\\n            }\\n                            \\n            grid1[0][0]=grid[n-1][m-1];\\n            grid=grid1;\\n        }\\n        return grid1;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/81a94899-35d9-4f72-abdf-cc0d37ae83e6_1623567794.6917243.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         vector<vector<int>>grid1=grid;\\n        while(k--)\\n        {\\n            int n=grid.size();\\n            int m=grid[0].size();\\n            \\n            for(int i=0;i<grid.size();i++)\\n            {\\n                for(int j=0;j<grid[0].size();j++)\\n                {\\n                       \\n                    if(j+1<m)\\n                    {\\n                      grid1[i][j+1]=grid[i][j]; \\n                    }\\n\\n                    if(i+1<n)\\n                    {\\n                     grid1[i+1][0]=grid[i][m-1];   \\n                    }\\n                     \\n                }\\n            }\\n                            \\n            grid1[0][0]=grid[n-1][m-1];\\n            grid=grid1;\\n        }\\n        return grid1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144081,
                "title": "c-solution",
                "content": "```\\n// Runtime: 20 ms, faster than 86.55% of C++ online submissions for Shift 2D Grid.\\n// Memory Usage: 13.8 MB, less than 95.69% of C++ online submissions for Shift 2D Grid.\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size(), n = grid[0].size();\\n\\tvector<vector<int>> res(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint newPos = (i * n + j + k) % (m * n);\\n\\t\\t\\tres[newPos / n][newPos % n] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Runtime: 20 ms, faster than 86.55% of C++ online submissions for Shift 2D Grid.\\n// Memory Usage: 13.8 MB, less than 95.69% of C++ online submissions for Shift 2D Grid.\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size(), n = grid[0].size();\\n\\tvector<vector<int>> res(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint newPos = (i * n + j + k) % (m * n);\\n\\t\\t\\tres[newPos / n][newPos % n] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1015725,
                "title": "easy-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        res=[]\\n        m,n=len(grid),len(grid[0])\\n        k=k%(m*n)\\n        for i in grid:\\n            for j in i:\\n                res.append(j)\\n        res=res[m*n-k:]+res[0:m*n-k]\\n        cp=n\\n        aux=[]\\n        ans=[]\\n        for i in res:\\n            aux.append(i)\\n            cp-=1\\n            if cp==0:\\n                ans.append(aux)\\n                aux=[]\\n                cp=n\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        res=[]\\n        m,n=len(grid),len(grid[0])\\n        k=k%(m*n)\\n        for i in grid:\\n            for j in i:\\n                res.append(j)\\n        res=res[m*n-k:]+res[0:m*n-k]\\n        cp=n\\n        aux=[]\\n        ans=[]\\n        for i in res:\\n            aux.append(i)\\n            cp-=1\\n            if cp==0:\\n                ans.append(aux)\\n                aux=[]\\n                cp=n\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008659,
                "title": "using-k-rotations-on-1d-vector-o-m-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int> a;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                a.push_back(grid[i][j]);\\n        \\n        int s = a.size() - k % a.size();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                grid[i][j] = a[s++%a.size()];\\n        \\n        return grid;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int> a;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                a.push_back(grid[i][j]);\\n        \\n        int s = a.size() - k % a.size();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                grid[i][j] = a[s++%a.size()];\\n        \\n        return grid;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 910356,
                "title": "python-deque-rotate",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        flat = deque(itertools.chain(*grid))\\n        flat.rotate(k)\\n        flat = list(flat)\\n\\n        m, n = len(grid), len(grid[0])\\n        return [flat[i*n:(i+1)*n] for i in range(m)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        flat = deque(itertools.chain(*grid))\\n        flat.rotate(k)\\n        flat = list(flat)\\n\\n        m, n = len(grid), len(grid[0])\\n        return [flat[i*n:(i+1)*n] for i in range(m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883235,
                "title": "simple-python-solution-which-beats-99-84-of-submissions-by-using-the-deque-object",
                "content": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        lst = []\\n        for row in grid:\\n            lst.extend(row)\\n        items = deque(lst)\\n        k %= len(items)\\n        items.rotate(k)\\n        items = list(items)\\n        lst = []\\n        for i in range(0, len(items), cols):\\n            lst.append(items[i:i+cols])\\n        return lst\\n```",
                "solutionTags": [],
                "code": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        lst = []\\n        for row in grid:\\n            lst.extend(row)\\n        items = deque(lst)\\n        k %= len(items)\\n        items.rotate(k)\\n        items = list(items)\\n        lst = []\\n        for i in range(0, len(items), cols):\\n            lst.append(items[i:i+cols])\\n        return lst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 594791,
                "title": "easy-java-solution",
                "content": "This problem has horrible return type for java! I guess in-place way would be simpler than returning List<List<>>.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int t = 0; t < k; t++) {\\n            \\n            int last = grid[m-1][n-1];\\n            for (int r = m-1; r >= 0; r--) {\\n                for (int c = n-1; c > 0; c--) {\\n                    grid[r][c] = grid[r][c-1];\\n                }\\n                if (r > 0)\\n                    grid[r][0] = grid[r-1][n-1];\\n                else\\n                    grid[0][0] = last;\\n            }\\n            \\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            res.add(new ArrayList<Integer>());\\n            for (int j = 0; j < n; j++) {\\n                res.get(i).add(grid[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int t = 0; t < k; t++) {\\n            \\n            int last = grid[m-1][n-1];\\n            for (int r = m-1; r >= 0; r--) {\\n                for (int c = n-1; c > 0; c--) {\\n                    grid[r][c] = grid[r][c-1];\\n                }\\n                if (r > 0)\\n                    grid[r][0] = grid[r-1][n-1];\\n                else\\n                    grid[0][0] = last;\\n            }\\n            \\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            res.add(new ArrayList<Integer>());\\n            for (int j = 0; j < n; j++) {\\n                res.get(i).add(grid[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552572,
                "title": "c-one-pass-solution-2-d-array-to-1-d-array",
                "content": "**1-dimensional array index to 2-dimensional array index**\\nFor a given 1-dimensional array element **array[i]**, the corresponding row and column in 2-dimensional array will be **(i / n)** and **(i % n)**, where n is the number of columns of the 2-dimensional array. \\n\\n**2-dimensional array index to 1-dimensional array index**\\nFor a given  2-dimensional array element **array[i][j]**, the corresponding index of 1-dimensional array will be **(i * n + j)** , where n is the number of columns of the 2-dimensional array. \\n\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, total = m * n; \\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        // convert 2-D array to 1-D array\\n        for(int pos = 0; pos < total; pos++)\\n        {\\n            // new position after shifting k times\\n            int newPos = (pos + k) % total;       \\n            \\n            // convert 1-D array back to 2-D array\\n            res[newPos / n][newPos % n] = grid[pos / n][pos % n];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n\\nApproach 2: Reverse\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, size = m * n;\\n        \\n        k %= size;\\n        reverse(grid, 0, size - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, size - 1);\\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n                res[i][j] = grid[i][j];\\n        }\\n       \\n        return res;\\n    }\\n    \\n    private void reverse(int[][] grid, int left, int right)\\n    {\\n        int m = grid.Length, n = grid[0].Length;\\n        \\n        while(left < right)\\n        {\\n            int r = left / n, c = left % n;\\n            int nr = right / n, nc = right % n;\\n            \\n            int tmp = grid[r][c];\\n            grid[r][c] = grid[nr][nc];\\n            grid[nr][nc] = tmp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, total = m * n; \\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        // convert 2-D array to 1-D array\\n        for(int pos = 0; pos < total; pos++)\\n        {\\n            // new position after shifting k times\\n            int newPos = (pos + k) % total;       \\n            \\n            // convert 1-D array back to 2-D array\\n            res[newPos / n][newPos % n] = grid[pos / n][pos % n];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, size = m * n;\\n        \\n        k %= size;\\n        reverse(grid, 0, size - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, size - 1);\\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n                res[i][j] = grid[i][j];\\n        }\\n       \\n        return res;\\n    }\\n    \\n    private void reverse(int[][] grid, int left, int right)\\n    {\\n        int m = grid.Length, n = grid[0].Length;\\n        \\n        while(left < right)\\n        {\\n            int r = left / n, c = left % n;\\n            int nr = right / n, nc = right % n;\\n            \\n            int tmp = grid[r][c];\\n            grid[r][c] = grid[nr][nc];\\n            grid[nr][nc] = tmp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466350,
                "title": "concise-o-m-n-rust-solution",
                "content": "```rust\\npub fn shift_grid(mut A: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n\\tlet (m, n) = (A.len(), A[0].len());\\n\\tlet mut R = vec![vec![0; n]; m];\\n\\tlet k = k as usize;\\n\\tfor i in 0..m {\\n\\t\\tfor j in 0..n {\\n\\t\\t\\tlet y = (j + k) % n;           // j shift right k times\\n\\t\\t\\tlet x = (i + (j + k) / n) % m; // i shift down (j + k) / n times\\n\\t\\t\\tR[x][y] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\tR\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn shift_grid(mut A: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n\\tlet (m, n) = (A.len(), A[0].len());\\n\\tlet mut R = vec![vec![0; n]; m];\\n\\tlet k = k as usize;\\n\\tfor i in 0..m {\\n\\t\\tfor j in 0..n {\\n\\t\\t\\tlet y = (j + k) % n;           // j shift right k times\\n\\t\\t\\tlet x = (i + (j + k) / n) % m; // i shift down (j + k) / n times\\n\\t\\t\\tR[x][y] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\tR\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437034,
                "title": "three-solutions-in-python-3-two-lines-beats-98",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        return [[G[i%P//N][i%N] for i in range(P-k+j*N,P-k+N+j*N)] for j in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, H, k = len(G), len(G[0]), sum(G,[]), k % (len(G)*len(G[0]))\\n        I = H[-k:] + H[:-k]\\n        return [I[i*N:(i+1)*N] for i in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        A = [[0]*N for _ in range(M)]\\n        for i in range(P): A[(i+k)%P//N][((i+k)%P)%N]= G[i//N][i%N]\\n        return A\\n\\t\\t\\n\\n\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        return [[G[i%P//N][i%N] for i in range(P-k+j*N,P-k+N+j*N)] for j in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, H, k = len(G), len(G[0]), sum(G,[]), k % (len(G)*len(G[0]))\\n        I = H[-k:] + H[:-k]\\n        return [I[i*N:(i+1)*N] for i in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        A = [[0]*N for _ in range(M)]\\n        for i in range(P): A[(i+k)%P//N][((i+k)%P)%N]= G[i//N][i%N]\\n        return A\\n\\t\\t\\n\\n\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 433799,
                "title": "java-100-space-with-comments",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        \\n        // column width of the grid\\n        int colWidth = grid[0].length;\\n        \\n        // row height of the grid\\n        int rowHeight = grid.length;\\n        \\n        // totalElements in the grid\\n        int modulo = colWidth * rowHeight;\\n        \\n        //temp flat one dimensional array to store the values, when they have finally shifted by K times\\n        int[] finalIndexes = new int[colWidth * rowHeight];\\n        \\n        //go thru every element in the grid\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                \\n                // final index within a grid is calculated as currentIndex \\n// (imagine it is not a 2-d grid but a 1-d array so that element in 2nd row 2nd column is at index 4 in the 1-d array... ), \\n// we just add K to it and then divide by total number of elements \\n// and whatever is there a reminder then it would be the final location\\n                int finalIndex = ((i * colWidth) + j + k ) % modulo;\\n              \\n                //assign a value to it\\'s final index\\n                finalIndexes[finalIndex] = grid[i][j];\\n            }\\n        }\\n        \\n        \\n        // the below part is just a boilerplate for returning the value in the desired output format\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        \\n        // since this is a list of list , then the outer list would contain sublists equal to the height of the original grid\\n        for(int i = 0; i < rowHeight; i++){\\n            resultList.add(new ArrayList<>());\\n        }\\n        \\n        int counter = 0;\\n        int rowCount = -1;\\n        \\n        for(int i = 0; i < finalIndexes.length; i++){\\n            if(i % colWidth == 0){\\n                rowCount++; // increment row count if all the elements are filled in the previous row\\n            }    \\n            //add to the row where it belongs    \\n            resultList.get(rowCount).add(finalIndexes[i]);\\n        }\\n        \\n        // the answer\\n        return resultList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        \\n        // column width of the grid\\n        int colWidth = grid[0].length;\\n        \\n        // row height of the grid\\n        int rowHeight = grid.length;\\n        \\n        // totalElements in the grid\\n        int modulo = colWidth * rowHeight;\\n        \\n        //temp flat one dimensional array to store the values, when they have finally shifted by K times\\n        int[] finalIndexes = new int[colWidth * rowHeight];\\n        \\n        //go thru every element in the grid\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                \\n                // final index within a grid is calculated as currentIndex \\n// (imagine it is not a 2-d grid but a 1-d array so that element in 2nd row 2nd column is at index 4 in the 1-d array... ), \\n// we just add K to it and then divide by total number of elements \\n// and whatever is there a reminder then it would be the final location\\n                int finalIndex = ((i * colWidth) + j + k ) % modulo;\\n              \\n                //assign a value to it\\'s final index\\n                finalIndexes[finalIndex] = grid[i][j];\\n            }\\n        }\\n        \\n        \\n        // the below part is just a boilerplate for returning the value in the desired output format\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        \\n        // since this is a list of list , then the outer list would contain sublists equal to the height of the original grid\\n        for(int i = 0; i < rowHeight; i++){\\n            resultList.add(new ArrayList<>());\\n        }\\n        \\n        int counter = 0;\\n        int rowCount = -1;\\n        \\n        for(int i = 0; i < finalIndexes.length; i++){\\n            if(i % colWidth == 0){\\n                rowCount++; // increment row count if all the elements are filled in the previous row\\n            }    \\n            //add to the row where it belongs    \\n            resultList.get(rowCount).add(finalIndexes[i]);\\n        }\\n        \\n        // the answer\\n        return resultList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431470,
                "title": "python-4-lines-beat-100-speed-and-space-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/koten0224/image_1573995656.png)\\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        r,c = len(grid),len(grid[0]) #get the nums of rows and columns\\n        temp=[j for i in grid for j in i] #make grid flatten\\n        temp=temp[-k%len(temp):]+temp[:-k%len(temp)] #do the shift\\n        return [[temp[i*c+j] for j in range(c)]for i in range(r)] #trans into grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        r,c = len(grid),len(grid[0]) #get the nums of rows and columns\\n        temp=[j for i in grid for j in i] #make grid flatten\\n        temp=temp[-k%len(temp):]+temp[:-k%len(temp)] #do the shift\\n        return [[temp[i*c+j] for j in range(c)]for i in range(r)] #trans into grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918501,
                "title": "easy-c-solution-easy-to-understand-simple-clean-code-with-explanationeasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Store the last column into a vector\\n2. Move the values of (i-1) th column to i th column\\n3. Move the element at grid[m - 1][n - 1] to grid[0][0] from \"tmp\"\\n4. Replace the rest of the column-1 with the stored values from \"tmp\"\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        while(k--){\\n            // Take a vector of length m with initial value of 0 to store the last column\\n            vector<int> tmp(m,0);\\n            //Store the values of last column in \"tmp\" for later \\n            for(int i = 0; i < m; i++){\\n                tmp[i] = grid[i][n-1];\\n                cout << tmp[i];\\n            }\\n            //iterate from last column to the second column\\n            for(int i = 0; i < m; i++){\\n                for(int j = n - 1; j >= 1 ; j--){\\n                     // Store the values of previous column in the current column\\n                    grid[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            // Move the element at grid[m - 1][n - 1] to grid[0][0]\\n            grid[0][0] = tmp[m-1];\\n            // Move the rest of the values in the first column\\n            for(int i = 1; i < m; i++){\\n                grid[i][0] = tmp[i-1];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        while(k--){\\n            // Take a vector of length m with initial value of 0 to store the last column\\n            vector<int> tmp(m,0);\\n            //Store the values of last column in \"tmp\" for later \\n            for(int i = 0; i < m; i++){\\n                tmp[i] = grid[i][n-1];\\n                cout << tmp[i];\\n            }\\n            //iterate from last column to the second column\\n            for(int i = 0; i < m; i++){\\n                for(int j = n - 1; j >= 1 ; j--){\\n                     // Store the values of previous column in the current column\\n                    grid[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            // Move the element at grid[m - 1][n - 1] to grid[0][0]\\n            grid[0][0] = tmp[m-1];\\n            // Move the rest of the values in the first column\\n            for(int i = 1; i < m; i++){\\n                grid[i][0] = tmp[i-1];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3075497,
                "title": "beats-99-43-python3",
                "content": "# Approach\\nFirst of all accessing each list of grid through index, popping the last element and inserting it to the starting of next list. \\n\\nFinally, accessing the last list popping the last element and inserting it to the first list. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def shift(grid):\\n            for i in range(len(grid) - 1):\\n                grid[i + 1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop())\\n            return grid\\n        for i in range(k):\\n            shift(grid)\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def shift(grid):\\n            for i in range(len(grid) - 1):\\n                grid[i + 1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop())\\n            return grid\\n        for i in range(k):\\n            shift(grid)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689101,
                "title": "o-1-space-easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n = len(grid)\\n        m  = len(grid[0])\\n        \\n        temp = float(\"inf\")\\n        \\n        \\n        for t in range(0,k):\\n        \\n            for i in range(0,n):\\n\\n                for j in range(0,m):\\n\\n                    if(i == 0 and j == 0 ):\\n\\n                        temp =  grid[i][j]\\n\\n                    else:\\n\\n                        t1 = grid[i][j]\\n\\n                        grid[i][j] = temp \\n\\n                        temp = t1 \\n\\n            grid[0][0] = temp\\n        \\n        \\n        return grid\\n\\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n = len(grid)\\n        m  = len(grid[0])\\n        \\n        temp = float(\"inf\")\\n        \\n        \\n        for t in range(0,k):\\n        \\n            for i in range(0,n):\\n\\n                for j in range(0,m):\\n\\n                    if(i == 0 and j == 0 ):\\n\\n                        temp =  grid[i][j]\\n\\n                    else:\\n\\n                        t1 = grid[i][j]\\n\\n                        grid[i][j] = temp \\n\\n                        temp = t1 \\n\\n            grid[0][0] = temp\\n        \\n        \\n        return grid\\n\\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446323,
                "title": "no-extra-space-taken-in-place-time-k-o-n-m-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int m = col;\\n        int total = row*col;\\n        int temp;\\n        while(k>0){\\n            temp = grid[row-1][col-1];\\n            for(int i = row*col-1 ; i>=1 ; i--){\\n                grid[i/m][i%m] = grid[(i-1)/m][(i-1)%m];\\n            }\\n            \\n            grid[0][0] = temp;\\n            \\n            k--;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int m = col;\\n        int total = row*col;\\n        int temp;\\n        while(k>0){\\n            temp = grid[row-1][col-1];\\n            for(int i = row*col-1 ; i>=1 ; i--){\\n                grid[i/m][i%m] = grid[(i-1)/m][(i-1)%m];\\n            }\\n            \\n            grid[0][0] = temp;\\n            \\n            k--;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444389,
                "title": "js-two-solutions-offset-in-place-runtime-83-58-memory-98-51",
                "content": "```\\n// Using .flat() + offset and refilling the grid in-place.\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length, N = grid[0].length;\\n\\tlet flat = grid.flat();\\n\\tif (k > flat.length) k = k % flat.length;\\n\\tlet shft = flat.splice(flat.length - k, k);\\n\\tflat.unshift(...shft);\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++) {\\n\\t\\t\\tgrid[i][j] = flat[i*N + j];\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n```\\n\\n```\\n// Grid copy + new position calculation\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length;\\n\\tconst N = grid[0].length;\\n\\tlet res = Array.from({length: M}, (v, k) => new Int16Array(N));\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++){\\n\\t\\t\\tlet newCol = (j + k) % N;\\n\\t\\t\\tlet newRow = (i + (j+k)/N) % M;\\n\\t\\t\\tres[~~newRow][newCol] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Using .flat() + offset and refilling the grid in-place.\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length, N = grid[0].length;\\n\\tlet flat = grid.flat();\\n\\tif (k > flat.length) k = k % flat.length;\\n\\tlet shft = flat.splice(flat.length - k, k);\\n\\tflat.unshift(...shft);\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++) {\\n\\t\\t\\tgrid[i][j] = flat[i*N + j];\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n```\n```\\n// Grid copy + new position calculation\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length;\\n\\tconst N = grid[0].length;\\n\\tlet res = Array.from({length: M}, (v, k) => new Int16Array(N));\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++){\\n\\t\\t\\tlet newCol = (j + k) % N;\\n\\t\\t\\tlet newRow = (i + (j+k)/N) % M;\\n\\t\\t\\tres[~~newRow][newCol] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2440236,
                "title": "c-solution-beats-96-21-of-cpp-submissions",
                "content": "The problem is similar to right rotating a 1d array k times. We can implement the same in this problem. Reverse the last k elements of the flattened version of the input array, and reverse the first n-k elements of the input array.  Then Reverse the whole 2d array. This solution does the job in-place.\\n\\n```\\n\\tvoid reverse(vector<vector<int>> &grid, int l, int r, int n){\\n        int r1, c1, r2, c2;\\n        for(int i = l, j = r; i < j; i++, j--){\\n            r1 = i/n;\\n            c1 = i%n;\\n            r2 = j/n;\\n            c2 = j%n;\\n            swap(grid[r1][c1], grid[r2][c2]);\\n        }\\n    }\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sz = m*n;\\n        k = k % sz;\\n        reverse(grid, sz-k, sz-1, n);\\n        reverse(grid, 0, sz-k-1, n);\\n        reverse(grid, 0, sz-1, n);\\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n\\tvoid reverse(vector<vector<int>> &grid, int l, int r, int n){\\n        int r1, c1, r2, c2;\\n        for(int i = l, j = r; i < j; i++, j--){\\n            r1 = i/n;\\n            c1 = i%n;\\n            r2 = j/n;\\n            c2 = j%n;\\n            swap(grid[r1][c1], grid[r2][c2]);\\n        }\\n    }\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sz = m*n;\\n        k = k % sz;\\n        reverse(grid, sz-k, sz-1, n);\\n        reverse(grid, 0, sz-k-1, n);\\n        reverse(grid, 0, sz-1, n);\\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2023525,
                "title": "c-flatten-rotate-locate",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& a, int k) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int> b(n*m);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                b[i*m + j] = a[i][j];\\n            }\\n        }\\n        \\n        k %= (n*m);\\n        \\n        rotate(b.begin(), b.end()-k, b.end());\\n        \\n        for(int i=0; i<n*m; i++)\\n        {\\n            a[i/m][i%m] = b[i];\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& a, int k) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int> b(n*m);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                b[i*m + j] = a[i][j];\\n            }\\n        }\\n        \\n        k %= (n*m);\\n        \\n        rotate(b.begin(), b.end()-k, b.end());\\n        \\n        for(int i=0; i<n*m; i++)\\n        {\\n            a[i/m][i%m] = b[i];\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941495,
                "title": "c-clean-code-simple-concise-easy",
                "content": "**Runtime: 16 ms**\\n***Faster than 90% solution in c++***\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int newpos= (i*n+j+k) % (m*n);      \\n                res[newpos/n][newpos%n]=grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int newpos= (i*n+j+k) % (m*n);      \\n                res[newpos/n][newpos%n]=grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937791,
                "title": "python-pop-insert-in-next-row",
                "content": "Remove the last element in each row and insert it at the beggining of the next row. \\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for i in range(k):\\n\\t\\t\\t#take last element in the matrix and move it to first position\\n            grid[0].insert(0, grid[-1].pop())\\n\\t\\t\\t\\n\\t\\t\\t# for each row after 1st row, pop last element in previous row, then add it to the beginning of current row\\n            for j in range(1,len(grid)):\\n                grid[j].insert(0, grid[j-1].pop())\\n        return grid\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for i in range(k):\\n\\t\\t\\t#take last element in the matrix and move it to first position\\n            grid[0].insert(0, grid[-1].pop())\\n\\t\\t\\t\\n\\t\\t\\t# for each row after 1st row, pop last element in previous row, then add it to the beginning of current row\\n            for j in range(1,len(grid)):\\n                grid[j].insert(0, grid[j-1].pop())\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937731,
                "title": "c-simple-solution-with-explanation-o-n-m-100-faster",
                "content": "The idea is to map the two dimensional array position to a postion in an imaginary one dimensional array from (0 to m*n -1).\\nIt can be done with i * n + j. \\nThen sum k to get the 1d array new position and get module to avoid having a number greater than the max length of the imaginary 1d array.\\nLast, convert the 1d new position to the 2d array postions with the x = newPosition/n and y = newPosition%n\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        var maxLength = m * n;\\n        \\n        // initialize result\\n        var result = new List<IList<int>>(m);\\n        for (int i = 0; i < m; i++)\\n        {\\n            result.Add(new List<int>(n));\\n            for (int j = 0; j < n; j++)\\n            {\\n               result[i].Add(0);\\n            }\\n        }\\n        \\n        // make the shifted grid\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                var currPosition = i*n + j;\\n                var newPosition = (currPosition + k) % maxLength;\\n                var x = newPosition / n;\\n                var y = newPosition % n;\\n                result[x][y] = grid[i][j];\\n            }\\n        }        \\n        return result;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/236a29de-fbe5-48ac-847c-01a10f7994fa_1649719535.5562575.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        var maxLength = m * n;\\n        \\n        // initialize result\\n        var result = new List<IList<int>>(m);\\n        for (int i = 0; i < m; i++)\\n        {\\n            result.Add(new List<int>(n));\\n            for (int j = 0; j < n; j++)\\n            {\\n               result[i].Add(0);\\n            }\\n        }\\n        \\n        // make the shifted grid\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                var currPosition = i*n + j;\\n                var newPosition = (currPosition + k) % maxLength;\\n                var x = newPosition / n;\\n                var y = newPosition % n;\\n                result[x][y] = grid[i][j];\\n            }\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937678,
                "title": "python-3-inplace-triple-reverse-doug-mcilroy-and-gcd-solutions",
                "content": "Straightforward solution is very boring, how could we do that inplace?\\n\\nAnother boring thing is Programming Pearls solution (page 33) aka triple reverse (by Doug Mcilroy). Even if it\\'s 1D you can easlily remap it to 2D grid:\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        def reverse(a, b):\\n            for i in range(a, (a + b)//2):\\n                j = a + b - i - 1\\n                grid[j//w][j%w], grid[i//w][i%w] = grid[i//w][i%w], grid[j//w][j%w]\\n        reverse(0, shift)\\n        reverse(shift, n)\\n        reverse(0, n)\\n        return grid\\n```\\n\\nIt\\'s very suboptimal though, because you have to address every element at least twice not counting the swaps. There\\'s an optimal solution that works in O(n) for 1D, or O(n x m) for 2D grid mentioned here: https://stackoverflow.com/questions/876293/fastest-algorithm-for-circle-shift-n-sized-array-for-m-position\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        for i in range(gcd(n, shift)):\\n            j = i\\n            while (k := (j + shift) % n) != i:\\n                grid[j//w][j%w], grid[k//w][k%w] = grid[k//w][k%w], grid[j//w][j%w]\\n                j = k\\n        return grid\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        def reverse(a, b):\\n            for i in range(a, (a + b)//2):\\n                j = a + b - i - 1\\n                grid[j//w][j%w], grid[i//w][i%w] = grid[i//w][i%w], grid[j//w][j%w]\\n        reverse(0, shift)\\n        reverse(shift, n)\\n        reverse(0, n)\\n        return grid\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        for i in range(gcd(n, shift)):\\n            j = i\\n            while (k := (j + shift) % n) != i:\\n                grid[j//w][j%w], grid[k//w][k%w] = grid[k//w][k%w], grid[j//w][j%w]\\n                j = k\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937599,
                "title": "javascript-neat-3-methods-flat-flat-in-place-in-place",
                "content": "## 1. Flat\\nComplexity: time **O(3mn)**, extra space **O(2mn)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = m * n;\\n  k = mn - k % mn;\\n  const res = grid.flat();\\n  res.splice(0, 0, ...res.splice(k));\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\\n\\n## 2. Flat In Place\\nComplexity: time **O(4mn)**, extra space **O(mn)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const res = grid.flat();\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j)\\n      [res[i], res[j]] = [res[j], res[i]]\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\\n\\n## 3. In Place\\nComplexity: time **O(2mn)**, extra space **O(1)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const xy = (i) => [i % n, (i / n) | 0];\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j) {\\n      const [Xi, Yi] = xy(i), [Xj, Yj] = xy(j);\\n      [grid[Yi][Xi], grid[Yj][Xj]] = [grid[Yj][Xj], grid[Yi][Xi]];\\n    }\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return grid;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = m * n;\\n  k = mn - k % mn;\\n  const res = grid.flat();\\n  res.splice(0, 0, ...res.splice(k));\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const res = grid.flat();\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j)\\n      [res[i], res[j]] = [res[j], res[i]]\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\n```js\\nconst shiftGrid = (grid, k) => {\\n  const n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const xy = (i) => [i % n, (i / n) | 0];\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j) {\\n      const [Xi, Yi] = xy(i), [Xj, Yj] = xy(j);\\n      [grid[Yi][Xi], grid[Yj][Xj]] = [grid[Yj][Xj], grid[Yi][Xi]];\\n    }\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937582,
                "title": "easy-c",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n\\n                int newj = (j+k)%c;\\n                \\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n\\n                int newj = (j+k)%c;\\n                \\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1937552,
                "title": "kotlin-100-time-and-space-easy-solution-with-explanation",
                "content": "At first, I was trying an approach where I calculate a toRow and toCol, but had difficulty getting them right without a paper and pencil.  Then I realized it\\'s much easier to just have a one-dimensional array for the elements, start at the kth position (called \"to\"), and just copy the items from the beginning of the grid to \"to\" and keep incrementing \"to\" by 1.\\n\\n\"to\" starts at k % size (# of rows * # of columns), which automatically makes is zero-based.  To save time, the first check is to see if k % size is 0, in which case nothing needs to be shifted, just turn the rows into lists and add them to the output list, and return.\\n\\nThe second speed saving is if the size of each row is 1.  In that case, still create an output array the size of the grid and copy the items in, starting at to, always column 0 in th grid.  Then, each item is its own list, so go through the array and add each one as a list, and return.\\n\\nWhenever \"to\" reaches the end of the list ( == size), reset to 0.\\n\\nFinally, starting at the begining of the output grid (to = 0), create a new list for each row, and add column number of items to the list, and then add that list to the out list.\\n\\n```\\nfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n        var out = MutableList<List<Int>>(0) { List<Int>(0) { 0 } }\\n        var rows = grid.size\\n        var cols = grid[0].size\\n        var size = rows * cols\\n        if (k % size == 0) {\\n            var list : List<Int>\\n            for (line in grid) {\\n                list = line.toList()\\n                out.add(list)\\n            }\\n            return out\\n        }\\n        var outGrid = IntArray(size) \\n        var to = k % size\\n        if (cols == 1) {\\n            for (row in 0..rows - 1) {\\n                outGrid[to++] = grid[row][0]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n            for (n in outGrid) {\\n                out.add(listOf(n))\\n                }\\n            return out\\n        }\\n        for (row in 0..rows - 1) {\\n            for (col in 0..cols - 1) {\\n                outGrid[to++] = grid[row][col]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n        }\\n        to = 0\\n        var list : MutableList<Int>\\n        for (row in 0..rows - 1) {\\n            list = mutableListOf<Int>(outGrid[to++])\\n            for (col in 1..cols - 1) {\\n                list.add(outGrid[to++])\\n            }\\n            out.add(list)\\n        }\\n        return out\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n        var out = MutableList<List<Int>>(0) { List<Int>(0) { 0 } }\\n        var rows = grid.size\\n        var cols = grid[0].size\\n        var size = rows * cols\\n        if (k % size == 0) {\\n            var list : List<Int>\\n            for (line in grid) {\\n                list = line.toList()\\n                out.add(list)\\n            }\\n            return out\\n        }\\n        var outGrid = IntArray(size) \\n        var to = k % size\\n        if (cols == 1) {\\n            for (row in 0..rows - 1) {\\n                outGrid[to++] = grid[row][0]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n            for (n in outGrid) {\\n                out.add(listOf(n))\\n                }\\n            return out\\n        }\\n        for (row in 0..rows - 1) {\\n            for (col in 0..cols - 1) {\\n                outGrid[to++] = grid[row][col]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n        }\\n        to = 0\\n        var list : MutableList<Int>\\n        for (row in 0..rows - 1) {\\n            list = mutableListOf<Int>(outGrid[to++])\\n            for (col in 1..cols - 1) {\\n                list.add(outGrid[to++])\\n            }\\n            out.add(list)\\n        }\\n        return out\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937526,
                "title": "golang-o-1-space",
                "content": "```go\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    \\n    i := func(x int) int { return x / n }\\n    j := func(x int) int { return x % n }\\n    \\n    for k = k % (m*n); k > 0; k-- {\\n        tmp := grid[m-1][n-1]\\n        for ii := m*n-1; ii > 0; ii-- {\\n            grid[i(ii)][j(ii)] = grid[i(ii-1)][j(ii-1)]\\n        }\\n        grid[0][0] = tmp\\n    }\\n    \\n    return grid\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    \\n    i := func(x int) int { return x / n }\\n    j := func(x int) int { return x % n }\\n    \\n    for k = k % (m*n); k > 0; k-- {\\n        tmp := grid[m-1][n-1]\\n        for ii := m*n-1; ii > 0; ii-- {\\n            grid[i(ii)][j(ii)] = grid[i(ii-1)][j(ii-1)]\\n        }\\n        grid[0][0] = tmp\\n    }\\n    \\n    return grid\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937511,
                "title": "python-short-functional-programming-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: list[list[int]], k_: int) -> list[list[int]]:\\n        m, n = len(grid), len(grid[0])\\n        t = m * n\\n        k = k_ % t\\n        \\n        initial_nums = chain.from_iterable(grid)\\n        shifted_nums = islice(cycle(initial_nums), t - k, t - k + t)\\n        \\n        # If asked for inplace (side effects and not FP):\\n        # for i, j in product(range(m), range(n)): grid[i][j] = next(shifted_nums)\\n        # return grid\\n        \\n        return [list(islice(shifted_nums, n)) for _ in range(m)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: list[list[int]], k_: int) -> list[list[int]]:\\n        m, n = len(grid), len(grid[0])\\n        t = m * n\\n        k = k_ % t\\n        \\n        initial_nums = chain.from_iterable(grid)\\n        shifted_nums = islice(cycle(initial_nums), t - k, t - k + t)\\n        \\n        # If asked for inplace (side effects and not FP):\\n        # for i, j in product(range(m), range(n)): grid[i][j] = next(shifted_nums)\\n        # return grid\\n        \\n        return [list(islice(shifted_nums, n)) for _ in range(m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937476,
                "title": "rust-rotate-in-place-same-as-189-rotate-array",
                "content": "The \"shift\" steps describe how to \"rotate\" a 1-D array by 1 element to the right by using its 2-d representation. Take the first example - if we convert the 2D matrix to 1D array:`[[1,2,3],[4,5,6],[7,8,9]] => [1,2,3,4,5,6,7,8,9]` and then rotate the 1D array by 1 element to the right we will get `[9, 1,2,3,4,5,6,7,8]` and then in order to get the answer we have to convert it back to a 2D representation: `[[9,1,2],[3,4,5],[6,7,8]]` \\n\\nIf we execute the steps of the \"shift\" algorithm we find out that it actually shifts all cells by 1 to the right. So doing the \"shift\" operation K times is equivalient to shiftingk by K positons only once. \\n\\nFrom  [189. Rotate Array](https://github.com/SvetlinZarev/coding-challenges/blob/main/leetcode/100%20-%20199/189%20-%20Rotate%20Array.md) we have already learned how to rorate (shift) a 1D array. We just have to apply that knowledge by extending it to a 2D array. This can be done by finding out how to go from 1D index, to a 2D index and vice cersa:\\n\\n* The formula to convert from 2D index to 1D index is `row * columns + column`\\n* The formula to convert from 1D index to 2D index is:\\n    * `row = index / columns`\\n    * `col = index % columns`\\n\\n\\n\\nNow we know that we can go from 2D to 1D matrix, rotate it, and then go back to 2D matrix.This means that we can use the same approach as in [189. Rotate Array](https://github.com/SvetlinZarev/coding-challenges/blob/main/leetcode/100%20-%20199/189%20-%20Rotate%20Array.md):\\n\\n```rust\\npub fn shift_grid(mut grid: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n    let elements = grid.len() * grid[0].len();\\n    let k = (k as usize) % elements;\\n    if k == 0 || elements == 1 {\\n        return grid;\\n    }\\n\\n    reverse(&mut grid, 0, elements);\\n    reverse(&mut grid, 0, k);\\n    reverse(&mut grid, k, elements);\\n    grid\\n}\\n\\nfn reverse(grid: &mut [Vec<i32>], from: usize, to: usize) {\\n    if from >= to {\\n        return;\\n    }\\n    let cols = grid[0].len();\\n\\n    let mut a = from;\\n    let mut b = to - 1;\\n\\n    while a < b {\\n        let cell = grid[a / cols][a % cols];\\n        grid[a / cols][a % cols] = grid[b / cols][b % cols];\\n        grid[b / cols][b % cols] = cell;\\n\\n        a += 1;\\n        b -= 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn shift_grid(mut grid: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n    let elements = grid.len() * grid[0].len();\\n    let k = (k as usize) % elements;\\n    if k == 0 || elements == 1 {\\n        return grid;\\n    }\\n\\n    reverse(&mut grid, 0, elements);\\n    reverse(&mut grid, 0, k);\\n    reverse(&mut grid, k, elements);\\n    grid\\n}\\n\\nfn reverse(grid: &mut [Vec<i32>], from: usize, to: usize) {\\n    if from >= to {\\n        return;\\n    }\\n    let cols = grid[0].len();\\n\\n    let mut a = from;\\n    let mut b = to - 1;\\n\\n    while a < b {\\n        let cell = grid[a / cols][a % cols];\\n        grid[a / cols][a % cols] = grid[b / cols][b % cols];\\n        grid[b / cols][b % cols] = cell;\\n\\n        a += 1;\\n        b -= 1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937433,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func shiftGrid(_ g: [[Int]], _ k: Int) -> [[Int]] {\\n        if k == 0 { return g }\\n        let row = g.count, col = g[0].count\\n        var grid = g\\n        for r in 0..<row {\\n            for c in 0..<col {\\n                let rw1 = (r + (c + k) / col) % row\\n                let cl1 = (c + k) % col\\n                grid[rw1][cl1] = g[r][c]\\n            }\\n        }\\n        return grid\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 1)\\n        XCTAssertEqual(value, [[9,1,2],[3,4,5],[6,7,8]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.shiftGrid([[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], 4)\\n        XCTAssertEqual(value, [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]])\\n    }\\n    \\n    func test2() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 9)\\n        XCTAssertEqual(value, [[1,2,3],[4,5,6],[7,8,9]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func shiftGrid(_ g: [[Int]], _ k: Int) -> [[Int]] {\\n        if k == 0 { return g }\\n        let row = g.count, col = g[0].count\\n        var grid = g\\n        for r in 0..<row {\\n            for c in 0..<col {\\n                let rw1 = (r + (c + k) / col) % row\\n                let cl1 = (c + k) % col\\n                grid[rw1][cl1] = g[r][c]\\n            }\\n        }\\n        return grid\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 1)\\n        XCTAssertEqual(value, [[9,1,2],[3,4,5],[6,7,8]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.shiftGrid([[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], 4)\\n        XCTAssertEqual(value, [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]])\\n    }\\n    \\n    func test2() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 9)\\n        XCTAssertEqual(value, [[1,2,3],[4,5,6],[7,8,9]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937377,
                "title": "c-easy-solution-using-extra-and-without-extra-space",
                "content": "**Method 1:**\\nTime Complexity : O(n*m)\\nSpace Complexity : O(m*n)\\n\\n\\n```\\n  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        deque<int>dq;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                dq.push_back(grid[i][j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            dq.push_front(dq.back());\\n            dq.pop_back();\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                grid[i][j]=dq.front();\\n                dq.pop_front();\\n            }\\n        }\\n    return grid;\\n    }\\n```\\n\\n**Method 2:\\nTime Complexity: O(n*m*k)**\\n**Space Complexity : O(k)**\\n\\n```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n      \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        int temp = -1;\\n        if(k==0)\\n           return grid;\\n            for(int i=0;i<m;i++)\\n           {  \\n             for(int j=0;j<n;j++)\\n             {\\n                swap(temp,grid[i][j]);\\n             }\\n          }\\n        swap(temp,grid[0][0]);\\n       \\n       return shiftGrid(grid,k-1); \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\n  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        deque<int>dq;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                dq.push_back(grid[i][j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            dq.push_front(dq.back());\\n            dq.pop_back();\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                grid[i][j]=dq.front();\\n                dq.pop_front();\\n            }\\n        }\\n    return grid;\\n    }\\n```\n```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n      \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        int temp = -1;\\n        if(k==0)\\n           return grid;\\n            for(int i=0;i<m;i++)\\n           {  \\n             for(int j=0;j<n;j++)\\n             {\\n                swap(temp,grid[i][j]);\\n             }\\n          }\\n        swap(temp,grid[0][0]);\\n       \\n       return shiftGrid(grid,k-1); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937351,
                "title": "c-2-approach-with-extra-space-without-extra-space",
                "content": "**First Approach :** Without extra space (Optimal Solution)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int temp =-1;\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                swap(grid[i][j], temp);\\n            }\\n        }\\n        swap(temp,grid[0][0]);\\n        return shiftGrid(grid,k-1);  //recursive call \\n        \\n    }\\n};\\n\\n```\\n\\n**Second Approach :** Here extra space used and call the recursion for k-1 steps.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // set all the values of the matrix is zero\\n        vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return shiftGrid(v,k-1);  //recursive call     \\n    }\\n};\\n```\\n\\nIf anyone didn\\'t understand how  the recursion works they can understand the concept by the below code.\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>myfunction(vector<vector<int>>&grid, int m, int n){\\n          vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return v;\\n    }  \\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>temp(m,vector<int>(n,0));\\n        while(k-->0){\\n            temp = myfunction(grid,m,n);\\n            grid = temp;   \\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int temp =-1;\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                swap(grid[i][j], temp);\\n            }\\n        }\\n        swap(temp,grid[0][0]);\\n        return shiftGrid(grid,k-1);  //recursive call \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // set all the values of the matrix is zero\\n        vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return shiftGrid(v,k-1);  //recursive call     \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>myfunction(vector<vector<int>>&grid, int m, int n){\\n          vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return v;\\n    }  \\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>temp(m,vector<int>(n,0));\\n        while(k-->0){\\n            temp = myfunction(grid,m,n);\\n            grid = temp;   \\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937324,
                "title": "c-clean",
                "content": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> shift_grid(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j) {\\n                int rowPlus = (j + k) / n;\\n                int colnOffset = (j + k) % n;\\n                int rowOffset = (i + rowPlus) % m;\\n                \\n                shift_grid[rowOffset][colnOffset] = grid[i][j];\\n            }\\n        return shift_grid;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> shift_grid(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j) {\\n                int rowPlus = (j + k) / n;\\n                int colnOffset = (j + k) % n;\\n                int rowOffset = (i + rowPlus) % m;\\n                \\n                shift_grid[rowOffset][colnOffset] = grid[i][j];\\n            }\\n        return shift_grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937312,
                "title": "c-solution-no-extra-space-hard-solution",
                "content": "Maybe the hardest solution but I found this approach a little intresting....\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size(),col=grid[0].size(),temp=grid[0][0],prev;\\n\\t\\tk=k%(row*col);\\n        while(k!=0){\\n\\t\\t\\n        for(int i=0;i<row;i++){\\n\\t\\t\\n            for(int j=0;j<col;j++){\\n\\t\\t\\t\\n                if(j==(col-1)){\\n\\t\\t\\t\\t\\n                    if(i==(row-1)){\\n\\t\\t\\t\\t\\t\\n                        grid[0][0]=temp;\\n                        swap(grid[0][0],grid[i][j]);\\n\\t\\t\\t\\t\\t\\t\\n                    }\\n\\t\\t\\t\\t\\t\\n                    else{\\n\\t\\t\\t\\t\\t\\n                        prev=grid[i][j];\\n                        grid[i][j]=temp;\\n                        temp=prev;\\n\\t\\t\\t\\t\\t\\t\\n                    }\\n\\t\\t\\t\\t\\t\\n                }\\n\\t\\t\\t\\t\\n                else{\\n\\t\\t\\t\\t\\n                    prev=grid[i][j];\\n                    grid[i][j]=temp;\\n                    temp=prev;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n           \\t}\\n\\t\\t\\t\\n            k--;\\n\\t\\t\\t\\n        }\\n\\t\\t\\n        return grid;      \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size(),col=grid[0].size(),temp=grid[0][0],prev;\\n\\t\\tk=k%(row*col);\\n        while(k!=0){\\n\\t\\t\\n        for(int i=0;i<row;i++){\\n\\t\\t\\n            for(int j=0;j<col;j++){\\n\\t\\t\\t\\n                if(j==(col-1)){\\n\\t\\t\\t\\t\\n                    if(i==(row-1)){\\n\\t\\t\\t\\t\\t\\n                        grid[0][0]=temp;\\n                        swap(grid[0][0],grid[i][j]);\\n\\t\\t\\t\\t\\t\\t\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1937310,
                "title": "simple-code-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0)\\n            return grid;\\n        vector<int>v,ans,v4;\\n       int n= grid.size();\\n        vector<vector<int>>res;\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++)\\n        {\\n             \\n             for(int j=0; j<m; j++)\\n              {\\n                 v.push_back(grid[i][j]);\\n              }\\n        }\\n        int k1=k;\\n      \\n        k=k%(m*n);\\n           for(int j=v.size()-1; j>=v.size()-k; j--)\\n              {\\n                 ans.push_back(v[j]);\\n              }\\n        reverse(ans.begin(),ans.end());\\n        for(int j=0; j<v.size()-k; j++)\\n              {\\n                 ans.push_back(v[j]);\\n              }\\n         \\n        int j=1;\\n        vector<int>v3;\\n        for(int i=0; i<ans.size(); i++)\\n        {\\n            if(j%m==0)\\n            {   v3.push_back(ans[i]);\\n                res.push_back(v3);\\n                v3.clear();\\n            }\\n            else\\n                v3.push_back(ans[i]);\\n            j++;\\n            \\n            \\n        }\\n              \\n     return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0)\\n            return grid;\\n        vector<int>v,ans,v4;\\n       int n= grid.size();\\n        vector<vector<int>>res;\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++)\\n        {\\n             \\n             for(int j=0; j<m; j++)\\n              {\\n                 v.push_back(grid[i][j]);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1937228,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n   \\tpublic static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tshift(grid);\\n\\n\\t\\tfor (int[] arr : grid) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tlist.add(Integer.valueOf(arr[i]));\\n\\t\\t\\tres.add(list);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic static void shift(int[][] grid) {\\n\\t\\tList<Integer> lastElements = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\t\\tlastElements.add(grid[i][grid[i].length - 1]);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\n\\t\\t\\tfor (int j = grid[i].length - 1; j > 0; j--) {\\n\\t\\t\\t\\tgrid[i][j] = grid[i][j - 1];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\t\\tif (i != grid.length - 1)\\n\\t\\t\\t\\tgrid[i + 1][0] = lastElements.get(i);\\n\\n\\t\\tgrid[0][0] = lastElements.get(lastElements.size() - 1);\\n\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   \\tpublic static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tshift(grid);\\n\\n\\t\\tfor (int[] arr : grid) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tlist.add(Integer.valueOf(arr[i]));\\n\\t\\t\\tres.add(list);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1937118,
                "title": "c-easy-understanding-algorithm-explanation",
                "content": "**Please Upvote If It Helps**\\n\\n**Algorithm**\\n* **Store all the values** in a **vector** temporary\\n\\n* Then maintain the **order that vector** \\n* Put **k values at the start from behind**\\n* Then after maintaining the order **make the pairs** according to the **size of column** \\n* after storing just **return** that \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        // store all the elements in a temp vector\\n        vector<int> temp;\\n        for(auto i : grid)\\n        {\\n            for(auto j : i)\\n            {\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        int n = temp.size();\\n        k = k % n;\\n        \\n        // for storing in the correct sequence\\n        vector<int> res; \\n        \\n        // last k vales at the start\\n        for(int i= n-k; i<n; i++)\\n        {\\n            res.push_back(temp[i]);\\n        }\\n        \\n        // starting values at the end\\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n        \\n        int m = grid[0].size();\\n        temp.clear();\\n        grid.clear();\\n        \\n        for(int i=0;i<res.size();i++)\\n        {\\n            if(temp.size() < m)\\n                temp.push_back(res[i]);\\n            \\n            if(temp.size()==m)\\n            {\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        // store all the elements in a temp vector\\n        vector<int> temp;\\n        for(auto i : grid)\\n        {\\n            for(auto j : i)\\n            {\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        int n = temp.size();\\n        k = k % n;\\n        \\n        // for storing in the correct sequence\\n        vector<int> res; \\n        \\n        // last k vales at the start\\n        for(int i= n-k; i<n; i++)\\n        {\\n            res.push_back(temp[i]);\\n        }\\n        \\n        // starting values at the end\\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n        \\n        int m = grid[0].size();\\n        temp.clear();\\n        grid.clear();\\n        \\n        for(int i=0;i<res.size();i++)\\n        {\\n            if(temp.size() < m)\\n                temp.push_back(res[i]);\\n            \\n            if(temp.size()==m)\\n            {\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937111,
                "title": "clean-code-c-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<vector<int>> ans(rows,vector<int>(cols,0));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                int newVal=((i*cols+j)+k)%(rows*cols);\\n                int newR=newVal/cols;\\n                int newC=newVal%cols;\\n                ans[newR][newC]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<vector<int>> ans(rows,vector<int>(cols,0));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                int newVal=((i*cols+j)+k)%(rows*cols);\\n                int newR=newVal/cols;\\n                int newC=newVal%cols;\\n                ans[newR][newC]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937107,
                "title": "c-simple-solution-single-traversal-m-n-extra-to-make-new-matrix",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        k = k % (m*n);\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                res[(((k + j) / n) + i) % m ][(k + j) % n] = grid[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        k = k % (m*n);\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                res[(((k + j) / n) + i) % m ][(k + j) % n] = grid[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937009,
                "title": "java-easy-beginner-less-complexity-based-on-o-1-space-solution",
                "content": "If you are familiar with [RotateArray](https://leetcode.com/problems/rotate-array/submissions/) and  [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/) this is using concept of both .\\n\\njust assuming matrix as 1D array using arr[i/lenOfRow][i%lenOfRow] and reverse the array and fill the matrix into arraylist and return \\nTC:O(N*M)    SC:O(1)\\nComment if needed improvements ;)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans= new ArrayList<>();\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int len=n*m;\\n            k=k%(m*n);\\n        reverse(grid,len-k,len-1);\\n        reverse(grid,0,len-k-1);\\n        reverse(grid,0,len-1);\\n        for(int i=0;i<m;i++){\\n              List<Integer> l= new ArrayList<>();\\n            for(int j=0;j<n;j++){\\n                l.add(grid[i][j]);\\n            }\\n            ans.add(l);       \\n        }\\n        return ans;\\n    }\\n    public void reverse(int [][] grid,int i,int j){\\n        int n=grid[0].length;\\n        while(i<j){\\n            int temp=grid[i/n][i%n];\\n            grid[i/n][i%n]=grid[j/n][j%n];\\n            grid[j/n][j%n]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans= new ArrayList<>();\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int len=n*m;\\n            k=k%(m*n);\\n        reverse(grid,len-k,len-1);\\n        reverse(grid,0,len-k-1);\\n        reverse(grid,0,len-1);\\n        for(int i=0;i<m;i++){\\n              List<Integer> l= new ArrayList<>();\\n            for(int j=0;j<n;j++){\\n                l.add(grid[i][j]);\\n            }\\n            ans.add(l);       \\n        }\\n        return ans;\\n    }\\n    public void reverse(int [][] grid,int i,int j){\\n        int n=grid[0].length;\\n        while(i<j){\\n            int temp=grid[i/n][i%n];\\n            grid[i/n][i%n]=grid[j/n][j%n];\\n            grid[j/n][j%n]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936972,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936874,
                "title": "java-faster-than-98-right-rotation-of-array",
                "content": "**Flatten 2D Array to 1D Array and apply right rotation. Then convert back to 2D Array.**\\n\\n```\\n public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n      int n = grid.length, m = grid[0].length;  \\n      int arr[] = new int[n*m]; \\n        \\n      int ind = 0;\\n      for(int i=0; i<n; i++){\\n          for(int j=0; j<m; j++)\\n              arr[ind++] = grid[i][j];\\n      }\\n      \\n      k = k%(m*n);\\n      int left = n*m-k-1, right = n*m-k;\\n      reverse(0, left, arr);\\n      reverse(right, n*m-1, arr);\\n      reverse(0, n*m-1, arr);\\n        \\n      List<List<Integer>> ans = new ArrayList<>();\\n      for(int i=0; i<n; i++){\\n         List<Integer> temp = new ArrayList<>();\\n         for(int j=i*m; j<(i+1)*m; j++)\\n             temp.add(arr[j]);\\n         \\n         ans.add(temp);\\n       }\\n        \\n       return ans;\\n    }\\n    \\n    void reverse(int s, int e, int arr[]){\\n       int mid = (s+e)/2; \\n       for(int i=s, j=e; i<=mid && j>=mid; i++,j--){\\n          int temp = arr[i];\\n           arr[i] = arr[j];\\n           arr[j] = temp;\\n       }\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n      int n = grid.length, m = grid[0].length;  \\n      int arr[] = new int[n*m]; \\n        \\n      int ind = 0;\\n      for(int i=0; i<n; i++){\\n          for(int j=0; j<m; j++)\\n              arr[ind++] = grid[i][j];\\n      }\\n      \\n      k = k%(m*n);\\n      int left = n*m-k-1, right = n*m-k;\\n      reverse(0, left, arr);\\n      reverse(right, n*m-1, arr);\\n      reverse(0, n*m-1, arr);\\n        \\n      List<List<Integer>> ans = new ArrayList<>();\\n      for(int i=0; i<n; i++){\\n         List<Integer> temp = new ArrayList<>();\\n         for(int j=i*m; j<(i+1)*m; j++)\\n             temp.add(arr[j]);\\n         \\n         ans.add(temp);\\n       }\\n        \\n       return ans;\\n    }\\n    \\n    void reverse(int s, int e, int arr[]){\\n       int mid = (s+e)/2; \\n       for(int i=s, j=e; i<=mid && j>=mid; i++,j--){\\n          int temp = arr[i];\\n           arr[i] = arr[j];\\n           arr[j] = temp;\\n       }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936841,
                "title": "c-90-faster-41-space-8-lines",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n    int m = grid.size(), n=grid[0].size(), row, col, ele;\\n    vector<vector<int>> result(m, vector<int>(n,0));\\n    k%=(m*n);\\n    for(int i=0;i<m;++i)\\n        for(int j=0;j<n;++j){\\n            ele = (i*n)+j+k;\\n            row = (ele/n)%m;\\n            col = (j+k)%n;\\n            result[row][col] = grid[i][j];\\n        }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n    int m = grid.size(), n=grid[0].size(), row, col, ele;\\n    vector<vector<int>> result(m, vector<int>(n,0));\\n    k%=(m*n);\\n    for(int i=0;i<m;++i)\\n        for(int j=0;j<n;++j){\\n            ele = (i*n)+j+k;\\n            row = (ele/n)%m;\\n            col = (j+k)%n;\\n            result[row][col] = grid[i][j];\\n        }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936727,
                "title": "js-modulo-arithmetic-no-stdlib-methods-faster-than-98",
                "content": "This solution is based on a circular list approach, where we \"connect\" the end to the beginning. Knowing dimensions of a matrix, we can work with it as a 1-dimensional array, where iterating all elements looks like `rowIndex * rowSize + columnIndex`. This also means that given an element index `i`, we can find row and column indices - `rowIndex = i / rowSize` (as an integer), `columnIndex = i mod rowSize`.\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar shiftGrid = function(grid, k) {\\n  const xSize = grid[0].length;\\n  const elements = xSize * grid.length;\\n\\n  // no need to shift if it\\'s a full loop\\n  if (k === elements) {\\n    return grid;\\n  }\\n  \\n  const offset = k % elements;\\n  \\n  // use modulo arithmetic to map 1-dim array index to matrix row and column position (2-dim array)\\n  // X is a column index, Y is a row index\\n  const coord = (idx) => [\\n    idx % xSize, // X\\n    Math.floor(idx / xSize), // Y\\n  ];\\n  \\n  const overflow = Array(offset);\\n  for (let i = elements - 1; i >= 0; i--) {\\n    // matrix coordinates of where an element is going to be moved\\n    const [newX, newY] = coord(i);\\n\\n    // save the last \"offset\" elements to be prepended later\\n    if (i >= elements - offset) {\\n      overflow[elements - i - 1] = grid[newY][newX];\\n    }    \\n    \\n    // get the saved elements and write them to the beginning\\n    if (i < offset) {\\n      grid[newY][newX] = overflow[offset - i - 1];\\n      continue;\\n    }\\n    \\n    // move the rest by offset positions\\n    const [oldX, oldY] = coord(i - offset);\\n    grid[newY][newX] = grid[oldY][oldX];\\n  }\\n  \\n  return grid;\\n};\\n```\\n\\nI\\'m new to Leetcode and I don\\'t understand how performance measurement works but the best run was **80ms with 47MB** of memory used, which is **faster than 98.7% and takes less memory than 93.51%** of solutions at the time of submission.",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar shiftGrid = function(grid, k) {\\n  const xSize = grid[0].length;\\n  const elements = xSize * grid.length;\\n\\n  // no need to shift if it\\'s a full loop\\n  if (k === elements) {\\n    return grid;\\n  }\\n  \\n  const offset = k % elements;\\n  \\n  // use modulo arithmetic to map 1-dim array index to matrix row and column position (2-dim array)\\n  // X is a column index, Y is a row index\\n  const coord = (idx) => [\\n    idx % xSize, // X\\n    Math.floor(idx / xSize), // Y\\n  ];\\n  \\n  const overflow = Array(offset);\\n  for (let i = elements - 1; i >= 0; i--) {\\n    // matrix coordinates of where an element is going to be moved\\n    const [newX, newY] = coord(i);\\n\\n    // save the last \"offset\" elements to be prepended later\\n    if (i >= elements - offset) {\\n      overflow[elements - i - 1] = grid[newY][newX];\\n    }    \\n    \\n    // get the saved elements and write them to the beginning\\n    if (i < offset) {\\n      grid[newY][newX] = overflow[offset - i - 1];\\n      continue;\\n    }\\n    \\n    // move the rest by offset positions\\n    const [oldX, oldY] = coord(i - offset);\\n    grid[newY][newX] = grid[oldY][oldX];\\n  }\\n  \\n  return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936571,
                "title": "js-time-o-mn-space-o-1-in-place-operations",
                "content": "The main idea of the solution is to count greatest common divisor between number of shifts we need to make and the total amount of elements. gcd here will show us the number of operations, before our algorithm starts to cycle. After each cycle we will start to proceed the remaining elements. And so on.\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    const m=grid.length,n=grid[0].length,count=m*n;\\n    const turns = k%count;\\n    \\n    const divisor = gcd(count, turns);\\n    \\n    for (let i=0;i<divisor;i++) {\\n        let previousElement = grid[countX(i,n)][countY(i,n)]; // store initial element\\n        let currentElement = i; // current element index if we imagine our matrix as 1d array(x*m+y)\\n        for (let j=0;j<count/divisor;j++) {\\n            currentElement = (currentElement + k) % count; // shifting current element\\n            const x = countX(currentElement, n);\\n            const y = countY(currentElement, n);\\n            const temp = grid[x][y]; // performs swapping in old fashion way to reduce space complexity\\n            grid[x][y] = previousElement;\\n            previousElement = temp;\\n        }\\n    }\\n\\n    return grid;\\n};\\n\\nfunction countX(val, columns) {\\n    return ~~(val/columns); // surprisingly, it performs much faster than Math.trunc/round\\n}\\n\\nfunction countY(val, columns) {\\n    return val%columns;\\n}\\n\\nfunction gcd(a, b) {\\n  if (!b) {\\n    return a;\\n  }\\n\\n  return gcd(b, a % b);\\n}\\n```\\n\\nTime complexity: O(mn)\\nSpace complexity: O(1)\\nFeature: In-place",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(grid, k) {\\n    const m=grid.length,n=grid[0].length,count=m*n;\\n    const turns = k%count;\\n    \\n    const divisor = gcd(count, turns);\\n    \\n    for (let i=0;i<divisor;i++) {\\n        let previousElement = grid[countX(i,n)][countY(i,n)]; // store initial element\\n        let currentElement = i; // current element index if we imagine our matrix as 1d array(x*m+y)\\n        for (let j=0;j<count/divisor;j++) {\\n            currentElement = (currentElement + k) % count; // shifting current element\\n            const x = countX(currentElement, n);\\n            const y = countY(currentElement, n);\\n            const temp = grid[x][y]; // performs swapping in old fashion way to reduce space complexity\\n            grid[x][y] = previousElement;\\n            previousElement = temp;\\n        }\\n    }\\n\\n    return grid;\\n};\\n\\nfunction countX(val, columns) {\\n    return ~~(val/columns); // surprisingly, it performs much faster than Math.trunc/round\\n}\\n\\nfunction countY(val, columns) {\\n    return val%columns;\\n}\\n\\nfunction gcd(a, b) {\\n  if (!b) {\\n    return a;\\n  }\\n\\n  return gcd(b, a % b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936568,
                "title": "a-in-place-solution",
                "content": "It consists of two concepts:\\n1. In-place array shifting/rotating can be decomposed into 3 reverse operations.\\n\\te.x.\\n\\t\\t[1, 2, 3, 4, 5] right rotate 2  => [4, 5, 1, 2, 3]\\n\\tequals to \\n\\t\\t[1, 2, 3, 4, 5] reverse  =>  [5, 4, 3, 2, 1] reverse first 2  => [<u>4, 5</u>, 3, 2, 1] reverse rest of the elements  =>  [4, 5, <u>1, 2, 3</u>]\\n2. The coordinate conversion between 1D and 2D can be achieved by \\'/\\' and \\'%\\' operators with the width n of the 2D matrix.\\n```\\nvoid reverse(vector<vector<int>>& grid, int n, int a, int b)\\n{\\n\\tint ix, iy, jx, jy;\\n\\t\\n\\tfor (int i = a, j = b; i < j; ++i, --j)\\n\\t{\\n\\t\\tix = i / n;\\n\\t\\tiy = i % n;\\n\\t\\tjx = j / n;\\n\\t\\tjy = j % n;\\n\\t\\t\\n\\t\\tswap(grid[ix][iy], grid[jx][jy]);\\n\\t}\\n}\\n\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tint l = m * n;\\n\\tk %= l;\\n\\t\\n\\treverse(grid, n, 0, l - 1);\\n\\treverse(grid, n, 0, k - 1);\\n\\treverse(grid, n, k, l - 1);\\n\\t\\n\\treturn grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverse(vector<vector<int>>& grid, int n, int a, int b)\\n{\\n\\tint ix, iy, jx, jy;\\n\\t\\n\\tfor (int i = a, j = b; i < j; ++i, --j)\\n\\t{\\n\\t\\tix = i / n;\\n\\t\\tiy = i % n;\\n\\t\\tjx = j / n;\\n\\t\\tjy = j % n;\\n\\t\\t\\n\\t\\tswap(grid[ix][iy], grid[jx][jy]);\\n\\t}\\n}\\n\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tint l = m * n;\\n\\tk %= l;\\n\\t\\n\\treverse(grid, n, 0, l - 1);\\n\\treverse(grid, n, 0, k - 1);\\n\\treverse(grid, n, k, l - 1);\\n\\t\\n\\treturn grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936555,
                "title": "c-3-approaches-in-decreasing-order-of-intuitiveness",
                "content": "### **Approach 1:** Brute Force Shifting using temp matrix\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> temp = grid;\\n        k = k%(m*n);\\n        \\n        while(k--) {\\n            // Shifting all columns except 0th column\\n            for(int i=0; i<m; i++) {\\n                for(int j=1; j<n; j++) {\\n                    temp[i][j] = grid[i][j-1]; \\n                }\\n            }\\n            // Modifying first column\\n            for(int i=0; i<m-1; i++)\\n                temp[i+1][0] = grid[i][n-1];\\n            // First element case\\n            temp[0][0] = grid[m-1][n-1];\\n            grid = temp;  // temp is the new grid\\n        }\\n        return grid;\\n    }\\n};\\n```\\n---\\n### **Approach 2:** Convert Matrix to 1-D Array (Brute Force)\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);    // For k>m*n\\n        vector<int> vect;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                vect.push_back(grid[i][j]);\\n            }\\n        }\\n        vector<int> t = vect;\\n        vect.insert(vect.begin(), t.begin()+m*n-k, t.end()); // Performing shift in 1-D Vector\\n        int id=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                grid[i][j] = vect[id];  // Copying shifted values back to 2-D Matrix\\n                id++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n---\\n### **Approach 3:** Calculate New Position of each element(Better Version of Approach 2)\\nFor an M*N matrix \\\\-\\n- 1-D index for [i, j] = `i*N + j`\\n- Shift 1-D index : `index = (index+k)%(M*N)`\\n- Calculate shifted 2-D coordinates : `[index/N, index%N]`\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int index = i*n + j;\\n                index = (index+k)%(m*n);\\n                int newI = index/n;\\n                int newJ = index%n;\\n                ans[newI][newJ] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> temp = grid;\\n        k = k%(m*n);\\n        \\n        while(k--) {\\n            // Shifting all columns except 0th column\\n            for(int i=0; i<m; i++) {\\n                for(int j=1; j<n; j++) {\\n                    temp[i][j] = grid[i][j-1]; \\n                }\\n            }\\n            // Modifying first column\\n            for(int i=0; i<m-1; i++)\\n                temp[i+1][0] = grid[i][n-1];\\n            // First element case\\n            temp[0][0] = grid[m-1][n-1];\\n            grid = temp;  // temp is the new grid\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);    // For k>m*n\\n        vector<int> vect;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                vect.push_back(grid[i][j]);\\n            }\\n        }\\n        vector<int> t = vect;\\n        vect.insert(vect.begin(), t.begin()+m*n-k, t.end()); // Performing shift in 1-D Vector\\n        int id=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                grid[i][j] = vect[id];  // Copying shifted values back to 2-D Matrix\\n                id++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int index = i*n + j;\\n                index = (index+k)%(m*n);\\n                int newI = index/n;\\n                int newJ = index%n;\\n                ans[newI][newJ] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936534,
                "title": "simple-python-using-deque",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for x in range(k):\\n            lst=collections.deque()\\n            for i in range(len(grid)):\\n                grid[i]=collections.deque(grid[i])\\n                grid[i].rotate(1)\\n                # print(i)\\n                lst.append(grid[i][0])\\n            # print(grid)\\n            lst.rotate(1)\\n            for i in grid:\\n                a=lst.popleft()\\n                i[0]=a\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for x in range(k):\\n            lst=collections.deque()\\n            for i in range(len(grid)):\\n                grid[i]=collections.deque(grid[i])\\n                grid[i].rotate(1)\\n                # print(i)\\n                lst.append(grid[i][0])\\n            # print(grid)\\n            lst.rotate(1)\\n            for i in grid:\\n                a=lst.popleft()\\n                i[0]=a\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936475,
                "title": "python3-shifting-in-2d-simple",
                "content": "Here I have shifted in 2D List in an extended manner (without using any list comprehension or one liner). It can also be done in shorter and more efficient manner.\\n**Logic:** Pop the last element from each sub list and insert it at 0 index in another sub list and for last sub list pop the last element and insert it at 0 index in first sub list.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for j in range(k):  # Shifting k times\\n            for i in range(len(grid)):  # Shifting without disturbing the structure\\n                if i==len(grid)-1:\\n                    a=grid[i].pop()\\n                    grid[0].insert(0,a)\\n                else:\\n                    a=grid[i].pop()\\n                    grid[i+1].insert(0,a)\\n        return grid\\n```\\n**Please upvote if the solution helps**\\n**Feel free to ask any question**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for j in range(k):  # Shifting k times\\n            for i in range(len(grid)):  # Shifting without disturbing the structure\\n                if i==len(grid)-1:\\n                    a=grid[i].pop()\\n                    grid[0].insert(0,a)\\n                else:\\n                    a=grid[i].pop()\\n                    grid[i+1].insert(0,a)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936463,
                "title": "c-solution-basic-optimized",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\t\\n        vector<vector<int>>temp;\\n        temp=grid;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    temp[i][j]=grid[i][j-1];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++)temp[i+1][0]=grid[i][n-1];\\n            temp[0][0]=grid[m-1][n-1];\\n            grid=temp;\\n        }\\n        return temp;\\n    }\\n};\\n(Optimized)\\nClass Solution {\\npublic:\\n    \\n\\tvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n\\t          {   \\n\\t        int m=grid.size();\\n            int n=grid[0].size();\\n           vector<vector<int>>temp(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                temp[(i+(j+k)/n)%m][(j+k)%n]=grid[i][j];\\n        }\\n        return temp;\\n    }\\n};\\n**Please do upvote if you liked it!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\t\\n        vector<vector<int>>temp;\\n        temp=grid;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    temp[i][j]=grid[i][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1936392,
                "title": "python-flatten-array-and-convert-back-2d",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        N = rows*cols\\n        shift = k%N # since max shift is N - 1 otherwise it\\'s just a cycle\\n        \\n        if shift == 0: # no need to shift\\n            return grid\\n\\t\\t\\t\\n        # flatten array\\n        flattened = []\\n        for y in range(rows):\\n            for x in range(cols):\\n                flattened.append(grid[y][x])\\n                \\n\\t\\t# shift array\\n        flattened = flattened[-shift:] + flattened[:-shift]\\n\\t\\t\\n        return  [[ flattened[y*cols + x] for x in range(cols)] for y in range(rows)] #convert back to 2d array\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        N = rows*cols\\n        shift = k%N # since max shift is N - 1 otherwise it\\'s just a cycle\\n        \\n        if shift == 0: # no need to shift\\n            return grid\\n\\t\\t\\t\\n        # flatten array\\n        flattened = []\\n        for y in range(rows):\\n            for x in range(cols):\\n                flattened.append(grid[y][x])\\n                \\n\\t\\t# shift array\\n        flattened = flattened[-shift:] + flattened[:-shift]\\n\\t\\t\\n        return  [[ flattened[y*cols + x] for x in range(cols)] for y in range(rows)] #convert back to 2d array\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936366,
                "title": "python-simple-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        a=[]\\n        ans1=[]\\n        ans=[]\\n        c=0\\n        if m==1 and n==1:\\n            return grid\\n        for i in range(m):\\n            for j in range(n):\\n                a.append(grid[i][j])\\n        l=len(a)\\n        for i in range(k):\\n            x=a[l-1]\\n            a.pop(l-1)\\n            a.insert(0,x)\\n        for i in range(l):\\n            if c==n:\\n                ans1.append(ans)\\n                ans=[]\\n                c=0\\n            ans.append(a[i])\\n            c+=1\\n        ans1.append(ans)\\n        return(ans1)      \\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        a=[]\\n        ans1=[]\\n        ans=[]\\n        c=0\\n        if m==1 and n==1:\\n            return grid\\n        for i in range(m):\\n            for j in range(n):\\n                a.append(grid[i][j])\\n        l=len(a)\\n        for i in range(k):\\n            x=a[l-1]\\n            a.pop(l-1)\\n            a.insert(0,x)\\n        for i in range(l):\\n            if c==n:\\n                ans1.append(ans)\\n                ans=[]\\n                c=0\\n            ans.append(a[i])\\n            c+=1\\n        ans1.append(ans)\\n        return(ans1)      \\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936342,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //get the row and col\\n        int m=grid.size();//row\\n        int n=grid[0].size();//col\\n        // create a space for storing value\\n        vector<vector<int>> temp(m,vector<int>(n,0));\\n        //use for loopto store value\\n        for(int r=0;r<m;r++){\\n            for(int c=0;c<n;c++){\\n                //assume that it will be in single array and add the k poistion\\n                int newVal=((r*n +c)+k)%(m*n);\\n                //create newr and newc\\n                int newr=newVal/n;\\n                int newc=newVal%n;\\n                //store the result in temp\\n                temp[newr][newc]=grid[r][c];\\n            }\\n        }\\n        return temp;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //get the row and col\\n        int m=grid.size();//row\\n        int n=grid[0].size();//col\\n        // create a space for storing value\\n        vector<vector<int>> temp(m,vector<int>(n,0));\\n        //use for loopto store value\\n        for(int r=0;r<m;r++){\\n            for(int c=0;c<n;c++){\\n                //assume that it will be in single array and add the k poistion\\n                int newVal=((r*n +c)+k)%(m*n);\\n                //create newr and newc\\n                int newr=newVal/n;\\n                int newc=newVal%n;\\n                //store the result in temp\\n                temp[newr][newc]=grid[r][c];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1936218,
                "title": "python-very-easy-o-1-space",
                "content": "**Solution 1**\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        d = m*n\\n        ans = [[0] * n for _ in range(m)]\\n        \\n        start = d - k\\n        for i in range(m):\\n            for j in range(n):\\n                start %= d\\n                r = start // n\\n                c = start % n\\n                ans[i][j] = grid[r][c]\\n                start += 1\\n        return ans\\n```\\n\\n***\\n```Time Complexity: O(N*M)```\\n```Space Complexity: O(N*M)```\\n***\\n\\n\\n**Solution 2**\\nSame approach as this question  [Click](https://leetcode.com/problems/rotate-array/)\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def reverse(start, end, n):\\n            while start < end:\\n                grid[start // n][start % n], grid[end // n][end % n] = grid[end // n][end % n], grid[start // n][start % n]\\n                start += 1\\n                end -= 1\\n        \\n        n = len(grid[0])\\n        d = len(grid) * n\\n        k = k % d\\n        reverse(0, d - k - 1, n)\\n        reverse(d - k, d - 1, n)\\n        reverse(0, d - 1, n)\\n        \\n        return grid\\n```\\n\\n***\\n```Time Complexity: O(N*M)```\\n```Space Complexity: O(1)```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        d = m*n\\n        ans = [[0] * n for _ in range(m)]\\n        \\n        start = d - k\\n        for i in range(m):\\n            for j in range(n):\\n                start %= d\\n                r = start // n\\n                c = start % n\\n                ans[i][j] = grid[r][c]\\n                start += 1\\n        return ans\\n```\n```Time Complexity: O(N*M)```\n```Space Complexity: O(N*M)```\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def reverse(start, end, n):\\n            while start < end:\\n                grid[start // n][start % n], grid[end // n][end % n] = grid[end // n][end % n], grid[start // n][start % n]\\n                start += 1\\n                end -= 1\\n        \\n        n = len(grid[0])\\n        d = len(grid) * n\\n        k = k % d\\n        reverse(0, d - k - 1, n)\\n        reverse(d - k, d - 1, n)\\n        reverse(0, d - 1, n)\\n        \\n        return grid\\n```\n```Time Complexity: O(N*M)```\n```Space Complexity: O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1936191,
                "title": "c-o-1-space-solution",
                "content": "# **Non Constant Space Solution**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& A, int k) {\\n        int n = A.size(), m = A[0].size();\\n        vector<int> B; // just convert the grid array to 1D array\\n        vector<vector<int>> result(n, vector<int>(m)); // return array\\n        k %= n * m;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                B.push_back(A[i][j]);\\n        for(int i = k; i < B.size(); i++){\\n            int row = i / m, col = i % m; // finding out the index \\n\\t\\t\\t// in 2D array. For example, if \"i\" is equal to 5 (6th element) and array is 3x4\\n\\t\\t\\t// the 6th element of B will be placed to \\n\\t\\t\\t// row = i / m = 5 / 4 = 1,   col = i % m = 5 % 4 = 1\\n\\t\\t\\t// So, it will be placed in result[1][1]\\n            result[row][col] = B[i - k];\\n        }\\n        for(int i = 0; i < k; i++){\\n            int row = i / m, col = i % m;\\n            result[row][col] = B[B.size() - k + i];\\n        }\\n        return result;\\n    }\\n};\\n```\\n```\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\\n# **O(1) Space Solution**\\nThe Testcase: \\n```\\n[1, 2, 3]\\n[4, 5, 6]\\n[7, 8, 9]\\nk = 2\\n```\\n**The Explanation:**\\nThe idea is simple, let\\'s assume that the given array grid is 1D array, to rotate it, we will just need to do 3 reverse operations:\\n1. reverse the whole array:\\n2. reverse the values before k [0, k - 1]\\n3. reverse the values from k to the end [k, n * m - 1]\\n\\nAfter the first reverse operation (reverse the whole array):\\n```\\n[9 ,8, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\\nAfter the second reverse operation (reverse the values before k):\\n```\\n[8, 9, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\\nAnd finally, after the third operation (reverse the values from k to the end) we get:\\n```\\n[8, 9, 1]\\n[2, 3, 4]\\n[5, 6, 7]\\n```\\nWhich is the right answer!\\n\\nHere is the **implementation**: \\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        n = grid.size(), m = grid[0].size(), k %= n * m;\\n        reverse(grid, 0, n * m - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, n * m - 1);\\n        return grid;\\n    }\\n    void reverse(vector<vector<int>>& grid, int i, int j){\\n        while(i < j){\\n            int rowI = i / m, colI = i % m, rowJ = j / m, colJ = j % m;\\n            int temp = grid[rowI][colI];\\n            grid[rowI][colI] = grid[rowJ][colJ];\\n            grid[rowJ][colJ] = temp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```\\n```\\nTime Complexity: O(n * m)\\nSpace Complexity: O(1)\\n```\\n\\n**Hope it helped! Your Upvote can make my day :D**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& A, int k) {\\n        int n = A.size(), m = A[0].size();\\n        vector<int> B; // just convert the grid array to 1D array\\n        vector<vector<int>> result(n, vector<int>(m)); // return array\\n        k %= n * m;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                B.push_back(A[i][j]);\\n        for(int i = k; i < B.size(); i++){\\n            int row = i / m, col = i % m; // finding out the index \\n\\t\\t\\t// in 2D array. For example, if \"i\" is equal to 5 (6th element) and array is 3x4\\n\\t\\t\\t// the 6th element of B will be placed to \\n\\t\\t\\t// row = i / m = 5 / 4 = 1,   col = i % m = 5 % 4 = 1\\n\\t\\t\\t// So, it will be placed in result[1][1]\\n            result[row][col] = B[i - k];\\n        }\\n        for(int i = 0; i < k; i++){\\n            int row = i / m, col = i % m;\\n            result[row][col] = B[B.size() - k + i];\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\n```\\n[1, 2, 3]\\n[4, 5, 6]\\n[7, 8, 9]\\nk = 2\\n```\n```\\n[9 ,8, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\n```\\n[8, 9, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\n```\\n[8, 9, 1]\\n[2, 3, 4]\\n[5, 6, 7]\\n```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        n = grid.size(), m = grid[0].size(), k %= n * m;\\n        reverse(grid, 0, n * m - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, n * m - 1);\\n        return grid;\\n    }\\n    void reverse(vector<vector<int>>& grid, int i, int j){\\n        while(i < j){\\n            int rowI = i / m, colI = i % m, rowJ = j / m, colJ = j % m;\\n            int temp = grid[rowI][colI];\\n            grid[rowI][colI] = grid[rowJ][colJ];\\n            grid[rowJ][colJ] = temp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```\n```\\nTime Complexity: O(n * m)\\nSpace Complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936181,
                "title": "daily-leetcoding-challenge-april-day-11-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k = k%(m*n);\\n        int a;\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n            for(int i=0;i<k;i++){\\n                a = v[m*n - 1];\\n                v.pop_back();\\n                v.insert (v.begin(), a);\\n            }\\n            int x = 0;\\n            for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j] = v[x];\\n                x++;\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k = k%(m*n);\\n        int a;\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1936143,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        k= k% (r*c);\\n        while(k-->0){\\n            int last = grid[r-1][c-1];\\n            for(int i=r-1;i>=0;i--){\\n                for(int j=c-1;j>=0;j--){\\n                    if(i==0 && j==0) grid[i][j]=last;\\n                    else if( i!=0 && j==0) grid[i][j]=grid[i-1][c-1];\\n                    else grid[i][j] = grid[i][j-1];\\n                }\\n            }\\n           \\n        }\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        k= k% (r*c);\\n        while(k-->0){\\n            int last = grid[r-1][c-1];\\n            for(int i=r-1;i>=0;i--){\\n                for(int j=c-1;j>=0;j--){\\n                    if(i==0 && j==0) grid[i][j]=last;\\n                    else if( i!=0 && j==0) grid[i][j]=grid[i-1][c-1];\\n                    else grid[i][j] = grid[i][j-1];\\n                }\\n            }\\n           \\n        }\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936041,
                "title": "c-100-faster-than-all-bruteforce-single-pass-approch",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n//         Brute force Time limit exceed error\\n        // while(k){\\n        //     int temp=grid[grid.size()-1][grid[0].size()-1];\\n        //     for(int i=grid.size()-1;i>=0;i--){\\n        //         for(int j=grid[i].size()-1;j>0;j--){\\n        //             cout<<i<<\" , \"<<j<<endl;\\n        //             grid[i][j]=grid[i][j-1];\\n        //         }\\n        //         if(i>0)\\n        //             grid[i][0]=grid[i-1][grid[i].size()-1];\\n        //         // for(int i=0;i<grid.size();i++){\\n        //         //     for(int j=0;j<grid[i].size();j++){\\n        //         //         cout<<grid[i][j]<<\" \";\\n        //         //     }\\n        //         //     cout<<endl;\\n        //         // }\\n        //     }\\n        //     grid[0][0]=temp;\\n        //  k--;   \\n        // }\\n        // return grid;\\n        //\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int newj=(j+k)%n;\\n                int newi = (i+(j+k)/n)%m;\\n                ans[newi][newj]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n//         Brute force Time limit exceed error\\n        // while(k){\\n        //     int temp=grid[grid.size()-1][grid[0].size()-1];\\n        //     for(int i=grid.size()-1;i>=0;i--){\\n        //         for(int j=grid[i].size()-1;j>0;j--){\\n        //             cout<<i<<\" , \"<<j<<endl;\\n        //             grid[i][j]=grid[i][j-1];\\n        //         }\\n        //         if(i>0)\\n        //             grid[i][0]=grid[i-1][grid[i].size()-1];\\n        //         // for(int i=0;i<grid.size();i++){\\n        //         //     for(int j=0;j<grid[i].size();j++){\\n        //         //         cout<<grid[i][j]<<\" \";\\n        //         //     }\\n        //         //     cout<<endl;\\n        //         // }\\n        //     }\\n        //     grid[0][0]=temp;\\n        //  k--;   \\n        // }\\n        // return grid;\\n        //\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int newj=(j+k)%n;\\n                int newi = (i+(j+k)/n)%m;\\n                ans[newi][newj]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1936035,
                "title": "daily-challenge-11-04-2022-faster-than-99-solution",
                "content": "The trick is to make a function for shifting grid by 1 position.\\nAfter that is done, just run a loop K times calling that function and return the answer!\\n\\n```\\nclass Solution {\\n    \\n    public int[][] oneShift(int[][] grid, int m, int n) \\n    {           \\n        int newVal= grid[m-1][n-1];\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int temp= grid[i][j];\\n                grid[i][j]= newVal;\\n                newVal= temp;\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) \\n    {\\n        while(k-->0) {\\n            grid= oneShift(grid, grid.length, grid[0].length);\\n        }\\n\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[][] oneShift(int[][] grid, int m, int n) \\n    {           \\n        int newVal= grid[m-1][n-1];\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int temp= grid[i][j];\\n                grid[i][j]= newVal;\\n                newVal= temp;\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) \\n    {\\n        while(k-->0) {\\n            grid= oneShift(grid, grid.length, grid[0].length);\\n        }\\n\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935927,
                "title": "c-o-m-n",
                "content": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n    for (int i = 0; i < gridSize; i++)\\n        *((*returnColumnSizes) + i) = *gridColSize;\\n\\n    if (k == gridSize * *gridColSize || (1 == gridSize && 1 == *gridColSize))\\n        return grid;\\n    \\n    k %= gridSize * *gridColSize;\\n    int *shifted = calloc(gridSize * *gridColSize, sizeof(int));\\n    int ptr = k;\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            *(shifted + ptr) = *(*(grid + i) + j);\\n            if (gridSize * *gridColSize == ++ptr)\\n                ptr = 0;\\n        }\\n    }\\n\\n    ptr = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++)\\n            *(*(grid + i) + j) = *(shifted + ptr++);\\n    }\\n    \\n    return grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n    for (int i = 0; i < gridSize; i++)\\n        *((*returnColumnSizes) + i) = *gridColSize;\\n\\n    if (k == gridSize * *gridColSize || (1 == gridSize && 1 == *gridColSize))\\n        return grid;\\n    \\n    k %= gridSize * *gridColSize;\\n    int *shifted = calloc(gridSize * *gridColSize, sizeof(int));\\n    int ptr = k;\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            *(shifted + ptr) = *(*(grid + i) + j);\\n            if (gridSize * *gridColSize == ++ptr)\\n                ptr = 0;\\n        }\\n    }\\n\\n    ptr = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++)\\n            *(*(grid + i) + j) = *(shifted + ptr++);\\n    }\\n    \\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935923,
                "title": "171ms-solution-easiest-explanation-python",
                "content": "The trickiest part in this problem is to handle the edge elements. If the value is at the last column of a row, then we have to shift it to the first column of the next row. Interestingly using this approach is the key to this problem.\\n\\n---\\nLet\\'s only focus on a matrix of two rows for now.\\n\\nWhat we need to do is \\'pop\\' the element from the second row and \\'insert\\' it at the first index of the first row.\\nNow if `m` is the number of elements in a row(or columns in the matrix), then after this operation the first row has `m+1` elements and the second row has `m-1` elements.\\nBut we still have to `pop` the last element of the first row and insert it the `0`<sup>th</sup> index of the second one to complete the iteration.\\nOn doing this operation, both our rows have the same number of elements, `m`, and our matrix is successfully shifted by one.\\n\\nWe need to repeat this cycle `k` times to arrive at the expected output.\\nFor a generalized solution for matrices with more than 2 rows, check out the well-documented python code below.\\n\\n---\\n**Time Complexity: O(kmn)** where **k** is the number of elements, **m** is the number of columns and **n** is the number of rows\\n\\n**Space Complexity: O(1)** as no extra space is required\\n\\n*Do upvote if you found the explanation deserving enough. Thanks for reading!*\\n\\n---\\nPython code:\\n```\\ndef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        while k>0:\\n            # Pop the last element from the last row of the matrix\\n\\t        curr_elem=grid[-1].pop()\\n            \\n            # Loop through all the rows except the last one\\n\\t        for i in range(rows-1):\\n                # Insert the last element popped at each iteration at\\n                # the first position of the current row of the matrix\\n                \\n                # This step takes care of the edge elements\\n\\t\\t        grid[i].insert(0,curr_elem)\\n                \\n                # Update curr with the value of latest popped element\\n                # from current row\\n\\t\\t        curr_elem=grid[i].pop()\\n            \\n            # Insert the latest curr element at the first position of the last row\\n\\t        grid[-1].insert(0,curr_elem)\\n\\t        k-=1  \\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\ndef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        while k>0:\\n            # Pop the last element from the last row of the matrix\\n\\t        curr_elem=grid[-1].pop()\\n            \\n            # Loop through all the rows except the last one\\n\\t        for i in range(rows-1):\\n                # Insert the last element popped at each iteration at\\n                # the first position of the current row of the matrix\\n                \\n                # This step takes care of the edge elements\\n\\t\\t        grid[i].insert(0,curr_elem)\\n                \\n                # Update curr with the value of latest popped element\\n                # from current row\\n\\t\\t        curr_elem=grid[i].pop()\\n            \\n            # Insert the latest curr element at the first position of the last row\\n\\t        grid[-1].insert(0,curr_elem)\\n\\t        k-=1  \\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1935919,
                "title": "simple-solution-c",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> v(m,vector<int>(n));\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n-1;j++){\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++){\\n                v[i+1][0]=grid[i][n-1];\\n            }\\n            v[0][0]=grid[m-1][n-1];\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    grid[i][j]=v[i][j];\\n                    v[i][j]=0;\\n                }\\n            }\\n        }   \\n        \\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> v(m,vector<int>(n));\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n-1;j++){\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++){\\n                v[i+1][0]=grid[i][n-1];\\n            }\\n            v[0][0]=grid[m-1][n-1];\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    grid[i][j]=v[i][j];\\n                    v[i][j]=0;\\n                }\\n            }\\n        }   \\n        \\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935728,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        int total=m*n;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                int pos=i*m+j;\\n                \\n                int pos1=(pos+k)%total;\\n                int row=pos1/m;\\n                int col=pos1%m;\\n                \\n                ans[row][col]=grid[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        int total=m*n;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                int pos=i*m+j;\\n                \\n                int pos1=(pos+k)%total;\\n                int row=pos1/m;\\n                int col=pos1%m;\\n                \\n                ans[row][col]=grid[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935704,
                "title": "c-simplest-solution-convert-to-1d-array",
                "content": "**Time Complexity :** ```O(m*n)```\\n\\n**Space Complexity :** ```O(m*n)```\\n\\n\\n**APPROACH :**\\n\\n* Convert the array into a 1D array ```v```.\\n\\n* Reverse the array from index ```0``` to index ```v.size() - k - 1```.\\n\\n* Then reverse the array from index ```v.size() - k``` to ```v.size() - 1```.\\n\\n* Then reverse the whole array.\\n\\n** ( Do a dry run on 1 of the examples to understand)\\n\\n**Code :**\\n```\\nclass Solution {\\n    void reverse(vector<int> &v, int start, int end) {\\n        while(start < end) {\\n            swap(v[start++], v[end--]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        vector<int> v;\\n        \\n        for(auto &i: grid) {\\n            for(auto &j: i) {\\n                v.push_back(j);\\n            }\\n        }\\n        \\n        k = k%v.size();\\n        reverse(v, 0, v.size()-k-1);\\n        reverse(v, v.size()-k, v.size()-1);\\n        reverse(v, 0, v.size()-1);\\n        \\n        int vec = 0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n**Do upvote if you like my solution :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```O(m*n)```\n```O(m*n)```\n```v```\n```0```\n```v.size() - k - 1```\n```v.size() - k```\n```v.size() - 1```\n```\\nclass Solution {\\n    void reverse(vector<int> &v, int start, int end) {\\n        while(start < end) {\\n            swap(v[start++], v[end--]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        vector<int> v;\\n        \\n        for(auto &i: grid) {\\n            for(auto &j: i) {\\n                v.push_back(j);\\n            }\\n        }\\n        \\n        k = k%v.size();\\n        reverse(v, 0, v.size()-k-1);\\n        reverse(v, v.size()-k, v.size()-1);\\n        reverse(v, 0, v.size()-1);\\n        \\n        int vec = 0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935646,
                "title": "easy-c-o-k-m-n-solution",
                "content": "**Algorithm**\\n\\n* Preserve the last index element.\\n* copy all index to their next\\n* Copy the saved last element to first\\n* Apply a set of if-else blocks for boundary conditions\\n* Repeat the above 3 steps k times.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\n        while(k--)\\n        {\\n            int element = grid[0][0],nextElement;\\n            for(int i=0;i<grid.size();i++)\\n        {\\n            int m = grid.size();\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int n= grid[i].size();\\n                \\n                if(i == (m-1) && j == (n-1))\\n                {\\n                    nextElement = grid[0][0];\\n                    grid[0][0] = element;\\n                    element = nextElement;\\n                }\\n                else if(j == (n-1))\\n                {\\n                    nextElement = grid[i+1][0]; \\n                    grid[i+1][0] = element; \\n                    element = nextElement; \\n                }\\n                else{\\n                    nextElement = grid[i][j+1]; \\n                    grid[i][j+1] = element; \\n                    element = nextElement; \\n                }\\n            }\\n        }\\n        }\\n\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\n        while(k--)\\n        {\\n            int element = grid[0][0],nextElement;\\n            for(int i=0;i<grid.size();i++)\\n        {\\n            int m = grid.size();\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int n= grid[i].size();\\n                \\n                if(i == (m-1) && j == (n-1))\\n                {\\n                    nextElement = grid[0][0];\\n                    grid[0][0] = element;\\n                    element = nextElement;\\n                }\\n                else if(j == (n-1))\\n                {\\n                    nextElement = grid[i+1][0]; \\n                    grid[i+1][0] = element; \\n                    element = nextElement; \\n                }\\n                else{\\n                    nextElement = grid[i][j+1]; \\n                    grid[i][j+1] = element; \\n                    element = nextElement; \\n                }\\n            }\\n        }\\n        }\\n\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935613,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> list = new ArrayList();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[] = new int[m*n];   \\n        int total = m*n;\\n        \\n        int index = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[(index + k)% total] = grid[i][j];\\n                index++;\\n            }\\n        }\\n        \\n        List<Integer> a = new ArrayList();\\n        for(int i=0;i<total;i++){\\n            a.add(ans[i]);\\n            if(a.size() == n){         \\n                System.out.println(a);\\n                list.add(a);\\n                a = new ArrayList();\\n            } \\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> list = new ArrayList();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[] = new int[m*n];   \\n        int total = m*n;\\n        \\n        int index = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[(index + k)% total] = grid[i][j];\\n                index++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1935549,
                "title": "c-reversal-algorithm-to-rotate-an-array",
                "content": "**Optimal Approach (Reversal Algorithm)**\\n```\\nclass Solution {\\n    // row and column\\n    int m, n;\\n    \\n    // As the asked form is in 2D matrix, we have to find out \\n    // our desirable row and column index for swapping, rest \\n    // the reverse algorithm is pretty much the same\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l < r) \\n        {\\n            // calculating the first element to be swapped\\n            int lr = l/n, lc = l%n;\\n            \\n            // second element\\n            int snd_row = r/n, snd_col = r%n;\\n            if(snd_row == m) snd_row = 0;\\n            \\n            swap(grid[fst_row][fst_col], grid[snd_row][snd_col]);\\n            \\n            // updating 1D array indexes\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        /*\\n        This is similar question like rotate an array, but this time it\\'s given as \\n        2D matrix, we\\'ll go for the similar reversal algorithm approach\\n        \\n        reverse(arr, 0, n-1);\\n        reverse(arr, 0, k-1);\\n        reverse(arr, k, n-1);\\n        */\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n); // a little optimisation over k rotations\\n        \\n        // a simple base case\\n        if(k == 0) return grid;\\n        \\n        // as total elements are m*n, we are passing last index as (m*n-1)\\n        // we\\'re considering 2D matrix as 1D array and will calculate the \\n        // index accordingly in the function body\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        \\n        // returning the answer\\n        return grid;\\n    }\\n};\\n\\n```\\n**Time - O(M.N)\\nSpace - O(1)**\\n\\n`As we are changing our input matrix loss of information happens, to prevent that we can make another \\'ans\\' matrix and in this case the space complexity would be O(M.N)`\\n\\n*NB: If I could help you a little consider upvoting the solution and comment your doubts and thoughts for this problem*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // row and column\\n    int m, n;\\n    \\n    // As the asked form is in 2D matrix, we have to find out \\n    // our desirable row and column index for swapping, rest \\n    // the reverse algorithm is pretty much the same\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l < r) \\n        {\\n            // calculating the first element to be swapped\\n            int lr = l/n, lc = l%n;\\n            \\n            // second element\\n            int snd_row = r/n, snd_col = r%n;\\n            if(snd_row == m) snd_row = 0;\\n            \\n            swap(grid[fst_row][fst_col], grid[snd_row][snd_col]);\\n            \\n            // updating 1D array indexes\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        /*\\n        This is similar question like rotate an array, but this time it\\'s given as \\n        2D matrix, we\\'ll go for the similar reversal algorithm approach\\n        \\n        reverse(arr, 0, n-1);\\n        reverse(arr, 0, k-1);\\n        reverse(arr, k, n-1);\\n        */\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n); // a little optimisation over k rotations\\n        \\n        // a simple base case\\n        if(k == 0) return grid;\\n        \\n        // as total elements are m*n, we are passing last index as (m*n-1)\\n        // we\\'re considering 2D matrix as 1D array and will calculate the \\n        // index accordingly in the function body\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        \\n        // returning the answer\\n        return grid;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566057,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2012899,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753271,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1739733,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Elements in a Contaminated Binary Tree",
        "question_content": "<p>Given a binary tree with the following rules:</p>\n\n<ol>\n\t<li><code>root.val == 0</code></li>\n\t<li>If <code>treeNode.val == x</code> and <code>treeNode.left != null</code>, then <code>treeNode.left.val == 2 * x + 1</code></li>\n\t<li>If <code>treeNode.val == x</code> and <code>treeNode.right != null</code>, then <code>treeNode.right.val == 2 * x + 2</code></li>\n</ol>\n\n<p>Now the binary tree is contaminated, which means all <code>treeNode.val</code> have been changed to <code>-1</code>.</p>\n\n<p>Implement the <code>FindElements</code> class:</p>\n\n<ul>\n\t<li><code>FindElements(TreeNode* root)</code> Initializes the object with a contaminated binary tree and recovers it.</li>\n\t<li><code>bool find(int target)</code> Returns <code>true</code> if the <code>target</code> value exists in the recovered binary tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4-1.jpg\" style=\"width: 320px; height: 119px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,null,-1]],[1],[2]]\n<strong>Output</strong>\n[null,false,true]\n<strong>Explanation</strong>\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True </pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4.jpg\" style=\"width: 400px; height: 198px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\n<strong>Output</strong>\n[null,true,true,false]\n<strong>Explanation</strong>\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/07/untitled-diagram-4-1-1.jpg\" style=\"width: 306px; height: 274px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\n<strong>Output</strong>\n[null,true,false,false,true]\n<strong>Explanation</strong>\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>TreeNode.val == -1</code></li>\n\t<li>The height of the binary tree is less than or equal to <code>20</code></li>\n\t<li>The total number of nodes is between <code>[1, 10<sup>4</sup>]</code></li>\n\t<li>Total calls of <code>find()</code> is between <code>[1, 10<sup>4</sup>]</code></li>\n\t<li><code>0 &lt;= target &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 431229,
                "title": "python-special-way-for-find-without-hashset-o-1-space-o-logn-time",
                "content": "It\\'s obvious to use `BFS` for the initial part. However, a lot of people use HashSet(`set()` in python) to pre-store all the values in the initial part, which may cause MLE when the values are huge. There is a special way to implement `find()` that  costs O(1) in space and O(logn) in time. \\n\\nFirstly, let\\'s see what a complete tree will look like in this problem: \\n\\n\\nIt\\'s very easy to find that numbers in each layer range from `[2^i-1,2^(i+1)-2]`\\nwhat if we add 1 to each number? Then it should range from `[2^i, 2^(i+1)-1]`\\nSee?  the binary of all numbers in each layer should be: `100..00` to `111...11`\\n\\nHence we could discover that maybe we could use the `binary number` of `target+1` to find a path:\\n\\n![image](https://assets.leetcode.com/users/qingdu_river/image_1573968285.png)\\n\\nI\\'m not proficient in English, so I would prefer to show my code here to explain my idea:\\n\\n```python\\ndef find(self, target: int) -> bool:\\n\\t\\tbinary = bin(target+1)[3:]                  # remove the useless first `1`\\n        index = 0\\n        root = self.root                                    # use a new pointer `root` to traverse the tree\\n        while root and index <= len(binary): # traverse the binary number from left to right\\n            if root.val == target:\\n                return True\\n            if  binary[index] == \\'0\\':  # if it\\'s 0, we have to go left\\n                root = root.left\\n            else:  # if it\\'s 1, we have to go right\\n                root = root.right\\n            index += 1\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef find(self, target: int) -> bool:\\n\\t\\tbinary = bin(target+1)[3:]                  # remove the useless first `1`\\n        index = 0\\n        root = self.root                                    # use a new pointer `root` to traverse the tree\\n        while root and index <= len(binary): # traverse the binary number from left to right\\n            if root.val == target:\\n                return True\\n            if  binary[index] == \\'0\\':  # if it\\'s 0, we have to go left\\n                root = root.left\\n            else:  # if it\\'s 1, we have to go right\\n                root = root.right\\n            index += 1\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431107,
                "title": "java-python-3-dfs-and-bfs-clean-codes-w-analysis",
                "content": "**DFS**\\n\\n```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        dfs(root, 0);\\n    }\\n    private void dfs(TreeNode n, int v) {\\n        if (n == null) return;\\n        seen.add(v);\\n        n.val = v;\\n        dfs(n.left, 2 * v + 1);\\n        dfs(n.right, 2 * v + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n```\\n```python\\n    def __init__(self, root: TreeNode):\\n        self.seen = set()\\n        \\n        def dfs(node: TreeNode, v: int) -> None:\\n            if node:\\n                node.val = v    \\n                self.seen.add(v)\\n                dfs(node.left, 2 * v + 1)\\n                dfs(node.right, 2 * v + 2)\\n            \\n        dfs(root, 0)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen\\n```\\n\\n----\\n\\n**BFS** - inspired by **@MichaelZ**.\\n```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        if (root != null) {\\n            root.val = 0;\\n            seen.add(root.val);\\n            bfs(root);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n    \\n    private void bfs(TreeNode node) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(node);\\n        while (!q.isEmpty()) {\\n            TreeNode cur = q.poll();\\n            if (cur.left != null) {\\n                cur.left.val = 2 * cur.val + 1;\\n                q.offer(cur.left);\\n                seen.add(cur.left.val);\\n            }\\n            if (cur.right != null) {\\n                cur.right.val = 2 * cur.val + 2;\\n                q.offer(cur.right);\\n                seen.add(cur.right.val);\\n            }\\n        }\\n    }\\n```\\n```python\\n    def __init__(self, root: TreeNode):\\n\\n        def bfs(root: TreeNode) -> None:\\n            dq = collections.deque([root])\\n            while dq:\\n                node = dq.popleft()\\n                if node.left:\\n                    node.left.val = 2 * node.val + 1\\n                    dq.append(node.left)\\n                    self.seen.add(node.left.val)\\n                if node.right:\\n                    node.right.val = 2 * node.val + 2\\n                    dq.append(node.right)\\n                    self.seen.add(node.right.val)\\n            \\n        self.seen = set()\\n        if root:\\n            root.val = 0\\n            bfs(root)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen    \\n```\\n\\n**Analysis:**\\nHashSet cost space `O(N)`, *dfs()* cost space ((H) and time `O(N)`, *bfs()* cost time and space O(N), therefore\\n\\n*FindElements() (dfs() and bfs()) cost*\\ntime & space: `O(N)`.\\n\\n*find() cost*\\ntime & space: `O(1)` excluding the space of HashSet.\\n\\nWhere `N` is the total number of nodes in the tree.",
                "solutionTags": [],
                "code": "```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        dfs(root, 0);\\n    }\\n    private void dfs(TreeNode n, int v) {\\n        if (n == null) return;\\n        seen.add(v);\\n        n.val = v;\\n        dfs(n.left, 2 * v + 1);\\n        dfs(n.right, 2 * v + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n```\n```python\\n    def __init__(self, root: TreeNode):\\n        self.seen = set()\\n        \\n        def dfs(node: TreeNode, v: int) -> None:\\n            if node:\\n                node.val = v    \\n                self.seen.add(v)\\n                dfs(node.left, 2 * v + 1)\\n                dfs(node.right, 2 * v + 2)\\n            \\n        dfs(root, 0)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen\\n```\n```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        if (root != null) {\\n            root.val = 0;\\n            seen.add(root.val);\\n            bfs(root);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n    \\n    private void bfs(TreeNode node) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(node);\\n        while (!q.isEmpty()) {\\n            TreeNode cur = q.poll();\\n            if (cur.left != null) {\\n                cur.left.val = 2 * cur.val + 1;\\n                q.offer(cur.left);\\n                seen.add(cur.left.val);\\n            }\\n            if (cur.right != null) {\\n                cur.right.val = 2 * cur.val + 2;\\n                q.offer(cur.right);\\n                seen.add(cur.right.val);\\n            }\\n        }\\n    }\\n```\n```python\\n    def __init__(self, root: TreeNode):\\n\\n        def bfs(root: TreeNode) -> None:\\n            dq = collections.deque([root])\\n            while dq:\\n                node = dq.popleft()\\n                if node.left:\\n                    node.left.val = 2 * node.val + 1\\n                    dq.append(node.left)\\n                    self.seen.add(node.left.val)\\n                if node.right:\\n                    node.right.val = 2 * node.val + 2\\n                    dq.append(node.right)\\n                    self.seen.add(node.right.val)\\n            \\n        self.seen = set()\\n        if root:\\n            root.val = 0\\n            bfs(root)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431362,
                "title": "java-bit-path-time-o-logn",
                "content": "Think about it with complete binary tree and the whole idea is to binary serialize the target number. It\\'s actually tha order we doing the dfs.\\nLet\\'s say our target : 9 we shall take it as 10 : 1010  ignoring the first digit 1 the path ( 010 )  means left -> right -> left  \\nSo \\'0\\' means going to the left and \\'1\\' means going to the right.\\nHere is the picture, very straightforward.\\n\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1574045418.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\tTreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        return dfs(root, binSerialize(target + 1), 1);\\n    }\\n\\t\\n\\tpublic boolean dfs(TreeNode root, String str, int pos){\\n        if(root == null)    return false;\\n        if(pos == str.length()) return true;\\n        return str.charAt(pos) == \\'0\\'? dfs(root.left, str, pos+1) : dfs(root.right, str, pos+1);\\n    }\\n    \\n    public String binSerialize(int num){\\n        StringBuilder sb = new StringBuilder();\\n        while(num > 0){\\n            sb.insert(0, num & 1);\\n            num /= 2;\\n        }\\n        return sb.toString();\\n    }\\n    \\n\\n",
                "solutionTags": [],
                "code": "Think about it with complete binary tree and the whole idea is to binary serialize the target number. It\\'s actually tha order we doing the dfs.\\nLet\\'s say our target : 9 we shall take it as 10 : 1010  ignoring the first digit 1 the path ( 010 )  means left -> right -> left  \\nSo \\'0\\' means going to the left and \\'1\\' means going to the right.\\nHere is the picture, very straightforward.\\n\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1574045418.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\tTreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        return dfs(root, binSerialize(target + 1), 1);\\n    }\\n\\t\\n\\tpublic boolean dfs(TreeNode root, String str, int pos){\\n        if(root == null)    return false;\\n        if(pos == str.length()) return true;\\n        return str.charAt(pos) == \\'0\\'? dfs(root.left, str, pos+1) : dfs(root.right, str, pos+1);\\n    }\\n    \\n    public String binSerialize(int num){\\n        StringBuilder sb = new StringBuilder();\\n        while(num > 0){\\n            sb.insert(0, num & 1);\\n            num /= 2;\\n        }\\n        return sb.toString();\\n    }\\n    \\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 434127,
                "title": "c-simple-and-easy-to-understand",
                "content": "```\\nclass FindElements {\\n    unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass FindElements {\\n    unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431462,
                "title": "intuitive-c-code-beats-100-in-memory",
                "content": "```\\nclass FindElements {\\n    TreeNode* head=new TreeNode(-1);\\npublic:\\n    FindElements(TreeNode* root) {\\n        head=root;\\n        head->val=0;\\n        recover(head);\\n    }\\n    \\n    void recover(TreeNode* root)\\n    {\\n        if(root->left)\\n        {\\n            root->left->val=(root->val)*2+1;\\n            recover(root->left);\\n        }\\n        if(root->right)\\n        {\\n            root->right->val=(root->val)*2+2;\\n            recover(root->right);\\n        }\\n        return;\\n    }\\n    \\n    bool find(int target) {\\n        return get(target,head);\\n    }\\n    \\n    bool get(int target,TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        \\n        bool t1=get(target,root->left);\\n        bool t2=get(target,root->right);\\n        \\n        if(t1||t2)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements {\\n    TreeNode* head=new TreeNode(-1);\\npublic:\\n    FindElements(TreeNode* root) {\\n        head=root;\\n        head->val=0;\\n        recover(head);\\n    }\\n    \\n    void recover(TreeNode* root)\\n    {\\n        if(root->left)\\n        {\\n            root->left->val=(root->val)*2+1;\\n            recover(root->left);\\n        }\\n        if(root->right)\\n        {\\n            root->right->val=(root->val)*2+2;\\n            recover(root->right);\\n        }\\n        return;\\n    }\\n    \\n    bool find(int target) {\\n        return get(target,head);\\n    }\\n    \\n    bool get(int target,TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        \\n        bool t1=get(target,root->left);\\n        bool t2=get(target,root->right);\\n        \\n        if(t1||t2)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431283,
                "title": "python-binary-path-without-set",
                "content": "bin(9 + 1) = 1 010\\nStart from the second digit: 0/1/0 means left/right/left when traverse if 9 exists.\\nrecover: T: O(n), S: O(n) (DFS worst case)\\nfind: T: O(logn), S: O(logn) (for the string of path encoding, can be O(1) if use bit mask) \\n```\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.root = root\\n        if not root:\\n            return\\n        root.val = 0\\n        self.recover(root)\\n        return\\n    def recover(self, root):\\n        if not root:\\n            return\\n        if root.left:\\n            root.left.val = root.val * 2 + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = root.val * 2 + 2\\n            self.recover(root.right)\\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        node = self.root\\n        encoding = bin(target + 1)[3:]\\n        counter = 0\\n        while counter < len(encoding):\\n            if encoding[counter] == \"0\":\\n                if node.left:\\n                    node = node.left\\n                    counter += 1\\n                else:\\n                    return False\\n            else:\\n                if node.right:\\n                    node = node.right\\n                    counter += 1\\n                else:\\n                    return False\\n        return True",
                "solutionTags": [],
                "code": "bin(9 + 1) = 1 010\\nStart from the second digit: 0/1/0 means left/right/left when traverse if 9 exists.\\nrecover: T: O(n), S: O(n) (DFS worst case)\\nfind: T: O(logn), S: O(logn) (for the string of path encoding, can be O(1) if use bit mask) \\n```\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.root = root\\n        if not root:\\n            return\\n        root.val = 0\\n        self.recover(root)\\n        return\\n    def recover(self, root):\\n        if not root:\\n            return\\n        if root.left:\\n            root.left.val = root.val * 2 + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = root.val * 2 + 2\\n            self.recover(root.right)\\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        node = self.root\\n        encoding = bin(target + 1)[3:]\\n        counter = 0\\n        while counter < len(encoding):\\n            if encoding[counter] == \"0\":\\n                if node.left:\\n                    node = node.left\\n                    counter += 1\\n                else:\\n                    return False\\n            else:\\n                if node.right:\\n                    node = node.right\\n                    counter += 1\\n                else:\\n                    return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 3172058,
                "title": "c-simple-solution-tc-o-log-n-sc-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(log(N))\\n\\n- Space complexity:\\nO(log(N))\\n# Code\\n```\\nclass FindElements\\n{\\npublic:\\n    TreeNode *root;\\n    FindElements(TreeNode *root2)\\n    {\\n        root = root2;\\n    }\\n\\n    bool find(int tar)\\n    {\\n        stack<int> st;\\n        while (tar > 0)\\n        {\\n            int x = 0;\\n            if ((tar & 1) == 1)\\n            {\\n                x = 1;\\n            }\\n            tar--;\\n            tar >>= 1;\\n            st.push(x);\\n        }\\n        TreeNode *temp = root;\\n        while (!st.empty())\\n        {\\n\\n            if (st.top() == 1)\\n            {\\n                if (temp->left)\\n                {\\n                    temp = temp->left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if (temp->right)\\n                {\\n                    temp = temp->right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            st.pop();\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements\\n{\\npublic:\\n    TreeNode *root;\\n    FindElements(TreeNode *root2)\\n    {\\n        root = root2;\\n    }\\n\\n    bool find(int tar)\\n    {\\n        stack<int> st;\\n        while (tar > 0)\\n        {\\n            int x = 0;\\n            if ((tar & 1) == 1)\\n            {\\n                x = 1;\\n            }\\n            tar--;\\n            tar >>= 1;\\n            st.push(x);\\n        }\\n        TreeNode *temp = root;\\n        while (!st.empty())\\n        {\\n\\n            if (st.top() == 1)\\n            {\\n                if (temp->left)\\n                {\\n                    temp = temp->left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if (temp->right)\\n                {\\n                    temp = temp->right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            st.pop();\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466109,
                "title": "java-bit-representation-of-target-1-solution-with-explanation",
                "content": "if the root.val is 1 instead of 0, then the values of tree node are:\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t 2                           3\\n\\t\\t   4                5           6               7\\n      8 \\t\\t9       10     11   12     13       14     15\\n  ....           .....              ....            ....         ...        ...\\n  ```\\n\\nThe bits starting from index 1(ignore the most significant bit) of binary representation of a val decide the path to reach it:\\n0 -> go to left\\n1 -> go the right;\\n\\nFor example:  \\n2  = 10 => ignore the most significant bit, the representation is \"0\" => 2 is the left child of root.\\n4 = 100 => ignore the most significant bit, the representation is \"00\" => go 2 lefts;\\n11 =1011 => ignore the most significant bit, the represenation is \"011\" => go one left, then 2 rights.\\n\\n```\\nclass FindElements {\\n\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        String binaryRep = Long.toString(target + 1L, 2);\\n        TreeNode curr = root;\\n        int i = 1;\\n        int len = binaryRep.length();\\n        while(i < len && curr != null) {\\n            char ch = binaryRep.charAt(i);\\n            curr = ch == \\'1\\' ? curr.right : curr.left;\\n            ++i;\\n        }\\n        \\n        return curr != null;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t 2                           3\\n\\t\\t   4                5           6               7\\n      8 \\t\\t9       10     11   12     13       14     15\\n  ....           .....              ....            ....         ...        ...\\n  ```\n```\\nclass FindElements {\\n\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        String binaryRep = Long.toString(target + 1L, 2);\\n        TreeNode curr = root;\\n        int i = 1;\\n        int len = binaryRep.length();\\n        while(i < len && curr != null) {\\n            char ch = binaryRep.charAt(i);\\n            curr = ch == \\'1\\' ? curr.right : curr.left;\\n            ++i;\\n        }\\n        \\n        return curr != null;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449680,
                "title": "simple-java-dsf-solution-use-bitset-double-100",
                "content": "```\\n    class FindElements {\\n\\n        private BitSet sets = new BitSet();\\n\\n        public FindElements(TreeNode root) {\\n            dsf(root, 0);\\n        }\\n\\n        public boolean find(int target) {\\n            return sets.get(target);\\n        }\\n\\n        private void dsf(TreeNode root, int val) {\\n            if (root == null) return;\\n            sets.set(val);\\n            dsf(root.left, 2 * val + 1);\\n            dsf(root.right, 2 * val + 2);\\n        }\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    class FindElements {\\n\\n        private BitSet sets = new BitSet();\\n\\n        public FindElements(TreeNode root) {\\n            dsf(root, 0);\\n        }\\n\\n        public boolean find(int target) {\\n            return sets.get(target);\\n        }\\n\\n        private void dsf(TreeNode root, int val) {\\n            if (root == null) return;\\n            sets.set(val);\\n            dsf(root.left, 2 * val + 1);\\n            dsf(root.right, 2 * val + 2);\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202354,
                "title": "easy-java-solution-easy-peasy-lemon-squeezy-simple",
                "content": "\\n# Code\\n```\\nclass FindElements {\\n    TreeNode root;\\n    Set<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        if(root != null){ root.val = 0; set.add(root.val); }\\n        recover(root,set);\\n    }\\n    \\n    public boolean find(int target) {\\n      return set.contains(target);\\n    }\\n\\n    private void recover(TreeNode root, Set<Integer> set){\\n        if(root.left != null){\\n            root.left.val = 2 * root.val + 1;\\n            set.add(root.left.val);\\n            recover(root.left, set);\\n        }\\n       if(root.right != null){\\n            root.right.val = 2 * root.val + 2;\\n            set.add(root.right.val);\\n            recover(root.right, set);\\n       } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    TreeNode root;\\n    Set<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        if(root != null){ root.val = 0; set.add(root.val); }\\n        recover(root,set);\\n    }\\n    \\n    public boolean find(int target) {\\n      return set.contains(target);\\n    }\\n\\n    private void recover(TreeNode root, Set<Integer> set){\\n        if(root.left != null){\\n            root.left.val = 2 * root.val + 1;\\n            set.add(root.left.val);\\n            recover(root.left, set);\\n        }\\n       if(root.right != null){\\n            root.right.val = 2 * root.val + 2;\\n            set.add(root.right.val);\\n            recover(root.right, set);\\n       } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797703,
                "title": "easy-python-o-1-find-recursion-queue",
                "content": "**Easy Python | O(1) Find | Recursion + Queue**\\n\\n**A) Standard Code**\\n\\nIn this problem, we can recover the values of the original Binary Tree, and store them in a \"set\" directly. (There\\'s no need to keep the Binary Tree itself)\\n\\nThis way, we can \"find\" any element with O(1) time/space complexity. The initialization method still runs with O(n) time/space complexity though.\\n\\n```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        self.A = A = set()\\n        #\\n        def recover(n,x):\\n            if n:\\n                A.add(x)\\n                recover(n.left , 2*x + 1)\\n                recover(n.right, 2*x + 2)\\n        #\\n        recover(root,0)\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```\\n\\n**B) 4 Lines of Code**\\n\\nOne-Liner version of the \"Recover\" function :)\\n\\n```\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        recover = lambda n,x: [ A.add(x) , recover(n.left,2*x+1) , recover(n.right,2*x+2) ] if n else None\\n        recover(root,0)\\n    def find(self, target):\\n        return target in self.A\\n```\\n\\n**C) Queue Method**\\n\\nThe previous code versions work fine. However, recursion consumes a lot of system resources, due to the initialization, namespace, and environment variables of each function call. Besides, many compilers have a hardcoded limit for Max. Recursion Depth, and there can be complicaitons by constantly needing to edit global settings.\\n\\nThere\\'s still hope in the galaxy though. We can use \"Queues\" to traverse the original Binary Tree without applying recursion.\\n\\nHere\\'s the code:\\n\\n```\\n# C) Improved Function without Recursion\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        # ---------------------------------------------------------------\\n        #     Queue Version of the Binary Tree \"Recovery\" Method \\n        # ---------------------------------------------------------------\\n        if not root:\\n            return\\n        #\\n        queue = collections.deque([[root,0]])\\n        while queue:\\n            n,x = queue.popleft()\\n            A.add(x)\\n            if n.left:\\n                queue.append( [n.left  , 2*x+1] )\\n            if n.right:\\n                queue.append( [n.right , 2*x+2] )\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```\\n\\nI hope the code was helpful. Cheers,\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        self.A = A = set()\\n        #\\n        def recover(n,x):\\n            if n:\\n                A.add(x)\\n                recover(n.left , 2*x + 1)\\n                recover(n.right, 2*x + 2)\\n        #\\n        recover(root,0)\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```\n```\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        recover = lambda n,x: [ A.add(x) , recover(n.left,2*x+1) , recover(n.right,2*x+2) ] if n else None\\n        recover(root,0)\\n    def find(self, target):\\n        return target in self.A\\n```\n```\\n# C) Improved Function without Recursion\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        # ---------------------------------------------------------------\\n        #     Queue Version of the Binary Tree \"Recovery\" Method \\n        # ---------------------------------------------------------------\\n        if not root:\\n            return\\n        #\\n        queue = collections.deque([[root,0]])\\n        while queue:\\n            n,x = queue.popleft()\\n            A.add(x)\\n            if n.left:\\n                queue.append( [n.left  , 2*x+1] )\\n            if n.right:\\n                queue.append( [n.right , 2*x+2] )\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645499,
                "title": "java-18ms-92-faster",
                "content": "The speed is obtained by not modifiying the tree and using bitwise operator\\nleftshift by 1 == multiplication by 2 and it is much faster than multiplication operator\\n\\nFor the fast lookup use hashmap, because the lookup time is O(1) (avg)\\n```\\nclass FindElements {\\n\\n    Set<Integer> set = new HashSet<>();\\n    void solve(TreeNode root ,int NodeVal){\\n        if(root == null) return;\\n        set.add(NodeVal);\\n        solve(root.left,(NodeVal<<1) + 1); \\n        solve(root.right,(NodeVal<<1) + 2);\\n    }\\n    public FindElements(TreeNode root) {\\n        solve(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n\\n    Set<Integer> set = new HashSet<>();\\n    void solve(TreeNode root ,int NodeVal){\\n        if(root == null) return;\\n        set.add(NodeVal);\\n        solve(root.left,(NodeVal<<1) + 1); \\n        solve(root.right,(NodeVal<<1) + 2);\\n    }\\n    public FindElements(TreeNode root) {\\n        solve(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906458,
                "title": "java-easiest-cosise-beginer-friendly-slow",
                "content": "```\\nclass FindElements {\\n    TreeNode root;\\n    public FindElements(TreeNode r) {\\n        root = r;\\n        r.val = 0;\\n    }\\n    public boolean find(int target) {\\n        return find(root,target);\\n    }\\n    public boolean find(TreeNode root,int target){\\n        if(root == null) return false;\\n        if(root.val == target) return true;\\n        if(root.left != null) root.left.val = 2 * root.val + 1; \\n        if(root.right != null) root.right.val = 2 * root.val + 2;\\n        return find(root.left,target) || find(root.right,target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    TreeNode root;\\n    public FindElements(TreeNode r) {\\n        root = r;\\n        r.val = 0;\\n    }\\n    public boolean find(int target) {\\n        return find(root,target);\\n    }\\n    public boolean find(TreeNode root,int target){\\n        if(root == null) return false;\\n        if(root.val == target) return true;\\n        if(root.left != null) root.left.val = 2 * root.val + 1; \\n        if(root.right != null) root.right.val = 2 * root.val + 2;\\n        return find(root.left,target) || find(root.right,target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530059,
                "title": "c-code-using-bfs-o-n",
                "content": "```\\nclass FindElements {\\n    unordered_map<int, int> m;\\npublic:\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val = 0;\\n        q.push(root);\\n        m[0]++;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            m[temp->val]++;\\n            if(temp->left){\\n                temp->left->val = 2 * temp->val + 1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val = 2 * temp->val + 2;\\n                q.push(temp->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target) != m.end())\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    unordered_map<int, int> m;\\npublic:\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val = 0;\\n        q.push(root);\\n        m[0]++;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            m[temp->val]++;\\n            if(temp->left){\\n                temp->left->val = 2 * temp->val + 1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val = 2 * temp->val + 2;\\n                q.push(temp->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target) != m.end())\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439249,
                "title": "clean-easy-understand-python",
                "content": "\\tdef __init__(self, root: TreeNode):\\n        root.val = 0\\n        self.s = set()\\n        q = [(root, 0)]\\n        self.s.add(0)\\n        while len(q) > 0:\\n            t,v = q.pop()\\n            if t.left:\\n                q.append((t.left, v * 2 + 1))\\n                self.s.add(v * 2 + 1)\\n            if t.right:\\n                q.append((t.right, v * 2 + 2))\\n                self.s.add(v * 2 + 2)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.s",
                "solutionTags": [],
                "code": "\\tdef __init__(self, root: TreeNode):\\n        root.val = 0\\n        self.s = set()\\n        q = [(root, 0)]\\n        self.s.add(0)\\n        while len(q) > 0:\\n            t,v = q.pop()\\n            if t.left:\\n                q.append((t.left, v * 2 + 1))\\n                self.s.add(v * 2 + 1)\\n            if t.right:\\n                q.append((t.right, v * 2 + 2))\\n                self.s.add(v * 2 + 2)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.s",
                "codeTag": "Python3"
            },
            {
                "id": 438239,
                "title": "python-hacks",
                "content": "```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        def v(r, x):\\n            return r and {x} | v(r.left, 2*x+1) | v(r.right, 2*x+2) or set()\\n        self.find = v(root, 0).__contains__\\n```\\n\\nAnother, based on [this one](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/discuss/431229/Python-Special-Way-for-find()-without-HashSet-O(1)-Space-O(logn)-Time/394342):\\n```\\nclass FindElements(object):\\n    def __init__(self, r):\\n        self.find = lambda t: reduce(lambda n, b: n and (n.left, n.right)[int(b)], bin(t+1)[3:], r)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        def v(r, x):\\n            return r and {x} | v(r.left, 2*x+1) | v(r.right, 2*x+2) or set()\\n        self.find = v(root, 0).__contains__\\n```\n```\\nclass FindElements(object):\\n    def __init__(self, r):\\n        self.find = lambda t: reduce(lambda n, b: n and (n.left, n.right)[int(b)], bin(t+1)[3:], r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543983,
                "title": "python-explained-tree-traversal",
                "content": "* We can use any tree traversal method to make the tree contaminated, here we are using preorder traversal it is more favorable here since value of child nodes are dependent on the value of thier parent node.\\n* For efficient target searching we will maintain a set and keep adding the values in it whenever we modify node value.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.root.val = 0\\n        self.st = set()\\n        self.st.add(0)\\n        \\n        def preorder(root):\\n            if root:\\n                if root.left:\\n                    root.left.val = 2*root.val+1\\n                    self.st.add(2*root.val+1)\\n                    preorder(root.left)\\n                if root.right:\\n                    root.right.val = 2*root.val+2\\n                    self.st.add(2*root.val+2)\\n                    preorder(root.right)\\n        preorder(self.root)\\n\\n    def find(self, target: int) -> bool:\\n        return True if target in self.st else False\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```\\n-----------------\\n**Upvote the post if you find it helpful.**\\n**Happy coding.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.root.val = 0\\n        self.st = set()\\n        self.st.add(0)\\n        \\n        def preorder(root):\\n            if root:\\n                if root.left:\\n                    root.left.val = 2*root.val+1\\n                    self.st.add(2*root.val+1)\\n                    preorder(root.left)\\n                if root.right:\\n                    root.right.val = 2*root.val+2\\n                    self.st.add(2*root.val+2)\\n                    preorder(root.right)\\n        preorder(self.root)\\n\\n    def find(self, target: int) -> bool:\\n        return True if target in self.st else False\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176160,
                "title": "simple-and-clean-c-solution-using-dfs-and-a-hashset",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\n```\\n    unordered_set<int> s;\\n    void solve(TreeNode* root)\\n    {\\n        if(root==nullptr)\\n            return;\\n        s.insert(root->val);\\n        if(root->left!=nullptr)\\n            root->left->val=root->val*2+1;\\n        if(root->right!=nullptr)\\n            root->right->val=root->val*2+2;\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n    unordered_set<int> s;\\n    void solve(TreeNode* root)\\n    {\\n        if(root==nullptr)\\n            return;\\n        s.insert(root->val);\\n        if(root->left!=nullptr)\\n            root->left->val=root->val*2+1;\\n        if(root->right!=nullptr)\\n            root->right->val=root->val*2+2;\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 921735,
                "title": "c-o-n-to-build-o-1-query",
                "content": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> cache;\\n    \\n    void recover(TreeNode *root, int prev)\\n    {\\n        if(!root) return;\\n        \\n        root->val = prev;\\n        cache.insert(root->val);\\n        \\n        recover(root->left, 2*prev + 1);\\n        recover(root->right, 2*prev + 2);\\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target)  {\\n        return cache.count(target) > 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> cache;\\n    \\n    void recover(TreeNode *root, int prev)\\n    {\\n        if(!root) return;\\n        \\n        root->val = prev;\\n        cache.insert(root->val);\\n        \\n        recover(root->left, 2*prev + 1);\\n        recover(root->right, 2*prev + 2);\\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target)  {\\n        return cache.count(target) > 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750532,
                "title": "easy-c-solution-using-hashmap",
                "content": "```\\nclass FindElements\\n{\\npublic:\\n    unordered_map<int,int>m;\\n\\n    FindElements(TreeNode* root)\\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            m[0]++;\\n\\n            while(!q.empty())\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                int x = temp->val;\\n                if(temp->left)\\n                {\\n                    temp->left->val = x*2 + 1;\\n\\n                    m[x*2 + 1]++;\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    temp->right->val = x*2 + 2;\\n\\n                    m[x*2 + 2]++;\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool find(int target)\\n    {\\n        return (m.find(target) != m.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements\\n{\\npublic:\\n    unordered_map<int,int>m;\\n\\n    FindElements(TreeNode* root)\\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            m[0]++;\\n\\n            while(!q.empty())\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                int x = temp->val;\\n                if(temp->left)\\n                {\\n                    temp->left->val = x*2 + 1;\\n\\n                    m[x*2 + 1]++;\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    temp->right->val = x*2 + 2;\\n\\n                    m[x*2 + 2]++;\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool find(int target)\\n    {\\n        return (m.find(target) != m.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708923,
                "title": "java-simple-dfs-and-set",
                "content": "```\\nclass FindElements {\\n    Set<Integer> st = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root, 0);\\n    }\\n    \\n    private void dfs(TreeNode node, int val) {\\n        st.add(val);\\n        if (node.left != null) dfs(node.left, val * 2 + 1);\\n        if (node.right != null) dfs(node.right, val * 2 + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return st.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    Set<Integer> st = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root, 0);\\n    }\\n    \\n    private void dfs(TreeNode node, int val) {\\n        st.add(val);\\n        if (node.left != null) dfs(node.left, val * 2 + 1);\\n        if (node.right != null) dfs(node.right, val * 2 + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return st.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509767,
                "title": "c-c-solution-the-find-is-o-1-uses-a-bitset-instead-of-a-set-saves-memory",
                "content": "If the tree is not too sparse, using a bitset uses less memory than an unordered_set. I think it amounts to only 8KiB, given the problem\\'s upper node limit, enough to fit entirely in the CPU\\'s cache. I also expect element access to compare favorably with an unordered_set\\'s.\\nIf lots of small trees are to be expected, preallocating a full-size bitset may be a pessimization, but replacing it with a (dynamic-sized) vector is fairly straightforward.\\n\\n```\\nclass FindElements {\\n    std::bitset< (2<<20) > vv;\\n    \\n    void recover(TreeNode* n, int ii) {\\n        if(!n) { return; }\\n        \\n        vv[ii] = true;\\n        recover(n->left, ii*2+1);\\n        recover(n->right, ii*2+2);\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return vv[target] == true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\n    std::bitset< (2<<20) > vv;\\n    \\n    void recover(TreeNode* n, int ii) {\\n        if(!n) { return; }\\n        \\n        vv[ii] = true;\\n        recover(n->left, ii*2+1);\\n        recover(n->right, ii*2+2);\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return vv[target] == true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758852,
                "title": "bfs-level-order-traversal-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse **BFS (Level Order Traversal Format)** to assign values to the nodes and store them in an **unordered map** to return the answer in **O(1) time** in the **find() function**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    unordered_map<int,bool> mp;\\n    FindElements(TreeNode* root) {\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n        while(!q.empty())\\n        {\\n            int n = q.size(),f = 1;\\n            for(int i = 0;i<n;i++)\\n            {\\n              TreeNode*  node = q.front().first;\\n              int val = q.front().second;\\n              q.pop();\\n              if(node) mp[val] = true;\\n             if(node)\\n             {\\n                q.push({node->left,2*val+1});\\n                q.push({node->right,2*val+2});\\n                f = 0;\\n             }\\n             else\\n             {\\n                q.push({NULL,2*val+1});\\n                q.push({NULL,2*val+2});\\n              }\\n            }\\n            if(f) break;\\n        }  \\n    }\\n    bool find(int t) {\\n         return mp[t]==true;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/64c6c860-2b36-4c39-bf33-7b4a44813c67_1689243388.5248017.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int,bool> mp;\\n    FindElements(TreeNode* root) {\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n        while(!q.empty())\\n        {\\n            int n = q.size(),f = 1;\\n            for(int i = 0;i<n;i++)\\n            {\\n              TreeNode*  node = q.front().first;\\n              int val = q.front().second;\\n              q.pop();\\n              if(node) mp[val] = true;\\n             if(node)\\n             {\\n                q.push({node->left,2*val+1});\\n                q.push({node->right,2*val+2});\\n                f = 0;\\n             }\\n             else\\n             {\\n                q.push({NULL,2*val+1});\\n                q.push({NULL,2*val+2});\\n              }\\n            }\\n            if(f) break;\\n        }  \\n    }\\n    bool find(int t) {\\n         return mp[t]==true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086295,
                "title": "simple-dfs-solution-beats-others",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* curr;\\n    FindElements(TreeNode* root) {\\n        curr=root;\\n    }\\n    bool findVal(TreeNode*root,int val,int x){\\n        if(!root)return false;\\n        if(val==0)return true;\\n        root->val=x;\\n        if(root->val==val)return true;       \\n        return findVal(root->left,val,(2*root->val)+1)||  findVal(root->right,val,(2*root->val)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return findVal(curr,target,0);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* curr;\\n    FindElements(TreeNode* root) {\\n        curr=root;\\n    }\\n    bool findVal(TreeNode*root,int val,int x){\\n        if(!root)return false;\\n        if(val==0)return true;\\n        root->val=x;\\n        if(root->val==val)return true;       \\n        return findVal(root->left,val,(2*root->val)+1)||  findVal(root->right,val,(2*root->val)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return findVal(curr,target,0);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076480,
                "title": "easy-understading-and-memory-efficient-solution-in-js",
                "content": "```\\nvar FindElements = function(root) {\\n    this.tree = root\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nFindElements.prototype.find = function(target) {\\n    this.tree.val = 0;\\n    function find(target,root){\\n        if(!root) return false;\\n        let val = root.val\\n        if(val === target) return true;\\n        if(root.left) {\\n            root.left.val = 2*val +1;\\n            if(find(target,root.left)) return true\\n        }\\n        if(root.right) {\\n            root.right.val = 2*val +2;\\n            if(find(target,root.right))return true\\n        }\\n        return false\\n    }\\n     return find(target,this.tree)\\n    \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nvar FindElements = function(root) {\\n    this.tree = root\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nFindElements.prototype.find = function(target) {\\n    this.tree.val = 0;\\n    function find(target,root){\\n        if(!root) return false;\\n        let val = root.val\\n        if(val === target) return true;\\n        if(root.left) {\\n            root.left.val = 2*val +1;\\n            if(find(target,root.left)) return true\\n        }\\n        if(root.right) {\\n            root.right.val = 2*val +2;\\n            if(find(target,root.right))return true\\n        }\\n        return false\\n    }\\n     return find(target,this.tree)\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2998771,
                "title": "c-array-and-tree-easiest-approach",
                "content": "\\n# Approach\\nForming a array to store binary tree. The values that is asked to store is similar to index that we use to store element of tree in array. Only storing a tree will take O(n). Otherwise find function will take O(1) time as it is only checking whether at target value, i.e., same as index of array is -1 or not.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ ---- where n is the number of nodes in tree.\\n\\n# Code\\n```\\nclass FindElements {\\n    vector<int> treeArr;\\npublic:\\n    FindElements(TreeNode* root) {\\n        treeArr = vector<int>(1e6+1, -1);\\n        dfs(root, 0);\\n    }\\n\\n    void dfs(TreeNode* root, int i){\\n        if(root == NULL || i > 1e6)\\n            return;\\n\\n        treeArr[i] = i;\\n        dfs(root->left, 2*i+1);\\n        dfs(root->right, 2*i+2);\\n    }\\n    \\n    bool find(int target) {\\n        if(treeArr[target] == -1)\\n            return false;\\n\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\n    vector<int> treeArr;\\npublic:\\n    FindElements(TreeNode* root) {\\n        treeArr = vector<int>(1e6+1, -1);\\n        dfs(root, 0);\\n    }\\n\\n    void dfs(TreeNode* root, int i){\\n        if(root == NULL || i > 1e6)\\n            return;\\n\\n        treeArr[i] = i;\\n        dfs(root->left, 2*i+1);\\n        dfs(root->right, 2*i+2);\\n    }\\n    \\n    bool find(int target) {\\n        if(treeArr[target] == -1)\\n            return false;\\n\\n        return true;\\n    }\\n};\\n```\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816045,
                "title": "java-easy-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSave all the nodes value in HashSet\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\n\\n    Set<Integer> nodes;\\n    public FindElements(TreeNode root) {\\n        nodes = new HashSet<>();\\n        recover(root,0);\\n    }\\n    private void recover(TreeNode root, int parent){\\n        if(root == null){\\n            return;\\n        }\\n        root.val = parent;\\n        nodes.add(root.val);\\n        recover(root.left,2*parent+1);\\n        recover(root.right,2*parent+2);\\n    }\\n    public boolean find(int target) {\\n        return nodes.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FindElements {\\n\\n    Set<Integer> nodes;\\n    public FindElements(TreeNode root) {\\n        nodes = new HashSet<>();\\n        recover(root,0);\\n    }\\n    private void recover(TreeNode root, int parent){\\n        if(root == null){\\n            return;\\n        }\\n        root.val = parent;\\n        nodes.add(root.val);\\n        recover(root.left,2*parent+1);\\n        recover(root.right,2*parent+2);\\n    }\\n    public boolean find(int target) {\\n        return nodes.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025906,
                "title": "easy-python-solution-faster-than-99-76-ms-comments",
                "content": "# Easy Python Solution | Faster than 99% (76 ms) | With Comments\\n\\n**Runtime: 76 ms, faster than 99.13% of Python3 online submissions for Find Elements in a Contaminated Binary Tree.\\nMemory Usage: 17.9 MB**\\n\\n```\\nclass FindElements:\\n    \\n    def dfs(self, node, val):\\n        if node:\\n            self.store[val] = 1  # adding the value of node to hashmap\\n            if node.left:\\n                vl = (2 * val) + 1  # correcting the value of left node\\n                self.dfs(node.left,vl)  # left sub tree traversal\\n            if node.right:\\n                vr = (2* val) + 2  # correcting the value of right node\\n                self.dfs(node.right, vr)  # right sub tree traversal\\n\\n    def __init__(self, root: TreeNode):\\n        self.store = {}  # hashmap for storing the corrected node values. And searching the values.\\n        self.dfs(root, 0)  # Traversing the incorrect tree and saving correct values on the way\\n\\n    def find(self, target: int) -> bool:\\n\\t\\t# checking if the target value exists in O(1) time\\n        if self.store.get(target, None) is not None:\\n            return True\\n        else:\\n            return False\\n```\\n![image](https://assets.leetcode.com/users/images/378c2109-1b90-48a2-829e-fab65cc6abbc_1652190280.408396.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements:\\n    \\n    def dfs(self, node, val):\\n        if node:\\n            self.store[val] = 1  # adding the value of node to hashmap\\n            if node.left:\\n                vl = (2 * val) + 1  # correcting the value of left node\\n                self.dfs(node.left,vl)  # left sub tree traversal\\n            if node.right:\\n                vr = (2* val) + 2  # correcting the value of right node\\n                self.dfs(node.right, vr)  # right sub tree traversal\\n\\n    def __init__(self, root: TreeNode):\\n        self.store = {}  # hashmap for storing the corrected node values. And searching the values.\\n        self.dfs(root, 0)  # Traversing the incorrect tree and saving correct values on the way\\n\\n    def find(self, target: int) -> bool:\\n\\t\\t# checking if the target value exists in O(1) time\\n        if self.store.get(target, None) is not None:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772130,
                "title": "beginner-friendly-python-soluiton",
                "content": "**Time Complexity : O(N)**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        self.st = set()\\n        \\n        def recover(root, val) :\\n            if(root):\\n                self.st.add(val)\\n                recover(root.left, 2 * val + 1)\\n                recover(root.right, 2 * val + 2)\\n        \\n        recover(root, 0)\\n        \\n\\n    def find(self, target):\\n        return target in self.st\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        self.st = set()\\n        \\n        def recover(root, val) :\\n            if(root):\\n                self.st.add(val)\\n                recover(root.left, 2 * val + 1)\\n                recover(root.right, 2 * val + 2)\\n        \\n        recover(root, 0)\\n        \\n\\n    def find(self, target):\\n        return target in self.st\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702451,
                "title": "c-easy-and-concise",
                "content": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int>st;\\n    void makeTree(TreeNode* root,int data)\\n    {\\n        if(!root) return;\\n        root->val=data;\\n        st.insert(data);\\n        makeTree(root->left,(data*2+1));\\n        makeTree(root->right,(data*2+2));\\n            \\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        makeTree(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int>st;\\n    void makeTree(TreeNode* root,int data)\\n    {\\n        if(!root) return;\\n        root->val=data;\\n        st.insert(data);\\n        makeTree(root->left,(data*2+1));\\n        makeTree(root->right,(data*2+2));\\n            \\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        makeTree(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628594,
                "title": "c-easy-to-implementation",
                "content": "class FindElements {\\npublic:\\n\\n    set<int>s;\\n    void solve(TreeNode *root)\\n    {\\n          if(root)\\n          {\\n             int x=root->val;\\n             if(root->left)\\n             {\\n               root->left->val=2*x+1;\\n               s.insert(2*x+1);\\n               solve(root->left);\\n             }\\n            if(root->right)\\n            {\\n              root->right->val=2*x+2;\\n              s.insert(2*x+2);\\n              solve(root->right);\\n            }\\n          }\\n    }\\n    FindElements(TreeNode* root) {\\n         root->val=0;\\n         s.insert(0);\\n         solve(root);\\n    } \\n    \\n    bool find(int t) {\\n        if(s.find(t)!=s.end())\\n          return true;\\n      return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "class FindElements {\\npublic:\\n\\n    set<int>s;\\n    void solve(TreeNode *root)\\n    {\\n          if(root)\\n          {\\n             int x=root->val;\\n             if(root->left)\\n             {\\n               root->left->val=2*x+1;\\n               s.insert(2*x+1);\\n               solve(root->left);\\n             }\\n            if(root->right)\\n            {\\n              root->right->val=2*x+2;\\n              s.insert(2*x+2);\\n              solve(root->right);\\n            }\\n          }\\n    }\\n    FindElements(TreeNode* root) {\\n         root->val=0;\\n         s.insert(0);\\n         solve(root);\\n    } \\n    \\n    bool find(int t) {\\n        if(s.find(t)!=s.end())\\n          return true;\\n      return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1626666,
                "title": "c-easy-map",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    int x = 0 ; \\n    map<int,int>mp ; \\n    void build(TreeNode *root , int x)\\n    {\\n        if(root == nullptr)\\n        {\\n            return ; \\n        }\\n        root->val = x ; \\n        mp[x]++ ; \\n        build(root->left,2*x+1);\\n        build(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n         build(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target) != mp.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    int x = 0 ; \\n    map<int,int>mp ; \\n    void build(TreeNode *root , int x)\\n    {\\n        if(root == nullptr)\\n        {\\n            return ; \\n        }\\n        root->val = x ; \\n        mp[x]++ ; \\n        build(root->left,2*x+1);\\n        build(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n         build(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target) != mp.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1514524,
                "title": "c-easy-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> set;\\n    void recover(TreeNode* root , int x){\\n        if(!root ){\\n            return ;\\n        }\\n        set.insert(x);\\n        recover(root->left , 2*x+1);\\n        recover(root->right , 2*x+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n              recover(root, 0);\\n\\n    }\\n\\n    bool find(int target) {\\n    return set.count(target);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> set;\\n    void recover(TreeNode* root , int x){\\n        if(!root ){\\n            return ;\\n        }\\n        set.insert(x);\\n        recover(root->left , 2*x+1);\\n        recover(root->right , 2*x+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n              recover(root, 0);\\n\\n    }\\n\\n    bool find(int target) {\\n    return set.count(target);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1363748,
                "title": "c-99-faster-simple-dfs",
                "content": "```\\nclass FindElements {\\npublic:\\n    vector<bool> mapper;\\n    FindElements(TreeNode* root) {\\n        mapper.resize(1000005,false);\\n        filterThis(root,0);\\n    }\\n    void filterThis(TreeNode* root, int x) {\\n        if(!root) return;\\n        if(x<=1000001) {\\n            mapper[x] = true; \\n            filterThis(root->left, 2*x+1);\\n            filterThis(root->right,2*x+2);\\n        }\\n    }\\n    bool find(int target) {\\n        return mapper[target];\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    vector<bool> mapper;\\n    FindElements(TreeNode* root) {\\n        mapper.resize(1000005,false);\\n        filterThis(root,0);\\n    }\\n    void filterThis(TreeNode* root, int x) {\\n        if(!root) return;\\n        if(x<=1000001) {\\n            mapper[x] = true; \\n            filterThis(root->left, 2*x+1);\\n            filterThis(root->right,2*x+2);\\n        }\\n    }\\n    bool find(int target) {\\n        return mapper[target];\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 431461,
                "title": "c-simple-easy-brute-force",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass FindElements {\\nprivate: \\n    TreeNode* root;\\npublic:\\n    \\n    void itr(TreeNode *root, int vl){\\n        if(!root) return;\\n        root->val = vl;\\n        itr(root->left,2*vl+1);\\n        itr(root->right,2*vl+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n            if(!root)\\n                return;\\n            itr(root,0);\\n            this->root = root;\\n        \\n    }\\n    \\n    bool fnd(TreeNode * root, int target){\\n        if(!root)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        return fnd(root->left, target) || fnd(root->right, target);\\n    }\\n    \\n    bool find(int target) {\\n        return fnd(root, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass FindElements {\\nprivate: \\n    TreeNode* root;\\npublic:\\n    \\n    void itr(TreeNode *root, int vl){\\n        if(!root) return;\\n        root->val = vl;\\n        itr(root->left,2*vl+1);\\n        itr(root->right,2*vl+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n            if(!root)\\n                return;\\n            itr(root,0);\\n            this->root = root;\\n        \\n    }\\n    \\n    bool fnd(TreeNode * root, int target){\\n        if(!root)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        return fnd(root->left, target) || fnd(root->right, target);\\n    }\\n    \\n    bool find(int target) {\\n        return fnd(root, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063151,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    static void recover(TreeNode root){\\n        if(root==null) return;\\n\\n        int x = root.val;\\n        if(root.left!=null) root.left.val = 2*x+1;\\n        if(root.right!=null) root.right.val = 2*x+2;\\n        recover(root.left);\\n        recover(root.right);\\n    }\\n\\n    static boolean check(TreeNode root, int a){\\n        if(root==null) return false;\\n        if(root.val==a) return true;\\n\\n        return check(root.left,a) || check(root.right,a);\\n    }\\n\\n    public FindElements(TreeNode x) {\\n        root = x;\\n        root.val = 0;\\n        recover(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return check(root,target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    static void recover(TreeNode root){\\n        if(root==null) return;\\n\\n        int x = root.val;\\n        if(root.left!=null) root.left.val = 2*x+1;\\n        if(root.right!=null) root.right.val = 2*x+2;\\n        recover(root.left);\\n        recover(root.right);\\n    }\\n\\n    static boolean check(TreeNode root, int a){\\n        if(root==null) return false;\\n        if(root.val==a) return true;\\n\\n        return check(root.left,a) || check(root.right,a);\\n    }\\n\\n    public FindElements(TreeNode x) {\\n        root = x;\\n        root.val = 0;\\n        recover(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return check(root,target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026035,
                "title": "easy-friendly-c-solution-based-on-precomputation-o-1-query-runtime",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses preorder DFS to recover all the nodes recursively, while also maintaining a hashmap for the found values so that we can easily hunt for the target value in the query.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ in recovering the tree, $$O(1)$$ for queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the recursive stack and the hashmap.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    unordered_map <int, bool> map;\\n\\n    void solve (TreeNode* root, int i) {\\n        if (!root) return;\\n        root->val = i;\\n        map[i] = true;\\n        solve (root->left, 2*i + 1);\\n        solve(root->right, 2*i + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        solve(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if (map.find(target) != map.end()) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map <int, bool> map;\\n\\n    void solve (TreeNode* root, int i) {\\n        if (!root) return;\\n        root->val = i;\\n        map[i] = true;\\n        solve (root->left, 2*i + 1);\\n        solve(root->right, 2*i + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        solve(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if (map.find(target) != map.end()) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019065,
                "title": "simple-solution-with-depth-first-search-hashset-in-python3",
                "content": "# Intuition\\nThe problem description is the following:\\n- there\\'s a **Binary Tree**, all of its values equal to `-1`\\n- our goal is to **recover** all nodes by changing values according to the schema\\n\\n```py\\n# Example\\ntree = TreeNode(-1, None, TreeNode(-1, TreeNode(-1)))\\n\\n# The original values in left parentheses and \\n# restored in right ones \\n#   (-1) => (0)\\n#     \\\\       \\\\\\n#     (-1) => (2)\\n#      /      /\\n#    (-1)=> (5)\\n\\n# The formulae to calculate value for a particular node\\n# is the following (for root.val == 0)\\n# node.left.val = parentNode.val * 2 + 1 \\n# node.right.val = parentNode.val * 2 + 2\\n \\n```\\n\\n# Approach \\n1. define a `set`, that\\'ll store all of the traversed values from `root` to quick search inside `find` method\\n2. define `recover` function to recover the values of a tree\\n3. if there\\'s no `node` return `None`\\n4. if the `left` or `right` children exist, change the values according to the schema and store the values inside `self.set`\\n5. implement the `find` method with checking value in `self.set`\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating over `root`\\n\\n- Space complexity: **O(n)**, because of recursive call stack and storing all the values inside `self.set`\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def recover(self, node):\\n        if not node: \\n            return node\\n\\n        node.val = 0\\n        \\n        def dfs(node, val = 0):\\n            if not node:\\n                return \\n            if node.left:\\n                node.left.val = val * 2 + 1\\n                self.set.add(node.left.val)\\n                dfs(node.left, node.left.val)\\n            if node.right:\\n                node.right.val = val * 2 + 2\\n                self.set.add(node.right.val)\\n                dfs(node.right, node.right.val)\\n\\n        dfs(node)\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.set = {0}\\n        self.recover(root)\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.set\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```py\\n# Example\\ntree = TreeNode(-1, None, TreeNode(-1, TreeNode(-1)))\\n\\n# The original values in left parentheses and \\n# restored in right ones \\n#   (-1) => (0)\\n#     \\\\       \\\\\\n#     (-1) => (2)\\n#      /      /\\n#    (-1)=> (5)\\n\\n# The formulae to calculate value for a particular node\\n# is the following (for root.val == 0)\\n# node.left.val = parentNode.val * 2 + 1 \\n# node.right.val = parentNode.val * 2 + 2\\n \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def recover(self, node):\\n        if not node: \\n            return node\\n\\n        node.val = 0\\n        \\n        def dfs(node, val = 0):\\n            if not node:\\n                return \\n            if node.left:\\n                node.left.val = val * 2 + 1\\n                self.set.add(node.left.val)\\n                dfs(node.left, node.left.val)\\n            if node.right:\\n                node.right.val = val * 2 + 2\\n                self.set.add(node.right.val)\\n                dfs(node.right, node.right.val)\\n\\n        dfs(node)\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.set = {0}\\n        self.recover(root)\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.set\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637883,
                "title": "easy-solution-using-set-and-traversal-in-c",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    set<int> num;\\n    void traverse(TreeNode *root) {\\n        \\n        if(root == NULL) {\\n            return;\\n        }\\n        if(root->left) {\\n            root->left->val = 2 * root->val + 1;\\n            num.insert(2 * root->val + 1);\\n            traverse(root->left);\\n        }\\n        if(root->right) {\\n            root->right->val = 2 * root->val + 2;\\n            num.insert(2 * root->val + 2);\\n            traverse(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        num.insert(0);\\n        traverse(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(num.find(target) != num.end()) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    set<int> num;\\n    void traverse(TreeNode *root) {\\n        \\n        if(root == NULL) {\\n            return;\\n        }\\n        if(root->left) {\\n            root->left->val = 2 * root->val + 1;\\n            num.insert(2 * root->val + 1);\\n            traverse(root->left);\\n        }\\n        if(root->right) {\\n            root->right->val = 2 * root->val + 2;\\n            num.insert(2 * root->val + 2);\\n            traverse(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        num.insert(0);\\n        traverse(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(num.find(target) != num.end()) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589532,
                "title": "c-solution-using-preorder-traversal-and-hashmap",
                "content": "# Intuition\\nWe simply need to store the appropriate values for non-empty nodes and update their values as required. As the values for the left or right child depend on the root value, so we update that first.\\n\\n# Approach\\nWe apply pre-order traversal where we first visit the root, then the left child and right child respectively. Map is used to store the node values accordingly. \\n\\n# Complexity\\n- Time complexity:\\nFor FindElements:- O(N)\\nFor find:- O(1)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,int> mp;\\nvoid preorder(TreeNode* root){\\n        //base case\\n        if(root==NULL){\\n        return;\\n        }\\n        if(root->left){\\n            mp[2*root->val +1];\\n            root->left->val = 2*root->val+1;\\n        preorder(root->left);\\n        }\\n        if(root->right){\\n            mp[2*root->val + 2];\\n            root->right->val = 2*root->val+2;\\n        preorder(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL) {mp[0]++;\\n        root->val = 0;\\n        preorder(root);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp.find(target) != mp.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```\\nPlease upvote if you understod the solution!\\nHave a great day :)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,int> mp;\\nvoid preorder(TreeNode* root){\\n        //base case\\n        if(root==NULL){\\n        return;\\n        }\\n        if(root->left){\\n            mp[2*root->val +1];\\n            root->left->val = 2*root->val+1;\\n        preorder(root->left);\\n        }\\n        if(root->right){\\n            mp[2*root->val + 2];\\n            root->right->val = 2*root->val+2;\\n        preorder(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL) {mp[0]++;\\n        root->val = 0;\\n        preorder(root);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp.find(target) != mp.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576674,
                "title": "map-post-order",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* r) {\\n        dfs(r,0);\\n    }\\n    \\n    void dfs(TreeNode* r,int val)\\n    {\\n        if(!r)\\n            return;\\n        mp[val] = val;\\n        dfs(r->left,val*2+1);\\n        dfs(r->right,val*2+2);\\n        \\n    }\\n    \\n    bool find(int t) {\\n        return mp.count(t)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* r) {\\n        dfs(r,0);\\n    }\\n    \\n    void dfs(TreeNode* r,int val)\\n    {\\n        if(!r)\\n            return;\\n        mp[val] = val;\\n        dfs(r->left,val*2+1);\\n        dfs(r->right,val*2+2);\\n        \\n    }\\n    \\n    bool find(int t) {\\n        return mp.count(t)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394657,
                "title": "easy-c",
                "content": "# Intuition :\\nDeclare global variable head in which we will store root and then pass it to find function and inside findelement function intialize root.val 0 and make new function help and pass root.\\n\\n# Approach : \\nBinary Tree\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void help(TreeNode *p){\\n        if(p->left != NULL){\\n            p->left->val = 2*p->val+1;\\n            help(p->left);\\n        }\\n        if(p->right != NULL){\\n            p->right->val = 2*p->val + 2;\\n            help(p->right);\\n        }\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        head = root;\\n        help(root);\\n    }\\n    bool findnode(TreeNode *root, int target){\\n        if(root==NULL) return false;\\n    if(root->val == target){\\n        return true;\\n    }\\n    else\\n    {\\n        bool ans=findnode(root->left , target);\\n        if(ans==true) return true;\\n        bool ans2=findnode(root->right , target);\\n        if(ans2==true) return true;\\n    }\\n    return false;\\n    }\\n    bool find(int target) {\\n       return findnode(head, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void help(TreeNode *p){\\n        if(p->left != NULL){\\n            p->left->val = 2*p->val+1;\\n            help(p->left);\\n        }\\n        if(p->right != NULL){\\n            p->right->val = 2*p->val + 2;\\n            help(p->right);\\n        }\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        head = root;\\n        help(root);\\n    }\\n    bool findnode(TreeNode *root, int target){\\n        if(root==NULL) return false;\\n    if(root->val == target){\\n        return true;\\n    }\\n    else\\n    {\\n        bool ans=findnode(root->left , target);\\n        if(ans==true) return true;\\n        bool ans2=findnode(root->right , target);\\n        if(ans2==true) return true;\\n    }\\n    return false;\\n    }\\n    bool find(int target) {\\n       return findnode(head, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394585,
                "title": "easy-using-unordered-map",
                "content": "# Intuition\\nThe intuition behind this code is to leverage the properties of a binary tree to efficiently check whether a particular value exists in it or not.\\n\\nThe constructor sets up a map that will keep track of all the integer values that exist in the binary tree. It uses a pre-order traversal to assign integer values to each node of the binary tree. The integer value of a node is calculated based on its position in the binary tree, where the root node has a value of 0, the left child of a node with value x has a value of 2x+1, and the right child of a node with value x has a value of 2x+2. This ensures that all nodes in the binary tree have a unique integer value.\\n\\nOnce all the integer values have been assigned to each node in the binary tree, the \"sexy\" map is updated to indicate that the integer value of each node exists in the binary tree.\\n\\nThe \"find\" method simply checks if the target value is present in the \"sexy\" map. Since the \"sexy\" map only contains integer values that exist in the binary tree, this allows for a quick check to determine if the target value exists in the binary tree or not.\\n\\nOverall, the intuition behind this code is to trade off additional memory usage for faster lookup times for checking whether a value exists in a binary tree.\\n\\n# Approach\\nThis code defines a class called \"FindElements\" which provides a way to find whether a target value exists in a binary tree. The binary tree is represented by a TreeNode* pointer to its root node.\\n\\nThe class has two public methods: \"FindElements\" (constructor) and \"find\". The constructor takes in a TreeNode* pointer to the root of the binary tree and sets up a map called \"sexy\" (not a very appropriate name) which maps integer values to boolean flags. The \"setting\" method is called recursively to traverse the binary tree in a pre-order manner and set the values of each node with an increasing integer value starting from 0, which represents the root node. As each node\\'s value is set, the \"sexy\" map is updated to mark that value as present in the binary tree.\\n\\nThe \"find\" method takes in a target integer value and returns whether that value is present in the binary tree by looking it up in the \"sexy\" map. If the target value exists in the binary tree, the method returns true, otherwise false.\\n\\nOverall, this code provides a simple way to check whether a particular value exists in a binary tree without having to traverse the entire tree each time. The downside is that it requires additional memory to maintain the \"sexy\" map.\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,bool> sexy;\\npublic:\\n\\n    void setting(TreeNode* root , int x){\\n        if(!root) return;\\n        root->val = x;\\n        sexy[x] = true;\\n        \\n        setting(root->left,2*x+1);\\n        setting(root->right,2*x+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        setting(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return sexy[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,bool> sexy;\\npublic:\\n\\n    void setting(TreeNode* root , int x){\\n        if(!root) return;\\n        root->val = x;\\n        sexy[x] = true;\\n        \\n        setting(root->left,2*x+1);\\n        setting(root->right,2*x+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        setting(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return sexy[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118073,
                "title": "c-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    void help(TreeNode* root){\\n        if(root->left){\\n            root->left->val = (2*root->val) +1;\\n            help(root->left);\\n        }\\n        \\n        if(root->right){\\n            root->right->val = (2*root->val) +2;\\n            help(root->right);\\n        }\\n    }\\n    \\n    TreeNode* head;\\n    \\n    FindElements(TreeNode* root) {\\n        head= root;\\n        root->val=0;\\n        help(root);\\n    }\\n    \\n    bool findd(TreeNode* root, int tar){\\n        if(!root)return false;\\n        if(root->val== tar) return true;\\n        \\n        return findd(root->left, tar)||findd(root->right, tar);\\n    }\\n    \\n    bool find(int target) {\\n        return findd(head, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    void help(TreeNode* root){\\n        if(root->left){\\n            root->left->val = (2*root->val) +1;\\n            help(root->left);\\n        }\\n        \\n        if(root->right){\\n            root->right->val = (2*root->val) +2;\\n            help(root->right);\\n        }\\n    }\\n    \\n    TreeNode* head;\\n    \\n    FindElements(TreeNode* root) {\\n        head= root;\\n        root->val=0;\\n        help(root);\\n    }\\n    \\n    bool findd(TreeNode* root, int tar){\\n        if(!root)return false;\\n        if(root->val== tar) return true;\\n        \\n        return findd(root->left, tar)||findd(root->right, tar);\\n    }\\n    \\n    bool find(int target) {\\n        return findd(head, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921408,
                "title": "easy-to-understand-c-solution-using-recursion-and-bt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* root1;\\n    TreeNode* answer(TreeNode* root,int x)\\n    {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        root->val=x;\\n        if(root->left!=NULL)\\n        {\\n          answer(root->left,2*x+1);\\n        }\\n        if(root->right!=NULL)\\n        {\\n          answer(root->right,2*x+2);\\n        }\\n        return root;\\n    }\\n    FindElements(TreeNode* root) {\\n        int x=0;\\n        root1=answer(root,x);\\n    }\\n    int maxi(TreeNode* temp,int target)//To find if target is in tree or not\\n    {\\n        if(temp==NULL)\\n        {\\n            return 0;\\n        }\\n         if(temp->val==target)\\n        {\\n            return 1;\\n        }\\n        int left=maxi(temp->left,target);\\n        int right=maxi(temp->right,target);\\n        return max(left,right);\\n    }\\n    bool find(int target) {\\n        TreeNode* temp=root1;\\n        int ans=maxi(temp,target);\\n        if(ans==0)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* root1;\\n    TreeNode* answer(TreeNode* root,int x)\\n    {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        root->val=x;\\n        if(root->left!=NULL)\\n        {\\n          answer(root->left,2*x+1);\\n        }\\n        if(root->right!=NULL)\\n        {\\n          answer(root->right,2*x+2);\\n        }\\n        return root;\\n    }\\n    FindElements(TreeNode* root) {\\n        int x=0;\\n        root1=answer(root,x);\\n    }\\n    int maxi(TreeNode* temp,int target)//To find if target is in tree or not\\n    {\\n        if(temp==NULL)\\n        {\\n            return 0;\\n        }\\n         if(temp->val==target)\\n        {\\n            return 1;\\n        }\\n        int left=maxi(temp->left,target);\\n        int right=maxi(temp->right,target);\\n        return max(left,right);\\n    }\\n    bool find(int target) {\\n        TreeNode* temp=root1;\\n        int ans=maxi(temp,target);\\n        if(ans==0)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720120,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n  unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n  unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672559,
                "title": "recursive-approach",
                "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* start;\\n    void modify(TreeNode* root)  //function to modify tree\\n    {  if(!root)\\n        return;        \\n        if(root->left!=NULL)\\n            root->left->val=2*root->val+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*root->val+2;\\n        modify(root->left);\\n        modify(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        start=root;\\n        if(!root)\\n            return;\\n        root->val=0;\\n        modify(root);\\n        \\n    }\\n    \\n    bool find(int target) {\\n        return findval(start,target);\\n    }\\n    bool findval(TreeNode* root,int target)\\n    {\\n       if(!root)\\n           return false;\\n        \\n        if(root->val==target)\\n            return true;\\n        else\\n            return findval(root->left,target) || findval(root->right,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* start;\\n    void modify(TreeNode* root)  //function to modify tree\\n    {  if(!root)\\n        return;        \\n        if(root->left!=NULL)\\n            root->left->val=2*root->val+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*root->val+2;\\n        modify(root->left);\\n        modify(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        start=root;\\n        if(!root)\\n            return;\\n        root->val=0;\\n        modify(root);\\n        \\n    }\\n    \\n    bool find(int target) {\\n        return findval(start,target);\\n    }\\n    bool findval(TreeNode* root,int target)\\n    {\\n       if(!root)\\n           return false;\\n        \\n        if(root->val==target)\\n            return true;\\n        else\\n            return findval(root->left,target) || findval(root->right,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2553191,
                "title": "simple-dfs-solution-c",
                "content": "**Please upvote if you like my solution .**\\n```\\nclass FindElements {\\npublic:\\n    // to return answer in O( 1 )  by storing if node with value is present or not\\n    vector<bool> node;\\n    // doing dfs and updating node value \\n    void dfs(TreeNode* r, int i){\\n        if(r == NULL) return;\\n        if(i < 1000000)\\n            node[i] = 1;\\n        dfs(r->left ,i*2 + 1);\\n        dfs(r->right,i*2 + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        node.reserve(1000000); // max value of node is 1000000 \\n        for(int i = 0 ; i < 1000000; i++) node[i] = 0; // in start \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return node[target]; // return present or not \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    // to return answer in O( 1 )  by storing if node with value is present or not\\n    vector<bool> node;\\n    // doing dfs and updating node value \\n    void dfs(TreeNode* r, int i){\\n        if(r == NULL) return;\\n        if(i < 1000000)\\n            node[i] = 1;\\n        dfs(r->left ,i*2 + 1);\\n        dfs(r->right,i*2 + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        node.reserve(1000000); // max value of node is 1000000 \\n        for(int i = 0 ; i < 1000000; i++) node[i] = 0; // in start \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return node[target]; // return present or not \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469299,
                "title": "c-easy-fully-commented-logic",
                "content": "```   \\n//this will store values of all the nodes\\n    map<int,int>m;\\n    \\n    void calc(TreeNode* root,int &r)\\n    {\\n        //if not root then simply return\\n        if(!root)\\n            return;\\n        //if it is a root then make it 0\\n        if(r==-1)\\n        {\\n            m[0]++;\\n            root->val=0;\\n            //change r so that no other node gets value 0\\n            r=10;\\n        }\\n        //if left child exists then update it\\'s value\\n        if(root->left)\\n        {\\n             root->left->val=2*root->val+1;\\n            //don\\'t forget to map the value\\n            m[root->left->val]++;\\n        }\\n        //if right child exists then update it\\'s value\\n        if(root->right)\\n        {\\n            root->right->val=2*root->val+2;\\n            //don\\'t forget to map the value\\n            m[root->right->val]++;\\n        }\\n        //recursively do the same with other nodes\\n        calc(root->left,r);\\n        calc(root->right,r);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        //this r will help us recognise root so that we can initialise root with 0\\n        int r=-1;\\n        calc(root,r);\\n    }\\n    \\n    bool find(int target) {\\n        //since we don\\'t have root in this func hence we used map to map all the values of node and now we will just check if target is there in the tree or not\\n       if(m.find(target)!=m.end())\\n           return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```   \\n//this will store values of all the nodes\\n    map<int,int>m;\\n    \\n    void calc(TreeNode* root,int &r)\\n    {\\n        //if not root then simply return\\n        if(!root)\\n            return;\\n        //if it is a root then make it 0\\n        if(r==-1)\\n        {\\n            m[0]++;\\n            root->val=0;\\n            //change r so that no other node gets value 0\\n            r=10;\\n        }\\n        //if left child exists then update it\\'s value\\n        if(root->left)\\n        {\\n             root->left->val=2*root->val+1;\\n            //don\\'t forget to map the value\\n            m[root->left->val]++;\\n        }\\n        //if right child exists then update it\\'s value\\n        if(root->right)\\n        {\\n            root->right->val=2*root->val+2;\\n            //don\\'t forget to map the value\\n            m[root->right->val]++;\\n        }\\n        //recursively do the same with other nodes\\n        calc(root->left,r);\\n        calc(root->right,r);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        //this r will help us recognise root so that we can initialise root with 0\\n        int r=-1;\\n        calc(root,r);\\n    }\\n    \\n    bool find(int target) {\\n        //since we don\\'t have root in this func hence we used map to map all the values of node and now we will just check if target is there in the tree or not\\n       if(m.find(target)!=m.end())\\n           return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2421082,
                "title": "c-simple-and-very-easy-to-understand",
                "content": "Do upvote , if you find this helpful.\\n```\\n\\nunordered_set<int>s;\\n    void contaminate(TreeNode *root)\\n    {\\n        if(!root) return;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*root->val)+1;\\n            s.emplace(root->left->val);\\n        }\\n        contaminate(root->left);\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*root->val)+2;\\n            s.emplace(root->right->val);\\n        }\\n        contaminate(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.emplace(0);\\n        contaminate(root);\\n    }\\n    \\n    bool find(int target) {\\n        return s.count(target);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\n\\nunordered_set<int>s;\\n    void contaminate(TreeNode *root)\\n    {\\n        if(!root) return;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*root->val)+1;\\n            s.emplace(root->left->val);\\n        }\\n        contaminate(root->left);\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*root->val)+2;\\n            s.emplace(root->right->val);\\n        }\\n        contaminate(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.emplace(0);\\n        contaminate(root);\\n    }\\n    \\n    bool find(int target) {\\n        return s.count(target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2323971,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dfs-hashset",
                "content": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class FindElements {\\n    private readonly HashSet<int> _values = new ();\\n    \\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        Recover(root);\\n    }\\n    \\n    public bool Find(int target) => this._values.Contains(target);\\n    \\n    private void Recover(TreeNode node) {\\n        if (node != null) {\\n            this._values.Add(node.val);\\n            if (node.left != null) { node.left.val = node.val * 2 + 1; this.Recover(node.left); }\\n            if (node.right != null) { node.right.val = node.val * 2 + 2; this.Recover(node.right); }\\n        }\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * bool param_1 = obj.Find(target);\\n */\\n ```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class FindElements {\\n    private readonly HashSet<int> _values = new ();\\n    \\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        Recover(root);\\n    }\\n    \\n    public bool Find(int target) => this._values.Contains(target);\\n    \\n    private void Recover(TreeNode node) {\\n        if (node != null) {\\n            this._values.Add(node.val);\\n            if (node.left != null) { node.left.val = node.val * 2 + 1; this.Recover(node.left); }\\n            if (node.right != null) { node.right.val = node.val * 2 + 2; this.Recover(node.right); }\\n        }\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * bool param_1 = obj.Find(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2317652,
                "title": "c-binarytree-traversal-simple-logic",
                "content": "![image](https://assets.leetcode.com/users/images/8bdb09f3-956f-429a-8de1-214e5e31cff0_1658493827.5027375.png)\\n\\n**n==No. of Nodes\\nFindElements Operation T->O(n)\\nFind Opeartion T->O(n)**\\n\\n\\tclass FindElements {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* r;\\n\\t\\t\\tvoid recover(TreeNode* curr,int x){\\n\\t\\t\\t\\tif(!curr)return ;\\n\\t\\t\\t\\tcurr->val=x;\\n\\t\\t\\t\\trecover(curr->left,2*x+1);\\n\\t\\t\\t\\trecover(curr->right,2*x+2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool f(TreeNode* curr,int target){\\n\\t\\t\\t\\tif(!curr)return false;\\n\\t\\t\\t\\tif(curr->val==target)return true;\\n\\t\\t\\t\\treturn f(curr->left,target) || f(curr->right,target);\\n\\t\\t\\t}\\n\\n\\t\\t\\tFindElements(TreeNode* root) {\\n\\t\\t\\t\\tr=root;\\n\\t\\t\\t\\trecover(root,0);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool find(int target) {\\n\\t\\t\\t\\treturn f(r,target);\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/8bdb09f3-956f-429a-8de1-214e5e31cff0_1658493827.5027375.png)\\n\\n**n==No. of Nodes\\nFindElements Operation T->O(n)\\nFind Opeartion T->O(n)**\\n\\n\\tclass FindElements {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* r;\\n\\t\\t\\tvoid recover(TreeNode* curr,int x){\\n\\t\\t\\t\\tif(!curr)return ;\\n\\t\\t\\t\\tcurr->val=x;\\n\\t\\t\\t\\trecover(curr->left,2*x+1);\\n\\t\\t\\t\\trecover(curr->right,2*x+2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool f(TreeNode* curr,int target){\\n\\t\\t\\t\\tif(!curr)return false;\\n\\t\\t\\t\\tif(curr->val==target)return true;\\n\\t\\t\\t\\treturn f(curr->left,target) || f(curr->right,target);\\n\\t\\t\\t}\\n\\n\\t\\t\\tFindElements(TreeNode* root) {\\n\\t\\t\\t\\tr=root;\\n\\t\\t\\t\\trecover(root,0);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool find(int target) {\\n\\t\\t\\t\\treturn f(r,target);\\n\\t\\t\\t}\\n\\t\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2307892,
                "title": "c-dfs-hash-set-time-o-n-space-o-n",
                "content": "DFS solution\\n* the constructor, perform DFS traversal on the tree and insert values into a hash set if the nodes exist\\n* find() searchs the target from the hash set in O(1) time\\n```\\n// time: O(n) for constructor, O(1) for find()\\n// space: O(n)\\n\\nclass FindElements {\\npublic:\\n  FindElements(TreeNode* root) {\\n    traverse(root, 0);\\n  }\\n  \\n  bool find(int target) {\\n    return valueSet.count(target);\\n  }\\n  \\nprivate:\\n  unordered_set<int> valueSet;\\n  \\n  void traverse(TreeNode* node, int val) {\\n    if (!node)\\n      return;\\n    \\n    valueSet.insert(val);\\n    \\n    traverse(node->left, val * 2 + 1);\\n    traverse(node->right, val * 2 + 2);\\n  }\\n};\\n```\\n\\nThanks for watching : )",
                "solutionTags": [],
                "code": "```\\n// time: O(n) for constructor, O(1) for find()\\n// space: O(n)\\n\\nclass FindElements {\\npublic:\\n  FindElements(TreeNode* root) {\\n    traverse(root, 0);\\n  }\\n  \\n  bool find(int target) {\\n    return valueSet.count(target);\\n  }\\n  \\nprivate:\\n  unordered_set<int> valueSet;\\n  \\n  void traverse(TreeNode* node, int val) {\\n    if (!node)\\n      return;\\n    \\n    valueSet.insert(val);\\n    \\n    traverse(node->left, val * 2 + 1);\\n    traverse(node->right, val * 2 + 2);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290791,
                "title": "go-with-map",
                "content": "```\\ntype FindElements struct {\\n    m map[int]struct{}\\n}\\n\\nfunc Constructor(root *TreeNode) FindElements {\\n    m := make(map[int]struct{})\\n    \\n    var recoverTree func(*TreeNode, int)\\n    recoverTree = func(root *TreeNode, val int)  {\\n        if root == nil {\\n            return\\n        }\\n        \\n        m[val] = struct{}{}\\n        \\n        recoverTree(root.Left, 2*val+1)\\n        recoverTree(root.Right, 2*val+2)\\n    }\\n    \\n    recoverTree(root, 0)\\n    \\n    return FindElements {\\n        m: m,\\n    }\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    if _, ok := this.m[target]; ok {\\n        return true\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\ntype FindElements struct {\\n    m map[int]struct{}\\n}\\n\\nfunc Constructor(root *TreeNode) FindElements {\\n    m := make(map[int]struct{})\\n    \\n    var recoverTree func(*TreeNode, int)\\n    recoverTree = func(root *TreeNode, val int)  {\\n        if root == nil {\\n            return\\n        }\\n        \\n        m[val] = struct{}{}\\n        \\n        recoverTree(root.Left, 2*val+1)\\n        recoverTree(root.Right, 2*val+2)\\n    }\\n    \\n    recoverTree(root, 0)\\n    \\n    return FindElements {\\n        m: m,\\n    }\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    if _, ok := this.m[target]; ok {\\n        return true\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2099200,
                "title": "golang",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\ntype FindElements struct {\\n    set map[int]bool\\n}\\n\\nfunc (this *FindElements)constructTree(root *TreeNode, x int) {\\n    if root==nil {\\n        return\\n    }\\n    root.Val=x\\n    this.set[x]=true \\n    this.constructTree(root.Left, (2*x)+1)\\n    this.constructTree(root.Right, (2*x)+2)\\n}\\nfunc Constructor(root *TreeNode) FindElements {\\n    m:=map[int]bool{}\\n    \\n    this:=FindElements{}\\n    this.set=m\\n    this.constructTree(root, 0)\\n    return this\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    return this.set[target];\\n}\\n\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * obj := Constructor(root);\\n * param_1 := obj.Find(target);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Design",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\ntype FindElements struct {\\n    set map[int]bool\\n}\\n\\nfunc (this *FindElements)constructTree(root *TreeNode, x int) {\\n    if root==nil {\\n        return\\n    }\\n    root.Val=x\\n    this.set[x]=true \\n    this.constructTree(root.Left, (2*x)+1)\\n    this.constructTree(root.Right, (2*x)+2)\\n}\\nfunc Constructor(root *TreeNode) FindElements {\\n    m:=map[int]bool{}\\n    \\n    this:=FindElements{}\\n    this.set=m\\n    this.constructTree(root, 0)\\n    return this\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    return this.set[target];\\n}\\n\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * obj := Constructor(root);\\n * param_1 := obj.Find(target);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060336,
                "title": "c-solution-bfs",
                "content": "```\\n map<int,int>mp;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n           int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                mp[temp->val]++;\\n                if(temp->left)\\n                {\\n                    temp->left->val=(temp->val*2+1);\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    temp->right->val=(temp->val*2+2);\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)!=mp.end())\\n            return true;\\n        return false;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n map<int,int>mp;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n           int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                mp[temp->val]++;\\n                if(temp->left)\\n                {\\n                    temp->left->val=(temp->val*2+1);\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    temp->right->val=(temp->val*2+2);\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)!=mp.end())\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2038820,
                "title": "java-dfs-binartysearch-log-n-space-time-easy-to-understand-with-comments",
                "content": "The key idea in search for any value X if (X-1)%2==0 it would be on left branch of a node else it would be on a right branch of a node. Now we are storing directions in a stack to find if node value exists or not in the tree. \\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    \\n    TreeNode rootref;\\n    public FindElements(TreeNode root) {\\n        rootref=root; // Assigining root to reference node which can be used later on\\n        root.val=0;\\n        recover(root.left,root.val,0);\\n        recover(root.right,root.val,1);\\n        //0 indicates left child,1 indicates right child\\n    }\\n    public void recover(TreeNode node,int parent,int dir)\\n    {\\n        if(node==null)\\n            return;\\n        if(dir==1)\\n        {\\n            node.val=parent*2+2; //Assigning value for right child\\n        }\\n        else\\n        {\\n            node.val=parent*2+1; //Assigning value for left child\\n        }\\n        recover(node.left,node.val,0);\\n        recover(node.right,node.val,1);\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        Stack<Integer> direction=new Stack<Integer>();\\n        //Stack to store direction in which we need to traverse to find the element (0 left,1 right)\\n        while(target!=0)\\n        {\\n            if((target-1)%2==0)\\n            {\\n                target=(target-1)/2;\\n                direction.add(0);\\n            }\\n            else\\n            {\\n                target=(target-2)/2;\\n                direction.add(1);\\n            }\\n            \\n            //If number-1 is divisible by 2 it would be on left side else it would be on right side\\n        }\\n        TreeNode node=rootref;\\n        //Maximum size of stack is height of binary tree\\n        while(!direction.isEmpty())\\n        {\\n            int dir=direction.pop(); //Popping entries from stack\\n            if(dir==1)\\n            {\\n                //Checking if there are nodes in right subtree.\\n                if(node.right!=null)\\n                {\\n                    node=node.right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                //Checking if there are nodes in left subtree.\\n                if(node.left!=null)\\n                {\\n                    node=node.left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    \\n    TreeNode rootref;\\n    public FindElements(TreeNode root) {\\n        rootref=root; // Assigining root to reference node which can be used later on\\n        root.val=0;\\n        recover(root.left,root.val,0);\\n        recover(root.right,root.val,1);\\n        //0 indicates left child,1 indicates right child\\n    }\\n    public void recover(TreeNode node,int parent,int dir)\\n    {\\n        if(node==null)\\n            return;\\n        if(dir==1)\\n        {\\n            node.val=parent*2+2; //Assigning value for right child\\n        }\\n        else\\n        {\\n            node.val=parent*2+1; //Assigning value for left child\\n        }\\n        recover(node.left,node.val,0);\\n        recover(node.right,node.val,1);\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        Stack<Integer> direction=new Stack<Integer>();\\n        //Stack to store direction in which we need to traverse to find the element (0 left,1 right)\\n        while(target!=0)\\n        {\\n            if((target-1)%2==0)\\n            {\\n                target=(target-1)/2;\\n                direction.add(0);\\n            }\\n            else\\n            {\\n                target=(target-2)/2;\\n                direction.add(1);\\n            }\\n            \\n            //If number-1 is divisible by 2 it would be on left side else it would be on right side\\n        }\\n        TreeNode node=rootref;\\n        //Maximum size of stack is height of binary tree\\n        while(!direction.isEmpty())\\n        {\\n            int dir=direction.pop(); //Popping entries from stack\\n            if(dir==1)\\n            {\\n                //Checking if there are nodes in right subtree.\\n                if(node.right!=null)\\n                {\\n                    node=node.right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                //Checking if there are nodes in left subtree.\\n                if(node.left!=null)\\n                {\\n                    node=node.left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1872558,
                "title": "c-short-and-simple-hashtable",
                "content": "\\nfirst try to recover the tree using preorder traversal \\nduring the traversal, store the values in hash table for fast searching\\n\\n```\\nclass FindElements \\n{\\n    TreeNode *root;\\n    unordered_set<int> set;\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        \\n        this -> root = root;\\n        \\n        recoverTree(this -> root, 0);\\n    }\\n    \\n    void recoverTree(TreeNode *itr, int val){\\n        \\n        if(!itr)\\n            return ;\\n        \\n        itr -> val = val;\\n        set.insert(val);\\n        \\n        recoverTree(itr -> left, val*2 + 1);\\n        recoverTree(itr -> right, val*2 + 2);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        return set.count(target);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass FindElements \\n{\\n    TreeNode *root;\\n    unordered_set<int> set;\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        \\n        this -> root = root;\\n        \\n        recoverTree(this -> root, 0);\\n    }\\n    \\n    void recoverTree(TreeNode *itr, int val){\\n        \\n        if(!itr)\\n            return ;\\n        \\n        itr -> val = val;\\n        set.insert(val);\\n        \\n        recoverTree(itr -> left, val*2 + 1);\\n        recoverTree(itr -> right, val*2 + 2);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        return set.count(target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846192,
                "title": "java-code-2-ways-to-solve",
                "content": "```\\n\\npublic class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while (!q.isEmpty()){\\n\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                }\\n\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                }\\n                q.poll();\\n            }\\n\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return helper(root, target);\\n       \\n    }\\n    public boolean helper(TreeNode rootRec, int target){\\n        if (rootRec == null) return false;\\n        \\n        if (rootRec.val == target) return true;\\n        \\n        boolean bool1 =helper(rootRec.left, target);\\n        if (bool1) return true;\\n        boolean bool2 = helper(rootRec.right, target);\\n        if (bool2) return true;\\n        \\n        return false;\\n    }\\n}\\n\\n\\n\\n\\n```\\n\\n\\n```\\nclass FindElements {\\n    TreeNode root;\\n    HashSet<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        root.val = 0;\\n        set.add(0);\\n        while (!q.isEmpty()){\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                    set.add(temp.left.val);\\n                }\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                    set.add(temp.right.val);\\n                }\\n                q.poll();\\n            }\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return set.contains(target);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\npublic class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while (!q.isEmpty()){\\n\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                }\\n\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                }\\n                q.poll();\\n            }\\n\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return helper(root, target);\\n       \\n    }\\n    public boolean helper(TreeNode rootRec, int target){\\n        if (rootRec == null) return false;\\n        \\n        if (rootRec.val == target) return true;\\n        \\n        boolean bool1 =helper(rootRec.left, target);\\n        if (bool1) return true;\\n        boolean bool2 = helper(rootRec.right, target);\\n        if (bool2) return true;\\n        \\n        return false;\\n    }\\n}\\n\\n\\n\\n\\n```\n```\\nclass FindElements {\\n    TreeNode root;\\n    HashSet<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        root.val = 0;\\n        set.add(0);\\n        while (!q.isEmpty()){\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                    set.add(temp.left.val);\\n                }\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                    set.add(temp.right.val);\\n                }\\n                q.poll();\\n            }\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return set.contains(target);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780860,
                "title": "bfs-based-solution-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode* treeNode;\\n    unordered_map<int,bool> valueMap;\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> bfsQ;\\n        TreeNode *temp;\\n        bfsQ.push(root);\\n        root->val = 0;\\n        valueMap[root->val] = true;\\n        \\n        do {\\n            \\n            temp = bfsQ.front();\\n            if(temp->left != NULL) {\\n                \\n                bfsQ.push(temp->left);\\n                temp->left->val = bfsQ.front()->val * 2 + 1;\\n                valueMap[temp->left->val] = true;\\n                \\n            }\\n            \\n            if(temp->right != NULL) {\\n                \\n                bfsQ.push(temp->right);\\n                temp->right->val = bfsQ.front()->val * 2 + 2;\\n                valueMap[temp->right->val] = true;\\n            }\\n            \\n            bfsQ.pop();\\n            \\n        }while(!bfsQ.empty());\\n        \\n        \\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        treeNode = root;\\n        recoverTree(treeNode);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        if(valueMap.find(target) != valueMap.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode* treeNode;\\n    unordered_map<int,bool> valueMap;\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> bfsQ;\\n        TreeNode *temp;\\n        bfsQ.push(root);\\n        root->val = 0;\\n        valueMap[root->val] = true;\\n        \\n        do {\\n            \\n            temp = bfsQ.front();\\n            if(temp->left != NULL) {\\n                \\n                bfsQ.push(temp->left);\\n                temp->left->val = bfsQ.front()->val * 2 + 1;\\n                valueMap[temp->left->val] = true;\\n                \\n            }\\n            \\n            if(temp->right != NULL) {\\n                \\n                bfsQ.push(temp->right);\\n                temp->right->val = bfsQ.front()->val * 2 + 2;\\n                valueMap[temp->right->val] = true;\\n            }\\n            \\n            bfsQ.pop();\\n            \\n        }while(!bfsQ.empty());\\n        \\n        \\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        treeNode = root;\\n        recoverTree(treeNode);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        if(valueMap.find(target) != valueMap.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777486,
                "title": "c-dfs-clean-and-concise",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode *troot;\\n    map<int,bool>ma;\\n    void dfs(TreeNode *root,int val)\\n    {\\n        if(!root)\\n            return;\\n        root->val=val;\\n        ma[val]=1;\\n        dfs(root->left,val*2+1);\\n        dfs(root->right,val*2+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        \\n       return ma[target];\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n ```\\n \\n**Pls upvote if you found helpful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode *troot;\\n    map<int,bool>ma;\\n    void dfs(TreeNode *root,int val)\\n    {\\n        if(!root)\\n            return;\\n        root->val=val;\\n        ma[val]=1;\\n        dfs(root->left,val*2+1);\\n        dfs(root->right,val*2+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        \\n       return ma[target];\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1736298,
                "title": "c-easy-recursive-solution",
                "content": "Solution is straight forword we only recursively check current node value greater than target value if we find target value we will return true otherwise false.\\n```\\n\\nTreeNode * head;\\n    FindElements(TreeNode* root) {\\n        head = new TreeNode();\\n        head = root;\\n    }\\n    bool help(TreeNode * root, int val, int target)\\n    {\\n        if(root == NULL)\\n            return false;\\n        if(val == target )\\n            return true;\\n        return help(root->left , 2*val+1 , target) || help(root->right , 2*val+2 , target);\\n    }\\n\\tbool find(int target) {\\n        return help(head, 0,target);\\n    }\\n```\\n\\t\\nIf you have any suggestion comment.Thank you for your suggestion.",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nTreeNode * head;\\n    FindElements(TreeNode* root) {\\n        head = new TreeNode();\\n        head = root;\\n    }\\n    bool help(TreeNode * root, int val, int target)\\n    {\\n        if(root == NULL)\\n            return false;\\n        if(val == target )\\n            return true;\\n        return help(root->left , 2*val+1 , target) || help(root->right , 2*val+2 , target);\\n    }\\n\\tbool find(int target) {\\n        return help(head, 0,target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690280,
                "title": "c-easy-to-understand-simple-implementation",
                "content": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> st;\\npublic:\\n    void recover(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        return;\\n        root->val=x;\\n        st.insert(x);\\n        recover(root->left,2*x+1);\\n        recover(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        recover(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return (st.find(target)!=st.end());\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> st;\\npublic:\\n    void recover(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        return;\\n        root->val=x;\\n        st.insert(x);\\n        recover(root->left,2*x+1);\\n        recover(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        recover(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return (st.find(target)!=st.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660470,
                "title": "c-solution-using-set-to-find-element-in-o-1",
                "content": "```\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void store(TreeNode *root)\\n    {\\n        if(root!=NULL)\\n        {\\n            s.insert(root->val);\\n            store(root->left);\\n            store(root->right);\\n        }\\n    }\\n    void solve(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+1;\\n            root->left->val=k;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+2;\\n            root->right->val=k;\\n        }\\n        solve(root->left);\\n        solve(root->right);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n        store(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void store(TreeNode *root)\\n    {\\n        if(root!=NULL)\\n        {\\n            s.insert(root->val);\\n            store(root->left);\\n            store(root->right);\\n        }\\n    }\\n    void solve(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+1;\\n            root->left->val=k;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+2;\\n            root->right->val=k;\\n        }\\n        solve(root->left);\\n        solve(root->right);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n        store(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1628305,
                "title": "c-easy-logical-solution-o-log-n-space-pruning-no-hashmap-or-set",
                "content": "```\\nclass FindElements {\\npublic:\\n    \\n    /*\\n        INTUITION\\n        No need to create / restore the tree (although it can be easily done, it is just in the form of a heap (left is 2i + 1, right is 2i + 2)).\\n        For the find operation, we can trace back the path to the root node from the target node.\\n        1. We know for sure that an odd node value will be in the left subtree of its parent, and an even node value will be in the right subtree of its parent.\\n        2. So we push \\'l\\' or \\'r\\' (left, or right) on the stack, based on if it is odd or even.\\n        3. Now we need to move to the nodes\\'s parent and see which side it lies on its own parent. To move to the parent node, we can deconstruct the value based on the formula\\n        If parent is i, then left child is 2i + 1, and right child is 2i + 2, so to get the parent of a node, we can use:\\n            parent = (target - 1)/2 for odd nodes\\n            parent = (target - 2)/2 for even nodes,\\n            and repeat steps 1 to 3 till we reach the root (i.e target is 0)\\n        Then we can start from the root and follow the steps from the stack. If we successfully reach the end of the stack without encountering a nullptr, then it means the target exists, but if we encounter a nullptr before executing all the steps from the stack, the target node does not exist.\\n        \\n        \\n        Optimisation: Maybe by a recursive approach, we can also cache which nodes exist to improve runtime for a large number of queries\\n    */\\n    \\n    TreeNode* tree;\\n    FindElements(TreeNode* root) {\\n        tree = root;\\n    }\\n    \\n    bool find(int target) {\\n        if(target == 0) return true;\\n        stack<char> steps;\\n        while(target > 0) {\\n            if(target % 2 == 1) {\\n                steps.push(\\'l\\');\\n                target = (target - 1)/2;\\n            } else {\\n                steps.push(\\'r\\');\\n                target = (target - 2)/2;\\n            }\\n        }\\n        TreeNode* curr = tree;\\n        while(curr != nullptr) {\\n            char step = steps.top();\\n            steps.pop();\\n            if(step == \\'l\\') {\\n                curr = curr->left;\\n            } else {\\n                curr = curr->right;\\n            }\\n            if(steps.empty() && curr != nullptr) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nPlease upvote if it helped. Happy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    \\n    /*\\n        INTUITION\\n        No need to create / restore the tree (although it can be easily done, it is just in the form of a heap (left is 2i + 1, right is 2i + 2)).\\n        For the find operation, we can trace back the path to the root node from the target node.\\n        1. We know for sure that an odd node value will be in the left subtree of its parent, and an even node value will be in the right subtree of its parent.\\n        2. So we push \\'l\\' or \\'r\\' (left, or right) on the stack, based on if it is odd or even.\\n        3. Now we need to move to the nodes\\'s parent and see which side it lies on its own parent. To move to the parent node, we can deconstruct the value based on the formula\\n        If parent is i, then left child is 2i + 1, and right child is 2i + 2, so to get the parent of a node, we can use:\\n            parent = (target - 1)/2 for odd nodes\\n            parent = (target - 2)/2 for even nodes,\\n            and repeat steps 1 to 3 till we reach the root (i.e target is 0)\\n        Then we can start from the root and follow the steps from the stack. If we successfully reach the end of the stack without encountering a nullptr, then it means the target exists, but if we encounter a nullptr before executing all the steps from the stack, the target node does not exist.\\n        \\n        \\n        Optimisation: Maybe by a recursive approach, we can also cache which nodes exist to improve runtime for a large number of queries\\n    */\\n    \\n    TreeNode* tree;\\n    FindElements(TreeNode* root) {\\n        tree = root;\\n    }\\n    \\n    bool find(int target) {\\n        if(target == 0) return true;\\n        stack<char> steps;\\n        while(target > 0) {\\n            if(target % 2 == 1) {\\n                steps.push(\\'l\\');\\n                target = (target - 1)/2;\\n            } else {\\n                steps.push(\\'r\\');\\n                target = (target - 2)/2;\\n            }\\n        }\\n        TreeNode* curr = tree;\\n        while(curr != nullptr) {\\n            char step = steps.top();\\n            steps.pop();\\n            if(step == \\'l\\') {\\n                curr = curr->left;\\n            } else {\\n                curr = curr->right;\\n            }\\n            if(steps.empty() && curr != nullptr) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482832,
                "title": "c-dfs-using-hash-inorder",
                "content": "**\\nunordered_map<int,int>mpp;\\n    void solve(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        else{\\n            root->val=i;\\n        }\\n        solve(root->left,2*i+1);\\n        mpp[root->val]=1;\\n        solve(root->right,2*i+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        solve(root,0);\\n    }\\n    bool find(int target) {\\n        \\n        if(mpp.find(target)!=mpp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n**",
                "solutionTags": [],
                "code": "**\\nunordered_map<int,int>mpp;\\n    void solve(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        else{\\n            root->val=i;\\n        }\\n        solve(root->left,2*i+1);\\n        mpp[root->val]=1;\\n        solve(root->right,2*i+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        solve(root,0);\\n    }\\n    bool find(int target) {\\n        \\n        if(mpp.find(target)!=mpp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n**",
                "codeTag": "Unknown"
            },
            {
                "id": 1424594,
                "title": "ac-java-solution-find-elements-in-a-contaminated-binary-tree-beats-84",
                "content": "Strictly by the definition, I contaminate and reconstruct the tree, all the while adding the keys to a set. \\n\\nThe latter makes the initial tree building O(n), but the find operation O(1), since we can look the keys up directly from the set.\\n\\nI\\'m sure I can make this faster by combining \\'contaminate\\' and \\'reconstruct\\', but It\\'s late now and I\\'m tired :)\\n\\n```\\nclass FindElements {\\n\\n    HashSet<Integer> keys;\\n    \\n    public FindElements(TreeNode root) {\\n        keys = new HashSet<Integer>();\\n        contaminate(root);\\n        root.val = 0;\\n        reconstruct(root);\\n    }\\n    \\n    public boolean find(int target) {\\n       return keys.contains(target);\\n    }\\n    \\n    private void contaminate(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        root.val = -1;\\n        contaminate(root.left);\\n        contaminate(root.right);\\n    }\\n    \\n    public void reconstruct(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        keys.add(root.val);\\n        \\n        if(root.left != null) {\\n            root.left.val = 2*root.val + 1;\\n            \\n        }\\n        \\n        if(root.right != null) {\\n            root.right.val = 2*root.val + 2;\\n        }\\n        \\n        reconstruct(root.left);\\n        reconstruct(root.right);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass FindElements {\\n\\n    HashSet<Integer> keys;\\n    \\n    public FindElements(TreeNode root) {\\n        keys = new HashSet<Integer>();\\n        contaminate(root);\\n        root.val = 0;\\n        reconstruct(root);\\n    }\\n    \\n    public boolean find(int target) {\\n       return keys.contains(target);\\n    }\\n    \\n    private void contaminate(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        root.val = -1;\\n        contaminate(root.left);\\n        contaminate(root.right);\\n    }\\n    \\n    public void reconstruct(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        keys.add(root.val);\\n        \\n        if(root.left != null) {\\n            root.left.val = 2*root.val + 1;\\n            \\n        }\\n        \\n        if(root.right != null) {\\n            root.right.val = 2*root.val + 2;\\n        }\\n        \\n        reconstruct(root.left);\\n        reconstruct(root.right);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338182,
                "title": "java-dfs-hashset-beats-98",
                "content": "class FindElements {\\n    Set<Integer> elements = new HashSet<>();\\n    \\n    private void dfs(TreeNode root){\\n        if(root == null){return;}\\n        elements.add(root.val);\\n        if(root.left != null){\\n            root.left.val = root.val * 2 + 1;    \\n        }\\n        if(root.right != null){\\n            root.right.val = root.val * 2 + 2;\\n        }\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        dfs(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return elements.contains(target);\\n    }\\n}\\n\\nPlease upvote if you find it useful!!!",
                "solutionTags": [],
                "code": "class FindElements {\\n    Set<Integer> elements = new HashSet<>();\\n    \\n    private void dfs(TreeNode root){\\n        if(root == null){return;}\\n        elements.add(root.val);\\n        if(root.left != null){\\n            root.left.val = root.val * 2 + 1;    \\n        }\\n        if(root.right != null){\\n            root.right.val = root.val * 2 + 2;\\n        }\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        dfs(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return elements.contains(target);\\n    }\\n}\\n\\nPlease upvote if you find it useful!!!",
                "codeTag": "Java"
            },
            {
                "id": 1272382,
                "title": "c-simple-easy-to-understand-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> ust;\\n    void recoverIt(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        ust.insert(root->val);\\n        if(root->left!=NULL)\\n            root->left->val=2*(root->val)+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*(root->val)+2;\\n        recoverIt(root->left);\\n        recoverIt(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        recoverIt(root);\\n    }\\n    bool find(int target) {\\n        return(ust.find(target)!=ust.end());\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> ust;\\n    void recoverIt(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        ust.insert(root->val);\\n        if(root->left!=NULL)\\n            root->left->val=2*(root->val)+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*(root->val)+2;\\n        recoverIt(root->left);\\n        recoverIt(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        recoverIt(root);\\n    }\\n    bool find(int target) {\\n        return(ust.find(target)!=ust.end());\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244162,
                "title": "c-hashmap",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* root) \\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            while(!q.empty())\\n            {\\n                int size = q.size();\\n                for(int i=0; i<size; i++)\\n                {\\n                    TreeNode* temp = q.front(); q.pop();\\n                    int x = temp->val;\\n                    mp[x]++;\\n                    if(temp->left)\\n                    {\\n                        temp->left->val = 2 * x + 1;\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        temp->right->val = 2 * x + 2;\\n                        q.push(temp->right);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) \\n    {\\n        return (mp.find(target) != mp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* root) \\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            while(!q.empty())\\n            {\\n                int size = q.size();\\n                for(int i=0; i<size; i++)\\n                {\\n                    TreeNode* temp = q.front(); q.pop();\\n                    int x = temp->val;\\n                    mp[x]++;\\n                    if(temp->left)\\n                    {\\n                        temp->left->val = 2 * x + 1;\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        temp->right->val = 2 * x + 2;\\n                        q.push(temp->right);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) \\n    {\\n        return (mp.find(target) != mp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233405,
                "title": "c-98-8-faster-very-simple-and-easy-to-understand-using-dfs",
                "content": "```\\n unordered_map<int,bool>m;\\n    void helper(TreeNode* root, int v){\\n        if(!root)return;\\n        helper(root->left, 2*v+1);\\n        m[v]=true;\\n        helper(root->right, 2*v+2);\\n    }\\n    FindElements(TreeNode* root, int v=0) {\\n        helper(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return m[target];\\n    }\\n```\\n**if you find it helpful plz upvote**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n unordered_map<int,bool>m;\\n    void helper(TreeNode* root, int v){\\n        if(!root)return;\\n        helper(root->left, 2*v+1);\\n        m[v]=true;\\n        helper(root->right, 2*v+2);\\n    }\\n    FindElements(TreeNode* root, int v=0) {\\n        helper(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return m[target];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229967,
                "title": "simple-recursive-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    void helper(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root->left != NULL)\\n            root->left->val = 2*root->val + 1;\\n        if(root->right != NULL)\\n            root->right->val = 2*root->val + 2;\\n        helper(root->left);\\n        helper(root->right);\\n        \\n    }\\n    TreeNode* start;\\n    FindElements(TreeNode* root) {\\n         root->val = 0;\\n        start = root;\\n        helper(start);\\n    }\\n       bool helper1(TreeNode* root,int target)\\n       {\\n           if(root == NULL)\\n               return false;\\n           if(root->val == target)\\n               return true;\\n           return helper1(root->left,target) or helper1(root->right,target);\\n               \\n               \\n       }\\n    bool find(int target) {\\n        return helper1(start,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    void helper(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root->left != NULL)\\n            root->left->val = 2*root->val + 1;\\n        if(root->right != NULL)\\n            root->right->val = 2*root->val + 2;\\n        helper(root->left);\\n        helper(root->right);\\n        \\n    }\\n    TreeNode* start;\\n    FindElements(TreeNode* root) {\\n         root->val = 0;\\n        start = root;\\n        helper(start);\\n    }\\n       bool helper1(TreeNode* root,int target)\\n       {\\n           if(root == NULL)\\n               return false;\\n           if(root->val == target)\\n               return true;\\n           return helper1(root->left,target) or helper1(root->right,target);\\n               \\n               \\n       }\\n    bool find(int target) {\\n        return helper1(start,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228884,
                "title": "c-simple-solution-using-bfs-and-unordered-set",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int>S;\\n    void bfs(TreeNode* root)\\n    {\\n        queue<TreeNode*>Q;\\n        root->val = 0;\\n        S.insert(0);\\n        Q.push(root);\\n        while(Q.size())\\n        {\\n            auto curr = Q.front();\\n            Q.pop();\\n            \\n            if(curr->left)\\n            {\\n                curr->left->val = 2*curr->val + 1;\\n                S.insert(curr->left->val);\\n                Q.push(curr->left);\\n            }\\n            \\n            if(curr->right)\\n            {\\n                curr->right->val = 2*curr->val + 2;\\n                S.insert(curr->right->val);\\n                Q.push(curr->right);\\n            }\\n        }\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        bfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return S.count(target) > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int>S;\\n    void bfs(TreeNode* root)\\n    {\\n        queue<TreeNode*>Q;\\n        root->val = 0;\\n        S.insert(0);\\n        Q.push(root);\\n        while(Q.size())\\n        {\\n            auto curr = Q.front();\\n            Q.pop();\\n            \\n            if(curr->left)\\n            {\\n                curr->left->val = 2*curr->val + 1;\\n                S.insert(curr->left->val);\\n                Q.push(curr->left);\\n            }\\n            \\n            if(curr->right)\\n            {\\n                curr->right->val = 2*curr->val + 2;\\n                S.insert(curr->right->val);\\n                Q.push(curr->right);\\n            }\\n        }\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        bfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return S.count(target) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174605,
                "title": "python3-simple-solution",
                "content": "```\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.res = set()\\n        x = [(root,0)]\\n        while x:\\n            node, value = x.pop(0)\\n            node.val = value\\n            self.res.add(value)\\n            if node.left:\\n                x.append((node.left,(2*value+1)))\\n            if node.right:\\n                x.append((node.right,(2*value+2)))\\n    def find(self, target: int) -> bool:\\n        return target in self.res\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.res = set()\\n        x = [(root,0)]\\n        while x:\\n            node, value = x.pop(0)\\n            node.val = value\\n            self.res.add(value)\\n            if node.left:\\n                x.append((node.left,(2*value+1)))\\n            if node.right:\\n                x.append((node.right,(2*value+2)))\\n    def find(self, target: int) -> bool:\\n        return target in self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137333,
                "title": "java-clean-and-easy-solution",
                "content": "**If you want to do this in O(1) space than you have to write the O(n) code for searching the target in Binary tree which is pretty slow**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   TreeNode nroot;\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n        nroot=root;\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        \\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  find(nroot,target); \\n    }\\n    public boolean find(TreeNode node,int key){\\n      if(node==null) return false;\\n      \\n      if(node.val==key) return true;\\n      boolean l=find(node.left,key);\\n      boolean r=find(node.right,key);\\n      \\n      return l || r;\\n      \\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```\\n**But if you use Map to store the values as key in map you will be doing the search operation in O(1) which will be fast**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    Map<Integer,Boolean> mp=new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        mp.put(node.val,true);\\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  mp.get(target)==null ? false : true; \\n    }\\n    \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   TreeNode nroot;\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n        nroot=root;\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        \\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  find(nroot,target); \\n    }\\n    public boolean find(TreeNode node,int key){\\n      if(node==null) return false;\\n      \\n      if(node.val==key) return true;\\n      boolean l=find(node.left,key);\\n      boolean r=find(node.right,key);\\n      \\n      return l || r;\\n      \\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    Map<Integer,Boolean> mp=new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        mp.put(node.val,true);\\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  mp.get(target)==null ? false : true; \\n    }\\n    \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129234,
                "title": "java-solution-99-faster",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n       if(root.val!=0){\\n           root.val = 0;\\n          \\n       }\\n        \\n       preorder(root);\\n      \\n         \\n       \\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        return false;\\n    }\\n    public void preorder(TreeNode root){\\n         \\n        if(root!=null){\\n            map.put(root.val,true);\\n            if(root.left!=null){\\n                root.left.val = 2*root.val+1;\\n                \\n            }\\n            if(root.right!=null){\\n                root.right.val = 2*root.val+2;\\n                   \\n            }\\n            preorder(root.left);\\n            preorder(root.right);\\n        }\\n        \\n    }\\n   \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n       if(root.val!=0){\\n           root.val = 0;\\n          \\n       }\\n        \\n       preorder(root);\\n      \\n         \\n       \\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        return false;\\n    }\\n    public void preorder(TreeNode root){\\n         \\n        if(root!=null){\\n            map.put(root.val,true);\\n            if(root.left!=null){\\n                root.left.val = 2*root.val+1;\\n                \\n            }\\n            if(root.right!=null){\\n                root.right.val = 2*root.val+2;\\n                   \\n            }\\n            preorder(root.left);\\n            preorder(root.right);\\n        }\\n        \\n    }\\n   \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129172,
                "title": "java-solution-99-faster",
                "content": "```\\nclass FindElements {\\n    HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        recoverTree(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        else return false;\\n    }\\n    public void recoverTree(TreeNode p,int x){\\n        if(p!=null){\\n            p.val = x;\\n            map.put(x,true);\\n            recoverTree(p.left,(2*x)+1);\\n            recoverTree(p.right,(2*x)+2);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        recoverTree(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        else return false;\\n    }\\n    public void recoverTree(TreeNode p,int x){\\n        if(p!=null){\\n            p.val = x;\\n            map.put(x,true);\\n            recoverTree(p.left,(2*x)+1);\\n            recoverTree(p.right,(2*x)+2);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085663,
                "title": "python-iterative-dfs",
                "content": "I think we can use any traversal order to update the node values?\\n```py\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        self.element = set()\\n        root.val = 0\\n        stack = []\\n        while stack or root:\\n            while root:\\n                self.element.add(root.val)\\n                if root.left:\\n                    root.left.val = root.val * 2 + 1\\n                stack.append(root)\\n                root = root.left\\n            \\n            root = stack.pop()\\n            if root.right:\\n                root.right.val = root.val * 2 + 2\\n            root = root.right\\n            \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.element\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        self.element = set()\\n        root.val = 0\\n        stack = []\\n        while stack or root:\\n            while root:\\n                self.element.add(root.val)\\n                if root.left:\\n                    root.left.val = root.val * 2 + 1\\n                stack.append(root)\\n                root = root.left\\n            \\n            root = stack.pop()\\n            if root.right:\\n                root.right.val = root.val * 2 + 2\\n            root = root.right\\n            \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.element\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046251,
                "title": "i-am-not-sure-if-it-s-allowed-to-use-static-but-that-s-how-i-implemented",
                "content": "\\tclass FindElements {\\n    public void findElements_(TreeNode root){\\n        if(root == null) return;\\n        \\n        if(root.val != -1 && root.left != null) root.left.val = 2 * root.val + 1;\\n        if(root.val != -1 && root.right != null) root.right.val = 2 * root.val + 2;\\n        \\n        set.add(root.val);\\n        \\n        findElements_(root.left);\\n        findElements_(root.right);\\n    }\\n    \\n    public HashSet<Integer> set = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        //here i am not worried about null point exception as because root can\\'t be null according to constraints.\\n        root.val = 0;\\n        findElements_(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n     }\\n\\t}\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\tclass FindElements {\\n    public void findElements_(TreeNode root){\\n        if(root == null) return;\\n        \\n        if(root.val != -1 && root.left != null) root.left.val = 2 * root.val + 1;\\n        if(root.val != -1 && root.right != null) root.right.val = 2 * root.val + 2;\\n        \\n        set.add(root.val);\\n        \\n        findElements_(root.left);\\n        findElements_(root.right);\\n    }\\n    \\n    public HashSet<Integer> set = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        //here i am not worried about null point exception as because root can\\'t be null according to constraints.\\n        root.val = 0;\\n        findElements_(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n     }\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1018682,
                "title": "java-better-than-98-of-runtime",
                "content": "```\\nclass FindElements {\\n    Set<Integer> set=new HashSet<>();   //set will store the values to search for later\\n    public FindElements(TreeNode root) {\\n        \\n        helper(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return (set.contains(target));  //if the set contains the target value then return true\\n    }\\n    \\n    private void helper(TreeNode root, int val){    //helper function will assign each node a value based on the                                                           condition given\\n        if(root==null)                              \\n            return;\\n        root.val=val;\\n        set.add(val);                               //adding each node\\'s val into the set\\n        if(root.left!=null)\\n           {\\n            helper(root.left,(2*val)+1); \\n        }\\n        if(root.right!=null)\\n            helper(root.right, (2*val)+2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    Set<Integer> set=new HashSet<>();   //set will store the values to search for later\\n    public FindElements(TreeNode root) {\\n        \\n        helper(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return (set.contains(target));  //if the set contains the target value then return true\\n    }\\n    \\n    private void helper(TreeNode root, int val){    //helper function will assign each node a value based on the                                                           condition given\\n        if(root==null)                              \\n            return;\\n        root.val=val;\\n        set.add(val);                               //adding each node\\'s val into the set\\n        if(root.left!=null)\\n           {\\n            helper(root.left,(2*val)+1); \\n        }\\n        if(root.right!=null)\\n            helper(root.right, (2*val)+2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012706,
                "title": "java-hashset",
                "content": "\\n\\tclass FindElements {\\n\\t\\tHashSet<Integer> set=new HashSet<>();\\n\\n\\t\\tpublic FindElements(TreeNode root) {\\n\\t\\t\\tif(root!=null)\\n\\t\\t\\t\\troot.val=0;\\n\\t\\t\\tcreate(root);\\n\\t\\t}\\n\\n\\t\\tpublic void create(TreeNode root){\\n\\n\\t\\t\\tif(root==null)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tset.add(root.val);\\n\\n\\t\\t\\tif(root.left!=null){\\n\\t\\t\\t\\troot.left.val=root.val*2+1;\\n\\t\\t\\t\\tcreate(root.left);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(root.right!=null){\\n\\t\\t\\t\\troot.right.val=root.val*2+2;\\n\\t\\t\\t\\tcreate(root.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif(set.contains(target))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\tclass FindElements {\\n\\t\\tHashSet<Integer> set=new HashSet<>();\\n\\n\\t\\tpublic FindElements(TreeNode root) {\\n\\t\\t\\tif(root!=null)\\n\\t\\t\\t\\troot.val=0;\\n\\t\\t\\tcreate(root);\\n\\t\\t}\\n\\n\\t\\tpublic void create(TreeNode root){\\n\\n\\t\\t\\tif(root==null)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tset.add(root.val);\\n\\n\\t\\t\\tif(root.left!=null){\\n\\t\\t\\t\\troot.left.val=root.val*2+1;\\n\\t\\t\\t\\tcreate(root.left);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(root.right!=null){\\n\\t\\t\\t\\troot.right.val=root.val*2+2;\\n\\t\\t\\t\\tcreate(root.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif(set.contains(target))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 984755,
                "title": "java-easty-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set;\\n    \\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recoverTree(root, 0);\\n    }\\n    \\n    private void recoverTree(TreeNode root, int val){\\n        if(root == null){\\n            return;\\n        }\\n        \\n        set.add(val);\\n        root.val = val;\\n        recoverTree(root.left, 2*val+1);\\n        recoverTree(root.right, 2*val+2);\\n    }\\n    \\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set;\\n    \\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recoverTree(root, 0);\\n    }\\n    \\n    private void recoverTree(TreeNode root, int val){\\n        if(root == null){\\n            return;\\n        }\\n        \\n        set.add(val);\\n        root.val = val;\\n        recoverTree(root.left, 2*val+1);\\n        recoverTree(root.right, 2*val+2);\\n    }\\n    \\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961877,
                "title": "python-simple-dfs-dict-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.d={}\\n        def helper(root):\\n            if root:\\n                self.d[root.val]=0\\n                if root.left:\\n                    root.left.val = root.val*2 +1 \\n                if root.right:\\n                    root.right.val = root.val*2 +2\\n                helper(root.left)\\n                helper(root.right)\\n        root.val = 0\\n        helper(root)\\n    def find(self, target: int) -> bool:\\n        return target in self.d\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.d={}\\n        def helper(root):\\n            if root:\\n                self.d[root.val]=0\\n                if root.left:\\n                    root.left.val = root.val*2 +1 \\n                if root.right:\\n                    root.right.val = root.val*2 +2\\n                helper(root.left)\\n                helper(root.right)\\n        root.val = 0\\n        helper(root)\\n    def find(self, target: int) -> bool:\\n        return target in self.d\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887582,
                "title": "java-dfs-96-faster",
                "content": "kindly do Upvote if you like the solution.\\n\\nclass FindElements {\\n\\n    private Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set=new HashSet<>();\\n        root.val=0;\\n        set.add(root.val);\\n        recoverTree(root);\\n    }\\n    \\n    void recoverTree(TreeNode root){\\n        if(root ==null)\\n            return;\\n       if(root.left !=null){\\n           int leftVal=root.val *2 +1;\\n           root.left.val=leftVal;\\n           set.add(leftVal);  \\n        }\\n        if(root.right !=null){\\n           int rightVal=root.val *2 +2;\\n           root.right.val=rightVal;\\n           set.add(rightVal);  \\n       }   \\n        recoverTree(root.left);\\n        recoverTree(root.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}",
                "solutionTags": [],
                "code": "kindly do Upvote if you like the solution.\\n\\nclass FindElements {\\n\\n    private Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set=new HashSet<>();\\n        root.val=0;\\n        set.add(root.val);\\n        recoverTree(root);\\n    }\\n    \\n    void recoverTree(TreeNode root){\\n        if(root ==null)\\n            return;\\n       if(root.left !=null){\\n           int leftVal=root.val *2 +1;\\n           root.left.val=leftVal;\\n           set.add(leftVal);  \\n        }\\n        if(root.right !=null){\\n           int rightVal=root.val *2 +2;\\n           root.right.val=rightVal;\\n           set.add(rightVal);  \\n       }   \\n        recoverTree(root.left);\\n        recoverTree(root.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 884358,
                "title": "java-simple-one-pass-solution",
                "content": "We don\\'t need to technically recover the tree. Just collect all the values the tree is supposed to have and perform a O(1) lookup.\\n\\n```\\nclass FindElements {\\n\\n    Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recover(root, 0, set);\\n    }\\n    \\n    private void recover(TreeNode root, int val, Set<Integer> set) {\\n        if (root==null)\\n            return;\\n        set.add(val);\\n        recover(root.left, 2 * val + 1, set);\\n        recover(root.right, 2 * val + 2, set);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n\\n    Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recover(root, 0, set);\\n    }\\n    \\n    private void recover(TreeNode root, int val, Set<Integer> set) {\\n        if (root==null)\\n            return;\\n        set.add(val);\\n        recover(root.left, 2 * val + 1, set);\\n        recover(root.right, 2 * val + 2, set);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812443,
                "title": "c-easy-set-recursion",
                "content": "```\\nclass FindElements {\\npublic:\\n    set<int>st;\\n    void finding(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(root->val!=i)\\n        {\\n            root->val=i;\\n            st.insert(i);\\n        }\\n        finding(root->left,2*i+1);\\n        finding(root->right,2*i+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        int i=0;\\n         finding(root,i);\\n       }\\n    \\n    bool find(int target) {\\n        if(st.find(target)!=st.end())\\n            return true;\\n        else\\n            return false;\\n      }\\n};\\n",
                "solutionTags": [
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    set<int>st;\\n    void finding(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(root->val!=i)\\n        {\\n            root->val=i;\\n            st.insert(i);\\n        }\\n        finding(root->left,2*i+1);\\n        finding(root->right,2*i+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        int i=0;\\n         finding(root,i);\\n       }\\n    \\n    bool find(int target) {\\n        if(st.find(target)!=st.end())\\n            return true;\\n        else\\n            return false;\\n      }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 750284,
                "title": "recursive-python-solution",
                "content": "```\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        def recoverBinary(node, value, array):\\n            if node is None:\\n                return\\n            array.append(value)\\n            node.val = value\\n            if node.left:\\n                recoverBinary(node.left, (2 * value) + 1, array)\\n            if node.right:\\n                recoverBinary(node.right, (2 * value) + 2, array)\\n                \\n        \\n        self.array = []\\n        recoverBinary(root, 0, self.array)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.array\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        def recoverBinary(node, value, array):\\n            if node is None:\\n                return\\n            array.append(value)\\n            node.val = value\\n            if node.left:\\n                recoverBinary(node.left, (2 * value) + 1, array)\\n            if node.right:\\n                recoverBinary(node.right, (2 * value) + 2, array)\\n                \\n        \\n        self.array = []\\n        recoverBinary(root, 0, self.array)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741098,
                "title": "easy-recursive-c-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    void recover(TreeNode* root, int val) {\\n        if(root) {\\n            root -> val = val;\\n            s.insert(val);\\n            recover(root->left, 2*val+1);\\n            recover(root->right, 2*val+2);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    void recover(TreeNode* root, int val) {\\n        if(root) {\\n            root -> val = val;\\n            s.insert(val);\\n            recover(root->left, 2*val+1);\\n            recover(root->right, 2*val+2);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 722900,
                "title": "java-recursion-and-set",
                "content": "```\\nclass FindElements {\\n    \\n    private Set<Integer> set;\\n\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<Integer>();\\n        fixRecursive(root, null);\\n    \\n    }\\n    \\n    private void fixRecursive(TreeNode node, TreeNode parent) {\\n        \\n        if (node == null)\\n            return;\\n        \\n        if (parent == null)\\n            node.val = 0;\\n        else\\n            node.val = node == parent.left? 2 * parent.val + 1\\n                        : 2 * parent.val + 2;\\n        \\n        set.add(node.val);\\n        \\n        fixRecursive(node.left, node);\\n        fixRecursive(node.right, node);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\n    \\n    private Set<Integer> set;\\n\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<Integer>();\\n        fixRecursive(root, null);\\n    \\n    }\\n    \\n    private void fixRecursive(TreeNode node, TreeNode parent) {\\n        \\n        if (node == null)\\n            return;\\n        \\n        if (parent == null)\\n            node.val = 0;\\n        else\\n            node.val = node == parent.left? 2 * parent.val + 1\\n                        : 2 * parent.val + 2;\\n        \\n        set.add(node.val);\\n        \\n        fixRecursive(node.left, node);\\n        fixRecursive(node.right, node);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681495,
                "title": "iterative-o-logn",
                "content": "class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        target++;\\n        List<Integer> path = new ArrayList<>();\\n        while (target > 1) {\\n            path.add(0, target);\\n            target /= 2;\\n        }\\n        \\n        TreeNode cur = root;\\n        for (int num : path) {\\n            if (num % 2 == 0) {\\n                cur = cur.left;\\n            } else {\\n                cur = cur.right;\\n            }\\n            if (cur == null) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        target++;\\n        List<Integer> path = new ArrayList<>();\\n        while (target > 1) {\\n            path.add(0, target);\\n            target /= 2;\\n        }\\n        \\n        TreeNode cur = root;\\n        for (int num : path) {\\n            if (num % 2 == 0) {\\n                cur = cur.left;\\n            } else {\\n                cur = cur.right;\\n            }\\n            if (cur == null) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 587897,
                "title": "java-iterative-traversal-using-queue-and-find-using-hashset",
                "content": "1. Traversed iteratively using queue and set the values for the left and right child. Additionally added the same values to the HashSet, since with the given conditions (2*x+1 and 2*x+2 with root initialized to zero) there can be no nodes with the same values.\\n2. find will check the hashset and return the value\\n\\n```\\nclass FindElements {\\n    Set<Integer> treeNodeValues = new HashSet<Integer>();\\n\\t\\n    public FindElements(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\troot.val = 0;\\n\\t\\tTreeNode temp = null;\\n\\t\\t\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\ttemp = queue.poll();\\n\\t\\t\\ttreeNodeValues.add(temp.val);\\n\\t\\t\\t\\n\\t\\t\\tif(temp.left != null) {\\n\\t\\t\\t\\ttemp.left.val = 2 * temp.val + 1;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.left.val);\\n\\t\\t\\t\\tqueue.add(temp.left);\\n\\t\\t\\t}\\n\\t\\t\\tif(temp.right != null) {\\n\\t\\t\\t\\ttemp.right.val = 2 * temp.val + 2;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.right.val);\\n\\t\\t\\t\\tqueue.add(temp.right);\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    \\n    public boolean find(int target) {\\n        return treeNodeValues.contains(target);\\n    }\\n}\\n```\\nNote: Updated the code after the comment from @stanislav8",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    Set<Integer> treeNodeValues = new HashSet<Integer>();\\n\\t\\n    public FindElements(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\troot.val = 0;\\n\\t\\tTreeNode temp = null;\\n\\t\\t\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\ttemp = queue.poll();\\n\\t\\t\\ttreeNodeValues.add(temp.val);\\n\\t\\t\\t\\n\\t\\t\\tif(temp.left != null) {\\n\\t\\t\\t\\ttemp.left.val = 2 * temp.val + 1;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.left.val);\\n\\t\\t\\t\\tqueue.add(temp.left);\\n\\t\\t\\t}\\n\\t\\t\\tif(temp.right != null) {\\n\\t\\t\\t\\ttemp.right.val = 2 * temp.val + 2;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.right.val);\\n\\t\\t\\t\\tqueue.add(temp.right);\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    \\n    public boolean find(int target) {\\n        return treeNodeValues.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523255,
                "title": "java-solution-stick-with-tree",
                "content": "Just in case the examiner likes to tease your brain and restrict not to use HashTable and must traverse the tree :)\\n\\n```java\\tstatic class FindElements {\\n\\n\\t\\tTreeNode root;\\n\\n\\t\\tpublic FindElements(TreeNode r) {\\n\\t\\t\\tif (r == null) {\\n\\t\\t\\t\\tthis.root = null;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.root = new TreeNode(0);\\n\\t\\t\\t\\trecover(this.root, r);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate void recover(TreeNode root, TreeNode referenceRoot) {\\n\\t\\t\\tif (referenceRoot.left != null) {\\n\\t\\t\\t\\troot.left = new TreeNode(root.val * 2 + 1);\\n\\t\\t\\t\\trecover(root.left, referenceRoot.left);\\n\\t\\t\\t}\\n\\t\\t\\tif (referenceRoot.right != null) {\\n\\t\\t\\t\\troot.right = new TreeNode(root.val * 2 + 2);\\n\\t\\t\\t\\trecover(root.right, referenceRoot.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif (target < 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (target == 0) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode curr = root;\\n\\t\\t\\tif (curr == null) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tStack<Boolean> stack = new Stack<Boolean>();\\n\\t\\t\\tint tmp = target;\\n\\n\\t\\t\\twhile (tmp > 0) {\\n\\t\\t\\t\\tif (tmp % 2 == 0) {\\n\\t\\t\\t\\t\\t// even\\n\\t\\t\\t\\t\\tstack.push(true);\\n\\t\\t\\t\\t\\ttmp = (tmp - 2) / 2;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// odd\\n\\t\\t\\t\\t\\tstack.push(false);\\n\\t\\t\\t\\t\\ttmp = (tmp - 1) / 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\t\\tif (stack.pop()) {\\n\\t\\t\\t\\t\\t// right\\n\\t\\t\\t\\t\\tif (curr.right == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.right.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.right;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// left\\n\\t\\t\\t\\t\\tif (curr.left == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.left.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}`\\n``",
                "solutionTags": [],
                "code": "Just in case the examiner likes to tease your brain and restrict not to use HashTable and must traverse the tree :)\\n\\n```java\\tstatic class FindElements {\\n\\n\\t\\tTreeNode root;\\n\\n\\t\\tpublic FindElements(TreeNode r) {\\n\\t\\t\\tif (r == null) {\\n\\t\\t\\t\\tthis.root = null;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.root = new TreeNode(0);\\n\\t\\t\\t\\trecover(this.root, r);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate void recover(TreeNode root, TreeNode referenceRoot) {\\n\\t\\t\\tif (referenceRoot.left != null) {\\n\\t\\t\\t\\troot.left = new TreeNode(root.val * 2 + 1);\\n\\t\\t\\t\\trecover(root.left, referenceRoot.left);\\n\\t\\t\\t}\\n\\t\\t\\tif (referenceRoot.right != null) {\\n\\t\\t\\t\\troot.right = new TreeNode(root.val * 2 + 2);\\n\\t\\t\\t\\trecover(root.right, referenceRoot.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif (target < 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (target == 0) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode curr = root;\\n\\t\\t\\tif (curr == null) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tStack<Boolean> stack = new Stack<Boolean>();\\n\\t\\t\\tint tmp = target;\\n\\n\\t\\t\\twhile (tmp > 0) {\\n\\t\\t\\t\\tif (tmp % 2 == 0) {\\n\\t\\t\\t\\t\\t// even\\n\\t\\t\\t\\t\\tstack.push(true);\\n\\t\\t\\t\\t\\ttmp = (tmp - 2) / 2;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// odd\\n\\t\\t\\t\\t\\tstack.push(false);\\n\\t\\t\\t\\t\\ttmp = (tmp - 1) / 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\t\\tif (stack.pop()) {\\n\\t\\t\\t\\t\\t// right\\n\\t\\t\\t\\t\\tif (curr.right == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.right.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.right;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// left\\n\\t\\t\\t\\t\\tif (curr.left == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.left.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}`\\n``",
                "codeTag": "Java"
            },
            {
                "id": 501417,
                "title": "python-o-n-sol-by-correction-in-dfs-approach-90-with-comment",
                "content": "Python O(n) sol. by correction in DFS approach.\\n\\nHint:\\nTake advantage of **average O(1) looking-up** in hashset(i.e., **set()** in **python**),\\nrecording node value during binary tree correction, in order to **speed-up find()** operation later on\\n\\n---\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def helper( self, node, correct_value ):\\n        \\n        # Base case:\\n        # Empty tree or empty node\\n        if not node:\\n            return\\n\\n        # Correct current node\\n        # Update node value set\\n        node.val = correct_value\\n        self.node_value.add( correct_value )\\n\\n        # Update next level with DFS\\n        self.helper( node.left, 2 * correct_value + 1)\\n        self.helper( node.right, 2 * correct_value + 2 )\\n\\n    # -----------------------------------------\\n    \\n    \\n    def __init__(self, root: TreeNode):\\n        \\n        \\n        self.root = root\\n\\n        # a set of node value in binary tree with given root\\n        self.node_value = set()\\n        \\n        # correct whole tree, from root node with correction value 0\\n        self.helper( self.root, 0 )\\n        \\n\\n    def find(self, target: int) -> bool:\\n        \\n        # lookup target in node value set\\n        return (target in self.node_value)\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```\\n\\n---\\n\\nRelative leetcode challenge:\\n\\n[Leetcode #114 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n\\n---\\n\\nReference:\\n[1] [Python official docs about built-in data structure: set()](https://docs.python.org/3/tutorial/datastructures.html#sets)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def helper( self, node, correct_value ):\\n        \\n        # Base case:\\n        # Empty tree or empty node\\n        if not node:\\n            return\\n\\n        # Correct current node\\n        # Update node value set\\n        node.val = correct_value\\n        self.node_value.add( correct_value )\\n\\n        # Update next level with DFS\\n        self.helper( node.left, 2 * correct_value + 1)\\n        self.helper( node.right, 2 * correct_value + 2 )\\n\\n    # -----------------------------------------\\n    \\n    \\n    def __init__(self, root: TreeNode):\\n        \\n        \\n        self.root = root\\n\\n        # a set of node value in binary tree with given root\\n        self.node_value = set()\\n        \\n        # correct whole tree, from root node with correction value 0\\n        self.helper( self.root, 0 )\\n        \\n\\n    def find(self, target: int) -> bool:\\n        \\n        # lookup target in node value set\\n        return (target in self.node_value)\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486479,
                "title": "c-no-hashmap-bit-path",
                "content": "idea: Use a stack to store the bit path and then reversely find.\\n```\\nclass FindElements {\\npublic:\\n    FindElements(TreeNode* root) {\\n        r = root;\\n        if (!root) return;\\n        build(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        stack<bool> st;\\n        int t = target;\\n        while (t > 0) {\\n            if (t % 2) {\\n                st.push(true);\\n                t = (t - 1) / 2;\\n            } else {\\n                st.push(false);\\n                t = t / 2 - 1;\\n            }\\n        }\\n        TreeNode *cur = r;\\n        while (!st.empty()) {\\n            if (!cur) return false;\\n            if (st.top()) {\\n                cur = cur->left;\\n            } else {\\n                cur = cur->right;\\n            }\\n            st.pop();\\n        }\\n        if (cur && cur->val == target) return true;\\n        return false;\\n    }\\n    \\nprivate:\\n    TreeNode *r;\\n    \\n    void build(TreeNode* root, int val) {\\n        root->val = val;\\n        int n = 2 * val + 1;\\n        if (root->left) build(root->left, n);\\n        if (root->right) build(root->right, n + 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    FindElements(TreeNode* root) {\\n        r = root;\\n        if (!root) return;\\n        build(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        stack<bool> st;\\n        int t = target;\\n        while (t > 0) {\\n            if (t % 2) {\\n                st.push(true);\\n                t = (t - 1) / 2;\\n            } else {\\n                st.push(false);\\n                t = t / 2 - 1;\\n            }\\n        }\\n        TreeNode *cur = r;\\n        while (!st.empty()) {\\n            if (!cur) return false;\\n            if (st.top()) {\\n                cur = cur->left;\\n            } else {\\n                cur = cur->right;\\n            }\\n            st.pop();\\n        }\\n        if (cur && cur->val == target) return true;\\n        return false;\\n    }\\n    \\nprivate:\\n    TreeNode *r;\\n    \\n    void build(TreeNode* root, int val) {\\n        root->val = val;\\n        int n = 2 * val + 1;\\n        if (root->left) build(root->left, n);\\n        if (root->right) build(root->right, n + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479099,
                "title": "python-100-less-space",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x \\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        root.val = 0\\n        # Recover\\n        self.res = []\\n        self.recover(root)\\n        \\n    def recover(self,root):\\n        if not root:\\n            return\\n        self.res.append(root.val)\\n   \\n        if root.left:\\n            root.left.val = 2 * root.val + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = 2 * root.val + 2\\n            self.recover(root.right)\\n   \\n    def find(self, target: int) -> bool:\\n        return target in self.res     \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x \\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        root.val = 0\\n        # Recover\\n        self.res = []\\n        self.recover(root)\\n        \\n    def recover(self,root):\\n        if not root:\\n            return\\n        self.res.append(root.val)\\n   \\n        if root.left:\\n            root.left.val = 2 * root.val + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = 2 * root.val + 2\\n            self.recover(root.right)\\n   \\n    def find(self, target: int) -> bool:\\n        return target in self.res     \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)",
                "codeTag": "Java"
            },
            {
                "id": 448692,
                "title": "python3-clean-solution-beats-80",
                "content": "\\tclass FindElements:\\n\\n\\t\\tdef __init__(self, root: TreeNode):\\n\\t\\t\\tself.root = root\\n\\n\\t\\tdef find(self, target: int) -> bool:\\n\\n\\t\\t\\tbinaryStr = \\'{0:b}\\'.format(target+1)\\n\\t\\t\\tcurrent = self.root\\n\\t\\t\\tfor c in binaryStr[1:]:\\n\\t\\t\\t\\tcurrent = current.left if c == \\'0\\' else current.right\\n\\t\\t\\t\\tif not current:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\tclass FindElements:\\n\\n\\t\\tdef __init__(self, root: TreeNode):\\n\\t\\t\\tself.root = root\\n\\n\\t\\tdef find(self, target: int) -> bool:\\n\\n\\t\\t\\tbinaryStr = \\'{0:b}\\'.format(target+1)\\n\\t\\t\\tcurrent = self.root\\n\\t\\t\\tfor c in binaryStr[1:]:\\n\\t\\t\\t\\tcurrent = current.left if c == \\'0\\' else current.right\\n\\t\\t\\t\\tif not current:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 437281,
                "title": "100-space-java-easy-understandable",
                "content": "```\\nclass FindElements {\\n    TreeNode findRoot;\\n    public FindElements(TreeNode root) {\\n        if(root == null){return;}        \\n        findRoot = root;\\n        findRoot.val =0;\\n        assignValues(findRoot);\\n    }\\n    \\n    private void assignValues(TreeNode root){        \\n        if(root.left !=null){\\n            root.left.val = 2 * root.val +1;\\n            assignValues(root.left);\\n        }\\n        if(root.right !=null){\\n            root.right.val = 2 * root.val +2;\\n            assignValues(root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n       return findTarget(findRoot, target); \\n    }\\n    \\n    boolean findTarget(TreeNode findRoot, int target){\\n        if(findRoot.val == target){\\n            return true;\\n        }\\n        if (findRoot.val > target) return false;\\n        boolean left =false, right =false;\\n        if(findRoot.left !=null){\\n           left = findTarget(findRoot.left, target);\\n        }\\n        \\n        if(findRoot.right !=null){\\n            right = findTarget(findRoot.right, target);\\n        }\\n        \\n        return left || right;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    TreeNode findRoot;\\n    public FindElements(TreeNode root) {\\n        if(root == null){return;}        \\n        findRoot = root;\\n        findRoot.val =0;\\n        assignValues(findRoot);\\n    }\\n    \\n    private void assignValues(TreeNode root){        \\n        if(root.left !=null){\\n            root.left.val = 2 * root.val +1;\\n            assignValues(root.left);\\n        }\\n        if(root.right !=null){\\n            root.right.val = 2 * root.val +2;\\n            assignValues(root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n       return findTarget(findRoot, target); \\n    }\\n    \\n    boolean findTarget(TreeNode findRoot, int target){\\n        if(findRoot.val == target){\\n            return true;\\n        }\\n        if (findRoot.val > target) return false;\\n        boolean left =false, right =false;\\n        if(findRoot.left !=null){\\n           left = findTarget(findRoot.left, target);\\n        }\\n        \\n        if(findRoot.right !=null){\\n            right = findTarget(findRoot.right, target);\\n        }\\n        \\n        return left || right;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437115,
                "title": "python-no-need-to-initialize-tree-top-down-search-by-binary",
                "content": "Look at the binary presentation of \"num+1\", you will find that binary value will append \"1\" when the tree go right, append \"0\" when the tree go left. With this feature, we can do a top down search without initialization.\\n\\nWe can also do it without using binary feature. We notice that even number is always on the right branch, odd number is always on the left branch, using this feature, we can reversely find the path of the number in the tree. Reversing this path and we will have the top-down path.\\n\\n```\\n    def find(self, target: int) -> bool:\\n        tmp=bin(target+1)[3:]\\n        node=self.root\\n        for t in tmp:\\n            if t==\\'0\\':\\n                if not node.left:\\n                    return False\\n                node=node.left\\n            elif t==\\'1\\':\\n                if not node.right:\\n                    return False\\n                node=node.right\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def find(self, target: int) -> bool:\\n        tmp=bin(target+1)[3:]\\n        node=self.root\\n        for t in tmp:\\n            if t==\\'0\\':\\n                if not node.left:\\n                    return False\\n                node=node.left\\n            elif t==\\'1\\':\\n                if not node.right:\\n                    return False\\n                node=node.right\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 435179,
                "title": "python-easy-to-understand-solution",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.s = set()\\n        \\n        head = TreeNode(-1)\\n        head.right = root\\n        arr = [head]\\n        while arr:\\n            top = arr.pop(0)\\n            val = top.val\\n            self.s.add(val)\\n            left, right = top.left, top.right\\n            if left:\\n                left.val = 2 * val + 1\\n                arr.append(left)\\n            if right:\\n                right.val = 2 * val + 2\\n                arr.append(right)\\n        \\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        return target in self.s\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.s = set()\\n        \\n        head = TreeNode(-1)\\n        head.right = root\\n        arr = [head]\\n        while arr:\\n            top = arr.pop(0)\\n            val = top.val\\n            self.s.add(val)\\n            left, right = top.left, top.right\\n            if left:\\n                left.val = 2 * val + 1\\n                arr.append(left)\\n            if right:\\n                right.val = 2 * val + 2\\n                arr.append(right)\\n        \\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        return target in self.s\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434356,
                "title": "python-java-easy-bitwise-trick-with-explanation",
                "content": "Given a number X, what\\'s the path to the corresponding node of X?\\nExample:\\nX = 1, path = left --> 0\\nX = 3, path = left, left --> 00\\nX = 9, path = left, right, left --> 010\\nX = 16, path = left, left, left, right --> 0001\\n......\\nCan you see the trick?\\npath = binary(X+1).substring(1)\\n\\nThen everything be quite easy:\\nPython:\\n```python\\nclass FindElements:\\n    \\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        target += 1\\n        path = bin(target)[3:]\\n        current = self.root\\n        for p in path:\\n            if not current: \\n                return False\\n            if p == \\'0\\':\\n                current = current.left\\n            else:\\n                current = current.right\\n        return current != None\\n```\\nJava:\\n```java\\nclass FindElements {\\n    \\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        TreeNode current = this.root;\\n        String path = Integer.toBinaryString(target + 1).substring(1);\\n        for (char c: path.toCharArray()) {\\n            if (current == null) return false;\\n            if (c == \\'0\\'){\\n                current = current.left;\\n            }\\n            else {\\n                current = current.right;\\n            }\\n        }\\n        return current != null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass FindElements:\\n    \\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        target += 1\\n        path = bin(target)[3:]\\n        current = self.root\\n        for p in path:\\n            if not current: \\n                return False\\n            if p == \\'0\\':\\n                current = current.left\\n            else:\\n                current = current.right\\n        return current != None\\n```\n```java\\nclass FindElements {\\n    \\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        TreeNode current = this.root;\\n        String path = Integer.toBinaryString(target + 1).substring(1);\\n        for (char c: path.toCharArray()) {\\n            if (current == null) return false;\\n            if (c == \\'0\\'){\\n                current = current.left;\\n            }\\n            else {\\n                current = current.right;\\n            }\\n        }\\n        return current != null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433461,
                "title": "c-super-simple-and-straight-forward-solution-with-o-1-find-can-be-easily-implemented-in-5-mins",
                "content": "A BFS solution in C++:\\n```   \\n    unordered_set<int> nums;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty()) {\\n            TreeNode* r=q.front();\\n            q.pop();\\n            nums.insert(r->val);\\n            if(r->left!=NULL) {\\n                r->left->val=r->val*2+1;\\n                q.push(r->left);\\n            }\\n            if(r->right!=NULL) \\n            {\\n                r->right->val=r->val*2+2;\\n                q.push(r->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return nums.find(target)!=nums.end();\\n    }",
                "solutionTags": [],
                "code": "A BFS solution in C++:\\n```   \\n    unordered_set<int> nums;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty()) {\\n            TreeNode* r=q.front();\\n            q.pop();\\n            nums.insert(r->val);\\n            if(r->left!=NULL) {\\n                r->left->val=r->val*2+1;\\n                q.push(r->left);\\n            }\\n            if(r->right!=NULL) \\n            {\\n                r->right->val=r->val*2+2;\\n                q.push(r->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return nums.find(target)!=nums.end();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 432956,
                "title": "easy-preorder-traversal-hash-table-c-solution-t-o-n-s-o-n",
                "content": "```\\nclass FindElements {\\n    unordered_set<int> ht;\\npublic:\\n    void helper(TreeNode* root, int x, int child){\\n        if(root==nullptr) return;\\n        if(child==0)    \\n            root->val=2*x+1;\\n        else\\n            root->val=2*x+2;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    FindElements(TreeNode* root) {\\n       if(root==nullptr) return;\\n        root->val=0;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    \\n    \\n    bool find(int target) {\\n        if(ht.find(target)!=ht.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass FindElements {\\n    unordered_set<int> ht;\\npublic:\\n    void helper(TreeNode* root, int x, int child){\\n        if(root==nullptr) return;\\n        if(child==0)    \\n            root->val=2*x+1;\\n        else\\n            root->val=2*x+2;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    FindElements(TreeNode* root) {\\n       if(root==nullptr) return;\\n        root->val=0;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    \\n    \\n    bool find(int target) {\\n        if(ht.find(target)!=ht.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 431344,
                "title": "c-solution",
                "content": "```\\npublic class FindElements \\n{\\n    private TreeNode root;\\n    \\n    public FindElements(TreeNode r) \\n    {\\n        this.root = r;\\n    }\\n    \\n    public bool Find(int target) \\n    {\\n        return Find(root, target, 0);\\n    }\\n    \\n    private bool Find(TreeNode node, int target, int index)\\n    {\\n        if(target == index) return true;\\n        var left = node.left == null ? false : Find(node.left, target, index * 2 + 1); \\n        var right = node.right == null ? false : Find(node.right, target, index * 2 + 2);\\n        return left || right;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class FindElements \\n{\\n    private TreeNode root;\\n    \\n    public FindElements(TreeNode r) \\n    {\\n        this.root = r;\\n    }\\n    \\n    public bool Find(int target) \\n    {\\n        return Find(root, target, 0);\\n    }\\n    \\n    private bool Find(TreeNode node, int target, int index)\\n    {\\n        if(target == index) return true;\\n        var left = node.left == null ? false : Find(node.left, target, index * 2 + 1); \\n        var right = node.right == null ? false : Find(node.right, target, index * 2 + 2);\\n        return left || right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431058,
                "title": "java-simple-pre-order-traversal",
                "content": "```\\nclass FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        recover(root, 0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return findAux(target, root);\\n    }\\n    \\n    private void recover(TreeNode node, int val) {\\n        if (node == null) return;\\n        node.val = val;\\n        recover(node.left, 2*val+1);\\n        recover(node.right, 2*val+2);\\n    }\\n    \\n    private boolean findAux(int target, TreeNode node) {\\n        if (node == null) return false;\\n        if (node.val == target) return true;\\n        if (node.val > target) return false;\\n        return findAux(target, node.left) || findAux(target, node.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        recover(root, 0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return findAux(target, root);\\n    }\\n    \\n    private void recover(TreeNode node, int val) {\\n        if (node == null) return;\\n        node.val = val;\\n        recover(node.left, 2*val+1);\\n        recover(node.right, 2*val+2);\\n    }\\n    \\n    private boolean findAux(int target, TreeNode node) {\\n        if (node == null) return false;\\n        if (node.val == target) return true;\\n        if (node.val > target) return false;\\n        return findAux(target, node.left) || findAux(target, node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088287,
                "title": "java-solution-using-bits-manipulation-without-tree-recovery-tc-o-logn-sc-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass FindElements {\\n    private TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int x) {\\n        int mask = 1;\\n        while (x != 0) {\\n            mask <<= 1;\\n            mask |= (x & 1);\\n            x = (x - 1) >> 1;\\n        }\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (mask == 1) return true;\\n            node = (mask & 1) == 1 ? node.left : node.right;\\n            mask >>= 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    private TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int x) {\\n        int mask = 1;\\n        while (x != 0) {\\n            mask <<= 1;\\n            mask |= (x & 1);\\n            x = (x - 1) >> 1;\\n        }\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (mask == 1) return true;\\n            node = (mask & 1) == 1 ? node.left : node.right;\\n            mask >>= 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083799,
                "title": "python-easy-solution-for-beginner-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are traversing and add value into our hashset.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def f(self,root,val):\\n        if root==None:\\n            return \\n        self.dict.add(val)\\n        if root.left:\\n            vl=(2*val)+1\\n            self.f(root.left,vl)\\n\\n        if root.right:\\n            vr=(2*val)+2\\n            self.f(root.right,vr)\\n\\n\\n\\n        \\n    def __init__(self, root: Optional[TreeNode]):\\n        self.dict=set()\\n        self.f(root,0)\\n        \\n\\n    def find(self, target: int) -> bool:\\n        if target in self.dict:\\n            return True\\n\\n        else:\\n            return False\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def f(self,root,val):\\n        if root==None:\\n            return \\n        self.dict.add(val)\\n        if root.left:\\n            vl=(2*val)+1\\n            self.f(root.left,vl)\\n\\n        if root.right:\\n            vr=(2*val)+2\\n            self.f(root.right,vr)\\n\\n\\n\\n        \\n    def __init__(self, root: Optional[TreeNode]):\\n        self.dict=set()\\n        self.f(root,0)\\n        \\n\\n    def find(self, target: int) -> bool:\\n        if target in self.dict:\\n            return True\\n\\n        else:\\n            return False\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075263,
                "title": "dfs-recover-method-and-hashset",
                "content": "## Result\\n![image.png](https://assets.leetcode.com/users/images/6f702887-d68d-4273-b7d0-cf4a3c8e5c5b_1695363557.7931392.png)\\n\\n## Code\\n```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node = root\\n        self.values = set()\\n        self.recover(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n    \\n    def recover(self, node, val):\\n        if node is None:\\n            return\\n        node.val = val\\n        self.values.add(val)\\n        self.recover(node.left, 2 * val + 1)\\n        self.recover(node.right, 2 * val + 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node = root\\n        self.values = set()\\n        self.recover(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n    \\n    def recover(self, node, val):\\n        if node is None:\\n            return\\n        node.val = val\\n        self.values.add(val)\\n        self.recover(node.left, 2 * val + 1)\\n        self.recover(node.right, 2 * val + 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029028,
                "title": "recursion-dfs",
                "content": "# Code\\n```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n            \\n\\n    def find(self, target: int) -> bool:\\n        def dfs(node, s, p):\\n            if not node:\\n                return False\\n            if len(s) == p:\\n                return True\\n            return dfs(node.left, s, p+1) if s[p] == \\'0\\' else dfs(node.right, s, p+1)\\n        return dfs(self.root, bin(target+1)[2:], 1)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n            \\n\\n    def find(self, target: int) -> bool:\\n        def dfs(node, s, p):\\n            if not node:\\n                return False\\n            if len(s) == p:\\n                return True\\n            return dfs(node.left, s, p+1) if s[p] == \\'0\\' else dfs(node.right, s, p+1)\\n        return dfs(self.root, bin(target+1)[2:], 1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010939,
                "title": "solution-using-hashmap-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will recover the tree initially and then we will store all the values from recovery to a hashmap and then return the query result referring the hashmap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Steps :**\\n1. First we create a function to traverse the tree that is provided and recover it.\\n2. While recovering, we put all the values recovered in a hashtable.\\n3. Lastly we will check if the target is present in the hashtable and return values accordingly. \\n\\n# Complexity\\n- Time complexity: O(n + q) where **n** = number of nodes present in the tree and **q** is the number of queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> um;\\n    void recover(TreeNode * r, int v){\\n        if(r == NULL)\\n            return;\\n\\n        r->val = v;\\n        um[v]++;\\n        recover(r->left, (2 * v) + 1);\\n        recover(r->right, (2 * v) + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if(um[target] > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> um;\\n    void recover(TreeNode * r, int v){\\n        if(r == NULL)\\n            return;\\n\\n        r->val = v;\\n        um[v]++;\\n        recover(r->left, (2 * v) + 1);\\n        recover(r->right, (2 * v) + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if(um[target] > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000237,
                "title": "c-simple-solution",
                "content": "# Approach\\n1. Recover the root first by setting it to 0 and store in map\\n2. Traverse to other nodes and recover them too\\n3. After recovering each node store that in map to search later\\n4. To find target find the value in the map and return true if found\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    //function to recover other nodes\\n    void traversal(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        int x=root->val;\\n        //while recovering also store new node values in a map\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*x)+1;\\n            mp[root->left->val]++;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*x)+2;\\n            mp[root->right->val]++;\\n        }\\n        traversal(root->left);\\n        traversal(root->right);\\n    }\\n    FindElements(TreeNode* root) \\n    {\\n        //recover the root first and store it\\'s value in map\\n        root->val=0;\\n        mp[root->val]++;\\n        traversal(root);\\n    }\\n    bool find(int target) \\n    {\\n        //check if target value is present in the map\\n        if(mp.find(target)!=mp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    //function to recover other nodes\\n    void traversal(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        int x=root->val;\\n        //while recovering also store new node values in a map\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*x)+1;\\n            mp[root->left->val]++;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*x)+2;\\n            mp[root->right->val]++;\\n        }\\n        traversal(root->left);\\n        traversal(root->right);\\n    }\\n    FindElements(TreeNode* root) \\n    {\\n        //recover the root first and store it\\'s value in map\\n        root->val=0;\\n        mp[root->val]++;\\n        traversal(root);\\n    }\\n    bool find(int target) \\n    {\\n        //check if target value is present in the map\\n        if(mp.find(target)!=mp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956071,
                "title": "easy-java-solution",
                "content": "# Intuition\\nWhen we read about the rules of the binary tree, we can understand that given any node value, we can determine the values of its left and right children. Therefore, if the tree\\'s values are changed to -1, we can still recover the tree\\'s original values by traversing it from the root and assigning the correct values according to the rules provided.\\n\\n# Approach\\n\\n1. Initialization:\\n\\n* Start by setting the root\\'s value to 0.\\n* Use a queue to traverse the tree in a BFS manner. This choice ensures that we visit nodes level by level, which is beneficial because child node values depend on parent node values.\\n* While there are nodes in the queue, pop a node.\\n* If it has a left child, set the left child\\'s value using the formula 2\\xD7node.val+1 and add the left child to the queue.\\n* Similarly, if it has a right child, set the right child\\'s value using the formula  2\\xD7node.val+2\\n* Additionally, for each node we visit, we add its value to a hash set. This set allows for O(1) look-up time when checking if a value exists in the tree.\\n\\n3. 2. Finding a Value:\\n\\n* To check if a value exists in the recovered tree, simply check if it exists in the hash set.\\n\\n\\n# Complexity\\n- Time complexity: O(N), O(1)\\n\\n\\n- Space complexity: O(N)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set = new HashSet<>();\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while(!queue.isEmpty()){\\n            TreeNode node = queue.poll();\\n            set.add(node.val);\\n            if(node.right!=null){\\n                node.right.val = 2*node.val + 2;\\n                queue.add(node.right);\\n            }\\n            if(node.left!=null){\\n                node.left.val = 2*node.val + 1; \\n                queue.add(node.left);\\n            }\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set = new HashSet<>();\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while(!queue.isEmpty()){\\n            TreeNode node = queue.poll();\\n            set.add(node.val);\\n            if(node.right!=null){\\n                node.right.val = 2*node.val + 2;\\n                queue.add(node.right);\\n            }\\n            if(node.left!=null){\\n                node.left.val = 2*node.val + 1; \\n                queue.add(node.left);\\n            }\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953690,
                "title": "level-order-traversal-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    vector <int> num;\\n\\n    // stor level-order traversal of recover BT in vector....\\n\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        if(root != NULL) root->val = 0;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto n = q.front();\\n            q.pop();\\n            num.push_back(n->val);\\n            \\n            if(n->left){\\n                n->left->val = 2*n->val + 1;\\n                q.push(n->left);\\n            }\\n            if(n->right){\\n                n->right->val = 2*n->val + 2;\\n                q.push(n->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int tar) {\\n        // level-order traversal of recover BT is sorted\\n        // so vector-num is sorted array\\n        // now we can apply Binary Search in num...\\n        int s = 0, e = num.size()-1;\\n        while(s <= e){\\n            int mid = s + (e-s)/2;\\n            if(num[mid] == tar) return true;\\n            else if(num[mid] > tar) e = mid-1;\\n            else s = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    vector <int> num;\\n\\n    // stor level-order traversal of recover BT in vector....\\n\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        if(root != NULL) root->val = 0;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto n = q.front();\\n            q.pop();\\n            num.push_back(n->val);\\n            \\n            if(n->left){\\n                n->left->val = 2*n->val + 1;\\n                q.push(n->left);\\n            }\\n            if(n->right){\\n                n->right->val = 2*n->val + 2;\\n                q.push(n->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int tar) {\\n        // level-order traversal of recover BT is sorted\\n        // so vector-num is sorted array\\n        // now we can apply Binary Search in num...\\n        int s = 0, e = num.size()-1;\\n        while(s <= e){\\n            int mid = s + (e-s)/2;\\n            if(num[mid] == tar) return true;\\n            else if(num[mid] > tar) e = mid-1;\\n            else s = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953465,
                "title": "python-easy-clean-solution",
                "content": "# Code\\n```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.db = set()\\n        self.db.add(0)\\n        root.val = 0\\n\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            \\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                self.db.add(node.left.val)\\n                stack.append(node.left)\\n            \\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                self.db.add(node.right.val)\\n                stack.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.db\\n```\\n![catty.png](https://assets.leetcode.com/users/images/5888e488-44f4-4c24-9b81-552eac175cfc_1692866410.1003535.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.db = set()\\n        self.db.add(0)\\n        root.val = 0\\n\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            \\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                self.db.add(node.left.val)\\n                stack.append(node.left)\\n            \\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                self.db.add(node.right.val)\\n                stack.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.db\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931318,
                "title": "python3-beats-99",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val = 0\\n        d = [root]\\n        self.s= set()\\n        while d:\\n            x = d.pop()\\n            self.s.add(x.val)\\n            if x.left:\\n                x.left.val = 2*x.val+1\\n                d.append(x.left)\\n            if x.right:\\n                x.right.val = 2*x.val+2\\n                d.append(x.right)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.s\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val = 0\\n        d = [root]\\n        self.s= set()\\n        while d:\\n            x = d.pop()\\n            self.s.add(x.val)\\n            if x.left:\\n                x.left.val = 2*x.val+1\\n                d.append(x.left)\\n            if x.right:\\n                x.right.val = 2*x.val+2\\n                d.append(x.right)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.s\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929431,
                "title": "python3-clean-dfs-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        \\n        def f(root,ind):\\n            if not root:\\n                return\\n            self.seen.add(ind)\\n            f(root.left,2*ind+1)\\n            f(root.right,2*ind+2)\\n        \\n        self.seen=set()\\n        f(root,0)\\n        \\n        \\n    def find(self, target: int) -> bool:\\n        \\n        return target in self.seen\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        \\n        def f(root,ind):\\n            if not root:\\n                return\\n            self.seen.add(ind)\\n            f(root.left,2*ind+1)\\n            f(root.right,2*ind+2)\\n        \\n        self.seen=set()\\n        f(root,0)\\n        \\n        \\n    def find(self, target: int) -> bool:\\n        \\n        return target in self.seen\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918921,
                "title": "python-solution-using-map-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the tree and assign the right set of values, also store these values in map or set which can be used later to determine whether the value exists in the tree or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse the tree, and assign the correct set of values i.e. $$(2 * value  + 1)$$ for left and $$(2 * value + 2)$$ for the right. As you assign the value to the tree, store that value in order to determine whether that value exists or not when you will query the tree later.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/95e6bf36-04b7-4288-b8ea-f8bfcf1da870_1692204361.671172.png)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\n\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.map = {}\\n        self.updateTree(self.root)\\n        \\n    def updateTree(self, root, val = 0):\\n        if root == None:\\n            return\\n        \\n        root.val = val\\n        self.map[val] = True\\n\\n        if root.left != None:\\n            self.updateTree(root.left, 2 * val + 1)\\n        \\n        if root.right != None:\\n            self.updateTree(root.right, 2 * val + 2)\\n\\n\\n    def find(self, target: int) -> bool:\\n        if self.root == None:\\n            return False\\n\\n        return target in self.map\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\n\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.map = {}\\n        self.updateTree(self.root)\\n        \\n    def updateTree(self, root, val = 0):\\n        if root == None:\\n            return\\n        \\n        root.val = val\\n        self.map[val] = True\\n\\n        if root.left != None:\\n            self.updateTree(root.left, 2 * val + 1)\\n        \\n        if root.right != None:\\n            self.updateTree(root.right, 2 * val + 2)\\n\\n\\n    def find(self, target: int) -> bool:\\n        if self.root == None:\\n            return False\\n\\n        return target in self.map\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902473,
                "title": "python3-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.vals = set()\\n        root.val = 0\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            self.vals.add(node.val)\\n\\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                queue.append(node.left)\\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                queue.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.vals\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.vals = set()\\n        root.val = 0\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            self.vals.add(node.val)\\n\\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                queue.append(node.left)\\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                queue.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.vals\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895129,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    TreeNode head=null;\\n    int f=1;\\n    boolean ft=false;\\n    public FindElements(TreeNode root) {\\n        head=create(root);\\n    }\\n\\n    public TreeNode create(TreeNode root){\\n        if(root==null)\\n        return root;\\n        if(f==1){\\n            root.val=0;\\n            f=0;\\n        }\\n        if(root.left!=null){\\n            root.left.val=2*root.val+1;\\n        }\\n        if(root.right!=null){\\n            root.right.val=2*root.val+2;\\n        }\\n        create(root.left);\\n        create(root.right);\\n        return root;\\n    }\\n    public boolean find1(int t,TreeNode root){\\n        if(root==null)\\n        return false;\\n\\n        if(root.val==t)\\n        ft=true;\\n        else{\\n            find1(t,root.left);\\n            find1(t,root.right);\\n        }\\n        return ft;\\n        \\n    }\\n    public boolean find(int target) {\\n        ft=false;\\n        find1(target,head);\\n        return ft;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    TreeNode head=null;\\n    int f=1;\\n    boolean ft=false;\\n    public FindElements(TreeNode root) {\\n        head=create(root);\\n    }\\n\\n    public TreeNode create(TreeNode root){\\n        if(root==null)\\n        return root;\\n        if(f==1){\\n            root.val=0;\\n            f=0;\\n        }\\n        if(root.left!=null){\\n            root.left.val=2*root.val+1;\\n        }\\n        if(root.right!=null){\\n            root.right.val=2*root.val+2;\\n        }\\n        create(root.left);\\n        create(root.right);\\n        return root;\\n    }\\n    public boolean find1(int t,TreeNode root){\\n        if(root==null)\\n        return false;\\n\\n        if(root.val==t)\\n        ft=true;\\n        else{\\n            find1(t,root.left);\\n            find1(t,root.right);\\n        }\\n        return ft;\\n        \\n    }\\n    public boolean find(int target) {\\n        ft=false;\\n        find1(target,head);\\n        return ft;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890896,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    void create(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        root->val=x;\\n        mp[x]++;\\n        create(root->left,2*x+1);\\n        create(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        create(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)==mp.end())\\n        {\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    void create(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        root->val=x;\\n        mp[x]++;\\n        create(root->left,2*x+1);\\n        create(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        create(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)==mp.end())\\n        {\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875732,
                "title": "python-easy-and-short-dfs-find-0-1",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ for init\\n$$O(1)$$ for find\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.values = set()\\n        \\n        def dfs(node, val):\\n            if not node: return\\n            self.values.add(val)\\n            dfs(node.left, 2 * val + 1)\\n            dfs(node.right, 2 * val + 2)\\n        \\n        dfs(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.values = set()\\n        \\n        def dfs(node, val):\\n            if not node: return\\n            self.values.add(val)\\n            dfs(node.left, 2 * val + 1)\\n            dfs(node.right, 2 * val + 2)\\n        \\n        dfs(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837024,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    TreeNode* root1;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root1 = root;  \\n        value(root , 0);\\n    }\\n\\n    void value(TreeNode* root , int x){\\n        if (root == NULL)\\n            return;\\n        \\n        root->val = x;\\n        value(root->left , 2*x + 1);\\n        value(root->right , 2*x + 2);\\n    }\\n\\n    bool solve(int target , TreeNode* root){\\n        if (root == NULL)\\n            return false;\\n        \\n        if (root->val == target)\\n            return true;\\n        bool left = solve(target , root->left);\\n        bool right = solve(target , root->right);\\n\\n        return left||right;\\n    }\\n    \\n    bool find(int target) {\\n        if (root1->val == target)\\n            return true;\\n        \\n        return solve(target , root1);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    TreeNode* root1;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root1 = root;  \\n        value(root , 0);\\n    }\\n\\n    void value(TreeNode* root , int x){\\n        if (root == NULL)\\n            return;\\n        \\n        root->val = x;\\n        value(root->left , 2*x + 1);\\n        value(root->right , 2*x + 2);\\n    }\\n\\n    bool solve(int target , TreeNode* root){\\n        if (root == NULL)\\n            return false;\\n        \\n        if (root->val == target)\\n            return true;\\n        bool left = solve(target , root->left);\\n        bool right = solve(target , root->right);\\n\\n        return left||right;\\n    }\\n    \\n    bool find(int target) {\\n        if (root1->val == target)\\n            return true;\\n        \\n        return solve(target , root1);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825912,
                "title": "c-solution-dfs",
                "content": "```\\nclass FindElements {\\npublic:\\n    TreeNode* m_root;\\n    map<int, int> mp;\\n\\n    FindElements(TreeNode* root) {\\n        m_root = root;\\n        recover(m_root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp.count(target) > 0;\\n    }\\nprivate:\\n    int recover(TreeNode* root, int x = 0) {\\n        if (!root)\\n            return 0;\\n        if (root->left)\\n            root->left->val = recover(root->left, 2 * x + 1);\\n        root->val = x;\\n        mp[x]++;\\n        if (root->right)\\n            root->right->val = recover(root->right, 2 * x + 2);\\n        return root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    TreeNode* m_root;\\n    map<int, int> mp;\\n\\n    FindElements(TreeNode* root) {\\n        m_root = root;\\n        recover(m_root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp.count(target) > 0;\\n    }\\nprivate:\\n    int recover(TreeNode* root, int x = 0) {\\n        if (!root)\\n            return 0;\\n        if (root->left)\\n            root->left->val = recover(root->left, 2 * x + 1);\\n        root->val = x;\\n        mp[x]++;\\n        if (root->right)\\n            root->right->val = recover(root->right, 2 * x + 2);\\n        return root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819886,
                "title": "find-elements-in-a-contaminated-binary-tree-easiest-with-c",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    map<int, int>mp;\\n    void recoverTree(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        mp[root->val]++;\\n        if(root->left)\\n            root->left->val = 2 * root->val + 1;\\n        if(root->right)\\n            root->right->val = 2 * root->val + 2;\\n\\n        recoverTree(root->left);\\n        recoverTree(root->right);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        recoverTree(root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    map<int, int>mp;\\n    void recoverTree(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        mp[root->val]++;\\n        if(root->left)\\n            root->left->val = 2 * root->val + 1;\\n        if(root->right)\\n            root->right->val = 2 * root->val + 2;\\n\\n        recoverTree(root->left);\\n        recoverTree(root->right);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        recoverTree(root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788198,
                "title": "easy-c-solution-dfs-map-efficient-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn= number of nodes\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,int> mp;\\n    void solve(TreeNode* root){\\n        if(root==NULL)\\n            return;\\n        mp[root->val]=1;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=2*root->val+1;\\n            solve(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            solve(root->right);\\n        }\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int t) {\\n        return mp[t];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,int> mp;\\n    void solve(TreeNode* root){\\n        if(root==NULL)\\n            return;\\n        mp[root->val]=1;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=2*root->val+1;\\n            solve(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            solve(root->right);\\n        }\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int t) {\\n        return mp[t];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753464,
                "title": "easy-solution-with-dfs-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,bool>Exist;\\n    FindElements(TreeNode* root) {\\n        RecoveredTree(root,0);\\n    }\\n\\n    void RecoveredTree(TreeNode* root,int value){\\n        if(root==NULL)return;\\n        root->val=value;\\n        Exist[value]=1;\\n        RecoveredTree(root->left,(2*value)+1);\\n        RecoveredTree(root->right,(2*value)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return Exist[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,bool>Exist;\\n    FindElements(TreeNode* root) {\\n        RecoveredTree(root,0);\\n    }\\n\\n    void RecoveredTree(TreeNode* root,int value){\\n        if(root==NULL)return;\\n        root->val=value;\\n        Exist[value]=1;\\n        RecoveredTree(root->left,(2*value)+1);\\n        RecoveredTree(root->right,(2*value)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return Exist[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750362,
                "title": "cpp-using-hash-map-clean-code",
                "content": "\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void dfs(TreeNode *root){\\n        if(root!=NULL){\\n            if(root->left){\\n                root->left->val=2*root->val +1;\\n                s.insert(root->left->val);\\n            }\\n            dfs(root->left);\\n            if(root->right){\\n                root->right->val=2*root->val +2;\\n                s.insert(root->right->val);\\n            }\\n            dfs(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)==s.end())return false;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void dfs(TreeNode *root){\\n        if(root!=NULL){\\n            if(root->left){\\n                root->left->val=2*root->val +1;\\n                s.insert(root->left->val);\\n            }\\n            dfs(root->left);\\n            if(root->right){\\n                root->right->val=2*root->val +2;\\n                s.insert(root->right->val);\\n            }\\n            dfs(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)==s.end())return false;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746686,
                "title": "easy-c-code",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int> mp;\\n    FindElements(TreeNode* root) {\\n        mp.clear();\\n\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n\\n        while(!q.empty()){\\n            TreeNode* node= q.front().first;\\n            int v= q.front().second;\\n            mp[v]=1;\\n            node->val=v;\\n            q.pop();\\n\\n            if(node->left) q.push({node->left,2*v+1});\\n            if(node->right) q.push({node->right,2*v+2});\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int> mp;\\n    FindElements(TreeNode* root) {\\n        mp.clear();\\n\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n\\n        while(!q.empty()){\\n            TreeNode* node= q.front().first;\\n            int v= q.front().second;\\n            mp[v]=1;\\n            node->val=v;\\n            q.pop();\\n\\n            if(node->left) q.push({node->left,2*v+1});\\n            if(node->right) q.push({node->right,2*v+2});\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731771,
                "title": "depth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe contaminated binary tree has some of its node values modified. The modification rule is that for any node with value v, its left child\\'s value is 2 * v + 1, and its right child\\'s value is 2 * v + 2.\\nThe goal is to create a data structure that allows us to efficiently determine whether a given value exists in the contaminated tree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1\\uFE0F\\u20E3 Contaminate Tree: Starting from the root, recursively traverse the tree and modify each node\\'s value based on the contamination rule.\\n2\\uFE0F\\u20E3 Find Operation: Implement a depth-first search (DFS) to traverse the tree and check if the target value is found.\\n\\nIf the current node\\'s value matches the target, mark it as found.\\nIf not found, recursively search in the left and right subtrees.\\n3\\uFE0F\\u20E3 Initialization: Initialize the root node with a value of 0 and call the ContaminateTree function.\\n4\\uFE0F\\u20E3 Construction: Create an instance of the FindElements class with the root of the contaminated tree.\\n5\\uFE0F\\u20E3 Query: Use the find method on the FindElements object to check if a target value exists in the contaminated tree. The find method performs a DFS search and returns true if the target is found, and false otherwise.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nTreeNode* myroot;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        myroot = root;\\n        ContaminateTree(myroot);\\n    }\\n    \\n    bool find(int target) {\\n        bool found = false;\\n        dfs_find(myroot , target , found);\\n        return found;\\n    };\\n\\n    void ContaminateTree(TreeNode* root){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->left != nullptr){\\n            root->left->val = 2*root->val + 1;\\n        }\\n        if(root->right != nullptr){\\n            root->right->val = 2*root->val + 2;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            ContaminateTree(root->left);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            ContaminateTree(root->right);\\n        }\\n\\n        return ;\\n    };\\n    void dfs_find(TreeNode* root , int target , bool &found){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            if(root->val == target){\\n                found = true;\\n            }\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->val == target){\\n            found = true;\\n        }\\n\\n        if(found == true){\\n            return;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            dfs_find(root->left , target , found);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            dfs_find(root->right , target , found);\\n        }\\n\\n        return ;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nTreeNode* myroot;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        myroot = root;\\n        ContaminateTree(myroot);\\n    }\\n    \\n    bool find(int target) {\\n        bool found = false;\\n        dfs_find(myroot , target , found);\\n        return found;\\n    };\\n\\n    void ContaminateTree(TreeNode* root){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->left != nullptr){\\n            root->left->val = 2*root->val + 1;\\n        }\\n        if(root->right != nullptr){\\n            root->right->val = 2*root->val + 2;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            ContaminateTree(root->left);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            ContaminateTree(root->right);\\n        }\\n\\n        return ;\\n    };\\n    void dfs_find(TreeNode* root , int target , bool &found){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            if(root->val == target){\\n                found = true;\\n            }\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->val == target){\\n            found = true;\\n        }\\n\\n        if(found == true){\\n            return;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            dfs_find(root->left , target , found);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            dfs_find(root->right , target , found);\\n        }\\n\\n        return ;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709999,
                "title": "c-implementation-using-set-data-structure",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nset<int>st;\\npublic:\\n    void help(TreeNode* root,int node)\\n    {\\n        if(root==NULL){\\n            return;\\n        }\\n        st.insert(node);\\n        help(root->left,2*node+1);\\n        help(root->right,2*node+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        help(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nset<int>st;\\npublic:\\n    void help(TreeNode* root,int node)\\n    {\\n        if(root==NULL){\\n            return;\\n        }\\n        st.insert(node);\\n        help(root->left,2*node+1);\\n        help(root->right,2*node+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        help(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708836,
                "title": "a-new-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA particular value could be reached from a particular path only. So instead of saving the entire list of nodes in hashset, just save the leaves.\\n\\n# Complexity\\n- Time complexity:\\nFindElements = O(N)\\nfind = O(H); H --> max height;\\nTotal = O(H+N) = O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H + 2^H); \\nO(H) --> for stack of recursion\\nO(2^H) --> max no. of leaf node that can be saved in the set.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>st;\\n    int maxi=0;\\n    void p(TreeNode* root, int val) {\\n        if(!root) return;\\n        root->val=val;\\n        if(!root->left && !root->right) {st.insert(val); maxi=max(maxi,val);}\\n        p(root->left,2*val+1);\\n        p(root->right,2*val+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        p(root,0);\\n    }\\n    \\n    bool find(int t) {\\n        queue<int>q;\\n        q.push(t);\\n        while(!q.empty()) {\\n            int k=q.front(); q.pop();\\n            if(st.find(k)!=st.end()) return 1;\\n            if((2*k+1) > maxi) continue;\\n            if((2*k+1) <=maxi) q.push(2*k+1);\\n            if((2*k+2) <= maxi) q.push(2*k+2);\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>st;\\n    int maxi=0;\\n    void p(TreeNode* root, int val) {\\n        if(!root) return;\\n        root->val=val;\\n        if(!root->left && !root->right) {st.insert(val); maxi=max(maxi,val);}\\n        p(root->left,2*val+1);\\n        p(root->right,2*val+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        p(root,0);\\n    }\\n    \\n    bool find(int t) {\\n        queue<int>q;\\n        q.push(t);\\n        while(!q.empty()) {\\n            int k=q.front(); q.pop();\\n            if(st.find(k)!=st.end()) return 1;\\n            if((2*k+1) > maxi) continue;\\n            if((2*k+1) <=maxi) q.push(2*k+1);\\n            if((2*k+2) <= maxi) q.push(2*k+2);\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708205,
                "title": "recursive-inorder-solution-c",
                "content": "# Intuition\\nUse inorder traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, recover the binary by given rule .\\nsecond, store elements in setby inorder traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nTreeNode* head=NULL;\\nset<int> st;\\n   void solv(TreeNode* root,set<int> &st){\\n       if(root==NULL){\\n           return;\\n       }\\n       solv(root->left,st);\\n       st.insert(root->val);\\n       solv(root->right,st);\\n   }\\n   void solve(TreeNode* &root){\\n       if(root==NULL){\\n           return;\\n       }\\n      if(root->left!=NULL){\\n          root->left->val=2*root->val+1;\\n          solve(root->left);\\n      }\\n      if(root->right!=NULL){\\n          root->right->val=2*root->val+2;\\n          solve(root->right);\\n      }\\n     \\n   }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL){\\n            root->val=0;\\n            solve(root);\\n            solv(root,st);\\n        }\\n        head=root;\\n    }\\n    \\n    bool find(int target) {\\n        if(head==NULL){\\n            return 0;\\n        }\\n       if(st.find(target)!=st.end()){\\n           return 1;\\n       }\\n       return 0;\\n    }\\n};\\n\\n*********************PLEASE UPVOTE IF FOUND USEFUL*********",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "# Intuition\\nUse inorder traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, recover the binary by given rule .\\nsecond, store elements in setby inorder traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nTreeNode* head=NULL;\\nset<int> st;\\n   void solv(TreeNode* root,set<int> &st){\\n       if(root==NULL){\\n           return;\\n       }\\n       solv(root->left,st);\\n       st.insert(root->val);\\n       solv(root->right,st);\\n   }\\n   void solve(TreeNode* &root){\\n       if(root==NULL){\\n           return;\\n       }\\n      if(root->left!=NULL){\\n          root->left->val=2*root->val+1;\\n          solve(root->left);\\n      }\\n      if(root->right!=NULL){\\n          root->right->val=2*root->val+2;\\n          solve(root->right);\\n      }\\n     \\n   }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL){\\n            root->val=0;\\n            solve(root);\\n            solv(root,st);\\n        }\\n        head=root;\\n    }\\n    \\n    bool find(int target) {\\n        if(head==NULL){\\n            return 0;\\n        }\\n       if(st.find(target)!=st.end()){\\n           return 1;\\n       }\\n       return 0;\\n    }\\n};\\n\\n*********************PLEASE UPVOTE IF FOUND USEFUL*********",
                "codeTag": "Java"
            },
            {
                "id": 3705988,
                "title": "easy-to-understand-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int, bool> elements;\\n    void dfs(TreeNode* root){\\n        if(root == NULL){\\n            return;\\n        }\\n        int x = root->val;\\n        elements[x] = true;\\n        if(root->left != NULL){\\n            root->left->val = x+x+1;\\n        }\\n        if(root->right != NULL){\\n            root->right->val = x+x+2;\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return elements[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int, bool> elements;\\n    void dfs(TreeNode* root){\\n        if(root == NULL){\\n            return;\\n        }\\n        int x = root->val;\\n        elements[x] = true;\\n        if(root->left != NULL){\\n            root->left->val = x+x+1;\\n        }\\n        if(root->right != NULL){\\n            root->right->val = x+x+2;\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return elements[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702949,
                "title": "c-bfs-binary-search-99-1-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int> vec;\\nint s;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(q.size()){\\n            TreeNode* temp=q.front();\\n            int x=temp->val;\\n            q.pop();\\n            vec.push_back(x);\\n            if(temp->left){\\n                temp->left->val=2*x+1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val=2*x+2;\\n                q.push(temp->right);\\n            }\\n        }\\n        s=vec.size();\\n    }\\n    \\n    bool find(int target) {\\n        int ind=lower_bound(vec.begin(),vec.end(),target)-vec.begin();\\n        if(ind<s && vec[ind]==target) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int> vec;\\nint s;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(q.size()){\\n            TreeNode* temp=q.front();\\n            int x=temp->val;\\n            q.pop();\\n            vec.push_back(x);\\n            if(temp->left){\\n                temp->left->val=2*x+1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val=2*x+2;\\n                q.push(temp->right);\\n            }\\n        }\\n        s=vec.size();\\n    }\\n    \\n    bool find(int target) {\\n        int ind=lower_bound(vec.begin(),vec.end(),target)-vec.begin();\\n        if(ind<s && vec[ind]==target) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693644,
                "title": "java-not-restoring-the-tree-just-deriving-and-following-the-path-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe don\\'t need to compute the values at all, given the formula we can trace back if, at each level in the tree, we have to go through the left or right subtree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGiven the formula, we know that odd values are in left subtree w.r.t. their parent, even values to the right.\\n\\nReworking the formula backward, we can derive the immediate predecessor in the path from root to target (e.g., (value - 1) / 2 for odd values, (value - 2) / 2 for even), in this way we can compute an array with the path root (index 0) to the target value (index equivalent to the depth at which the value lies).\\n\\nWith this array, we can, at each step, decide if we need to go left (odd value), or right (even value), and we just need to follow the right child of the tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N) for computing the target level, O(log N) for computing the array, O(log N) to traverse, still summing up to O(log N) in total.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe array for each requests is as long as the path, which is O(log N).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n    }\\n    \\n    public boolean find(int target) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (target == 0 && root != null) {\\n            return true;\\n        }\\n        \\n        // here we derive the depth where the target element is, knowing that 2^i elements are at level i\\n        int targetLevel = 0;\\n        for (int tot = 1; ; targetLevel++) {\\n            int left = tot - 1;\\n            int right = tot * 2 - 2;\\n            if (target >= left && target <= right) {\\n                break;\\n            }\\n            tot *= 2;\\n        }\\n\\n        // now we compute the path backwards with the reverse of the given formula\\n        int[] path = new int[targetLevel + 1];\\n        path[targetLevel] = target;\\n        for (int i = targetLevel - 1; i >= 0; i--) {\\n            path[i] = (path[i + 1] - (path[i + 1] % 2 != 0 ? 1 : 2)) / 2;\\n        }\\n\\n        // here we traverse the tree, guided by the array\\n        TreeNode curr = root;\\n        for (int i = 1; curr != null && i < path.length; i++) {\\n            boolean left = path[i] % 2 != 0;\\n            curr = left ? curr.left : curr.right;\\n        }\\n        // at the final step, we just need to check that the node is there, if it is, it\\'s our target\\n        return curr != null;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n    }\\n    \\n    public boolean find(int target) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (target == 0 && root != null) {\\n            return true;\\n        }\\n        \\n        // here we derive the depth where the target element is, knowing that 2^i elements are at level i\\n        int targetLevel = 0;\\n        for (int tot = 1; ; targetLevel++) {\\n            int left = tot - 1;\\n            int right = tot * 2 - 2;\\n            if (target >= left && target <= right) {\\n                break;\\n            }\\n            tot *= 2;\\n        }\\n\\n        // now we compute the path backwards with the reverse of the given formula\\n        int[] path = new int[targetLevel + 1];\\n        path[targetLevel] = target;\\n        for (int i = targetLevel - 1; i >= 0; i--) {\\n            path[i] = (path[i + 1] - (path[i + 1] % 2 != 0 ? 1 : 2)) / 2;\\n        }\\n\\n        // here we traverse the tree, guided by the array\\n        TreeNode curr = root;\\n        for (int i = 1; curr != null && i < path.length; i++) {\\n            boolean left = path[i] % 2 != 0;\\n            curr = left ? curr.left : curr.right;\\n        }\\n        // at the final step, we just need to check that the node is there, if it is, it\\'s our target\\n        return curr != null;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687184,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n    Set <Integer> values; \\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n        values = new HashSet();\\n        recover(root);\\n    }\\n\\n    private void recover(TreeNode root){\\n        values.add(root.val);\\n        if (root.left != null){\\n            root.left.val = 2*root.val +1;\\n            recover (root.left);\\n        }\\n        if (root.right != null){\\n            root.right.val = 2*root.val +2;\\n            recover (root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return values.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n    Set <Integer> values; \\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n        values = new HashSet();\\n        recover(root);\\n    }\\n\\n    private void recover(TreeNode root){\\n        values.add(root.val);\\n        if (root.left != null){\\n            root.left.val = 2*root.val +1;\\n            recover (root.left);\\n        }\\n        if (root.right != null){\\n            root.right.val = 2*root.val +2;\\n            recover (root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return values.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687083,
                "title": "java-dfs-preorder",
                "content": "```\\nclass FindElements {\\n    Set<Integer> elements;\\n    public FindElements(TreeNode root) {\\n        this.elements = new HashSet<>();\\n        root.val = 0;\\n        preorder(root);\\n    }\\n    \\n    private void preorder(TreeNode node) {\\n        if(node == null) return;\\n        this.elements.add(node.val);\\n        if(node.left != null) {\\n            node.left.val = 2*node.val + 1;\\n        }\\n        if(node.right != null) {\\n            node.right.val = 2*node.val + 2;\\n        }\\n        preorder(node.left);\\n        preorder(node.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return this.elements.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    Set<Integer> elements;\\n    public FindElements(TreeNode root) {\\n        this.elements = new HashSet<>();\\n        root.val = 0;\\n        preorder(root);\\n    }\\n    \\n    private void preorder(TreeNode node) {\\n        if(node == null) return;\\n        this.elements.add(node.val);\\n        if(node.left != null) {\\n            node.left.val = 2*node.val + 1;\\n        }\\n        if(node.right != null) {\\n            node.right.val = 2*node.val + 2;\\n        }\\n        preorder(node.left);\\n        preorder(node.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return this.elements.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679723,
                "title": "c-easy-fast-dfs-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* node;\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        node=root;\\n        solve(root);\\n    }\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n\\n        if(root->left!=NULL)\\n        {\\n            \\n            root->left->val=root->val*2+1;\\n            s.insert(root->left->val);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=root->val*2+2;\\n             s.insert(root->right->val);\\n        }\\n\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    \\n    bool find(int target) {\\n       return s.find(target)!=s.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* node;\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        node=root;\\n        solve(root);\\n    }\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n\\n        if(root->left!=NULL)\\n        {\\n            \\n            root->left->val=root->val*2+1;\\n            s.insert(root->left->val);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=root->val*2+2;\\n             s.insert(root->right->val);\\n        }\\n\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    \\n    bool find(int target) {\\n       return s.find(target)!=s.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672040,
                "title": "c-set-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void traverse(TreeNode* root){\\n       if(!root) return ;\\n       if(root->left){\\n           root->left->val=(2*root->val)+1;\\n           s.insert((2*root->val)+1);\\n           traverse(root->left);\\n       } \\n       if(root->right){\\n           root->right->val=(2*root->val)+2;\\n           s.insert((2*root->val)+2);\\n           traverse(root->right);\\n       } \\n    }\\n    FindElements(TreeNode* root) {\\n        s.insert(0);\\n        root->val=0;\\n        traverse(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target)!=s.end()){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void traverse(TreeNode* root){\\n       if(!root) return ;\\n       if(root->left){\\n           root->left->val=(2*root->val)+1;\\n           s.insert((2*root->val)+1);\\n           traverse(root->left);\\n       } \\n       if(root->right){\\n           root->right->val=(2*root->val)+2;\\n           s.insert((2*root->val)+2);\\n           traverse(root->right);\\n       } \\n    }\\n    FindElements(TreeNode* root) {\\n        s.insert(0);\\n        root->val=0;\\n        traverse(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target)!=s.end()){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662753,
                "title": "recursive-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\nTreeNode * root1;\\nvoid solve(TreeNode* root,int target,bool &ans)\\n{\\n  if(root==NULL)return;\\n  if(root==root1)root->val=0;\\n  if(root->val==target)ans=1;\\n  if(root->left)\\n  {\\n    root->left->val=(2*root->val)+1;\\n  }\\n   if(root->right)\\n  {\\n    root->right->val=(2*root->val)+2;\\n  }\\n  solve(root->left,target,ans);\\n  solve(root->right,target,ans);\\n\\n}\\npublic:\\n    FindElements(TreeNode* root) {\\n       if(root==NULL)return;\\n       root1=root;\\n       root->val=-1;\\n       FindElements(root->right);\\n       FindElements(root->left);\\n    }\\n    \\n    bool find(int target) {\\n        int initial=0;\\n        bool ans=0;\\n        solve(root1,target,ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\nTreeNode * root1;\\nvoid solve(TreeNode* root,int target,bool &ans)\\n{\\n  if(root==NULL)return;\\n  if(root==root1)root->val=0;\\n  if(root->val==target)ans=1;\\n  if(root->left)\\n  {\\n    root->left->val=(2*root->val)+1;\\n  }\\n   if(root->right)\\n  {\\n    root->right->val=(2*root->val)+2;\\n  }\\n  solve(root->left,target,ans);\\n  solve(root->right,target,ans);\\n\\n}\\npublic:\\n    FindElements(TreeNode* root) {\\n       if(root==NULL)return;\\n       root1=root;\\n       root->val=-1;\\n       FindElements(root->right);\\n       FindElements(root->left);\\n    }\\n    \\n    bool find(int target) {\\n        int initial=0;\\n        bool ans=0;\\n        solve(root1,target,ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660362,
                "title": "dfs-set-beats-100",
                "content": "\\tclass FindElements:                   \\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val=0\\n        self.st=set()\\n        \\n        def depth(root):\\n            if not root:\\n                return None\\n\\n            self.st.add(root.val)\\n            if root.left:\\n                root.left.val=2*root.val+1\\n                \\n            if root.right:\\n                 root.right.val=2*root.val+2\\n\\n            depth(root.left)\\n            depth(root.right)\\n            \\n        depth(root)  \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.st\\n\\n![image](https://assets.leetcode.com/users/images/c0190ecf-6719-4002-a400-825aec3121a1_1687245876.3178642.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass FindElements:                   \\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val=0\\n        self.st=set()\\n        \\n        def depth(root):\\n            if not root:\\n                return None\\n\\n            self.st.add(root.val)\\n            if root.left:\\n                root.left.val=2*root.val+1\\n                \\n            if root.right:\\n                 root.right.val=2*root.val+2\\n\\n            depth(root.left)\\n            depth(root.right)\\n            \\n        depth(root)  \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.st\\n\\n![image](https://assets.leetcode.com/users/images/c0190ecf-6719-4002-a400-825aec3121a1_1687245876.3178642.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3654585,
                "title": "dfs-hashset-c-100-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***There are two approaches in which this can be solved.***\\n\\n- We can avoid \\'Recover\\' of the tree. But everytime we want to Find a value, we would need to traverse the contaminated tree via BFS to find possibility of existance of the target element.\\n- We can recover the contaminated tree and everytime we recover a node, we\\'ll add it\\'s value to a HashSet. With this the Find can work in O(1).\\n-*<b>If we wish not to use a HashSet, then we can \"Find\" via BFS efficiently compared to DFS</b>. Because, since the elements will be ordered at each level (top-to-bottom + left-to-right), we can conclude that the target element is not present if we encounter any element whose value is greater than our target. The same cannot be concluded via DFS.*\\n\\n![Screenshot 2023-06-19 084844.png](https://assets.leetcode.com/users/images/28d70aee-77ce-4759-9af4-fb451bcf67ad_1687144782.9810998.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) - Recover - as we need to visit every node of the contaminated tree.\\nO(1) - Find\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - as we use a HashSet\\n*if we wish not use a hashset, we can search via DFS with O(1) space complexity and O(N) runtime complexity*\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\npublic class FindElements {\\n    TreeNode root;\\n    HashSet<int> h;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        h = new HashSet<int>();\\n        RecoverNode(root, 0);\\n    }\\n\\n    private void RecoverNode(TreeNode node, int val)\\n    {\\n        //recover via DFS\\n        if (node == null)\\n            return;\\n\\n        h.Add(val);\\n        node.val = val;\\n        RecoverNode(node.left, 2*val + 1);\\n        RecoverNode(node.right, 2*val + 2);\\n    }\\n    \\n    public bool Find(int target) {\\n        return h.Contains(target);\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\npublic class FindElements {\\n    TreeNode root;\\n    HashSet<int> h;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        h = new HashSet<int>();\\n        RecoverNode(root, 0);\\n    }\\n\\n    private void RecoverNode(TreeNode node, int val)\\n    {\\n        //recover via DFS\\n        if (node == null)\\n            return;\\n\\n        h.Add(val);\\n        node.val = val;\\n        RecoverNode(node.left, 2*val + 1);\\n        RecoverNode(node.right, 2*val + 2);\\n    }\\n    \\n    public bool Find(int target) {\\n        return h.Contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641333,
                "title": "very-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int>v;\\n    FindElements(TreeNode* root) {\\n        if (!root)\\n            return;\\n        root->val=0;\\n        recovery(root);\\n    }\\n    void recovery(TreeNode* root)\\n    {\\n        if (!root)  \\n            return;\\n        if (root->left)\\n        {\\n            root->left->val=(2*root->val)+1;\\n        }\\n        if (root->right)\\n        {\\n            root->right->val=(2*root->val)+2;\\n        }\\n        recovery(root->left);\\n        recovery(root->right);\\n        v.push_back(root->val);\\n    }\\n    bool find(int target) {\\n      for (auto c:v)\\n        {\\n            if (c==target)\\n                return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int>v;\\n    FindElements(TreeNode* root) {\\n        if (!root)\\n            return;\\n        root->val=0;\\n        recovery(root);\\n    }\\n    void recovery(TreeNode* root)\\n    {\\n        if (!root)  \\n            return;\\n        if (root->left)\\n        {\\n            root->left->val=(2*root->val)+1;\\n        }\\n        if (root->right)\\n        {\\n            root->right->val=(2*root->val)+2;\\n        }\\n        recovery(root->left);\\n        recovery(root->right);\\n        v.push_back(root->val);\\n    }\\n    bool find(int target) {\\n      for (auto c:v)\\n        {\\n            if (c==target)\\n                return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605244,
                "title": "c-solution-with-back-traverse",
                "content": "# Intuition\\nWe can go without recovering tree by builing backward path.\\n\\n# Approach\\nleft - odd number\\nright - even number\\nwith this precondition we can rebuild a path for the target value.\\n# Code\\n```\\npublic class FindElements {\\n\\n    private readonly TreeNode _root;\\n\\n    public FindElements(TreeNode root) {\\n        _root = root;   \\n    }\\n    \\n    public bool Find(int target) {\\n        if(target == 0)\\n        {\\n            return _root != null;\\n        }\\n\\n        var path = new int[(int)Math.Log(target + 1, 2)];\\n        path[path.Length - 1] = target;\\n        for(var i = path.Length - 2; i >= 0; i--)\\n        {\\n            path[i] = path[i+1] % 2 == 0 ? (path[i+1] - 2)/2 : (path[i+1] - 1)/2;\\n        }\\n        \\n        var node = _root;\\n        foreach(var p in path)\\n        {\\n            node = p % 2 == 0 ? node.right : node.left;\\n\\n            if(node == null)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "C#"
                ],
                "code": "# Intuition\\nWe can go without recovering tree by builing backward path.\\n\\n# Approach\\nleft - odd number\\nright - even number\\nwith this precondition we can rebuild a path for the target value.\\n# Code\\n```\\npublic class FindElements {\\n\\n    private readonly TreeNode _root;\\n\\n    public FindElements(TreeNode root) {\\n        _root = root;   \\n    }\\n    \\n    public bool Find(int target) {\\n        if(target == 0)\\n        {\\n            return _root != null;\\n        }\\n\\n        var path = new int[(int)Math.Log(target + 1, 2)];\\n        path[path.Length - 1] = target;\\n        for(var i = path.Length - 2; i >= 0; i--)\\n        {\\n            path[i] = path[i+1] % 2 == 0 ? (path[i+1] - 2)/2 : (path[i+1] - 1)/2;\\n        }\\n        \\n        var node = _root;\\n        foreach(var p in path)\\n        {\\n            node = p % 2 == 0 ? node.right : node.left;\\n\\n            if(node == null)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3587328,
                "title": "c-simple-and-interesting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n->To implement this, I chose to use a depth-first traversal of the binary tree. Starting from the root node, I assign the value 0 to the root and recursively recover the values of the left and right subtrees based on the parent node\\'s value.\\n\\n->During the recovery process, I store the recovered values in an unordered set (values) to enable efficient lookup in the find method.\\n\\n->The expression values.count(target) > 0 compares the result of values.count(target) with 0. If the count is greater than 0, it means that the target value was found in the set, which gives us true. Otherwise, if the count is 0, it means that the target value is not present in the set, and we can return false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS and Unordered_set\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    private:\\n    unordered_set<int>values;  // Using set to remove duplicacy.\\npublic:\\n    FindElements(TreeNode* root) {\\n        if(root->val!=NULL)\\n        {\\n            root->val=0; //  So as the statement is asking you if root is not null then make it null.\\n            recoverTree(root);\\n        }\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        values.insert(root->val); // insert values inside set\\n        if(root->left!=NULL)\\n        {\\n          root->left->val=2*root->val+1;\\n          recoverTree(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            recoverTree(root->right);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return values.count(target)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    private:\\n    unordered_set<int>values;  // Using set to remove duplicacy.\\npublic:\\n    FindElements(TreeNode* root) {\\n        if(root->val!=NULL)\\n        {\\n            root->val=0; //  So as the statement is asking you if root is not null then make it null.\\n            recoverTree(root);\\n        }\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        values.insert(root->val); // insert values inside set\\n        if(root->left!=NULL)\\n        {\\n          root->left->val=2*root->val+1;\\n          recoverTree(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            recoverTree(root->right);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return values.count(target)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585307,
                "title": "c-searching-in-tree",
                "content": "```\\nclass FindElements {\\npublic:\\n    TreeNode* root = nullptr;\\n    FindElements(TreeNode* root) {\\n        this->root = root;\\n    }\\n    bool find(int target) {\\n        vector<bool> path;\\n        int targetCopy = target;\\n        while(targetCopy) {\\n            if (targetCopy % 2 == 0) {\\n                path.push_back(true);\\n                targetCopy -= 2;\\n            } else {\\n                path.push_back(false);\\n                targetCopy -= 1;\\n            }\\n            targetCopy /= 2;\\n        }\\n        TreeNode* head = root;\\n        for(auto it = path.rbegin(); it != path.rend(); it++) {\\n            if (head == nullptr) {\\n                return false;\\n            }\\n            if (*it) {\\n                head = head->right;\\n            } else {\\n                head = head->left;\\n            }\\n        }\\n        return head ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    TreeNode* root = nullptr;\\n    FindElements(TreeNode* root) {\\n        this->root = root;\\n    }\\n    bool find(int target) {\\n        vector<bool> path;\\n        int targetCopy = target;\\n        while(targetCopy) {\\n            if (targetCopy % 2 == 0) {\\n                path.push_back(true);\\n                targetCopy -= 2;\\n            } else {\\n                path.push_back(false);\\n                targetCopy -= 1;\\n            }\\n            targetCopy /= 2;\\n        }\\n        TreeNode* head = root;\\n        for(auto it = path.rbegin(); it != path.rend(); it++) {\\n            if (head == nullptr) {\\n                return false;\\n            }\\n            if (*it) {\\n                head = head->right;\\n            } else {\\n                head = head->left;\\n            }\\n        }\\n        return head ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584270,
                "title": "solution",
                "content": "```C++ []\\nclass FindElements {\\n public:\\n  FindElements(TreeNode* root) {\\n    dfs(root, 0);\\n  }\\n  bool find(int target) {\\n    return vals.count(target);\\n  }\\n private:\\n  unordered_set<int> vals;\\n\\n  void dfs(TreeNode* root, int val) {\\n    if (root == nullptr)\\n      return;\\n\\n    root->val = val;\\n    vals.insert(val);\\n    dfs(root->left, val * 2 + 1);\\n    dfs(root->right, val * 2 + 2);\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass FindElements:\\n    node_list = None\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node_list = set()\\n        root.val = 0\\n        self.node_list.add(root.val)\\n        myq = collections.deque([root])\\n        l_val = 0\\n        r_val = 0\\n\\n        while myq:\\n            lvl_size = len(myq)\\n           \\n            for _ in range(0, lvl_size):\\n                node = myq.popleft()\\n                x = node.val\\n                \\n                if node.left:\\n                    l_val = 2 * x + 1\\n                    node.left.val = l_val\\n                    myq.append(node.left)\\n                    self.node_list.add(node.left.val)\\n\\n                if node.right:\\n                    r_val = 2 * x + 2\\n                    node.right.val = r_val\\n                    myq.append(node.right)\\n                    self.node_list.add(node.right.val)\\n            \\n    def f(self, target: int) -> bool:\\n        if target in self.node_list:\\n            return True\\n\\n    def find(self, target: int) -> bool:\\n        return self.f(target)\\n```\\n\\n```Java []\\nclass FindElements {\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root=root;\\n    }\\n    public boolean find(int target) {\\n        target++;\\n        int high=high(target);\\n        TreeNode cur=root;\\n        high=high>>1;\\n        while(high>0){\\n            int bit=target&high;\\n            high=high>>1;\\n            if(bit!=0&&cur.right!=null){\\n                cur=cur.right;\\n            }else if(bit==0&&cur.left!=null){\\n                cur=cur.left;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int high(long target){\\n        target=target|target>>1;\\n        target=target|target>>2;\\n        target=target|target>>4;\\n        target=target|target>>8;\\n        target=target|target>>16;\\n        return (int)((target+1)>>1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass FindElements {\\n public:\\n  FindElements(TreeNode* root) {\\n    dfs(root, 0);\\n  }\\n  bool find(int target) {\\n    return vals.count(target);\\n  }\\n private:\\n  unordered_set<int> vals;\\n\\n  void dfs(TreeNode* root, int val) {\\n    if (root == nullptr)\\n      return;\\n\\n    root->val = val;\\n    vals.insert(val);\\n    dfs(root->left, val * 2 + 1);\\n    dfs(root->right, val * 2 + 2);\\n  }\\n};\\n```\n```Python3 []\\nclass FindElements:\\n    node_list = None\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node_list = set()\\n        root.val = 0\\n        self.node_list.add(root.val)\\n        myq = collections.deque([root])\\n        l_val = 0\\n        r_val = 0\\n\\n        while myq:\\n            lvl_size = len(myq)\\n           \\n            for _ in range(0, lvl_size):\\n                node = myq.popleft()\\n                x = node.val\\n                \\n                if node.left:\\n                    l_val = 2 * x + 1\\n                    node.left.val = l_val\\n                    myq.append(node.left)\\n                    self.node_list.add(node.left.val)\\n\\n                if node.right:\\n                    r_val = 2 * x + 2\\n                    node.right.val = r_val\\n                    myq.append(node.right)\\n                    self.node_list.add(node.right.val)\\n            \\n    def f(self, target: int) -> bool:\\n        if target in self.node_list:\\n            return True\\n\\n    def find(self, target: int) -> bool:\\n        return self.f(target)\\n```\n```Java []\\nclass FindElements {\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root=root;\\n    }\\n    public boolean find(int target) {\\n        target++;\\n        int high=high(target);\\n        TreeNode cur=root;\\n        high=high>>1;\\n        while(high>0){\\n            int bit=target&high;\\n            high=high>>1;\\n            if(bit!=0&&cur.right!=null){\\n                cur=cur.right;\\n            }else if(bit==0&&cur.left!=null){\\n                cur=cur.left;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int high(long target){\\n        target=target|target>>1;\\n        target=target|target>>2;\\n        target=target|target>>4;\\n        target=target|target>>8;\\n        target=target|target>>16;\\n        return (int)((target+1)>>1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580493,
                "title": "easiest-sol-c-recursion-binary-tree",
                "content": "# Intuition\\ni stored all the recovered elements in a map and then checked whether they are present or not and returned the bool value\\n\\n# Approach\\nmade a build function with index and TreeNode and if its value was -1 then i stored the node with its real value else ignored it and later in the find function just checked whether element was present or not \\n\\n# Complexity\\n- Time complexity:\\nO(n) \\n\\n- Space complexity:\\nO(n)re\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int,int> m;\\n   void build(int i,TreeNode* root){\\n       if(root==nullptr){\\n           return;\\n       }\\n       m[i]++;\\n       build(2*i+1,root->left);\\n       build(2*i+2,root->right);\\n   }\\n    FindElements(TreeNode* root) {\\n        if(root==nullptr){\\n            return ;\\n        }\\n        build(0,root);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int,int> m;\\n   void build(int i,TreeNode* root){\\n       if(root==nullptr){\\n           return;\\n       }\\n       m[i]++;\\n       build(2*i+1,root->left);\\n       build(2*i+2,root->right);\\n   }\\n    FindElements(TreeNode* root) {\\n        if(root==nullptr){\\n            return ;\\n        }\\n        build(0,root);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575305,
                "title": "c-2-different-approaches-with-code-explanation-1-runtime-efficient-2-space-efficient",
                "content": "# Intuition\\nI tried to explain both the basic approaches that I did + codes are below, please upvote if you find this helpful : )\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nFirst approach is having better runtime (better than 90%) as it uses set and we dont have to search in the tree to find hence it saves recursion stack calling, but uses  extra space.\\n\\n# Approach 2 \\n\\nThis approach is having better memory control (better than 90% ), it uses basic methods which saves extra space but the runtime is slower, so have a loook at both\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->Approach 1\\nO(N) in both cases\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nrecursive internal stack and set in approach 1\\n\\n# Code\\n```\\nAPPROACH 1\\n\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        s.insert(node->val);\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);     \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        recoverTree(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n\\n*************************************\\n\\n\\nAPPROACH 2\\n\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);\\n            \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        head = root;\\n        recoverTree(root);\\n    }\\n    bool findInTree(TreeNode *root, int target,bool isFound){\\n        if(root == NULL)\\n            return false;\\n        if(root->val == target)\\n        {\\n            isFound = true;\\n            return true;\\n        }\\n        if(isFound == false)\\n            return findInTree(root->left, target,isFound) || findInTree(root->right,target,isFound);\\n        return false;\\n    }\\n    bool find(int target) {\\n        bool isFound = false;\\n        return findInTree(head, target,isFound);\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nAPPROACH 1\\n\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        s.insert(node->val);\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);     \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        recoverTree(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n\\n*************************************\\n\\n\\nAPPROACH 2\\n\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);\\n            \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        head = root;\\n        recoverTree(root);\\n    }\\n    bool findInTree(TreeNode *root, int target,bool isFound){\\n        if(root == NULL)\\n            return false;\\n        if(root->val == target)\\n        {\\n            isFound = true;\\n            return true;\\n        }\\n        if(isFound == false)\\n            return findInTree(root->left, target,isFound) || findInTree(root->right,target,isFound);\\n        return false;\\n    }\\n    bool find(int target) {\\n        bool isFound = false;\\n        return findInTree(head, target,isFound);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566938,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "```\\nvar FindElements = function(root) {\\n    this.treeSet = new Set();\\n\\n    const dfsTree = (node = root, parent = 0, add = 0) => {\\n        if (!node) return;\\n        const { left, right } = node;\\n        const value = parent * 2 + add;\\n\\n        this.treeSet.add(value);\\n        dfsTree(left, value, 1);\\n        dfsTree(right, value, 2);\\n    };\\n\\n    dfsTree();\\n};\\n\\nFindElements.prototype.find = function(target) {\\n    return this.treeSet.has(target);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar FindElements = function(root) {\\n    this.treeSet = new Set();\\n\\n    const dfsTree = (node = root, parent = 0, add = 0) => {\\n        if (!node) return;\\n        const { left, right } = node;\\n        const value = parent * 2 + add;\\n\\n        this.treeSet.add(value);\\n        dfsTree(left, value, 1);\\n        dfsTree(right, value, 2);\\n    };\\n\\n    dfsTree();\\n};\\n\\nFindElements.prototype.find = function(target) {\\n    return this.treeSet.has(target);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566522,
                "title": "c-easiest-solution-recursive",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    void solve(TreeNode* &root, int data, unordered_map<int,int> &m){\\n        // base case\\n        if(!root) return;\\n\\n        root->val = data;\\n        m[data]++;\\n\\n        solve(root->left, data*2+1, m);\\n        solve(root->right, data*2+2, m);\\n    }\\npublic:\\n    unordered_map<int,int> m;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        m[0]++;\\n        solve(root->left,1,m);\\n        solve(root->right,2,m);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()) return 1;\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    void solve(TreeNode* &root, int data, unordered_map<int,int> &m){\\n        // base case\\n        if(!root) return;\\n\\n        root->val = data;\\n        m[data]++;\\n\\n        solve(root->left, data*2+1, m);\\n        solve(root->right, data*2+2, m);\\n    }\\npublic:\\n    unordered_map<int,int> m;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        m[0]++;\\n        solve(root->left,1,m);\\n        solve(root->right,2,m);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()) return 1;\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574006,
                "content": [
                    {
                        "username": "sushobh",
                        "content": "There are quite a few problems out there which are tagged easy but are should be medium.\\nThis one is the opposite , it should have been easy. Most people are familiar with tree traversal\\nand so i don\\'t understand why this should be tagged medium considering some of the tough medium problems i have solved."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It\\'s trivial if you save the existing values with a hashset for queries. But requires some work otherwise."
                    },
                    {
                        "username": "ashvaibhav",
                        "content": "![image](https://assets.leetcode.com/users/ashvaibhav/image_1573963660.png)\\nFor even simple test cases like:\\n\\n[\"FindElements\",\"find\",\"find\"]\\n[[[-1,null,-1]],[1],[2]]\\n"
                    },
                    {
                        "username": "0icy",
                        "content": "if you are allowed to use hashset this q shld be ez"
                    }
                ]
            },
            {
                "id": 1573193,
                "content": [
                    {
                        "username": "sushobh",
                        "content": "There are quite a few problems out there which are tagged easy but are should be medium.\\nThis one is the opposite , it should have been easy. Most people are familiar with tree traversal\\nand so i don\\'t understand why this should be tagged medium considering some of the tough medium problems i have solved."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It\\'s trivial if you save the existing values with a hashset for queries. But requires some work otherwise."
                    },
                    {
                        "username": "ashvaibhav",
                        "content": "![image](https://assets.leetcode.com/users/ashvaibhav/image_1573963660.png)\\nFor even simple test cases like:\\n\\n[\"FindElements\",\"find\",\"find\"]\\n[[[-1,null,-1]],[1],[2]]\\n"
                    },
                    {
                        "username": "0icy",
                        "content": "if you are allowed to use hashset this q shld be ez"
                    }
                ]
            },
            {
                "id": 2020758,
                "content": [
                    {
                        "username": "sushobh",
                        "content": "There are quite a few problems out there which are tagged easy but are should be medium.\\nThis one is the opposite , it should have been easy. Most people are familiar with tree traversal\\nand so i don\\'t understand why this should be tagged medium considering some of the tough medium problems i have solved."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It\\'s trivial if you save the existing values with a hashset for queries. But requires some work otherwise."
                    },
                    {
                        "username": "ashvaibhav",
                        "content": "![image](https://assets.leetcode.com/users/ashvaibhav/image_1573963660.png)\\nFor even simple test cases like:\\n\\n[\"FindElements\",\"find\",\"find\"]\\n[[[-1,null,-1]],[1],[2]]\\n"
                    },
                    {
                        "username": "0icy",
                        "content": "if you are allowed to use hashset this q shld be ez"
                    }
                ]
            }
        ]
    },
    {
        "title": "Greatest Sum Divisible by Three",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>the <strong>maximum possible sum </strong>of elements of the array such that it is divisible by three</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,5,1,8]\n<strong>Output:</strong> 18\n<strong>Explanation:</strong> Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Since 4 is not divisible by 3, do not pick any number.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,4]\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 431077,
                "title": "java-c-python-one-pass-o-1-space",
                "content": "# **Explanation**\\ndp[0] = largest sum which is divisible by 3\\ndp[1] = largest sum when divided by 3, remainder = 1\\ndp[2] = largest sum when divided by 3, remainder = 2\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java\\n```java\\n    public int maxSumDivThree(int[] A) {\\n        int[] dp = new int[3];\\n        for (int a : A)\\n            for (int i: Arrays.copyOf(dp, dp.length))\\n                dp[(i + a) % 3] = Math.max(dp[(i + a) % 3], i + a);\\n        return dp[0];\\n    }\\n```\\n**C++**\\n```cpp\\n    int maxSumDivThree(vector<int>& A) {\\n        vector<int> dp(3);\\n        for (int a : A)\\n            for (int i : vector<int>(dp))\\n                dp[(i + a) % 3] = max(dp[(i + a) % 3], i + a);\\n        return dp[0];\\n    }\\n```\\n**Python:**\\n```python\\n    def maxSumDivThree(self, A):\\n        dp = [0, 0, 0]\\n        for a in A:\\n            for i in dp[:]:\\n                dp[(i + a) % 3] = max(dp[(i + a) % 3], i + a)\\n        return dp[0]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxSumDivThree(int[] A) {\\n        int[] dp = new int[3];\\n        for (int a : A)\\n            for (int i: Arrays.copyOf(dp, dp.length))\\n                dp[(i + a) % 3] = Math.max(dp[(i + a) % 3], i + a);\\n        return dp[0];\\n    }\\n```\n```cpp\\n    int maxSumDivThree(vector<int>& A) {\\n        vector<int> dp(3);\\n        for (int a : A)\\n            for (int i : vector<int>(dp))\\n                dp[(i + a) % 3] = max(dp[(i + a) % 3], i + a);\\n        return dp[0];\\n    }\\n```\n```python\\n    def maxSumDivThree(self, A):\\n        dp = [0, 0, 0]\\n        for a in A:\\n            for i in dp[:]:\\n                dp[(i + a) % 3] = max(dp[(i + a) % 3], i + a)\\n        return dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431108,
                "title": "java-o-n-solution-simple-math-o-1-space",
                "content": "Add all together, if sum%3==0, return sum. \\nif sum%3==1, remove the smallest number which has n%3==1.\\nif sum%3==2, remove the smallest number which has n%3==2.\\n\\none pass, and we need to keep the smallest two numbers that have n1%3==1 and n2%3==2.\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int res = 0, leftOne = 20000, leftTwo = 20000;\\n        for(int n:nums){\\n            res+=n;\\n            if(n%3==1){\\n                leftTwo = Math.min(leftTwo,leftOne+n);\\n                leftOne = Math.min(leftOne,n);\\n            }\\n            if(n%3==2) {\\n                leftOne = Math.min(leftOne,leftTwo+n);\\n                leftTwo = Math.min(leftTwo,n);\\n            }\\n        }\\n        if(res%3==0) return res;\\n        if(res%3==1) return res-leftOne;\\n        return res - leftTwo;\\n        \\n    }\\n}\\n```\\nDp solution for K problem:\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivK(nums,3);\\n    }\\n    public int maxSumDivK(int[] nums, int k){\\n        if(k==0) return -1;\\n        int[] dp = new int[k];\\n        for(int num : nums){\\n            int tmp[] = Arrays.copyOf(dp,k);\\n            for(int i=0;i<k;i++){\\n                dp[(num+tmp[i])%k] = Math.max(dp[(num+tmp[i])%k],num+tmp[i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int res = 0, leftOne = 20000, leftTwo = 20000;\\n        for(int n:nums){\\n            res+=n;\\n            if(n%3==1){\\n                leftTwo = Math.min(leftTwo,leftOne+n);\\n                leftOne = Math.min(leftOne,n);\\n            }\\n            if(n%3==2) {\\n                leftOne = Math.min(leftOne,leftTwo+n);\\n                leftTwo = Math.min(leftTwo,n);\\n            }\\n        }\\n        if(res%3==0) return res;\\n        if(res%3==1) return res-leftOne;\\n        return res - leftTwo;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivK(nums,3);\\n    }\\n    public int maxSumDivK(int[] nums, int k){\\n        if(k==0) return -1;\\n        int[] dp = new int[k];\\n        for(int num : nums){\\n            int tmp[] = Arrays.copyOf(dp,k);\\n            for(int i=0;i<k;i++){\\n                dp[(num+tmp[i])%k] = Math.max(dp[(num+tmp[i])%k],num+tmp[i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559999,
                "title": "come-here-if-you-can-t-seem-to-get-it-full-explanation-uncondensed-code",
                "content": "I originally couldn\\'t understand the logic because many of the solutions combine handling the transitioning between states cleverly using math. I\\'ll attempt to explain exactly whats happening and how we\\'re going to track this state. \\n\\nSo the state here is `dp[i][m]`. `dp[i][m]` = largest sum from a subset of `nums[:i]` such that the sum % 3 equals m. After defining this we loop thru each number in `nums`. At each number we mod it by 3 and see what the result is. \\n\\nFor example, lets say the current number (`nums[i]`) we\\'re looking at is 4. 4 % 3 = 1. So what does this mean? For each of the states we\\'re tracking (`dp[i][0]`, `dp[i][1]`, `dp[i][2]`) how can we use this? If we add a number with remainder 1 to a sum with remainder 1 what do we get? We get a number with remainder 2. So we can use this info to construct the answer!\\n\\n**Example: If nums[i] % 3 == 1. We have remainder 1. How can we use this?:**\\n* For `dp[i][0]` we want a remainder of 0. How do we get this given we currently have a remainder of 1? We can add this number with remainder 1 to a sum with remainder 2. This creates an overall remainder of 0 as 2 + 1 = 3\\n* For `dp[i][1]` we want a remainder of 1. This means we can add this number to `dp[i-1][0]`. This will give an overall remainder of 1 (num_with_remainder_0 + num_with_remainder_1) % 3 = 1.\\n* For `dp[i][2]` we do the same thing. We can add the number to `dp[i][1]`. Why? If you\\'ve been following you can probably answer now.\\n\\nWe do this for each of the three cases:\\n1. if num % 3 == 0\\n2. if num % 3 == 1\\n3. if num % 3 == 2\\n\\nAnd we\\'re done.\\n\\n```\\ndef maxSumDivThree(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\tdp = [[0]*3 for _ in range(n+1)]\\n\\tdp[0][1] = float(\\'-inf\\')\\n\\tdp[0][2] = float(\\'-inf\\')\\n\\tfor i in range(1, n+1):\\n\\t\\tif nums[i-1] % 3 == 0: # Current remainder == 0\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][0] to keep the remainder 0\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][1] to keep the remainder 1\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][2] to keep the remainder 2\\n\\t\\telif nums[i-1] % 3 == 1: # Current remainder == 1\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][2] to keep the remainder 0\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][0] to keep the remainder 1\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][1] to keep the remainder 2\\n\\t\\telse: # Current remainder == 2\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1]) # Can you tell how this works now?\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1])\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1])\\n\\n\\treturn dp[-1][0]\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef maxSumDivThree(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\tdp = [[0]*3 for _ in range(n+1)]\\n\\tdp[0][1] = float(\\'-inf\\')\\n\\tdp[0][2] = float(\\'-inf\\')\\n\\tfor i in range(1, n+1):\\n\\t\\tif nums[i-1] % 3 == 0: # Current remainder == 0\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][0] to keep the remainder 0\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][1] to keep the remainder 1\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][2] to keep the remainder 2\\n\\t\\telif nums[i-1] % 3 == 1: # Current remainder == 1\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][2] to keep the remainder 0\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][0] to keep the remainder 1\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][1] to keep the remainder 2\\n\\t\\telse: # Current remainder == 2\\n\\t\\t\\tdp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1]) # Can you tell how this works now?\\n\\t\\t\\tdp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1])\\n\\t\\t\\tdp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1])\\n\\n\\treturn dp[-1][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 927253,
                "title": "step-by-step-top-down-bottom-up-optimised-dp-u-should-do-a-recursive-solution-first",
                "content": "To solve this problem, **we find the subsets of the given array and check if the `subset sum` is divisible by 3, if so pick the largest `subset sum`**\\n\\nFinding subsets sum is not hard,  just tweak the solution of [78. Subsets](https://leetcode.com/problems/subsets/).\\n\\nCreate a basic form of the recurisve solution, build the solution on top of this\\n\\n```javascript\\nfunction rc (nums, index = 0, currentSum = 0) { // O(2^n)\\n    if (index >= nums.length) return currentSum % 3 ? -Infinity : currentSum; // if not divisible by 3, ignore its value by returning the smallest possible number\\n    return Math.max( // return subset sum\\n        rc(nums, index + 1, currentSum + nums[index]), // use current number\\n        rc(nums, index + 1, currentSum) // skip current number\\n    )\\n}\\n```\\n\\n**The problem now is \"find a way to cache the results at each index\". `dp[index][currentSum]` is not going to help as there are too many `currentSum` values**\\n\\n**Let\\'s find another way to get `subset sum` and keep only the those divisible by 3. Instead of passing `currentSum` to the function, we can pass the `reminder`. If the final reminder is not zero, we ignore the `subset sum`.**\\n\\n```javascript\\nfunction rc (nums, index = 0, remainder = 0) { // O(2^n)\\n    if (index >= nums.length) return remainder ? -Infinity : 0; // \\n    return Math.max( // subset sum = current number + max subset sum from next index OR skip the current number\\n        nums[index] + rc(nums, index + 1, (remainder + nums[index]) % 3), // calculate the new reminder after using the current number\\n        rc(nums, index + 1, remainder) // skip the current number\\n    )\\n}\\n```\\n\\n**Results now look cachable, there are only 3 possible reminders at each index, we will get O(3n) complexity if we cache/memoise them**\\n\\n```javascript\\nfunction rc (nums, index = 0, remainder = 0, memo = {}) { \\n    if (index >= nums.length) return remainder ? -Infinity : 0;\\n\\n    const memoKey = `${index},${remainder}`;\\n    if (memo[memoKey] !== undefined) return memo[memoKey] ;\\n    \\n    return memo[memoKey] = Math.max(\\n        nums[index] + rc(nums, index + 1, (remainder + nums[index]) % 3, memo),\\n        rc(nums, index + 1, remainder , memo)\\n    )\\n}\\n```\\n\\n**You have a DP solution already, now you want the fancy iterative DP arrays. All you need to do is just translate the recursive solution.**\\n\\n```javascript\\nfunction dp (nums) {\\n    const dp = Array(nums.length + 1).fill(0).map(\\n        () => Array(3).fill(0).map(\\n            (_, remainder) => remainder ? -Infinity : 0\\n        )\\n    );\\n   \\n    for (let i = 1; i <= nums.length; i++) {\\n        for (let r = 0; r < 3; r++) {\\n            dp[i][r] = Math.max( // who cares about what dp[i][r] means, this is a direct translation from the recursive solution which is far easier to understand. \\n                nums[i - 1] + dp[i - 1][(r + nums[i - 1]) % 3],\\n                dp[i - 1][r]\\n            )\\n        }\\n    }\\n    \\n    return dp[nums.length][0]\\n}\\n```\\n\\n**now, you can create the optimised O(n) O(1) dp**\\n\\n```javascript\\nfunction dp2 (nums) { \\n\\t// only dp[i - 1] is needed for calculatiing the next result, we just need two variables instead of an array\\n    const current = Array(3).fill(0).map((_, remainder) => remainder ? -Infinity : 0);\\n   \\n    for (let i = 0; i < nums.length; i++) {\\n        const previous = current.slice();\\n        for (let r = 0; r < 3; r++) {\\n            current[r] = Math.max(nums[i] + previous[(r + nums[i]) % 3], previous[r]);\\n        }\\n    }\\n    \\n    return current[0]\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```javascript\\nfunction rc (nums, index = 0, currentSum = 0) { // O(2^n)\\n    if (index >= nums.length) return currentSum % 3 ? -Infinity : currentSum; // if not divisible by 3, ignore its value by returning the smallest possible number\\n    return Math.max( // return subset sum\\n        rc(nums, index + 1, currentSum + nums[index]), // use current number\\n        rc(nums, index + 1, currentSum) // skip current number\\n    )\\n}\\n```\n```javascript\\nfunction rc (nums, index = 0, remainder = 0) { // O(2^n)\\n    if (index >= nums.length) return remainder ? -Infinity : 0; // \\n    return Math.max( // subset sum = current number + max subset sum from next index OR skip the current number\\n        nums[index] + rc(nums, index + 1, (remainder + nums[index]) % 3), // calculate the new reminder after using the current number\\n        rc(nums, index + 1, remainder) // skip the current number\\n    )\\n}\\n```\n```javascript\\nfunction rc (nums, index = 0, remainder = 0, memo = {}) { \\n    if (index >= nums.length) return remainder ? -Infinity : 0;\\n\\n    const memoKey = `${index},${remainder}`;\\n    if (memo[memoKey] !== undefined) return memo[memoKey] ;\\n    \\n    return memo[memoKey] = Math.max(\\n        nums[index] + rc(nums, index + 1, (remainder + nums[index]) % 3, memo),\\n        rc(nums, index + 1, remainder , memo)\\n    )\\n}\\n```\n```javascript\\nfunction dp (nums) {\\n    const dp = Array(nums.length + 1).fill(0).map(\\n        () => Array(3).fill(0).map(\\n            (_, remainder) => remainder ? -Infinity : 0\\n        )\\n    );\\n   \\n    for (let i = 1; i <= nums.length; i++) {\\n        for (let r = 0; r < 3; r++) {\\n            dp[i][r] = Math.max( // who cares about what dp[i][r] means, this is a direct translation from the recursive solution which is far easier to understand. \\n                nums[i - 1] + dp[i - 1][(r + nums[i - 1]) % 3],\\n                dp[i - 1][r]\\n            )\\n        }\\n    }\\n    \\n    return dp[nums.length][0]\\n}\\n```\n```javascript\\nfunction dp2 (nums) { \\n\\t// only dp[i - 1] is needed for calculatiing the next result, we just need two variables instead of an array\\n    const current = Array(3).fill(0).map((_, remainder) => remainder ? -Infinity : 0);\\n   \\n    for (let i = 0; i < nums.length; i++) {\\n        const previous = current.slice();\\n        for (let r = 0; r < 3; r++) {\\n            current[r] = Math.max(nums[i] + previous[(r + nums[i]) % 3], previous[r]);\\n        }\\n    }\\n    \\n    return current[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431057,
                "title": "python-math-solution",
                "content": "Divide the whole list into three parts: mod_0, mod_1, mod_2.\\nThink about the sum of the original list, if it mods 3 == 0, then we can just return the sum.\\nIf tot_sum % 3 == 1, then we should remove one smallest element from mod_1 or two smallest ones from mod_2.\\nIf tot_sum % 3 == 2, then we should remove one smallest element from mod_2 or two smallest ones from mod_1.\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mod_1, mod_2,res,remove = [], [], 0, float(\\'inf\\')\\n        for i in nums:\\n            if i%3 == 0: res += i\\n            if i%3 == 1: mod_1 += [i]\\n            if i %3 == 2: mod_2 += [i]\\n        mod_1.sort(reverse = True)\\n        mod_2.sort(reverse = True)\\n        tmp = sum(mod_1) +sum(mod_2)\\n        if tmp % 3 == 0:\\n            return res + tmp\\n        elif tmp% 3 == 1:\\n            if len(mod_1): remove = min(remove,mod_1[-1])\\n            if len(mod_2) > 1: remove = min(mod_2[-1]+mod_2[-2],remove)\\n        elif tmp % 3 == 2:\\n            if len(mod_2): remove = min(remove,mod_2[-1])\\n            if len(mod_1) > 1: remove = min(mod_1[-1]+mod_1[-2],remove)\\n        return res + tmp - remove\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mod_1, mod_2,res,remove = [], [], 0, float(\\'inf\\')\\n        for i in nums:\\n            if i%3 == 0: res += i\\n            if i%3 == 1: mod_1 += [i]\\n            if i %3 == 2: mod_2 += [i]\\n        mod_1.sort(reverse = True)\\n        mod_2.sort(reverse = True)\\n        tmp = sum(mod_1) +sum(mod_2)\\n        if tmp % 3 == 0:\\n            return res + tmp\\n        elif tmp% 3 == 1:\\n            if len(mod_1): remove = min(remove,mod_1[-1])\\n            if len(mod_2) > 1: remove = min(mod_2[-1]+mod_2[-2],remove)\\n        elif tmp % 3 == 2:\\n            if len(mod_2): remove = min(remove,mod_2[-1])\\n            if len(mod_1) > 1: remove = min(mod_1[-1]+mod_1[-2],remove)\\n        return res + tmp - remove\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431785,
                "title": "c-commented-dp-solution-that-actually-makes-sense",
                "content": "Well, at least hopefully this explanation makes sense.\\nI had to reverse-engineer the solution from a lot of solutions that didn\\'t explain anything. lol\\n\\nIf you want to optimize the solution for space like many other solutions did, you can choose to just keep the latest calculated sum. You don\\'t need all the information up to `n`.\\n\\n```\\n    int maxSumDivThree(vector<int>& vec) {\\n       vector<vector<int>> dp(vec.size() + 1, vector<int>(3));\\n   \\n       /* What does the first index mean? (i)\\n        *  It means we\\'re currently looking at the subarray from 0 to i (exclusive).\\n        *\\n        * What does the second index mean? (j)\\n        *  It represents the remainder that we currently have.\\n        *\\n        * We want to find dp[N][0]. In other words, we want to find the greatest sum of the whole array, given that we have no remainder left to add, that is still divisible by 3.\\n        */\\n   \\n       dp[0][0] = 0; // our sum at this point is 0, and we have no remainder left to add. that gives us 0, which is divisible by 3, so 0 is a valid answer!\\n       dp[0][1] = INT_MIN; // our sum at this point is 0, and we have 1 remainder left to add. that gives us 1, which is not divisible by 3, and is invalid.\\n       dp[0][2] = INT_MIN; // same as above. 2 is not divisible by 3, which is invalid.\\n\\n        \\n       for (unsigned int i = 1; i <= vec.size(); i++)\\n       {\\n           int ind = i-1;\\n           /* At every i, we have a choice.\\n            *\\n            *  1. Skip the element. So our answer is just our previous answer.\\n            *\\n            *  2. Add the element to our sum. If we add this element, that means our remainder will now be (num % 3).\\n            *  This won\\'t give us a number that\\'s fully divisible by 3 by itself, well, unless (num % 3) is 0.\\n            *\\n            *  The only way we can get one, is if we look at a state which is dependent on adding the remainder (num % 3) to get a number divisible by 3.\\n            *  Luckily, we can find one for the step right before us using dp[i-1][(vec[ind] % 3)]!\\n            */\\n           dp[i][0] = max(dp[i-1][0], dp[i-1][(vec[ind]) % 3] + vec[ind]);\\n   \\n           /* The same logic applies for 1 and 2.\\n            * We add 1 or 2 because we still need to count our outstanding remainder.\\n            *\\n            * In other words:\\n            *\\n            * If we\\'re at dp[i][1], we\\'re at the state where we have +1 remainder.\\n            * If we\\'re at dp[i][2], we\\'re at the state where we have +2 remainder.\\n            *\\n            * We combine that with the remainder we\\'ll get when we add our element.\\n            */\\n           dp[i][1] = max(dp[i-1][1], dp[i-1][(vec[ind]+1) % 3] + vec[ind]);\\n           dp[i][2] = max(dp[i-1][2], dp[i-1][(vec[ind]+2) % 3] + vec[ind]);\\n       }\\n        \\n       return dp[vec.size()][0];\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Well, at least hopefully this explanation makes sense.\\nI had to reverse-engineer the solution from a lot of solutions that didn\\'t explain anything. lol\\n\\nIf you want to optimize the solution for space like many other solutions did, you can choose to just keep the latest calculated sum. You don\\'t need all the information up to `n`.\\n\\n```\\n    int maxSumDivThree(vector<int>& vec) {\\n       vector<vector<int>> dp(vec.size() + 1, vector<int>(3));\\n   \\n       /* What does the first index mean? (i)\\n        *  It means we\\'re currently looking at the subarray from 0 to i (exclusive).\\n        *\\n        * What does the second index mean? (j)\\n        *  It represents the remainder that we currently have.\\n        *\\n        * We want to find dp[N][0]. In other words, we want to find the greatest sum of the whole array, given that we have no remainder left to add, that is still divisible by 3.\\n        */\\n   \\n       dp[0][0] = 0; // our sum at this point is 0, and we have no remainder left to add. that gives us 0, which is divisible by 3, so 0 is a valid answer!\\n       dp[0][1] = INT_MIN; // our sum at this point is 0, and we have 1 remainder left to add. that gives us 1, which is not divisible by 3, and is invalid.\\n       dp[0][2] = INT_MIN; // same as above. 2 is not divisible by 3, which is invalid.\\n\\n        \\n       for (unsigned int i = 1; i <= vec.size(); i++)\\n       {\\n           int ind = i-1;\\n           /* At every i, we have a choice.\\n            *\\n            *  1. Skip the element. So our answer is just our previous answer.\\n            *\\n            *  2. Add the element to our sum. If we add this element, that means our remainder will now be (num % 3).\\n            *  This won\\'t give us a number that\\'s fully divisible by 3 by itself, well, unless (num % 3) is 0.\\n            *\\n            *  The only way we can get one, is if we look at a state which is dependent on adding the remainder (num % 3) to get a number divisible by 3.\\n            *  Luckily, we can find one for the step right before us using dp[i-1][(vec[ind] % 3)]!\\n            */\\n           dp[i][0] = max(dp[i-1][0], dp[i-1][(vec[ind]) % 3] + vec[ind]);\\n   \\n           /* The same logic applies for 1 and 2.\\n            * We add 1 or 2 because we still need to count our outstanding remainder.\\n            *\\n            * In other words:\\n            *\\n            * If we\\'re at dp[i][1], we\\'re at the state where we have +1 remainder.\\n            * If we\\'re at dp[i][2], we\\'re at the state where we have +2 remainder.\\n            *\\n            * We combine that with the remainder we\\'ll get when we add our element.\\n            */\\n           dp[i][1] = max(dp[i-1][1], dp[i-1][(vec[ind]+1) % 3] + vec[ind]);\\n           dp[i][2] = max(dp[i-1][2], dp[i-1][(vec[ind]+2) % 3] + vec[ind]);\\n       }\\n        \\n       return dp[vec.size()][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1777839,
                "title": "all-4-dp-approaches-o-1-space-c",
                "content": "**Approach 1 - Recursion**\\n```\\nclass Solution {\\npublic:\\n    //recursion\\n    int solve(int i,vector<int>& nums,int r){\\n        if(i == nums.size()){\\n            if(r == 0){\\n                return 0;\\n            }\\n            return -1000000;\\n        }\\n        \\n        int op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3);\\n        int op2 = solve(i+1,nums,r);\\n        return max(op1,op2);\\n    }\\n\\t int maxSumDivThree(vector<int>& nums) {\\n\\t     return solve(0,nums,0);\\n\\t }\\n};\\n```\\n**Approach 2 -  Recursion + Memoization**\\n```\\nclass Solution {\\npublic:\\n\\tint solve(int i,vector<int>& nums,int r,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == nums.size()){\\n\\t\\t\\t\\tif(r == 0){\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1000000;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][r] != -1) return dp[i][r];\\n\\n\\t\\t\\tint op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3,dp);\\n\\t\\t\\tint op2 = solve(i+1,nums,r,dp);\\n\\t\\t\\treturn dp[i][r] = max(op1,op2);\\n\\t\\t}\\n\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(3,-1));  \\n\\t\\t\\treturn solve(0,nums,0,dp);\\n\\t\\t }\\n};\\t \\n```\\n\\n**Approach 3 - Tabulation**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[i-1][0] + nums[i];\\n            int y = dp[i-1][1] + nums[i];\\n            int z = dp[i-1][2] + nums[i];\\n            dp[i] = dp[i-1];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[i][x%3] = max({dp[i][x%3],x});\\n            dp[i][y%3] = max({dp[i][y%3],y});\\n            dp[i][z%3] = max({dp[i][z%3],z});\\n            \\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```\\n\\n**Approach 4 - Space Optimized Tabulation**\\n```\\nclass Solution {\\npublic:\\nint maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(1,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[0][0] + nums[i];\\n            int y = dp[0][1] + nums[i];\\n            int z = dp[0][2] + nums[i];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[0][x%3] = max({dp[0][x%3],x});\\n            dp[0][y%3] = max({dp[0][y%3],y});\\n            dp[0][z%3] = max({dp[0][z%3],z});\\n            \\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //recursion\\n    int solve(int i,vector<int>& nums,int r){\\n        if(i == nums.size()){\\n            if(r == 0){\\n                return 0;\\n            }\\n            return -1000000;\\n        }\\n        \\n        int op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3);\\n        int op2 = solve(i+1,nums,r);\\n        return max(op1,op2);\\n    }\\n\\t int maxSumDivThree(vector<int>& nums) {\\n\\t     return solve(0,nums,0);\\n\\t }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint solve(int i,vector<int>& nums,int r,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == nums.size()){\\n\\t\\t\\t\\tif(r == 0){\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1000000;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][r] != -1) return dp[i][r];\\n\\n\\t\\t\\tint op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3,dp);\\n\\t\\t\\tint op2 = solve(i+1,nums,r,dp);\\n\\t\\t\\treturn dp[i][r] = max(op1,op2);\\n\\t\\t}\\n\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(3,-1));  \\n\\t\\t\\treturn solve(0,nums,0,dp);\\n\\t\\t }\\n};\\t \\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[i-1][0] + nums[i];\\n            int y = dp[i-1][1] + nums[i];\\n            int z = dp[i-1][2] + nums[i];\\n            dp[i] = dp[i-1];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[i][x%3] = max({dp[i][x%3],x});\\n            dp[i][y%3] = max({dp[i][y%3],y});\\n            dp[i][z%3] = max({dp[i][z%3],z});\\n            \\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(1,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[0][0] + nums[i];\\n            int y = dp[0][1] + nums[i];\\n            int z = dp[0][2] + nums[i];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[0][x%3] = max({dp[0][x%3],x});\\n            dp[0][y%3] = max({dp[0][y%3],y});\\n            dp[0][z%3] = max({dp[0][z%3],z});\\n            \\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 439097,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nFormulate a dynamic programming solution from the bottom-up by tracking the maximum sum mod 3 in buckets 0, 1, 2.\\n\\n1. Initially buckets 0, 1, 2 are set to 0... `{ 0, 0, 0 }`\\n2. For each `num` in `A`\\n    a. let `sum` be `num` plus each ongoing maximum `sum` in buckets `0, 1, 2`\\n    b. update the bucket corresponding to `sum % 3` to be the maximum of its current value and this current sum\\n3. Return the value in bucket 0 (ie. the maximum sum of elements in A which is evenly divisible by 3)\\n\\n**Notes:**\\n* If the above explanation does *not* make sense, the 3 examples below show step-by-step how this algorithm works.\\n* The solutions below begin with commented verbosity to help understand the algorithm\\'s general concept.  Then each solution is incrementally refactored for memory optimization and conciseness (just for fun!).\\n\\n**Runtime:** O(N)\\n\\n*Example 1:*\\n\\n```\\nA = [3,6,5,1,8]\\n\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n     ^\\nbuckets { 3, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n       ^\\nbuckets { 9, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n         ^\\nbuckets { 9, 0, 14 }\\n          0  1   2\\n\\nA = [3,6,5,1,8]\\n           ^\\nbuckets { 15, 10, 14 }\\n           0   1   2\\n\\nA = [3,6,5,1,8]\\n             ^\\nbuckets { 18, 22, 23 }\\n           0   1   2\\n           \\nthe answer in buckets[0] is 18\\n```\\n\\n*Example 2:*\\n```\\nA = [4]\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n\\nA = [4]\\n     ^\\nbuckets { 0, 4, 0 }\\n          0  1  2\\n          \\nthe answer in buckets[0] is 0\\n```\\n\\n*Example 3:*\\n```\\nA = [1,2,3,4,4]\\n\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n          \\nA = [1,2,3,4,4]\\n     ^\\nbuckets { 0, 1, 0 } \\n          0  1  2\\n\\nA = [1,2,3,4,4]\\n       ^\\nbuckets { 3, 1, 2 } \\n          0  1  2\\n          \\nA = [1,2,3,4,4]\\n         ^\\nbuckets { 6, 4, 5 } \\n          0  1  2\\n\\nA = [1,2,3,4,4]\\n           ^\\nbuckets { 9, 10, 8 }\\n          0   1  2\\n\\nA = [1,2,3,4,4]\\n             ^\\nbuckets { 12, 13, 14 } \\n           0   1   2\\n\\nthe answer in buckets[0] is 12\\n```\\n\\n---\\n**Javascript Solutions:**\\n\\n*Javascript (verbose)*\\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let buckets = [...Array(N + 1)].map(_ => Array(3).fill(0));\\n    for (let i = 1; i <= N; ++i) {\\n        buckets[i] = [...buckets[i - 1]]; // create current from previous \\uD83E\\uDD14\\n        for (let j of [0, 1, 2]) {\\n            let sum = A[i - 1] + buckets[i - 1][j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n            buckets[i][sum % 3] = Math.max(buckets[i][sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return buckets[N][0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\\n\\n*Javascript (memory optimization)*\\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let cur = Array(3).fill(0);\\n    for (let i = 1; i <= N; ++i) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let j of [0, 1, 2]) {\\n            let sum = A[i - 1] + pre[j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n            cur[sum % 3] = Math.max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\\n\\n*Javascript (memory optimization + more concise code)*\\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let cur = Array(3).fill(0);\\n    for (let x of A) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let y of pre) {\\n            let sum = x + y; // add A[i] (ie. x) onto each previous bucket value (ie. y)\\n            cur[sum % 3] = Math.max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\\n\\n*Javascript (memory optimization + most concise code)*\\n```\\nlet maxSumDivThree = (A, cur = [0, 0, 0]) => {\\n    for (let x of A) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let y of pre)\\n            cur[(x + y) % 3] = Math.max(cur[(x + y) % 3], x + y); // add A[i] (ie. x) onto each previous bucket and update each current bucket to max of itself and the current sum (x + y)\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n*C++ (verbose)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VVI buckets(N + 1, VI(3));\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            buckets[i] = buckets[i - 1]; // create current from previous \\uD83E\\uDD14\\n            for (auto j: VI{ 0, 1, 2 }) {\\n                auto sum = A[i - 1] + buckets[i - 1][j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n                buckets[i][sum % 3] = max(buckets[i][sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return buckets[N][0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\\n\\n*C++ (memory optimization)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VI cur(3);\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto j: VI{ 0, 1, 2 }) {\\n                auto sum = A[i - 1] + pre[j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n                cur[sum % 3] = max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\\n\\n*C++ (memory optimization + more concise code)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto y: pre) {\\n                auto sum = x + y; // add A[i] (ie. x) onto each previous bucket value (ie. y)\\n                cur[sum % 3] = max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\\n\\n*C++ (memory optimization + most concise code)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y); // update each (current sum % 3) bucket to max of itself and the current sum (x + y)\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\\n\\n---\\n\\n**Update 2021-01-15:** I just solved this one from scratch in C++ to document my thought process as follows: let `N` be the cardinality of `A` which is at most `40,000`, so I know I need to create a near-linear algorithm to avoid TLE which we know will occur from a quadratic asymptotic bound O(`N`<sup>2</sup>), ie. `40,000 * 40,000 == 1,600,000,000` (since we expect anything over one million or so operations to TLE).  Using this deductive reasoning, I thought `120,000` works to create \"buckets\" `0`,`1`,`2` of each maximum sum so far mod `3` from the bottom-up.  Based on this overall game plan, I came up with the recurrence relation and then wrote the corresponding code as follows...\\n\\n**Recurrence Relation:**\\n\\nLet `dp[i][j]` denote the maximum possible sum ending at `i` non-inclusive who\\'s value mod `3` is `j`\\nThen `dp[N][0]` is the maximum possible sum ending at `N` non-inclusive who\\'s value mod `3` is `0` (ie. evenly divisible by `3`)\\n\\n**C++ Code:**\\n\\nIn the code below `x` is the maximum sum so far and `k` is the mod `3` \"bucket\":\\n\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VVI dp(N + 1, VI(3));\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                dp[i][j] = dp[i - 1][j]; // init current row from previous row\\n            }\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto x = A[i - 1] + dp[i - 1][j];\\n                auto k = x % 3;\\n                dp[i][k] = max(dp[i][k], x);\\n            }\\n        }\\n        return dp[N][0];\\n    }\\n};\\n```\\n\\nAnd then from here, I just iteratively refactored...\\n\\n1. since the current row `dp[i]` is only dependent upon the previous row `dp[i - 1]` we can optimize memory from O(N<sup>2</sup>), ie. storing the entire `dp` matrix, to O(N) by only storing the current and previous rows, ie. `cur` and `pre` correspondingly.\\n2. the index `i` isn\\'t needed, so use `x` in place of `A[i]`\\n3. likewise the index `j` isn\\'t needed, so use `y` in place of `pre[j]`, then notice the previous use of `y` and `k` were ephemeral, intermediary values\\n4. instead of continually swapping `cur` and `pre`, we can create copies of `cur` as `pre` upon demand\\n\\n```\\n// refactor 1\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VI pre(3);\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            VI cur{ pre };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto x = A[i - 1] + pre[j];\\n                auto k = x % 3;\\n                cur[k] = max(cur[k], x);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 2\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI pre(3);\\n        for (auto x: A) {\\n            VI cur{ pre };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto y = x + pre[j];\\n                auto k = y % 3;\\n                cur[k] = max(cur[k], y);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 3\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI pre(3);\\n        for (auto x: A) {\\n            VI cur{ pre };\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y);\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 4\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            VI pre{ cur };\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y);\\n        }\\n        return cur[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nA = [3,6,5,1,8]\\n\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n     ^\\nbuckets { 3, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n       ^\\nbuckets { 9, 0, 0 }\\n          0  1  2\\n\\nA = [3,6,5,1,8]\\n         ^\\nbuckets { 9, 0, 14 }\\n          0  1   2\\n\\nA = [3,6,5,1,8]\\n           ^\\nbuckets { 15, 10, 14 }\\n           0   1   2\\n\\nA = [3,6,5,1,8]\\n             ^\\nbuckets { 18, 22, 23 }\\n           0   1   2\\n           \\nthe answer in buckets[0] is 18\\n```\n```\\nA = [4]\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n\\nA = [4]\\n     ^\\nbuckets { 0, 4, 0 }\\n          0  1  2\\n          \\nthe answer in buckets[0] is 0\\n```\n```\\nA = [1,2,3,4,4]\\n\\nbuckets { 0, 0, 0 }\\n          0  1  2\\n          \\nA = [1,2,3,4,4]\\n     ^\\nbuckets { 0, 1, 0 } \\n          0  1  2\\n\\nA = [1,2,3,4,4]\\n       ^\\nbuckets { 3, 1, 2 } \\n          0  1  2\\n          \\nA = [1,2,3,4,4]\\n         ^\\nbuckets { 6, 4, 5 } \\n          0  1  2\\n\\nA = [1,2,3,4,4]\\n           ^\\nbuckets { 9, 10, 8 }\\n          0   1  2\\n\\nA = [1,2,3,4,4]\\n             ^\\nbuckets { 12, 13, 14 } \\n           0   1   2\\n\\nthe answer in buckets[0] is 12\\n```\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let buckets = [...Array(N + 1)].map(_ => Array(3).fill(0));\\n    for (let i = 1; i <= N; ++i) {\\n        buckets[i] = [...buckets[i - 1]]; // create current from previous \\uD83E\\uDD14\\n        for (let j of [0, 1, 2]) {\\n            let sum = A[i - 1] + buckets[i - 1][j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n            buckets[i][sum % 3] = Math.max(buckets[i][sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return buckets[N][0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let cur = Array(3).fill(0);\\n    for (let i = 1; i <= N; ++i) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let j of [0, 1, 2]) {\\n            let sum = A[i - 1] + pre[j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n            cur[sum % 3] = Math.max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\n```\\nlet maxSumDivThree = A => {\\n    let N = A.length;\\n    let cur = Array(3).fill(0);\\n    for (let x of A) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let y of pre) {\\n            let sum = x + y; // add A[i] (ie. x) onto each previous bucket value (ie. y)\\n            cur[sum % 3] = Math.max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n        }\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\n```\\nlet maxSumDivThree = (A, cur = [0, 0, 0]) => {\\n    for (let x of A) {\\n        let pre = [...cur]; // create current from previous \\uD83E\\uDD14\\n        for (let y of pre)\\n            cur[(x + y) % 3] = Math.max(cur[(x + y) % 3], x + y); // add A[i] (ie. x) onto each previous bucket and update each current bucket to max of itself and the current sum (x + y)\\n    }\\n    return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VVI buckets(N + 1, VI(3));\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            buckets[i] = buckets[i - 1]; // create current from previous \\uD83E\\uDD14\\n            for (auto j: VI{ 0, 1, 2 }) {\\n                auto sum = A[i - 1] + buckets[i - 1][j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n                buckets[i][sum % 3] = max(buckets[i][sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return buckets[N][0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VI cur(3);\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto j: VI{ 0, 1, 2 }) {\\n                auto sum = A[i - 1] + pre[j]; // add A[i] onto each previous bucket (A[i - 1] for A[i] because buckets is offset by 1)\\n                cur[sum % 3] = max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto y: pre) {\\n                auto sum = x + y; // add A[i] (ie. x) onto each previous bucket value (ie. y)\\n                cur[sum % 3] = max(cur[sum % 3], sum); // update each (current sum % 3) bucket to max of itself and the current sum\\n            }\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            auto pre{ cur }; // create current from previous \\uD83E\\uDD14\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y); // update each (current sum % 3) bucket to max of itself and the current sum (x + y)\\n        }\\n        return cur[0]; // max sum of all N items of A which is evenly divisible by 3 \\uD83C\\uDFAF\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VVI dp(N + 1, VI(3));\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                dp[i][j] = dp[i - 1][j]; // init current row from previous row\\n            }\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto x = A[i - 1] + dp[i - 1][j];\\n                auto k = x % 3;\\n                dp[i][k] = max(dp[i][k], x);\\n            }\\n        }\\n        return dp[N][0];\\n    }\\n};\\n```\n```\\n// refactor 1\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        int N = A.size();\\n        VI pre(3);\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            VI cur{ pre };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto x = A[i - 1] + pre[j];\\n                auto k = x % 3;\\n                cur[k] = max(cur[k], x);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 2\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI pre(3);\\n        for (auto x: A) {\\n            VI cur{ pre };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                auto y = x + pre[j];\\n                auto k = y % 3;\\n                cur[k] = max(cur[k], y);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 3\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI pre(3);\\n        for (auto x: A) {\\n            VI cur{ pre };\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y);\\n            swap(pre, cur);\\n        }\\n        return pre[0];\\n    }\\n};\\n\\n// refactor 4\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxSumDivThree(VI& A) {\\n        VI cur(3);\\n        for (auto x: A) {\\n            VI pre{ cur };\\n            for (auto y: pre)\\n                cur[(x + y) % 3] = max(cur[(x + y) % 3], x + y);\\n        }\\n        return cur[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524408,
                "title": "c-o-n-time-complexity-with-explanation",
                "content": "The idea is to sum up every ```nums[i]```, and then substract the smallest one or two numbers to make the sum divisible by 3.\\nWe record the most 2 smallest ```nums[i]``` for each ```% 3 = 1``` and ```% 3 = 2```. The name of ```m1fir```stands for \"mod  = 1 first\" (smallest), and```m2sec``` stands for \"mod = 2 second\" (second smallest).\\nAt last, in case of ```sum % 3 == 1```, we substract the smallest \"mod 3 = 1\" (which is m1fir) OR the sum of the two smallest \"mod 3 = 2\" (which is m2fir + m2sec) whichever is smaller because (2 + 2) % 3 = 1. Case of ```sum % 3 == 2``` can be dealed with similar method.\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int m1fir = 10001, m1sec = 10001, m2fir = 10001, m2sec = 10001;\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            if (nums[i] % 3 == 1)\\n            {\\n                if (nums[i] < m1fir)\\n                {\\n                    m1sec = m1fir;\\n                    m1fir = nums[i];\\n                }\\n                else if (nums[i] < m1sec) m1sec = nums[i];\\n            }\\n            else if (nums[i] % 3 == 2)\\n            {\\n                if (nums[i] < m2fir)\\n                {\\n                    m2sec = m2fir;\\n                    m2fir = nums[i];\\n                }\\n                else if (nums[i] < m2sec) m2sec = nums[i];\\n            }\\n        }\\n        if (sum % 3 == 0) return sum;\\n        if (sum % 3 == 1) return sum - min(m1fir, m2fir + m2sec);\\n        return sum - min(m2fir, m1fir + m1sec);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```nums[i]```\n```nums[i]```\n```% 3 = 1```\n```% 3 = 2```\n```m1fir```\n```m2sec```\n```sum % 3 == 1```\n```sum % 3 == 2```\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int m1fir = 10001, m1sec = 10001, m2fir = 10001, m2sec = 10001;\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            if (nums[i] % 3 == 1)\\n            {\\n                if (nums[i] < m1fir)\\n                {\\n                    m1sec = m1fir;\\n                    m1fir = nums[i];\\n                }\\n                else if (nums[i] < m1sec) m1sec = nums[i];\\n            }\\n            else if (nums[i] % 3 == 2)\\n            {\\n                if (nums[i] < m2fir)\\n                {\\n                    m2sec = m2fir;\\n                    m2fir = nums[i];\\n                }\\n                else if (nums[i] < m2sec) m2sec = nums[i];\\n            }\\n        }\\n        if (sum % 3 == 0) return sum;\\n        if (sum % 3 == 1) return sum - min(m1fir, m2fir + m2sec);\\n        return sum - min(m2fir, m1fir + m1sec);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432201,
                "title": "java-o-n-time-o-1-space-one-pass-with-explanation",
                "content": "In this problem we find the sum of all the elements in the array.\\nLet it be sum.\\nNow there can be 3 cases:\\n1. sum % 3 == 0\\n2. sum % 3 == 1\\n3. sum % 3 == 2\\nIf sum % 3 == 0, we can return sum.\\nNow there was an observation in this problem. \\n\\n\\n**When we have the sum % 3 == 1**, **we can remove either one element with nums[i] % 3 == 1**(if there exists one such element) to get the remaining-sum of the elements divisible by 3 **OR** **we could remove two elements form the nums array which when divided by 3 gave 2 as remainder**(if they exist). It is quite obvious that if you would want to remove a single element with mod 3 == 1, you would want to remove the minimum element out of all those which when when divided by 3 gave remainder as 1. Similarly if you were to remove two elements which gave remainder 2 on division by 3, you would want to remove the minimum two elements out of all the elements which gave a remainder of 2 when divided by 3.\\n\\nThe case when sum % 3 == 2 is analogous to the case when sum % 3 == 1.\\nWe will either remove the minimum element which when divided by 3 gave remainder as 2, OR we will remove two elements which when divided by 3 gave a remainder 1.\\n\\nFor both the cases, we would choose the removal which would maximize the sum.\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        \\n        int n = nums.length;\\n        int sum = 0;\\n        int min1 = Integer.MAX_VALUE; /* 1st min element with % 3 = 1 */\\n        int min2 = Integer.MAX_VALUE; /* 2nd min element with % 3 = 1 */\\n        int min3 = Integer.MAX_VALUE; /* 1st min element with % 3 = 2 */\\n        int min4 = Integer.MAX_VALUE; /* 2nd min element with % 3 = 2 */\\n        \\n        for(int i = 0; i < n; i++){\\n            int curr = nums[i];\\n            sum += nums[i];\\n            if(curr % 3 == 1){\\n                if(curr <= min1){\\n                    min2 = min1;\\n                    min1 = curr;\\n                }\\n                else if(curr < min2){\\n                    min2 = curr;\\n                }\\n            }\\n            else if(curr % 3 == 2){\\n                if(curr <= min3){\\n                    min4 = min3;\\n                    min3 = curr;\\n                }\\n                else if(curr < min4){\\n                    min4 = curr;\\n                }\\n            }\\n        }\\n        \\n        if(sum % 3 == 0) return sum;\\n        \\n        if(sum % 3 == 1){\\n            int min = Integer.MAX_VALUE;\\n            if(min1 != Integer.MAX_VALUE) min = Math.min(min, min1);\\n            if(min3 != Integer.MAX_VALUE && min4 != Integer.MAX_VALUE) min = Math.min(min, min3  + min4);\\n            return sum - min;\\n        }\\n        \\n        else{\\n            int min = Integer.MAX_VALUE;\\n            if(min3 != Integer.MAX_VALUE) min = Math.min(min, min3);\\n            if(min1 != Integer.MAX_VALUE && min2 != Integer.MAX_VALUE) min = Math.min(min, min1  + min2);\\n            return sum - min;\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        \\n        int n = nums.length;\\n        int sum = 0;\\n        int min1 = Integer.MAX_VALUE; /* 1st min element with % 3 = 1 */\\n        int min2 = Integer.MAX_VALUE; /* 2nd min element with % 3 = 1 */\\n        int min3 = Integer.MAX_VALUE; /* 1st min element with % 3 = 2 */\\n        int min4 = Integer.MAX_VALUE; /* 2nd min element with % 3 = 2 */\\n        \\n        for(int i = 0; i < n; i++){\\n            int curr = nums[i];\\n            sum += nums[i];\\n            if(curr % 3 == 1){\\n                if(curr <= min1){\\n                    min2 = min1;\\n                    min1 = curr;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 857968,
                "title": "c-o-n-solution-with-comment",
                "content": "Runtime: 88 ms, faster than 84.15% of C++ online submissions for Greatest Sum Divisible by Three.\\nMemory Usage: 25.2 MB, less than 74.19% of C++ online submissions for Greatest Sum Divisible by Three.\\n\\n**Math Solution:**\\n.\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        // If we want to find greatest sum divisible by 3 then\\n        // total_sum can be of 3 type total_sum mod 3 = 0 or 1 or 2\\n        // If total_sum mod 3 is 0 then it is the result\\n        // If total_sum mod 3 is 1 then we need to remove the least_sum which has least_sum mod 3 = 1 \\n        // If total_sum mod 3 is 2 then we need to remove the least_sum which has least_sum mod 3 = 2\\n        \\n        // least_sum mod 3 = 1 value \\n        int rem1 = 10001;\\n        \\n        // least_sum mod 3 = 2 value\\n        int rem2 = 10001;\\n        \\n        // total_sum\\n        int sum = 0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // cumulative sum\\n            sum+=nums[i];\\n            \\n            // if current number nums[i] is 3 mod 1 then update the reminder1 value with min between num[i] and reminder1\\n            // Also we update the reminder2 value cause 2 reminder1 value can make 1 reminder2 value EX => 1 + 1 = 2\\n            if(nums[i]%3==1)rem2 = min(rem1+nums[i],rem2),rem1= min(rem1,nums[i]);\\n            \\n            // if current number nums[i] is 3 mod 2 then update the reminder2 value with min between num[i] and reminder2 \\n            // Also we update the reminder1 value cause 2 reminder2 value can make 1 reminder1 value EX => 2 + 2 = 4\\n            if(nums[i]%3==2)rem1 = min(rem2+nums[i],rem1),rem2= min(rem2,nums[i]);\\n        }\\n        \\n        // If total_sum %3 == 0 return total_sum\\n        // Otherwise return total_sum - reminder[total_sum%3]\\n        \\n        return (sum%3==0)?sum:((sum%3==1)?(sum-rem1):(sum-rem2));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        // If we want to find greatest sum divisible by 3 then\\n        // total_sum can be of 3 type total_sum mod 3 = 0 or 1 or 2\\n        // If total_sum mod 3 is 0 then it is the result\\n        // If total_sum mod 3 is 1 then we need to remove the least_sum which has least_sum mod 3 = 1 \\n        // If total_sum mod 3 is 2 then we need to remove the least_sum which has least_sum mod 3 = 2\\n        \\n        // least_sum mod 3 = 1 value \\n        int rem1 = 10001;\\n        \\n        // least_sum mod 3 = 2 value\\n        int rem2 = 10001;\\n        \\n        // total_sum\\n        int sum = 0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // cumulative sum\\n            sum+=nums[i];\\n            \\n            // if current number nums[i] is 3 mod 1 then update the reminder1 value with min between num[i] and reminder1\\n            // Also we update the reminder2 value cause 2 reminder1 value can make 1 reminder2 value EX => 1 + 1 = 2\\n            if(nums[i]%3==1)rem2 = min(rem1+nums[i],rem2),rem1= min(rem1,nums[i]);\\n            \\n            // if current number nums[i] is 3 mod 2 then update the reminder2 value with min between num[i] and reminder2 \\n            // Also we update the reminder1 value cause 2 reminder2 value can make 1 reminder1 value EX => 2 + 2 = 4\\n            if(nums[i]%3==2)rem1 = min(rem2+nums[i],rem1),rem2= min(rem2,nums[i]);\\n        }\\n        \\n        // If total_sum %3 == 0 return total_sum\\n        // Otherwise return total_sum - reminder[total_sum%3]\\n        \\n        return (sum%3==0)?sum:((sum%3==1)?(sum-rem1):(sum-rem2));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657894,
                "title": "java-clear-easy-solution",
                "content": "Time Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nSince we need the greatest sum divisible by 3, we just need to get the sum of the entire array and subtract the smaller number that would remove the remainder if it is not divisible by 3. \\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int oneRemainder = 20000;\\n        int twoRemainder = 20000;\\n        \\n        for(int num : nums)\\n        {\\n            sum += num;\\n            \\n            if(num % 3 == 1)\\n            {\\n                twoRemainder = Math.min(twoRemainder, oneRemainder + num);\\n                oneRemainder = Math.min(oneRemainder, num); \\n            }\\n            \\n            if(num % 3 == 2)\\n            {\\n                oneRemainder = Math.min(oneRemainder, twoRemainder + num);\\n                twoRemainder = Math.min(twoRemainder, num);\\n                 \\n            }\\n        }\\n        \\n        if(sum % 3 == 0)\\n            return sum;\\n        \\n        if(sum % 3 == 1)\\n            return sum - oneRemainder;\\n        \\n        if(sum % 3 == 2)\\n            return sum - twoRemainder;\\n        \\n        return 0;\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int oneRemainder = 20000;\\n        int twoRemainder = 20000;\\n        \\n        for(int num : nums)\\n        {\\n            sum += num;\\n            \\n            if(num % 3 == 1)\\n            {\\n                twoRemainder = Math.min(twoRemainder, oneRemainder + num);\\n                oneRemainder = Math.min(oneRemainder, num); \\n            }\\n            \\n            if(num % 3 == 2)\\n            {\\n                oneRemainder = Math.min(oneRemainder, twoRemainder + num);\\n                twoRemainder = Math.min(twoRemainder, num);\\n                 \\n            }\\n        }\\n        \\n        if(sum % 3 == 0)\\n            return sum;\\n        \\n        if(sum % 3 == 1)\\n            return sum - oneRemainder;\\n        \\n        if(sum % 3 == 2)\\n            return sum - twoRemainder;\\n        \\n        return 0;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431198,
                "title": "python-dp-solution-beast-100-time-and-100-space",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        f = [[0] * 3 for i in range(len(nums))]\\n        f[0][nums[0] % 3] = nums[0]\\n        for i in range(1, len(nums)):\\n            for j in range(3):\\n                include = f[i-1][(j + 3 - nums[i] %3) % 3] + nums[i]\\n                if include % 3 == j:\\n                    f[i][j] = max(f[i-1][j], include)\\n                else:\\n                    f[i][j] = f[i-1][j]\\n        return f[-1][0]\\n            \\n```\\n\\nf[i] is the biggest value can possibly have after ith iteration, with remainder 0,1,2.\\nFor example, the input is 3,6,5,1,8. The initial f would be \\n[[3,0,0],\\n [0,0,0],\\n [0,0,0],\\n [0,0,0],\\n [0,0,0]].\\n After the first iteration, which the ith value is 6. The f would become\\n [[3,0,0],\\n [9,0,0],\\n [0,0,0],\\n [0,0,0],\\n [0,0,0]].\\n After 2nd iteration, when ith value is 5, f becomes\\n[[3,0,0],\\n [9,0,0],\\n [9,0,14], (14 is from 9 + 5)\\n [0,0,0],\\n [0,0,0]].\\n Then, ith value is 1\\n[[3,0,0],\\n [9,0,0],\\n [9,0,14],\\n [15,10,14], (15 is from 14 + 1, 10 is from 9 + 1)\\n [0,0,0]].\\nAnd finally, ith value is 8\\n[[3,0,0],\\n [9,0,0],\\n [9,0,14],\\n [15,10,14],\\n [18,22,23]]. (18 is from 10 + 8, 22 is from 14 + 8, 23 is from 15 + 8)\\n \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        f = [[0] * 3 for i in range(len(nums))]\\n        f[0][nums[0] % 3] = nums[0]\\n        for i in range(1, len(nums)):\\n            for j in range(3):\\n                include = f[i-1][(j + 3 - nums[i] %3) % 3] + nums[i]\\n                if include % 3 == j:\\n                    f[i][j] = max(f[i-1][j], include)\\n                else:\\n                    f[i][j] = f[i-1][j]\\n        return f[-1][0]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 431105,
                "title": "python-dp-solution",
                "content": "dp[r][i] = the maximal subset sum selected from nums[:i+1] which modulos 3 equals to r\\n```\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0 for _ in range(n)] for _ in range(3)]\\n        dp[nums[0] % 3][0] = nums[0]\\n        for i in range(1, n):\\n            for r in range(3):\\n                include = dp[(r - nums[i]) % 3][i-1] + nums[i]\\n                if include % 3 == r:\\n                    dp[r][i] = max(dp[r][i-1], include)\\n                else:\\n                    dp[r][i] = dp[r][i-1]\\n        return dp[0][n-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0 for _ in range(n)] for _ in range(3)]\\n        dp[nums[0] % 3][0] = nums[0]\\n        for i in range(1, n):\\n            for r in range(3):\\n                include = dp[(r - nums[i]) % 3][i-1] + nums[i]\\n                if include % 3 == r:\\n                    dp[r][i] = max(dp[r][i-1], include)\\n                else:\\n                    dp[r][i] = dp[r][i-1]\\n        return dp[0][n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431073,
                "title": "java-two-o-n-solution-dp-one-pass-non-dp",
                "content": "**DP**\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] sum = new int[3];\\n        sum[1] = -1;\\n        sum[2] = -1;\\n        for (int num : nums) {\\n            int[] temp = new int[3];\\n            temp[0] = sum[0];\\n            temp[1] = sum[1];\\n            temp[2] = sum[2];\\n            \\n            if (temp[(3 - num%3)%3] != -1)\\n                sum[0] = Math.max(sum[0], temp[(3 - num%3)%3] + num);\\n            \\n            if (temp[(4 - num%3)%3] != -1)\\n                sum[1] = Math.max(sum[1], temp[(4 - num%3)%3] + num);\\n            \\n            if (temp[(5 - num%3)%3] != -1)\\n                sum[2] = Math.max(sum[2], temp[(5 - num%3)%3] + num);\\n        }\\n        return sum[0];\\n    }\\n}\\n```\\n\\n\\n**Non DP**\\nCalculate the sum of all numbers. During that iterate, find:\\n- smallest number that % 3 == 1\\n- second smallest number that % 3 == 1\\n- smallest number that % 3 == 2\\n- second smallest number that % 3 == 2\\n\\nif `sum % 3 == 0`, return it.\\n\\nif `sum % 3 == 1`, either subtract it by `smallest1` or `smallest2 + second_smallest2`, to get a number that % 3 == 0. Return number after subtraction.\\n\\nif `sum % 3 == 2`, either subtract it by `smallest2` or `smallest1 + second_smallest1`, to get a number that % 3 == 0. Return number after subtraction.\\n\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int f1 = 1_000_0000, s1 = 1_000_0000, f2 = 1_000_0000, s2 = 1_000_0000;\\n        for (int num : nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                if (num < f1) {\\n                    s1 = f1;\\n                    f1 = num;\\n                } else if (num < s1) {\\n                    s1 = num;\\n                }\\n            } else if (num % 3 == 2) {\\n                if (num < f2) {\\n                    s2 = f2;\\n                    f2 = num;\\n                } else if (num < s2) {\\n                    s2 = num;\\n                }\\n            }\\n        }\\n        \\n        if (sum % 3 == 0) return sum;\\n        \\n        if (sum % 3 == 1) {\\n            return sum - Math.min(f1, f2+s2);\\n        } else {\\n            return sum - Math.min(f2, f1+s1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] sum = new int[3];\\n        sum[1] = -1;\\n        sum[2] = -1;\\n        for (int num : nums) {\\n            int[] temp = new int[3];\\n            temp[0] = sum[0];\\n            temp[1] = sum[1];\\n            temp[2] = sum[2];\\n            \\n            if (temp[(3 - num%3)%3] != -1)\\n                sum[0] = Math.max(sum[0], temp[(3 - num%3)%3] + num);\\n            \\n            if (temp[(4 - num%3)%3] != -1)\\n                sum[1] = Math.max(sum[1], temp[(4 - num%3)%3] + num);\\n            \\n            if (temp[(5 - num%3)%3] != -1)\\n                sum[2] = Math.max(sum[2], temp[(5 - num%3)%3] + num);\\n        }\\n        return sum[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int f1 = 1_000_0000, s1 = 1_000_0000, f2 = 1_000_0000, s2 = 1_000_0000;\\n        for (int num : nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                if (num < f1) {\\n                    s1 = f1;\\n                    f1 = num;\\n                } else if (num < s1) {\\n                    s1 = num;\\n                }\\n            } else if (num % 3 == 2) {\\n                if (num < f2) {\\n                    s2 = f2;\\n                    f2 = num;\\n                } else if (num < s2) {\\n                    s2 = num;\\n                }\\n            }\\n        }\\n        \\n        if (sum % 3 == 0) return sum;\\n        \\n        if (sum % 3 == 1) {\\n            return sum - Math.min(f1, f2+s2);\\n        } else {\\n            return sum - Math.min(f2, f1+s1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322946,
                "title": "my-dp-solution-with-explaination",
                "content": "dp[i][j] -> what is the maximum sum that we can get using first i elements of nums and has remainder j\\n                        here we need sums divisible by 3 so j will be 0, 1, and 2\\nwhy do we need all 3 values ?\\nLets say we have the number 8 at ith index. 8 % 3 = 2\\n8 is not divisible by 3 and has remainder 2. so if we add 8 to the sum which has remainder 1\\nand these 2 will make a new sum which will be divisible by 3.\\nTo handle cases like this, we need all three states in our DP\\n\\nBasic idea is as follows:\\n\\nIf lets say we are at index i, and nums[i] % 3 = 2, then we do following things,\\n\\nthis number can be added with the dp[i-1][0] and this new sum will have remainder 2, so we will update dp[i][2]\\nthis number can be added with the dp[i-1][1] and this new sum will have remainder 0, so we will update dp[i][0]\\nthis number can be added with the dp[i-1][2] and this new sum will have remainder 1, so we will update dp[i][1]\\n\\nsame logic will apply when nums[i] % 3 = 0 and 1\\nif dp[i-1][j] is zero than the other two sums will be considered only if they are greater than 0\\n\\n```\\npublic int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][3];\\n        dp[0][nums[0] % 3] = nums[0];\\n//        System.out.println(Arrays.toString(dp[0]));\\n        for (int i = 1; i < n; i++) {\\n            int num = nums[i];\\n            int mod = num % 3;\\n            if (mod == 0) {\\n                dp[i][0] = dp[i - 1][0] + num;\\n                dp[i][1] = dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0;\\n                dp[i][2] = dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0;\\n            } else if (mod == 1) {\\n                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0);\\n                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + num); // if we add this num with the sum(with mod 0) new sum will be mod 1\\n                dp[i][2] = dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0;\\n            } else {\\n                // mod 2\\n                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0);\\n                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0);\\n                dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][0] + num);\\n            }\\n\\n//            System.out.println(Arrays.toString(dp[i]));\\n        }\\n\\n        return dp[n - 1][0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][3];\\n        dp[0][nums[0] % 3] = nums[0];\\n//        System.out.println(Arrays.toString(dp[0]));\\n        for (int i = 1; i < n; i++) {\\n            int num = nums[i];\\n            int mod = num % 3;\\n            if (mod == 0) {\\n                dp[i][0] = dp[i - 1][0] + num;\\n                dp[i][1] = dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0;\\n                dp[i][2] = dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0;\\n            } else if (mod == 1) {\\n                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0);\\n                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + num); // if we add this num with the sum(with mod 0) new sum will be mod 1\\n                dp[i][2] = dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0;\\n            } else {\\n                // mod 2\\n                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] > 0 ? dp[i - 1][1] + num : 0);\\n                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2] > 0 ? dp[i - 1][2] + num : 0);\\n                dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][0] + num);\\n            }\\n\\n//            System.out.println(Arrays.toString(dp[i]));\\n        }\\n\\n        return dp[n - 1][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2520718,
                "title": "c-dp-approach-pick-or-not-pick-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n     int solve(int i, int curr_sum_rem,vector<int>& nums,vector<vector<int>>&dp){\\n    if(i>=nums.size()){\\n        if(curr_sum_rem==0){\\n            return 0;\\n        }\\n        return INT_MIN;\\n    }\\n    if(dp[i][curr_sum_rem]!=-1)\\n        return dp[i][curr_sum_rem];\\n    int pick =nums[i]+ solve(i+1,(curr_sum_rem+nums[i])%3,nums,dp);    \\n    int notpick =0+ solve(i+1,curr_sum_rem,nums,dp);  \\n    return dp[i][curr_sum_rem]=max(pick,notpick);\\n    \\n}\\n    \\n    int maxSumDivThree(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,-1)); \\n        return solve(0,0,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int solve(int i, int curr_sum_rem,vector<int>& nums,vector<vector<int>>&dp){\\n    if(i>=nums.size()){\\n        if(curr_sum_rem==0){\\n            return 0;\\n        }\\n        return INT_MIN;\\n    }\\n    if(dp[i][curr_sum_rem]!=-1)\\n        return dp[i][curr_sum_rem];\\n    int pick =nums[i]+ solve(i+1,(curr_sum_rem+nums[i])%3,nums,dp);    \\n    int notpick =0+ solve(i+1,curr_sum_rem,nums,dp);  \\n    return dp[i][curr_sum_rem]=max(pick,notpick);\\n    \\n}\\n    \\n    int maxSumDivThree(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,-1)); \\n        return solve(0,0,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055939,
                "title": "java-simple-one-pass-easy-solution-with-explanation",
                "content": "1.First Sum all the elements\\n\\n2.If sum % 3 == 0 it is maximum;\\n\\n3.if sum % 3 == 1 we can delete smallest element which has mod1 or we can delete 2 smallest elements of mod 2.We delete which ever is smallest.\\n\\n4.eg -> [2,6,2,2,7] we can delete [7] beacuse it is smallest elemnt with mod 1 or [2,2] because mod = 4 % 3 = 1.We delele[2,2]\\n\\n5.Similarly if sum % 3 == 2 we can delete smallest element which has mod 2 or we can delete 2 smallest elements of mod 1 because .We delete which ever is smallest.\\n\\nUnoptimised code(runtime 26 ms)\\n_____________________________________\\n```\\nclass Solution {\\npublic int maxSumDivThree(int[] nums) {\\nint sum = 0;\\nList ones = new ArrayList<>();\\nList twos = new ArrayList<>();\\nfor(int i:nums){\\nsum+=i;\\nif(i % 3 == 1) {\\nones.add(i);\\n}\\nif(i % 3 == 2) twos.add(i);\\n}\\nCollections.sort(ones);\\nCollections.sort(twos);\\nif(sum % 3 == 0) return sum;\\n\\n    else if(sum % 3 == 2) {\\n        int min = 0;\\n        if(ones.size() >= 2){\\n           min = Math.min(twos.get(0),ones.get(0)+ones.get(1));\\n            return sum-min;\\n        }else{\\n            min = twos.get(0);\\n        }\\n        return sum - min;\\n    }else if( sum % 3 == 1){\\n        int min = 0;\\n        if(twos.size() >= 2){\\n            min = Math.min(ones.get(0),twos.get(0)+twos.get(1));\\n        }else{\\n            min = ones.get(0);\\n        }\\n        return sum - min;\\n    }\\n    return sum;\\n}\\n}\\n```\\n\\n\\nOptimised with variable for tracking smallest elemnts\\n------------------------------------\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int smallest_num_with_mod_1 = 10001;\\n        int second_smallest_num_with_mod_1 = 10002;\\n        int smallest_num_with_mod_2 = 10001;\\n        int second_smallest_num_with_mod_2 = 10002;\\n        for(int i:nums){\\n            sum+=i;\\n            if(i % 3 == 1) {\\n                if(i<= smallest_num_with_mod_1){\\n                    int temp = smallest_num_with_mod_1;\\n                    smallest_num_with_mod_1 = i;\\n                    second_smallest_num_with_mod_1 = temp;\\n                }else if(i< second_smallest_num_with_mod_1){\\n                    second_smallest_num_with_mod_1 = i;\\n                }\\n            }\\n            if(i % 3 == 2) {\\n                if(i<= smallest_num_with_mod_2){\\n                    int temp = smallest_num_with_mod_2;\\n                    smallest_num_with_mod_2 = i;\\n                    second_smallest_num_with_mod_2 = temp;\\n                }else if(i< second_smallest_num_with_mod_2){\\n                    second_smallest_num_with_mod_2 = i;\\n                }\\n            }\\n        }\\n        if(sum % 3 == 0) return sum;\\n        \\n        else if(sum % 3 == 2) {\\n            int min = Math.min(smallest_num_with_mod_2,smallest_num_with_mod_1+second_smallest_num_with_mod_1);\\n            return sum-min;\\n        }else if( sum % 3 == 1){\\n            int min = Math.min(smallest_num_with_mod_1,smallest_num_with_mod_2+second_smallest_num_with_mod_2);\\n            return sum - min;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic int maxSumDivThree(int[] nums) {\\nint sum = 0;\\nList ones = new ArrayList<>();\\nList twos = new ArrayList<>();\\nfor(int i:nums){\\nsum+=i;\\nif(i % 3 == 1) {\\nones.add(i);\\n}\\nif(i % 3 == 2) twos.add(i);\\n}\\nCollections.sort(ones);\\nCollections.sort(twos);\\nif(sum % 3 == 0) return sum;\\n\\n    else if(sum % 3 == 2) {\\n        int min = 0;\\n        if(ones.size() >= 2){\\n           min = Math.min(twos.get(0),ones.get(0)+ones.get(1));\\n            return sum-min;\\n        }else{\\n            min = twos.get(0);\\n        }\\n        return sum - min;\\n    }else if( sum % 3 == 1){\\n        int min = 0;\\n        if(twos.size() >= 2){\\n            min = Math.min(ones.get(0),twos.get(0)+twos.get(1));\\n        }else{\\n            min = ones.get(0);\\n        }\\n        return sum - min;\\n    }\\n    return sum;\\n}\\n}\\n```\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        int smallest_num_with_mod_1 = 10001;\\n        int second_smallest_num_with_mod_1 = 10002;\\n        int smallest_num_with_mod_2 = 10001;\\n        int second_smallest_num_with_mod_2 = 10002;\\n        for(int i:nums){\\n            sum+=i;\\n            if(i % 3 == 1) {\\n                if(i<= smallest_num_with_mod_1){\\n                    int temp = smallest_num_with_mod_1;\\n                    smallest_num_with_mod_1 = i;\\n                    second_smallest_num_with_mod_1 = temp;\\n                }else if(i< second_smallest_num_with_mod_1){\\n                    second_smallest_num_with_mod_1 = i;\\n                }\\n            }\\n            if(i % 3 == 2) {\\n                if(i<= smallest_num_with_mod_2){\\n                    int temp = smallest_num_with_mod_2;\\n                    smallest_num_with_mod_2 = i;\\n                    second_smallest_num_with_mod_2 = temp;\\n                }else if(i< second_smallest_num_with_mod_2){\\n                    second_smallest_num_with_mod_2 = i;\\n                }\\n            }\\n        }\\n        if(sum % 3 == 0) return sum;\\n        \\n        else if(sum % 3 == 2) {\\n            int min = Math.min(smallest_num_with_mod_2,smallest_num_with_mod_1+second_smallest_num_with_mod_1);\\n            return sum-min;\\n        }else if( sum % 3 == 1){\\n            int min = Math.min(smallest_num_with_mod_1,smallest_num_with_mod_2+second_smallest_num_with_mod_2);\\n            return sum - min;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473354,
                "title": "c-o-1-space-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tvector<int> dp{0,0,0};\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tvector<int> temp;\\n\\t\\t\\t\\ttemp=dp;\\n\\t\\t\\t\\tfor(auto x:dp){\\n\\t\\t\\t\\t\\tint cur=x+nums[i];\\n\\t\\t\\t\\t\\ttemp[cur%3]=max(temp[cur%3],cur);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp=temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tvector<int> dp{0,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 431070,
                "title": "python-dp-solution",
                "content": "\\n```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dp = [0, 0, 0]\\n        \\n        for n in nums:\\n            tmp_dp = dp[:]\\n            for i in range(len(dp)):\\n                c_sum = tmp_dp[i] + n\\n                dp[c_sum % 3] = max(dp[c_sum % 3], c_sum)\\n\\n\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dp = [0, 0, 0]\\n        \\n        for n in nums:\\n            tmp_dp = dp[:]\\n            for i in range(len(dp)):\\n                c_sum = tmp_dp[i] + n\\n                dp[c_sum % 3] = max(dp[c_sum % 3], c_sum)\\n\\n\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246922,
                "title": "greatest-sum-divisible-by-three-cpp-o-n-greedy-100-fast-100-space",
                "content": "# ***Explaination***\\n\\n**f1**  stores the minimum possible value of a number whose mod to 3 is **1**.\\n**s1** stores the second minimum possible value of a number whose mod to 3 is **1**.\\n**ct1** stores the count of numbers whose mod to 3 is **1**.\\n\\nSimilarly,\\n\\n**f2**  stores the minimum possible value of a number whose mod to 3 is **2**.\\n**s2** stores the second minimum possible value of a number whose mod to 3 is **2**.\\n**ct2** stores the count of numbers whose mod to 3 is **2**.\\n\\n**res** stores the sum of the whole input array.\\n\\nNow, while traversing the loop, we will keep on updating the values for all the variables.\\n\\n***Now, the main logic starts here!***\\n\\nThere can be three possible values for this ***(ct1+ct2*2)%3*** which are clearly **0, 1, and 2**\\n\\n***CASE I: 0***\\nWe will simply return the **res** value because all the values sum upto such a value which is divisible by three.\\n\\n***CASE II: 1***\\nWe need to remove either **1 element** with ***value % 3 == 1*** or we can remove **2 elements** (if possible) with ***value % 3 == 2***  as this will lead to maximum valid sum possible. So, here ***f1, f2, s2*** comes into the picture.\\n\\n***CASE III: 2***\\nWe need to remove either **1 element** with ***value % 3 == 2*** or we can remove **2 elements** (if possible) with ***value % 3 == 1***  as this will lead to maximum valid sum possible. So, here ***f2, f1, s1*** comes into the picture.\\n\\nThis is how, I have solved the question. If you liked the solution, do upvote it.\\n\\n# ***Code***\\n\\n```\\nint maxSumDivThree(vector<int>& nums) {\\n\\tint f1=-1;\\n\\tint s1=-1;\\n\\tint f2=-1;\\n\\tint s2=-1;\\n\\tint ct1=0, ct2=0;\\n\\tint res = 0;\\n\\tint n = nums.size();\\n\\tfor(int i=0; i<n; i++) {\\n\\t\\tint mod = nums[i]%3;\\n\\t\\tif(mod == 1) {\\n\\t\\t\\tif(f1 == -1 || nums[i] < nums[f1]) {\\n\\t\\t\\t\\ts1 = f1;\\n\\t\\t\\t\\tf1 = i;\\n\\t\\t\\t} else if(s1 == -1 || nums[i] < nums[s1]) {\\n\\t\\t\\t\\ts1 = i;\\n\\t\\t\\t}\\n\\t\\t\\tct1 += 1;\\n\\t\\t} else if(mod == 2) {\\n\\t\\t\\tif(f2 == -1 || nums[i] < nums[f2]) {\\n\\t\\t\\t\\ts2 = f2;\\n\\t\\t\\t\\tf2 = i;\\n\\t\\t\\t} else if(s2 == -1 || nums[i] < nums[s2]) {\\n\\t\\t\\t\\ts2 = i;\\n\\t\\t\\t}\\n\\t\\t\\tct2 += 1;\\n\\t\\t}\\n\\t\\tres += nums[i];\\n\\t}\\n\\n\\tint mod = (ct1+ct2*2)%3;\\n\\n\\tif(mod==1) {\\n\\t\\tint val2 = INT_MAX;\\n\\t\\tint val1 = nums[f1];\\n\\t\\tif(f2 != -1 && s2 != -1) val2 = nums[f2]+nums[s2];\\n\\t\\tif(val1>val2) res-=val2;\\n\\t\\telse res-=val1;\\n\\t} else if(mod==2) {\\n\\t\\tint val1 = INT_MAX, val2 = INT_MAX;\\n\\t\\tif(f1!=-1 and s1!=-1) {\\n\\t\\t\\tval1 = nums[f1]+nums[s1];\\n\\t\\t}\\n\\t\\tif(f2!=-1) val2 = nums[f2];\\n\\n\\t\\tif(val1<val2) res-=val1;\\n\\t\\telse res-=val2;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint maxSumDivThree(vector<int>& nums) {\\n\\tint f1=-1;\\n\\tint s1=-1;\\n\\tint f2=-1;\\n\\tint s2=-1;\\n\\tint ct1=0, ct2=0;\\n\\tint res = 0;\\n\\tint n = nums.size();\\n\\tfor(int i=0; i<n; i++) {\\n\\t\\tint mod = nums[i]%3;\\n\\t\\tif(mod == 1) {\\n\\t\\t\\tif(f1 == -1 || nums[i] < nums[f1]) {\\n\\t\\t\\t\\ts1 = f1;\\n\\t\\t\\t\\tf1 = i;\\n\\t\\t\\t} else if(s1 == -1 || nums[i] < nums[s1]) {\\n\\t\\t\\t\\ts1 = i;\\n\\t\\t\\t}\\n\\t\\t\\tct1 += 1;\\n\\t\\t} else if(mod == 2) {\\n\\t\\t\\tif(f2 == -1 || nums[i] < nums[f2]) {\\n\\t\\t\\t\\ts2 = f2;\\n\\t\\t\\t\\tf2 = i;\\n\\t\\t\\t} else if(s2 == -1 || nums[i] < nums[s2]) {\\n\\t\\t\\t\\ts2 = i;\\n\\t\\t\\t}\\n\\t\\t\\tct2 += 1;\\n\\t\\t}\\n\\t\\tres += nums[i];\\n\\t}\\n\\n\\tint mod = (ct1+ct2*2)%3;\\n\\n\\tif(mod==1) {\\n\\t\\tint val2 = INT_MAX;\\n\\t\\tint val1 = nums[f1];\\n\\t\\tif(f2 != -1 && s2 != -1) val2 = nums[f2]+nums[s2];\\n\\t\\tif(val1>val2) res-=val2;\\n\\t\\telse res-=val1;\\n\\t} else if(mod==2) {\\n\\t\\tint val1 = INT_MAX, val2 = INT_MAX;\\n\\t\\tif(f1!=-1 and s1!=-1) {\\n\\t\\t\\tval1 = nums[f1]+nums[s1];\\n\\t\\t}\\n\\t\\tif(f2!=-1) val2 = nums[f2];\\n\\n\\t\\tif(val1<val2) res-=val1;\\n\\t\\telse res-=val2;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1065983,
                "title": "c-dp-general-approach-for-given-k-o-n-time-o-k-space",
                "content": "This is a general case for given K of a lineartime complexity and only K additional memory.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        return maxSumDivK(nums, 3);\\n    }\\n    \\n    int maxSumDivK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(k, INT_MIN);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int num = nums[i - 1], mod = nums[i - 1] % k;\\n            vector<int> newDp(k);\\n            \\n            for (int j = 0; j < k; j++) {\\n                newDp[j] = max(dp[j], dp[(j + mod) % k] + num);\\n            }\\n            \\n            dp = newDp;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        return maxSumDivK(nums, 3);\\n    }\\n    \\n    int maxSumDivK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(k, INT_MIN);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int num = nums[i - 1], mod = nums[i - 1] % k;\\n            vector<int> newDp(k);\\n            \\n            for (int j = 0; j < k; j++) {\\n                newDp[j] = max(dp[j], dp[(j + mod) % k] + num);\\n            }\\n            \\n            dp = newDp;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897819,
                "title": "python-no-trick-only-case-discussion-o-2n-99-9",
                "content": "The code looks long but actually very simple to read; just if/else discusions.\\n\\n- **get sum**\\n- **get residue**\\n- **find numbers to eliminate**\\n\\t- if residue==0:  no need to eliminate\\n\\t- if residue==1:  means there are either 1 One or 2 Two need to be eliminated\\n\\t- if residue==2:  means therea re either 1 Two or 2 One need to be eliminated\\n\\t- Terms explanation: \\n\\t\\t- \\'One\\': num,  s.t. num%3==1 \\n\\t\\t- \\'Two\\': num, s.t. num%3==2\\n\\t- find smallest number(s) to eliminate\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        summ = sum(nums)\\n        residue = summ % 3\\n        \\n        if residue == 0: return summ\\n        \\n        elif residue == 1:   # one, two+two\\n            min1 = min2 = single = float(\\'inf\\')\\n            for x in nums:\\n                if x % 3 == 2:\\n                    if x < min1:\\n                        min1, min2 = x, min1\\n                    elif x < min2:\\n                        min2 = x\\n                elif x % 3 == 1:\\n                    if x < single:\\n                        single = x\\n            if single == float(\\'inf\\'): return summ - min1 - min2\\n            elif min1 == float(\\'inf\\'): return summ - single\\n            else: return summ - min(min1+min2, single)     \\n            \\n        elif residue == 2:   # two, one+one\\n            min1 = min2 = single = float(\\'inf\\')\\n            for x in nums:\\n                if x % 3 == 1:\\n                    if x < min1:\\n                        min1, min2 = x, min1\\n                    elif x < min2:\\n                        min2 = x\\n                elif x % 3 == 2:\\n                    if x < single:\\n                        single = x\\n            if single == float(\\'inf\\'):return summ - min1 - min2\\n            elif min1 == float(\\'inf\\'): return summ - single\\n            else: return summ - min(min1+min2, single)        \\n```\\n\\n**Upvote!** Thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        summ = sum(nums)\\n        residue = summ % 3\\n        \\n        if residue == 0: return summ\\n        \\n        elif residue == 1:   # one, two+two\\n            min1 = min2 = single = float(\\'inf\\')\\n            for x in nums:\\n                if x % 3 == 2:\\n                    if x < min1:\\n                        min1, min2 = x, min1\\n                    elif x < min2:\\n                        min2 = x\\n                elif x % 3 == 1:\\n                    if x < single:\\n                        single = x\\n            if single == float(\\'inf\\'): return summ - min1 - min2\\n            elif min1 == float(\\'inf\\'): return summ - single\\n            else: return summ - min(min1+min2, single)     \\n            \\n        elif residue == 2:   # two, one+one\\n            min1 = min2 = single = float(\\'inf\\')\\n            for x in nums:\\n                if x % 3 == 1:\\n                    if x < min1:\\n                        min1, min2 = x, min1\\n                    elif x < min2:\\n                        min2 = x\\n                elif x % 3 == 2:\\n                    if x < single:\\n                        single = x\\n            if single == float(\\'inf\\'):return summ - min1 - min2\\n            elif min1 == float(\\'inf\\'): return summ - single\\n            else: return summ - min(min1+min2, single)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 725974,
                "title": "easy-c-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<vector<int>> dp(n, vector<int>(3, 0));\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i==0)\\n            {\\n                dp[0][nums[0]%3] = nums[0];\\n                continue;\\n            }\\n            for(int j=0; j<3; j++) dp[i][j] = dp[i-1][j];            \\n            for(int j=0; j<3; j++)\\n            {\\n                int t=nums[i]+dp[i-1][j];\\n                dp[i][t%3] = max(dp[i][t%3], t);\\n            }\\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<vector<int>> dp(n, vector<int>(3, 0));\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i==0)\\n            {\\n                dp[0][nums[0]%3] = nums[0];\\n                continue;\\n            }\\n            for(int j=0; j<3; j++) dp[i][j] = dp[i-1][j];            \\n            for(int j=0; j<3; j++)\\n            {\\n                int t=nums[i]+dp[i-1][j];\\n                dp[i][t%3] = max(dp[i][t%3], t);\\n            }\\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497058,
                "title": "python-3-four-lines-math-solution-no-dp-beats-92",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, N: List[int]) -> int:\\n        A, B, S = heapq.nsmallest(2,[n for n in N if n % 3 == 1]), heapq.nsmallest(2,[n for n in N if n % 3 == 2]), sum(N)\\n        if S % 3 == 0: return S\\n        if S % 3 == 1: return S - min(A[0], sum(B) if len(B) > 1 else math.inf)\\n        if S % 3 == 2: return S - min(B[0], sum(A) if len(A) > 1 else math.inf)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, N: List[int]) -> int:\\n        A, B, S = heapq.nsmallest(2,[n for n in N if n % 3 == 1]), heapq.nsmallest(2,[n for n in N if n % 3 == 2]), sum(N)\\n        if S % 3 == 0: return S\\n        if S % 3 == 1: return S - min(A[0], sum(B) if len(B) > 1 else math.inf)\\n        if S % 3 == 2: return S - min(B[0], sum(A) if len(A) > 1 else math.inf)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 2316748,
                "title": "c-easy-to-understand-memoization-iterative-dp",
                "content": "**Memoization (Top-Down DP)**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int fun(vector<int> &nums,int i,int sum,int rem,vector<vector<int>> &dp)\\n    {\\n        if(i>=n)\\n        {\\n            if(sum%3==0)\\n            return 0;\\n            else\\n            return INT_MIN;\\n        }\\n        \\n        if(dp[i][rem]!=-1)\\n        return dp[i][rem];\\n        \\n        int ans=0;\\n        ans=nums[i]+fun(nums,i+1,sum+nums[i],(rem+nums[i]%3)%3,dp);\\n        ans=max(ans,fun(nums,i+1,sum,rem,dp));\\n        \\n        return dp[i][rem]=ans;\\n    }\\n    int maxSumDivThree(vector<int>& nums) {\\n        n=nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(4,-1));\\n        return fun(nums,0,0,0,dp);\\n    }\\n};\\n```\\n**Iterative DP(Bottom-Up DP)**\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(3,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int sum1,sum2,sum3;\\n            sum1=nums[i-1]+dp[i-1][0];\\n            sum2=nums[i-1]+dp[i-1][1];\\n            sum3=nums[i-1]+dp[i-1][2];\\n            dp[i]=dp[i-1];\\n            dp[i][sum1%3]=max(dp[i][sum1%3],sum1);\\n            dp[i][sum2%3]=max(dp[i][sum2%3],sum2);\\n            dp[i][sum3%3]=max(dp[i][sum3%3],sum3);\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int fun(vector<int> &nums,int i,int sum,int rem,vector<vector<int>> &dp)\\n    {\\n        if(i>=n)\\n        {\\n            if(sum%3==0)\\n            return 0;\\n            else\\n            return INT_MIN;\\n        }\\n        \\n        if(dp[i][rem]!=-1)\\n        return dp[i][rem];\\n        \\n        int ans=0;\\n        ans=nums[i]+fun(nums,i+1,sum+nums[i],(rem+nums[i]%3)%3,dp);\\n        ans=max(ans,fun(nums,i+1,sum,rem,dp));\\n        \\n        return dp[i][rem]=ans;\\n    }\\n    int maxSumDivThree(vector<int>& nums) {\\n        n=nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(4,-1));\\n        return fun(nums,0,0,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(3,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int sum1,sum2,sum3;\\n            sum1=nums[i-1]+dp[i-1][0];\\n            sum2=nums[i-1]+dp[i-1][1];\\n            sum3=nums[i-1]+dp[i-1][2];\\n            dp[i]=dp[i-1];\\n            dp[i][sum1%3]=max(dp[i][sum1%3],sum1);\\n            dp[i][sum2%3]=max(dp[i][sum2%3],sum2);\\n            dp[i][sum3%3]=max(dp[i][sum3%3],sum3);\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995032,
                "title": "python3-math-sol-no-dp-or-recursion-t-m-97-84",
                "content": "```class Solution:\\n    def maxSumDivThree(self, nums: list[int]) -> int:\\n                    # Determine the list sum mod 3. if sum is \\n                    # is 0 mod 3, we are done\\n        n = sum(nums)               \\n        nDiv3 = n%3\\n        if nDiv3 == 0: return n\\n\\n                    # all terms 0 mod 3 can be ignored\\n                    # the remaining terms are 1 mod 3 and 2 mod 3\\n                    # the task reduces to finding the smallest term\\n                    # or sum of two terms that is equal to nDiv3 mod 3,\\n                    # so we find the least two terms each (if they exist)\\n                    # from those terms that are 1 mod 3 and 2 mod 3.\\n                    # We pad this list with zeros so len(terms) == 5\\n        nums1 = sorted([x for x in nums if x%3 == 1])[:2]\\n        nums2 = sorted([x for x in nums if x%3 == 2])[:2]\\n        terms = nums1 + nums2\\n        terms+= [0]*(5-len(terms))\\n                                    \\n                    # We iterate for the sums of all pairs in terms.\\n                    # Because there is at least one zero in terms, the  \\n                    # individual terms also will be in the collection of \\n                    # sums. Finding the least sum from the collection of  \\n                    # sums with the appropriate mod 3 and subtracting it \\n                    # from n gives us the answer.\\n        ans = []                    \\n        for i in range(5):\\n            for j in range(i+1,5):\\n                if (terms[i]+terms[j])%3 == nDiv3:\\n                    ans.append(terms[i]+terms[j])\\n          \\n        return n - min(ans)",
                "solutionTags": [],
                "code": "```class Solution:\\n    def maxSumDivThree(self, nums: list[int]) -> int:\\n                    # Determine the list sum mod 3. if sum is \\n                    # is 0 mod 3, we are done\\n        n = sum(nums)               \\n        nDiv3 = n%3\\n        if nDiv3 == 0: return n\\n\\n                    # all terms 0 mod 3 can be ignored\\n                    # the remaining terms are 1 mod 3 and 2 mod 3\\n                    # the task reduces to finding the smallest term\\n                    # or sum of two terms that is equal to nDiv3 mod 3,\\n                    # so we find the least two terms each (if they exist)\\n                    # from those terms that are 1 mod 3 and 2 mod 3.\\n                    # We pad this list with zeros so len(terms) == 5\\n        nums1 = sorted([x for x in nums if x%3 == 1])[:2]\\n        nums2 = sorted([x for x in nums if x%3 == 2])[:2]\\n        terms = nums1 + nums2\\n        terms+= [0]*(5-len(terms))\\n                                    \\n                    # We iterate for the sums of all pairs in terms.\\n                    # Because there is at least one zero in terms, the  \\n                    # individual terms also will be in the collection of \\n                    # sums. Finding the least sum from the collection of  \\n                    # sums with the appropriate mod 3 and subtracting it \\n                    # from n gives us the answer.\\n        ans = []                    \\n        for i in range(5):\\n            for j in range(i+1,5):\\n                if (terms[i]+terms[j])%3 == nDiv3:\\n                    ans.append(terms[i]+terms[j])\\n          \\n        return n - min(ans)",
                "codeTag": "Java"
            },
            {
                "id": 1369213,
                "title": "c-dp-constant-space",
                "content": "```\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int>v(3);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i]+v[0],y=nums[i]+v[1],z=nums[i]+v[2];\\n            v[x%3]=max(x, v[x%3]); \\n            v[y%3]=max(y, v[y%3]); \\n            v[z%3]=max(z, v[z%3]); \\n        }\\n        return v[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int>v(3);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i]+v[0],y=nums[i]+v[1],z=nums[i]+v[2];\\n            v[x%3]=max(x, v[x%3]); \\n            v[y%3]=max(y, v[y%3]); \\n            v[z%3]=max(z, v[z%3]); \\n        }\\n        return v[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1028889,
                "title": "java-detailed-summary-of-3-one-pass-o-n-solutions-math-and-two-dp",
                "content": "## Solution 1: Math\\n\\n### Algorithm\\n\\nWe can divide all elements into 3 groups based on `nums[i]%3,` and if:\\n\\n- `totalSum % 3 == 1`: we need to either take out the smallest number from group 1 (`nums[i] % 3 == 1`) , or the two smallest numbers from group 2 (`nums[i] % 3 == 2`), whichever have a smaller total amount.\\n- `totalSum % 3 == 2`: take out the smallest number from group2, or the two smallest numbers from group 1.\\n\\n### Complexity\\n\\nTime: O(n), space O(1)\\n\\n### Caveat\\n\\nCan\\'t generalize 3 to k\\n\\n```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        long min1 = Integer.MAX_VALUE; // smallest of num with num % 3 == 1\\n        long secMin1 = Integer.MAX_VALUE; // second smallest num % 3 == 1\\n        long min2 = Integer.MAX_VALUE; // smallest num with num % 3 == 2\\n        long secMin2 = Integer.MAX_VALUE; // second smallest num % 3 == 2\\n        \\n        long sum = 0;\\n        for (int num: nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                if (num <= min1) {\\n                    secMin1 = min1;\\n                    min1 = num;\\n                } else if (num <= secMin1) {\\n                    secMin1 = num;\\n                }\\n            } else if (num % 3 == 2) {\\n                if (num <= min2) {\\n                    secMin2 = min2;\\n                    min2 = num;\\n                } else if (num <= secMin2) {\\n                    secMin2 = num;\\n                }\\n            }\\n        }\\n        \\n        if (sum % 3 == 0) {\\n            return (int) sum;\\n        } \\n        long takeout = sum % 3 == 1 ? Math.min(min1, min2 + secMin2) : Math.min(min2, min1 + secMin1);\\n        return takeout < Integer.MAX_VALUE ? (int) (sum - takeout) : 0;\\n        \\n    }\\n}\\n```\\n\\n## Solution 2: DP\\n\\n### Intuition\\n\\nFor `nums[i]`, to get max possible subset sum in `nums[0...i]` with `sum % 3 == 0`, we can choose to:\\n\\n- include `nums[i]` in the subset, then we need to find max subset sum in `nums[0...i-1]` with `(sum + nums[i]) % 3 == 0`, i.e. `sum % 3 == (3 - nums[i] % 3) % 3`\\n- not include `nums[i]`, then we need to find max subset sum in `nums[0...i-1]` with `sum % 3 == 0`\\n\\nSo problem with size `i` depends on problem with size `i-1` with other remainder `1` or `2` as well.\\n\\n### State\\n\\n`dp[i][j]` = max possible subset sum in first `i` elements of nums with `sum % 3 == j`\\n\\n### State transition\\n\\n`dp[i][j] = max(dp[i-1][j], dp[i-1][x] + nums[i-1])`, \\n\\nwhere `x = (j - nums[i-1] % 3 + 3) % 3` is actually  `Math.floorMod(j - nums[i-1] % 3, 3)`, e.g. `x = 0, 2, 1` for `nums[i-1] = 0, 1, 2`. Note `floorMod` preserves the sign of the divisor.\\n\\n### Base state\\n\\n`dp[0][0] = 0`, `dp[0][1] = -Inf`, `dp[0][2] = -Inf`, where `-Inf` represents impossible states.\\n\\n### Answer\\n\\n`dp[n][0]`\\n\\n### Complexity\\n\\nTime `O(n)`, space `O(n)`, can be optimized to `O(1)`\\n\\n```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n        dp[1] = Integer.MIN_VALUE;\\n        dp[2] = Integer.MIN_VALUE;\\n        for (int num: nums) {\\n            int[] prev = Arrays.copyOf(dp, 3);\\n            for (int k = 0; k < 3; k++) {\\n                int x = (k - num % 3 + 3) % 3;\\n                dp[k] = Math.max(prev[k], num + prev[x]);\\n            }\\n        }\\n        return dp[0] < 0 ? 0 : dp[0];\\n    }\\n}\\n```\\n\\n## Solution 3: Another DP\\n\\n\\u26A0\\uFE0F  This DP approach is harder to reason about, since when updating the states, the second index is NOT directly specified in the for-loop, instead, it depends on the previous state\\'s value. As a result, for a given outer loop index `i` the state `dp[i][j]` may get updated multiple times for some `j`, and not updated at all for some other `j`.\\n\\n### State\\n\\n`dp[i][j]` is the max possible subset sum of the first `i` elements in `nums` with `sum % 3 == j`. **If not possible, `dp[i][j] = 0`. (previously we use `dp[i][j] = -Inf` for impossible state).** \\n\\n### State transition\\n\\nFor each previous max subset sum with modulus `j`, try to add current number `num = nums[i-1]` to it and compare with not adding it, i.e.\\n\\n```java\\ndp[i][(s + num) % 3] = \\n\\tmax{dp[i-1][(s + num) % 3], s + num | s = dp[i-1][j],  0 <= j < 3}\\n```\\n\\n\\uD83D\\uDD25\\uFE0F Why the left side can\\'t be `dp[i][j + num) % 3`?\\n\\nIt is true that `(s + num) % 3 = (dp[i-1][j] + num) % 3` should be equivalent to `(j + num) % 3`, **if we assume `dp[i-1][j] % 3 == j`.** \\n\\nHowever, that assumption does NOT hold given that `dp[i-1][j]` could be 0.\\n\\n\\uD83D\\uDD25\\uFE0F `s = dp[i-1][j], 0 <= j < 3` can be the SAME for multiple `j`, i.e. we may update the same `dp[i][x]` multiple times.  This is very important in the implementation.\\n\\n### Base states\\n\\n`dp[0][j] = 0`\\n\\n### Answer\\n\\n`dp[n][0]`\\n\\n### Complexity\\n\\nTime `O(n)`, space `O(n)`, can be optimized to `O(1)`\\n\\n```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n    \\n        for (int num: nums) {\\n            // why can\\'t iterate over remainder k=0,1,2? It\\'s because prevSum[k] % 3 == k is not always true, e.g. prevSum[1] can be 0!!!\\n            int[] prev = Arrays.copyOf(dp, 3);\\n            for (int s: prev) { \\n                // why not dp[(s + num) % 3] = max(prev[(s + num) % 3], s + num) ? \\n                // This is because dp[x] can be updated multiple times!\\n                // e.g. prev = [3 0 0], num = 5, then dp[2] will be updated 3 times with 8, 5, 5\\n                dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num); \\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        long min1 = Integer.MAX_VALUE; // smallest of num with num % 3 == 1\\n        long secMin1 = Integer.MAX_VALUE; // second smallest num % 3 == 1\\n        long min2 = Integer.MAX_VALUE; // smallest num with num % 3 == 2\\n        long secMin2 = Integer.MAX_VALUE; // second smallest num % 3 == 2\\n        \\n        long sum = 0;\\n        for (int num: nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                if (num <= min1) {\\n                    secMin1 = min1;\\n                    min1 = num;\\n                } else if (num <= secMin1) {\\n                    secMin1 = num;\\n                }\\n            } else if (num % 3 == 2) {\\n                if (num <= min2) {\\n                    secMin2 = min2;\\n                    min2 = num;\\n                } else if (num <= secMin2) {\\n                    secMin2 = num;\\n                }\\n            }\\n        }\\n        \\n        if (sum % 3 == 0) {\\n            return (int) sum;\\n        } \\n        long takeout = sum % 3 == 1 ? Math.min(min1, min2 + secMin2) : Math.min(min2, min1 + secMin1);\\n        return takeout < Integer.MAX_VALUE ? (int) (sum - takeout) : 0;\\n        \\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n        dp[1] = Integer.MIN_VALUE;\\n        dp[2] = Integer.MIN_VALUE;\\n        for (int num: nums) {\\n            int[] prev = Arrays.copyOf(dp, 3);\\n            for (int k = 0; k < 3; k++) {\\n                int x = (k - num % 3 + 3) % 3;\\n                dp[k] = Math.max(prev[k], num + prev[x]);\\n            }\\n        }\\n        return dp[0] < 0 ? 0 : dp[0];\\n    }\\n}\\n```\n```java\\ndp[i][(s + num) % 3] = \\n\\tmax{dp[i-1][(s + num) % 3], s + num | s = dp[i-1][j],  0 <= j < 3}\\n```\n```java\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n    \\n        for (int num: nums) {\\n            // why can\\'t iterate over remainder k=0,1,2? It\\'s because prevSum[k] % 3 == k is not always true, e.g. prevSum[1] can be 0!!!\\n            int[] prev = Arrays.copyOf(dp, 3);\\n            for (int s: prev) { \\n                // why not dp[(s + num) % 3] = max(prev[(s + num) % 3], s + num) ? \\n                // This is because dp[x] can be updated multiple times!\\n                // e.g. prev = [3 0 0], num = 5, then dp[2] will be updated 3 times with 8, 5, 5\\n                dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num); \\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957683,
                "title": "c-dp",
                "content": "### [\\u53C2\\u8003](https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/559999/Come-here-if-you-can\\'t-seem-to-get-it-(Full-Explanation-%2B-uncondensed-code))\\n```C++\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        \\n        vector<vector<int>> dp(N+1, vector<int>(3, 0));\\n        \\n        dp[0][0] = 0;\\n        dp[0][1] = INT_MIN;\\n        dp[0][2] = INT_MIN;\\n        \\n        for (int i = 1; i <= N; i++)\\n        {\\n            if (nums[i-1] % 3 == 0)\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1]);\\n\\t\\t\\t    dp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1]);\\n\\t\\t\\t    dp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1]);\\n            }\\n            else if (nums[i-1] % 3 == 1)\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1]);\\n                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]);\\n                dp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1]);\\n            }\\n            else\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1]);\\n\\t\\t\\t    dp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1]);\\n\\t\\t\\t    dp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1]);\\n            }\\n        }\\n        \\n        return dp[N][0];\\n    }\\n};\\n```\\n\\n### [\\u53C2\\u8003](https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-1262-greatest-sum-divisible-by-three/)\\n```C++\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int> dp(3);\\n        \\n        for (const auto& num : nums)\\n        {\\n            vector<int> tmp (dp);\\n            \\n            for (const auto & s : tmp)\\n            {\\n                dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        \\n        vector<vector<int>> dp(N+1, vector<int>(3, 0));\\n        \\n        dp[0][0] = 0;\\n        dp[0][1] = INT_MIN;\\n        dp[0][2] = INT_MIN;\\n        \\n        for (int i = 1; i <= N; i++)\\n        {\\n            if (nums[i-1] % 3 == 0)\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1]);\\n\\t\\t\\t    dp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1]);\\n\\t\\t\\t    dp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1]);\\n            }\\n            else if (nums[i-1] % 3 == 1)\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1]);\\n                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]);\\n                dp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1]);\\n            }\\n            else\\n            {\\n                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1]);\\n\\t\\t\\t    dp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1]);\\n\\t\\t\\t    dp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1]);\\n            }\\n        }\\n        \\n        return dp[N][0];\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int> dp(3);\\n        \\n        for (const auto& num : nums)\\n        {\\n            vector<int> tmp (dp);\\n            \\n            for (const auto & s : tmp)\\n            {\\n                dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699057,
                "title": "very-easy-to-understand-python-code-time-o-n-space-o-1",
                "content": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0,0,0]\\n        for i in nums:\\n            v0 = dp[0]+i\\n            v1 = dp[1]+i\\n            v2 = dp[2]+i\\n            dp[v0%3] = max(dp[v0%3],v0)\\n            dp[v1%3] = max(dp[v1%3],v1)\\n            dp[v2%3] = max(dp[v2%3],v2)\\n        return dp[0]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0,0,0]\\n        for i in nums:\\n            v0 = dp[0]+i\\n            v1 = dp[1]+i\\n            v2 = dp[2]+i\\n            dp[v0%3] = max(dp[v0%3],v0)\\n            dp[v1%3] = max(dp[v1%3],v1)\\n            dp[v2%3] = max(dp[v2%3],v2)\\n        return dp[0]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 686960,
                "title": "simple-c-solution-with-explanation",
                "content": "Sum array stores the max Sum that give remainder 0,1,2 respectively when divided by 3.\\nInitially sum is (0,0,0).\\nAt any point when a new number is processed, add it to all individual elements of Sum array(stored in the temp 2D array) and then check whether the new generated numbers have greater sum than the previous elements in Sum array.\\ne.g - Suppose Sum array is (3,16,11) an the next number to process is 7. The new temporary sums are (10,23,18). Thus Sum now becomes (max(3,18),max(16,10),max(11,23)) = (18,16,23).\\nFinally sum[0] has the max sum which we need.\\n```\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> sum(3,0);\\n        vector<vector<int>> temp;\\n        vector<int> row;\\n        //Sum is a an array storing max sums  mod3 = 0,1,2\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<3;j++){\\n                row.push_back((sum[j] + nums[i])%3);\\n                row.push_back(sum[j] + nums[i]);\\n                temp.push_back(row);\\n                row.clear();\\n            }\\n            sort(temp.begin(),temp.end());\\n\\t\\t\\t//If we get 2 or more numbers with same remainder mod 3, then we take the highest among the two. \\n\\t\\t\\t//Thus sort temp and traverse from end in temp.\\n            for(int j=2;j>=0;j--){\\n                sum[temp[j][0]] = max(sum[temp[j][0]],temp[j][1]);    \\n            }\\n            temp.clear();\\n        }\\n        return sum[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> sum(3,0);\\n        vector<vector<int>> temp;\\n        vector<int> row;\\n        //Sum is a an array storing max sums  mod3 = 0,1,2\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<3;j++){\\n                row.push_back((sum[j] + nums[i])%3);\\n                row.push_back(sum[j] + nums[i]);\\n                temp.push_back(row);\\n                row.clear();\\n            }\\n            sort(temp.begin(),temp.end());\\n\\t\\t\\t//If we get 2 or more numbers with same remainder mod 3, then we take the highest among the two. \\n\\t\\t\\t//Thus sort temp and traverse from end in temp.\\n            for(int j=2;j>=0;j--){\\n                sum[temp[j][0]] = max(sum[temp[j][0]],temp[j][1]);    \\n            }\\n            temp.clear();\\n        }\\n        return sum[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575977,
                "title": "c-dp",
                "content": "Use dp to store max sum\\'s with remainder 0, 1 and 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int>dp = {0, 0, 0};\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            vector<int>ndp = dp;\\n            for (int j =  0; j < 3; j++) {\\n                int x = dp[j] + nums[i];\\n                ndp[x%3] = max(ndp[x%3], x);\\n            }\\n            dp = ndp;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int>dp = {0, 0, 0};\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            vector<int>ndp = dp;\\n            for (int j =  0; j < 3; j++) {\\n                int x = dp[j] + nums[i];\\n                ndp[x%3] = max(ndp[x%3], x);\\n            }\\n            dp = ndp;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435540,
                "title": "c-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[40001][3];\\n    int f(int i,int sum,vector<int> &v){\\n        if(i==n)return 0;\\n        \\n        if(dp[i][sum]!=-1)return dp[i][sum];\\n        \\n        int ans=0;\\n        if((sum+f(i+1,sum,v))%3==0){\\n            ans=f(i+1,sum,v);\\n        }\\n        if((sum+v[i]+f(i+1,(sum+v[i])%3,v))%3==0){\\n            ans=max(ans,v[i]+f(i+1,(sum+v[i])%3,v));\\n        }\\n        \\n        return dp[i][sum]=ans;\\n        \\n    }\\n    \\n    int maxSumDivThree(vector<int>& v) {\\n        n=v.size();\\n        memset(dp,-1,sizeof dp);\\n        return f(0,0,v);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[40001][3];\\n    int f(int i,int sum,vector<int> &v){\\n        if(i==n)return 0;\\n        \\n        if(dp[i][sum]!=-1)return dp[i][sum];\\n        \\n        int ans=0;\\n        if((sum+f(i+1,sum,v))%3==0){\\n            ans=f(i+1,sum,v);\\n        }\\n        if((sum+v[i]+f(i+1,(sum+v[i])%3,v))%3==0){\\n            ans=max(ans,v[i]+f(i+1,(sum+v[i])%3,v));\\n        }\\n        \\n        return dp[i][sum]=ans;\\n        \\n    }\\n    \\n    int maxSumDivThree(vector<int>& v) {\\n        n=v.size();\\n        memset(dp,-1,sizeof dp);\\n        return f(0,0,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431633,
                "title": "state-machine-java-o-n-o-1",
                "content": "There are 3 states in this problem. \\n1. sum%3 == 0\\n2. sum%3 == 1\\n3. sum%3 == 2\\nAnd the relationship and transfer method of these three states can be shown as follows:\\n![image](https://assets.leetcode.com/users/luyeyun/image_1574017216.png)\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int zero = 0, one = -1, two = -1;\\n        for(int n:nums){\\n            if(n%3==0){\\n                zero += n;\\n                if(one!=-1) one += n;\\n                if(two!=-1) two += n;\\n            }\\n            else if(n%3==1){\\n                int tmp_zero = zero;\\n                if(two!=-1)\\n                    zero = Math.max(zero,two+n);\\n                if(one!=-1)\\n                    two = Math.max(two,one+n);\\n                one = Math.max(one,tmp_zero+n);\\n            }\\n            else{ // n%3==2\\n                int tmp_zero = zero;\\n                if(one!=-1)\\n                    zero = Math.max(zero,one+n);\\n                if(two!=-1)\\n                    one = Math.max(one,two+n);\\n                two = Math.max(two,tmp_zero+n);\\n            }\\n        }\\n        return zero;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int zero = 0, one = -1, two = -1;\\n        for(int n:nums){\\n            if(n%3==0){\\n                zero += n;\\n                if(one!=-1) one += n;\\n                if(two!=-1) two += n;\\n            }\\n            else if(n%3==1){\\n                int tmp_zero = zero;\\n                if(two!=-1)\\n                    zero = Math.max(zero,two+n);\\n                if(one!=-1)\\n                    two = Math.max(two,one+n);\\n                one = Math.max(one,tmp_zero+n);\\n            }\\n            else{ // n%3==2\\n                int tmp_zero = zero;\\n                if(one!=-1)\\n                    zero = Math.max(zero,one+n);\\n                if(two!=-1)\\n                    one = Math.max(one,two+n);\\n                two = Math.max(two,tmp_zero+n);\\n            }\\n        }\\n        return zero;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431088,
                "title": "c-dp-solution",
                "content": "```f[i][j]``` denotes the maximum subset sum select from nums[0] - nums[i] which modulos 3 equal to j.\\n\\nObviously, at each step, we can choose whether to pick up the current number or not. So, ```f[i][j] = max((f[i - 1][x] + nums[i - 1]) % k == j ? f[i - 1][x] + nums[i - 1] : f[i - 1][x], f[i - 1][j])```\\n\\n```C++\\nclass Solution {\\npublic:\\n  int maxSumDivThree(vector<int>& nums) {\\n    vector<vector<int>> f(nums.size() + 1, vector<int>(3, 0));\\n    int k = 3;\\n    for (int i = 1; i <= nums.size(); i++)\\n      for (int j = 0; j < k; j++) {\\n        int x = (j + k - (nums[i - 1] % k)) % k;\\n        f[i][j] = max((f[i - 1][x] + nums[i - 1]) % k == j ? f[i - 1][x] + nums[i - 1] : f[i - 1][x], f[i - 1][j]);\\n      }\\n    return f[nums.size()][0];\\n  }\\n};\\n```\\n\\nreference: https://stackoverflow.com/questions/13511885/finding-greatest-sum-of-elements-of-array-which-is-divisible-by-a-given-number",
                "solutionTags": [],
                "code": "```f[i][j]```\n```f[i][j] = max((f[i - 1][x] + nums[i - 1]) % k == j ? f[i - 1][x] + nums[i - 1] : f[i - 1][x], f[i - 1][j])```\n```C++\\nclass Solution {\\npublic:\\n  int maxSumDivThree(vector<int>& nums) {\\n    vector<vector<int>> f(nums.size() + 1, vector<int>(3, 0));\\n    int k = 3;\\n    for (int i = 1; i <= nums.size(); i++)\\n      for (int j = 0; j < k; j++) {\\n        int x = (j + k - (nums[i - 1] % k)) % k;\\n        f[i][j] = max((f[i - 1][x] + nums[i - 1]) % k == j ? f[i - 1][x] + nums[i - 1] : f[i - 1][x], f[i - 1][j]);\\n      }\\n    return f[nums.size()][0];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675863,
                "title": "time-o-n-spaceo-1-most-optimezed-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int a = INT_MAX,b = INT_MAX,c=INT_MAX,d=INT_MAX,s=0;\\n        for(auto &i: nums){\\n            s += i;\\n            if(i%3==1){\\n                if(i<a){\\n                    b= a;\\n                    a = i;\\n                }else if(i<b){\\n                    b = i;\\n                }\\n            }else if(i%3==2){\\n                if(i<c){\\n                    d = c;\\n                    c = i;\\n                }else if(i<d){\\n                    d = i;\\n                }\\n            }\\n        }\\n        if(s%3==0)return s;\\n        if(s%3 == 1){\\n            int ans = 0;\\n            if(a != INT_MAX){\\n                ans = s-a;\\n            }\\n            if(d != INT_MAX && c != INT_MAX)ans = max(ans,s-d-c);\\n            return ans;\\n        }\\n        int ans = 0;\\n        if(c != INT_MAX)ans =  s-c;\\n        if(a != INT_MAX && b != INT_MAX)ans = max(ans, s-a-b);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int a = INT_MAX,b = INT_MAX,c=INT_MAX,d=INT_MAX,s=0;\\n        for(auto &i: nums){\\n            s += i;\\n            if(i%3==1){\\n                if(i<a){\\n                    b= a;\\n                    a = i;\\n                }else if(i<b){\\n                    b = i;\\n                }\\n            }else if(i%3==2){\\n                if(i<c){\\n                    d = c;\\n                    c = i;\\n                }else if(i<d){\\n                    d = i;\\n                }\\n            }\\n        }\\n        if(s%3==0)return s;\\n        if(s%3 == 1){\\n            int ans = 0;\\n            if(a != INT_MAX){\\n                ans = s-a;\\n            }\\n            if(d != INT_MAX && c != INT_MAX)ans = max(ans,s-d-c);\\n            return ans;\\n        }\\n        int ans = 0;\\n        if(c != INT_MAX)ans =  s-c;\\n        if(a != INT_MAX && b != INT_MAX)ans = max(ans, s-a-b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461570,
                "title": "o-n-math-based-c-solution-with-constant-space-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the total sum of the array. \\n\\n### If sum % 3 == 0: \\nreturn the sum\\n\\n### If sum % 3 == 1:\\nThe answer will be\\n* (sum - smallest number whose remainder is 1 when divided by 3)\\n\\n* (sum - first smallest number whose remainder is 2 - second smallest number whose remainder is 2)\\n\\n* Return the maximum of these two\\n\\n### If sum % 3 == 2:\\nThe answer will be\\n\\n* (sum - smallest number whose remainder is 2 when divided by 3)\\n\\n* (sum - first smallest number whose remainder is 1 - second smallest number whose remainder is 1)\\n\\n* Return the maximum of these two\\n\\n\\n\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate through the array to find the total sum. When iterating through the array also find the first and second smallest numbers whose remainder is 1 and 2.\\n\\nFor sum % 3 == 1 and sum % 3 == 2 before returning check if the necessary first and second min are set\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n            \\n        int num11 = INT_MAX;\\n        int num12 = INT_MAX;\\n        int num21 = INT_MAX;\\n        int num22 = INT_MAX;\\n\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 3 == 1)\\n            {\\n                if(nums[i] < num11)\\n                {\\n                    num12 = num11;\\n                    num11 = nums[i];\\n                }\\n                else if(nums[i] < num12)\\n                {\\n                    num12 = nums[i];\\n                }\\n            }\\n            else if(nums[i] % 3 == 2)\\n            {\\n                if(nums[i] < num21)\\n                {\\n                    num22 = num21;\\n                    num21 = nums[i];\\n                }\\n                else if(nums[i] < num22)\\n                {\\n                    num22 = nums[i];\\n                }\\n\\n            }\\n            sum += nums[i];\\n        }\\n\\n        if(sum % 3 == 0)\\n        {\\n            return sum;\\n        }\\n        else if(sum % 3 == 1)\\n        {   \\n            if(num11 == INT_MAX) // If num11 is not set\\n            {\\n                return sum - num21 - num22;\\n            }\\n            else if(num21 == INT_MAX || num22 == INT_MAX)\\n            {\\n                return sum - num11;\\n            }\\n\\n            return max(sum - num11, sum - num21 - num22); \\n        }\\n        \\n        if(num21 == INT_MAX) // If num21 is not set\\n        {\\n            return sum - num11 - num12;\\n        }\\n        else if(num11 == INT_MAX || num12 == INT_MAX)\\n        {\\n            return sum - num21;\\n        }\\n        return max(sum - num21, sum - num11 - num12);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n            \\n        int num11 = INT_MAX;\\n        int num12 = INT_MAX;\\n        int num21 = INT_MAX;\\n        int num22 = INT_MAX;\\n\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 3 == 1)\\n            {\\n                if(nums[i] < num11)\\n                {\\n                    num12 = num11;\\n                    num11 = nums[i];\\n                }\\n                else if(nums[i] < num12)\\n                {\\n                    num12 = nums[i];\\n                }\\n            }\\n            else if(nums[i] % 3 == 2)\\n            {\\n                if(nums[i] < num21)\\n                {\\n                    num22 = num21;\\n                    num21 = nums[i];\\n                }\\n                else if(nums[i] < num22)\\n                {\\n                    num22 = nums[i];\\n                }\\n\\n            }\\n            sum += nums[i];\\n        }\\n\\n        if(sum % 3 == 0)\\n        {\\n            return sum;\\n        }\\n        else if(sum % 3 == 1)\\n        {   \\n            if(num11 == INT_MAX) // If num11 is not set\\n            {\\n                return sum - num21 - num22;\\n            }\\n            else if(num21 == INT_MAX || num22 == INT_MAX)\\n            {\\n                return sum - num11;\\n            }\\n\\n            return max(sum - num11, sum - num21 - num22); \\n        }\\n        \\n        if(num21 == INT_MAX) // If num21 is not set\\n        {\\n            return sum - num11 - num12;\\n        }\\n        else if(num11 == INT_MAX || num12 == INT_MAX)\\n        {\\n            return sum - num21;\\n        }\\n        return max(sum - num21, sum - num11 - num12);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340843,
                "title": "c-dp-memoization-tabulation",
                "content": "# Memoization Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(3, -1));\\n        return max(0, solve(nums, dp, n-1, 0));\\n    }\\n\\n    int solve(vector<int>& nums, vector<vector<int>>& dp, int ind, int rem){\\n        if(ind < 0){\\n            if(rem == 0)    return 0;\\n            return -1e9;\\n        }\\n\\n        if(dp[ind][rem] != -1)   return dp[ind][rem];\\n\\n        int pick = nums[ind] + solve(nums, dp, ind-1, (rem + nums[ind])%3);\\n        int notPick = solve(nums, dp, ind-1, rem);\\n\\n        return dp[ind][rem] = max(pick, notPick);\\n    }\\n};\\n```\\n\\n# Tabulation Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n+1, vector<int>(3, 0));\\n        dp[0][1] = -1e9;\\n        dp[0][2] = -1e9;\\n        for(int i = 1 ; i <= n ; i++){\\n            for(int rem = 2 ; rem >= 0 ; rem--){\\n                int pick = nums[i-1] + dp[i-1][(rem+nums[i-1])%3];\\n                int notPick = dp[i-1][rem];\\n                dp[i][rem] = max(pick, notPick);\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(3, -1));\\n        return max(0, solve(nums, dp, n-1, 0));\\n    }\\n\\n    int solve(vector<int>& nums, vector<vector<int>>& dp, int ind, int rem){\\n        if(ind < 0){\\n            if(rem == 0)    return 0;\\n            return -1e9;\\n        }\\n\\n        if(dp[ind][rem] != -1)   return dp[ind][rem];\\n\\n        int pick = nums[ind] + solve(nums, dp, ind-1, (rem + nums[ind])%3);\\n        int notPick = solve(nums, dp, ind-1, rem);\\n\\n        return dp[ind][rem] = max(pick, notPick);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n+1, vector<int>(3, 0));\\n        dp[0][1] = -1e9;\\n        dp[0][2] = -1e9;\\n        for(int i = 1 ; i <= n ; i++){\\n            for(int rem = 2 ; rem >= 0 ; rem--){\\n                int pick = nums[i-1] + dp[i-1][(rem+nums[i-1])%3];\\n                int notPick = dp[i-1][rem];\\n                dp[i][rem] = max(pick, notPick);\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140595,
                "title": "java-easy-solution-memoization",
                "content": "```\\nclass Solution {\\n    public static int [][] t;\\n    public int maxSumDivThree(int[] nums) {\\n        int n=nums.length;\\n        t=new int[n+1][3];\\n        for(int [] i:t) Arrays.fill(i,-1);\\n        return solve(nums,0,0);\\n    }\\n    public static int solve(int [] nums,int i,int curr){\\n        if(i>=nums.length){\\n            if(curr==0) return 0;\\n            return -10000;\\n        }\\n        if(t[i][curr]!=-1) return t[i][curr];\\n        int take=nums[i]+solve(nums,i+1,(curr+nums[i])%3);\\n        int left=solve(nums,i+1,curr);\\n        return t[i][curr]=Math.max(take,left);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public static int [][] t;\\n    public int maxSumDivThree(int[] nums) {\\n        int n=nums.length;\\n        t=new int[n+1][3];\\n        for(int [] i:t) Arrays.fill(i,-1);\\n        return solve(nums,0,0);\\n    }\\n    public static int solve(int [] nums,int i,int curr){\\n        if(i>=nums.length){\\n            if(curr==0) return 0;\\n            return -10000;\\n        }\\n        if(t[i][curr]!=-1) return t[i][curr];\\n        int take=nums[i]+solve(nums,i+1,(curr+nums[i])%3);\\n        int left=solve(nums,i+1,curr);\\n        return t[i][curr]=Math.max(take,left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562337,
                "title": "c-most-clean-code-greedy-priority-queue",
                "content": "Hello Guys, After First Reading the question I tried to solve it by using greedy approach though dynamic programming can also be applied but that would result in higher time complexity I felt...\\nInitially my greedy solution was able to pass 39/41 test cases....\\nThen I tried to analyse where my solution was going wrong. So after analysis I came to conclusion that if total sum that you get by adding all numbers in the given vector gives you a remainder 1 let say then in that case you can either remove 1 element from the vector that gives the remainder as 1 or you can remove 2 element from vector that gives remainder as 2.\\nSimilarly if the total sum % 3 == 2 then in that case either you need to remove a number from the vector that gives remainder as 2 or you need to remove 2 numbers that gives remainder as 1.\\nSo then we need to find out removing elements in which case leaves you with maximum sum.\\nSince sum will always be more when small number is removed from it. Therefore i used priority queue to get minimum values to store numbers with remiander 1 and 2 respectively.\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum = 0;\\n        priority_queue<int,vector<int>,greater<int>>pq1;\\n        priority_queue<int,vector<int>,greater<int>>pq2;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            \\n            sum+=nums[i];\\n            if(nums[i]%3 == 1)\\n                pq1.push(nums[i]);\\n            if(nums[i]%3 == 2)\\n                pq2.push(nums[i]);\\n        }\\n        if(sum%3 == 1)\\n        {\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            if(pq1.size() > 0)\\n            {\\n                sum1 = sum - pq1.top();\\n            }\\n            if(pq2.size() >= 2)\\n            {\\n                sum2 = sum - pq2.top();\\n                pq2.pop();\\n                sum2 = sum2 - pq2.top();\\n            }\\n            return(max(sum1,sum2));\\n        }\\n        else if(sum%3 == 2)\\n        {\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            if(pq2.size() > 0)\\n            {\\n                sum1 = sum - pq2.top();\\n            }\\n            if(pq1.size() >= 2)\\n            {\\n                sum2 = sum - pq1.top();\\n                pq1.pop();\\n                sum2 = sum2 - pq1.top();\\n                \\n            }\\n            return(max(sum1,sum2));\\n        }\\n        return(sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum = 0;\\n        priority_queue<int,vector<int>,greater<int>>pq1;\\n        priority_queue<int,vector<int>,greater<int>>pq2;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            \\n            sum+=nums[i];\\n            if(nums[i]%3 == 1)\\n                pq1.push(nums[i]);\\n            if(nums[i]%3 == 2)\\n                pq2.push(nums[i]);\\n        }\\n        if(sum%3 == 1)\\n        {\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            if(pq1.size() > 0)\\n            {\\n                sum1 = sum - pq1.top();\\n            }\\n            if(pq2.size() >= 2)\\n            {\\n                sum2 = sum - pq2.top();\\n                pq2.pop();\\n                sum2 = sum2 - pq2.top();\\n            }\\n            return(max(sum1,sum2));\\n        }\\n        else if(sum%3 == 2)\\n        {\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            if(pq2.size() > 0)\\n            {\\n                sum1 = sum - pq2.top();\\n            }\\n            if(pq1.size() >= 2)\\n            {\\n                sum2 = sum - pq1.top();\\n                pq1.pop();\\n                sum2 = sum2 - pq1.top();\\n                \\n            }\\n            return(max(sum1,sum2));\\n        }\\n        return(sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626586,
                "title": "simple-c-o-n-solution-using-constant-space",
                "content": "/*\\nHere I have used a simple concepts of division, if remainder is subtracted from the dividend the divisor will completely divide the dividend.\\neg:\\n4%3=1\\n4-1=3\\n3%3=0\\nlikewise,\\n5%3=2\\n5-2=3\\n3%3=0\\n\\nAccording to the above mentioned approach, we traverse the array and find the sum of all the elements of the array, along with keeping the track of, minimum element that gives 1 and minimum number that gives 2 as remainder.\\n\\nAt the end, if;\\n\\nsum%3=0;  return sum\\nsum%3=1; return (sum-minimum element minimum element that gives 1 as remainder).\\nsum%3=2; return (sum-minimum element minimum element that gives 1 as remainder).\\n\\nThus maximum sum divisible by 3 is returned.\\n\\n*/\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum=0,sum1=20000,sum2=20000;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(nums[i]%3==1){\\n                sum2=min(sum2,nums[i]+sum1);\\n                sum1=min(sum1,nums[i]);\\n                \\n            }\\n            else if(nums[i]%3==2){\\n                sum1=min(sum1,sum2+nums[i]);\\n                sum2=min(sum2,nums[i]);\\n            }\\n        }\\n        \\n        switch(sum%3){\\n            case 0:{\\n                break;\\n            }\\n            case 1:{\\n                return (sum-sum1);\\n                //break;\\n                }\\n            case 2:{\\n                return (sum-sum2);\\n                //break;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum=0,sum1=20000,sum2=20000;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(nums[i]%3==1){\\n                sum2=min(sum2,nums[i]+sum1);\\n                sum1=min(sum1,nums[i]);\\n                \\n            }\\n            else if(nums[i]%3==2){\\n                sum1=min(sum1,sum2+nums[i]);\\n                sum2=min(sum2,nums[i]);\\n            }\\n        }\\n        \\n        switch(sum%3){\\n            case 0:{\\n                break;\\n            }\\n            case 1:{\\n                return (sum-sum1);\\n                //break;\\n                }\\n            case 2:{\\n                return (sum-sum2);\\n                //break;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382710,
                "title": "python-heap-solution",
                "content": "That\\'s how I solved it. I didn\\'t find anything like that at least on top of the Discuss sectios. Seems like unique one and wanted to share it.\\n\\nThe idea is let\\'s sum all the elements in the array and put it in a heap and then let\\'s start subtracting all the elements from the smallest to largest untill we find the sum that can be devided by 3.\\n\\nIn heap we keep the mask of subtracted elements.\\n\\n```python\\nclass Solution:\\n    def maxSumDivThree(self, A: List[int]) -> int:\\n        B = []\\n        ans = S = 0\\n        for a in A:\\n            if a %3:\\n                S += a\\n                B.append(a)\\n            else:\\n                ans += a\\n        B.sort()\\n        \\n        q = []\\n        heappush(q,(-S,0))\\n        N = len(B)\\n        while q:\\n            L = len(q)\\n            s, mask = heappop(q)\\n            if s % 3 == 0:\\n                return ans-s\\n\\n            for i in range(N):\\n                if mask & (1 << i) == 0:\\n                    heappush(q,(s + B[i], mask | (1 << i)))\\n```\\n\\n`O(2^N)`  worst case. somehow getting 61% of speed\\n`O(heap size)` space\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSumDivThree(self, A: List[int]) -> int:\\n        B = []\\n        ans = S = 0\\n        for a in A:\\n            if a %3:\\n                S += a\\n                B.append(a)\\n            else:\\n                ans += a\\n        B.sort()\\n        \\n        q = []\\n        heappush(q,(-S,0))\\n        N = len(B)\\n        while q:\\n            L = len(q)\\n            s, mask = heappop(q)\\n            if s % 3 == 0:\\n                return ans-s\\n\\n            for i in range(N):\\n                if mask & (1 << i) == 0:\\n                    heappush(q,(s + B[i], mask | (1 << i)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903071,
                "title": "java-recursive-recursive-simplified-memoization-2d-bottom-up-1d-bottom-up",
                "content": "```\\n    - If we are currently at index \\'i\\' with \\'num\\'\\n        - If \\'num % 3\\' is equal to 0\\n            - We will want to add \\'num\\' to the largest \\'sum\\', where \\'sum % 3\\' is also equal to 0\\n            - This allows \\'sum + num\\' to also be divisible by 3\\n        - If \\'num % 3\\' is equal to 1\\n            - We will want to find the largest \\'sum\\', where \\'sum % 3\\' is equal to 2\\n            - This will allow \\'sum + num\\' to also be divisible by 3\\n        - If \\'num % 3\\' is equal to 2\\n            - We will want to find the largest \\'sum\\', where \\'sum % 3\\' is equal to 1\\n            - This will allow \\'sum + num\\' to also be divisible by 3\\n    - Using the approach\\n        - We can see that we are trying to find the maximum \\'sum\\' that has the remainders \\'0, 1, 2\\'\\n            - But our main target is finding the maximum \\'sum\\' that has a remainder of 0\\n```\\n```\\npublic class GreatestSumDivisibleByThreeRecursiveApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n\\n        if (nums[i] % 3 == 0) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        if (nums[i] % 3 == 1) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        if (nums[i] % 3 == 2) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        return -1; // should not get here\\n    }\\n}\\n```\\n```\\npublic class GreatestSumDivisibleByThreeRecursiveApproachSimplified {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n\\n        int difference = target - (nums[i] % 3);\\n        int nextTarget = (difference >= 0) ? difference : difference + 3;\\n        return Math.max(maxSumDivThree(i + 1, nextTarget, nums) + nums[i], maxSumDivThree(i + 1, target, nums));\\n    }\\n}\\n```\\n```\\npublic class GreatestSumDivisibleByThreeMemoizationApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums, new int[nums.length][3]);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums, int[][] memo) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n        if (memo[i][target] != 0) return memo[i][target];\\n\\n        int difference = target - (nums[i] % 3);\\n\\n        return memo[i][target] = Math.max(\\n                maxSumDivThree(i + 1, (difference >= 0) ? difference : difference + 3, nums, memo) + nums[i],\\n                maxSumDivThree(i + 1, target, nums, memo)\\n        );\\n    }\\n}\\n```\\n```\\npublic class GreatestSumDivisibleByThreeBottomUp2DApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] maxSum = new int[nums.length + 1][3];\\n\\n        for (int i = nums.length; i >= 0; i--) {\\n            for (int target = 2; target >= 0; target--) {\\n                if (i >= nums.length) {\\n                    maxSum[i][target] = (target == 0) ? 0 : Integer.MIN_VALUE;\\n                    continue;\\n                }\\n\\n                int difference = target - (nums[i] % 3);\\n\\n                maxSum[i][target] = Math.max(\\n                        maxSum[i + 1][(difference >= 0) ? difference : difference + 3] + nums[i],\\n                        maxSum[i + 1][target]\\n                );\\n            }\\n        }\\n\\n        return maxSum[0][0];\\n    }\\n}\\n```\\n```\\npublic class GreatestSumDivisibleByThreeBottomUpConstantSpaceApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] maxSum = new int[3];\\n\\n        for (int i = nums.length; i >= 0; i--) {\\n            int[] current = new int[3];\\n\\n            for (int target = 2; target >= 0; target--) {\\n                if (i >= nums.length) {\\n                    current[target] = (target == 0) ? 0 : Integer.MIN_VALUE;\\n                    continue;\\n                }\\n\\n                int difference = target - (nums[i] % 3);\\n\\n                current[target] = Math.max(\\n                        maxSum[(difference >= 0) ? difference : difference + 3] + nums[i],\\n                        maxSum[target]\\n                );\\n            }\\n\\n            maxSum = current;\\n        }\\n\\n        return maxSum[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    - If we are currently at index \\'i\\' with \\'num\\'\\n        - If \\'num % 3\\' is equal to 0\\n            - We will want to add \\'num\\' to the largest \\'sum\\', where \\'sum % 3\\' is also equal to 0\\n            - This allows \\'sum + num\\' to also be divisible by 3\\n        - If \\'num % 3\\' is equal to 1\\n            - We will want to find the largest \\'sum\\', where \\'sum % 3\\' is equal to 2\\n            - This will allow \\'sum + num\\' to also be divisible by 3\\n        - If \\'num % 3\\' is equal to 2\\n            - We will want to find the largest \\'sum\\', where \\'sum % 3\\' is equal to 1\\n            - This will allow \\'sum + num\\' to also be divisible by 3\\n    - Using the approach\\n        - We can see that we are trying to find the maximum \\'sum\\' that has the remainders \\'0, 1, 2\\'\\n            - But our main target is finding the maximum \\'sum\\' that has a remainder of 0\\n```\n```\\npublic class GreatestSumDivisibleByThreeRecursiveApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n\\n        if (nums[i] % 3 == 0) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        if (nums[i] % 3 == 1) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        if (nums[i] % 3 == 2) {\\n            if (target == 0) return Math.max(maxSumDivThree(i + 1, 1, nums) + nums[i], maxSumDivThree(i + 1, 0, nums));\\n            if (target == 1) return Math.max(maxSumDivThree(i + 1, 2, nums) + nums[i], maxSumDivThree(i + 1, 1, nums));\\n            if (target == 2) return Math.max(maxSumDivThree(i + 1, 0, nums) + nums[i], maxSumDivThree(i + 1, 2, nums));\\n        }\\n\\n        return -1; // should not get here\\n    }\\n}\\n```\n```\\npublic class GreatestSumDivisibleByThreeRecursiveApproachSimplified {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n\\n        int difference = target - (nums[i] % 3);\\n        int nextTarget = (difference >= 0) ? difference : difference + 3;\\n        return Math.max(maxSumDivThree(i + 1, nextTarget, nums) + nums[i], maxSumDivThree(i + 1, target, nums));\\n    }\\n}\\n```\n```\\npublic class GreatestSumDivisibleByThreeMemoizationApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        return maxSumDivThree(0, 0, nums, new int[nums.length][3]);\\n    }\\n\\n    private int maxSumDivThree(int i, int target, int[] nums, int[][] memo) {\\n        if (i >= nums.length) return target == 0 ? 0 : Integer.MIN_VALUE;\\n        if (memo[i][target] != 0) return memo[i][target];\\n\\n        int difference = target - (nums[i] % 3);\\n\\n        return memo[i][target] = Math.max(\\n                maxSumDivThree(i + 1, (difference >= 0) ? difference : difference + 3, nums, memo) + nums[i],\\n                maxSumDivThree(i + 1, target, nums, memo)\\n        );\\n    }\\n}\\n```\n```\\npublic class GreatestSumDivisibleByThreeBottomUp2DApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] maxSum = new int[nums.length + 1][3];\\n\\n        for (int i = nums.length; i >= 0; i--) {\\n            for (int target = 2; target >= 0; target--) {\\n                if (i >= nums.length) {\\n                    maxSum[i][target] = (target == 0) ? 0 : Integer.MIN_VALUE;\\n                    continue;\\n                }\\n\\n                int difference = target - (nums[i] % 3);\\n\\n                maxSum[i][target] = Math.max(\\n                        maxSum[i + 1][(difference >= 0) ? difference : difference + 3] + nums[i],\\n                        maxSum[i + 1][target]\\n                );\\n            }\\n        }\\n\\n        return maxSum[0][0];\\n    }\\n}\\n```\n```\\npublic class GreatestSumDivisibleByThreeBottomUpConstantSpaceApproach {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] maxSum = new int[3];\\n\\n        for (int i = nums.length; i >= 0; i--) {\\n            int[] current = new int[3];\\n\\n            for (int target = 2; target >= 0; target--) {\\n                if (i >= nums.length) {\\n                    current[target] = (target == 0) ? 0 : Integer.MIN_VALUE;\\n                    continue;\\n                }\\n\\n                int difference = target - (nums[i] % 3);\\n\\n                current[target] = Math.max(\\n                        maxSum[(difference >= 0) ? difference : difference + 3] + nums[i],\\n                        maxSum[target]\\n                );\\n            }\\n\\n            maxSum = current;\\n        }\\n\\n        return maxSum[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820598,
                "title": "python-heaps-dp-top-down-and-dp-bottom-up",
                "content": "### 1. Heaps\\nWhat differentiates this problem from other 0/1 knapsack problem is that\\u2014to get the best results, we can simply remove 1 or 2 smallest numbers meeting certain requirement.\\n\\nWe can simply keep track of how many have num % 3 == 1 and num % 3 == 2. Once we finish iterating the array, we can calculate the sum of the array % 3. \\n\\nIf this is 0, the sum of the array is the answer. \\n\\nIf this is 1, we need to remove 1 or 2 numbers. We can either remove the smallest number that mod 3 == 1 or the two smallest numbers that mod 3 == 2. \\n\\nIf this is 2, we need to remove 1 or 2 numbers. We can either remove the smallest number that mod 3 == 2 or the two smallest numbers that mod 3 == 1. \\n\\nWe can also leverage heaps to maintain the smallest 2 numbers that mod 3 == 1 and do the same for those that mod 3 == 2.\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mods = [0, 0, 0]\\n        heaps = [[], [], []]\\n        total = 0\\n        \\n        for n in nums:\\n            total += n\\n            m = n%3\\n            mods[m] += 1\\n            if len(heaps[m]) < 2:\\n                heapq.heappush(heaps[m], -n)\\n            else:\\n                heapq.heappushpop(heaps[m], -n)\\n        \\n        total_mod = (mods[1] * 1 + mods[2] * 2) % 3\\n        ret = -float(\"inf\")\\n        if total_mod == 0:\\n            ret = total\\n        elif total_mod == 1:\\n            if len(heaps[1]) > 0:\\n                ret = max(ret, total + heaps[1][-1])\\n            if len(heaps[2]) == 2:\\n                ret = max(ret, total + sum(heaps[2]))\\n        else:\\n            if len(heaps[1]) == 2:\\n                ret = max(ret, total + sum(heaps[1]))\\n            if len(heaps[2]) > 0:\\n                ret = max(ret, total + heaps[2][-1])\\n        return ret\\n        \\n```\\n\\n### 2. Top-down DP\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        L= len(nums)\\n        \\n        @functools.lru_cache(None)\\n        def dp(index, remainder):\\n            if index == L:\\n                if remainder == 0:\\n                    return 0\\n                else:\\n                    return -float(\"inf\")\\n            \\n            new_remainder = (remainder + nums[index] % 3) % 3\\n            return max(dp(index+1, remainder), nums[index] + dp(index+1, new_remainder))\\n        \\n        return dp(0, 0)\\n```\\n\\n### 3. Bottom-up DP\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        L = len(nums)\\n        dp = [-float(\"inf\")] * 3\\n        dp[0] = 0\\n        for i in range(L):\\n            dp2 = [i for i in dp]\\n            r = nums[i] % 3 \\n            \\n            for r_old, cumsum_old in enumerate(dp):\\n                r_new = (r + r_old) % 3\\n                dp2[r_new] = max(dp2[r_new], cumsum_old+nums[i])\\n            dp = dp2\\n        return dp[0]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mods = [0, 0, 0]\\n        heaps = [[], [], []]\\n        total = 0\\n        \\n        for n in nums:\\n            total += n\\n            m = n%3\\n            mods[m] += 1\\n            if len(heaps[m]) < 2:\\n                heapq.heappush(heaps[m], -n)\\n            else:\\n                heapq.heappushpop(heaps[m], -n)\\n        \\n        total_mod = (mods[1] * 1 + mods[2] * 2) % 3\\n        ret = -float(\"inf\")\\n        if total_mod == 0:\\n            ret = total\\n        elif total_mod == 1:\\n            if len(heaps[1]) > 0:\\n                ret = max(ret, total + heaps[1][-1])\\n            if len(heaps[2]) == 2:\\n                ret = max(ret, total + sum(heaps[2]))\\n        else:\\n            if len(heaps[1]) == 2:\\n                ret = max(ret, total + sum(heaps[1]))\\n            if len(heaps[2]) > 0:\\n                ret = max(ret, total + heaps[2][-1])\\n        return ret\\n        \\n```\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        L= len(nums)\\n        \\n        @functools.lru_cache(None)\\n        def dp(index, remainder):\\n            if index == L:\\n                if remainder == 0:\\n                    return 0\\n                else:\\n                    return -float(\"inf\")\\n            \\n            new_remainder = (remainder + nums[index] % 3) % 3\\n            return max(dp(index+1, remainder), nums[index] + dp(index+1, new_remainder))\\n        \\n        return dp(0, 0)\\n```\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        L = len(nums)\\n        dp = [-float(\"inf\")] * 3\\n        dp[0] = 0\\n        for i in range(L):\\n            dp2 = [i for i in dp]\\n            r = nums[i] % 3 \\n            \\n            for r_old, cumsum_old in enumerate(dp):\\n                r_new = (r + r_old) % 3\\n                dp2[r_new] = max(dp2[r_new], cumsum_old+nums[i])\\n            dp = dp2\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783107,
                "title": "easy-clean-java-solution-using-min-heap",
                "content": "Explanation :-\\n========\\nis if sum % 3 == 1 then you can either sutract lowest number which is num % 3 == 1 from sum to obtain sum%3==0 or two lowest number having mod of 2\\n\\nSame is for sum % 2 == 1. You can either subtract lowest number having mod 2 or two lowest number having mod 1 to make it sum % 3 == 0\\n\\nTime Complexity O ( N log N ), Space complexity O ( N )\\n\\n```\\nclass Solution {\\n    \\n    public int maxSumDivThree(int[] nums) {\\n\\n        int sum = 0, sum1 = Integer.MIN_VALUE, sum2 = Integer.MIN_VALUE;\\n\\n        PriorityQueue<Integer> dp[] = new PriorityQueue[] { \\n            new PriorityQueue<>(), new PriorityQueue<>(), new PriorityQueue<>()\\n        };\\n        \\n        for (int num: nums) {\\n            // Num goes to bucket num % 3\\n            dp[num % 3].add(num);\\n            sum+=num;\\n        }\\n        \\n        int k = sum % 3;\\n        switch (k) {\\n            case 0:\\n                return sum;\\n            case 1:\\n            case 2:\\n                if (dp[k].size() > 0)\\n                    sum1 = sum - dp[k].poll();\\n                \\n                if (dp[3-k].size() > 1)\\n                    sum2 = sum - dp[3-k].poll() - dp[3-k].poll();\\n                return Math.max(sum1, sum2);\\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int maxSumDivThree(int[] nums) {\\n\\n        int sum = 0, sum1 = Integer.MIN_VALUE, sum2 = Integer.MIN_VALUE;\\n\\n        PriorityQueue<Integer> dp[] = new PriorityQueue[] { \\n            new PriorityQueue<>(), new PriorityQueue<>(), new PriorityQueue<>()\\n        };\\n        \\n        for (int num: nums) {\\n            // Num goes to bucket num % 3\\n            dp[num % 3].add(num);\\n            sum+=num;\\n        }\\n        \\n        int k = sum % 3;\\n        switch (k) {\\n            case 0:\\n                return sum;\\n            case 1:\\n            case 2:\\n                if (dp[k].size() > 0)\\n                    sum1 = sum - dp[k].poll();\\n                \\n                if (dp[3-k].size() > 1)\\n                    sum2 = sum - dp[3-k].poll() - dp[3-k].poll();\\n                return Math.max(sum1, sum2);\\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708944,
                "title": "java-using-remainder",
                "content": "A little bit long but easy to understand:\\n1, find the smallest 2 nums that num % 3 == 1, 2 respectively; \\n2, calculate sum of array, sum\\n3, find smallest num that num % 3 == sum % 3, if exists, note as a;\\n4, find 2 smallest num that num % 3 == 3 - sum % 3, if exists, say, c and d, b = c + d;\\n5, return sum - Math.min(a, b);\\n\\n```\\n    public int maxSumDivThree(int[] nums) {\\n        Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n        int m = 3, sum = 0;\\n        for (int i = 1; i < m; i++) map.put(i, new PriorityQueue<>((a, b) -> b - a));\\n        for (int n : nums) {\\n            sum += n;\\n            if (n % m != 0) {\\n                PriorityQueue pq = map.get(n % m);\\n                pq.offer(n);\\n                if (pq.size() > 2) pq.poll();\\n            }\\n        }\\n        int rem = sum % m;\\n        if (rem == 0) return sum;\\n        int b = 0;\\n        if (map.get(m - rem).size() == 2) {\\n            while (map.get(m - rem).size() > 0) b += map.get(m - rem).poll();\\n        }\\n        if (map.get(rem).size() == 0) return sum - b; // another method to get rem; size must be 2 or 0;\\n        while (map.get(rem).size() > 1) map.get(rem).poll();\\n        int a = map.get(rem).poll();\\n        if (b > 0) a = Math.min(a, b);\\n        return sum - a;   // min num with rem == num % 3;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxSumDivThree(int[] nums) {\\n        Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n        int m = 3, sum = 0;\\n        for (int i = 1; i < m; i++) map.put(i, new PriorityQueue<>((a, b) -> b - a));\\n        for (int n : nums) {\\n            sum += n;\\n            if (n % m != 0) {\\n                PriorityQueue pq = map.get(n % m);\\n                pq.offer(n);\\n                if (pq.size() > 2) pq.poll();\\n            }\\n        }\\n        int rem = sum % m;\\n        if (rem == 0) return sum;\\n        int b = 0;\\n        if (map.get(m - rem).size() == 2) {\\n            while (map.get(m - rem).size() > 0) b += map.get(m - rem).poll();\\n        }\\n        if (map.get(rem).size() == 0) return sum - b; // another method to get rem; size must be 2 or 0;\\n        while (map.get(rem).size() > 1) map.get(rem).poll();\\n        int a = map.get(rem).poll();\\n        if (b > 0) a = Math.min(a, b);\\n        return sum - a;   // min num with rem == num % 3;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612793,
                "title": "c-o-n-detailed-explanation",
                "content": "```\\nThis is a really tricky problem.\\nOne thing u have to note is that when i divide any number by 3 my maximum number would be 2.\\nOne way to solve this method is to ste the maximum sum with remainders 0,1,2\\n[3,6,5,1,8]        [0,0,0] <----auxiliary array storing the maimum sum int the remainders position\\n ^\\n |\\n i\\nsum = 3            [3,0,0] <---3%3=0\\n\\n\\n[3,6,5,1,8]        [9,0,0] <----9%3=0\\n   ^\\n   |\\n   i\\nsum = 3+6 = 9\\n\\n[3,6,5,1,8]        [9,0,14] <----14%3=2\\n   ^\\n   |\\n   i\\nsum = 9+5=14\\n\\n[3,6,5,1,8]        [15,0,14] <----15%3=0\\n   ^\\n   |\\n   i\\nsum = 14+1=15\\n\\n[3,6,5,1,8]        [15,0,23] <----23%3=2\\n   ^\\n   |\\n   i\\nsum = 15+8=23\\n\\nThis approach gives me a max sum of remainder 0 as 15 but that isnt an answer\\nOur approach here finds the maximum sum of a subarray that is divisible by 3\\nBut we need to find a subsequence(not necesaaruly have to by contiguos elements).\\n\\nJust look at our auxiliary array carefully.\\n\\n[3,0,0]             [3,] \\n[9,0,0]             [3,6,]\\n[9,0,14]            [3,6,5,]\\n[15,0,14]           [3,6,5,1,]\\n[15,0,23]           [3,6,5,1,8]\\n\\nIf i were to add every new number to the sums present in the auxiliary array and mod it and check if it beats any of the sum would that work?\\n\\n[3,0,0]             [3,] \\n[9,0,0]             [3,6,]\\n[9,0,14]            [3,6,5,]\\n[15,10,14]           [3,6,5,1,] 1 is added to 9 0 and 14 = 10, 1 and 15\\n[18,22,23]           [3,6,5,1,8]  8 is added to 15,10 and 14 which gives 23,18,22 where 18 beats 15 \\n\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> dp={0,0,0};\\n        for(int x:nums)\\n        {\\n            vector<int> dp1=dp;\\n            for(int a:dp1)\\n            {\\n                dp[(x+a)%3]=max(dp[(x+a)%3],x+a);\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nThis is a really tricky problem.\\nOne thing u have to note is that when i divide any number by 3 my maximum number would be 2.\\nOne way to solve this method is to ste the maximum sum with remainders 0,1,2\\n[3,6,5,1,8]        [0,0,0] <----auxiliary array storing the maimum sum int the remainders position\\n ^\\n |\\n i\\nsum = 3            [3,0,0] <---3%3=0\\n\\n\\n[3,6,5,1,8]        [9,0,0] <----9%3=0\\n   ^\\n   |\\n   i\\nsum = 3+6 = 9\\n\\n[3,6,5,1,8]        [9,0,14] <----14%3=2\\n   ^\\n   |\\n   i\\nsum = 9+5=14\\n\\n[3,6,5,1,8]        [15,0,14] <----15%3=0\\n   ^\\n   |\\n   i\\nsum = 14+1=15\\n\\n[3,6,5,1,8]        [15,0,23] <----23%3=2\\n   ^\\n   |\\n   i\\nsum = 15+8=23\\n\\nThis approach gives me a max sum of remainder 0 as 15 but that isnt an answer\\nOur approach here finds the maximum sum of a subarray that is divisible by 3\\nBut we need to find a subsequence(not necesaaruly have to by contiguos elements).\\n\\nJust look at our auxiliary array carefully.\\n\\n[3,0,0]             [3,] \\n[9,0,0]             [3,6,]\\n[9,0,14]            [3,6,5,]\\n[15,0,14]           [3,6,5,1,]\\n[15,0,23]           [3,6,5,1,8]\\n\\nIf i were to add every new number to the sums present in the auxiliary array and mod it and check if it beats any of the sum would that work?\\n\\n[3,0,0]             [3,] \\n[9,0,0]             [3,6,]\\n[9,0,14]            [3,6,5,]\\n[15,10,14]           [3,6,5,1,] 1 is added to 9 0 and 14 = 10, 1 and 15\\n[18,22,23]           [3,6,5,1,8]  8 is added to 15,10 and 14 which gives 23,18,22 where 18 beats 15 \\n\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> dp={0,0,0};\\n        for(int x:nums)\\n        {\\n            vector<int> dp1=dp;\\n            for(int a:dp1)\\n            {\\n                dp[(x+a)%3]=max(dp[(x+a)%3],x+a);\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 592982,
                "title": "java-solution-recursion-memo",
                "content": "```\\nclass Solution {\\n     public int maxSumDivThree(int[] nums) {\\n      int dp[][]=new int[nums.length][4];\\n         for(int i=0;i<nums.length;i++)\\n             for(int j=0;j<4;j++)\\n                 dp[i][j]=-1;\\n          int x= function(nums,0,0,dp);\\n         if(x==-1)\\n             return 0;\\n         else\\n             return x;\\n    }\\n\\n    private int function(int[] nums, int sum, int i,int dp[][]) {\\n        \\n        if (i == nums.length) \\n        {\\n            if(sum==0)\\n                return 0;\\n            else\\n                return -1;\\n        }\\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum];\\n       int a=function(nums,(sum+nums[i])%3,i+1,dp);\\n        if(a!=-1)\\n            a=a+nums[i];\\n        int b=function(nums,sum%3,i+1,dp);\\n        return dp[i][sum]=Math.max(a,b);\\n        \\n     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int maxSumDivThree(int[] nums) {\\n      int dp[][]=new int[nums.length][4];\\n         for(int i=0;i<nums.length;i++)\\n             for(int j=0;j<4;j++)\\n                 dp[i][j]=-1;\\n          int x= function(nums,0,0,dp);\\n         if(x==-1)\\n             return 0;\\n         else\\n             return x;\\n    }\\n\\n    private int function(int[] nums, int sum, int i,int dp[][]) {\\n        \\n        if (i == nums.length) \\n        {\\n            if(sum==0)\\n                return 0;\\n            else\\n                return -1;\\n        }\\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum];\\n       int a=function(nums,(sum+nums[i])%3,i+1,dp);\\n        if(a!=-1)\\n            a=a+nums[i];\\n        int b=function(nums,sum%3,i+1,dp);\\n        return dp[i][sum]=Math.max(a,b);\\n        \\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431180,
                "title": "java-o-nlogn-easy-to-understand-solution-with-comments",
                "content": "1. Take the sum of complete array and see by how much does it exceed from the nearest multiple of  3 (take mod of this sum with 3 and see what is the remainder)\\n2. Select a set of numbers which can offset this value and bring sum to a multiple of 3 by ejecting these numbers. In other words find shortest set of values whose sum gives same remainder as the total sum on taking mod with 3. To find these shortest values we need to sort the array,\\n3. If sum%3==0 just return this sum.\\n4. If sum%3==1:  Either eject the smallest number with num%3==1 or two numbers with num%3==2 (since (2+2)%3 is also 1) so that we lose this extra 1 as remainder from total sum. We need to consider both of these possibilities as there might be two very small numbers with mod 2 in the array and the first number with mod 1 might be bigger than combined sum of such small numbers.\\n5. Similarly if sum%3==2 either remove smallest number with num%3==2 or two numbers with num%3==1 whichever does less damage to out sum. Below is my code:\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic int maxSumDivThree(int[] nums) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tint rem= sum%3;\\n        \\n\\t\\t\\t//if sum is already divisible by 3 return this sum\\n\\t\\t\\tif(rem==0)\\n\\t\\t\\t\\treturn sum;\\n        \\n\\t\\t\\t//sum of numbers we want to throw out so total sum becomes a multiple of 3. \\n\\t\\t\\t//This should be as low as possible\\n\\t\\t\\tint eject=0;\\n \\n\\t\\t\\t//if remainder exceeds by 1 either eject one number with mod=1 or two numbers with mod=2 so that (2+2)%3=1 \\n\\t\\t\\tif(rem==1) eject=Math.min(one1(nums),two2(nums));\\n        \\n\\t\\t\\t//same logic as above but we either need to throw 2 numbers with mod 1 each or one number with mod 2\\n\\t\\t\\telse       eject=Math.min(one2(nums),two1(nums));\\n        \\n\\t\\t\\treturn sum-eject;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tprivate int one1(int[] nums){\\n\\t\\t\\t\\tfor(int i=0;i<nums.length;i++)\\n\\t\\t\\t\\t\\tif(nums[i]%3==1)\\n\\t\\t\\t\\t\\t\\treturn nums[i];\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t\\t}\\n    \\n\\t\\t\\tprivate int two2(int[] nums){\\n\\t\\t\\tint first=0,second=0;\\n        \\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tif(nums[i]%3==2 && first==0)\\n\\t\\t\\t\\t\\tfirst=nums[i];\\n\\t\\t\\t\\telse if(nums[i]%3==2){\\n\\t\\t\\t\\t\\tsecond=nums[i]; break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(first==0 || second==0)\\n\\t\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t\\treturn first+second;\\n\\t\\t\\t}\\n    \\n\\t\\t\\tprivate int one2(int[] nums){\\n\\t\\t\\t\\tfor(int i=0;i<nums.length;i++)\\n\\t\\t\\t\\t\\tif(nums[i]%3==2)\\n\\t\\t\\t\\t\\t\\treturn nums[i];\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t\\t}\\n    \\n\\t\\t\\tprivate int two1(int[] nums){\\n\\t\\t\\t\\tint first=0,second=0;\\n        \\n\\t\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\t\\tif(nums[i]%3==1 && first==0)\\n\\t\\t\\t\\t\\t\\tfirst=nums[i];\\n\\t\\t\\t\\t\\telse if(nums[i]%3==1){\\n\\t\\t\\t\\t\\t\\tsecond=nums[i]; break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(first==0 || second==0)\\n\\t\\t\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t\\t\\treturn first+second;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic int maxSumDivThree(int[] nums) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3918116,
                "title": "100-faster-java-code-dp-simplest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/c7d0bb97-d250-4053-ae1e-7cdbe3b5cd08_1692192623.3204708.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int k = 3; // Number of possible remainders\\n        long[][] dp = new long[n + 1][k];\\n        \\n        // Initialize the dp array with negative infinity values\\n        for (int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], Integer.MIN_VALUE);\\n        }\\n        \\n        // Base case: maximum sum with remainder 0 is 0\\n        dp[0][0] = 0;\\n        \\n        // Iterate through the numbers in the array\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k; j++) {\\n                // Calculate the new remainder after including the current number\\n                int newRemainder = (j + nums[i]) % k;\\n                \\n                // Update the maximum sum for the current remainder\\n                dp[i + 1][newRemainder] = Math.max(dp[i][newRemainder], dp[i][j] + nums[i]);\\n            }\\n        }\\n        \\n        // The maximum sum with remainder 0 after considering all elements\\n        return (int) dp[n][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int k = 3; // Number of possible remainders\\n        long[][] dp = new long[n + 1][k];\\n        \\n        // Initialize the dp array with negative infinity values\\n        for (int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], Integer.MIN_VALUE);\\n        }\\n        \\n        // Base case: maximum sum with remainder 0 is 0\\n        dp[0][0] = 0;\\n        \\n        // Iterate through the numbers in the array\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k; j++) {\\n                // Calculate the new remainder after including the current number\\n                int newRemainder = (j + nums[i]) % k;\\n                \\n                // Update the maximum sum for the current remainder\\n                dp[i + 1][newRemainder] = Math.max(dp[i][newRemainder], dp[i][j] + nums[i]);\\n            }\\n        }\\n        \\n        // The maximum sum with remainder 0 after considering all elements\\n        return (int) dp[n][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735402,
                "title": "most-efficient-greedy-approach-beats-97-o-n-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size(), sum = 0;\\n\\n        for(auto i : nums) sum += i;\\n        if(sum % 3 == 0) return sum;\\n\\n        vector<int>v;\\n        for(auto i : nums){\\n            if(i%3) v.push_back(i);\\n        }\\n\\n        sort(v.begin(),v.end());\\n        v.push_back(1e9+7);\\n\\n        int curr = 0 , l = 0;\\n\\n        for(int i=0; i<v.size(); i++){\\n            while(curr < v[i]){\\n                if(sum % 3 == curr % 3) return sum - curr;\\n                curr += v[l];\\n                l++;\\n            }\\n\\n            if(sum % 3 == v[i] % 3) return sum - v[i];\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size(), sum = 0;\\n\\n        for(auto i : nums) sum += i;\\n        if(sum % 3 == 0) return sum;\\n\\n        vector<int>v;\\n        for(auto i : nums){\\n            if(i%3) v.push_back(i);\\n        }\\n\\n        sort(v.begin(),v.end());\\n        v.push_back(1e9+7);\\n\\n        int curr = 0 , l = 0;\\n\\n        for(int i=0; i<v.size(); i++){\\n            while(curr < v[i]){\\n                if(sum % 3 == curr % 3) return sum - curr;\\n                curr += v[l];\\n                l++;\\n            }\\n\\n            if(sum % 3 == v[i] % 3) return sum - v[i];\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259873,
                "title": "o-n-time-o-1-space-java-solution",
                "content": "# Approach\\n1. We just have to keep track of the following three things for the sub-problem till index i.\\n-Maximum subset sum that gives **reminder 0** when divided by 3.\\n-Maximum subset sum that gives **reminder 1** when divided by 3.\\n-Maximum subset sum that gives **reminder 2** when divided by 3.\\nI have used an array of size 3 for the sake of simplicity.\\n\\n2. At every iteration we have to compute and update the sums and remainders considering the current element.\\n\\n3. Return maximum sum that gives **reminder 0** when divided by 3.\\n \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n=nums.length;\\n        int[] sums=new int [3];\\n\\n        for(int i=0; i<n; i++){\\n            int s0=sums[0]+nums[i];\\n            int s1=sums[1]+nums[i];\\n            int s2=sums[2]+nums[i];\\n\\n            int r0=s0 % 3;\\n            int r1=s1 % 3;\\n            int r2=s2 % 3;\\n\\n            sums[r0]=Math.max(sums[r0], s0);\\n            sums[r1]=Math.max(sums[r1], s1);\\n            sums[r2]=Math.max(sums[r2], s2);\\n        } \\n\\n        return sums[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n=nums.length;\\n        int[] sums=new int [3];\\n\\n        for(int i=0; i<n; i++){\\n            int s0=sums[0]+nums[i];\\n            int s1=sums[1]+nums[i];\\n            int s2=sums[2]+nums[i];\\n\\n            int r0=s0 % 3;\\n            int r1=s1 % 3;\\n            int r2=s2 % 3;\\n\\n            sums[r0]=Math.max(sums[r0], s0);\\n            sums[r1]=Math.max(sums[r1], s1);\\n            sums[r2]=Math.max(sums[r2], s2);\\n        } \\n\\n        return sums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244290,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int>dp(3);\\n        for(auto a:nums){\\n            for(int i:vector<int>(dp)){\\n                dp[(i+a)%3]=max(dp[(i+a)%3],i+a);\\n            }\\n        }\\n       return dp[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=0;\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int>dp(3);\\n        for(auto a:nums){\\n            for(int i:vector<int>(dp)){\\n                dp[(i+a)%3]=max(dp[(i+a)%3],i+a);\\n            }\\n        }\\n       return dp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579063,
                "title": "1262-python",
                "content": "\\tclass Solution:\\n\\t\\tdef maxSumDivThree(self, nums: List[int]) -> int:\\n\\t\\t\\tdp = [0]*3\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tnewdp = dp.copy()\\n\\t\\t\\t\\tfor i in range(3):\\n\\t\\t\\t\\t\\tnewdp[(num+dp[i])%3] = max(newdp[(num+dp[i])%3], num+dp[i])\\n\\t\\t\\t\\tdp = newdp\\n\\t\\t\\treturn dp[0]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxSumDivThree(self, nums: List[int]) -> int:\\n\\t\\t\\tdp = [0]*3\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tnewdp = dp.copy()\\n\\t\\t\\t\\tfor i in range(3):\\n\\t\\t\\t\\t\\tnewdp[(num+dp[i])%3] = max(newdp[(num+dp[i])%3], num+dp[i])\\n\\t\\t\\t\\tdp = newdp\\n\\t\\t\\treturn dp[0]",
                "codeTag": "Java"
            },
            {
                "id": 2454461,
                "title": "weeb-does-python-dp",
                "content": "dp[j][i] represents the current max sum divisible by 3\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(3, vector<int>(n+1, 0));\\n\\n\\t\\t\\tfor(int i=1; i<n+1; i++){\\n\\t\\t\\t\\tfor(int j=0; j<3; j++){\\n\\t\\t\\t\\t\\tdp[j][i] = max(dp[j][i-1], dp[j][i]);\\n\\t\\t\\t\\t\\tint curSum = nums[i-1] + dp[j][i-1];\\n\\t\\t\\t\\t\\tint idx = curSum % 3;\\n\\t\\t\\t\\t\\tdp[idx][i] = max(max(dp[idx][i-1], curSum), dp[idx][i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][n];\\n\\t\\t}\\n\\t};\\n\\n**Python**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maxSumDivThree(self, nums: List[int]) -> int:\\n\\t\\t\\tdp = [[0 for i in range(len(nums)+1)] for j in range(3)]\\n\\n\\t\\t\\tfor i in range(1,len(nums)+1):\\n\\t\\t\\t\\tfor j in range(3):\\n\\t\\t\\t\\t\\tdp[j][i] = max(dp[j][i-1], dp[j][i])\\n\\t\\t\\t\\t\\tcurSum = nums[i-1] + dp[j][i-1]\\n\\t\\t\\t\\t\\tidx = curSum % 3\\n\\t\\t\\t\\t\\tdp[idx][i] = max(dp[idx][i-1], curSum, dp[idx][i])\\n\\n\\t\\t\\treturn dp[0][-1]\\n\\nTake a break, watch some anime instead\\nCheck out **\\u963F\\u6CE2\\u9023\\u3055\\u3093\\u306F\\u306F\\u304B\\u308C\\u306A\\u3044 (Aharen-san wa Hakarenai)**\\n\\n# Episodes: 12\\n# Genre: Comedy\\n# Themes: Iyashikei, School\\n# Demographic: Shounen\\n\\nA really wholesome anime, so pls watch it!!",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(3, vector<int>(n+1, 0));\\n\\n\\t\\t\\tfor(int i=1; i<n+1; i++){\\n\\t\\t\\t\\tfor(int j=0; j<3; j++){\\n\\t\\t\\t\\t\\tdp[j][i] = max(dp[j][i-1], dp[j][i]);\\n\\t\\t\\t\\t\\tint curSum = nums[i-1] + dp[j][i-1];\\n\\t\\t\\t\\t\\tint idx = curSum % 3;\\n\\t\\t\\t\\t\\tdp[idx][i] = max(max(dp[idx][i-1], curSum), dp[idx][i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2419612,
                "title": "python-recursion-memo-explained-mod-clear-concise",
                "content": "# EXPLAINATION\\nThe idea is to use recursion first \\n\\nNow we have two choices at each step : \\n1. choose the element at index i and continue to i + 1\\n2. do not choose the element at index i and continue to i +1\\n\\nWe need to keep track of index and current_sum ( sum of all nums[i] we have choosen so far)\\n\\nNow the recursion will terminate when index i will be equals to len(nums) -> base case\\n\\nNow we have two choices ( recursion ) at every step so this gives us the idea to do memoization \\n\\nIn memoization we memoize those variables which changes in each recursive call\\nHere current _ sum and index will change so we will memoize them\\n\\nBut this will give us TLE\\n\\nNow the solution to the TLE is using mod\\n\\nThe idea is 7 + 5 = 12 can also be written as\\n       3 + 3 + 1 + 5 = 12\\n\\t = 2(3) +1 + 5 = 12\\n\\t \\n\\t Now if we remove this 2(3) we will get sum 1 + 5 = 6 \\n\\t Now 6 % 3 is same as 12 % 3 \\n\\t \\n\\tSo if we reach index = 3 with sum = 22 in way (1)\\n\\t     and again reach index = 3 with sum = 16 in way(2)\\n\\t\\t \\nWhat is common between them is I am reaching index = 3 and mod(sum) = 1 in both.......\\n\\nNow dp[index][mod(sum)] can  store the best we can do after index when our mod = mod(sum) \\n\\nIn case of 3 the mod(sum) can be 0 / 1 / 2\\n\\nSo our dp is acting as a 2D dp having rows = 3 and columns = index \\n\\n\\t\\t \\n\\t\\n\\n# CODE\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp,n = {} , len(nums)\\n        \\n        def recursion(index,mod):\\n            if index == n: \\n                return 0 if mod == 0 else -inf\\n            if (index,mod) in dp: return dp[(index,mod)]\\n            a = recursion(index + 1, (mod + nums[index]) % 3) + nums[index]\\n            b = recursion(index + 1 , mod)\\n            ans = max(a,b)\\n            dp[(index,mod)] = ans\\n            return ans\\n        return recursion(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp,n = {} , len(nums)\\n        \\n        def recursion(index,mod):\\n            if index == n: \\n                return 0 if mod == 0 else -inf\\n            if (index,mod) in dp: return dp[(index,mod)]\\n            a = recursion(index + 1, (mod + nums[index]) % 3) + nums[index]\\n            b = recursion(index + 1 , mod)\\n            ans = max(a,b)\\n            dp[(index,mod)] = ans\\n            return ans\\n        return recursion(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237262,
                "title": "o-n-time-o-1-space-greedy-c",
                "content": "The mod of any value by 3 could only give **0**, **1** or **2**, which means we only have to worry about the values which give **1 or 2** with mod3. \\n**If the total sum is not divisible by, we only have to subtract the smallest value such that it does become divisible.**\\nFor eg, if **res** gives **1** when mod with 3, we have to subtract the **smallest of (smallest value from input array which gives 1 when mod by 3, sum of two smallest values which give 2 when mod by 3, since (2%3 + 2%3)%3 = 1)**, and **vice versa** if res gives **2** when mod with 3.\\n\\n***Note: If a%3 gives 2, then, a%3 = 2%3, and (a+b)%m = (a%m + b%m)%m.***\\n\\nDo comment down in case of any queries or remarks.\\n**Please upvote if you find the solution insightful.\\n*Thank You!!***\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> twos = {(int)1e4+1, (int)1e4+1}, ones = {(int)1e4+1, (int)1e4+1};\\n        int res = 0;\\n        for(int i: nums) {\\n            if(i%3 == 2) {\\n                if(i <= twos[0]) {\\n                    twos[1] = twos[0], twos[0] = i;\\n                }\\n                else if(i < twos[1]) twos[1] = i;\\n            }\\n            else if(i%3 == 1) {\\n                if(i <= ones[0]) {\\n                    ones[1] = ones[0], ones[0] = i;\\n                }\\n                else if(i < ones[1]) ones[1] = i;\\n            }\\n            res += i;\\n        }\\n        if(res%3 == 2)\\n            return max(res - twos[0], res - ones[0] - ones[1]);\\n        else if(res%3 == 1)\\n            return max(res - ones[0], res - twos[0] - twos[1]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> twos = {(int)1e4+1, (int)1e4+1}, ones = {(int)1e4+1, (int)1e4+1};\\n        int res = 0;\\n        for(int i: nums) {\\n            if(i%3 == 2) {\\n                if(i <= twos[0]) {\\n                    twos[1] = twos[0], twos[0] = i;\\n                }\\n                else if(i < twos[1]) twos[1] = i;\\n            }\\n            else if(i%3 == 1) {\\n                if(i <= ones[0]) {\\n                    ones[1] = ones[0], ones[0] = i;\\n                }\\n                else if(i < ones[1]) ones[1] = i;\\n            }\\n            res += i;\\n        }\\n        if(res%3 == 2)\\n            return max(res - twos[0], res - ones[0] - ones[1]);\\n        else if(res%3 == 1)\\n            return max(res - ones[0], res - twos[0] - twos[1]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966725,
                "title": "greatest-sum-divisible-by-three",
                "content": "# Approach 1-recursion\\n```\\nclass Solution {\\npublic:\\n    //recursion\\n    int solve(int i,vector<int>& nums,int r){\\n        if(i == nums.size()){\\n            if(r == 0){\\n                return 0;\\n            }\\n            return -1000000;\\n        }\\n        \\n        int op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3);\\n        int op2 = solve(i+1,nums,r);\\n        return max(op1,op2);\\n    }\\n\\t int maxSumDivThree(vector<int>& nums) {\\n\\t     return solve(0,nums,0);\\n\\t }\\n};\\n\\n```\\n# Approach 2- recursion + memoization\\n\\n```\\nclass Solution {\\npublic:\\n\\tint solve(int i,vector<int>& nums,int r,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == nums.size()){\\n\\t\\t\\t\\tif(r == 0){\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1000000;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][r] != -1) return dp[i][r];\\n\\n\\t\\t\\tint op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3,dp);\\n\\t\\t\\tint op2 = solve(i+1,nums,r,dp);\\n\\t\\t\\treturn dp[i][r] = max(op1,op2);\\n\\t\\t}\\n\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(3,-1));  \\n\\t\\t\\treturn solve(0,nums,0,dp);\\n\\t\\t }\\n};\\t \\n```\\n# Approach 3 - Tabulation\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[i-1][0] + nums[i];\\n            int y = dp[i-1][1] + nums[i];\\n            int z = dp[i-1][2] + nums[i];\\n            dp[i] = dp[i-1];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[i][x%3] = max({dp[i][x%3],x});\\n            dp[i][y%3] = max({dp[i][y%3],y});\\n            dp[i][z%3] = max({dp[i][z%3],z});\\n            \\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //recursion\\n    int solve(int i,vector<int>& nums,int r){\\n        if(i == nums.size()){\\n            if(r == 0){\\n                return 0;\\n            }\\n            return -1000000;\\n        }\\n        \\n        int op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3);\\n        int op2 = solve(i+1,nums,r);\\n        return max(op1,op2);\\n    }\\n\\t int maxSumDivThree(vector<int>& nums) {\\n\\t     return solve(0,nums,0);\\n\\t }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\tint solve(int i,vector<int>& nums,int r,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == nums.size()){\\n\\t\\t\\t\\tif(r == 0){\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1000000;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][r] != -1) return dp[i][r];\\n\\n\\t\\t\\tint op1 = nums[i] + solve(i+1,nums,(r+nums[i])%3,dp);\\n\\t\\t\\tint op2 = solve(i+1,nums,r,dp);\\n\\t\\t\\treturn dp[i][r] = max(op1,op2);\\n\\t\\t}\\n\\tint maxSumDivThree(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(3,-1));  \\n\\t\\t\\treturn solve(0,nums,0,dp);\\n\\t\\t }\\n};\\t \\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        if(nums[0]%3 == 0){\\n            dp[0][0] = nums[0];\\n        }else if(nums[0]%3 == 1){\\n            dp[0][1] = nums[0];\\n        }else{\\n            dp[0][1] = nums[0];\\n        }\\n        for(int i=1;i<n;i++){\\n            int x = dp[i-1][0] + nums[i];\\n            int y = dp[i-1][1] + nums[i];\\n            int z = dp[i-1][2] + nums[i];\\n            dp[i] = dp[i-1];\\n            // cout<<x<<\" \"<<y<<\" \"<<z<<endl;\\n            dp[i][x%3] = max({dp[i][x%3],x});\\n            dp[i][y%3] = max({dp[i][y%3],y});\\n            dp[i][z%3] = max({dp[i][z%3],z});\\n            \\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1813430,
                "title": "python3-greedy-linear-time",
                "content": "In this approach, the goal will be to sum up the entire list, and subtract only what needs to be subtracted to make the sum divisible by 3.\\n\\nThere are 3 situations regarding the sum:\\n**It is divisible by 3:** We are done already, just return the sum\\n**Leaves a remainder of 1:** Subtract the smallest number that leaves a remainder of 1, or the 2 smallest numbers which leave a remainder of 2- whichever one leaves the larger sum.\\n**Leaves a remainder of 2:** Subtract the smallest number that leaves a remainder of 2, or the 2 smallest numbers which leave a remainder of 1- whichever one leaves the larger sum.\\n\\n```\\ndef maxSumDivThree(self, nums: List[int]) -> int:\\n\\ttotal = sum(nums)\\n\\tif total%3 == 0:\\n\\t\\treturn total\\n\\n\\trem1_min = [10000, 10000] # Smallest 2 numbers leaving remainder of 1\\n\\trem2_min = [10000, 10000] # Smallest 2 numbers leaving remainder of 2\\n\\tfor num in nums:\\n\\t\\tif num % 3 == 1:\\n\\t\\t\\tif num < rem1_min[0]:\\n\\t\\t\\t\\trem1_min[0], rem1_min[1] = num, rem1_min[0]\\n\\t\\t\\telif num < rem1_min[1]:\\n\\t\\t\\t\\trem1_min[1] = num\\n\\t\\telif num % 3 == 2:\\n\\t\\t\\tif num < rem2_min[0]:\\n\\t\\t\\t\\trem2_min[0], rem2_min[1] = num, rem2_min[0]\\n\\t\\t\\telif num < rem2_min[1]:\\n\\t\\t\\t\\trem2_min[1] = num\\n\\n\\tif total%3 == 1:\\n\\t\\treturn total - min(rem1_min[0], sum(rem2_min))\\n\\tif total%3 == 2:\\n\\t\\treturn total - min(rem2_min[0], sum(rem1_min))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "In this approach, the goal will be to sum up the entire list, and subtract only what needs to be subtracted to make the sum divisible by 3.\\n\\nThere are 3 situations regarding the sum:\\n**It is divisible by 3:** We are done already, just return the sum\\n**Leaves a remainder of 1:** Subtract the smallest number that leaves a remainder of 1, or the 2 smallest numbers which leave a remainder of 2- whichever one leaves the larger sum.\\n**Leaves a remainder of 2:** Subtract the smallest number that leaves a remainder of 2, or the 2 smallest numbers which leave a remainder of 1- whichever one leaves the larger sum.\\n\\n```\\ndef maxSumDivThree(self, nums: List[int]) -> int:\\n\\ttotal = sum(nums)\\n\\tif total%3 == 0:\\n\\t\\treturn total\\n\\n\\trem1_min = [10000, 10000] # Smallest 2 numbers leaving remainder of 1\\n\\trem2_min = [10000, 10000] # Smallest 2 numbers leaving remainder of 2\\n\\tfor num in nums:\\n\\t\\tif num % 3 == 1:\\n\\t\\t\\tif num < rem1_min[0]:\\n\\t\\t\\t\\trem1_min[0], rem1_min[1] = num, rem1_min[0]\\n\\t\\t\\telif num < rem1_min[1]:\\n\\t\\t\\t\\trem1_min[1] = num\\n\\t\\telif num % 3 == 2:\\n\\t\\t\\tif num < rem2_min[0]:\\n\\t\\t\\t\\trem2_min[0], rem2_min[1] = num, rem2_min[0]\\n\\t\\t\\telif num < rem2_min[1]:\\n\\t\\t\\t\\trem2_min[1] = num\\n\\n\\tif total%3 == 1:\\n\\t\\treturn total - min(rem1_min[0], sum(rem2_min))\\n\\tif total%3 == 2:\\n\\t\\treturn total - min(rem2_min[0], sum(rem1_min))",
                "codeTag": "Python3"
            },
            {
                "id": 1646188,
                "title": "python-o-n-without-dp-o-1-space",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        # strategy:\\n        # we sum everything, and then remove the smallest\\n        # number(s) possible to make the number divisble by 3\\n        \\n\\t\\t# if sum % 3 == 2, we just remove a number that \\n\\t\\t# is also % 3 == 2, call it mod2, same for mod1.\\n\\t\\t# key: removing 2 mod2\\'s is the same as removing 1 mod1 number\\n\\t\\t# and vice versa\\n\\t\\t\\n        # if sum % 3 == 0, then we are good\\n        # if sum % 3 == 2, we either remove 2 mod1\\'s or 1 mod2\\n\\t\\t# if sum % 3 == 1, we remove 2 mod2\\'s or 1 mod1\\n        # which ever smaller\\n\\t\\t\\n\\t\\t# you notice we only need to keep track of the 2 smallest\\n\\t\\t# nums for mod1 and mod2, so only O(1) space is needed\\n        \\n        total = 0\\n        mod1 = [math.inf, math.inf]\\n        mod2 = [math.inf, math.inf]\\n        \\n        for num in nums:\\n            if num % 3 == 1:\\n                if num < mod1[0]:\\n                    mod1[0], mod1[1] = num, mod1[0]\\n                elif num < mod1[1]:\\n                    mod1[1] = num\\n            elif num % 3 == 2:\\n                if num < mod2[0]:\\n                    mod2[0], mod2[1] = num, mod2[0]\\n                elif num < mod2[1]:\\n                    mod2[1] = num\\n            total += num\\n            \\n        if total % 3 == 1:\\n\\t\\t\\t# if less than 2 nums in mod2, then we can only take from mod1\\n            if math.inf in mod2:\\n                return total - mod1[0]\\n            total -= min(sum(mod2), mod1[0])\\n        elif total % 3 == 2:\\n            if math.inf in mod1:\\n                return total - mod2[0]\\n            total -= min(sum(mod1), mod2[0])\\n            \\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        # strategy:\\n        # we sum everything, and then remove the smallest\\n        # number(s) possible to make the number divisble by 3\\n        \\n\\t\\t# if sum % 3 == 2, we just remove a number that \\n\\t\\t# is also % 3 == 2, call it mod2, same for mod1.\\n\\t\\t# key: removing 2 mod2\\'s is the same as removing 1 mod1 number\\n\\t\\t# and vice versa\\n\\t\\t\\n        # if sum % 3 == 0, then we are good\\n        # if sum % 3 == 2, we either remove 2 mod1\\'s or 1 mod2\\n\\t\\t# if sum % 3 == 1, we remove 2 mod2\\'s or 1 mod1\\n        # which ever smaller\\n\\t\\t\\n\\t\\t# you notice we only need to keep track of the 2 smallest\\n\\t\\t# nums for mod1 and mod2, so only O(1) space is needed\\n        \\n        total = 0\\n        mod1 = [math.inf, math.inf]\\n        mod2 = [math.inf, math.inf]\\n        \\n        for num in nums:\\n            if num % 3 == 1:\\n                if num < mod1[0]:\\n                    mod1[0], mod1[1] = num, mod1[0]\\n                elif num < mod1[1]:\\n                    mod1[1] = num\\n            elif num % 3 == 2:\\n                if num < mod2[0]:\\n                    mod2[0], mod2[1] = num, mod2[0]\\n                elif num < mod2[1]:\\n                    mod2[1] = num\\n            total += num\\n            \\n        if total % 3 == 1:\\n\\t\\t\\t# if less than 2 nums in mod2, then we can only take from mod1\\n            if math.inf in mod2:\\n                return total - mod1[0]\\n            total -= min(sum(mod2), mod1[0])\\n        elif total % 3 == 2:\\n            if math.inf in mod1:\\n                return total - mod2[0]\\n            total -= min(sum(mod1), mod2[0])\\n            \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514206,
                "title": "o-n-time-o-1-space-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        r0 = r1 = r2 = 0\\n        # r0: maximum sum so far that % 3 == 0\\n        # r1: maximum sum so far that % 3 == 1\\n        # r2: maximum sum so far that % 3 == 2\\n        for num in nums:\\n            candidates = num + r0, num + r1, num + r2\\n            for candidate in candidates:\\n                if candidate % 3 == 0:\\n                    r0 = max(r0, candidate)\\n                elif candidate % 3 == 1:\\n                    r1 = max(r1, candidate)\\n                elif candidate % 3 == 2:\\n                    r2 = max(r2, candidate)\\n        return r0",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        r0 = r1 = r2 = 0\\n        # r0: maximum sum so far that % 3 == 0\\n        # r1: maximum sum so far that % 3 == 1\\n        # r2: maximum sum so far that % 3 == 2\\n        for num in nums:\\n            candidates = num + r0, num + r1, num + r2\\n            for candidate in candidates:\\n                if candidate % 3 == 0:\\n                    r0 = max(r0, candidate)\\n                elif candidate % 3 == 1:\\n                    r1 = max(r1, candidate)\\n                elif candidate % 3 == 2:\\n                    r2 = max(r2, candidate)\\n        return r0",
                "codeTag": "Java"
            },
            {
                "id": 1395720,
                "title": "python-dp-solution-simple-code",
                "content": "Using a DP array that considers 3 conditions:\\nmod3 == 0\\nmod3 == 1\\nmod3 == 2\\n\\nThe trick is the initial value of first DP instance.\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [[0]*3 for _ in range(len(nums)+1)]\\n        dp[0][1] = float(\\'-inf\\')\\n        dp[0][2] = float(\\'-inf\\')\\n\\n        for i in range(len(nums)):\\n            remainder = nums[i] % 3\\n            dp[i+1][0] = max(dp[i][0], dp[i][(3 - remainder)%3] + nums[i])\\n            dp[i+1][1] = max(dp[i][1], dp[i][(3-remainder+1)%3] + nums[i])\\n            dp[i+1][2] = max(dp[i][2], dp[i][(3-remainder+2)%3] + nums[i])\\n        return dp[-1][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [[0]*3 for _ in range(len(nums)+1)]\\n        dp[0][1] = float(\\'-inf\\')\\n        dp[0][2] = float(\\'-inf\\')\\n\\n        for i in range(len(nums)):\\n            remainder = nums[i] % 3\\n            dp[i+1][0] = max(dp[i][0], dp[i][(3 - remainder)%3] + nums[i])\\n            dp[i+1][1] = max(dp[i][1], dp[i][(3-remainder+1)%3] + nums[i])\\n            dp[i+1][2] = max(dp[i][2], dp[i][(3-remainder+2)%3] + nums[i])\\n        return dp[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357841,
                "title": "java-clean-dp-with-comments",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] dp = new int[3][nums.length + 1];\\n        for(int i = 1; i <= nums.length; i++) {\\n            int curNum = nums[i - 1];\\n            for(int k = 0; k <= 2; k++) { // for 3 remainders possible i.e. 0, 1, 2\\n                int sum = dp[k][i - 1] + curNum; // add cur number with previous sum for all remainders each.\\n                int newRemainder = sum % 3;\\n                dp[newRemainder][i] = Math.max(dp[newRemainder][i], sum); // hold sum for new remainder \\n                dp[k][i] = Math.max(dp[k][i - 1], dp[k][i]); // check if we can pick max sum from previous location\\n            }\\n            \\n        }\\n        \\n        return dp[0][nums.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] dp = new int[3][nums.length + 1];\\n        for(int i = 1; i <= nums.length; i++) {\\n            int curNum = nums[i - 1];\\n            for(int k = 0; k <= 2; k++) { // for 3 remainders possible i.e. 0, 1, 2\\n                int sum = dp[k][i - 1] + curNum; // add cur number with previous sum for all remainders each.\\n                int newRemainder = sum % 3;\\n                dp[newRemainder][i] = Math.max(dp[newRemainder][i], sum); // hold sum for new remainder \\n                dp[k][i] = Math.max(dp[k][i - 1], dp[k][i]); // check if we can pick max sum from previous location\\n            }\\n            \\n        }\\n        \\n        return dp[0][nums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297334,
                "title": "98-faster-c-standard-dp-approach-with-explanation",
                "content": "dp[i][0] = maximum sum till i-th index which have remainder 0\\n        dp[i][1] = maximum sum till i-th index which have remainder 1\\n        dp[i][2] = maximum sum till i-th index which have remainder 2      \\n\\t\\t\\n\\tint maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n][3];memset(dp,0,sizeof(dp));\\n\\t\\tfor(int i=0;i<n;i++){\\n            for(int j=0;j<3;j++){\\n                // every time we will update all the three columns with the maximum possible sum at that index\\n                if(i==0){ // trivial case i.e.when first element is encountered\\n                    int pos = nums[i]%3; // take out the remainder which will act as a column index for our DP-Table\\n                    dp[i][pos] = max(dp[i][pos],nums[i]); // compare either this possible answer or our previous answer\\n                }\\n                else{\\n                    // this time we have some numbers behind us so we have to consider them for index\\n                    int pos = (dp[i-1][j]+nums[i])%3; // take out the remainder which will act as a column index for our DP-Table\\n                    dp[i][pos] = max(dp[i][pos], dp[i-1][j]+nums[i]);\\n                    dp[i][j] = max(dp[i][j], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        return dp[n-1][0]; //   at last return the maximum sum with 0 remainder \\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "dp[i][0] = maximum sum till i-th index which have remainder 0\\n        dp[i][1] = maximum sum till i-th index which have remainder 1\\n        dp[i][2] = maximum sum till i-th index which have remainder 2      \\n\\t\\t\\n\\tint maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n][3];memset(dp,0,sizeof(dp));\\n\\t\\tfor(int i=0;i<n;i++){\\n            for(int j=0;j<3;j++){\\n                // every time we will update all the three columns with the maximum possible sum at that index\\n                if(i==0){ // trivial case i.e.when first element is encountered\\n                    int pos = nums[i]%3; // take out the remainder which will act as a column index for our DP-Table\\n                    dp[i][pos] = max(dp[i][pos],nums[i]); // compare either this possible answer or our previous answer\\n                }\\n                else{\\n                    // this time we have some numbers behind us so we have to consider them for index\\n                    int pos = (dp[i-1][j]+nums[i])%3; // take out the remainder which will act as a column index for our DP-Table\\n                    dp[i][pos] = max(dp[i][pos], dp[i-1][j]+nums[i]);\\n                    dp[i][j] = max(dp[i][j], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        return dp[n-1][0]; //   at last return the maximum sum with 0 remainder \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1223831,
                "title": "python-greedy-nlogn-easy-to-understand-faster-than-86-with-mathematical-explanation",
                "content": "Let\\'s understand this first. For any integer n, if n mod 3 = 1, then if we subtract n by any integer (smaller than n) m1, m1 mod 3 = 1, then (n-m1) mod 3 = 0. And if we have 2 integer s1 and s2 (s1 and s2 smaller than n), s1 mod 3 = 1 , s2 mod 3 = 1, then (n - s1 - s2) mod 3 = 0. It\\'s the same for n mod 3 = 2\\nSo lets set n as the sum of the input array.\\nif n%3=1\\nans = n - min(m1,s1+ s2)    m1 is the smallest integer that m%3=1 in the list , s1 and s2 are the smallest integers that s or t mod 3 is 2 in the list.\\n\\nif n%3=2\\nans = n - min(m1+m2,s1)     s1 is the smallest integer that m%3=2 in the list , m1 and m2 are the smallest integers that s or t % 3 = 1 in the list.\\n\\nelse\\nans = n\\n\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        rem1 = [float(\\'inf\\')]\\n        rem2 = [float(\\'inf\\')]\\n        \\n        \\n        ans = sum(nums)\\n        \\n        for item in nums:\\n            if item%3 == 1:\\n                rem1.append(item)\\n                \\n            elif item%3 == 2:\\n                rem2.append(item)\\n                \\n        rem1.sort()\\n        rem2.sort()\\n        if ans%3==1:\\n            return ans-min(rem1[0],sum(rem2[:2]))\\n            \\n        \\n        elif ans%3==2:\\n            \\n            return ans-min(rem2[0],sum(rem1[:2]))\\n            \\n        \\n        else:\\n            return ans\\n\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        rem1 = [float(\\'inf\\')]\\n        rem2 = [float(\\'inf\\')]\\n        \\n        \\n        ans = sum(nums)\\n        \\n        for item in nums:\\n            if item%3 == 1:\\n                rem1.append(item)\\n                \\n            elif item%3 == 2:\\n                rem2.append(item)\\n                \\n        rem1.sort()\\n        rem2.sort()\\n        if ans%3==1:\\n            return ans-min(rem1[0],sum(rem2[:2]))\\n            \\n        \\n        elif ans%3==2:\\n            \\n            return ans-min(rem2[0],sum(rem1[:2]))\\n            \\n        \\n        else:\\n            return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137590,
                "title": "c-recursive-memoization",
                "content": "class Solution {\\npublic:\\n    int dp[40001][3]={};\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        return solve(nums,n,0,0);\\n        \\n    }\\n    int solve(vector<int>& nums,int n,int i,int r) { // O(2^n)\\n    if (i >= n) return r % 3 ? INT_MIN : 0;\\n        if(dp[i][r]!=0)\\n            return dp[i][r];\\n        \\n     return dp[i][r]=max(nums[i] + solve(nums,n, i + 1, (r + nums[i]) % 3), solve(nums,n, i+ 1, r));\\n            }      \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[40001][3]={}",
                "codeTag": "Java"
            },
            {
                "id": 948167,
                "title": "c-very-simple-and-short-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int a[3] = {0};\\n        for(int x : nums) {\\n            int b[3];\\n            memcpy(b,a,sizeof(a));\\n            for(int i = 0;i<3;i++) {\\n                int y = b[i] + x;\\n                a[y%3] = max(y,a[y%3]);\\n            }\\n        }\\n        return a[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int a[3] = {0};\\n        for(int x : nums) {\\n            int b[3];\\n            memcpy(b,a,sizeof(a));\\n            for(int i = 0;i<3;i++) {\\n                int y = b[i] + x;\\n                a[y%3] = max(y,a[y%3]);\\n            }\\n        }\\n        return a[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855429,
                "title": "java-single-pass-o-n",
                "content": "Any number will be a sum of 3 if (sum%3 == 0)\\n\\nLet\\'s say x = (sum % 3) and x != 0.\\nthen to make the sum divisble by 3, we have to subtract x from sum (i.e. alpha = sum-x) and hence alpha will be divisble by 3.\\n\\nThus our task is to find greatest value of alpha, which in  turn implies we have to find smallest value of x.\\n\\n-> x can have two values either 1 or 2. (sum%3)/\\nThus our task is to find smalles number in the whole array having remainder as 1 or 2. And subtract that number from the total sum of the array.\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int rem1=10001;\\n        int rem2=10001;\\n        int n = nums.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++) {\\n            sum+=nums[i];\\n            if(nums[i]%3==1) {\\n                rem2 = Math.min(rem1+nums[i], rem2);\\n                rem1 = Math.min(rem1, nums[i]);\\n            }\\n            if(nums[i]%3==2) {\\n                rem1 = Math.min(rem2+nums[i], rem1);\\n                rem2 = Math.min(rem2, nums[i]);\\n            }\\n            \\n        }\\n        if (sum % 3 == 0) {\\n            return sum;\\n        }\\n        return sum%3==1 ? (sum-rem1) : (sum-rem2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int rem1=10001;\\n        int rem2=10001;\\n        int n = nums.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++) {\\n            sum+=nums[i];\\n            if(nums[i]%3==1) {\\n                rem2 = Math.min(rem1+nums[i], rem2);\\n                rem1 = Math.min(rem1, nums[i]);\\n            }\\n            if(nums[i]%3==2) {\\n                rem1 = Math.min(rem2+nums[i], rem1);\\n                rem2 = Math.min(rem2, nums[i]);\\n            }\\n            \\n        }\\n        if (sum % 3 == 0) {\\n            return sum;\\n        }\\n        return sum%3==1 ? (sum-rem1) : (sum-rem2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827184,
                "title": "python-faster-than-99-math-solution",
                "content": "**Explanation:** you can get a modulo-3 number from a sequence, (that\\'s not already mod3) by removing:\\n  -  at most two numbers nums\\n  -  as little as one number num.\\n\\nDon\\'t remove anymore than you have to, so find the minimum sum of these removals and subtract it from the total sequence\\'s sum.\\n\\nRemoving one or two depends on the full-sequence\\'s-sum modulo and the the sum of the two-num-removal vs the value of the one num removal. \\n\\nNote: no need to sort the nums, only remove the minimum iteratively which is what the helper `min_n()` does.\\n \\n```\\ndef maxSumDivThree(nums):\\n    \\n    total =     sum(nums)\\n    mod_total = total % 3 \\n\\n    if mod_total == 0:\\n        return total\\n    \\n    else:\\n        \\n        def min_n(nums, n):\\n            if len(nums) < n: return 10**6\\n            sum_n = 0\\n            for i in range(n):\\n                min_current = min(nums)\\n                min_current_ind = nums.index(min_current)\\n                sum_n += nums.pop(min_current_ind)\\n            return sum_n\\n        \\n        mod_1 = [e for e in nums if e % 3 == 1]\\n        mod_2 = [e for e in nums if e % 3 == 2]\\n        \\n        if mod_total == 1:\\n            \\n            one_mod_1 =   min_n(mod_1, 1)\\n            two_mod_2 =   min_n(mod_2, 2)\\n            \\n            return total - min(one_mod_1, two_mod_2)\\n            \\n        elif mod_total == 2:\\n            \\n            two_mod_1 =   min_n(mod_1, 2)\\n            one_mod_2 =   min_n(mod_2, 1)\\n            \\n            return total - min(two_mod_1, one_mod_2)\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxSumDivThree(nums):\\n    \\n    total =     sum(nums)\\n    mod_total = total % 3 \\n\\n    if mod_total == 0:\\n        return total\\n    \\n    else:\\n        \\n        def min_n(nums, n):\\n            if len(nums) < n: return 10**6\\n            sum_n = 0\\n            for i in range(n):\\n                min_current = min(nums)\\n                min_current_ind = nums.index(min_current)\\n                sum_n += nums.pop(min_current_ind)\\n            return sum_n\\n        \\n        mod_1 = [e for e in nums if e % 3 == 1]\\n        mod_2 = [e for e in nums if e % 3 == 2]\\n        \\n        if mod_total == 1:\\n            \\n            one_mod_1 =   min_n(mod_1, 1)\\n            two_mod_2 =   min_n(mod_2, 2)\\n            \\n            return total - min(one_mod_1, two_mod_2)\\n            \\n        elif mod_total == 2:\\n            \\n            two_mod_1 =   min_n(mod_1, 2)\\n            one_mod_2 =   min_n(mod_2, 1)\\n            \\n            return total - min(two_mod_1, one_mod_2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 758399,
                "title": "c-solution-with-comments-if-doubts-arrise-please-ping-the-comments",
                "content": "class Solution {\\npublic:\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n     \\t\\n     \\tint n = nums.size() ; \\n\\n        //store the numbers which give remainder 1 , 2 when div by 3 : \\n     \\tpriority_queue<int, vector<int> , greater<int> > one ; \\n     \\tpriority_queue<int, vector<int> , greater<int> > two ; \\n\\n        \\n        \\n     \\tint  tsum = 0 ; \\n\\n/*\\n    what i am doing in the below loop : \\n    basically tsum will store the total sum of the nums \\n    \\n    3 cases arrive : either the tsum % 3 == 0 or 1 or 2 ! \\n    so the pq -> one and two will have the nums with remainder 1 and 2 respectively \\n    \\n*/\\n        \\n     \\tfor(int i =0 ; i < n ; i++){\\n     \\t\\ttsum += nums[i] ; \\n     \\t\\tif(nums[i] % 3 == 1){\\n     \\t\\t\\tone.push(nums[i]) ; \\n     \\t\\t}\\n     \\t\\tif(nums[i] % 3 == 2){\\n     \\t\\t\\ttwo.push(nums[i]) ; \\n     \\t\\t}\\n     \\t}\\n    \\n        // best answer \\n     \\tif(tsum % 3 == 0){\\n     \\t\\treturn tsum ; \\n     \\t}\\n\\n        \\n        // here i have 2 choices : \\n        // either subtract 1 num with remainder 1 or 2 numbers with remainder two : \\n     \\tif(tsum % 3 == 1 ){\\n     \\t\\tint first = tsum - one.top() , second = 0  ; \\n\\n     \\t\\tif(two.size() >= 2){\\n     \\t\\t\\tsecond += two.top() ;\\n     \\t\\t\\tint temp = two.top() ; \\n     \\t\\t\\ttwo.pop() ; \\n     \\t\\t\\tsecond += two.top() ; \\n     \\t\\t\\ttwo.push(temp) ; \\n     \\t\\t}\\n\\n     \\t\\tif(second == 0){\\n     \\t\\t\\treturn first ; \\n     \\t\\t}\\n\\n     \\t\\treturn max(first , tsum - second ) ; \\n     \\t}\\n\\n        \\n        // here again i have 2 choices : \\n        // subtract 1 num with remainder 2 or subtract 2 num with remainder 2 : \\n     \\tif(tsum % 3 == 2 ){\\n     \\t\\tint first = tsum - two.top() , second = 0  ; \\n\\n     \\t\\tif(one.size() >= 2){\\n     \\t\\t\\tsecond += one.top() ;\\n     \\t\\t\\tint temp = one.top() ; \\n     \\t\\t\\tone.pop() ; \\n     \\t\\t\\tsecond += one.top() ; \\n     \\t\\t\\tone.push(temp) ; \\n     \\t\\t}\\n\\n     \\t\\tif(second == 0){\\n     \\t\\t\\treturn first ; \\n     \\t\\t}\\n\\n     \\t\\treturn max(first , tsum - second ) ; \\n     \\t}\\n     \\treturn 0 ; \\n    }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n     \\t\\n     \\tint n = nums.size() ; \\n\\n        //store the numbers which give remainder 1 , 2 when div by 3 : \\n     \\tpriority_queue<int, vector<int> , greater<int> > one ; \\n     \\tpriority_queue<int, vector<int> , greater<int> > two ; \\n\\n        \\n        \\n     \\tint  tsum = 0 ; \\n\\n/*\\n    what i am doing in the below loop : \\n    basically tsum will store the total sum of the nums \\n    \\n    3 cases arrive : either the tsum % 3 == 0 or 1 or 2 ! \\n    so the pq -> one and two will have the nums with remainder 1 and 2 respectively \\n    \\n*/\\n        \\n     \\tfor(int i =0 ; i < n ; i++){\\n     \\t\\ttsum += nums[i] ; \\n     \\t\\tif(nums[i] % 3 == 1){\\n     \\t\\t\\tone.push(nums[i]) ; \\n     \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 725484,
                "title": "c-just-math-without-dp",
                "content": "In this solution I just used math to accomplish the solution, but the problem is tagged with dp So I will try to solve it by dp too. In the given solution what I have done is I have consider three cases.\\n**1.** If whole `sum%3==0` then return sum\\n**2.** If `sum%3==1` then to have `sum%3==0` you can remove either one smallest number having mod 1 with 3 or two number having mod 2.\\n**3.** This is similar to point 2 but here removal of number is changed\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v[4];\\n        int sum=0;\\n        for(auto it:nums)\\n        {\\n            int k=it%3;\\n            v[k].push_back(it);\\n            sum+=it;\\n        }\\n        if(sum%3==0)return sum;\\n        for(int i=0;i<4;i++)\\n            sort(v[i].begin(),v[i].end());\\n        if(sum%3==1)\\n        {\\n            int t1=INT_MIN;\\n            int t2=INT_MIN;\\n            if(v[1].size()>0)\\n                t1=sum-v[1][0];\\n            if(v[2].size()>1)\\n                t2=sum-v[2][0]-v[2][1];\\n            return max(t1,t2);\\n        }\\n        else\\n        {\\n            int t1=INT_MIN;\\n            int t2=INT_MIN;\\n            if(v[1].size()>1)\\n                t1=sum-v[1][0]-v[1][1];\\n            if(v[2].size()>0)\\n                t2=sum-v[2][0];\\n            return max(t1,t2);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v[4];\\n        int sum=0;\\n        for(auto it:nums)\\n        {\\n            int k=it%3;\\n            v[k].push_back(it);\\n            sum+=it;\\n        }\\n        if(sum%3==0)return sum;\\n        for(int i=0;i<4;i++)\\n            sort(v[i].begin(),v[i].end());\\n        if(sum%3==1)\\n        {\\n            int t1=INT_MIN;\\n            int t2=INT_MIN;\\n            if(v[1].size()>0)\\n                t1=sum-v[1][0];\\n            if(v[2].size()>1)\\n                t2=sum-v[2][0]-v[2][1];\\n            return max(t1,t2);\\n        }\\n        else\\n        {\\n            int t1=INT_MIN;\\n            int t2=INT_MIN;\\n            if(v[1].size()>1)\\n                t1=sum-v[1][0]-v[1][1];\\n            if(v[2].size()>0)\\n                t2=sum-v[2][0];\\n            return max(t1,t2);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650621,
                "title": "java-math-solution-o-n-time-o-1-space",
                "content": "Execution Plan :\\nWe first calculate the total sum of array . \\nif sum % 3 == 1\\nThen we can remove two elements with remainder 2 or we can remove one element with remainder 1\\nif sum % 3 == 2\\nThen we can remove two elements with remainder 1 or we can remove one element with remainder 2 \\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int m1_min1 = Integer.MAX_VALUE;\\n        int m1_min2 = Integer.MAX_VALUE;\\n        int m2_min1 = Integer.MAX_VALUE;\\n        int m2_min2 = Integer.MAX_VALUE;\\n        int sum = 0;\\n        for(int n : nums){\\n            sum = sum + n;\\n            if(n % 3 == 1){\\n                if(n < m1_min1){\\n                    m1_min2 = m1_min1;\\n                    m1_min1 = n;\\n                } else if(n < m1_min2){\\n                    m1_min2 = n;\\n                }\\n            } else if(n % 3 == 2){\\n                if(n < m2_min1){\\n                    m2_min2 = m2_min1;\\n                    m2_min1 = n;\\n                } else if(n < m2_min2){\\n                    m2_min2 = n;\\n                }\\n            }\\n        }\\n        if(sum % 3 == 0) return sum;\\n        int ans = 0;\\n        if(sum % 3 == 1){\\n            if(m1_min1 < Integer.MAX_VALUE){\\n                ans = Math.max(ans,sum - m1_min1);\\n            }\\n            if(m2_min1 < Integer.MAX_VALUE && m2_min2 < Integer.MAX_VALUE){\\n                ans = Math.max(ans , sum - m2_min1 - m2_min2);\\n            }\\n        }\\n        if(sum % 3 == 2){\\n            if(m2_min1 < Integer.MAX_VALUE){\\n                ans = Math.max(ans,sum - m2_min1);\\n            }\\n            if(m1_min1 < Integer.MAX_VALUE && m1_min2 < Integer.MAX_VALUE){\\n                ans = Math.max(ans , sum - m1_min1 - m1_min2);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int m1_min1 = Integer.MAX_VALUE;\\n        int m1_min2 = Integer.MAX_VALUE;\\n        int m2_min1 = Integer.MAX_VALUE;\\n        int m2_min2 = Integer.MAX_VALUE;\\n        int sum = 0;\\n        for(int n : nums){\\n            sum = sum + n;\\n            if(n % 3 == 1){\\n                if(n < m1_min1){\\n                    m1_min2 = m1_min1;\\n                    m1_min1 = n;\\n                } else if(n < m1_min2){\\n                    m1_min2 = n;\\n                }\\n            } else if(n % 3 == 2){\\n                if(n < m2_min1){\\n                    m2_min2 = m2_min1;\\n                    m2_min1 = n;\\n                } else if(n < m2_min2){\\n                    m2_min2 = n;\\n                }\\n            }\\n        }\\n        if(sum % 3 == 0) return sum;\\n        int ans = 0;\\n        if(sum % 3 == 1){\\n            if(m1_min1 < Integer.MAX_VALUE){\\n                ans = Math.max(ans,sum - m1_min1);\\n            }\\n            if(m2_min1 < Integer.MAX_VALUE && m2_min2 < Integer.MAX_VALUE){\\n                ans = Math.max(ans , sum - m2_min1 - m2_min2);\\n            }\\n        }\\n        if(sum % 3 == 2){\\n            if(m2_min1 < Integer.MAX_VALUE){\\n                ans = Math.max(ans,sum - m2_min1);\\n            }\\n            if(m1_min1 < Integer.MAX_VALUE && m1_min2 < Integer.MAX_VALUE){\\n                ans = Math.max(ans , sum - m1_min1 - m1_min2);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601387,
                "title": "golang-short-dp-solution",
                "content": "```go\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maxSumDivThree(nums []int) int {\\n    dp := [3]int{}\\n    temp := [3]int{}\\n    \\n    for _, n := range nums {\\n        temp = dp\\n        for _, sum := range temp {\\n            key := (sum+n) % 3 // reminder as key, key is index based\\n            dp[key] = max(sum+n, dp[key])\\n        }\\n    }\\n    \\n    return dp[0]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maxSumDivThree(nums []int) int {\\n    dp := [3]int{}\\n    temp := [3]int{}\\n    \\n    for _, n := range nums {\\n        temp = dp\\n        for _, sum := range temp {\\n            key := (sum+n) % 3 // reminder as key, key is index based\\n            dp[key] = max(sum+n, dp[key])\\n        }\\n    }\\n    \\n    return dp[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548456,
                "title": "10-lines-dp-in-python-if-you-know-what-you-are-doing",
                "content": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        # key: remainder - 0, 1, or 2\\n        # value: maximum sum that can be divide by 3 with the remainer\\n        max_dict = {0: 0}\\n\\n        for n in nums:\\n            previous_max = list(max_dict.values())\\n            for p in previous_max:\\n                new_sum = p + n\\n                remainder = new_sum % 3\\n                max_dict[remainder] = max(max_dict.get(remainder, new_sum), new_sum)\\n\\n        return max_dict[0]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        # key: remainder - 0, 1, or 2\\n        # value: maximum sum that can be divide by 3 with the remainer\\n        max_dict = {0: 0}\\n\\n        for n in nums:\\n            previous_max = list(max_dict.values())\\n            for p in previous_max:\\n                new_sum = p + n\\n                remainder = new_sum % 3\\n                max_dict[remainder] = max(max_dict.get(remainder, new_sum), new_sum)\\n\\n        return max_dict[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520617,
                "title": "java-o-n-solution",
                "content": "```\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[]{0, -1, -1};\\n\\n        for(int num : nums){\\n            int folds = num / 3;\\n            int remain = num % 3;\\n\\n            int[] tmp = Arrays.copyOf(dp, 3);\\n            for(int i=0; i<3; i++){\\n                if(tmp[i]!=-1){\\n                    int newKey = remain + i;\\n                    int newFolds = folds + tmp[i];\\n                    if(newKey>=3){\\n                        newKey %= 3;\\n                        newFolds++;\\n                    }\\n\\n                    dp[newKey] = Math.max(tmp[newKey], newFolds);\\n                }\\n            }\\n        }\\n\\n        return dp[0] * 3;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[]{0, -1, -1};\\n\\n        for(int num : nums){\\n            int folds = num / 3;\\n            int remain = num % 3;\\n\\n            int[] tmp = Arrays.copyOf(dp, 3);\\n            for(int i=0; i<3; i++){\\n                if(tmp[i]!=-1){\\n                    int newKey = remain + i;\\n                    int newFolds = folds + tmp[i];\\n                    if(newKey>=3){\\n                        newKey %= 3;\\n                        newFolds++;\\n                    }\\n\\n                    dp[newKey] = Math.max(tmp[newKey], newFolds);\\n                }\\n            }\\n        }\\n\\n        return dp[0] * 3;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 511448,
                "title": "go-golang-two-solutions",
                "content": ">Runtime: 32 ms, faster than 94.12% of Go online submissions for Greatest Sum Divisible by Three.\\nMemory Usage: 6.3 MB, less than 100.00% of Go online submissions for Greatest Sum Divisible by Three.\\n\\n```go\\nfunc maxSumDivThree(nums []int) int {\\n    res := 0\\n    one := 10000\\n    two := 10000\\n    for i := 0; i < len(nums); i++ {\\n        res += nums[i]\\n        if nums[i] % 3 == 1 {\\n            two = min(two, one + nums[i])\\n            one = min(one, nums[i])\\n        }\\n        if nums[i] % 3 == 2 {\\n            one = min(one, two + nums[i])\\n            two = min(two, nums[i])\\n        }\\n    }\\n    if res % 3 == 0 { return res }\\n    if res % 3 == 1 { return res - one }\\n    return res - two\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```\\n\\n>Runtime: 32 ms, faster than 94.12% of Go online submissions for Greatest Sum Divisible by Three.\\nMemory Usage: 6.3 MB, less than 100.00% of Go online submissions for Greatest Sum Divisible by Three.\\n\\n```go\\nfunc maxSumDivThree(nums []int) int {\\n    dp := make([]int, 3)\\n    for _, v := range nums {\\n        tmp := make([]int, 3)\\n        copy(tmp, dp)\\n        for i := 0; i < 3; i++ {\\n            dp[(v + tmp[i]) % 3] = max(dp[(v + tmp[i]) % 3], v + tmp[i])\\n        }\\n    }\\n    return dp[0]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxSumDivThree(nums []int) int {\\n    res := 0\\n    one := 10000\\n    two := 10000\\n    for i := 0; i < len(nums); i++ {\\n        res += nums[i]\\n        if nums[i] % 3 == 1 {\\n            two = min(two, one + nums[i])\\n            one = min(one, nums[i])\\n        }\\n        if nums[i] % 3 == 2 {\\n            one = min(one, two + nums[i])\\n            two = min(two, nums[i])\\n        }\\n    }\\n    if res % 3 == 0 { return res }\\n    if res % 3 == 1 { return res - one }\\n    return res - two\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```\n```go\\nfunc maxSumDivThree(nums []int) int {\\n    dp := make([]int, 3)\\n    for _, v := range nums {\\n        tmp := make([]int, 3)\\n        copy(tmp, dp)\\n        for i := 0; i < 3; i++ {\\n            dp[(v + tmp[i]) % 3] = max(dp[(v + tmp[i]) % 3], v + tmp[i])\\n        }\\n    }\\n    return dp[0]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458559,
                "title": "o-n-math-solution-no-dp",
                "content": "Get the sum of all numbers in the array first. Then we have 3 cases:\\n1. If sum % 3 == 0\\n    return sum directly.\\n2. If sum % 3 == 1\\n    What we want to do is to find out the smallest sub array in the origin array whose sum mod 3 is also 1.\\n\\tSo that we can get the final answer: sum - sub_sum.\\n\\tThe only 2 cases for the sub_sum which mod 3 is 1:\\n    * \\tThe smallest number which mod 3 is 1.\\n    * \\tThe smallest 2 numbers which mod 3 is 2. (if a % 3 == 2 and b % 3 == 2, (a + b) % 3 will be 1)\\n    \\n\\tOnce we get above 2 sub sums, just need to compare which one is smaller and minus this sub sum.\\n3. If sum % 3 == 2\\n    The same idea as #2.\\n\\n\\nAdd an example here.\\n\\nIf we have an array like: 7, 5, 4, 2, 9, 10, 6, 3, 1.\\nThe solution here is to sum up all the numbers together, which is 47.\\nAnd also get the smallest 2 numbers who mod 3 is 1 and 2, which are `min_remain_one`= 1, `min_remain_one_2`= 4 and `min_remain_two`= 2, `min_remain_two_2`= 5.\\nAs 47 mod 3 is 2, then we compare `min_remain_two`= 2 with `min_remain_one` + `min_remain_one_2` = 5, get `min_remain_two` is smaller. So that the final result is 47 - 2 = 45.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int min_remain_one = INT_MAX;\\n        int min_remain_two = INT_MAX;\\n        int min_remain_one_2 = INT_MAX;\\n        int min_remain_two_2 = INT_MAX;\\n        int sum = 0;\\n        \\n        for (int num : nums) {\\n            int remain = num % 3;\\n            \\n            switch (remain) {\\n                case 1:\\n                    if (num <= min_remain_one) {\\n                        min_remain_one_2 = min_remain_one;\\n                        min_remain_one = num;\\n                    } else if (num <= min_remain_one_2) {\\n                        min_remain_one_2 = num;\\n                    }\\n                    break;\\n                case 2:\\n                    if (num <= min_remain_two) {\\n                        min_remain_two_2 = min_remain_two;\\n                        min_remain_two = num;\\n                    } else if (num <= min_remain_two_2) {\\n                        min_remain_two_2 = num;\\n                    }\\n                    break;\\n            }\\n            \\n            sum += num;\\n        }\\n        \\n        if (sum % 3 == 1) {\\n            if (min_remain_two == INT_MAX || min_remain_two_2 == INT_MAX)\\n                sum -= min_remain_one;\\n            else\\n                sum -= min(min_remain_one, min_remain_two + min_remain_two_2);\\n        } else if (sum % 3 == 2) {\\n            if (min_remain_one == INT_MAX || min_remain_one_2 == INT_MAX)\\n                sum -= min_remain_two;\\n            else\\n                sum -= min(min_remain_two, min_remain_one + min_remain_one_2);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int min_remain_one = INT_MAX;\\n        int min_remain_two = INT_MAX;\\n        int min_remain_one_2 = INT_MAX;\\n        int min_remain_two_2 = INT_MAX;\\n        int sum = 0;\\n        \\n        for (int num : nums) {\\n            int remain = num % 3;\\n            \\n            switch (remain) {\\n                case 1:\\n                    if (num <= min_remain_one) {\\n                        min_remain_one_2 = min_remain_one;\\n                        min_remain_one = num;\\n                    } else if (num <= min_remain_one_2) {\\n                        min_remain_one_2 = num;\\n                    }\\n                    break;\\n                case 2:\\n                    if (num <= min_remain_two) {\\n                        min_remain_two_2 = min_remain_two;\\n                        min_remain_two = num;\\n                    } else if (num <= min_remain_two_2) {\\n                        min_remain_two_2 = num;\\n                    }\\n                    break;\\n            }\\n            \\n            sum += num;\\n        }\\n        \\n        if (sum % 3 == 1) {\\n            if (min_remain_two == INT_MAX || min_remain_two_2 == INT_MAX)\\n                sum -= min_remain_one;\\n            else\\n                sum -= min(min_remain_one, min_remain_two + min_remain_two_2);\\n        } else if (sum % 3 == 2) {\\n            if (min_remain_one == INT_MAX || min_remain_one_2 == INT_MAX)\\n                sum -= min_remain_two;\\n            else\\n                sum -= min(min_remain_two, min_remain_one + min_remain_one_2);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433078,
                "title": "java-dp-explained",
                "content": "Problem can be solved with DP. The parameter we can use is the modulo of the sum. 3 possible values, and for each element of the array (from j to N - 1). Optimize by max sum for each modulo.\\nO(n) time - need to check every element of the array 3 times. O(n) space - dp array proportional to number of elements \\n\\n```\\n    public int maxSumDivThree(int[] nums) {\\n        int N = nums.length;\\n        //create array i,j will be max sum from i to end with modulo 3 == j\\n        int[][] dp = new int[N][3];\\n        //init with the last array element\\n        dp[N - 1][nums[N - 1] % 3] = nums[N - 1];\\n        //starting from the second from the end element do the dp loop\\n        for (int i = N - 2; i >= 0; i--) {\\n            //copy max sums from the previous step\\n            for (int j =0; j < 3; j++)\\n                dp[i][j] = dp[i +1][j];\\n            //for each modulo 3 value\\n            for (int j = 0; j < 3; j++) {\\n                //get previous sum for modulo j and add nums[i]\\n                int s = dp[i + 1][j] + nums[i];\\n                //then put to the s % 3 element max between s and the sum for the same modulo\\n                //from the previous step\\n                dp[i][s % 3] = Math.max(s, dp[i][s % 3]);\\n            }\\n        }\\n        //result always be in 0,0 - max sum with modulo 3\\n        return dp[0][0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int maxSumDivThree(int[] nums) {\\n        int N = nums.length;\\n        //create array i,j will be max sum from i to end with modulo 3 == j\\n        int[][] dp = new int[N][3];\\n        //init with the last array element\\n        dp[N - 1][nums[N - 1] % 3] = nums[N - 1];\\n        //starting from the second from the end element do the dp loop\\n        for (int i = N - 2; i >= 0; i--) {\\n            //copy max sums from the previous step\\n            for (int j =0; j < 3; j++)\\n                dp[i][j] = dp[i +1][j];\\n            //for each modulo 3 value\\n            for (int j = 0; j < 3; j++) {\\n                //get previous sum for modulo j and add nums[i]\\n                int s = dp[i + 1][j] + nums[i];\\n                //then put to the s % 3 element max between s and the sum for the same modulo\\n                //from the previous step\\n                dp[i][s % 3] = Math.max(s, dp[i][s % 3]);\\n            }\\n        }\\n        //result always be in 0,0 - max sum with modulo 3\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431189,
                "title": "java-easy-to-understand-o-n-solution-with-o-1-space-3ms",
                "content": "Idea is to maintain 2 minimum numbers having mod%3 == 1 and 2 minimum numbers having mod%3 == 2. Then after calculating total sum, answer would be - \\n\\t-> totalSum, if divisible by 3\\n\\t-> totalSum - min{min num having mod%3 == 1, sum of min two nums having mod%3 == 2}, if totalSum%3 == 1\\n\\t-> totalSum - min{min num having mod%3 == 2, sum of min two nums having mod%3 == 1}, if totalSum%3 == 2\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        if (nums == null || nums.length == 0) \\n            return 0;\\n        \\n        int maxSum = 0;\\n        int mod1Min1 = Integer.MAX_VALUE, mod1Min2 = Integer.MAX_VALUE;\\n        int mod2Min1 = Integer.MAX_VALUE, mod2Min2 = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            maxSum += num;\\n\\n            switch (num%3) {\\n                case 1:\\n                    if (num < mod1Min1) {\\n                        mod1Min2 = mod1Min1;\\n                        mod1Min1 = num;\\n                    } else if (num < mod1Min2) {\\n                        mod1Min2 = num;\\n                    }\\n                    break;\\n                case 2:\\n                    if (num < mod2Min1) {\\n                        mod2Min2 = mod2Min1;\\n                        mod2Min1 = num;\\n                    } else if (num < mod2Min2) {\\n                        mod2Min2 = num;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n        if (maxSum%3 == 1) {\\n            return maxSum - Math.min(mod1Min1, mod2Min2 != Integer.MAX_VALUE? mod2Min1+mod2Min2 : Integer.MAX_VALUE);\\n        }\\n        if (maxSum%3 == 2) {\\n            return maxSum - Math.min(mod1Min2 != Integer.MAX_VALUE? mod1Min1+mod1Min2 : Integer.MAX_VALUE, mod2Min1);\\n        }\\n        \\n        return maxSum;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        if (nums == null || nums.length == 0) \\n            return 0;\\n        \\n        int maxSum = 0;\\n        int mod1Min1 = Integer.MAX_VALUE, mod1Min2 = Integer.MAX_VALUE;\\n        int mod2Min1 = Integer.MAX_VALUE, mod2Min2 = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            maxSum += num;\\n\\n            switch (num%3) {\\n                case 1:\\n                    if (num < mod1Min1) {\\n                        mod1Min2 = mod1Min1;\\n                        mod1Min1 = num;\\n                    } else if (num < mod1Min2) {\\n                        mod1Min2 = num;\\n                    }\\n                    break;\\n                case 2:\\n                    if (num < mod2Min1) {\\n                        mod2Min2 = mod2Min1;\\n                        mod2Min1 = num;\\n                    } else if (num < mod2Min2) {\\n                        mod2Min2 = num;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n        if (maxSum%3 == 1) {\\n            return maxSum - Math.min(mod1Min1, mod2Min2 != Integer.MAX_VALUE? mod2Min1+mod2Min2 : Integer.MAX_VALUE);\\n        }\\n        if (maxSum%3 == 2) {\\n            return maxSum - Math.min(mod1Min2 != Integer.MAX_VALUE? mod1Min1+mod1Min2 : Integer.MAX_VALUE, mod2Min1);\\n        }\\n        \\n        return maxSum;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431175,
                "title": "clear-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        List<Integer> oneList = new ArrayList<>();\\n        List<Integer> twoList = new ArrayList<>();\\n        for (int num : nums) {\\n            if (num % 3 == 1) oneList.add(num);\\n            if (num % 3 == 2) twoList.add(num);\\n            sum += num;\\n        }\\n        if (sum % 3 == 0) return sum;\\n        else {\\n            Collections.sort(oneList);\\n            Collections.sort(twoList);\\n            \\n            if (sum % 3 == 1) {\\n                if (oneList.size() < 1 && twoList.size() < 2) return 0; \\n                int minSubtract = Integer.MAX_VALUE;\\n                if (oneList.size() >= 1) minSubtract = Math.min(minSubtract, oneList.get(0));\\n                if (twoList.size() >= 2) minSubtract = Math.min(minSubtract, twoList.get(0) + twoList.get(1));\\n                return sum - minSubtract;\\n            } else { // %3 == 2\\n                if (oneList.size() < 2 && twoList.size() < 1) return 0; \\n                int minSubtract = Integer.MAX_VALUE;\\n                if (oneList.size() >= 2) minSubtract = Math.min(minSubtract, oneList.get(0) + oneList.get(1));\\n                if (twoList.size() >= 1) minSubtract = Math.min(minSubtract, twoList.get(0));\\n                return sum - minSubtract;\\n            }            \\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int sum = 0;\\n        List<Integer> oneList = new ArrayList<>();\\n        List<Integer> twoList = new ArrayList<>();\\n        for (int num : nums) {\\n            if (num % 3 == 1) oneList.add(num);\\n            if (num % 3 == 2) twoList.add(num);\\n            sum += num;\\n        }\\n        if (sum % 3 == 0) return sum;\\n        else {\\n            Collections.sort(oneList);\\n            Collections.sort(twoList);\\n            \\n            if (sum % 3 == 1) {\\n                if (oneList.size() < 1 && twoList.size() < 2) return 0; \\n                int minSubtract = Integer.MAX_VALUE;\\n                if (oneList.size() >= 1) minSubtract = Math.min(minSubtract, oneList.get(0));\\n                if (twoList.size() >= 2) minSubtract = Math.min(minSubtract, twoList.get(0) + twoList.get(1));\\n                return sum - minSubtract;\\n            } else { // %3 == 2\\n                if (oneList.size() < 2 && twoList.size() < 1) return 0; \\n                int minSubtract = Integer.MAX_VALUE;\\n                if (oneList.size() >= 2) minSubtract = Math.min(minSubtract, oneList.get(0) + oneList.get(1));\\n                if (twoList.size() >= 1) minSubtract = Math.min(minSubtract, twoList.get(0));\\n                return sum - minSubtract;\\n            }            \\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431153,
                "title": "java-one-pass-o-n-time-o-1-space-solution",
                "content": "Use 2 PriorityQueue with size of 2. Space is O(1). The priority queue insertion is O(pq.size()) for time complexity, namely O(1).\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        PriorityQueue<Integer> ones = new PriorityQueue<>((a, b) -> b - a);  // the two minumum numbers which % 3 == 1\\n        PriorityQueue<Integer> twos = new PriorityQueue<>((a, b) -> b - a);  // the two minumum numbers which % 3 == 2\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                updatePQ(ones, num);\\n            } else if (num % 3 == 2) {\\n                updatePQ(twos, num);\\n            }\\n        }\\n        int sum1 = 0, sum2 = 0;\\n        if (sum % 3 == 0) {\\n            return sum;\\n        } else if (sum % 3 == 1) {\\n            if (twos.size() == 2) {\\n                sum2 = sum - twos.poll() - twos.poll();\\n            }\\n            if (!ones.isEmpty()) {\\n                if (ones.size() == 2) {\\n                    ones.poll();\\n                }\\n                sum1 = sum - ones.poll();\\n            }\\n        } else {\\n            if (ones.size() == 2) {\\n                sum1 = sum - ones.poll() - ones.poll();\\n            }\\n            if (!twos.isEmpty()) {\\n                if (twos.size() == 2) {\\n                    twos.poll();\\n                }\\n                sum2 = sum - twos.poll();\\n            }\\n        }\\n        return Math.max(sum1, sum2);\\n    }\\n    \\n    private void updatePQ(PriorityQueue<Integer> pq, int num) {\\n        pq.offer(num);\\n        if (pq.size() > 2) {\\n            pq.poll();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        PriorityQueue<Integer> ones = new PriorityQueue<>((a, b) -> b - a);  // the two minumum numbers which % 3 == 1\\n        PriorityQueue<Integer> twos = new PriorityQueue<>((a, b) -> b - a);  // the two minumum numbers which % 3 == 2\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            if (num % 3 == 1) {\\n                updatePQ(ones, num);\\n            } else if (num % 3 == 2) {\\n                updatePQ(twos, num);\\n            }\\n        }\\n        int sum1 = 0, sum2 = 0;\\n        if (sum % 3 == 0) {\\n            return sum;\\n        } else if (sum % 3 == 1) {\\n            if (twos.size() == 2) {\\n                sum2 = sum - twos.poll() - twos.poll();\\n            }\\n            if (!ones.isEmpty()) {\\n                if (ones.size() == 2) {\\n                    ones.poll();\\n                }\\n                sum1 = sum - ones.poll();\\n            }\\n        } else {\\n            if (ones.size() == 2) {\\n                sum1 = sum - ones.poll() - ones.poll();\\n            }\\n            if (!twos.isEmpty()) {\\n                if (twos.size() == 2) {\\n                    twos.poll();\\n                }\\n                sum2 = sum - twos.poll();\\n            }\\n        }\\n        return Math.max(sum1, sum2);\\n    }\\n    \\n    private void updatePQ(PriorityQueue<Integer> pq, int num) {\\n        pq.offer(num);\\n        if (pq.size() > 2) {\\n            pq.poll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431085,
                "title": "c-greedy-solution-with-explaination",
                "content": "1) By seeing the constraints, it is clear that a dp approach of the order of N ^ 2 cannot be applied(just like coin change or subset sum(N ^ 2)). By the way, others have done it using dp in linear time complexity.\\n2) Therefore, we have to think greedily. \\n3) If total sum is divisible by 3, then we do not need to remove any element and the entire sum is our answer.\\n4) On the other hand, if sum is either 1 or 2, then we need to remove the smallest possible sum from the total.\\n5) For total % 3 = 1, we have two options, either to remove two smallest number with % 3 = 2 or the smallest number with % 3  = 1.\\n6) Similarily, for total % 3 = 2, we have two options, either to remove two smallest number with % 3 = 1 or the smallest number with % 3  = 2.\\n\\nWe can do it without sorting as well. Finding smallest and second smallest element in O(N) is also quite easy.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int sum = 0;\\n        mp[0] = 0;\\n        int mx = 0;\\n        vector<int> v1, v2;\\n        int sm1 = INT_MAX, sm2 = INT_MAX;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if(nums[i] % 3 == 1) {\\n                v1.push_back(nums[i]);\\n            }\\n            if(nums[i] % 3 == 2) {\\n                v2.push_back(nums[i]);\\n            }\\n        }\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        int mn11, mn12, mn21, mn22;\\n        mn11 = mn21 = mn12 = mn22 = INT_MAX;\\n        if(v1.size()) {\\n            mn11 = v1[0];\\n        }\\n        if(v1.size() > 1) {\\n            mn12 = v1[1];\\n        }\\n        if(v2.size()) {\\n            mn21 = v2[0];\\n        }\\n        if(v2.size() > 1) {\\n            mn22 = v2[1];\\n        }\\n        if(sum % 3 == 0) {\\n            return sum;\\n        }\\n        else if(sum % 3 == 1) {\\n            int ans = 0;\\n            if(mn11 != INT_MAX) {\\n                ans = sum - mn11;\\n            }\\n            if(mn21 != INT_MAX && mn22 != INT_MAX) {\\n                ans = max(ans, sum - mn21 - mn22);\\n            }\\n            return ans;\\n        }\\n        else if(sum % 3 == 2) {\\n            int ans = 0;\\n            if(mn21 !=INT_MAX) {\\n                ans = sum - mn21;\\n            }\\n            if(mn11 != INT_MAX && mn12 != INT_MAX) {\\n                ans = max(ans, sum - mn11 - mn12);\\n            }\\n            return ans;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int sum = 0;\\n        mp[0] = 0;\\n        int mx = 0;\\n        vector<int> v1, v2;\\n        int sm1 = INT_MAX, sm2 = INT_MAX;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if(nums[i] % 3 == 1) {\\n                v1.push_back(nums[i]);\\n            }\\n            if(nums[i] % 3 == 2) {\\n                v2.push_back(nums[i]);\\n            }\\n        }\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        int mn11, mn12, mn21, mn22;\\n        mn11 = mn21 = mn12 = mn22 = INT_MAX;\\n        if(v1.size()) {\\n            mn11 = v1[0];\\n        }\\n        if(v1.size() > 1) {\\n            mn12 = v1[1];\\n        }\\n        if(v2.size()) {\\n            mn21 = v2[0];\\n        }\\n        if(v2.size() > 1) {\\n            mn22 = v2[1];\\n        }\\n        if(sum % 3 == 0) {\\n            return sum;\\n        }\\n        else if(sum % 3 == 1) {\\n            int ans = 0;\\n            if(mn11 != INT_MAX) {\\n                ans = sum - mn11;\\n            }\\n            if(mn21 != INT_MAX && mn22 != INT_MAX) {\\n                ans = max(ans, sum - mn21 - mn22);\\n            }\\n            return ans;\\n        }\\n        else if(sum % 3 == 2) {\\n            int ans = 0;\\n            if(mn21 !=INT_MAX) {\\n                ans = sum - mn21;\\n            }\\n            if(mn11 != INT_MAX && mn12 != INT_MAX) {\\n                ans = max(ans, sum - mn11 - mn12);\\n            }\\n            return ans;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567033,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar maxSumDivThree = function(nums) {\\n    let remainOne = remainTwo = 10 ** 4;\\n    let sum = 0;\\n\\n    nums.forEach(num => {\\n        sum += num;\\n        if (num % 3 === 1) {\\n            remainTwo = Math.min(remainTwo, remainOne + num);\\n            remainOne = Math.min(remainOne, num);\\n        } else if (num % 3 === 2) {\\n            remainOne = Math.min(remainOne, remainTwo + num);\\n            remainTwo = Math.min(remainTwo, num);\\n        }\\n    });\\n\\n    const remainSum = sum % 3;\\n\\n    if (remainSum === 0) return sum;\\n    if (remainSum === 1) return sum - remainOne;\\n    return sum - remainTwo;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSumDivThree = function(nums) {\\n    let remainOne = remainTwo = 10 ** 4;\\n    let sum = 0;\\n\\n    nums.forEach(num => {\\n        sum += num;\\n        if (num % 3 === 1) {\\n            remainTwo = Math.min(remainTwo, remainOne + num);\\n            remainOne = Math.min(remainOne, num);\\n        } else if (num % 3 === 2) {\\n            remainOne = Math.min(remainOne, remainTwo + num);\\n            remainTwo = Math.min(remainTwo, num);\\n        }\\n    });\\n\\n    const remainSum = sum % 3;\\n\\n    if (remainSum === 0) return sum;\\n    if (remainSum === 1) return sum - remainOne;\\n    return sum - remainTwo;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3103419,
                "title": "python-greedy-heap",
                "content": "# Intuition\\nIn order to maximize sum divisible by 3, we need to minimize sum of items, which give the same remainder as the whole array sum.\\n\\n# Approach\\n1. Check whole array sum remainder.\\n- If it is ``0`` then return whole array sum\\n- Otherwise check the remainder - either ``1`` or ``2``\\n2. Build two min-heaps for each of the remainders of size ``2``\\n3. Check different cases for each remainder:\\n- ``1`` is either smallest remainder-1 value or sum of two smallest remainder-2 values\\n- ``2`` is either smallest remainder-2 value or sum of two smallest remainder-1 values\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        r = s % 3\\n        if r == 0:\\n            return s\\n        h1, h2 = [], []\\n        for v in nums:\\n            if v % 3 == 1:\\n                if len(h1) < 2:\\n                    heapq.heappush(h1, -v)\\n                elif v < -h1[0]:\\n                    heapq.heappop(h1)\\n                    heapq.heappush(h1, -v)\\n            elif v % 3 == 2:\\n                if len(h2) < 2:\\n                    heapq.heappush(h2, -v)\\n                elif v < -h2[0]:\\n                    heapq.heappop(h2)\\n                    heapq.heappush(h2, -v)\\n\\n        r11, r12 = -heapq.heappop(h1) if h1 else s, -heapq.heappop(h1) if h1 else s\\n        r21, r22 = -heapq.heappop(h2) if h2 else s, -heapq.heappop(h2) if h2 else s\\n\\n        if r == 1:\\n            return s - min(r12, r11, r21+r22)\\n\\n        return s - min(r11 + r12, r22, r21)",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "# Intuition\\nIn order to maximize sum divisible by 3, we need to minimize sum of items, which give the same remainder as the whole array sum.\\n\\n# Approach\\n1. Check whole array sum remainder.\\n- If it is ``0`` then return whole array sum\\n- Otherwise check the remainder - either ``1`` or ``2``\\n2. Build two min-heaps for each of the remainders of size ``2``\\n3. Check different cases for each remainder:\\n- ``1`` is either smallest remainder-1 value or sum of two smallest remainder-2 values\\n- ``2`` is either smallest remainder-2 value or sum of two smallest remainder-1 values\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        r = s % 3\\n        if r == 0:\\n            return s\\n        h1, h2 = [], []\\n        for v in nums:\\n            if v % 3 == 1:\\n                if len(h1) < 2:\\n                    heapq.heappush(h1, -v)\\n                elif v < -h1[0]:\\n                    heapq.heappop(h1)\\n                    heapq.heappush(h1, -v)\\n            elif v % 3 == 2:\\n                if len(h2) < 2:\\n                    heapq.heappush(h2, -v)\\n                elif v < -h2[0]:\\n                    heapq.heappop(h2)\\n                    heapq.heappush(h2, -v)\\n\\n        r11, r12 = -heapq.heappop(h1) if h1 else s, -heapq.heappop(h1) if h1 else s\\n        r21, r22 = -heapq.heappop(h2) if h2 else s, -heapq.heappop(h2) if h2 else s\\n\\n        if r == 1:\\n            return s - min(r12, r11, r21+r22)\\n\\n        return s - min(r11 + r12, r22, r21)",
                "codeTag": "Java"
            },
            {
                "id": 2971208,
                "title": "python-very-easy-solution",
                "content": "# Complexity\\n- Time complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [0] * 3\\n        for v in nums:\\n            a, b, c = dp[0] + v, dp[1] + v, dp[2] + v\\n            dp[a % 3] = max(dp[a % 3], a)\\n            dp[b % 3] = max(dp[b % 3], b)\\n            dp[c % 3] = max(dp[c % 3], c)\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [0] * 3\\n        for v in nums:\\n            a, b, c = dp[0] + v, dp[1] + v, dp[2] + v\\n            dp[a % 3] = max(dp[a % 3], a)\\n            dp[b % 3] = max(dp[b % 3], b)\\n            dp[c % 3] = max(dp[c % 3], c)\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500253,
                "title": "c-o-n-dp-tabulation-easy-to-understand",
                "content": "**Dynamic Programming Approach!!**\\n**(Tabulation)**\\nTime Complexity:- O(N)\\nSpace Complexity:- O(N) \\n    \\nclass Solution {\\npublic:\\n   \\n    int maxSumDivThree(vector<int>& nums) {\\n\\t\\n        // dp vector for storing number with remainder {0,1,2}\\n        vector<int> dp={0,INT_MIN,INT_MIN};\\n        \\n        for(auto i: nums){\\n            vector<int> tmp(3);\\n            \\n            for(int j=0;j<3;j++){\\n                tmp[(j+i)%3]=max(dp[(j+i)%3],dp[j]+i);\\n            }\\n            \\n            dp=tmp;\\n        }\\n        \\n        // Returning the Greatest sum\\n        return dp[0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    int maxSumDivThree(vector<int>& nums) {\\n\\t\\n        // dp vector for storing number with remainder {0,1,2}",
                "codeTag": "Java"
            },
            {
                "id": 2335142,
                "title": "o-n-o-1-solution",
                "content": "**SC: O(1) TC: O(N)**\\nFor any number if we divide it by 3 there will be 3 case ->1. a%3== 0,1,2.\\nnow if you want to get any sum that divisable by 3, then its sum%3=0;\\nnow if .\\na+b+c%3==0\\n&& a+b%3=2 then c%3=1 is certain ie the reminder sum should be 0 or 3.. 3%3=0\\n\\n```\\nclass Solution {\\n\\n    public int maxSumDivThree(int[] nums) {\\n        int r0 = 0;\\n        int r1 = 0;\\n        int r2 = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int nr0 = r0;\\n            int nr1 = r1;\\n            int nr2 = r2;\\n            int a = r0 + nums[i];\\n            int b = r1 + nums[i];\\n            int c = r2 + nums[i];\\n            if (a % 3 == 0) {\\n                nr0 = Math.max(nr0, a);\\n            } else if (a % 3 == 1) {\\n                nr1 = Math.max(nr1, a);\\n            } else if (a % 3 == 2) {\\n                nr2 = Math.max(nr2, a);\\n            }\\n\\n            if (b % 3 == 0) {\\n                nr0 = Math.max(nr0, b);\\n            } else if (b % 3 == 1) {\\n                nr1 = Math.max(nr1, b);\\n            } else if (b % 3 == 2) {\\n                nr2 = Math.max(nr2, b);\\n            }\\n            \\n            if (c % 3 == 0) {\\n                nr0 = Math.max(nr0, c);\\n            } else if (c % 3 == 1) {\\n                nr1 = Math.max(nr1, c);\\n            } else if (c % 3 == 2) {\\n                nr2 = Math.max(nr2, c);\\n            }\\n            r0=nr0;\\n            r1=nr1;\\n            r2=nr2;\\n        }\\n        \\n        return r0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxSumDivThree(int[] nums) {\\n        int r0 = 0;\\n        int r1 = 0;\\n        int r2 = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int nr0 = r0;\\n            int nr1 = r1;\\n            int nr2 = r2;\\n            int a = r0 + nums[i];\\n            int b = r1 + nums[i];\\n            int c = r2 + nums[i];\\n            if (a % 3 == 0) {\\n                nr0 = Math.max(nr0, a);\\n            } else if (a % 3 == 1) {\\n                nr1 = Math.max(nr1, a);\\n            } else if (a % 3 == 2) {\\n                nr2 = Math.max(nr2, a);\\n            }\\n\\n            if (b % 3 == 0) {\\n                nr0 = Math.max(nr0, b);\\n            } else if (b % 3 == 1) {\\n                nr1 = Math.max(nr1, b);\\n            } else if (b % 3 == 2) {\\n                nr2 = Math.max(nr2, b);\\n            }\\n            \\n            if (c % 3 == 0) {\\n                nr0 = Math.max(nr0, c);\\n            } else if (c % 3 == 1) {\\n                nr1 = Math.max(nr1, c);\\n            } else if (c % 3 == 2) {\\n                nr2 = Math.max(nr2, c);\\n            }\\n            r0=nr0;\\n            r1=nr1;\\n            r2=nr2;\\n        }\\n        \\n        return r0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327947,
                "title": "python-dp",
                "content": "dp[0]: max sum which mods 3 = 0\\ndp[1]: max sum which mods 3 = 1\\ndp[2]: max sum which mods 3 = 2\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [0, float(\\'-inf\\'), float(\\'-inf\\')] \\n        for x in nums:\\n            dp_cp = dp[:]\\n            for left in range(3):\\n                right = (left + x) % 3\\n                dp[right] = max(dp_cp[right], dp_cp[left] + x)\\n            \\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = [0, float(\\'-inf\\'), float(\\'-inf\\')] \\n        for x in nums:\\n            dp_cp = dp[:]\\n            for left in range(3):\\n                right = (left + x) % 3\\n                dp[right] = max(dp_cp[right], dp_cp[left] + x)\\n            \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175452,
                "title": "tabulation-memo-c",
                "content": "```class Solution {\\npublic:\\n    #define ll long long\\n//     ll rec(int i,int k,vector<int>&nums){\\n//         if(i<0){\\n//             if(k==0)return 0;\\n//             else return INT_MIN;\\n//         }\\n//         if(dp[i][k]!=-1)return dp[i][k];\\n//         ll a=nums[i]+rec(i-1,(k+nums[i])%3,nums);\\n//         ll b=rec(i-1,k,nums);\\n        \\n//         return dp[i][k]=max(a,b);\\n//     }\\n    int maxSumDivThree(vector<int>&nums){\\n        ll n=nums.size();\\n        vector<vector<ll>>dp(n+1,vector<ll>(3,INT_MIN));\\n        dp[0][0]=0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=2;j++){\\n                ll a=nums[i-1]+dp[i-1][(j+nums[i-1])%3];\\n                ll b=dp[i-1][j];\\n                dp[i][j]=max(a,b);\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n//     ll rec(int i,int k,vector<int>&nums){\\n//         if(i<0){\\n//             if(k==0)return 0;\\n//             else return INT_MIN;\\n//         }",
                "codeTag": "Java"
            },
            {
                "id": 2104456,
                "title": "dp-but-less-confusing-essentially-using-just-3-variables",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int[] dp = new int[3]; // index for each of the type of remainder we can get when divide a number by 3\\n        for (int i = 0; i < nums.length;i++) {\\n            \\n            //3 possible remainders are 0,1,2\\n            // array indices indicate the remainders\\n            // add the current number to each of the value in dp[index]\\n            // take the remainder of the new sum against those 3 numbers \\n            int threes = dp[0] + nums[i];\\n            int ones = dp[1] + nums[i];\\n            int twos = dp[2] + nums[i];\\n            // if the existing value against sum%3 is lesser then copy that number.\\n            if(threes > dp[threes%3]) dp[threes%3] = threes;\\n            if(ones > dp[ones%3]) dp[ones%3] = ones;\\n            if(twos > dp[twos%3]) dp[twos%3] = twos;\\n        }\\n        //finally we are asked to produce the max sum divisible by 3.\\n        return dp[0];\\n        //if we were asked to produce max sum with remainder 1 then dp[1] or \\n        //if we are asked about 2 remainder than dp[2] will be the values to be returned.\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int[] dp = new int[3]; // index for each of the type of remainder we can get when divide a number by 3\\n        for (int i = 0; i < nums.length;i++) {\\n            \\n            //3 possible remainders are 0,1,2\\n            // array indices indicate the remainders\\n            // add the current number to each of the value in dp[index]\\n            // take the remainder of the new sum against those 3 numbers \\n            int threes = dp[0] + nums[i];\\n            int ones = dp[1] + nums[i];\\n            int twos = dp[2] + nums[i];\\n            // if the existing value against sum%3 is lesser then copy that number.\\n            if(threes > dp[threes%3]) dp[threes%3] = threes;\\n            if(ones > dp[ones%3]) dp[ones%3] = ones;\\n            if(twos > dp[twos%3]) dp[twos%3] = twos;\\n        }\\n        //finally we are asked to produce the max sum divisible by 3.\\n        return dp[0];\\n        //if we were asked to produce max sum with remainder 1 then dp[1] or \\n        //if we are asked about 2 remainder than dp[2] will be the values to be returned.\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966731,
                "title": "python",
                "content": "\\n    def maxSumDivThree(self, nums):\\n        n = len(nums)\\n        \\n        dp = [[0]*3 for _ in range(n)]\\n        \\n        if nums[0]%3 == 0:\\n            dp[0][0] = nums[0]\\n        elif nums[0]%3 == 1:\\n            dp[0][1] = nums[0]\\n        else:\\n            dp[0][2] = nums[0]\\n            \\n        for i in range(1,n):\\n            x = dp[i-1][0] + nums[i]\\n            y = dp[i-1][1] + nums[i]\\n            z = dp[i-1][2] + nums[i]\\n            \\n            dp[i] = dp[i-1]\\n            \\n            dp[i][x%3] = max(x, dp[i][x%3])\\n            dp[i][y%3] = max(y, dp[i][y%3])\\n            dp[i][z%3] = max(z, dp[i][z%3])\\n            \\n        return dp[n-1][0]",
                "solutionTags": [],
                "code": "\\n    def maxSumDivThree(self, nums):\\n        n = len(nums)\\n        \\n        dp = [[0]*3 for _ in range(n)]\\n        \\n        if nums[0]%3 == 0:\\n            dp[0][0] = nums[0]\\n        elif nums[0]%3 == 1:\\n            dp[0][1] = nums[0]\\n        else:\\n            dp[0][2] = nums[0]\\n            \\n        for i in range(1,n):\\n            x = dp[i-1][0] + nums[i]\\n            y = dp[i-1][1] + nums[i]\\n            z = dp[i-1][2] + nums[i]\\n            \\n            dp[i] = dp[i-1]\\n            \\n            dp[i][x%3] = max(x, dp[i][x%3])\\n            dp[i][y%3] = max(y, dp[i][y%3])\\n            dp[i][z%3] = max(z, dp[i][z%3])\\n            \\n        return dp[n-1][0]",
                "codeTag": "Python3"
            },
            {
                "id": 1756168,
                "title": "o-n-time-begineer-friendly-solution-c-solution",
                "content": "````\\nint maxSumDivThree(vector<int>& nums) {\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        if(sum%3==0)\\n        return sum;\\n        else\\n        {\\n          vector<int> p,q,r;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n            if(nums[i]%3==0) r.push_back(nums[i]);\\n            else if(nums[i]%3==1) p.push_back(nums[i]);\\n            else q.push_back(nums[i]);\\n          }\\n          sort(p.begin(),p.end());\\n          sort(q.begin(),q.end());\\n          sort(r.begin(),r.end());\\n          if(sum%3==1)\\n          {\\n            if(p.empty())\\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=q.size();\\n              g%=3;\\n              for(int i=q.size()-1;i>=g;i--)\\n              temp+=q[i];\\n              return temp;\\n            }\\n            else \\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=q.size();\\n              g%=3;\\n              for(int i=q.size()-1;i>=g;i--)\\n              temp+=q[i];\\n              int res=sum;\\n              if(q.size()>=2) res-=(q[0]+q[1]);\\n              else res=0;\\n              return max({temp,sum-p[0],res});\\n            }\\n          }\\n          else\\n          {\\n            if(q.empty())\\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=p.size();\\n              g%=3;\\n              for(int i=p.size()-1;i>=g;i--)\\n              temp+=p[i];\\n              return temp;\\n            }\\n            else \\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=p.size();\\n              g%=3;\\n              for(int i=p.size()-1;i>=g;i--)\\n              temp+=p[i];\\n              int res=sum;\\n              if(p.size()>=2) res-=(p[0]+p[1]);\\n              else res=0;\\n              return max({temp,sum-q[0],res});\\n            }\\n          }\\n        }\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "````\\nint maxSumDivThree(vector<int>& nums) {\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        if(sum%3==0)\\n        return sum;\\n        else\\n        {\\n          vector<int> p,q,r;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n            if(nums[i]%3==0) r.push_back(nums[i]);\\n            else if(nums[i]%3==1) p.push_back(nums[i]);\\n            else q.push_back(nums[i]);\\n          }\\n          sort(p.begin(),p.end());\\n          sort(q.begin(),q.end());\\n          sort(r.begin(),r.end());\\n          if(sum%3==1)\\n          {\\n            if(p.empty())\\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=q.size();\\n              g%=3;\\n              for(int i=q.size()-1;i>=g;i--)\\n              temp+=q[i];\\n              return temp;\\n            }\\n            else \\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=q.size();\\n              g%=3;\\n              for(int i=q.size()-1;i>=g;i--)\\n              temp+=q[i];\\n              int res=sum;\\n              if(q.size()>=2) res-=(q[0]+q[1]);\\n              else res=0;\\n              return max({temp,sum-p[0],res});\\n            }\\n          }\\n          else\\n          {\\n            if(q.empty())\\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=p.size();\\n              g%=3;\\n              for(int i=p.size()-1;i>=g;i--)\\n              temp+=p[i];\\n              return temp;\\n            }\\n            else \\n            {\\n              int temp=accumulate(r.begin(),r.end(),0);\\n              int g=p.size();\\n              g%=3;\\n              for(int i=p.size()-1;i>=g;i--)\\n              temp+=p[i];\\n              int res=sum;\\n              if(p.size()>=2) res-=(p[0]+p[1]);\\n              else res=0;\\n              return max({temp,sum-q[0],res});\\n            }\\n          }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1744087,
                "title": "c-dynamic-programming-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    int recurr(vector<int>&nums, int i, int len, int sum, vector<vector<int>>&dp,int mod)\\n    {\\n        \\n        if(i >= len)\\n        {\\n          \\n           if(mod%3 == 0)\\n           {\\n               return 0;\\n           }\\n            return INT_MIN;\\n        }\\n       if(dp[i][mod] != 0)\\n        {\\n         \\n           return dp[i][mod];\\n       }\\n    \\n       int a = nums[i] + recurr(nums, i+1, len, sum+nums[i], dp, (mod+nums[i])%3);\\n       int b = recurr(nums, i+1, len, sum,dp,mod);\\n       return dp[i][mod] = max(a,b);\\n        \\n    }\\npublic:\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<vector<int>>dp(nums.size(), vector<int>(3,0));\\n       int a = recurr(nums,0,nums.size(),0,dp,0);\\n        return a;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int recurr(vector<int>&nums, int i, int len, int sum, vector<vector<int>>&dp,int mod)\\n    {\\n        \\n        if(i >= len)\\n        {\\n          \\n           if(mod%3 == 0)\\n           {\\n               return 0;\\n           }\\n            return INT_MIN;\\n        }\\n       if(dp[i][mod] != 0)\\n        {\\n         \\n           return dp[i][mod];\\n       }\\n    \\n       int a = nums[i] + recurr(nums, i+1, len, sum+nums[i], dp, (mod+nums[i])%3);\\n       int b = recurr(nums, i+1, len, sum,dp,mod);\\n       return dp[i][mod] = max(a,b);\\n        \\n    }\\npublic:\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<vector<int>>dp(nums.size(), vector<int>(3,0));\\n       int a = recurr(nums,0,nums.size(),0,dp,0);\\n        return a;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620607,
                "title": "java-o-1-space-one-pass-10-lines-comments",
                "content": "Let `dp[0]` be the largest sum up to a given index that is divisible by 3, `dp[1]` be largest sum up to a given index that has the form of `3n + 1`, and `dp[2]` be the largest sum up to a given index that has the form of `3n + 2`, then we have the following reocurring relationship `dp[i] = Math.max(dp[i], dp[complement] + nums[i]`. \\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n        dp[nums[0] % 3] = nums[0]; //base case\\n\\n        for (int i = 1; i < nums.length; i++){\\n            int complement = nums[i] % 3 == 0? 0 : 3 - nums[i] % 3; //complement idx \\n            int zero = Math.max(dp[0], dp[complement] + nums[i]); // reoccuring relationship\\n            int one  = Math.max(dp[1], dp[++complement % 3] + nums[i]);\\n            int two  = Math.max(dp[2], dp[++complement % 3] + nums[i]);\\n            dp[0] = zero;\\n\\t\\t\\t//dp[1] and dp[2] initializtion may not be %3 == 1 and %3 == 2 respectively, so we need to check.\\n            dp[1] = one % 3 == 1? one : dp[1]; \\n            dp[2] = two % 3 == 2? two : dp[2];\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[] dp = new int[3];\\n        dp[nums[0] % 3] = nums[0]; //base case\\n\\n        for (int i = 1; i < nums.length; i++){\\n            int complement = nums[i] % 3 == 0? 0 : 3 - nums[i] % 3; //complement idx \\n            int zero = Math.max(dp[0], dp[complement] + nums[i]); // reoccuring relationship\\n            int one  = Math.max(dp[1], dp[++complement % 3] + nums[i]);\\n            int two  = Math.max(dp[2], dp[++complement % 3] + nums[i]);\\n            dp[0] = zero;\\n\\t\\t\\t//dp[1] and dp[2] initializtion may not be %3 == 1 and %3 == 2 respectively, so we need to check.\\n            dp[1] = one % 3 == 1? one : dp[1]; \\n            dp[2] = two % 3 == 2? two : dp[2];\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606617,
                "title": "dp-or-not-dp-that-is-the-question",
                "content": "**Iterative**\\n**time:** `O(N)`; **space:** `O(1)`\\n\\nIn this solution I maintain two least numbers in an array that have remainder `1` modulo `3` and two least numbers that have remainder `2` modulo `3`.\\nActually this is done using `dp`\\'ish algo (as it is done step by step using previously obtained two least numbers) but this algo is different from [lee215](https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space)\\'s `dp` solution.\\n```\\nint maxSumDivThree(vector<int>& n)\\n{\\n\\tint out{}, m1{10000}, mm1{10001}, m2{10000}, mm2{10001};\\n\\tfor(const auto & i : n)\\n\\t{\\n\\t\\tout += i;\\n\\t\\tif(i%3==1)\\n\\t\\t\\tmm1 = i<=m1 ? exchange(m1,i) : i<mm1 ? i : mm1;\\n\\t\\telse if(i%3==2)\\n\\t\\t\\tmm2 = i<=m2 ? exchange(m2,i) : i<mm2 ? i : mm2;\\n\\t}\\n\\treturn out -= out%3==1 ? min(m1, mm2+m2) : out%3==2 ? min(m2, mm1+m1) : 0;\\n}\\n```\\n\\n**Explanation**\\n\\nSum up all the numbers and determine two least numbers equal `1 mod 3` and two least numbers equal `2 mod 3`. If the total sum is `1 mod 3` you should substract either the least `1 mod 3` number or two least `2 mod 3` numbers. If the total sum is `1 mod 3` you should substract either the least `2 mod 3` number or two least `1 mod 3` numbers.\\nNote, that\\n```mm1 = i<=m1 ? exchange(m1,i) : i<mm1 ? i : mm1;```\\nand \\n```mm2 = i<=m2 ? exchange(m2,i) : i<mm2 ? i : mm2;```\\ncalculate the aforementioned two least numbers using `exchange` magic.\\n\\n**Notation**\\n\\n`m1` - least number that is `1 mod 3`;\\n`mm1` - second to least number that is `1 mod 3`;\\n`m2` - least number that is `2 mod 3`;\\n`mm2` - second to least number that is `2 mod 3`.\\n\\n**[lee215](https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space)\\'s solution**\\n**time:** `O(N)`; **space:** `O(1)`\\n```\\nint maxSumDivThree(vector<int>& A)\\n{\\n\\tint dp[3]{}, t[3]{};\\n\\tfor(const int & a : A)\\n\\t\\tfor(copy(begin(dp), end(dp), begin(t)); const int & i : t)\\n\\t\\t\\tdp[(i+a)%3] = max(dp[(i+a)%3], i+a);\\n\\treturn dp[0];\\n}\\n```\\n**Notation**\\n\\n`dp[0]` - largest sum that is `0 mod 3`;\\n`dp[1]` - largest sum that is `1 mod 3`;\\n`dp[2]` - largest sum  that is `2 mod 3`.\\n\\nIn order to find the best `0 mod 3` sum at the end we need to track the best sums of three  `modulo 3` categories\\n* best `0 mod 3` sum (naturally);\\n* best `1 mod 3` sum;\\n* best `2 mod 3` sum.\\n\\nWe should consider new element \"added\" to each of the \"best sums\".\\n\\n![image](https://assets.leetcode.com/users/images/54b3d9bd-a2b9-4ed1-a50a-90ae31c08d02_1638444975.8460197.png)\\n\\nAnd each of them *can* become the best sum of another (or the same) `modulo 3` category.\\n\\n![image](https://assets.leetcode.com/users/images/cf735d65-3e8d-4c88-905a-20914f9c66a7_1638444811.8744032.png)\\n\\nSo we should find out which of this possibilities happens to maintain the best sums.\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxSumDivThree(vector<int>& n)\\n{\\n\\tint out{}, m1{10000}, mm1{10001}, m2{10000}, mm2{10001};\\n\\tfor(const auto & i : n)\\n\\t{\\n\\t\\tout += i;\\n\\t\\tif(i%3==1)\\n\\t\\t\\tmm1 = i<=m1 ? exchange(m1,i) : i<mm1 ? i : mm1;\\n\\t\\telse if(i%3==2)\\n\\t\\t\\tmm2 = i<=m2 ? exchange(m2,i) : i<mm2 ? i : mm2;\\n\\t}\\n\\treturn out -= out%3==1 ? min(m1, mm2+m2) : out%3==2 ? min(m2, mm1+m1) : 0;\\n}\\n```\n```mm1 = i<=m1 ? exchange(m1,i) : i<mm1 ? i : mm1;```\n```mm2 = i<=m2 ? exchange(m2,i) : i<mm2 ? i : mm2;```\n```\\nint maxSumDivThree(vector<int>& A)\\n{\\n\\tint dp[3]{}, t[3]{};\\n\\tfor(const int & a : A)\\n\\t\\tfor(copy(begin(dp), end(dp), begin(t)); const int & i : t)\\n\\t\\t\\tdp[(i+a)%3] = max(dp[(i+a)%3], i+a);\\n\\treturn dp[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582424,
                "title": "simple-c-recursive-memoization",
                "content": "**Plz upvote if u liked it**\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[40001][3];\\n    int helper(vector<int>& nums,int ind,int rem){\\n        if(ind>=nums.size()){\\n            return rem?INT_MIN:0;\\n        }\\n        if(dp[ind][rem]!=-1){\\n            return dp[ind][rem];\\n        }\\n        return dp[ind][rem]= max(nums[ind]+helper(nums,ind+1,(rem+nums[ind])%3),helper(nums,ind+1,rem));\\n        \\n    }\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return helper(nums,0,0);\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[40001][3];\\n    int helper(vector<int>& nums,int ind,int rem){\\n        if(ind>=nums.size()){\\n            return rem?INT_MIN:0;\\n        }\\n        if(dp[ind][rem]!=-1){\\n            return dp[ind][rem];\\n        }\\n        return dp[ind][rem]= max(nums[ind]+helper(nums,ind+1,(rem+nums[ind])%3),helper(nums,ind+1,rem));\\n        \\n    }\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return helper(nums,0,0);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579311,
                "title": "java-dp-approach",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] dp = new int[nums.length+1][3];\\n        dp[0][1] = Integer.MIN_VALUE;\\n        dp[0][2] = Integer.MIN_VALUE;\\n        \\n        for(int i = 1; i < dp.length; i++) {\\n            int mod = nums[i-1] % 3;\\n            if(mod == 0) {\\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][0] + nums[i-1]);\\n                dp[i][1] = Math.max(dp[i-1][1], dp[i-1][1] + nums[i-1]);\\n                dp[i][2] = Math.max(dp[i-1][2], dp[i-1][2] + nums[i-1]);\\n            } else if(mod == 1) {\\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2] + nums[i-1]);\\n                dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + nums[i-1]);\\n                dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + nums[i-1]);\\n            } else {\\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + nums[i-1]);\\n                dp[i][1] = Math.max(dp[i-1][1], dp[i-1][2] + nums[i-1]);\\n                dp[i][2] = Math.max(dp[i-1][2], dp[i-1][0] + nums[i-1]);\\n            }\\n        }\\n        \\n        return dp[nums.length][0];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int[][] dp = new int[nums.length+1][3];\\n        dp[0][1] = Integer.MIN_VALUE;\\n        dp[0][2] = Integer.MIN_VALUE;\\n        \\n        for(int i = 1; i < dp.length; i++) {\\n            int mod = nums[i-1] % 3;\\n            if(mod == 0) {\\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][0] + nums[i-1]);\\n                dp[i][1] = Math.max(dp[i-1][1], dp[i-1][1] + nums[i-1]);\\n                dp[i][2] = Math.max(dp[i-1][2], dp[i-1][2] + nums[i-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1566374,
                "title": "c-one-pass-solution-maths-100-runtime-maths-easy-to-understand",
                "content": "\\nSimply calculating the sum of array and checking if sum%3==0.If it is not it is would be either 1 or 2.\\nSo if it is 1 we remove min(min number with n%3==1,sum of 2 min number with n%3==2)\\nSo if it is 2 we remove min(min number with n%3==2,sum of 2 min number with n%3==1)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) \\n\\t{\\n        long int sum=0,min11=INT_MAX,min12=INT_MAX,min21=INT_MAX,min22=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(nums[i]%3==1)\\n            {\\n                if(min11>nums[i])\\n                {\\n                    min12=min11;\\n                    min11=nums[i];\\n                }\\n                else if(min12>nums[i])\\n                    min12=nums[i];\\n            }\\n            else if(nums[i]%3==2)\\n            {\\n                if(min21>nums[i])\\n                {\\n                    min22=min21;\\n                    min21=nums[i];\\n                }\\n                else if(min22>nums[i])\\n                    min22=nums[i];\\n            }\\n        }\\n        if(sum%3==0)\\n            return sum;\\n         else if(sum%3==1)\\n            return sum-min(min11,min21+min22)\\n         else\\n            return sum-min(min21,min11+min12);\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) \\n\\t{\\n        long int sum=0,min11=INT_MAX,min12=INT_MAX,min21=INT_MAX,min22=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(nums[i]%3==1)\\n            {\\n                if(min11>nums[i])\\n                {\\n                    min12=min11;\\n                    min11=nums[i];\\n                }\\n                else if(min12>nums[i])\\n                    min12=nums[i];\\n            }\\n            else if(nums[i]%3==2)\\n            {\\n                if(min21>nums[i])\\n                {\\n                    min22=min21;\\n                    min21=nums[i];\\n                }\\n                else if(min22>nums[i])\\n                    min22=nums[i];\\n            }\\n        }\\n        if(sum%3==0)\\n            return sum;\\n         else if(sum%3==1)\\n            return sum-min(min11,min21+min22)\\n         else\\n            return sum-min(min21,min11+min12);\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486029,
                "title": "c-solution-time-o-n-space-o-k-where-the-sum-needs-to-be-divisible-by-k-here-k-is-3",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int dpp[3] = {0,-1,-1}, dp[3] = {0,-1,-1};\\n\\n        for (int i = 0; i <  nums.size(); ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                if (dp[j] >= 0) {\\n                    int sum = dp[j]+nums[i];\\n                    dpp[sum%3] = max(dpp[sum%3], sum);\\n                }\\n            }\\n            memcpy(dp, dpp, 3*sizeof(int));\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int dpp[3] = {0,-1,-1}, dp[3] = {0,-1,-1};\\n\\n        for (int i = 0; i <  nums.size(); ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                if (dp[j] >= 0) {\\n                    int sum = dp[j]+nums[i];\\n                    dpp[sum%3] = max(dpp[sum%3], sum);\\n                }\\n            }\\n            memcpy(dp, dpp, 3*sizeof(int));\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472330,
                "title": "every-positive-number-increases-sum-of-either-modulo-0-1-or-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(3,0);\\n        int x,y,z;\\n        for(int i=0; i<n; i++) {\\n            x = dp[0] + arr[i];\\n            y = dp[1] + arr[i];\\n            z = dp[2] + arr[i];\\n            dp[x%3] = max(dp[x%3], x);\\n            dp[y%3] = max(dp[y%3], y);\\n            dp[z%3] = max(dp[z%3], z);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(3,0);\\n        int x,y,z;\\n        for(int i=0; i<n; i++) {\\n            x = dp[0] + arr[i];\\n            y = dp[1] + arr[i];\\n            z = dp[2] + arr[i];\\n            dp[x%3] = max(dp[x%3], x);\\n            dp[y%3] = max(dp[y%3], y);\\n            dp[z%3] = max(dp[z%3], z);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469858,
                "title": "math-sort",
                "content": "Divisibility rule of 3: sum of digits should be divisible by 3\\n\\nIf sum of digits gives a remainder of 1: We need to remove the smallest number which gives the remainder of 1\\n\\nIf sum of digits gives a remainder of 2: We need to remove the smallest number which gives the remainder of 2\\n\\nEdge case: [2,6,2,2,7]\\nIn this case, the smallest number which gives remainder of 1 is 7\\nBut, there is sum of numbers lesser than 7 which gives remainder 1\\n(2+2 = 4, 4%3=1) \\n\\nSo, we need to look for the min value\\n\\n\\t\\ta.sort()\\n        total = sum(a)\\n        ones = [i for i in a if i%3==1]\\n        twos = [i for i in a if i%3==2]\\n        \\n        if total%3==1:\\n            one,two = math.inf,math.inf\\n            if ones: \\n                one = ones[0] \\n            if len(twos) > 1: \\n                two = twos[0] + twos[1] \\n            return total-min(one,two)\\n                \\n        elif total%3==2:\\n            one,two = math.inf,math.inf\\n            if twos: \\n                two = twos[0] \\n            if len(ones) > 1: \\n                one = ones[0] + ones[1] \\n            return total-min(one,two)  \\n        \\n        else:\\n            return sum(a)",
                "solutionTags": [],
                "code": "Divisibility rule of 3: sum of digits should be divisible by 3\\n\\nIf sum of digits gives a remainder of 1: We need to remove the smallest number which gives the remainder of 1\\n\\nIf sum of digits gives a remainder of 2: We need to remove the smallest number which gives the remainder of 2\\n\\nEdge case: [2,6,2,2,7]\\nIn this case, the smallest number which gives remainder of 1 is 7\\nBut, there is sum of numbers lesser than 7 which gives remainder 1\\n(2+2 = 4, 4%3=1) \\n\\nSo, we need to look for the min value\\n\\n\\t\\ta.sort()\\n        total = sum(a)\\n        ones = [i for i in a if i%3==1]\\n        twos = [i for i in a if i%3==2]\\n        \\n        if total%3==1:\\n            one,two = math.inf,math.inf\\n            if ones: \\n                one = ones[0] \\n            if len(twos) > 1: \\n                two = twos[0] + twos[1] \\n            return total-min(one,two)\\n                \\n        elif total%3==2:\\n            one,two = math.inf,math.inf\\n            if twos: \\n                two = twos[0] \\n            if len(ones) > 1: \\n                one = ones[0] + ones[1] \\n            return total-min(one,two)  \\n        \\n        else:\\n            return sum(a)",
                "codeTag": "Unknown"
            },
            {
                "id": 1326520,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum = 0;\\n        vector<int>ta;\\n        vector<int>pc;\\n        for(int i:nums){\\n            sum+=i;\\n            if(i%3 == 1){\\n                ta.push_back(i);\\n            }\\n            else if(i%3 == 2){\\n                pc.push_back(i);\\n            }\\n        }\\n        sort(ta.begin(),ta.end());\\n        sort(pc.begin(),pc.end());\\n        if(sum%3 == 0){\\n            return sum;\\n        }\\n        else if(sum%3 == 1){\\n            if(pc.size()>=2)\\n                return max(sum-ta[0],sum-pc[0]-pc[1]);\\n            return sum-ta[0];\\n        }\\n        if(ta.size()>=2)\\n            return max(sum-pc[0],sum-ta[0]-ta[1]);\\n        return sum-pc[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int sum = 0;\\n        vector<int>ta;\\n        vector<int>pc;\\n        for(int i:nums){\\n            sum+=i;\\n            if(i%3 == 1){\\n                ta.push_back(i);\\n            }\\n            else if(i%3 == 2){\\n                pc.push_back(i);\\n            }\\n        }\\n        sort(ta.begin(),ta.end());\\n        sort(pc.begin(),pc.end());\\n        if(sum%3 == 0){\\n            return sum;\\n        }\\n        else if(sum%3 == 1){\\n            if(pc.size()>=2)\\n                return max(sum-ta[0],sum-pc[0]-pc[1]);\\n            return sum-ta[0];\\n        }\\n        if(ta.size()>=2)\\n            return max(sum-pc[0],sum-ta[0]-ta[1]);\\n        return sum-pc[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318421,
                "title": "o-n-time-complexity-and-o-1-auxiliary-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxi = 99999999;\\n    int maxSumDivThree(vector<int>& nums) {\\n        int one1=maxi, one2=maxi, two1=maxi, two2=maxi; //Variables to track two smallest 3k+1, 3k+2 numbers; \\n        int ans = 0;\\n        if(nums.size()==1 && nums[0]%3) return 0;\\n        for(int i=0;i<nums.size(); i++){\\n            ans+= nums[i];\\n            switch(nums[i]%3){   \\n                case 1:\\n                one2 = min(one2, nums[i]);\\n                if(one2 < one1) swap(one1, one2);\\n                break;\\n            \\n                case 2:\\n                two2 = min(two2, nums[i]);\\n                if(two2 < two1) swap(two1, two2);\\n                break;  \\n            }\\n        }\\n        \\n        if(ans%3==0) return ans;\\n        \\n        if(ans%3 == 1) ans-=min(one1, two1+two2);\\n        \\n        else ans-=min(two1, one1+one2);\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi = 99999999;\\n    int maxSumDivThree(vector<int>& nums) {\\n        int one1=maxi, one2=maxi, two1=maxi, two2=maxi; //Variables to track two smallest 3k+1, 3k+2 numbers; \\n        int ans = 0;\\n        if(nums.size()==1 && nums[0]%3) return 0;\\n        for(int i=0;i<nums.size(); i++){\\n            ans+= nums[i];\\n            switch(nums[i]%3){   \\n                case 1:\\n                one2 = min(one2, nums[i]);\\n                if(one2 < one1) swap(one1, one2);\\n                break;\\n            \\n                case 2:\\n                two2 = min(two2, nums[i]);\\n                if(two2 < two1) swap(two1, two2);\\n                break;  \\n            }\\n        }\\n        \\n        if(ans%3==0) return ans;\\n        \\n        if(ans%3 == 1) ans-=min(one1, two1+two2);\\n        \\n        else ans-=min(two1, one1+one2);\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305234,
                "title": "recursion-and-tabulation-knapsack-subsequence-dp-template-suffix-dp",
                "content": "```\\nclass Solution:\\n    def maxSumDivThreeTopDown(self, nums: List[int]) -> int:\\n        # normal knapsack/subsequence dp\\n        # at each position, pick OR don\\'t pick...\\n        # also keep 3 different states for each remainder\\n        @functools.cache\\n        def dp(i, remainder): \\n            if i == len(nums):\\n                if remainder:\\n                    return -math.inf \\n                else: \\n                    return 0\\n            \\n            # don\\'t pick me\\n            skip = dp(i+1, remainder)\\n            \\n            # pick me\\n            pick = nums[i] + dp(i+1, (remainder + nums[i])%3)\\n            \\n            return max(pick, skip)\\n        return dp(0,0)\\n    # how to convert it into bottom up?\\n    \\n    # just convert brackets into square brackets ;)\\n    \\n    # and loop backwards since all `i` depends on `i+1`\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        # base case is 0, -inf, -inf\\n        dp = [[0,-math.inf, -math.inf] for i in range(len(nums)+1)]\\n        \\n        for i in range(len(nums)-1,-1,-1): # i = , i != , +=\\n            for rem in range(3):\\n                val = nums[i]\\n                \\n                # don\\'t pick  \\n                skip = dp[i+1][rem]\\n                \\n                # pick me...\\n                pick = val + dp[i+1][(rem+val)%3]\\n\\n                dp[i][rem] = max(pick, skip)\\n        \\n        return dp[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThreeTopDown(self, nums: List[int]) -> int:\\n        # normal knapsack/subsequence dp\\n        # at each position, pick OR don\\'t pick...\\n        # also keep 3 different states for each remainder\\n        @functools.cache\\n        def dp(i, remainder): \\n            if i == len(nums):\\n                if remainder:\\n                    return -math.inf \\n                else: \\n                    return 0\\n            \\n            # don\\'t pick me\\n            skip = dp(i+1, remainder)\\n            \\n            # pick me\\n            pick = nums[i] + dp(i+1, (remainder + nums[i])%3)\\n            \\n            return max(pick, skip)\\n        return dp(0,0)\\n    # how to convert it into bottom up?\\n    \\n    # just convert brackets into square brackets ;)\\n    \\n    # and loop backwards since all `i` depends on `i+1`\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        # base case is 0, -inf, -inf\\n        dp = [[0,-math.inf, -math.inf] for i in range(len(nums)+1)]\\n        \\n        for i in range(len(nums)-1,-1,-1): # i = , i != , +=\\n            for rem in range(3):\\n                val = nums[i]\\n                \\n                # don\\'t pick  \\n                skip = dp[i+1][rem]\\n                \\n                # pick me...\\n                pick = val + dp[i+1][(rem+val)%3]\\n\\n                dp[i][rem] = max(pick, skip)\\n        \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304538,
                "title": "java-min-heap-greedy",
                "content": "```\\n\\n    public int maxSumDivThree(int[] nums) {\\n        PriorityQueue<Integer> minHeap1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> minHeap2 = new PriorityQueue<>();\\n\\n        Arrays.stream(nums).boxed().filter(t -> t % 3 == 1).forEach(minHeap1::add);\\n        Arrays.stream(nums).boxed().filter(t -> t % 3 == 2).forEach(minHeap2::add);\\n\\n        int sum = Arrays.stream(nums).boxed().reduce(Integer::sum).get();\\n        int sum0 = Arrays.stream(nums).boxed().filter(t -> t % 3 == 0).reduce(Integer::sum).orElse(0);\\n\\n        while (sum % 3 != 0) {\\n            if (sum % 3 == 1) {\\n                if (!minHeap1.isEmpty()) {\\n                    if (minHeap2.size() > 1) {\\n                        int t1 = minHeap2.poll();\\n                        int t2 = minHeap2.poll();\\n                        if (t1 + t2 < minHeap1.peek()) {\\n                            sum = sum - t1 - t2;\\n                        } else {\\n                            sum = sum - minHeap1.poll();\\n                            minHeap2.add(t1);\\n                            minHeap2.add(t2);\\n                        }\\n                    } else {\\n                        sum = sum - minHeap1.poll();\\n                    }\\n                } else if (minHeap1.isEmpty() && minHeap2.size() < 2)\\n                    return sum0;\\n                else {\\n                    sum = sum - minHeap2.poll() - minHeap2.poll();\\n                }\\n            } else if (sum % 3 == 2) {\\n                if (!minHeap2.isEmpty()) {\\n                    if (minHeap1.size() > 1) {\\n                        int t1 = minHeap1.poll();\\n                        int t2 = minHeap1.poll();\\n                        if (t1 + t2 < minHeap2.peek()) {\\n                            sum = sum - t1 - t2;\\n                        } else {\\n                            sum = sum - minHeap2.poll();\\n                            minHeap1.add(t1);\\n                            minHeap1.add(t2);\\n                        }\\n                    } else {\\n                        sum = sum - minHeap2.poll();\\n                    }\\n                } else if (minHeap2.isEmpty() && minHeap1.size() < 2)\\n                    return sum0;\\n                else {\\n                    sum = sum - minHeap1.poll() - minHeap1.poll();\\n                }\\n            }\\n        }\\n        return sum;\\n\\n    }\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public int maxSumDivThree(int[] nums) {\\n        PriorityQueue<Integer> minHeap1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> minHeap2 = new PriorityQueue<>();\\n\\n        Arrays.stream(nums).boxed().filter(t -> t % 3 == 1).forEach(minHeap1::add);\\n        Arrays.stream(nums).boxed().filter(t -> t % 3 == 2).forEach(minHeap2::add);\\n\\n        int sum = Arrays.stream(nums).boxed().reduce(Integer::sum).get();\\n        int sum0 = Arrays.stream(nums).boxed().filter(t -> t % 3 == 0).reduce(Integer::sum).orElse(0);\\n\\n        while (sum % 3 != 0) {\\n            if (sum % 3 == 1) {\\n                if (!minHeap1.isEmpty()) {\\n                    if (minHeap2.size() > 1) {\\n                        int t1 = minHeap2.poll();\\n                        int t2 = minHeap2.poll();\\n                        if (t1 + t2 < minHeap1.peek()) {\\n                            sum = sum - t1 - t2;\\n                        } else {\\n                            sum = sum - minHeap1.poll();\\n                            minHeap2.add(t1);\\n                            minHeap2.add(t2);\\n                        }\\n                    } else {\\n                        sum = sum - minHeap1.poll();\\n                    }\\n                } else if (minHeap1.isEmpty() && minHeap2.size() < 2)\\n                    return sum0;\\n                else {\\n                    sum = sum - minHeap2.poll() - minHeap2.poll();\\n                }\\n            } else if (sum % 3 == 2) {\\n                if (!minHeap2.isEmpty()) {\\n                    if (minHeap1.size() > 1) {\\n                        int t1 = minHeap1.poll();\\n                        int t2 = minHeap1.poll();\\n                        if (t1 + t2 < minHeap2.peek()) {\\n                            sum = sum - t1 - t2;\\n                        } else {\\n                            sum = sum - minHeap2.poll();\\n                            minHeap1.add(t1);\\n                            minHeap1.add(t2);\\n                        }\\n                    } else {\\n                        sum = sum - minHeap2.poll();\\n                    }\\n                } else if (minHeap2.isEmpty() && minHeap1.size() < 2)\\n                    return sum0;\\n                else {\\n                    sum = sum - minHeap1.poll() - minHeap1.poll();\\n                }\\n            }\\n        }\\n        return sum;\\n\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291204,
                "title": "c-clean-and-concise-dp-solution-easy-to-understand",
                "content": "Please upvote if it helps you!\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& a) {\\n        int n=a.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        dp[0][a[0]%3] = a[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int x = dp[i-1][0]+a[i];\\n            int y = dp[i-1][1]+a[i];\\n            int z = dp[i-1][2]+a[i];\\n            dp[i]=dp[i-1];\\n            dp[i][x%3] = max(x,dp[i][x%3]);\\n            dp[i][y%3] = max(y,dp[i][y%3]);\\n            dp[i][z%3] = max(z,dp[i][z%3]);\\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& a) {\\n        int n=a.size();\\n        vector<vector<int>> dp(n,vector<int>(3,0));\\n        dp[0][a[0]%3] = a[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int x = dp[i-1][0]+a[i];\\n            int y = dp[i-1][1]+a[i];\\n            int z = dp[i-1][2]+a[i];\\n            dp[i]=dp[i-1];\\n            dp[i][x%3] = max(x,dp[i][x%3]);\\n            dp[i][y%3] = max(y,dp[i][y%3]);\\n            dp[i][z%3] = max(z,dp[i][z%3]);\\n        }\\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266267,
                "title": "python3-solution-using-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = []\\n        for i in range(3):\\n            z = []\\n            for j in range(len(nums)):\\n                z.append(0)\\n            dp.append(z)\\n        dp[nums[0]%3][0] = nums[0]\\n        for i in range(1,len(nums)):\\n            for j in range(3):\\n                x = dp[j][i-1] + nums[i]\\n                dp[x%3][i] = max([dp[x%3][i], x, dp[x%3][i-1]])\\n                dp[j][i] = max(dp[j][i-1],dp[j][i])\\n        return dp[0][-1]\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        dp = []\\n        for i in range(3):\\n            z = []\\n            for j in range(len(nums)):\\n                z.append(0)\\n            dp.append(z)\\n        dp[nums[0]%3][0] = nums[0]\\n        for i in range(1,len(nums)):\\n            for j in range(3):\\n                x = dp[j][i-1] + nums[i]\\n                dp[x%3][i] = max([dp[x%3][i], x, dp[x%3][i-1]])\\n                dp[j][i] = max(dp[j][i-1],dp[j][i])\\n        return dp[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246664,
                "title": "c-98-easiest-and-pretty-solution-with-explanation",
                "content": "* Here dp[i] stores the minimum value of integer giving mod3 = i.\\n* if current number nums[i] is 3 mod 1 then update the dp[1] value with min between num[i] and dp[1]\\n* Also we update the dp[2] value cause 2 dp[1] value can make 1 dp[2] value EX => 1 + 1 = 2.\\n* if current number nums[i] is 3 mod 2 then update the dp[2] value with min between num[i] and dp[2]\\n* Also we update the dp[1] value cause 2 dp[2] value can make 1 dp[1] value EX => 2 + 2 = 4%3 = 1.\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int dp[3];\\n        int sum=0;\\n        \\n        dp[1]=10000;\\n        dp[2]=10000;\\n        \\n        for(int i:nums){\\n            if(i%3)\\n            {\\n                if(i%3==1) dp[2]=min(dp[2],dp[1]+i), dp[1]=min(dp[1],i);\\n                else       dp[1]=min(dp[1],dp[2]+i), dp[2]=min(dp[2],i);\\n            }\\n            sum+=i;\\n        }\\n        \\n        return sum-dp[sum%3];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int dp[3];\\n        int sum=0;\\n        \\n        dp[1]=10000;\\n        dp[2]=10000;\\n        \\n        for(int i:nums){\\n            if(i%3)\\n            {\\n                if(i%3==1) dp[2]=min(dp[2],dp[1]+i), dp[1]=min(dp[1],i);\\n                else       dp[1]=min(dp[1],dp[2]+i), dp[2]=min(dp[2],i);\\n            }\\n            sum+=i;\\n        }\\n        \\n        return sum-dp[sum%3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189916,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int> dp(3);\\n        \\n        for (int i : nums){\\n            for (int j : vector<int>(dp)) {\\n                dp[(i+j)%3] = max(dp[(i+j)%3], i+j);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        vector<int> dp(3);\\n        \\n        for (int i : nums){\\n            for (int j : vector<int>(dp)) {\\n                dp[(i+j)%3] = max(dp[(i+j)%3], i+j);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119637,
                "title": "c-dp-o-n-with-short-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        // DP: define size == nums.size() and array dp[3][size + 1] where dp[i][j + 1]\\n        // denotes the max sum modulo 3 equals i in subarray nums[0:j]. We calculate dp[i][j] accordingly\\n        // and return the final result of dp[0][size].\\n        int size = nums.size();\\n        vector<vector<int>> dp(3, vector<int>(size + 1));\\n        \\n        for (int j = 1; j <= size; ++j)\\n        {\\n            int mod = nums[j - 1] % 3;\\n            if (mod == 0) // nums[j - 1] modulo 3 == 0\\n            {\\n                dp[0][j] = nums[j - 1] + dp[0][j - 1];\\n                dp[1][j] = dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1];\\n                dp[2][j] = dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1];\\n            }\\n            else if (mod == 1) // nums[j - 1] modulo 3 == 1\\n            {\\n                dp[0][j] = max(dp[0][j - 1], dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1]);\\n                dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + nums[j - 1]);\\n                dp[2][j] = max(dp[2][j - 1], dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1]);\\n            }\\n            else // nums[j - 1] modulo 3 == 2\\n            {\\n                dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1]);\\n                dp[1][j] = max(dp[1][j - 1], dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1]);\\n                dp[2][j] = max(dp[2][j - 1], dp[0][j - 1] + nums[j - 1]);\\n            }\\n        }\\n        \\n        return dp[0][size];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        // DP: define size == nums.size() and array dp[3][size + 1] where dp[i][j + 1]\\n        // denotes the max sum modulo 3 equals i in subarray nums[0:j]. We calculate dp[i][j] accordingly\\n        // and return the final result of dp[0][size].\\n        int size = nums.size();\\n        vector<vector<int>> dp(3, vector<int>(size + 1));\\n        \\n        for (int j = 1; j <= size; ++j)\\n        {\\n            int mod = nums[j - 1] % 3;\\n            if (mod == 0) // nums[j - 1] modulo 3 == 0\\n            {\\n                dp[0][j] = nums[j - 1] + dp[0][j - 1];\\n                dp[1][j] = dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1];\\n                dp[2][j] = dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1];\\n            }\\n            else if (mod == 1) // nums[j - 1] modulo 3 == 1\\n            {\\n                dp[0][j] = max(dp[0][j - 1], dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1]);\\n                dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + nums[j - 1]);\\n                dp[2][j] = max(dp[2][j - 1], dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1]);\\n            }\\n            else // nums[j - 1] modulo 3 == 2\\n            {\\n                dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] == 0 ? 0 : dp[1][j - 1] + nums[j - 1]);\\n                dp[1][j] = max(dp[1][j - 1], dp[2][j - 1] == 0 ? 0 : dp[2][j - 1] + nums[j - 1]);\\n                dp[2][j] = max(dp[2][j - 1], dp[0][j - 1] + nums[j - 1]);\\n            }\\n        }\\n        \\n        return dp[0][size];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096108,
                "title": "easy-to-understand-python-dp",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0]*3 for _ in range(n+1)]\\n        dp[0][0] = 0\\n        dp[0][1] = float(\\'-inf\\')\\n        dp[0][2] = float(\\'-inf\\')\\n        \\n        for i in range(1,n+1):\\n            if nums[i-1]%3 ==0:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][0]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][1]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][2]+nums[i-1] )\\n            if nums[i-1]%3 ==1:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][2]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][0]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][1]+nums[i-1] )\\n            if nums[i-1]%3 ==2:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][1]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][2]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][0]+nums[i-1] )\\n        print(dp)\\n        \\n        return dp[n][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[0]*3 for _ in range(n+1)]\\n        dp[0][0] = 0\\n        dp[0][1] = float(\\'-inf\\')\\n        dp[0][2] = float(\\'-inf\\')\\n        \\n        for i in range(1,n+1):\\n            if nums[i-1]%3 ==0:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][0]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][1]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][2]+nums[i-1] )\\n            if nums[i-1]%3 ==1:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][2]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][0]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][1]+nums[i-1] )\\n            if nums[i-1]%3 ==2:\\n                dp[i][0] = max(dp[i-1][0],dp[i-1][1]+nums[i-1] )\\n                dp[i][1] = max(dp[i-1][1],dp[i-1][2]+nums[i-1] )\\n                dp[i][2] = max(dp[i-1][2],dp[i-1][0]+nums[i-1] )\\n        print(dp)\\n        \\n        return dp[n][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096013,
                "title": "python-solution-beats-99-67-with-explanation",
                "content": "* core idea is that if n%3 == 1(or 2), then for any number ni%3 == 1(or 2), (n-ni)%3 == 0\\n* Now we this question is asking us to find the minimum sum S, that S%3 == sum(nums)%3\\n* it\\'s not hard to figure out if n1%3 == n2%3 == 1, then (n1+n2)%3 == 2\\n* if n1%3 == n2%3 == 2, then (n1+n2)%3 == 1\\n\\nclass Solution:\\n\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        remainder = s%3\\n        if not remainder:\\n            return s\\n\\n        remainder1 = [float(\"inf\"),float(\"inf\")]\\n        remainder2 = [float(\"inf\"),float(\"inf\")]\\n        for n in nums: # find the remainder of the largest and second largest number that are equal to 1 and 2\\n            if n%3 == 1:\\n                if n<=remainder1[0]:\\n                    remainder1[1] = remainder1[0]\\n                    remainder1[0] = n\\n                elif n<remainder1[1]:\\n                    remainder1[1] = n\\n            if n%3 == 2:\\n                if n<=remainder2[0]:\\n                    remainder2[1] = remainder2[0]\\n                    remainder2[0] = n\\n                elif n<remainder2[1]:\\n                    remainder2[1] = n\\n\\n        if remainder == 1: # sum(remainder1)%3 == 2 and sum(remainder2)%3 == 1\\n            ans = s - min(sum(remainder2),remainder1[0])\\n        elif remainder == 2:\\n            ans = s - min(sum(remainder1),remainder2[0])\\n        return ans if ans!=float(\"inf\") else 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "* core idea is that if n%3 == 1(or 2), then for any number ni%3 == 1(or 2), (n-ni)%3 == 0\\n* Now we this question is asking us to find the minimum sum S, that S%3 == sum(nums)%3\\n* it\\'s not hard to figure out if n1%3 == n2%3 == 1, then (n1+n2)%3 == 2\\n* if n1%3 == n2%3 == 2, then (n1+n2)%3 == 1\\n\\nclass Solution:\\n\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        remainder = s%3\\n        if not remainder:\\n            return s\\n\\n        remainder1 = [float(\"inf\"),float(\"inf\")]\\n        remainder2 = [float(\"inf\"),float(\"inf\")]\\n        for n in nums: # find the remainder of the largest and second largest number that are equal to 1 and 2\\n            if n%3 == 1:\\n                if n<=remainder1[0]:\\n                    remainder1[1] = remainder1[0]\\n                    remainder1[0] = n\\n                elif n<remainder1[1]:\\n                    remainder1[1] = n\\n            if n%3 == 2:\\n                if n<=remainder2[0]:\\n                    remainder2[1] = remainder2[0]\\n                    remainder2[0] = n\\n                elif n<remainder2[1]:\\n                    remainder2[1] = n\\n\\n        if remainder == 1: # sum(remainder1)%3 == 2 and sum(remainder2)%3 == 1\\n            ans = s - min(sum(remainder2),remainder1[0])\\n        elif remainder == 2:\\n            ans = s - min(sum(remainder1),remainder2[0])\\n        return ans if ans!=float(\"inf\") else 0",
                "codeTag": "Java"
            },
            {
                "id": 1071991,
                "title": "best-java-dp-solution-and-easy-to-understand-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] a) {\\n        int n=a.length;\\n        int dp[][]=new int [n][3];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                dp[i][a[i]%3]=a[i];\\n            }else{\\n                for(int j=0;j<3;j++){\\n                    int sum=dp[i-1][j]+a[i];\\n                    dp[i][sum%3]=Math.max(dp[i][sum%3],sum);\\n                    dp[i][j]=Math.max(dp[i][j],dp[i-1][j]);\\n                }\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<3;j++){\\n        //         System.out.print(dp[i][j]+\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        return dp[n-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] a) {\\n        int n=a.length;\\n        int dp[][]=new int [n][3];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                dp[i][a[i]%3]=a[i];\\n            }else{\\n                for(int j=0;j<3;j++){\\n                    int sum=dp[i-1][j]+a[i];\\n                    dp[i][sum%3]=Math.max(dp[i][sum%3],sum);\\n                    dp[i][j]=Math.max(dp[i][j],dp[i-1][j]);\\n                }\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<3;j++){\\n        //         System.out.print(dp[i][j]+\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        return dp[n-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994280,
                "title": "simply-python-runtime-100-memory-90-48",
                "content": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        s = sum(nums)\\n        \\n        if s % 3 == 0:\\n            return s\\n        \\n        r11 = 10000\\n        r12 = 10000\\n        r21 = 10000\\n        r22 = 10000\\n        \\n        for num in nums:\\n            if num % 3 == 1 and num < r12:\\n                if num < r11:\\n                    r12 = r11\\n                    r11 = num\\n                else:\\n                    r12 = num\\n            if num % 3 == 2 and num < r22:\\n                if num < r21:\\n                    r22 = r21\\n                    r21 = num\\n                else: \\n                    r22 = num\\n        if s % 3 == 1:\\n            return s - min(r11, r21+r22)\\n        if s % 3 == 2:\\n            return s - min(r21, r11+r12)  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        s = sum(nums)\\n        \\n        if s % 3 == 0:\\n            return s\\n        \\n        r11 = 10000\\n        r12 = 10000\\n        r21 = 10000\\n        r22 = 10000\\n        \\n        for num in nums:\\n            if num % 3 == 1 and num < r12:\\n                if num < r11:\\n                    r12 = r11\\n                    r11 = num\\n                else:\\n                    r12 = num\\n            if num % 3 == 2 and num < r22:\\n                if num < r21:\\n                    r22 = r21\\n                    r21 = num\\n                else: \\n                    r22 = num\\n        if s % 3 == 1:\\n            return s - min(r11, r21+r22)\\n        if s % 3 == 2:\\n            return s - min(r21, r11+r12)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 914120,
                "title": "python-o-n-time-o-1-space-fast-beats-98",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        sums = sum(nums)\\n        if sums%3==0:\\n            return sums\\n        mods = {1:[],2:[]}\\n        for n in nums:\\n            a = n%3\\n            if a:\\n                if len(mods[a])<2:\\n                    mods[a].append(n)\\n                    mods[a].sort()\\n                elif n<mods[a][0]:\\n                    mods[a] = [n,mods[a][0]]\\n                elif n<mods[a][1]:\\n                    mods[a][1] = n\\n\\n        if sums%3 == 1:\\n            a = sum(mods[2]) if len(mods[2])==2 else 10**5\\n            b = mods[1][0] if mods[1] else 10**5\\n            return sums - min(a,b)\\n        if sums%3 == 2:\\n            a = sum(mods[1]) if len(mods[1])==2 else 10**5\\n            b = mods[2][0] if mods[2] else 10**5\\n            return sums - min(a,b)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        sums = sum(nums)\\n        if sums%3==0:\\n            return sums\\n        mods = {1:[],2:[]}\\n        for n in nums:\\n            a = n%3\\n            if a:\\n                if len(mods[a])<2:\\n                    mods[a].append(n)\\n                    mods[a].sort()\\n                elif n<mods[a][0]:\\n                    mods[a] = [n,mods[a][0]]\\n                elif n<mods[a][1]:\\n                    mods[a][1] = n\\n\\n        if sums%3 == 1:\\n            a = sum(mods[2]) if len(mods[2])==2 else 10**5\\n            b = mods[1][0] if mods[1] else 10**5\\n            return sums - min(a,b)\\n        if sums%3 == 2:\\n            a = sum(mods[1]) if len(mods[1])==2 else 10**5\\n            b = mods[2][0] if mods[2] else 10**5\\n            return sums - min(a,b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899423,
                "title": "python-o-nlogn-but-has-good-readability-and-comments",
                "content": "```\\nbased on the @TwerpApple solution\\n# O(nlogn) because of sorting in the very beginning\\n# possible to do the same without sorting in O(n) but it\\'ll probably become less readable\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        nums.sort()\\n        total_sum = sum(nums)\\n        reminder = total_sum % 3\\n        if reminder == 0:\\n            return total_sum\\n        # getting up to 2(may be 1 or none) smallest numbers with the reminder of 1\\n        # and\\n        # getting up to 2(may be 1 or none) smallest numbers with the reminder of 2\\n        num_mods = [x % 3 for x in nums]\\n        nums_with_reminder_of_one = [x[1] for x in zip(num_mods, nums) if x[0] == 1][0:2]\\n        nums_with_reminder_of_two = [x[1] for x in zip(num_mods, nums) if x[0] == 2][0:2]\\n\\n        # if the reminder of modulo  the  sum of the while nums arr is 2\\n        # we calculate two numbers:\\n        # total sum minus sum of two smallest numbers with the reminder of 1\\n        #   and the total sum minus the smallest number with the reminder of 2\\n        # Return the largest of them\\n        # Same for the case when modulo of total sum has a reminder of 1\\n        if reminder == 1:\\n            sum_1 = (total_sum - nums_with_reminder_of_one[0]) if nums_with_reminder_of_one else 0\\n            sum_2 = total_sum - sum(nums_with_reminder_of_two) if len(nums_with_reminder_of_two) == 2 else 0\\n        else:\\n            sum_1 = (total_sum - sum(nums_with_reminder_of_one)) if len(nums_with_reminder_of_one) == 2 else 0\\n            sum_2 = (total_sum - nums_with_reminder_of_two[0]) if nums_with_reminder_of_two else 0\\n\\n        return max(sum_1, sum_2)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nbased on the @TwerpApple solution\\n# O(nlogn) because of sorting in the very beginning\\n# possible to do the same without sorting in O(n) but it\\'ll probably become less readable\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        nums.sort()\\n        total_sum = sum(nums)\\n        reminder = total_sum % 3\\n        if reminder == 0:\\n            return total_sum\\n        # getting up to 2(may be 1 or none) smallest numbers with the reminder of 1\\n        # and\\n        # getting up to 2(may be 1 or none) smallest numbers with the reminder of 2\\n        num_mods = [x % 3 for x in nums]\\n        nums_with_reminder_of_one = [x[1] for x in zip(num_mods, nums) if x[0] == 1][0:2]\\n        nums_with_reminder_of_two = [x[1] for x in zip(num_mods, nums) if x[0] == 2][0:2]\\n\\n        # if the reminder of modulo  the  sum of the while nums arr is 2\\n        # we calculate two numbers:\\n        # total sum minus sum of two smallest numbers with the reminder of 1\\n        #   and the total sum minus the smallest number with the reminder of 2\\n        # Return the largest of them\\n        # Same for the case when modulo of total sum has a reminder of 1\\n        if reminder == 1:\\n            sum_1 = (total_sum - nums_with_reminder_of_one[0]) if nums_with_reminder_of_one else 0\\n            sum_2 = total_sum - sum(nums_with_reminder_of_two) if len(nums_with_reminder_of_two) == 2 else 0\\n        else:\\n            sum_1 = (total_sum - sum(nums_with_reminder_of_one)) if len(nums_with_reminder_of_one) == 2 else 0\\n            sum_2 = (total_sum - nums_with_reminder_of_two[0]) if nums_with_reminder_of_two else 0\\n\\n        return max(sum_1, sum_2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781625,
                "title": "java-98-remainder-with-comments",
                "content": "Every number is positive, we\\'ll want to use as many numbers as we can.\\n\\nSince we can choose any subsequence in the array, we\\'ll remove minimum possible numbers from `sum` to a number % by 3.\\n\\nThere are several intuitions to look out for:\\n- Any numbers `num % 3 == 0` are always included.\\n- Sums not divisible by 3 can be turned to a number divisible by 3 by minusing the remainder from `sum % 3`. We\\'ll look for a minimum number to fulfill this condition to fulfill maxSum.\\n- Two numbers with `num % 3 == 1` combined together will always equal `num % 3 == 2`. \\n\\t- These combined numbers can be less than a single number `num % 3 == 2`. \\n\\t- **Note**: We don\\'t use three `num % 3 == 1` as combining them will equal `num % 3 == 0`.\\n- Two numbers with `num % 3 == 2` combined together will always equal `num % 3 == 1`. \\n\\t- These combined numbers can be less than a single number `num % 3 == 1`. \\n\\t- **Note**: We don\\'t use three `num % 3 == 2` as combining them will equal `num % 3 == 0`.\\n\\n```java\\npublic int maxSumDivThree(int[] nums) {\\n\\tint sum = 0;\\n\\n\\tint minOne = Integer.MAX_VALUE;\\n\\tint minTwo = Integer.MAX_VALUE;\\n\\tfor (int num: nums) {\\n\\t\\tsum += num;\\n\\n\\t\\tswitch (num % 3) {\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\t// 1+1=2%3=2. 4+4=8%3=2. 1+4=5%3=2.\\n\\t\\t\\t\\tif (minOne != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tminTwo = Math.min(minTwo, num + minOne);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminOne = Math.min(minOne, num);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\t// 2+2=4%3=1. 5+5=10%3=1. 2+5=7%3=1.\\n\\t\\t\\t\\tif (minTwo != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tminOne = Math.min(minOne, num + minTwo);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminTwo = Math.min(minTwo, num);\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tswitch (sum % 3) {\\n\\t\\tcase 1:\\n\\t\\t\\tif (minOne == Integer.MAX_VALUE) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum - minOne;\\n\\t\\tcase 2:\\n\\t\\t\\tif (minTwo == Integer.MAX_VALUE) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum - minTwo;\\n\\t\\tdefault:\\n\\t\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int maxSumDivThree(int[] nums) {\\n\\tint sum = 0;\\n\\n\\tint minOne = Integer.MAX_VALUE;\\n\\tint minTwo = Integer.MAX_VALUE;\\n\\tfor (int num: nums) {\\n\\t\\tsum += num;\\n\\n\\t\\tswitch (num % 3) {\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\t// 1+1=2%3=2. 4+4=8%3=2. 1+4=5%3=2.\\n\\t\\t\\t\\tif (minOne != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tminTwo = Math.min(minTwo, num + minOne);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminOne = Math.min(minOne, num);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\t// 2+2=4%3=1. 5+5=10%3=1. 2+5=7%3=1.\\n\\t\\t\\t\\tif (minTwo != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tminOne = Math.min(minOne, num + minTwo);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminTwo = Math.min(minTwo, num);\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tswitch (sum % 3) {\\n\\t\\tcase 1:\\n\\t\\t\\tif (minOne == Integer.MAX_VALUE) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum - minOne;\\n\\t\\tcase 2:\\n\\t\\t\\tif (minTwo == Integer.MAX_VALUE) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum - minTwo;\\n\\t\\tdefault:\\n\\t\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 757173,
                "title": "python-3-98-speed-250ms-maths",
                "content": "Key idea:\\nSum all values,and set this to sum_, then the problem is simply taking out the remainder mod 3 if possible.\\nIf the remainder is 0, sum_ is the solution\\nElse without loss of generality, we can say sum_ has remainder 1 when divided by 3..\\nTake the smallest pair of values (a,b) in our list congruent to 2 mod 3, and the smallest value \\'x\\' congruent to 1 mod 3\\nEither x < sum(a,b), and we can return sum_ - x\\nelse return sum - a - b\\n\\nThe only edge case is when there are no values congruent to 1 mod 3, or there are fewer than 2 congruent to 2 mod 3.\\nThese are dealt with in the below code.\\n\\nRather than returning the smallest two in min_two below, one could instead return the sum and handle cases that way.\\n\\nThis should be O(N)\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n                 \\n        if not nums:\\n            return 0\\n        if len(nums) == 1 and nums[0] % 3:\\n            return 0\\n        \\n        sum_ = sum(nums)\\n        mod_ = sum_ % 3\\n        if not mod_:\\n            return sum_\\n                \\n        vals = {False: self.min_two([n for n in nums if n % 3 == 3 - mod_]),\\n                True: [min([n for n in nums if n % 3 == mod_])]}\\n        \\n        if vals[True] and len(vals[False]) <= 1:\\n            return sum_ - vals[True][0]\\n        \\n        elif vals[True] and vals[True][0] < sum(vals[False]):\\n            return sum_ - vals[True][0]\\n        \\n        elif len(vals[False]) == 2:\\n            return sum_ - sum(vals[False])\\n        return 0\\n        \\n            \\n    \\n    def min_two(self, l):\\n        if not l:\\n            return []\\n        idx = [i for i in range(len(l))]\\n        out = [min(idx, key = lambda i: l[i])]\\n        idx.pop(out[0])\\n        if idx:\\n            out.append(min(idx, key = lambda i: l[i]))\\n        \\n        return [l[i] for i in out]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n                 \\n        if not nums:\\n            return 0\\n        if len(nums) == 1 and nums[0] % 3:\\n            return 0\\n        \\n        sum_ = sum(nums)\\n        mod_ = sum_ % 3\\n        if not mod_:\\n            return sum_\\n                \\n        vals = {False: self.min_two([n for n in nums if n % 3 == 3 - mod_]),\\n                True: [min([n for n in nums if n % 3 == mod_])]}\\n        \\n        if vals[True] and len(vals[False]) <= 1:\\n            return sum_ - vals[True][0]\\n        \\n        elif vals[True] and vals[True][0] < sum(vals[False]):\\n            return sum_ - vals[True][0]\\n        \\n        elif len(vals[False]) == 2:\\n            return sum_ - sum(vals[False])\\n        return 0\\n        \\n            \\n    \\n    def min_two(self, l):\\n        if not l:\\n            return []\\n        idx = [i for i in range(len(l))]\\n        out = [min(idx, key = lambda i: l[i])]\\n        idx.pop(out[0])\\n        if idx:\\n            out.append(min(idx, key = lambda i: l[i]))\\n        \\n        return [l[i] for i in out]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688937,
                "title": "simple-o-n-dp-c-solution-with-dp-table-by-farouk",
                "content": "![image](https://assets.leetcode.com/users/alfarouksaleh/image_1592243114.png)\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    int maxSumDivThree(vector<int>& nums) {\\n        int sz=nums.size();\\n       // if(!sz)return \\n        int dp[sz+1][3];\\n        int temp1,temp2;\\n        for (int i=0;i<3;i++)dp[0][i]=0;\\n        for (int i=1;i<=sz;i++){\\n            for (int j=0;j<3;j++){dp[i][j]=dp[i-1][j];}\\n            \\n            for (int j=0;j<3;j++){\\n                temp1=nums[i-1]+dp[i-1][j];\\n                temp2=temp1%3;//the mod3 of the current number\\n                dp[i][temp2]=max(dp[i][temp2],temp1);\\n                \\n            }\\n            \\n            \\n            \\n        }\\n       return dp[sz][0];\\n        \\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int maxSumDivThree(vector<int>& nums) {\\n        int sz=nums.size();\\n       // if(!sz)return \\n        int dp[sz+1][3];\\n        int temp1,temp2;\\n        for (int i=0;i<3;i++)dp[0][i]=0;\\n        for (int i=1;i<=sz;i++){\\n            for (int j=0;j<3;j++){dp[i][j]=dp[i-1][j];}",
                "codeTag": "Java"
            },
            {
                "id": 665706,
                "title": "python-99-87-of-time-and-100-00-of-memory-subtract-minimum-with-the-sum-remainder",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        max_sum = sum(nums)\\n        if max_sum % 3:\\n            # if the total sum has a remainder the remainder can be neutralized by subtracting the smallest number\\n            # with the same remainder or the sum of two smallest numbers with a different remainder\\n            if max_sum % 3 == 1:\\n                # search for x % 3 == 1 or two minimum numbers such that x % 3 == 2\\n                min_mod1   = math.inf\\n                min_mod2   = [math.inf, math.inf]\\n                for num in nums:\\n                    mod = num % 3\\n                    if mod == 1 and num < min_mod1:\\n                        min_mod1 = num\\n                    elif mod == 2 and num < max(min_mod2):\\n                        min_mod2[min_mod2[0] < min_mod2[1]] = num\\n                        \\n                max_sum -= min(min_mod1, sum(min_mod2))\\n            else:\\n                min_mod2 = math.inf\\n                min_mod1 = [math.inf, math.inf]\\n                for num in nums:\\n                    mod = num % 3\\n                    if mod == 1 and num < max(min_mod1):\\n                        min_mod1[min_mod1[0] < min_mod1[1]] = num\\n                    elif mod == 2 and num < min_mod2:\\n                        min_mod2 = num\\n                max_sum -= min(min_mod2, sum(min_mod1))\\n                        \\n        return max_sum\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        max_sum = sum(nums)\\n        if max_sum % 3:\\n            # if the total sum has a remainder the remainder can be neutralized by subtracting the smallest number\\n            # with the same remainder or the sum of two smallest numbers with a different remainder\\n            if max_sum % 3 == 1:\\n                # search for x % 3 == 1 or two minimum numbers such that x % 3 == 2\\n                min_mod1   = math.inf\\n                min_mod2   = [math.inf, math.inf]\\n                for num in nums:\\n                    mod = num % 3\\n                    if mod == 1 and num < min_mod1:\\n                        min_mod1 = num\\n                    elif mod == 2 and num < max(min_mod2):\\n                        min_mod2[min_mod2[0] < min_mod2[1]] = num\\n                        \\n                max_sum -= min(min_mod1, sum(min_mod2))\\n            else:\\n                min_mod2 = math.inf\\n                min_mod1 = [math.inf, math.inf]\\n                for num in nums:\\n                    mod = num % 3\\n                    if mod == 1 and num < max(min_mod1):\\n                        min_mod1[min_mod1[0] < min_mod1[1]] = num\\n                    elif mod == 2 and num < min_mod2:\\n                        min_mod2 = num\\n                max_sum -= min(min_mod2, sum(min_mod1))\\n                        \\n        return max_sum\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 661492,
                "title": "c-o-n-dp-solution-o-1-for-space-finished-after-10-mins-very-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int v[]={0,0,0};\\n        //v[0] ~ mod3==0\\n        //v[1] ~ mod3==1\\n        //v[2] ~ mod3==2\\n        int n=nums.size();\\n        for (int i=n-1; i>=0; i--){\\n            int tmp[3];\\n            for (int i=0; i<3; i++)\\n                tmp[i]=v[i];\\n            for (int j=0; j<3; j++){\\n                int mod=(tmp[j]+nums[i])%3;\\n                v[mod]=max(v[mod],tmp[j]+nums[i]);                \\n            }\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int v[]={0,0,0};\\n        //v[0] ~ mod3==0\\n        //v[1] ~ mod3==1\\n        //v[2] ~ mod3==2\\n        int n=nums.size();\\n        for (int i=n-1; i>=0; i--){\\n            int tmp[3];\\n            for (int i=0; i<3; i++)\\n                tmp[i]=v[i];\\n            for (int j=0; j<3; j++){\\n                int mod=(tmp[j]+nums[i])%3;\\n                v[mod]=max(v[mod],tmp[j]+nums[i]);                \\n            }\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654344,
                "title": "easy-java-solution-o-n-time-o-1-space",
                "content": "Create a dp array with size of 3. Indicating max value that have remainder equals with the index.\\ni.e. dp[1] = 7 means the maximum value can sum up which has a remainer =1 after mod 3 is 7.\\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int [] dp = new int[3];\\n        for (int i = 0; i < nums.length; i++) {\\n            int [] n = new int[3];\\n            if (nums[i] % 3 == 0) {\\n                n[0] = dp[0] + nums[i];\\n                n[1] = dp[1] + nums[i];\\n                n[2] = dp[2] + nums[i];\\n            } else if (nums[i] % 3 == 1) {\\n                n[0] = dp[2] % 3 == 2 ?  Math.max(dp[2] + nums[i], dp[0]) : dp[0];\\n                n[1] = Math.max(dp[0] + nums[i], dp[1]);\\n                n[2] = dp[1] % 3 == 1 ? Math.max(dp[1] + nums[i], dp[2]) : dp[2];\\n            } else {\\n                n[0] = dp[1] % 3 == 1 ? Math.max(dp[1] + nums[i], dp[0]) : dp[0];\\n                n[1] = dp[2] % 3 == 2 ? Math.max(dp[2] + nums[i], dp[1]) : dp[1];\\n                n[2] = Math.max(dp[0] + nums[i], dp[2]);\\n            }\\n            dp = n;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int [] dp = new int[3];\\n        for (int i = 0; i < nums.length; i++) {\\n            int [] n = new int[3];\\n            if (nums[i] % 3 == 0) {\\n                n[0] = dp[0] + nums[i];\\n                n[1] = dp[1] + nums[i];\\n                n[2] = dp[2] + nums[i];\\n            } else if (nums[i] % 3 == 1) {\\n                n[0] = dp[2] % 3 == 2 ?  Math.max(dp[2] + nums[i], dp[0]) : dp[0];\\n                n[1] = Math.max(dp[0] + nums[i], dp[1]);\\n                n[2] = dp[1] % 3 == 1 ? Math.max(dp[1] + nums[i], dp[2]) : dp[2];\\n            } else {\\n                n[0] = dp[1] % 3 == 1 ? Math.max(dp[1] + nums[i], dp[0]) : dp[0];\\n                n[1] = dp[2] % 3 == 2 ? Math.max(dp[2] + nums[i], dp[1]) : dp[1];\\n                n[2] = Math.max(dp[0] + nums[i], dp[2]);\\n            }\\n            dp = n;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641510,
                "title": "easy-peasy-c-o-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        if(sum%3==0)\\n            return sum;\\n        if(sum%3==1){\\n            int temp=sum;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==1){\\n                    sum-=nums[i];\\n                    break;\\n                }\\n            }\\n            \\n            \\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==2){\\n                    temp-=nums[i];\\n                    cnt++;\\n                }\\n                if(cnt==2)\\n                    break;\\n            }\\n            if(temp%3==0&&sum%3==0)\\n                return max(sum,temp);\\n            if(temp%3==0)\\n                return temp;\\n            return sum;\\n        }\\n        if(sum%3==2){\\n            int temp=sum;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==2){\\n                    sum-=nums[i];\\n                    break;\\n                }\\n            }\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==1){\\n                    temp-=nums[i];\\n                    cnt++;\\n                }\\n                if(cnt==2)\\n                    break;\\n            }\\n            if(temp%3==0&&sum%3==0)\\n                return max(sum,temp);\\n            if(temp%3==0)\\n                return temp;\\n            return sum;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        if(sum%3==0)\\n            return sum;\\n        if(sum%3==1){\\n            int temp=sum;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==1){\\n                    sum-=nums[i];\\n                    break;\\n                }\\n            }\\n            \\n            \\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==2){\\n                    temp-=nums[i];\\n                    cnt++;\\n                }\\n                if(cnt==2)\\n                    break;\\n            }\\n            if(temp%3==0&&sum%3==0)\\n                return max(sum,temp);\\n            if(temp%3==0)\\n                return temp;\\n            return sum;\\n        }\\n        if(sum%3==2){\\n            int temp=sum;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==2){\\n                    sum-=nums[i];\\n                    break;\\n                }\\n            }\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%3==1){\\n                    temp-=nums[i];\\n                    cnt++;\\n                }\\n                if(cnt==2)\\n                    break;\\n            }\\n            if(temp%3==0&&sum%3==0)\\n                return max(sum,temp);\\n            if(temp%3==0)\\n                return temp;\\n            return sum;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639335,
                "title": "simple-python-logic-based-solution-explained-beats-97-time-100-memory",
                "content": "There aren\\'t that many possibilities for the numbers we could exclude to get the max sum divisible by 3. Either the sum of `nums` is divisible by 3 to begin with, (in which case, great!), or we need to remove numbers that aren\\'t divisible by 3 to get there. You can\\'t exclude both a mod3=1 and a mod3=2 number, because together they\\'d be divisible by 3. And you\\'d only want to exclude the lowest possible mod3=1 or mod3=2 numbers, so there\\'s only 4 different possible solutions:\\n* Remove the smallest mod3=1 element\\n* Remove the smallest 2 mod3=1 elements\\n* Remove the smallest mod3=2 element\\n* Remove the smallest 2 mod3=2 elements\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        if sum(nums) % 3 == 0:\\n            return sum(nums)\\n        \\n        mod1 = [num for num in nums if num % 3 == 1]\\n        mod2 = [num for num in nums if num % 3 == 2]\\n        mod1_min = min(mod1 or [float(\\'inf\\')])\\n        mod2_min = min(mod2 or [float(\\'inf\\')])\\n        mod1.remove(mod1_min)\\n        mod2.remove(mod2_min)\\n        \\n        possibilities = [ \\n            sum(nums) - mod1_min,\\n            sum(nums) - mod2_min,\\n            sum(nums) - mod1_min - min(mod1 or [float(\\'inf\\')]),\\n            sum(nums) - mod2_min - min(mod2 or [float(\\'inf\\')]),\\n        ]\\n        \\n        return max([\\n            pos for pos in possibilities if pos % 3 == 0\\n        ] or [0])\\n```\\n\\nA DP solution would make more sense for something like \"greatest sum divisible by 7\", where there would be many cominations of numbers you\\'d have to exclude, but it\\'s overengineering for something that only has a few possible outcomes :)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        if sum(nums) % 3 == 0:\\n            return sum(nums)\\n        \\n        mod1 = [num for num in nums if num % 3 == 1]\\n        mod2 = [num for num in nums if num % 3 == 2]\\n        mod1_min = min(mod1 or [float(\\'inf\\')])\\n        mod2_min = min(mod2 or [float(\\'inf\\')])\\n        mod1.remove(mod1_min)\\n        mod2.remove(mod2_min)\\n        \\n        possibilities = [ \\n            sum(nums) - mod1_min,\\n            sum(nums) - mod2_min,\\n            sum(nums) - mod1_min - min(mod1 or [float(\\'inf\\')]),\\n            sum(nums) - mod2_min - min(mod2 or [float(\\'inf\\')]),\\n        ]\\n        \\n        return max([\\n            pos for pos in possibilities if pos % 3 == 0\\n        ] or [0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592532,
                "title": "1262-greatest-sum-divisible-by-three-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Set**\\n| O(T): O() | O(S): O() | Rt: ms | TLE\\n```python\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = {0}\\n        for i in nums:\\n            s |= {i+j for j in s}\\n        return max(i for i in s if i % 3 == 0)\\n```\\nComment: easy to guess the backtracking solution is TLE as well.\\n\\n\\n**II). Bucket DP**\\n| O(T): O(n) | O(S): O(1) | Rt: 424ms | \\n```python\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        m = [0, 0, 0]\\n        for i in nums:\\n            for j in m[:]:\\n                m[(i+j) % 3] = max(m[(i+j) % 3], i+j)\\n        return m[0]\\n```\\nReferrence: https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space",
                "solutionTags": [],
                "code": "```python\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        s = {0}\\n        for i in nums:\\n            s |= {i+j for j in s}\\n        return max(i for i in s if i % 3 == 0)\\n```\n```python\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        m = [0, 0, 0]\\n        for i in nums:\\n            for j in m[:]:\\n                m[(i+j) % 3] = max(m[(i+j) % 3], i+j)\\n        return m[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 589195,
                "title": "python-memory-100",
                "content": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        D={0:[],1:[],2:[]}\\n        for n in nums:\\n            D[n%3].append(n)\\n        for k in range(3):\\n            D[k].sort()\\n        S=sum(nums)\\n        if S%3==0:\\n            return S\\n        elif S%3==1:\\n            a=0\\n            b=0\\n            if len(D[1])>=1:\\n                a=S-D[1][0]\\n            if len(D[2])>=2:\\n                b=S-D[2][0]-D[2][1]\\n            return(max(a,b))\\n        elif S%3==2:\\n            a=0\\n            b=0\\n            if len(D[2])>=1:\\n                a=S-D[2][0]\\n            if len(D[1])>=2:\\n                b=S-D[1][0]-D[1][1]\\n            return(max(a,b))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        D={0:[],1:[],2:[]}\\n        for n in nums:\\n            D[n%3].append(n)\\n        for k in range(3):\\n            D[k].sort()\\n        S=sum(nums)\\n        if S%3==0:\\n            return S\\n        elif S%3==1:\\n            a=0\\n            b=0\\n            if len(D[1])>=1:\\n                a=S-D[1][0]\\n            if len(D[2])>=2:\\n                b=S-D[2][0]-D[2][1]\\n            return(max(a,b))\\n        elif S%3==2:\\n            a=0\\n            b=0\\n            if len(D[2])>=1:\\n                a=S-D[2][0]\\n            if len(D[1])>=2:\\n                b=S-D[1][0]-D[1][1]\\n            return(max(a,b))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580822,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int dp[][]=new int[nums.length][3];\\n        dp[0][nums[0]%3]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            int index1=(nums[i]+dp[i-1][0])%3;\\n            int index2=(nums[i]+dp[i-1][1])%3;\\n            int index3=(nums[i]+dp[i-1][2])%3;\\n            dp[i][index1]=Math.max(dp[i][index1],nums[i]+dp[i-1][0]);\\n            dp[i][index2]=Math.max(dp[i][index2],nums[i]+dp[i-1][1]);\\n            dp[i][index3]=Math.max(dp[i][index3],nums[i]+dp[i-1][2]);\\n            dp[i][0]=Math.max(dp[i][0],dp[i-1][0]);\\n            dp[i][1]=Math.max(dp[i][1],dp[i-1][1]);\\n            dp[i][2]=Math.max(dp[i][2],dp[i-1][2]);\\n        }\\n        return dp[nums.length-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int dp[][]=new int[nums.length][3];\\n        dp[0][nums[0]%3]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            int index1=(nums[i]+dp[i-1][0])%3;\\n            int index2=(nums[i]+dp[i-1][1])%3;\\n            int index3=(nums[i]+dp[i-1][2])%3;\\n            dp[i][index1]=Math.max(dp[i][index1],nums[i]+dp[i-1][0]);\\n            dp[i][index2]=Math.max(dp[i][index2],nums[i]+dp[i-1][1]);\\n            dp[i][index3]=Math.max(dp[i][index3],nums[i]+dp[i-1][2]);\\n            dp[i][0]=Math.max(dp[i][0],dp[i-1][0]);\\n            dp[i][1]=Math.max(dp[i][1],dp[i-1][1]);\\n            dp[i][2]=Math.max(dp[i][2],dp[i-1][2]);\\n        }\\n        return dp[nums.length-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538722,
                "title": "python-simple-solution-o-n",
                "content": "```class Solution(object):\\n    def maxSumDivThree(self, nums):\\n        seen = {\\n            0: [],\\n            1: [],\\n            2: []\\n        }\\n        \\n        for num in nums:\\n            seen[num % 3].append(num)\\n        \\n        s = sum(seen[0] + seen[1] + seen[2])\\n        remainderOne = sorted(seen[1])[:2]\\n        remainderTwo = sorted(seen[2])[:2]\\n        \\n        if s % 3 == 2:\\n            if len(remainderOne) < 2 and len(remainderTwo) < 1:\\n                return 0\\n            elif len(remainderOne) < 2:\\n                return s - remainderTwo[0]\\n            elif len(remainderTwo) < 1:\\n                return s - sum(remainderOne)\\n            return s - min(sum(remainderOne), remainderTwo[0])\\n        \\n        elif s % 3 == 1:\\n            if len(remainderOne) < 1 and len(remainderTwo) < 2:\\n                return 0\\n            elif len(remainderOne) < 1:\\n                return s - sum(remainderTwo)\\n            elif len(remainderTwo) < 2:\\n                return s - remainderOne[0]\\n            return s - min(remainderOne[0], sum(remainderTwo))\\n        \\n        return s\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def maxSumDivThree(self, nums):\\n        seen = {\\n            0: [],\\n            1: [],\\n            2: []\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 535819,
                "title": "simple-python3-solution-using-dp-with-examples",
                "content": "Easy-understandable solution.\\n\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\'\\'\\'\\n            3  6  5  1   8  \\n        0   3  9  9  15  18 \\n        1   0  0  0  10  10 \\n        2   0  0  14 0   23\\n        \\n            1  2  3  4  4\\n        0   0  3  6  9  12\\n        1   1  1  4 10  13\\n        2   0  2  5  8  14\\n        \\n        \\'\\'\\'\\n        \\n        m = [[0 for n in range(len(nums))] for n in range(3)]\\n        m[nums[0] % 3][0] = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            for j in range(3):\\n                m[j][i] = m [j][i-1]\\n        \\n            for j in range(3):\\n                n = m[j][i-1] + nums[i]\\n                mod = n % 3\\n                if m[mod][i] < n:\\n                    m[mod][i] = n\\n                    \\n        \\n        return m[0][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\'\\'\\'\\n            3  6  5  1   8  \\n        0   3  9  9  15  18 \\n        1   0  0  0  10  10 \\n        2   0  0  14 0   23\\n        \\n            1  2  3  4  4\\n        0   0  3  6  9  12\\n        1   1  1  4 10  13\\n        2   0  2  5  8  14\\n        \\n        \\'\\'\\'\\n        \\n        m = [[0 for n in range(len(nums))] for n in range(3)]\\n        m[nums[0] % 3][0] = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            for j in range(3):\\n                m[j][i] = m [j][i-1]\\n        \\n            for j in range(3):\\n                n = m[j][i-1] + nums[i]\\n                mod = n % 3\\n                if m[mod][i] < n:\\n                    m[mod][i] = n\\n                    \\n        \\n        return m[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521926,
                "title": "straightforward-24ms-o-n-dp-even-handles-negative-elements",
                "content": "```\\nclass Solution {\\n    \\nint sub(int k, int i) {\\n    int tmp = k - ((i%3+3)%3);\\n    if (tmp < 0) {\\n        return tmp + 3;\\n    }\\n    return tmp;\\n}\\n    \\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n    \\n        int oo = INT_MIN;\\n        int n = nums.size();\\n        int dp[n][3];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (!i) {\\n                    if (!j) {\\n                        dp[i][j] = (nums[i]%3 == 0 ? max(nums[i],0) : 0);\\n                    }\\n                    else {\\n                        dp[i][j] = (nums[i]%3 == j ? nums[i] : oo);\\n                    }\\n                }\\n                else {\\n                    int excl = dp[i-1][j];\\n                    int incl = dp[i-1][sub(j,nums[i])];\\n                    if (excl == oo) {\\n                        if (incl == oo) {\\n                            dp[i][j] = oo;\\n                        }\\n                        else {\\n                            dp[i][j] = incl + nums[i];\\n                        }\\n                    }\\n                    else {\\n                        if (incl == oo) {\\n                            dp[i][j] = excl;\\n                        }\\n                        else {\\n                            dp[i][j] = max(excl, incl+nums[i]);\\n                        }\\n                    }                    \\n                }\\n            }\\n        }\\n        return dp[n-1][0]; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\nint sub(int k, int i) {\\n    int tmp = k - ((i%3+3)%3);\\n    if (tmp < 0) {\\n        return tmp + 3;\\n    }\\n    return tmp;\\n}\\n    \\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n    \\n        int oo = INT_MIN;\\n        int n = nums.size();\\n        int dp[n][3];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (!i) {\\n                    if (!j) {\\n                        dp[i][j] = (nums[i]%3 == 0 ? max(nums[i],0) : 0);\\n                    }\\n                    else {\\n                        dp[i][j] = (nums[i]%3 == j ? nums[i] : oo);\\n                    }\\n                }\\n                else {\\n                    int excl = dp[i-1][j];\\n                    int incl = dp[i-1][sub(j,nums[i])];\\n                    if (excl == oo) {\\n                        if (incl == oo) {\\n                            dp[i][j] = oo;\\n                        }\\n                        else {\\n                            dp[i][j] = incl + nums[i];\\n                        }\\n                    }\\n                    else {\\n                        if (incl == oo) {\\n                            dp[i][j] = excl;\\n                        }\\n                        else {\\n                            dp[i][j] = max(excl, incl+nums[i]);\\n                        }\\n                    }                    \\n                }\\n            }\\n        }\\n        return dp[n-1][0]; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 514523,
                "title": "python3-o-n-time-o-1-space",
                "content": "```class Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        D, Max = {}, 0\\n        Max1, Max2, Max3 =  0, 0 , 0\\n        for i in range(len(nums)):\\n            D[0], D[1], D[2] = 0, 0, 0\\n            D[nums[i]%3] = nums[i]\\n            if not Max1 == 0:\\n                D[(Max1 + nums[i])%3] = Max1 + nums[i]\\n            if not Max2 == 0:\\n                D[(Max2 + nums[i])%3] = Max2 + nums[i]\\n            if not Max3 == 0:\\n                D[(Max3 + nums[i])%3] = Max3 + nums[i]\\n            Max1, Max2, Max3 = max(Max1, D[0]), max(Max2, D[1]), max(D[2], Max3)\\n            \\n            Max = max(Max, D[0])\\n            \\n        return Max",
                "solutionTags": [],
                "code": "class Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        D, Max = {}",
                "codeTag": "Java"
            },
            {
                "id": 506895,
                "title": "python-dp-o-n-solution-with-simple-explanations",
                "content": "While passing through the list, update the array \"sums\", where sums[0] is the maximum sum of elements passed so far which is divisible by 3, sums[1] is the max sum of encountered elements which is divisible by 3 with remainder 1, and sums[2] is ... divisible by 3 with remainder 2. It is easy to see how these values have to be updated. For instance, if we encounter element n of the given array such that n % 3 == 1, then we know that adding that element to nums[2] (provided nums[2] is non-zero, which we check for) will give the sum which is divisible by 3. So we will have to see if nums[0] needs to be updated, i.e., whether the resulting sum, divisible by 3, is larger than what we already had in nums[0].\\n\\n```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        sums = [0, 0, 0]\\n        for n in nums:\\n            if n % 3 == 0:\\n                sums[0] += n\\n                if sums[1] > 0:\\n                    sums[1] += n\\n                if sums[2] > 0:\\n                    sums[2] += n\\n            elif n % 3 == 1:\\n                [n0, n1, n2] = sums\\n                if sums[2] > 0:\\n                    n0 = max(n0, sums[2]+n)\\n                n1 = max(n1, sums[0]+n)\\n                if sums[1] > 0:\\n                    n2 = max(n2, sums[1]+n)\\n                sums = [n0, n1, n2]\\n            else:\\n                [n0, n1, n2] = sums\\n                if sums[1] > 0:\\n                    n0 = max(n0, sums[1]+n)\\n                if sums[2] > 0:\\n                    n1 = max(n1, sums[2]+n)\\n                n2 = max(n2, sums[0]+n)\\n                sums = [n0, n1, n2]\\n        return sums[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        sums = [0, 0, 0]\\n        for n in nums:\\n            if n % 3 == 0:\\n                sums[0] += n\\n                if sums[1] > 0:\\n                    sums[1] += n\\n                if sums[2] > 0:\\n                    sums[2] += n\\n            elif n % 3 == 1:\\n                [n0, n1, n2] = sums\\n                if sums[2] > 0:\\n                    n0 = max(n0, sums[2]+n)\\n                n1 = max(n1, sums[0]+n)\\n                if sums[1] > 0:\\n                    n2 = max(n2, sums[1]+n)\\n                sums = [n0, n1, n2]\\n            else:\\n                [n0, n1, n2] = sums\\n                if sums[1] > 0:\\n                    n0 = max(n0, sums[1]+n)\\n                if sums[2] > 0:\\n                    n1 = max(n1, sums[2]+n)\\n                n2 = max(n2, sums[0]+n)\\n                sums = [n0, n1, n2]\\n        return sums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499454,
                "title": "easy-well-explained-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<vector<int>> dp(3,vector<int>(nums.size(),0));\\n        int state = nums[0]%3;\\n        for(int i=0;i<3;i++){\\n            if(i == state){\\n                dp[i][0] = nums[0];\\n            }\\n            else{\\n                dp[i][0] = 0;\\n            }\\n        }\\n        \\n        for(int j=1;j<nums.size();j++){\\n            for(int i=0;i<3;i++){\\n                dp[(nums[j] + dp[i][j-1])%3][j] = max(dp[(nums[j] + dp[i][j-1])%3][j], nums[j] + dp[i][j-1]);\\n            }\\n            dp[nums[j]%3][j] = max(dp[nums[j]%3][j],nums[j]);\\n            for(int i=0;i<3;i++){\\n                dp[i][j] = max(dp[i][j-1],dp[i][j]);\\n            }\\n        }\\n\\t    return dp[0][nums.size()-1];\\n}\\n};\\n```\\nIn the main loop The following information is stored in dp:\\n1.There are 3 possibilites for each state `dp[i][j]` where i is the state number and j is the jth index in nums array\\n2.We take **max** of : a) current nums and each of previous state value and then find the new state into which this whole value will be inserted\\nb) Exclude current nums and calculate max of a) and previous dp state(`dp[i][j-1]` for my code)\\nc) Also check if nums[j] itself can go to a state with value higher than a) or b).",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<vector<int>> dp(3,vector<int>(nums.size(),0));\\n        int state = nums[0]%3;\\n        for(int i=0;i<3;i++){\\n            if(i == state){\\n                dp[i][0] = nums[0];\\n            }\\n            else{\\n                dp[i][0] = 0;\\n            }\\n        }\\n        \\n        for(int j=1;j<nums.size();j++){\\n            for(int i=0;i<3;i++){\\n                dp[(nums[j] + dp[i][j-1])%3][j] = max(dp[(nums[j] + dp[i][j-1])%3][j], nums[j] + dp[i][j-1]);\\n            }\\n            dp[nums[j]%3][j] = max(dp[nums[j]%3][j],nums[j]);\\n            for(int i=0;i<3;i++){\\n                dp[i][j] = max(dp[i][j-1],dp[i][j]);\\n            }\\n        }\\n\\t    return dp[0][nums.size()-1];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476653,
                "title": "python-one-pass-o-n-time-o-1-space-no-dp",
                "content": "We don\\'t need to use DP for this problem.\\n\\nThere can only be 3 cases for the sum of the whole array:\\nsum % 3 = 0: directly return the result.\\n\\nsum % 3 = 1: we can subtract the smallest number x that (x % 3) = 1, or substract two smallest numbers that has remainder 2.\\n\\nsum % 3 = 2: roughly the same.\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mod1 = [float(\\'inf\\'), float(\\'inf\\')]\\n        mod2 = [float(\\'inf\\'), float(\\'inf\\')]\\n        sums = 0\\n        \\n        for number in nums:\\n            sums += number\\n            \\n            r = number % 3\\n            if r == 2:\\n                mod2.append(number)\\n                mod2.sort()\\n                mod2.pop()\\n            elif r == 1:\\n                mod1.append(number)\\n                mod1.sort()\\n                mod1.pop()\\n        \\n        r = sums % 3\\n        if not r:\\n            return sums\\n        elif r == 1:\\n            return max(sums - sum(mod2), sums - mod1[0])\\n        else:\\n            return max(sums - sum(mod1), sums - mod2[0])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        mod1 = [float(\\'inf\\'), float(\\'inf\\')]\\n        mod2 = [float(\\'inf\\'), float(\\'inf\\')]\\n        sums = 0\\n        \\n        for number in nums:\\n            sums += number\\n            \\n            r = number % 3\\n            if r == 2:\\n                mod2.append(number)\\n                mod2.sort()\\n                mod2.pop()\\n            elif r == 1:\\n                mod1.append(number)\\n                mod1.sort()\\n                mod1.pop()\\n        \\n        r = sums % 3\\n        if not r:\\n            return sums\\n        elif r == 1:\\n            return max(sums - sum(mod2), sums - mod1[0])\\n        else:\\n            return max(sums - sum(mod1), sums - mod2[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457247,
                "title": "greedy-approach-is-working",
                "content": "```\\nclass Solution { \\n    public int maxSumDivThree(int[] nums) {\\n        ArrayList<Integer>mod1 = new ArrayList();\\n        ArrayList<Integer>mod2 = new ArrayList();\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum +=nums[i];\\n            if(nums[i]%3==1){\\n                mod1.add(nums[i]);\\n            }\\n            if(nums[i]%3==2){\\n                mod2.add(nums[i]);\\n            }\\n        }\\n        Collections.sort(mod1);\\n        Collections.sort(mod2);\\n        if(sum%3==0){\\n            return sum;\\n        }\\n        else if(sum%3==1){\\n            int x = 0,y=0;\\n            if(mod1.size()>=1){\\n                x = sum - mod1.get(0);\\n            }\\n            if(mod2.size()>=2){\\n                y = sum - mod2.get(0) - mod2.get(1);\\n                }\\n            return Math.max(x,y);\\n        }\\n        else if(sum%3==2){\\n            int x = 0,y = 0;\\n            if(mod2.size()>=1){\\n                x = sum - mod2.get(0);\\n            }\\n            if(mod1.size()>=2){\\n                y = sum - mod1.get(0) - mod1.get(1);\\n            }\\n            return Math.max(x,y);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    public int maxSumDivThree(int[] nums) {\\n        ArrayList<Integer>mod1 = new ArrayList();\\n        ArrayList<Integer>mod2 = new ArrayList();\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum +=nums[i];\\n            if(nums[i]%3==1){\\n                mod1.add(nums[i]);\\n            }\\n            if(nums[i]%3==2){\\n                mod2.add(nums[i]);\\n            }\\n        }\\n        Collections.sort(mod1);\\n        Collections.sort(mod2);\\n        if(sum%3==0){\\n            return sum;\\n        }\\n        else if(sum%3==1){\\n            int x = 0,y=0;\\n            if(mod1.size()>=1){\\n                x = sum - mod1.get(0);\\n            }\\n            if(mod2.size()>=2){\\n                y = sum - mod2.get(0) - mod2.get(1);\\n                }\\n            return Math.max(x,y);\\n        }\\n        else if(sum%3==2){\\n            int x = 0,y = 0;\\n            if(mod2.size()>=1){\\n                x = sum - mod2.get(0);\\n            }\\n            if(mod1.size()>=2){\\n                y = sum - mod1.get(0) - mod1.get(1);\\n            }\\n            return Math.max(x,y);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449653,
                "title": "a-more-generalised-code-can-work-on-divisibilty-with-any-number",
                "content": "DP[i,j] = represents largest sum we can get till i whose sum modulo k(here k=3) is j. Each time we\\'ll have to options, either include the sum or not:- Hence, DP[i,j]=max(DP[i-1,x] + nums[i], DP[i-1,j] where x + nums[i] == j mod k The result will be DP[n,0]\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        int i,j,n=nums.size();\\n        int k=3;\\n        \\n        int dp[n+1][k];\\n        memset(dp,0,sizeof dp);\\n        \\n        for (j = 0; j < k; j++) dp[0][j] = 0;\\n\\n         for (i = 1; i <= n; i++)\\n          for (j = 0; j < k; j++)\\n          {\\n           int x = (j + k - nums[i-1]%k) % k;\\n\\t\\t   //This is to check if the sum fulfills the condition or not because initially we\\'re considering sum as zero for every column and  any column other than zeroth col will have  0 mod j==0 which is wrong \\n            if((dp[i-1][x]+nums[i-1])%3==j)\\n             dp[i][j] = max(dp[i-1][x]+nums[i-1], dp[i-1][j]);\\n            else\\n             dp[i][j] = dp[i-1][j];\\n          }\\n        \\n        return dp[n][0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        \\n        int i,j,n=nums.size();\\n        int k=3;\\n        \\n        int dp[n+1][k];\\n        memset(dp,0,sizeof dp);\\n        \\n        for (j = 0; j < k; j++) dp[0][j] = 0;\\n\\n         for (i = 1; i <= n; i++)\\n          for (j = 0; j < k; j++)\\n          {\\n           int x = (j + k - nums[i-1]%k) % k;\\n\\t\\t   //This is to check if the sum fulfills the condition or not because initially we\\'re considering sum as zero for every column and  any column other than zeroth col will have  0 mod j==0 which is wrong \\n            if((dp[i-1][x]+nums[i-1])%3==j)\\n             dp[i][j] = max(dp[i-1][x]+nums[i-1], dp[i-1][j]);\\n            else\\n             dp[i][j] = dp[i-1][j];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 440372,
                "title": "c-24ms-beat-98-81-python-256ms-beat-96-55",
                "content": "C++ solution,\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        priority_queue<int,vector<int>,greater<int>> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n\\n        int res = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            res += nums[i];\\n            \\n            if (nums[i]%3 == 1)\\n                pq1.push(nums[i]);\\n            else if (nums[i]%3 == 2)\\n                pq2.push(nums[i]);\\n        }\\n\\n        int var11 = 100000;\\n        int var12 = 100000;\\n        int var21 = 100000;\\n        int var22 = 100000;\\n        if (pq1.size() > 0) { var11 = pq1.top(); pq1.pop(); }\\n        if (pq1.size() > 0) { var12 = pq1.top(); }\\n        if (pq2.size() > 0) { var21 = pq2.top(); pq2.pop(); }\\n        if (pq2.size() > 0) { var22 = pq2.top(); }\\n\\n        if (res % 3 == 1)\\n            res -= min(var11,var21+var22);\\n        else if (res % 3 == 2)\\n            res -= min(var21,var11+var12);\\n\\n        return res;\\n    }\\n};\\n```\\n\\nPython solution,\\n```\\nimport heapq\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums):\\n        pq1, pq2 = [], []\\n\\n        res = 0\\n        for i in nums:\\n            res += i\\n            \\n            if i % 3 == 1:\\n                heapq.heappush(pq1,i)\\n            elif i % 3 == 2:\\n                heapq.heappush(pq2,i)\\n\\n        var11, var12, var21, var22 = 100000, 100000, 100000, 100000\\n        if len(pq1) > 0: var11 = pq1[0]\\n        if len(pq2) > 0: var21 = pq2[0]\\n\\n        if len(pq1) > 1: \\n            heapq.heappop(pq1)\\n            var12 = pq1[0]\\n        \\n        if len(pq2) > 1: \\n            heapq.heappop(pq2)\\n            var22 = pq2[0]\\n\\n        if res % 3 == 1:\\n            res -= min(var11,var21+var22)\\n        elif res % 3 == 2:\\n            res -= min(var21,var11+var12)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        priority_queue<int,vector<int>,greater<int>> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n\\n        int res = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            res += nums[i];\\n            \\n            if (nums[i]%3 == 1)\\n                pq1.push(nums[i]);\\n            else if (nums[i]%3 == 2)\\n                pq2.push(nums[i]);\\n        }\\n\\n        int var11 = 100000;\\n        int var12 = 100000;\\n        int var21 = 100000;\\n        int var22 = 100000;\\n        if (pq1.size() > 0) { var11 = pq1.top(); pq1.pop(); }\\n        if (pq1.size() > 0) { var12 = pq1.top(); }\\n        if (pq2.size() > 0) { var21 = pq2.top(); pq2.pop(); }\\n        if (pq2.size() > 0) { var22 = pq2.top(); }\\n\\n        if (res % 3 == 1)\\n            res -= min(var11,var21+var22);\\n        else if (res % 3 == 2)\\n            res -= min(var21,var11+var12);\\n\\n        return res;\\n    }\\n};\\n```\n```\\nimport heapq\\n\\nclass Solution:\\n    def maxSumDivThree(self, nums):\\n        pq1, pq2 = [], []\\n\\n        res = 0\\n        for i in nums:\\n            res += i\\n            \\n            if i % 3 == 1:\\n                heapq.heappush(pq1,i)\\n            elif i % 3 == 2:\\n                heapq.heappush(pq2,i)\\n\\n        var11, var12, var21, var22 = 100000, 100000, 100000, 100000\\n        if len(pq1) > 0: var11 = pq1[0]\\n        if len(pq2) > 0: var21 = pq2[0]\\n\\n        if len(pq1) > 1: \\n            heapq.heappop(pq1)\\n            var12 = pq1[0]\\n        \\n        if len(pq2) > 1: \\n            heapq.heappop(pq2)\\n            var22 = pq2[0]\\n\\n        if res % 3 == 1:\\n            res -= min(var11,var21+var22)\\n        elif res % 3 == 2:\\n            res -= min(var21,var11+var12)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433793,
                "title": "python-dp-solution",
                "content": "Explaination:\\n        m0: the maximum possible sum of elements of the array such that it is divisible by three.\\n        m1: the maximum possible sum of elements of the array such that it is divisible by three mod 1.\\n        m2: the maximum possible sum of elements of the array such that it is divisible by three mod 2.\\n        then given number n, we can get new m0/m1/m2\\n\\t\\t\\n```python\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n       \\n        \"\"\"\\n        m0 = 0\\n        m1 = 0\\n        m2 = 0\\n        for n in nums:\\n            m = n % 3\\n            m0n, m1n, m2n = m0, m1, m2\\n            \\n            if m == 0:\\n                m0n = m0 + n\\n                m1n = m1 + n\\n                m2n = m2 + n\\n            elif m == 1:\\n                if m2 % 3 == 2:\\n                    m0n = max(m0, m2 + n)\\n                m1n = max(m1, m0 + n)\\n                if m1 % 3 == 1:\\n                    m2n = max(m2, m1 + n)\\n            elif m == 2:\\n                if m1 % 3 == 1:\\n                    m0n = max(m0, m1 + n)\\n                if m2 % 3 == 2:\\n                    m1n = max(m1, m2 + n)\\n                m2n = max(m2, m0 + n)\\n            m0, m1, m2 = m0n, m1n, m2n\\n            \\n        return m0\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n       \\n        \"\"\"\\n        m0 = 0\\n        m1 = 0\\n        m2 = 0\\n        for n in nums:\\n            m = n % 3\\n            m0n, m1n, m2n = m0, m1, m2\\n            \\n            if m == 0:\\n                m0n = m0 + n\\n                m1n = m1 + n\\n                m2n = m2 + n\\n            elif m == 1:\\n                if m2 % 3 == 2:\\n                    m0n = max(m0, m2 + n)\\n                m1n = max(m1, m0 + n)\\n                if m1 % 3 == 1:\\n                    m2n = max(m2, m1 + n)\\n            elif m == 2:\\n                if m1 % 3 == 1:\\n                    m0n = max(m0, m1 + n)\\n                if m2 % 3 == 2:\\n                    m1n = max(m1, m2 + n)\\n                m2n = max(m2, m0 + n)\\n            m0, m1, m2 = m0n, m1n, m2n\\n            \\n        return m0\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 431312,
                "title": "java-dp-solution-beats-100-o-n-time-and-o-n-space",
                "content": "The idea is to store the maximum sum at each position with each mod 0, 1 and 2;\\ndp[pos][mod] stores the max sum possible till position pos with mod. \\nThe sum at ith position can be derived by the maximum sum available at i-1th position. \\n\\n```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][3];\\n        dp[0][nums[0]%3] = nums[0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<3; j++) \\n                dp[i][j] = dp[i-1][j];\\n            for(int j=0; j<3; j++) {\\n                int res = dp[i-1][j]+nums[i];\\n                dp[i][res%3] = Math.max(dp[i][res%3], res);\\n            }\\n        }\\n        return dp[n-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumDivThree(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][3];\\n        dp[0][nums[0]%3] = nums[0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<3; j++) \\n                dp[i][j] = dp[i-1][j];\\n            for(int j=0; j<3; j++) {\\n                int res = dp[i-1][j]+nums[i];\\n                dp[i][res%3] = Math.max(dp[i][res%3], res);\\n            }\\n        }\\n        return dp[n-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431186,
                "title": "java-dp-0-1-knapsack",
                "content": "```\\nclass Solution {\\n    static int max=0;\\n    public int maxSumDivThree(int[] nums) {\\n        int[][]dp=new int[nums.length][3];\\n        for(int i=0;i<nums.length;i++){\\n            if(i==0){\\n                dp[0][nums[0]%3]=nums[0];\\n            }else{\\n                for(int j=0;j<3;j++){\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n                for(int j=0;j<3;j++){\\n                    int res=dp[i-1][j]+nums[i];\\n                    dp[i][res%3]=Math.max(dp[i][res%3],res);\\n                }\\n            }\\n        }\\n        return dp[nums.length-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int max=0;\\n    public int maxSumDivThree(int[] nums) {\\n        int[][]dp=new int[nums.length][3];\\n        for(int i=0;i<nums.length;i++){\\n            if(i==0){\\n                dp[0][nums[0]%3]=nums[0];\\n            }else{\\n                for(int j=0;j<3;j++){\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n                for(int j=0;j<3;j++){\\n                    int res=dp[i-1][j]+nums[i];\\n                    dp[i][res%3]=Math.max(dp[i][res%3],res);\\n                }\\n            }\\n        }\\n        return dp[nums.length-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431116,
                "title": "java-solution-with-detailed-explanation",
                "content": "The key idea to solving this problem is that if we add all of the numbers in the array up then the sum mod three can only be 3 values: 0, 1, and 2.\\n\\nIf ```sum % 3 = 0``` then we\\'re done.\\n\\nIf ```sum % 3 == 1``` then sum is of the form ```n % 3 + 1``` therefore to make it divisible by 3 with the smallest subtractions the possibilities are:\\n\\n```n * 3 + 1 - mod1_min[0] = n * 3 + 1 - (m * 3 + 1) = (n - m) * 3 => Divisible by 3```\\nor\\n```n * 3 + 1 - mod2_min[0] - mod2_min[1] = n * 3 + 1 - (m * 3 + 2) - (l * 3 + 2) = (n - m - l) * 3 - 3 = (n - m - l - 1) * 3 => Divisible by 3```\\n\\nThere are other possibilities to make the sum divisible by 3 however note that they will all be smaller than the results obtained by these options.\\n\\nif ```sum % 3 == 2``` then similar expressions as for ```sum % 3 == 1``` can be found.\\n\\nSolution:\\n\\n```Java\\npublic int maxSumDivThree(int[] nums)\\n{\\n    int sum = 0;\\n    int[] mod1_mins = new int[2];\\n    int[] mod2_mins = new int[2];\\n    \\n    Arrays.fill(mod1_mins, Integer.MAX_VALUE);\\n    Arrays.fill(mod2_mins, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < nums.length; i++)\\n    {\\n        int tmpMod = nums[i] % 3;\\n        \\n        sum += nums[i];\\n        \\n        if (tmpMod == 1)\\n        {\\n            if (nums[i] < mod1_mins[0])\\n            {\\n                mod1_mins[1] = mod1_mins[0];\\n                mod1_mins[0] = nums[i];\\n            }\\n            else if (nums[i] < mod1_mins[1])\\n                mod1_mins[1] = nums[i];\\n        }\\n        else if (tmpMod == 2)\\n        {\\n            if (nums[i] < mod2_mins[0])\\n            {\\n                mod2_mins[1] = mod2_mins[0];\\n                mod2_mins[0] = nums[i];\\n            }\\n            else if (nums[i] < mod2_mins[1])\\n                mod2_mins[1] = nums[i];\\n        }\\n    }\\n    \\n    int sumMod = sum % 3;\\n    int rem;\\n    \\n    if (sumMod == 1)\\n    {\\n        rem = mod1_mins[0];\\n        \\n        //Check for potential overflow...\\n        if (mod2_mins[0] != Integer.MAX_VALUE && mod2_mins[1] != Integer.MAX_VALUE)\\n            rem = Math.min(rem, mod2_mins[0] + mod2_mins[1]);\\n        \\n        sum -= rem;\\n    }\\n    else if (sumMod == 2)\\n    {\\n        rem = mod2_mins[0];\\n        \\n        if (mod1_mins[0] != Integer.MAX_VALUE && mod1_mins[1] != Integer.MAX_VALUE)\\n            rem = Math.min(rem, mod1_mins[0] + mod1_mins[1]);\\n        \\n        sum -= rem;\\n    }\\n    \\n    return sum;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```sum % 3 = 0```\n```sum % 3 == 1```\n```n % 3 + 1```\n```n * 3 + 1 - mod1_min[0] = n * 3 + 1 - (m * 3 + 1) = (n - m) * 3 => Divisible by 3```\n```n * 3 + 1 - mod2_min[0] - mod2_min[1] = n * 3 + 1 - (m * 3 + 2) - (l * 3 + 2) = (n - m - l) * 3 - 3 = (n - m - l - 1) * 3 => Divisible by 3```\n```sum % 3 == 2```\n```sum % 3 == 1```\n```Java\\npublic int maxSumDivThree(int[] nums)\\n{\\n    int sum = 0;\\n    int[] mod1_mins = new int[2];\\n    int[] mod2_mins = new int[2];\\n    \\n    Arrays.fill(mod1_mins, Integer.MAX_VALUE);\\n    Arrays.fill(mod2_mins, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < nums.length; i++)\\n    {\\n        int tmpMod = nums[i] % 3;\\n        \\n        sum += nums[i];\\n        \\n        if (tmpMod == 1)\\n        {\\n            if (nums[i] < mod1_mins[0])\\n            {\\n                mod1_mins[1] = mod1_mins[0];\\n                mod1_mins[0] = nums[i];\\n            }\\n            else if (nums[i] < mod1_mins[1])\\n                mod1_mins[1] = nums[i];\\n        }\\n        else if (tmpMod == 2)\\n        {\\n            if (nums[i] < mod2_mins[0])\\n            {\\n                mod2_mins[1] = mod2_mins[0];\\n                mod2_mins[0] = nums[i];\\n            }\\n            else if (nums[i] < mod2_mins[1])\\n                mod2_mins[1] = nums[i];\\n        }\\n    }\\n    \\n    int sumMod = sum % 3;\\n    int rem;\\n    \\n    if (sumMod == 1)\\n    {\\n        rem = mod1_mins[0];\\n        \\n        //Check for potential overflow...\\n        if (mod2_mins[0] != Integer.MAX_VALUE && mod2_mins[1] != Integer.MAX_VALUE)\\n            rem = Math.min(rem, mod2_mins[0] + mod2_mins[1]);\\n        \\n        sum -= rem;\\n    }\\n    else if (sumMod == 2)\\n    {\\n        rem = mod2_mins[0];\\n        \\n        if (mod1_mins[0] != Integer.MAX_VALUE && mod1_mins[1] != Integer.MAX_VALUE)\\n            rem = Math.min(rem, mod1_mins[0] + mod1_mins[1]);\\n        \\n        sum -= rem;\\n    }\\n    \\n    return sum;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431075,
                "title": "python-solution-without-dp",
                "content": "```\\ndef maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        c = {}\\n        c[1] = []\\n        c[2] = []\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] % 3 == 0:\\n                res += nums[i]\\n            elif nums[i] % 3 == 1:\\n                c[1].append(nums[i])\\n            else:\\n                c[2].append(nums[i])\\n        c[1] = sorted(c[1])\\n        c[2] = sorted(c[2])\\n        print(c[2])\\n        k = sum(c[1]) + sum(c[2])\\n        res += k\\n        if k % 3 == 0:\\n            return res\\n        elif k % 3 == 1:\\n            if not c[1]:\\n                res -= (c[2][0] + c[2][1])\\n            if len(c[2]) < 2:\\n                res -= c[1][0]\\n            else:\\n                res -= min(c[1][0], c[2][0] + c[2][1])\\n        else:\\n            if not c[2]:\\n                res -= (c[1][0] + c[1][1])\\n            if len(c[1]) < 2:\\n                res -= c[2][0]\\n            else:\\n                res -= min(c[2][0], c[1][0] + c[1][1])\\n        return res",
                "solutionTags": [],
                "code": "```\\ndef maxSumDivThree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        c = {}\\n        c[1] = []\\n        c[2] = []\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] % 3 == 0:\\n                res += nums[i]\\n            elif nums[i] % 3 == 1:\\n                c[1].append(nums[i])\\n            else:\\n                c[2].append(nums[i])\\n        c[1] = sorted(c[1])\\n        c[2] = sorted(c[2])\\n        print(c[2])\\n        k = sum(c[1]) + sum(c[2])\\n        res += k\\n        if k % 3 == 0:\\n            return res\\n        elif k % 3 == 1:\\n            if not c[1]:\\n                res -= (c[2][0] + c[2][1])\\n            if len(c[2]) < 2:\\n                res -= c[1][0]\\n            else:\\n                res -= min(c[1][0], c[2][0] + c[2][1])\\n        else:\\n            if not c[2]:\\n                res -= (c[1][0] + c[1][1])\\n            if len(c[1]) < 2:\\n                res -= c[2][0]\\n            else:\\n                res -= min(c[2][0], c[1][0] + c[1][1])\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 4069129,
                "title": "easy-way-to-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif a%b=c%b so (a-c)%b==0\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso we need to find 2 smallest elements that %3==1 and %3==2;\\neasy sort the vector\\ncompare sum of 2 smallest %3==2 with the smallest %3==1 to find the smallest sum %3==1;\\ndo the same way to find smallest sum %3==2;\\nuse this recipe to solve\\nif  (a%b=c%b)   so  ((a-c)%b==0)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlog(N))+O(n);\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int s=0;\\n        int m11=10000,m12=10000,m21=10001,m22=10001;\\n        sort(nums.begin(),nums.end());\\n        for (int i=0;i<nums.size();i++)\\n            {\\n            s=s+nums[i];\\n            if (nums[i]%3==1)\\n                if (m11==10000)\\n                    m11=nums[i];\\n                    else if (m12==10000)\\n                    m12=nums[i];\\n            if (nums[i]%3==2)\\n                if (m21==10001)\\n                    m21=nums[i];\\n                    else if (m22==10001)\\n                    m22=nums[i];\\n        }\\n    if (s%3==1)\\n    return s-(min(m11,m21+m22));\\n    else if (s%3==2)\\n    return s-(min(m21,m12+m11));\\n    else return s;\\n    ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int s=0;\\n        int m11=10000,m12=10000,m21=10001,m22=10001;\\n        sort(nums.begin(),nums.end());\\n        for (int i=0;i<nums.size();i++)\\n            {\\n            s=s+nums[i];\\n            if (nums[i]%3==1)\\n                if (m11==10000)\\n                    m11=nums[i];\\n                    else if (m12==10000)\\n                    m12=nums[i];\\n            if (nums[i]%3==2)\\n                if (m21==10001)\\n                    m21=nums[i];\\n                    else if (m22==10001)\\n                    m22=nums[i];\\n        }\\n    if (s%3==1)\\n    return s-(min(m11,m21+m22));\\n    else if (s%3==2)\\n    return s-(min(m21,m12+m11));\\n    else return s;\\n    ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056521,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(3, INT_MIN));\\n\\n        // Initialize the base case\\n        dp[0][0] = 0;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            int remainder = nums[i - 1] % 3;\\n\\n            for (int j = 0; j < 3; ++j) {\\n                dp[i][j] = dp[i - 1][j];  // Initialize with the previous state\\n\\n                // Update dp[i][j] using the current element\\n                int prev_remainder = (j - remainder + 3) % 3;\\n                dp[i][j] = max(dp[i][j], dp[i - 1][prev_remainder] + nums[i - 1]);\\n            }\\n        }\\n\\n        return dp[n][0];\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(3, INT_MIN));\\n\\n        // Initialize the base case\\n        dp[0][0] = 0;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            int remainder = nums[i - 1] % 3;\\n\\n            for (int j = 0; j < 3; ++j) {\\n                dp[i][j] = dp[i - 1][j];  // Initialize with the previous state\\n\\n                // Update dp[i][j] using the current element\\n                int prev_remainder = (j - remainder + 3) % 3;\\n                dp[i][j] = max(dp[i][j], dp[i - 1][prev_remainder] + nums[i - 1]);\\n            }\\n        }\\n\\n        return dp[n][0];\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046405,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> next(3, 0), curr(3, 0);\\n        int res{};\\n\\n        next[nums.back() % 3] = nums.back();\\n\\n        for(int i = nums.size() - 2; i >= 0; i--) {\\n            int mod = nums[i] % 3;\\n\\n            for(int j = 0; j < 3; j++) {\\n                if(next[j] or (mod+j)%3 == mod)\\n                    curr[(mod+j)%3] = std::max(curr[(mod+j)%3], next[j] + nums[i]);\\n                curr[j] = std::max(curr[j], next[j]);\\n            }\\n            std::swap(curr, next);\\n        } return next[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int> next(3, 0), curr(3, 0);\\n        int res{};\\n\\n        next[nums.back() % 3] = nums.back();\\n\\n        for(int i = nums.size() - 2; i >= 0; i--) {\\n            int mod = nums[i] % 3;\\n\\n            for(int j = 0; j < 3; j++) {\\n                if(next[j] or (mod+j)%3 == mod)\\n                    curr[(mod+j)%3] = std::max(curr[(mod+j)%3], next[j] + nums[i]);\\n                curr[j] = std::max(curr[j], next[j]);\\n            }\\n            std::swap(curr, next);\\n        } return next[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936537,
                "title": "simple-javascript",
                "content": "\\n```\\n\\nconst maxSumDivThree = function (nums) {\\n  const sum = nums.reduce((a, c) => a + c);\\n\\n  if (sum % 3 === 0) return sum;\\n\\n  nums.sort((a, b) => a - b)\\n\\n  let numsSum = 0;\\n  let singleNumDiff = 0;\\n  let multiNumSumDiff = 0;\\n\\n  for (const num of nums) {\\n    if ((sum - num) % 3 === 0) {\\n      singleNumDiff = sum - num;\\n      break;\\n    }\\n  }\\n\\n  for (const num of nums) {\\n    if (num % 3) numsSum += num;\\n    if ((sum - numsSum) % 3 === 0) {\\n      multiNumSumDiff = sum - numsSum;\\n      break;\\n    }\\n  }\\n\\n  return Math.max(singleNumDiff, multiNumSumDiff);\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst maxSumDivThree = function (nums) {\\n  const sum = nums.reduce((a, c) => a + c);\\n\\n  if (sum % 3 === 0) return sum;\\n\\n  nums.sort((a, b) => a - b)\\n\\n  let numsSum = 0;\\n  let singleNumDiff = 0;\\n  let multiNumSumDiff = 0;\\n\\n  for (const num of nums) {\\n    if ((sum - num) % 3 === 0) {\\n      singleNumDiff = sum - num;\\n      break;\\n    }\\n  }\\n\\n  for (const num of nums) {\\n    if (num % 3) numsSum += num;\\n    if ((sum - numsSum) % 3 === 0) {\\n      multiNumSumDiff = sum - numsSum;\\n      break;\\n    }\\n  }\\n\\n  return Math.max(singleNumDiff, multiNumSumDiff);\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929509,
                "title": "python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        \\n        total=sum(nums)\\n        q,r=divmod(total,3)\\n        \\n        if r==0:\\n            return total\\n        \\n        r1=[]\\n        r2=[]\\n        \\n        for val in nums:\\n            if val%3==1:\\n                r1.append(val)\\n            elif val%3==2:\\n                r2.append(val)\\n        \\n        r1.sort()\\n        r2.sort()\\n        \\n        if r==1:\\n            if not r1:\\n                return total-(r2[0]+r2[1])\\n            elif len(r2)<=1:\\n                return total-(r1[0])\\n            else:\\n                pos1=r1[0]\\n                pos2=r2[0]+r2[1]\\n                return total-min(pos1,pos2)\\n            \\n        elif r==2:\\n            if not r2:\\n                return total-(r1[0]+r1[1])\\n            elif len(r1)<=1:\\n                return total-(r2[0])\\n            else:\\n                pos1=r2[0]\\n                pos2=r1[0]+r1[1]\\n                return total-min(pos1,pos2)\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        \\n        \\n        total=sum(nums)\\n        q,r=divmod(total,3)\\n        \\n        if r==0:\\n            return total\\n        \\n        r1=[]\\n        r2=[]\\n        \\n        for val in nums:\\n            if val%3==1:\\n                r1.append(val)\\n            elif val%3==2:\\n                r2.append(val)\\n        \\n        r1.sort()\\n        r2.sort()\\n        \\n        if r==1:\\n            if not r1:\\n                return total-(r2[0]+r2[1])\\n            elif len(r2)<=1:\\n                return total-(r1[0])\\n            else:\\n                pos1=r1[0]\\n                pos2=r2[0]+r2[1]\\n                return total-min(pos1,pos2)\\n            \\n        elif r==2:\\n            if not r2:\\n                return total-(r1[0]+r1[1])\\n            elif len(r1)<=1:\\n                return total-(r2[0])\\n            else:\\n                pos1=r2[0]\\n                pos2=r1[0]+r1[1]\\n                return total-min(pos1,pos2)\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918754,
                "title": "a-very-intuitive-c-solution-based-on-knapsack-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI converted this problem into a knapsack problem\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int n;\\n    vector<int> b;\\n    // pair<int, int> dp[100001][5];\\n    // t/f, sum\\n    pair<int, int> f(int i, int s, vector<int> &a, vector<vector<pair<int, int>>> &dp)\\n    {\\n        if (i == n)\\n            return {s % 3 == 0, 0};\\n\\n        if (dp[i][s] != make_pair(-1, -1))\\n            return dp[i][s];\\n\\n        bool take = f(i + 1, (s + b[i]) % 3, a, dp).first;\\n        int nottake = f(i + 1, s, a, dp).first;\\n        if (take)\\n            return dp[i][s] = {take, max(a[i] + f(i + 1, (s + b[i]) % 3, a, dp).second, f(i + 1, s, a, dp).second)};\\n        else\\n            return dp[i][s] = {nottake, f(i + 1, s, a, dp).second};\\n    }\\n    int maxSumDivThree(vector<int> &a)\\n    {\\n        n = a.size();\\n        b.resize(n);\\n        // pair<int, int> p;\\n        // memset(dp, make_pair(-1, -1), sizeof(dp));\\n        vector<vector<pair<int, int>>> dp(n + 1, vector<pair<int, int>>(5, {-1, -1}));\\n\\n        for (int i = 0; i < n; i++)\\n            b[i] = a[i] % 3;\\n\\n        return f(0, 0, a, dp).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int n;\\n    vector<int> b;\\n    // pair<int, int> dp[100001][5];\\n    // t/f, sum\\n    pair<int, int> f(int i, int s, vector<int> &a, vector<vector<pair<int, int>>> &dp)\\n    {\\n        if (i == n)\\n            return {s % 3 == 0, 0};\\n\\n        if (dp[i][s] != make_pair(-1, -1))\\n            return dp[i][s];\\n\\n        bool take = f(i + 1, (s + b[i]) % 3, a, dp).first;\\n        int nottake = f(i + 1, s, a, dp).first;\\n        if (take)\\n            return dp[i][s] = {take, max(a[i] + f(i + 1, (s + b[i]) % 3, a, dp).second, f(i + 1, s, a, dp).second)};\\n        else\\n            return dp[i][s] = {nottake, f(i + 1, s, a, dp).second};\\n    }\\n    int maxSumDivThree(vector<int> &a)\\n    {\\n        n = a.size();\\n        b.resize(n);\\n        // pair<int, int> p;\\n        // memset(dp, make_pair(-1, -1), sizeof(dp));\\n        vector<vector<pair<int, int>>> dp(n + 1, vector<pair<int, int>>(5, {-1, -1}));\\n\\n        for (int i = 0; i < n; i++)\\n            b[i] = a[i] % 3;\\n\\n        return f(0, 0, a, dp).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911317,
                "title": "python-solution-in-o-n-and-o-1",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        arr=[0,0,0]\\n        for i in range(len(nums)):\\n            val=[0,0,0]\\n            for j in range(3):\\n                s=(nums[i]+arr[j])\\n                val[s%3]=max(val[s%3],s)\\n                val[j]=max(arr[j],val[j])\\n            arr=val\\n        return arr[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        arr=[0,0,0]\\n        for i in range(len(nums)):\\n            val=[0,0,0]\\n            for j in range(3):\\n                s=(nums[i]+arr[j])\\n                val[s%3]=max(val[s%3],s)\\n                val[j]=max(arr[j],val[j])\\n            arr=val\\n        return arr[0]\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1573843,
                "content": [
                    {
                        "username": "satish8060",
                        "content": "![image](https://assets.leetcode.com/users/satish8060/image_1590931842.png)\\n"
                    }
                ]
            }
        ]
    }
]