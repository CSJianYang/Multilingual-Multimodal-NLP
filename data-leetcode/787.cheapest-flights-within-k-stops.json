[
    {
        "title": "Cheapest Flights Within K Stops",
        "question_content": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\n&nbsp;\nExample 1:\n\nInput: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\nOutput: 700\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.\n\nExample 2:\n\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n\nExample 3:\n\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation:\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 100\n\t0 <= flights.length <= (n * (n - 1) / 2)\n\tflights[i].length == 3\n\t0 <= fromi, toi < n\n\tfromi != toi\n\t1 <= pricei <= 104\n\tThere will not be any multiple flights between two cities.\n\t0 <= src, dst, k < n\n\tsrc != dst",
        "solutions": [
            {
                "id": 115541,
                "title": "java-c-python-priority-queue-solution-tle-now",
                "content": "**Idea**\\nIt happen to be the same idea of Dijkstra\\'s algorithm, but we need to keep the path.\\n\\n**More**\\nMore helpful and detailed explanation here:\\nhttps://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\\n\\nPython\\n```py\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        f = collections.defaultdict(dict)\\n        for a, b, p in flights:\\n            f[a][b] = p\\n        heap = [(0, src, k + 1)]\\n        while heap:\\n            p, i, k = heapq.heappop(heap)\\n            if i == dst:\\n                return p\\n            if k > 0:\\n                for j in f[i]:\\n                    heapq.heappush(heap, (p + f[i][j], j, k - 1))\\n        return -1\\n```\\n\\n**Thanks @sur081547 for Java version**\\n```java\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, Map<Integer, Integer>> prices = new HashMap<>();\\n        for (int[] f : flights) {\\n            if (!prices.containsKey(f[0])) prices.put(f[0], new HashMap<>());\\n            prices.get(f[0]).put(f[1], f[2]);\\n        }\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> (Integer.compare(a[0], b[0])));\\n        pq.add(new int[] {0, src, k + 1});\\n        while (!pq.isEmpty()) {\\n            int[] top = pq.remove();\\n            int price = top[0];\\n            int city = top[1];\\n            int stops = top[2];\\n            if (city == dst) return price;\\n            if (stops > 0) {\\n                Map<Integer, Integer> adj = prices.getOrDefault(city, new HashMap<>());\\n                for (int a : adj.keySet()) {\\n                    pq.add(new int[] {price + adj.get(a), a, stops - 1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\n**C++ verison from @tensor-flower**\\n```cpp\\ntypedef tuple<int,int,int> ti;\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<pair<int,int>>>vp(n);\\n        for(const auto&f:flights)   vp[f[0]].emplace_back(f[1],f[2]);\\n        priority_queue<ti,vector<ti>,greater<ti>>pq;\\n        pq.emplace(0,src,K+1);\\n        while(!pq.empty()){\\n            auto [cost,u,stops] = pq.top();\\n            pq.pop();\\n            if(u==dst)  return cost;\\n            if(!stops)  continue;\\n            for(auto to:vp[u]){\\n                auto [v,w] = to;\\n                pq.emplace(cost+w,v,stops-1);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        f = collections.defaultdict(dict)\\n        for a, b, p in flights:\\n            f[a][b] = p\\n        heap = [(0, src, k + 1)]\\n        while heap:\\n            p, i, k = heapq.heappop(heap)\\n            if i == dst:\\n                return p\\n            if k > 0:\\n                for j in f[i]:\\n                    heapq.heappush(heap, (p + f[i][j], j, k - 1))\\n        return -1\\n```\n```java\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, Map<Integer, Integer>> prices = new HashMap<>();\\n        for (int[] f : flights) {\\n            if (!prices.containsKey(f[0])) prices.put(f[0], new HashMap<>());\\n            prices.get(f[0]).put(f[1], f[2]);\\n        }\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> (Integer.compare(a[0], b[0])));\\n        pq.add(new int[] {0, src, k + 1});\\n        while (!pq.isEmpty()) {\\n            int[] top = pq.remove();\\n            int price = top[0];\\n            int city = top[1];\\n            int stops = top[2];\\n            if (city == dst) return price;\\n            if (stops > 0) {\\n                Map<Integer, Integer> adj = prices.getOrDefault(city, new HashMap<>());\\n                for (int a : adj.keySet()) {\\n                    pq.add(new int[] {price + adj.get(a), a, stops - 1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```cpp\\ntypedef tuple<int,int,int> ti;\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<pair<int,int>>>vp(n);\\n        for(const auto&f:flights)   vp[f[0]].emplace_back(f[1],f[2]);\\n        priority_queue<ti,vector<ti>,greater<ti>>pq;\\n        pq.emplace(0,src,K+1);\\n        while(!pq.empty()){\\n            auto [cost,u,stops] = pq.top();\\n            pq.pop();\\n            if(u==dst)  return cost;\\n            if(!stops)  continue;\\n            for(auto to:vp[u]){\\n                auto [v,w] = to;\\n                pq.emplace(cost+w,v,stops-1);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361711,
                "title": "java-dfs-bfs-bellman-ford-dijkstra-s",
                "content": "Here\\'s a compilation of 4 graph algorithms.\\n1. DFS\\nPretty straightforward implementation. keep a global answer and traverse all the children of the source upto k stops. If at any point we reach the destination,store the min of the naswer and the current cost.\\n\\nCode:\\n```\\n    int ans_dfs;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        ans_dfs=Integer.MAX_VALUE;\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] i:flights)\\n        {\\n            map.putIfAbsent(i[0],new ArrayList<>());\\n            map.get(i[0]).add(new int[]{i[1],i[2]});\\n        }\\n        dfs(map,src,dst,K+1,0);\\n        return ans_dfs==Integer.MAX_VALUE?-1:ans_dfs;\\n    }\\n    public void dfs(Map<Integer,List<int[]>> map, int src, int dst, int k, int cost)\\n    {\\n        if(k<0)\\n            return;\\n        if(src==dst)\\n        {\\n            ans_dfs=cost;\\n            return;\\n        }\\n        if(!map.containsKey(src))\\n            return;\\n        for(int[] i:map.get(src))\\n        {\\n            if(cost+i[1]>ans_dfs)               //Pruning, check the sum of current price and next cost. If it\\'s greater then the ans so far, continue\\n                continue;\\n            dfs(map,i[0],dst,k-1,cost+i[1]);\\n        }\\n    }\\n```\\n\\nA few caveats, pruning the path based on the cost of next children will improve performance, remove the need of a visited set and solve the annoying TLE issue.\\n\\n2. BFS\\n\\tUnlike BFS, now we simultaneously traverse all the possible path going out from source for upto k steps. If the ans is found in between, we store the min of the current ans with the newly found one. A modification to the standard bfs design, we pass the starting cost a 0 to the queue as well and go on adding to it.\\nCode :\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] i:flights)\\n        {\\n            map.putIfAbsent(i[0],new ArrayList<>());\\n            map.get(i[0]).add(new int[]{i[1],i[2]});\\n        }\\n        int step=0;\\n        Queue<int[]> q=new LinkedList<>();\\n        q.offer(new int[]{src,0});\\n        int ans=Integer.MAX_VALUE;\\n        while(!q.isEmpty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int[] curr=q.poll();\\n                if(curr[0]==dst)\\n                    ans=Math.min(ans,curr[1]);\\n                if(!map.containsKey(curr[0]))\\n                    continue;\\n                for(int[] f:map.get(curr[0]))\\n                {\\n                    if(curr[1]+f[1]>ans)      //Pruning\\n                        continue;\\n                    q.offer(new int[]{f[0],curr[1]+f[1]});\\n                }\\n            }\\n            if(step++>K)\\n                break;\\n        }\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n```\\n\\nSimilar to DFS, I used pruning to avoid TLE and remove the need of a visited set.\\n\\n3.Bellman Ford\\n\\tMuch like BFS, run the algorithm K times, if the answer exists, it should be stored in the helper matrix\\n\\nCode\\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        int[] cost=new int[n];\\n        Arrays.fill(cost,Integer.MAX_VALUE);\\n        cost[src]=0;\\n        for(int i=0;i<=K;i++)\\n        {\\n            int[] temp= Arrays.copyOf(cost,n);\\n            for(int[] f: flights)\\n            {\\n                int curr=f[0],next=f[1],price=f[2];\\n                if(cost[curr]==Integer.MAX_VALUE)\\n                    continue;\\n                temp[next]=Math.min(temp[next],cost[curr]+price);\\n            }\\n            cost=temp;\\n        }\\n        return cost[dst]==Integer.MAX_VALUE?-1:cost[dst];\\n    }\\n```\\n\\n4.Dijkstra\\'s\\nMuch like BFS, but use a PriorityQueue based on the cheapest cost. Incorporate the stop limit to individual paths to traverse upto k stops.\\ncredit to @lee215 for the solution\\n\\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) \\n    {\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] f:flights)\\n        {\\n            map.putIfAbsent(f[0],new ArrayList<>());\\n            map.get(f[0]).add(new int[]{f[1],f[2]});\\n        }\\n        PriorityQueue<int[]> q=new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Integer.compare(o1[0],o2[0]);\\n            }\\n        });\\n        q.offer(new int[]{0,src,K+1});\\n        while(!q.isEmpty())\\n        {\\n            int[] c=q.poll();\\n            int cost=c[0];\\n            int curr=c[1];\\n            int stop=c[2];\\n            if(curr==dst)\\n                return cost;\\n            if(stop>0)\\n            {\\n                if(!map.containsKey(curr))\\n                    continue;\\n                for(int[] next:map.get(curr))\\n                {\\n                    q.add(new int[]{cost+next[1],next[0],stop-1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\t\\n\\n\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\n    int ans_dfs;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        ans_dfs=Integer.MAX_VALUE;\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] i:flights)\\n        {\\n            map.putIfAbsent(i[0],new ArrayList<>());\\n            map.get(i[0]).add(new int[]{i[1],i[2]});\\n        }\\n        dfs(map,src,dst,K+1,0);\\n        return ans_dfs==Integer.MAX_VALUE?-1:ans_dfs;\\n    }\\n    public void dfs(Map<Integer,List<int[]>> map, int src, int dst, int k, int cost)\\n    {\\n        if(k<0)\\n            return;\\n        if(src==dst)\\n        {\\n            ans_dfs=cost;\\n            return;\\n        }\\n        if(!map.containsKey(src))\\n            return;\\n        for(int[] i:map.get(src))\\n        {\\n            if(cost+i[1]>ans_dfs)               //Pruning, check the sum of current price and next cost. If it\\'s greater then the ans so far, continue\\n                continue;\\n            dfs(map,i[0],dst,k-1,cost+i[1]);\\n        }\\n    }\\n```\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] i:flights)\\n        {\\n            map.putIfAbsent(i[0],new ArrayList<>());\\n            map.get(i[0]).add(new int[]{i[1],i[2]});\\n        }\\n        int step=0;\\n        Queue<int[]> q=new LinkedList<>();\\n        q.offer(new int[]{src,0});\\n        int ans=Integer.MAX_VALUE;\\n        while(!q.isEmpty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int[] curr=q.poll();\\n                if(curr[0]==dst)\\n                    ans=Math.min(ans,curr[1]);\\n                if(!map.containsKey(curr[0]))\\n                    continue;\\n                for(int[] f:map.get(curr[0]))\\n                {\\n                    if(curr[1]+f[1]>ans)      //Pruning\\n                        continue;\\n                    q.offer(new int[]{f[0],curr[1]+f[1]});\\n                }\\n            }\\n            if(step++>K)\\n                break;\\n        }\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n```\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        int[] cost=new int[n];\\n        Arrays.fill(cost,Integer.MAX_VALUE);\\n        cost[src]=0;\\n        for(int i=0;i<=K;i++)\\n        {\\n            int[] temp= Arrays.copyOf(cost,n);\\n            for(int[] f: flights)\\n            {\\n                int curr=f[0],next=f[1],price=f[2];\\n                if(cost[curr]==Integer.MAX_VALUE)\\n                    continue;\\n                temp[next]=Math.min(temp[next],cost[curr]+price);\\n            }\\n            cost=temp;\\n        }\\n        return cost[dst]==Integer.MAX_VALUE?-1:cost[dst];\\n    }\\n```\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) \\n    {\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] f:flights)\\n        {\\n            map.putIfAbsent(f[0],new ArrayList<>());\\n            map.get(f[0]).add(new int[]{f[1],f[2]});\\n        }\\n        PriorityQueue<int[]> q=new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Integer.compare(o1[0],o2[0]);\\n            }\\n        });\\n        q.offer(new int[]{0,src,K+1});\\n        while(!q.isEmpty())\\n        {\\n            int[] c=q.poll();\\n            int cost=c[0];\\n            int curr=c[1];\\n            int stop=c[2];\\n            if(curr==dst)\\n                return cost;\\n            if(stop>0)\\n            {\\n                if(!map.containsKey(curr))\\n                    continue;\\n                for(int[] next:map.get(curr))\\n                {\\n                    q.add(new int[]{cost+next[1],next[0],stop-1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115596,
                "title": "c-8-line-bellman-ford",
                "content": "```\nclass Solution {\npublic:\n    //bellman ford.\n    //just run it k+1 iterations.\n    int findCheapestPrice(int n, vector<vector<int>>& a, int src, int sink, int k) {\n        \n        vector<int> c(n, 1e8);\n        c[src] = 0;\n        \n        for(int z=0; z<=k; z++){\n            vector<int> C(c);\n            for(auto e: a)\n                C[e[1]] = min(C[e[1]], c[e[0]] + e[2]);\n            c = C;\n        }\n        return c[sink] == 1e8 ? -1 : c[sink];\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    //bellman ford.\n    //just run it k+1 iterations.\n    int findCheapestPrice(int n, vector<vector<int>>& a, int src, int sink, int k) {\n        \n        vector<int> c(n, 1e8);\n        c[src] = 0;\n        \n        for(int z=0; z<=k; z++){\n            vector<int> C(c);\n            for(auto e: a)\n                C[e[1]] = min(C[e[1]], c[e[0]] + e[2]);\n            c = C;\n        }\n        return c[sink] == 1e8 ? -1 : c[sink];\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 662812,
                "title": "c-bfs-bellman-ford-algo-dijkstra-algo",
                "content": "I check many posts in discussion forum but none of them were clear, consise and more readable. Here\\'s my solution:\\n\\nIf you find this post useful then **upvote** so that more people can see. Please comment if you have any doubt and I\\'ll try to improve this post.\\n\\nAlgos used are already well known so didn\\'t tried to explain it.\\n\\n1. BFS\\n```\\nint findCheapestPrice( int n, vector<vector<int>>& flights, int src, int dst, int K ) { \\n\\t// Create adjList\\n\\tunordered_map<int, vector< pair<int,int> > > adjList;\\n\\tfor( auto flight : flights )\\n\\t\\tadjList[flight[0]].push_back( { flight[1], flight[2] } );\\n\\n\\t/* BFS starting from src */\\n\\tqueue< pair<int,int> > q; // < node, dist_from_src > pair\\n\\tq.push( { src, 0 } );\\n\\tint srcToTgtDist = INT_MAX; // result\\n\\n\\twhile( !q.empty() && K-- >= 0 ) {\\n\\t\\tint size = q.size();\\n\\t\\tfor( int i = 0; i < size; i++ ) {\\n\\t\\t\\tauto curr = q.front(); q.pop();         \\n\\t\\t\\tfor( auto nbr : adjList[curr.first] ) {\\n\\t\\t\\t\\tif( srcToTgtDist < curr.second + nbr.second ) continue;\\n\\n\\t\\t\\t\\tq.push( { nbr.first, curr.second + nbr.second } );\\n\\n\\t\\t\\t\\t// update distance from src to dst\\n\\t\\t\\t\\tif( dst == nbr.first ) \\n\\t\\t\\t\\t\\tsrcToTgtDist = min( srcToTgtDist, curr.second + nbr.second );\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn srcToTgtDist == INT_MAX ? -1 : srcToTgtDist;\\n}\\n```\\n\\n2. Bellman-Ford Algorithm\\n\\n```\\n    /*  In bellman-ford algo calculates the shortest distance from the source\\n        point to all of the vertices.\\n        Time complexity of Bellman-Ford is O(VE),\\n    */\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        /* distance from source to all other nodes */\\n        vector<int> dist( n, INT_MAX );\\n        dist[src] = 0;\\n        \\n        // Run only K+1 times since we want shortest distance in K hops\\n        for( int i=0; i <= K; i++ ) {\\n            vector<int> tmp( dist );\\n            for( auto flight : flights ) {\\n                if( dist[ flight[0] ] != INT_MAX ) {\\n                    tmp[ flight[1] ] = min( tmp[flight[1]], dist[ flight[0] ] + flight[2] );\\n                }\\n            }\\n            dist = tmp;\\n        }\\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\\n    }\\n```\\n\\n3. Dijkstra Algo\\n```\\n    /* Dijkstra\\u2019s Algorithm allows you to calculate the shortest path between \\n    one node of your choosing and every other node in a graph. \\n    \\n    Given a graph and a source vertex in the graph, find shortest paths from source\\n    to all vertices in the given graph.\\n    \\n    We generate a SPT (shortest path tree) with given source as root. We maintain\\n    two sets, one set contains vertices included in shortest path tree, other set\\n    includes vertices not yet included in shortest path tree. At every step of the\\n    algorithm, we find a vertex which is in the other set (set of not yet included)\\n    and has a minimum distance from the source.\\n    \\n    Time Complexity:  If we take a closer look, we can observe that the statements\\n    in inner loop are executed O(V+E) times (similar to BFS).\\n    So overall time complexity is O(E+V)*O(LogV) which is O((E+V)*LogV) = O(ELogV)\\n    */\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        // create adjacency list\\n        unordered_map<int,vector<pair<int, int>>> adjList;\\n        for( auto f : flights )\\n            adjList[f[0]].push_back( { f[1], f[2] } );\\n        \\n        // minHeap based on cost of distance from source\\n        priority_queue< vector<int>, vector<vector<int>>, greater<vector<int>> > minHeap;\\n        minHeap.push( { 0, src, K+1 } ); // cost, vertex, hops\\n        \\n        while( !minHeap.empty() ) {\\n            auto t = minHeap.top(); minHeap.pop();\\n            int cost = t[0];\\n            int curr = t[1];\\n            int stop = t[2];\\n            if( curr == dst )\\n                return cost;\\n\\n            if( stop > 0 )\\n                for( auto next : adjList[curr] )\\n                    minHeap.push( { cost+next.second, next.first, stop-1 } );\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nint findCheapestPrice( int n, vector<vector<int>>& flights, int src, int dst, int K ) { \\n\\t// Create adjList\\n\\tunordered_map<int, vector< pair<int,int> > > adjList;\\n\\tfor( auto flight : flights )\\n\\t\\tadjList[flight[0]].push_back( { flight[1], flight[2] } );\\n\\n\\t/* BFS starting from src */\\n\\tqueue< pair<int,int> > q; // < node, dist_from_src > pair\\n\\tq.push( { src, 0 } );\\n\\tint srcToTgtDist = INT_MAX; // result\\n\\n\\twhile( !q.empty() && K-- >= 0 ) {\\n\\t\\tint size = q.size();\\n\\t\\tfor( int i = 0; i < size; i++ ) {\\n\\t\\t\\tauto curr = q.front(); q.pop();         \\n\\t\\t\\tfor( auto nbr : adjList[curr.first] ) {\\n\\t\\t\\t\\tif( srcToTgtDist < curr.second + nbr.second ) continue;\\n\\n\\t\\t\\t\\tq.push( { nbr.first, curr.second + nbr.second } );\\n\\n\\t\\t\\t\\t// update distance from src to dst\\n\\t\\t\\t\\tif( dst == nbr.first ) \\n\\t\\t\\t\\t\\tsrcToTgtDist = min( srcToTgtDist, curr.second + nbr.second );\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn srcToTgtDist == INT_MAX ? -1 : srcToTgtDist;\\n}\\n```\n```\\n    /*  In bellman-ford algo calculates the shortest distance from the source\\n        point to all of the vertices.\\n        Time complexity of Bellman-Ford is O(VE),\\n    */\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        /* distance from source to all other nodes */\\n        vector<int> dist( n, INT_MAX );\\n        dist[src] = 0;\\n        \\n        // Run only K+1 times since we want shortest distance in K hops\\n        for( int i=0; i <= K; i++ ) {\\n            vector<int> tmp( dist );\\n            for( auto flight : flights ) {\\n                if( dist[ flight[0] ] != INT_MAX ) {\\n                    tmp[ flight[1] ] = min( tmp[flight[1]], dist[ flight[0] ] + flight[2] );\\n                }\\n            }\\n            dist = tmp;\\n        }\\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\\n    }\\n```\n```\\n    /* Dijkstra\\u2019s Algorithm allows you to calculate the shortest path between \\n    one node of your choosing and every other node in a graph. \\n    \\n    Given a graph and a source vertex in the graph, find shortest paths from source\\n    to all vertices in the given graph.\\n    \\n    We generate a SPT (shortest path tree) with given source as root. We maintain\\n    two sets, one set contains vertices included in shortest path tree, other set\\n    includes vertices not yet included in shortest path tree. At every step of the\\n    algorithm, we find a vertex which is in the other set (set of not yet included)\\n    and has a minimum distance from the source.\\n    \\n    Time Complexity:  If we take a closer look, we can observe that the statements\\n    in inner loop are executed O(V+E) times (similar to BFS).\\n    So overall time complexity is O(E+V)*O(LogV) which is O((E+V)*LogV) = O(ELogV)\\n    */\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        // create adjacency list\\n        unordered_map<int,vector<pair<int, int>>> adjList;\\n        for( auto f : flights )\\n            adjList[f[0]].push_back( { f[1], f[2] } );\\n        \\n        // minHeap based on cost of distance from source\\n        priority_queue< vector<int>, vector<vector<int>>, greater<vector<int>> > minHeap;\\n        minHeap.push( { 0, src, K+1 } ); // cost, vertex, hops\\n        \\n        while( !minHeap.empty() ) {\\n            auto t = minHeap.top(); minHeap.pop();\\n            int cost = t[0];\\n            int curr = t[1];\\n            int stop = t[2];\\n            if( curr == dst )\\n                return cost;\\n\\n            if( stop > 0 )\\n                for( auto next : adjList[curr] )\\n                    minHeap.push( { cost+next.second, next.first, stop-1 } );\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099885,
                "title": "day-26-simple-bfs-easiest-beginner-friendly-solution",
                "content": "# Intuition of this Problem\\nWe can solve this problem using various ways:\\n- **Dijkstra Algorithm** - Time Complexity - O(V^2)\\n- **Floyd Warshall Algoithm** - Time Complexity - O(v^3)\\n- **Bellman Ford Algorithm** - Time Complexity - O(V^3)\\n\\nI used **simple BFS** to solve the problem. For furhter optimization in this solution we can use priority queue. But In this solution I didn\\'t use.\\n\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem\\n1. Initialize an adjacency list with the given flights information, where each index i represents the node i, and the corresponding value is a list of pairs (neighbor, price) representing the edges from node i to its neighboring nodes and the price of the flight.\\n2. Initialize a queue with the source node and its cost (0) and a vector minCost with the same size as the number of nodes, where each index i represents the minimum cost to reach node i and the corresponding value is initialized to INT_MAX.\\n3. Create a variable stops and initialize it to 0.\\n4. Start a while loop until the queue is not empty and stops are less than or equal to k (maximum stops allowed).\\n5. In the while loop, create a variable size equal to the size of the queue.\\n6. Start another while loop with the size of the queue.\\n7. In the inner while loop, pop the front element from the queue and assign it to a variable (currNode, cost).\\n8. Iterate through the neighbors and price of the current node from the adjacency list.\\n9. If the total cost to reach the neighbor is greater than or equal to the minimum cost to reach the neighbor, continue to the next iteration.\\n10. Else, update the minimum cost to reach the neighbor as the total cost and push the neighbor and its cost to the queue.\\n11. End the inner while loop and increment the stops by 1.\\n12. End the outer while loop.\\n13. If the minimum cost to reach the destination is still INT_MAX, return -1, otherwise, return the minimum cost to reach the destination.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto flight : flights){\\n            // flight[0] represent node i, flight[1] represent neighbor node of node i, flight[2] represent cost between node i to neighbor node\\n            adj[flight[0]].push_back({flight[1], flight[2]});\\n        }\\n        //it will store [node, cost]\\n        queue<pair<int, int>> q;\\n        q.push({src, 0});\\n        //it will store minimum cost to reach each node\\n        vector<int> minCost(n, INT_MAX);\\n        int stops = 0;\\n        while(!q.empty() && stops <= k){\\n            int size = q.size();\\n            while (size--) {\\n                auto [currNode, cost] = q.front();\\n                q.pop();\\n                for (auto& [neighbour, price] : adj[currNode]) {\\n                    if (price + cost < minCost[neighbour]){\\n                        minCost[neighbour] = price + cost;\\n                        q.push({neighbour, minCost[neighbour]});\\n                    }\\n                }\\n            }\\n            stops++;\\n        }\\n        if(minCost[dst] == INT_MAX)\\n            return -1;\\n        return minCost[dst];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        List<List<int[]>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\\n        for (int[] flight : flights) {\\n            adj.get(flight[0]).add(new int[] {flight[1], flight[2]});\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[] {src, 0});\\n        int[] minCost = new int[n];\\n        Arrays.fill(minCost, Integer.MAX_VALUE);\\n        int stops = 0;\\n        while (!q.isEmpty() && stops <= k) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] curr = q.poll();\\n                for (int[] neighbour : adj.get(curr[0])) {\\n                    int price = neighbour[1], neighbourNode = neighbour[0];\\n                    if (price + curr[1] >= minCost[neighbourNode]) continue;\\n                    minCost[neighbourNode] = price + curr[1];\\n                    q.offer(new int[] {neighbourNode, minCost[neighbourNode]});\\n                }\\n            }\\n            stops++;\\n        }\\n        return minCost[dst] == Integer.MAX_VALUE ? -1 : minCost[dst];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        adj = [[] for _ in range(n)]\\n        for flight in flights:\\n            adj[flight[0]].append((flight[1], flight[2]))\\n        \\n        q = [(src, 0)]\\n        minCost = [float(\\'inf\\') for _ in range(n)]\\n        stops = 0\\n        \\n        while q and stops <= k:\\n            size = len(q)\\n            for i in range(size):\\n                currNode, cost = q.pop(0)\\n                for neighbour, price in adj[currNode]:\\n                    if price + cost >= minCost[neighbour]:\\n                        continue\\n                    minCost[neighbour] = price + cost\\n                    q.append((neighbour, minCost[neighbour]))\\n            stops += 1\\n        \\n        return -1 if minCost[dst] == float(\\'inf\\') else minCost[dst]\\n\\n```\\n\\n# Time Complexity and Space Complexity\\n- Time complexity: **O(V + E*K)**\\nThe time complexity of this code is O(V + E*K) where E is the number of flights, and V is the number of cities. The reason for this is that the outer while loop runs for at most V iterations, and in each iteration, the inner while loop runs for at most E iterations.However, the maximum number of times an edge can be processed is limited by K.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(V + E)**\\nhe space complexity of this code is O(V + E), as it uses two data structures to store the graph (a list of lists) and the minimum cost to reach each node (an array of integers). The queue used to keep track of the next node to visit also takes up O(V) space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto flight : flights){\\n            // flight[0] represent node i, flight[1] represent neighbor node of node i, flight[2] represent cost between node i to neighbor node\\n            adj[flight[0]].push_back({flight[1], flight[2]});\\n        }\\n        //it will store [node, cost]\\n        queue<pair<int, int>> q;\\n        q.push({src, 0});\\n        //it will store minimum cost to reach each node\\n        vector<int> minCost(n, INT_MAX);\\n        int stops = 0;\\n        while(!q.empty() && stops <= k){\\n            int size = q.size();\\n            while (size--) {\\n                auto [currNode, cost] = q.front();\\n                q.pop();\\n                for (auto& [neighbour, price] : adj[currNode]) {\\n                    if (price + cost < minCost[neighbour]){\\n                        minCost[neighbour] = price + cost;\\n                        q.push({neighbour, minCost[neighbour]});\\n                    }\\n                }\\n            }\\n            stops++;\\n        }\\n        if(minCost[dst] == INT_MAX)\\n            return -1;\\n        return minCost[dst];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        List<List<int[]>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\\n        for (int[] flight : flights) {\\n            adj.get(flight[0]).add(new int[] {flight[1], flight[2]});\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[] {src, 0});\\n        int[] minCost = new int[n];\\n        Arrays.fill(minCost, Integer.MAX_VALUE);\\n        int stops = 0;\\n        while (!q.isEmpty() && stops <= k) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] curr = q.poll();\\n                for (int[] neighbour : adj.get(curr[0])) {\\n                    int price = neighbour[1], neighbourNode = neighbour[0];\\n                    if (price + curr[1] >= minCost[neighbourNode]) continue;\\n                    minCost[neighbourNode] = price + curr[1];\\n                    q.offer(new int[] {neighbourNode, minCost[neighbourNode]});\\n                }\\n            }\\n            stops++;\\n        }\\n        return minCost[dst] == Integer.MAX_VALUE ? -1 : minCost[dst];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        adj = [[] for _ in range(n)]\\n        for flight in flights:\\n            adj[flight[0]].append((flight[1], flight[2]))\\n        \\n        q = [(src, 0)]\\n        minCost = [float(\\'inf\\') for _ in range(n)]\\n        stops = 0\\n        \\n        while q and stops <= k:\\n            size = len(q)\\n            for i in range(size):\\n                currNode, cost = q.pop(0)\\n                for neighbour, price in adj[currNode]:\\n                    if price + cost >= minCost[neighbour]:\\n                        continue\\n                    minCost[neighbour] = price + cost\\n                    q.append((neighbour, minCost[neighbour]))\\n            stops += 1\\n        \\n        return -1 if minCost[dst] == float(\\'inf\\') else minCost[dst]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267200,
                "title": "python-dijkstra",
                "content": "A good case to practice Dijkstra.\\n\\nTo implement Dijkstra, we need a priority queue to pop out the lowest weight node for next search. In this case, the weight would be the accumulated flight cost. So my node takes a form of `(cost, src, k)`. `cost` is the accumulated cost, `src` is the current node\\'s location, `k`  is stop times we left as we only have at most K stops. I also convert ```edges``` to an adjacent list based graph `g`.\\n\\nUse a `vis` array to maintain visited nodes to avoid loop. `vis[x]` record the remaining steps to reach x with the lowest cost. If `vis[x] >= k`, then no need to visit that case `(start from x with k steps left)` as a better solution has been visited before (more remaining step and lower cost as heappopped beforehand). And we should initialize `vis[x]` to `0` to ensure visit always stop at a negative `k`.\\n\\nOnce `k` is used up (`k == 0`) or `vis[x] >= k`, we no longer push that node `x` to our queue. Once a popped cost is our destination, we get our lowest valid cost.\\n\\nFor Dijkstra, there is not need to maintain a ```best cost``` for each node since it\\'s kind of greedy search. It always chooses the lowest cost node for next search. So the previous searched node always has a lower cost and has no chance to be updated. The first time we pop our destination from our queue, we have found the lowest cost to our destination.\\n```\\ndef findCheapestPrice(n, flights, src, dst, K):\\n\\tgraph = collections.defaultdict(dict)\\n\\tfor s, d, w in flights:\\n\\t\\tgraph[s][d] = w\\n\\tpq = [(0, src, K+1)]\\n\\tvis = [0] * n\\n\\twhile pq:\\n\\t\\tw, x, k = heapq.heappop(pq)\\n\\t\\tif x == dst:\\n\\t\\t\\treturn w\\n\\t\\tif vis[x] >= k:\\n\\t\\t\\tcontinue\\n\\t\\tvis[x] = k\\n\\t\\tfor y, dw in graph[x].items():\\n\\t\\t\\theapq.heappush(pq, (w+dw, y, k-1))\\n\\treturn -1\\n```\\nPython heapq doesn\\'t support update heap node\\'s weight. But if you implement your own heap structure and support that function, you can maintain a n-size heap and time complexity is O((m + n)logn). m is number of edges and n is number of nodes. And it can be improved to O(m + nlogn) with a Fibonacci heap where a delete min costs logn but an update cost costs constant time.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```edges```\n```best cost```\n```\\ndef findCheapestPrice(n, flights, src, dst, K):\\n\\tgraph = collections.defaultdict(dict)\\n\\tfor s, d, w in flights:\\n\\t\\tgraph[s][d] = w\\n\\tpq = [(0, src, K+1)]\\n\\tvis = [0] * n\\n\\twhile pq:\\n\\t\\tw, x, k = heapq.heappop(pq)\\n\\t\\tif x == dst:\\n\\t\\t\\treturn w\\n\\t\\tif vis[x] >= k:\\n\\t\\t\\tcontinue\\n\\t\\tvis[x] = k\\n\\t\\tfor y, dw in graph[x].items():\\n\\t\\t\\theapq.heappush(pq, (w+dw, y, k-1))\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 340911,
                "title": "understanding-bellman-ford",
                "content": "Actually Bellman Ford is a space optimized version of 2D Dynamic Programming Solution.\\n\\nTo understand Bellman Ford you need to understand the 2D version first.\\n\\ndp[v, k] = Shortest path from src to v using atmost k edges\\n\\ndp[v, k] = {Minimum dist over all u belonging to all vertices which are coming towards v(in the indegree[v])} min(dp[u, k-1] + w(u->v)).\\ndp[u, k-1] becoz we have to reach to u using atmost k-1 edges. As we have to reach v using atmost k edges.\\n\\nSimilarly dp[u, k-1] = (p belongs to indegree[u]) min(dp[p, k-2] + w(p->u)).\\n\\nWhy doesn\\'t Space optimized version work for atmost K edges case?\\n\\n![image](https://assets.leetcode.com/users/david_maverick/image_1563773352.png)\\n\\nUsing above example.\\n\\nThe space optimized version will depend on order of visiting the edges.\\n\\nSuppose the order in which we relax edges is:\\n0->1\\n1->2\\n0->2\\n\\nSo after 1 round of relaxation\\n\\nDistances will be 0->1 = 100\\n\\t\\t\\t\\t\\t\\t\\t0->2 = 200\\nWhich is wrong as using atmost 1 edge the distance from 0->2 should be 500.\\nThe 1D version is agnostic to the order in which we visit edges.\\n\\nNote: K Stops = K + 1 edges\\n\\n```\\nclass Solution\\n{\\npublic:\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\\n    {        \\n        vector<vector<int>> dp(K+2, vector<int>(n, INT_MAX));\\n        \\n        //dp[i][j] = Dist to reach j using atmost i edges from src\\n        \\n        for(int i = 0; i <= K+1; i++)\\n        {\\n            dp[i][src] = 0; // Dist to reach src always zero\\n        }\\n        \\n        for(int i = 1; i <= K+1; i++)\\n        {\\n            for(auto &f: flights)\\n            {\\n                //Using indegree\\n                int u = f[0];\\n                int v = f[1];\\n                int w = f[2];\\n                \\n                if(dp[i-1][u] != INT_MAX)\\n                    dp[i][v] = min(dp[i][v], dp[i-1][u] + w);\\n            }\\n        }\\n        \\n        return (dp[K+1][dst] == INT_MAX)? -1: dp[K+1][dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\\n    {        \\n        vector<vector<int>> dp(K+2, vector<int>(n, INT_MAX));\\n        \\n        //dp[i][j] = Dist to reach j using atmost i edges from src\\n        \\n        for(int i = 0; i <= K+1; i++)\\n        {\\n            dp[i][src] = 0; // Dist to reach src always zero\\n        }\\n        \\n        for(int i = 1; i <= K+1; i++)\\n        {\\n            for(auto &f: flights)\\n            {\\n                //Using indegree\\n                int u = f[0];\\n                int v = f[1];\\n                int w = f[2];\\n                \\n                if(dp[i-1][u] != INT_MAX)\\n                    dp[i][v] = min(dp[i][v], dp[i-1][u] + w);\\n            }\\n        }\\n        \\n        return (dp[K+1][dst] == INT_MAX)? -1: dp[K+1][dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128217,
                "title": "three-c-solutions-bfs-dfs-and-bf",
                "content": "#### 1. DFS \\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n       unordered_map<int, vector<pair<int,int>>> g;\\n       for (const auto& e : flights)\\n            g[e[0]].emplace_back(e[1], e[2]);        \\n        int ans = INT_MAX;\\n        vector<int> visited(n,0);\\n        dfs(s, d, K + 1, 0, visited, ans, g);\\n        return ans == INT_MAX ? - 1 : ans;\\n    }\\n    \\n    void dfs(int s, int d, int k, int cost, vector<int>& visited, int& ans, unordered_map<int, vector<pair<int,int>>>& g ) {\\n        if (s == d) { ans = cost; return; }\\n        if (k == 0) return; \\n        visited[s]=1;\\n        for (const auto& x : g[s]) {\\n          if (visited[x.first]==0){\\n              if (cost + x.second > ans) continue; // IMPORTANT!!! prunning \\n     \\n              dfs(x.first, d, k - 1, cost + x.second, visited, ans, g); \\n             \\n          }\\n        }\\n         visited[s] = 0;\\n  }\\n```\\n#### 2. BFS\\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n       unordered_map<int, vector<pair<int,int>>> g;\\n       for (const auto& e : flights)\\n            g[e[0]].emplace_back(e[1], e[2]);        \\n        int ans = INT_MAX;\\n        queue<pair<int,int>> q;q.push({s,0}); \\n        int steps =0; \\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i=0; i<n; ++i){\\n             auto curr=q.front();q.pop();\\n            if(curr.first == d) ans = min(ans, curr.second);   \\n            for(auto x:  g[curr.first]){             \\n               if( curr.second + x.second > ans) continue;\\n                q.push({x.first,curr.second + x.second });\\n             }  \\n            }\\n          if(steps++ > K) break;\\n        }\\n        \\n        return ans == INT_MAX ? - 1 : ans;\\n    } \\n```\\n#### 3. BF\\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n        const int INF = 1e9;\\n        vector<vector<int>> dp(K + 2, vector<int>(n, INF));\\n        dp[0][s] = 0;        \\n         for (int i = 1; i <= K + 1; ++i) {\\n            dp[i][s] = 0;\\n            for (const auto& x : flights)\\n                  dp[i][x[1]] = min(dp[i][x[1]], dp[i-1][x[0]] + x[2]);    \\n            }\\n            return dp[K + 1][d] >= INF ? -1 : dp[K + 1][d];\\n            \\n        } \\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n       unordered_map<int, vector<pair<int,int>>> g;\\n       for (const auto& e : flights)\\n            g[e[0]].emplace_back(e[1], e[2]);        \\n        int ans = INT_MAX;\\n        vector<int> visited(n,0);\\n        dfs(s, d, K + 1, 0, visited, ans, g);\\n        return ans == INT_MAX ? - 1 : ans;\\n    }\\n    \\n    void dfs(int s, int d, int k, int cost, vector<int>& visited, int& ans, unordered_map<int, vector<pair<int,int>>>& g ) {\\n        if (s == d) { ans = cost; return; }\\n        if (k == 0) return; \\n        visited[s]=1;\\n        for (const auto& x : g[s]) {\\n          if (visited[x.first]==0){\\n              if (cost + x.second > ans) continue; // IMPORTANT!!! prunning \\n     \\n              dfs(x.first, d, k - 1, cost + x.second, visited, ans, g); \\n             \\n          }\\n        }\\n         visited[s] = 0;\\n  }\\n```\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n       unordered_map<int, vector<pair<int,int>>> g;\\n       for (const auto& e : flights)\\n            g[e[0]].emplace_back(e[1], e[2]);        \\n        int ans = INT_MAX;\\n        queue<pair<int,int>> q;q.push({s,0}); \\n        int steps =0; \\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i=0; i<n; ++i){\\n             auto curr=q.front();q.pop();\\n            if(curr.first == d) ans = min(ans, curr.second);   \\n            for(auto x:  g[curr.first]){             \\n               if( curr.second + x.second > ans) continue;\\n                q.push({x.first,curr.second + x.second });\\n             }  \\n            }\\n          if(steps++ > K) break;\\n        }\\n        \\n        return ans == INT_MAX ? - 1 : ans;\\n    } \\n```\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n        const int INF = 1e9;\\n        vector<vector<int>> dp(K + 2, vector<int>(n, INF));\\n        dp[0][s] = 0;        \\n         for (int i = 1; i <= K + 1; ++i) {\\n            dp[i][s] = 0;\\n            for (const auto& x : flights)\\n                  dp[i][x[1]] = min(dp[i][x[1]], dp[i-1][x[0]] + x[2]);    \\n            }\\n            return dp[K + 1][d] >= INF ? -1 : dp[K + 1][d];\\n            \\n        } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686829,
                "title": "c-easy-beginner-friendly",
                "content": "```\\n// 1st approach\\n int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n    //1. Create an Adjacency List\\n        vector<vector<vector<int>>> adjList(n);\\n        \\n        //example :\\n        //0 : {1, 100}, {2, 500}\\n        //1 : {2, 100}\\n        //2 : \\n        \\n        \\n        for(auto f : flights) {\\n            int from = f[0];\\n            int to = f[1];\\n            int cost = f[2];\\n            adjList[from].push_back({to, cost});\\n            //from : source\\n            //to : dest \\n            //cost: cost from \\'from\\' to \\'to\\'\\n        }\\n        \\n        \\n    //2. Create a queue for performing BFS\\n        queue<vector<int>> q;\\n        \\n     //3. Push source in q as {src, money spent so far, number of stops b/w current city and source}\\n        q.push({src, 0, -1});\\n        //Note : if {A, B} are two directly connected cities, then number of stops b/w them is Zero,\\n        //so for convenience i\\'m assuming number of stops b/w A and A as -1\\n        \\n     int minCost = INT_MAX;   //this keeps track of minimum cost\\n    \\n        \\n     while(!q.empty()) {\\n            vector<int> curStation = q.front(); q.pop();\\n         \\n            int curCity = curStation[0];\\n            int curCost = curStation[1];\\n            int curK = curStation[2];      //this is the number of stops seen so far from source to current city\\n         \\n            if(curCity == dst) {\\n              minCost = min(minCost, curCost);\\n              continue;  \\n            }\\n             \\n         \\n            for(auto p : adjList[curCity]) {\\n                //we include a city in our route only if :\\n                // > it doesn\\'t exceed number of stops alloted\\n                // > it keeps cost less than mincost\\n\\t\\t\\t\\t//***\\n                if(curK+1 <= k and curCost + p[1] < minCost)\\n                q.push({p[0], p[1] + curCost, curK+1});\\n            } \\n         \\n     }   \\n        \\n     return minCost==INT_MAX?-1:minCost;   \\n    }\\n\\t\\n// ***\\n// We could have just normally pushed cities and tested the conditons at the time of popping them from q\\n//But what we did is more effecient bcoz, this prevents from inserting the false cities beforehand and keeps the size of q small, (simply, we are saving many PUSH and POP operations).\\n\\n// -------------------------------------------------------------------\\n// 2nd Approach\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        vector<vector< pair<int,int> >> graph(n);\\n        for( auto edge: flights ){\\n            graph[edge[0]].push_back( {edge[1],edge[2]} );\\n        }\\n        \\n        vector<int> dist(n,pow(10,4)*n) , prev(n);\\n        dist[src] = 0;\\n        prev = dist;\\n        k++;\\n        while( k-- ){\\n            for( int i = 0 ; i < n ; i++ ){\\n                for( int j = 0; j < graph[i].size(); j++ ){\\n                    int index = graph[i][j].first;\\n                    int value = graph[i][j].second;\\n                    // at x\\'th step there can be more than one updates\\n                    // so we compare the update value, of the index \\n                    // gettting updated \\n                    if( dist[ index ] > prev[i] + value ){\\n                        dist[ index ] = prev[i] + value;\\n                    }\\n                }\\n            }\\n            prev = dist;\\n        }\\n        if( prev[dst] == pow(10,4)*n ){\\n            return -1;\\n        }\\n        return prev[dst];\\n    }",
                "solutionTags": [],
                "code": "```\\n// 1st approach\\n int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n    //1. Create an Adjacency List\\n        vector<vector<vector<int>>> adjList(n);\\n        \\n        //example :\\n        //0 : {1, 100}, {2, 500}\\n        //1 : {2, 100}\\n        //2 : \\n        \\n        \\n        for(auto f : flights) {\\n            int from = f[0];\\n            int to = f[1];\\n            int cost = f[2];\\n            adjList[from].push_back({to, cost});\\n            //from : source\\n            //to : dest \\n            //cost: cost from \\'from\\' to \\'to\\'\\n        }\\n        \\n        \\n    //2. Create a queue for performing BFS\\n        queue<vector<int>> q;\\n        \\n     //3. Push source in q as {src, money spent so far, number of stops b/w current city and source}\\n        q.push({src, 0, -1});\\n        //Note : if {A, B} are two directly connected cities, then number of stops b/w them is Zero,\\n        //so for convenience i\\'m assuming number of stops b/w A and A as -1\\n        \\n     int minCost = INT_MAX;   //this keeps track of minimum cost\\n    \\n        \\n     while(!q.empty()) {\\n            vector<int> curStation = q.front(); q.pop();\\n         \\n            int curCity = curStation[0];\\n            int curCost = curStation[1];\\n            int curK = curStation[2];      //this is the number of stops seen so far from source to current city\\n         \\n            if(curCity == dst) {\\n              minCost = min(minCost, curCost);\\n              continue;  \\n            }\\n             \\n         \\n            for(auto p : adjList[curCity]) {\\n                //we include a city in our route only if :\\n                // > it doesn\\'t exceed number of stops alloted\\n                // > it keeps cost less than mincost\\n\\t\\t\\t\\t//***\\n                if(curK+1 <= k and curCost + p[1] < minCost)\\n                q.push({p[0], p[1] + curCost, curK+1});\\n            } \\n         \\n     }   \\n        \\n     return minCost==INT_MAX?-1:minCost;   \\n    }\\n\\t\\n// ***\\n// We could have just normally pushed cities and tested the conditons at the time of popping them from q\\n//But what we did is more effecient bcoz, this prevents from inserting the false cities beforehand and keeps the size of q small, (simply, we are saving many PUSH and POP operations).\\n\\n// -------------------------------------------------------------------\\n// 2nd Approach\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        vector<vector< pair<int,int> >> graph(n);\\n        for( auto edge: flights ){\\n            graph[edge[0]].push_back( {edge[1],edge[2]} );\\n        }\\n        \\n        vector<int> dist(n,pow(10,4)*n) , prev(n);\\n        dist[src] = 0;\\n        prev = dist;\\n        k++;\\n        while( k-- ){\\n            for( int i = 0 ; i < n ; i++ ){\\n                for( int j = 0; j < graph[i].size(); j++ ){\\n                    int index = graph[i][j].first;\\n                    int value = graph[i][j].second;\\n                    // at x\\'th step there can be more than one updates\\n                    // so we compare the update value, of the index \\n                    // gettting updated \\n                    if( dist[ index ] > prev[i] + value ){\\n                        dist[ index ] = prev[i] + value;\\n                    }\\n                }\\n            }\\n            prev = dist;\\n        }\\n        if( prev[dst] == pow(10,4)*n ){\\n            return -1;\\n        }\\n        return prev[dst];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 317262,
                "title": "2-clean-python-solution-bfs-dijkstra-explained",
                "content": "# Dijkstra\\nWe start from src and only got K+1 stops to use\\nEach time, we choose the cheapest place to go.\\n\\nIf the city we popout is dst, then the price must be lowest\\nSince we always pick the lowest place to go.\\n\\nIf we still have stops left (stops>1), we put its neighbor to the priority queue.\\nSo the city in the priority queue must be within the stops limit.\\n\\nMaking the graph takes O(E)\\nThe size of priority queue is O(V), since we might put all the cities in it.\\nSo for every pop, it is O(LogV). Total is O(VLogV).\\nFor every edge we call an heappush, so that is ELogV\\nO(E+ (V+E)LogV) -> O((V+E)LogV)\\nV is the number of cities within range K stops.\\n```\\nclass Solution(object):\\n\\tdef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\\tgraph = collections.defaultdict(list)\\n\\t\\tpq = []\\n\\n\\t\\tfor u, v, w in flights: graph[u].append((w, v))\\n\\n\\t\\theapq.heappush(pq, (0, K+1, src))\\n\\t\\twhile pq:\\n\\t\\t\\tprice, stops, city = heapq.heappop(pq)\\n\\n\\t\\t\\tif city is dst: return price\\n\\t\\t\\tif stops>0:\\n\\t\\t\\t\\tfor price_to_nei, nei in graph[city]:\\n\\t\\t\\t\\t\\theapq.heappush(pq, (price+price_to_nei, stops-1, nei))\\n\\t\\treturn -1\\n```\\n# BFS\\nThis is mostly straight forward BFS.\\nWhen we are out of stops, or price is greater than min_price, we stop adding cities to the queue.\\nEvery time we encounter dst we compare the price and set it to the min.\\n\\nMaking the graph takes O(E)\\nBFS every node in adjacent list takes O(V+E)\\nV is the number of cities within range K stops.\\n```\\nclass Solution1(object):\\n\\tdef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\\tgraph = collections.defaultdict(list)\\n\\t\\tq = collections.deque()\\n\\t\\tmin_price = float(\\'inf\\')\\n\\n\\t\\tfor u, v, w in flights: graph[u].append((w, v))\\n\\t\\tq.append((src, 0, 0))\\n\\t\\twhile q:\\n\\t\\t\\tcity, stops, price = q.popleft()\\n\\t\\t\\tif city==dst:\\n\\t\\t\\t\\tmin_price = min(min_price, price)\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\tif stops<=K and price<=min_price:\\n\\t\\t\\t\\tfor price_to_nei, nei in graph[city]:\\n\\t\\t\\t\\t\\tq.append((nei, stops+1, price+price_to_nei))\\n\\n\\t\\treturn min_price if min_price!=float(\\'inf\\') else -1\\n```\\n\\n```\\nI really take time tried to make the best solution or explaination. \\nBecause I wanted to help others like me. \\nIf you like my answer, a star on GitHub means a lot to me. \\nhttps://github.com/wuduhren/leetcode-python\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\tdef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\\tgraph = collections.defaultdict(list)\\n\\t\\tpq = []\\n\\n\\t\\tfor u, v, w in flights: graph[u].append((w, v))\\n\\n\\t\\theapq.heappush(pq, (0, K+1, src))\\n\\t\\twhile pq:\\n\\t\\t\\tprice, stops, city = heapq.heappop(pq)\\n\\n\\t\\t\\tif city is dst: return price\\n\\t\\t\\tif stops>0:\\n\\t\\t\\t\\tfor price_to_nei, nei in graph[city]:\\n\\t\\t\\t\\t\\theapq.heappush(pq, (price+price_to_nei, stops-1, nei))\\n\\t\\treturn -1\\n```\n```\\nclass Solution1(object):\\n\\tdef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\\tgraph = collections.defaultdict(list)\\n\\t\\tq = collections.deque()\\n\\t\\tmin_price = float(\\'inf\\')\\n\\n\\t\\tfor u, v, w in flights: graph[u].append((w, v))\\n\\t\\tq.append((src, 0, 0))\\n\\t\\twhile q:\\n\\t\\t\\tcity, stops, price = q.popleft()\\n\\t\\t\\tif city==dst:\\n\\t\\t\\t\\tmin_price = min(min_price, price)\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\tif stops<=K and price<=min_price:\\n\\t\\t\\t\\tfor price_to_nei, nei in graph[city]:\\n\\t\\t\\t\\t\\tq.append((nei, stops+1, price+price_to_nei))\\n\\n\\t\\treturn min_price if min_price!=float(\\'inf\\') else -1\\n```\n```\\nI really take time tried to make the best solution or explaination. \\nBecause I wanted to help others like me. \\nIf you like my answer, a star on GitHub means a lot to me. \\nhttps://github.com/wuduhren/leetcode-python\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128776,
                "title": "5-ms-ac-java-solution-based-on-dijkstra-s-algorithm",
                "content": "The key point for this problem using Dijkstra\\'s Algorithm is to have two different weights on each edge, because if only consider cost, intermediate cases with higher cost but fewer stops which can further become the shortest valid solution will be discarded.\\n\\nI use a minHeap as the conventional Dijkstra\\'s Algorithm does. The difference is that conventional Dijkstra\\'s Algorithm would remove higher cost with fewer stops cases from heap and only offer cases with lower cost into heap, but I keep all valid intermediate cases in heap and offer higher cost but fewer stops cases into heap as well.  \\n```\\nclass Solution {\\n    private class City implements Comparable<City>{\\n        int id;\\n        int costFromSrc;\\n        int stopFromSrc;\\n        public City(int id, int costFromSrc, int stopFromSrc){\\n            this.id = id;\\n            this.costFromSrc = costFromSrc;\\n            this.stopFromSrc = stopFromSrc;\\n        }\\n        public boolean equals(City c){\\n            if(c instanceof City)\\n                return this.id == c.id;\\n            return false;\\n        }\\n        public int compareTo(City c){\\n            return this.costFromSrc - c.costFromSrc;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[][] srcToDst = new int[n][n];\\n        for(int i = 0; i < flights.length; i++)\\n            srcToDst[flights[i][0]][flights[i][1]] = flights[i][2]; \\n\\t\\t\\t\\t\\t\\t\\n        PriorityQueue<City> minHeap = new PriorityQueue();\\n        minHeap.offer(new City(src,0,0));\\n\\t\\t\\t\\t\\n        int[] cost = new int[n];\\n        Arrays.fill(cost, Integer.MAX_VALUE);\\n        cost[src] = 0;\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        stop[src] = 0;\\n\\t\\t\\t\\t\\n        while(!minHeap.isEmpty()){\\n            City curCity = minHeap.poll();\\n            if(curCity.id == dst) return curCity.costFromSrc;\\n            if(curCity.stopFromSrc == K + 1) continue;\\n            int[] nexts = srcToDst[curCity.id];\\n            for(int i = 0; i < n; i++){\\n                if(nexts[i] != 0){\\n                    int newCost = curCity.costFromSrc + nexts[i];\\n                    int newStop = curCity.stopFromSrc + 1;\\n                    if(newCost < cost[i]){\\n                        minHeap.offer(new City(i, newCost, newStop));\\n                        cost[i] = newCost;\\n                    }\\n                    else if(newStop < stop[i]){\\n                        minHeap.offer(new City(i, newCost, newStop));\\n                        stop[i] = newStop;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cost[dst] == Integer.MAX_VALUE? -1:cost[dst];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private class City implements Comparable<City>{\\n        int id;\\n        int costFromSrc;\\n        int stopFromSrc;\\n        public City(int id, int costFromSrc, int stopFromSrc){\\n            this.id = id;\\n            this.costFromSrc = costFromSrc;\\n            this.stopFromSrc = stopFromSrc;\\n        }\\n        public boolean equals(City c){\\n            if(c instanceof City)\\n                return this.id == c.id;\\n            return false;\\n        }\\n        public int compareTo(City c){\\n            return this.costFromSrc - c.costFromSrc;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[][] srcToDst = new int[n][n];\\n        for(int i = 0; i < flights.length; i++)\\n            srcToDst[flights[i][0]][flights[i][1]] = flights[i][2]; \\n\\t\\t\\t\\t\\t\\t\\n        PriorityQueue<City> minHeap = new PriorityQueue();\\n        minHeap.offer(new City(src,0,0));\\n\\t\\t\\t\\t\\n        int[] cost = new int[n];\\n        Arrays.fill(cost, Integer.MAX_VALUE);\\n        cost[src] = 0;\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        stop[src] = 0;\\n\\t\\t\\t\\t\\n        while(!minHeap.isEmpty()){\\n            City curCity = minHeap.poll();\\n            if(curCity.id == dst) return curCity.costFromSrc;\\n            if(curCity.stopFromSrc == K + 1) continue;\\n            int[] nexts = srcToDst[curCity.id];\\n            for(int i = 0; i < n; i++){\\n                if(nexts[i] != 0){\\n                    int newCost = curCity.costFromSrc + nexts[i];\\n                    int newStop = curCity.stopFromSrc + 1;\\n                    if(newCost < cost[i]){\\n                        minHeap.offer(new City(i, newCost, newStop));\\n                        cost[i] = newCost;\\n                    }\\n                    else if(newStop < stop[i]){\\n                        minHeap.offer(new City(i, newCost, newStop));\\n                        stop[i] = newStop;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cost[dst] == Integer.MAX_VALUE? -1:cost[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532900,
                "title": "c-3-methods-bfs-bellman-ford-dijksrta-no-tle",
                "content": "**Method 1: Dijkstra\\'s Algorithm**\\n\\nSpace Complexity: ```O(e * k)```\\nTime Complexity: ```O(e * k) * (log(e * k))```\\n(Priority queue will store at max ```(e * k)``` values which will happen when the destinaton cannot be reached in ```k``` stops. To push a value it will take ```log(e * k)```)\\n(```e``` represent number of edges or size of ```flights``` vector)\\n\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto e : flights) {\\n            graph[e[0]].push_back({e[1], e[2]});\\n        }\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        // {dist_from_src_node, node, number_of_stops_from_src_node}\\n        pq.push({0, src, 0});\\n        \\n        vector<int> stops(n, INT_MAX);\\n        // number of stops to reach indexth node with least possible price from src node\\n        // as it will be calculated once the pq.top() equals to indexth node\\n        \\n        // pq.top() will always store least cost among the pq elements so if already stop is calculated\\n        // and if that is greater than the cstop that means already we have a path with cheaper cost\\n        // as well as with less or equal number of stops\\n        \\n        while(!pq.empty()) {\\n            auto temp=pq.top();\\n            int cdist=temp[0];\\n            int cnode=temp[1];\\n            int cstop=temp[2];\\n            pq.pop();\\n            \\n            if(cstop>stops[cnode] || cstop>k+1)\\n                continue;\\n            \\n            stops[cnode]=cstop;\\n            if(cnode==dst) {\\n                return cdist;\\n            }\\n            \\n            for(auto a : graph[cnode]) {\\n                pq.push({cdist+a.second, a.first, cstop+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Method 2: BFS**\\n\\nSpace Complexity: ```O(e * k) + O(n)```\\nTime Complexity: ```O(e * k)```\\n(Queue will store at max ```(e * k)``` values for the same reason and pushing or popping requires ```O(1)```)\\n\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto e : flights) {\\n            graph[e[0]].push_back({e[1], e[2]});\\n        }\\n        int ans=INT_MAX;\\n        vector<int> dist(n, INT_MAX);\\n        queue<pair<int, int>> q;\\n        q.push({src, 0});\\n        int stops=0;\\n        while(stops<=k && !q.empty()) {\\n            int sz=q.size();\\n            while(sz--) {\\n                int cnode=q.front().first;\\n                int cdist=q.front().second;\\n                q.pop();\\n                if(cdist>dist[cnode]) continue;\\n                dist[cnode]=cdist;\\n                for(auto e : graph[cnode]) {\\n                    if(e.second+cdist>ans) continue;\\n                    if(e.first==dst) ans=min(ans, e.second+cdist);\\n                    q.push({e.first, e.second+cdist});\\n                }\\n            }\\n            stops++;\\n        }\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Method 3: Bellman Ford**\\n\\nSpace Complexity: ```O(n)```\\nTime Complexity: ```O(e * k)```\\n(It simply makes the use of a ```dist``` vector. We run a loop ```k``` times and each time we traverse all the edges)\\n\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& edges, int src, int dst, int k) {\\n        vector<int> dist(n, INT_MAX);\\n        dist[src]=0;\\n        for(int i=0; i<=k; i++) {\\n            vector<int> temp(n);\\n            copy(dist.begin(), dist.end(), temp.begin());\\n            for(auto e : edges) {\\n                if(dist[e[0]]==INT_MAX)\\n                    continue;\\n                if(temp[e[1]]>dist[e[0]]+e[2])\\n                    temp[e[1]]=dist[e[0]]+e[2];\\n            }\\n            copy(temp.begin(), temp.end(), dist.begin());\\n        }\\n        if(dist[dst]==INT_MAX)\\n            return -1;\\n        return dist[dst];\\n    }\\n};\\n```\\n\\n*PLease upvote if you find this helpful* :)\\n*Feel free to comment in case of any doubt*",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```O(e * k)```\n```O(e * k) * (log(e * k))```\n```(e * k)```\n```k```\n```log(e * k)```\n```e```\n```flights```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto e : flights) {\\n            graph[e[0]].push_back({e[1], e[2]});\\n        }\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        // {dist_from_src_node, node, number_of_stops_from_src_node}\\n        pq.push({0, src, 0});\\n        \\n        vector<int> stops(n, INT_MAX);\\n        // number of stops to reach indexth node with least possible price from src node\\n        // as it will be calculated once the pq.top() equals to indexth node\\n        \\n        // pq.top() will always store least cost among the pq elements so if already stop is calculated\\n        // and if that is greater than the cstop that means already we have a path with cheaper cost\\n        // as well as with less or equal number of stops\\n        \\n        while(!pq.empty()) {\\n            auto temp=pq.top();\\n            int cdist=temp[0];\\n            int cnode=temp[1];\\n            int cstop=temp[2];\\n            pq.pop();\\n            \\n            if(cstop>stops[cnode] || cstop>k+1)\\n                continue;\\n            \\n            stops[cnode]=cstop;\\n            if(cnode==dst) {\\n                return cdist;\\n            }\\n            \\n            for(auto a : graph[cnode]) {\\n                pq.push({cdist+a.second, a.first, cstop+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```O(e * k) + O(n)```\n```O(e * k)```\n```(e * k)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto e : flights) {\\n            graph[e[0]].push_back({e[1], e[2]});\\n        }\\n        int ans=INT_MAX;\\n        vector<int> dist(n, INT_MAX);\\n        queue<pair<int, int>> q;\\n        q.push({src, 0});\\n        int stops=0;\\n        while(stops<=k && !q.empty()) {\\n            int sz=q.size();\\n            while(sz--) {\\n                int cnode=q.front().first;\\n                int cdist=q.front().second;\\n                q.pop();\\n                if(cdist>dist[cnode]) continue;\\n                dist[cnode]=cdist;\\n                for(auto e : graph[cnode]) {\\n                    if(e.second+cdist>ans) continue;\\n                    if(e.first==dst) ans=min(ans, e.second+cdist);\\n                    q.push({e.first, e.second+cdist});\\n                }\\n            }\\n            stops++;\\n        }\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```\n```O(n)```\n```O(e * k)```\n```dist```\n```k```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& edges, int src, int dst, int k) {\\n        vector<int> dist(n, INT_MAX);\\n        dist[src]=0;\\n        for(int i=0; i<=k; i++) {\\n            vector<int> temp(n);\\n            copy(dist.begin(), dist.end(), temp.begin());\\n            for(auto e : edges) {\\n                if(dist[e[0]]==INT_MAX)\\n                    continue;\\n                if(temp[e[1]]>dist[e[0]]+e[2])\\n                    temp[e[1]]=dist[e[0]]+e[2];\\n            }\\n            copy(temp.begin(), temp.end(), dist.begin());\\n        }\\n        if(dist[dst]==INT_MAX)\\n            return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686906,
                "title": "python-multipass-bfs-o-v-2-dijkstra-with-sortedlist-explained",
                "content": "There are a lot of different ways to handle this problem: using DFS, BFS, Dijkstra, Bellman-Ford, Dynamic programming. For me it is easier to use **BFS**, because we are asked to find the shortest distance between two given cities, not with all `dst` like in Dijkstra or Bellman-Ford. \\n\\n**BFS** the idea is to traverse our graph in usual bfs routine and also take into account that we can have maximum `k` stops, that is our pathes should have length less or equal than `k + 1`. To implement bfs in python usual way is to use deque (double ended queue), it works pretty fast in python. We can not use usual list like in dfs (for similate stack), because here we need to pop elements from the beginning of our queue.\\n\\nWe need to keep in each cell of our queue `3` values: current `city`, current number of `visited` cities and current `price`. It is worth to investigate new city if 3 conditions met:\\n1. Our current price is less or equal to minumum price found so far.\\n2. If we still can visit one more city, `visited < k+1`.\\n3. The current city is not our destination yet.\\n\\nIf we reached our city of destination, we update minimum price we get so far.\\n\\n**Complexity**, both time and memory of bfs is `O(V + E)`, where `E` is number of edges and `V` is number of vertices. Note however, that we have here multipass bfs, when we visit node, we do not mark it as visited, and we can visit it several times. In fact this algorighm is very similar to Dijkstra algorighm, and I think complexity is `O(E + V^2) = E(V^2)`, because we traverse each edge only once, but we can visit nodes a lot of times. **Update** I do no think it is quite true, need to be checked.\\n\\n\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        graph = defaultdict(list)\\n        deque_vert = deque([[src, 0, 0]])\\n        min_price = float(\\'inf\\')\\n     \\n        for i, j, w in flights: \\n            graph[i].append([j, w])\\n\\n        while deque_vert:\\n            city, visited, price = deque_vert.popleft()\\n\\n            if price <= min_price and visited <= k and city != dst:\\n                for neibh, price_neibh in graph[city]:\\n                     deque_vert.append([neibh, visited + 1, price + price_neibh])\\n            \\n            if city == dst:\\n                min_price = min(min_price, price)\\n                \\n        return min_price if min_price != float(\\'inf\\') else -1\\n```\\n\\n### Dijkstra \\n\\nThere is better complexity time solution (however we need bigger tests to check it).\\nI was wonderig is it possible to use `SortedList`, instead of `Heap` in Dijkstra algorighm, and the answer is yes! What we need to do is to pop the smallest element and to insert into our list in logarighmic time. Here we need to keep `2`-dimensional table `dist` for shortest distances with given length of path. \\n\\n**Complexity** I think it is `O(E+(Vk)*log(Vk))`, because there will be no more than `Vk` different elements in our SortedList (Heap) at any moment.\\n\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        graph = defaultdict(list)\\n        dist = [[float(\"inf\")] * (k+2) for _ in range(n)] \\n        dist[src][0] = 0\\n\\n        SList = SortedList([[0, 0, src]])\\n        \\n        for i, j, w in flights: \\n            graph[i].append([j, w])\\n        \\n        while SList:\\n            price, visited, city = SList.pop(0)\\n\\n            if city == dst: return price\\n            \\n            if visited <= k:\\n                for neibh, price_neibh in graph[city]: \\n                    candidate = dist[city][visited] + price_neibh\\n                    if candidate <= dist[neibh][visited + 1]:\\n                        dist[neibh][visited + 1] = candidate\\n                        SList.add([price + price_neibh, visited + 1, neibh])\\n                        \\n        return -1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        graph = defaultdict(list)\\n        deque_vert = deque([[src, 0, 0]])\\n        min_price = float(\\'inf\\')\\n     \\n        for i, j, w in flights: \\n            graph[i].append([j, w])\\n\\n        while deque_vert:\\n            city, visited, price = deque_vert.popleft()\\n\\n            if price <= min_price and visited <= k and city != dst:\\n                for neibh, price_neibh in graph[city]:\\n                     deque_vert.append([neibh, visited + 1, price + price_neibh])\\n            \\n            if city == dst:\\n                min_price = min(min_price, price)\\n                \\n        return min_price if min_price != float(\\'inf\\') else -1\\n```\n```\\nclass Solution:\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        graph = defaultdict(list)\\n        dist = [[float(\"inf\")] * (k+2) for _ in range(n)] \\n        dist[src][0] = 0\\n\\n        SList = SortedList([[0, 0, src]])\\n        \\n        for i, j, w in flights: \\n            graph[i].append([j, w])\\n        \\n        while SList:\\n            price, visited, city = SList.pop(0)\\n\\n            if city == dst: return price\\n            \\n            if visited <= k:\\n                for neibh, price_neibh in graph[city]: \\n                    candidate = dist[city][visited] + price_neibh\\n                    if candidate <= dist[neibh][visited + 1]:\\n                        dist[neibh][visited + 1] = candidate\\n                        SList.add([price + price_neibh, visited + 1, neibh])\\n                        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626208,
                "title": "detailed-c-standard-approaches-dp-approach-dfs-with-memoization-bfs",
                "content": "The questions can be easily solved using both the Depth First Search (DFS) and Breadth First Search (BFS) approach.\\n\\n**1. DFS Approach**\\nPretty standard format and easy to understand I guess. The only thing which appears to be different from a standard DFS call is the memoization part. Since, the nodes are higher in number and we can easily get a TLE re-calculating the distances, it\\'s better to store the computed values for later use.\\nOur cache (DP table) will be a 2-D grid because the only varible factors in our function call are `src` and `k`. Both these parameter decide the outcome, and hence both these parameters are needed to map the answer.\\n\\n```\\n\\tint dp[10001][101];\\n\\t\\n    int dfs(vector<vector<pair<int, int>>>& graph, int src, int dst, int k) {\\n        if (src == dst) return 0;\\n        if (k <= -1) return INT_MAX;\\n        \\n        if (dp[src][k] != -1) return dp[src][k];\\n        \\n        int ans = INT_MAX;\\n        for (auto child : graph[src]) {\\n            int res = dfs(graph, child.first, dst, k-1);\\n            if (res != INT_MAX)\\n                ans = min(ans, child.second +res);\\n        }\\n        \\n        return dp[src][k] = ans;\\n    }\\n```\\n\\n**2. BFS Approach**\\nWe might also use the BFS approach and the run time is slightly better than the DFS approach. This is also pretty standard, we\\'ll use a queue and so on. BFS will also give a TLE if we don\\'t prune using ` if(child.second + node.second > ans) continue;`\\n \\n ![image](https://assets.leetcode.com/users/abhisharma404/image_1589180870.png)\\n\\nA little explanation of the following using a dry run\\n```\\nif(child.second + node.second > ans) continue;\\nchild.second += node.second;\\nq.push(child);\\n```\\n1. We set ans = INT_MAX;\\n2. We push in all the nodes connected to 0, i.e. `2` and `1`.\\n3. We visit `2` and update our answer, `ans = min(ans, node.second)`, our answer is now equal to 500 and pop out `2`.\\n4. We visit `1`. Now `2` is a child of `1`, things are different from rest of the BFS here, just because we have visited `2` once does not mean we will ignore it like we use to do in standard BFS call. Instead, we\\'ll prune using the condition ` if(child.second + node.second > ans) continue;`. The following calculation happens:\\n\\ta. Child = `2`, Node = `1`\\n\\tb. Child.second = 100 (cost of `1` to `2`)\\n\\tc. Node.second = 100 (total cost from start i.e. `0` to `1`)\\n\\td. 100 + 100 = 200 < ans(=500), hence we update the value of the child node `2` and push it again into the queue.\\n\\n```\\n    int bfs(vector<vector<pair<int, int>>>& graph, int src, int dst, int k) {\\n        queue <pair<int, int>> q;\\n        for (auto p : graph[src]) {\\n            q.push(p);\\n        }\\n        int ans = INT_MAX;\\n        while (!q.empty()) {\\n            int sz = q.size();\\n            k--;\\n            if (k < -1) break;\\n            for (int s=0; s<sz; s++) {\\n                auto node = q.front();\\n                q.pop();\\n                if (node.first == dst)\\n                    ans = min(ans, node.second);\\n                for (auto child : graph[node.first]) {\\n                    if(child.second + node.second > ans) continue;\\n                    child.second += node.second;\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n**3. Caller Function**\\n\\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        memset(dp, -1, sizeof dp);\\n        // Build the graph\\n        vector<vector<pair<int, int>>> graph(n);\\n        for (auto vec : flights) {\\n            graph[vec[0]].emplace_back(make_pair(vec[1], vec[2]));\\n        }\\n        int ans = bfs(graph, src, dst, K);  // or make the dfs call\\n        if (ans == INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n```\\n\\nI hope it helps. :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint dp[10001][101];\\n\\t\\n    int dfs(vector<vector<pair<int, int>>>& graph, int src, int dst, int k) {\\n        if (src == dst) return 0;\\n        if (k <= -1) return INT_MAX;\\n        \\n        if (dp[src][k] != -1) return dp[src][k];\\n        \\n        int ans = INT_MAX;\\n        for (auto child : graph[src]) {\\n            int res = dfs(graph, child.first, dst, k-1);\\n            if (res != INT_MAX)\\n                ans = min(ans, child.second +res);\\n        }\\n        \\n        return dp[src][k] = ans;\\n    }\\n```\n```\\nif(child.second + node.second > ans) continue;\\nchild.second += node.second;\\nq.push(child);\\n```\n```\\n    int bfs(vector<vector<pair<int, int>>>& graph, int src, int dst, int k) {\\n        queue <pair<int, int>> q;\\n        for (auto p : graph[src]) {\\n            q.push(p);\\n        }\\n        int ans = INT_MAX;\\n        while (!q.empty()) {\\n            int sz = q.size();\\n            k--;\\n            if (k < -1) break;\\n            for (int s=0; s<sz; s++) {\\n                auto node = q.front();\\n                q.pop();\\n                if (node.first == dst)\\n                    ans = min(ans, node.second);\\n                for (auto child : graph[node.first]) {\\n                    if(child.second + node.second > ans) continue;\\n                    child.second += node.second;\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        memset(dp, -1, sizeof dp);\\n        // Build the graph\\n        vector<vector<pair<int, int>>> graph(n);\\n        for (auto vec : flights) {\\n            graph[vec[0]].emplace_back(make_pair(vec[1], vec[2]));\\n        }\\n        int ans = bfs(graph, src, dst, K);  // or make the dfs call\\n        if (ans == INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100039,
                "title": "clean-codes-full-explanation-dijkstra-s-algo-c-java-python3",
                "content": "# Intuition :\\n- Since in this problem, we have to calculate the minimum cost to reach the destination from the source but with a restriction on the number of stops, we would be using Dijkstra\\u2019s Algorithm. Now, one must wonder that based on what parameter we should add elements to the priority queue.\\n\\n- Now, if we store the elements in the priority queue with the priority given to the minimum distance first, then after a few iterations we would realize that the Algorithm will halt when the number of stops would exceed. This may result in a wrong answer as it would not allow us to explore those paths which have more cost but fewer stops than the current answer.\\n\\n- To tackle this issue, we store the elements in terms of the minimum number of stops in the priority queue so that when the algorithm halts, we can get the minimum cost within limits.\\n\\n- Also, a point to note here is that do we really need a priority queue for carrying out the algorithm? The answer for that is No because when we are storing everything in terms of a number of stops, the stops are increasing monotonically which means that the number of sops is increasing by 1 and when we pop an element out of the queue, we are always popping the element with a lesser number of stops first. \\n- Replacing the priority queue with a simple queue will let us eliminate an extra log(N) of the complexity of insertion-deletion in a priority queue which would in turn make our algorithm a lot faster.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n**Initial configuration:**\\n- Queue: Define a Queue that would contain pairs of the type {stops, {node,dist} }, where \\u2018dist\\u2019 indicates the currently updated value of the distance from the source to the \\u2018node\\u2019 and \\u2018stops\\u2019 contains the number of nodes one has to traverse in order to reach node from src.\\n\\n- Distance Array: Define a distance array that would contain the minimum cost/distance from the source cell to a particular cell. If a cell is marked as \\u2018infinity\\u2019 then it is treated as unreachable/unvisited.\\n\\n- Source and Destination: Define the source and the destination from where the flights have to run.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Steps to Follow :\\n- Start by creating an adjacency list, a queue that stores the distance-node and stops pairs in the form {stops,{node,dist}} and a dist array with each node initialized with a very large number ( to indicate that they\\u2019re unvisited initially) and the source node marked as \\u20180\\u2019.\\n- We push the source cell to the queue along with its distance which is also 0 and the stops are marked as \\u20180\\u2019 initially because we\\u2019ve just started.\\n- Pop the element at the front of the queue and look out for its adjacent nodes. \\n- If the current dist value of a node is better than the previous distance indicated by the distance array and the number of stops until now is less than K, we update the distance in the array and push it to the queue. Also, increase the stop count by 1.\\n- We repeat the above three steps until the queue becomes empty. Note that we do not stop the algorithm from just reaching the destination node as it may give incorrect results.\\n- Return the calculated distance/cost after we reach the required number of stops. If the queue becomes empty and we don\\u2019t encounter the destination node, return \\u2018-1\\u2019 indicating there\\u2019s no path from source to destination.\\n\\n![Screenshot-2023-01-08-144144.webp](https://assets.leetcode.com/users/images/f9a796f2-4b3b-4b36-925e-95be42217e20_1674703906.0808144.webp)\\n\\n\\n# Complexity\\n- Time complexity: O(\\u2223E\\u2223 + \\u2223V\\u2223 log\\u2223E\\u2223)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nk)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nAnother Approach \\u2B07\\uFE0F\\u2B07\\uFE0F with Python code also( Scroll down to \\ncheck).\\n```\\n# Codes for above Explained Approach :\\n```C++ []\\nclass Solution\\n{\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>> &flights,\\n                       int src, int dst, int K)\\n    {\\n        // Create the adjacency list to depict airports and flights in\\n        // the form of a graph.\\n        vector<pair<int, int>> adj[n];\\n        for (auto it : flights)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n\\n        // Create a queue which stores the node and their distances from the\\n        // source in the form of {stops, {node, dist}} with \\u2018stops\\u2019 indicating \\n        // the no. of nodes between src and current node.\\n        queue<pair<int, pair<int, int>>> q;\\n        \\n        q.push({0, {src, 0}});\\n\\n        // Distance array to store the updated distances from the source.\\n        vector<int> dist(n, 1e9);\\n        dist[src] = 0;\\n\\n        // Iterate through the graph using a queue like in Dijkstra with \\n        // popping out the element with min stops first.\\n        while (!q.empty())\\n        {\\n            auto it = q.front();\\n            q.pop();\\n            int stops = it.first;\\n            int node = it.second.first;\\n            int cost = it.second.second;\\n\\n            // We stop the process as soon as the limit for the stops reaches.\\n            if (stops > K)\\n                continue;\\n            for (auto iter : adj[node])\\n            {\\n                int adjNode = iter.first;\\n                int edW = iter.second;\\n\\n                // We only update the queue if the new calculated dist is\\n                // less than the prev and the stops are also within limits.\\n                if (cost + edW < dist[adjNode] && stops <= K)\\n                {\\n                    dist[adjNode] = cost + edW;\\n                    q.push({stops + 1, {adjNode, cost + edW}});\\n                }\\n            }\\n        }\\n        // If the destination node is unreachable return \\u2018-1\\u2019\\n        // else return the calculated dist from src to dst.\\n        if (dist[dst] == 1e9)\\n            return -1;\\n        return dist[dst];\\n    }\\n};\\n```\\n```Java []\\nclass Pair{\\n    int first;\\n    int second;\\n    public Pair(int first,int second){\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\nclass Tuple {\\n    int first, second, third; \\n    Tuple(int first, int second, int third) {\\n        this.first = first; \\n        this.second = second;\\n        this.third = third; \\n    }\\n}\\nclass Solution {\\n    public int findCheapestPrice(int n,int flights[][],int src,int dst,int K) {\\n\\n        // Create the adjacency list to depict airports and flights in\\n        // the form of a graph.\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>(); \\n        for(int i = 0;i<n;i++) {\\n            adj.add(new ArrayList<>()); \\n        }\\n        int m = flights.length; \\n        for(int i = 0;i<m;i++) {\\n            adj.get(flights[i][0]).add(new Pair(flights[i][1], flights[i][2])); \\n        }\\n        \\n        // Create a queue which stores the node and their distances from the\\n        // source in the form of {stops, {node, dist}} with \\u2018stops\\u2019 indicating \\n        // the no. of nodes between src and current node.\\n        Queue<Tuple> q = new LinkedList<>(); \\n        \\n        q.add(new Tuple(0, src, 0));\\n\\n        // Distance array to store the updated distances from the source. \\n        int[] dist = new int[n]; \\n        for(int i = 0;i<n;i++) {\\n            dist[i] = (int)(1e9); \\n        }\\n        dist[src] = 0; \\n\\n        // Iterate through the graph using a queue like in Dijkstra with \\n        // popping out the element with min stops first.\\n        while(!q.isEmpty()) {\\n            Tuple it = q.peek(); \\n            q.remove(); \\n            int stops = it.first; \\n            int node = it.second; \\n            int cost = it.third; \\n            \\n            // We stop the process as soon as the limit for the stops reaches.\\n            if(stops > K) continue; \\n            for(Pair iter: adj.get(node)) {\\n                int adjNode = iter.first; \\n                int edW = iter.second; \\n                \\n                // We only update the queue if the new calculated dist is\\n                // less than the prev and the stops are also within limits.\\n                if (cost + edW < dist[adjNode] && stops <= K) {\\n                    dist[adjNode] = cost + edW; \\n                    q.add(new Tuple(stops + 1, adjNode, cost + edW)); \\n                }\\n            }\\n        }\\n        // If the destination node is unreachable return \\u2018-1\\u2019\\n        // else return the calculated dist from src to dst.\\n        if(dist[dst] == (int)(1e9)) return -1; \\n        return dist[dst]; \\n    }\\n}\\n```\\n\\n\\n# Another Approach using Priority Queue :\\n```C++ []\\nclass Solution {\\n public:\\n  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst,\\n                        int k) {\\n    vector<vector<pair<int, int>>> graph(n);\\n    using T = tuple<int, int, int>;  // (d, u, stops)\\n    priority_queue<T, vector<T>, greater<>> minHeap;\\n    vector<vector<int>> dist(n, vector<int>(k + 2, INT_MAX));\\n\\n    minHeap.emplace(0, src, k + 1);  // Start with node src with d == 0\\n    dist[src][k + 1] = 0;\\n\\n    for (const vector<int>& f : flights) {\\n      const int u = f[0];\\n      const int v = f[1];\\n      const int w = f[2];\\n      graph[u].emplace_back(v, w);\\n    }\\n\\n    while (!minHeap.empty()) {\\n      const auto [d, u, stops] = minHeap.top();\\n      minHeap.pop();\\n      if (u == dst)\\n        return d;\\n      if (stops > 0)\\n        for (const auto& [v, w] : graph[u]) {\\n          const int newDist = d + w;\\n          if (newDist < dist[v][stops - 1]) {\\n            dist[v][stops - 1] = newDist;\\n            minHeap.emplace(newDist, v, stops - 1);\\n          }\\n        }\\n    }\\n\\n    return -1;\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n    List<Pair<Integer, Integer>>[] graph = new List[n];\\n    // (d, u, stops)\\n    Queue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    int[][] dist = new int[n][k + 2];\\n    Arrays.stream(dist).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE));\\n\\n    for (int i = 0; i < n; ++i)\\n      graph[i] = new ArrayList<>();\\n\\n    for (int[] f : flights) {\\n      final int u = f[0];\\n      final int v = f[1];\\n      final int w = f[2];\\n      graph[u].add(new Pair<>(v, w));\\n    }\\n\\n    minHeap.offer(new int[] {0, src, k + 1}); // Start with node src with d == 0\\n    dist[src][k + 1] = 0;\\n\\n    while (!minHeap.isEmpty()) {\\n      final int d = minHeap.peek()[0];\\n      final int u = minHeap.peek()[1];\\n      final int stops = minHeap.poll()[2];\\n      if (u == dst)\\n        return d;\\n      if (stops > 0)\\n        for (Pair<Integer, Integer> pair : graph[u]) {\\n          final int v = pair.getKey();\\n          final int w = pair.getValue();\\n          final int newDist = d + w;\\n          if (newDist < dist[v][stops - 1]) {\\n            dist[v][stops - 1] = newDist;\\n            minHeap.offer(new int[] {d + w, v, stops - 1});\\n          }\\n        }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n    graph = [[] for _ in range(n)]\\n    minHeap = [(0, src, k + 1)]  # (d, u, stops)\\n    dist = [[math.inf] * (k + 2) for _ in range(n)]\\n\\n    for u, v, w in flights:\\n      graph[u].append((v, w))\\n\\n    while minHeap:\\n      d, u, stops = heapq.heappop(minHeap)\\n      if u == dst:\\n        return d\\n      if stops > 0:\\n        for v, w in graph[u]:\\n          newDist = d + w\\n          if newDist < dist[v][stops - 1]:\\n            dist[v][stops - 1] = newDist\\n            heapq.heappush(minHeap, (newDist, v, stops - 1))\\n\\n    return -1\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/85caab22-23a7-4187-8f6a-b4725bfd78ac_1674703985.897158.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nAnother Approach \\u2B07\\uFE0F\\u2B07\\uFE0F with Python code also( Scroll down to \\ncheck).\\n```\n```C++ []\\nclass Solution\\n{\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>> &flights,\\n                       int src, int dst, int K)\\n    {\\n        // Create the adjacency list to depict airports and flights in\\n        // the form of a graph.\\n        vector<pair<int, int>> adj[n];\\n        for (auto it : flights)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n\\n        // Create a queue which stores the node and their distances from the\\n        // source in the form of {stops, {node, dist}} with \\u2018stops\\u2019 indicating \\n        // the no. of nodes between src and current node.\\n        queue<pair<int, pair<int, int>>> q;\\n        \\n        q.push({0, {src, 0}});\\n\\n        // Distance array to store the updated distances from the source.\\n        vector<int> dist(n, 1e9);\\n        dist[src] = 0;\\n\\n        // Iterate through the graph using a queue like in Dijkstra with \\n        // popping out the element with min stops first.\\n        while (!q.empty())\\n        {\\n            auto it = q.front();\\n            q.pop();\\n            int stops = it.first;\\n            int node = it.second.first;\\n            int cost = it.second.second;\\n\\n            // We stop the process as soon as the limit for the stops reaches.\\n            if (stops > K)\\n                continue;\\n            for (auto iter : adj[node])\\n            {\\n                int adjNode = iter.first;\\n                int edW = iter.second;\\n\\n                // We only update the queue if the new calculated dist is\\n                // less than the prev and the stops are also within limits.\\n                if (cost + edW < dist[adjNode] && stops <= K)\\n                {\\n                    dist[adjNode] = cost + edW;\\n                    q.push({stops + 1, {adjNode, cost + edW}});\\n                }\\n            }\\n        }\\n        // If the destination node is unreachable return \\u2018-1\\u2019\\n        // else return the calculated dist from src to dst.\\n        if (dist[dst] == 1e9)\\n            return -1;\\n        return dist[dst];\\n    }\\n};\\n```\n```Java []\\nclass Pair{\\n    int first;\\n    int second;\\n    public Pair(int first,int second){\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\nclass Tuple {\\n    int first, second, third; \\n    Tuple(int first, int second, int third) {\\n        this.first = first; \\n        this.second = second;\\n        this.third = third; \\n    }\\n}\\nclass Solution {\\n    public int findCheapestPrice(int n,int flights[][],int src,int dst,int K) {\\n\\n        // Create the adjacency list to depict airports and flights in\\n        // the form of a graph.\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>(); \\n        for(int i = 0;i<n;i++) {\\n            adj.add(new ArrayList<>()); \\n        }\\n        int m = flights.length; \\n        for(int i = 0;i<m;i++) {\\n            adj.get(flights[i][0]).add(new Pair(flights[i][1], flights[i][2])); \\n        }\\n        \\n        // Create a queue which stores the node and their distances from the\\n        // source in the form of {stops, {node, dist}} with \\u2018stops\\u2019 indicating \\n        // the no. of nodes between src and current node.\\n        Queue<Tuple> q = new LinkedList<>(); \\n        \\n        q.add(new Tuple(0, src, 0));\\n\\n        // Distance array to store the updated distances from the source. \\n        int[] dist = new int[n]; \\n        for(int i = 0;i<n;i++) {\\n            dist[i] = (int)(1e9); \\n        }\\n        dist[src] = 0; \\n\\n        // Iterate through the graph using a queue like in Dijkstra with \\n        // popping out the element with min stops first.\\n        while(!q.isEmpty()) {\\n            Tuple it = q.peek(); \\n            q.remove(); \\n            int stops = it.first; \\n            int node = it.second; \\n            int cost = it.third; \\n            \\n            // We stop the process as soon as the limit for the stops reaches.\\n            if(stops > K) continue; \\n            for(Pair iter: adj.get(node)) {\\n                int adjNode = iter.first; \\n                int edW = iter.second; \\n                \\n                // We only update the queue if the new calculated dist is\\n                // less than the prev and the stops are also within limits.\\n                if (cost + edW < dist[adjNode] && stops <= K) {\\n                    dist[adjNode] = cost + edW; \\n                    q.add(new Tuple(stops + 1, adjNode, cost + edW)); \\n                }\\n            }\\n        }\\n        // If the destination node is unreachable return \\u2018-1\\u2019\\n        // else return the calculated dist from src to dst.\\n        if(dist[dst] == (int)(1e9)) return -1; \\n        return dist[dst]; \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst,\\n                        int k) {\\n    vector<vector<pair<int, int>>> graph(n);\\n    using T = tuple<int, int, int>;  // (d, u, stops)\\n    priority_queue<T, vector<T>, greater<>> minHeap;\\n    vector<vector<int>> dist(n, vector<int>(k + 2, INT_MAX));\\n\\n    minHeap.emplace(0, src, k + 1);  // Start with node src with d == 0\\n    dist[src][k + 1] = 0;\\n\\n    for (const vector<int>& f : flights) {\\n      const int u = f[0];\\n      const int v = f[1];\\n      const int w = f[2];\\n      graph[u].emplace_back(v, w);\\n    }\\n\\n    while (!minHeap.empty()) {\\n      const auto [d, u, stops] = minHeap.top();\\n      minHeap.pop();\\n      if (u == dst)\\n        return d;\\n      if (stops > 0)\\n        for (const auto& [v, w] : graph[u]) {\\n          const int newDist = d + w;\\n          if (newDist < dist[v][stops - 1]) {\\n            dist[v][stops - 1] = newDist;\\n            minHeap.emplace(newDist, v, stops - 1);\\n          }\\n        }\\n    }\\n\\n    return -1;\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n    List<Pair<Integer, Integer>>[] graph = new List[n];\\n    // (d, u, stops)\\n    Queue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    int[][] dist = new int[n][k + 2];\\n    Arrays.stream(dist).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE));\\n\\n    for (int i = 0; i < n; ++i)\\n      graph[i] = new ArrayList<>();\\n\\n    for (int[] f : flights) {\\n      final int u = f[0];\\n      final int v = f[1];\\n      final int w = f[2];\\n      graph[u].add(new Pair<>(v, w));\\n    }\\n\\n    minHeap.offer(new int[] {0, src, k + 1}); // Start with node src with d == 0\\n    dist[src][k + 1] = 0;\\n\\n    while (!minHeap.isEmpty()) {\\n      final int d = minHeap.peek()[0];\\n      final int u = minHeap.peek()[1];\\n      final int stops = minHeap.poll()[2];\\n      if (u == dst)\\n        return d;\\n      if (stops > 0)\\n        for (Pair<Integer, Integer> pair : graph[u]) {\\n          final int v = pair.getKey();\\n          final int w = pair.getValue();\\n          final int newDist = d + w;\\n          if (newDist < dist[v][stops - 1]) {\\n            dist[v][stops - 1] = newDist;\\n            minHeap.offer(new int[] {d + w, v, stops - 1});\\n          }\\n        }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n    graph = [[] for _ in range(n)]\\n    minHeap = [(0, src, k + 1)]  # (d, u, stops)\\n    dist = [[math.inf] * (k + 2) for _ in range(n)]\\n\\n    for u, v, w in flights:\\n      graph[u].append((v, w))\\n\\n    while minHeap:\\n      d, u, stops = heapq.heappop(minHeap)\\n      if u == dst:\\n        return d\\n      if stops > 0:\\n        for v, w in graph[u]:\\n          newDist = d + w\\n          if newDist < dist[v][stops - 1]:\\n            dist[v][stops - 1] = newDist\\n            heapq.heappush(minHeap, (newDist, v, stops - 1))\\n\\n    return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099854,
                "title": "dynamic-programming-solution-with-video",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCredit to @gcl272633743 \\n\\n\\n![Screenshot 2023-01-26 at 6.55.48 AM.png](https://assets.leetcode.com/users/images/f9e5e5c9-161e-47f6-ab9f-44c5eb9bc735_1674696379.0685956.png)\\n\\nWe will have a table where columns are cities and row indicates steps(not stops) Any row, column indicates cost to travel from src to this city in k steps. If its infinity its not possible.\\n\\nInitially all are infinity, we mark the source column to 0, as the cost required to travel from src to src is 0 with any steps.\\n\\nNow we go to each step, i.e say step 1 (row 1).\\n\\nWe check all the flights and if the source is already visited, i.e(the previous row is not infinity) we change this cell\\'s value.\\n\\nex [0,1,100] city 0 is visisted with 0 steps, hence dp[1][1] = 100;\\n[1,2,100] no change since 1 is not visited in previous steps.\\n\\nSame goes for 2 steps\\neg [1,2,100]-- is 1 already visited, yes so dp[2][2] = 100+100\\n[1,3,600] -- is 1 already visited, yes dp[2][3] = 100+600 =700\\n\\n\\nhttps://youtu.be/5V_72xBSh8E\\n\\n\\nFor More read: https://medium.com/swlh/graph-dynamic-programming-heap-cheapest-flights-within-k-stops-e622ce956479\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/e81a44ac-2a0a-4268-8033-63780c428560_1674698166.6324708.webp)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[][] dp = new int[k+2][n];\\n        for(int i=0; i<=k+1; i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);    \\n        }\\n        //fly from src to scr cost 0\\n        for(int i=0; i<=k+1; i++){\\n            dp[i][src] = 0;    \\n        }\\n        \\n        for(int i=1; i<=k+1; i++){\\n            for(int[] f: flights){\\n                if(dp[i-1][f[0]]!=Integer.MAX_VALUE){\\n                    dp[i][f[1]] = Math.min(dp[i][f[1]],dp[i-1][f[0]]+f[2]);\\n                }\\n            }\\n        }\\n        return dp[k+1][dst] == Integer.MAX_VALUE ? -1 : dp[k+1][dst];\\n    }\\n}\\n```\\n\\n```\\ndef findCheapestPrice(self, n, flights, src, dst, k):\\n        dp = [[sys.maxsize for _ in range(n)] for _ in range(k+2)]\\n        for i in range(k+2):\\n            dp[i][src] = 0\\n        for i in range(1, k+2):\\n            for f in flights:\\n                if dp[i-1][f[0]] != sys.maxsize:\\n                    dp[i][f[1]] = min(dp[i][f[1]], dp[i-1][f[0]] + f[2])\\n        return dp[k+1][dst] if dp[k+1][dst] != sys.maxsize else -1\\n        \\n```\\n\\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> dp(k + 2, vector<int>(n, INT_MAX));\\n        for (int i = 0; i <= k + 1; i++) {\\n            dp[i][src] = 0;\\n        }\\n        for (int i = 1; i <= k + 1; i++) {\\n            for (const auto& f : flights) {\\n                if (dp[i - 1][f[0]] != INT_MAX) {\\n                    dp[i][f[1]] = min(dp[i][f[1]], dp[i - 1][f[0]] + f[2]);\\n                }\\n            }\\n        }\\n        return dp[k + 1][dst] == INT_MAX ? -1 : dp[k + 1][dst];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[][] dp = new int[k+2][n];\\n        for(int i=0; i<=k+1; i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);    \\n        }\\n        //fly from src to scr cost 0\\n        for(int i=0; i<=k+1; i++){\\n            dp[i][src] = 0;    \\n        }\\n        \\n        for(int i=1; i<=k+1; i++){\\n            for(int[] f: flights){\\n                if(dp[i-1][f[0]]!=Integer.MAX_VALUE){\\n                    dp[i][f[1]] = Math.min(dp[i][f[1]],dp[i-1][f[0]]+f[2]);\\n                }\\n            }\\n        }\\n        return dp[k+1][dst] == Integer.MAX_VALUE ? -1 : dp[k+1][dst];\\n    }\\n}\\n```\n```\\ndef findCheapestPrice(self, n, flights, src, dst, k):\\n        dp = [[sys.maxsize for _ in range(n)] for _ in range(k+2)]\\n        for i in range(k+2):\\n            dp[i][src] = 0\\n        for i in range(1, k+2):\\n            for f in flights:\\n                if dp[i-1][f[0]] != sys.maxsize:\\n                    dp[i][f[1]] = min(dp[i][f[1]], dp[i-1][f[0]] + f[2])\\n        return dp[k+1][dst] if dp[k+1][dst] != sys.maxsize else -1\\n        \\n```\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> dp(k + 2, vector<int>(n, INT_MAX));\\n        for (int i = 0; i <= k + 1; i++) {\\n            dp[i][src] = 0;\\n        }\\n        for (int i = 1; i <= k + 1; i++) {\\n            for (const auto& f : flights) {\\n                if (dp[i - 1][f[0]] != INT_MAX) {\\n                    dp[i][f[1]] = min(dp[i][f[1]], dp[i - 1][f[0]] + f[2]);\\n                }\\n            }\\n        }\\n        return dp[k + 1][dst] == INT_MAX ? -1 : dp[k + 1][dst];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163698,
                "title": "easy-java-bellman-ford",
                "content": "```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int INF = 0x3F3F3F3F;\\n        int[] cost = new int[n];\\n        Arrays.fill(cost, INF);\\n        cost[src] = 0;\\n        int ans = cost[dst];\\n        for(int i = k; i >= 0; i--){\\n            int[] cur = new int[n];\\n            Arrays.fill(cur, INF);\\n            for(int[] flight : flights){\\n                cur[flight[1]] = Math.min(cur[flight[1]], cost[flight[0]] + flight[2]);\\n            }\\n            cost = cur;\\n            ans = Math.min(ans, cost[dst]);\\n        }\\n        return ans == INF ? -1 : ans;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int INF = 0x3F3F3F3F;\\n        int[] cost = new int[n];\\n        Arrays.fill(cost, INF);\\n        cost[src] = 0;\\n        int ans = cost[dst];\\n        for(int i = k; i >= 0; i--){\\n            int[] cur = new int[n];\\n            Arrays.fill(cur, INF);\\n            for(int[] flight : flights){\\n                cur[flight[1]] = Math.min(cur[flight[1]], cost[flight[0]] + flight[2]);\\n            }\\n            cost = cur;\\n            ans = Math.min(ans, cost[dst]);\\n        }\\n        return ans == INF ? -1 : ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099967,
                "title": "fast-c-solution",
                "content": "# Solution Code\\n\\n``` C++ []\\n\\nclass Solution { // similar to network delay time.  dijkstra algo\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        for(auto e: flights) graph[e[0]].push_back({e[1], e[2]});\\n        vector<int> prices(n, -1);\\n        queue<pair<int, int>> q; q.push({src, 0});\\n        ++K;\\n        while(!q.empty()) {\\n            if(!K) break;\\n            int len = q.size();\\n            for(int i = 0; i < len; i++) {\\n                auto cur = q.front(); q.pop();\\n                for(auto e: graph[cur.first]) {\\n                    int price = cur.second + e.second; \\n                    if(prices[e.first] == -1 || price < prices[e.first]) {\\n                        prices[e.first] = price;\\n                        q.push({e.first, price});\\n                    }\\n                }\\n            }\\n            K--;\\n        }\\n        return prices[dst];\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/49b61c2b-e657-488a-902a-01847800509c_1674701698.200033.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\n\\nclass Solution { // similar to network delay time.  dijkstra algo\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        for(auto e: flights) graph[e[0]].push_back({e[1], e[2]});\\n        vector<int> prices(n, -1);\\n        queue<pair<int, int>> q; q.push({src, 0});\\n        ++K;\\n        while(!q.empty()) {\\n            if(!K) break;\\n            int len = q.size();\\n            for(int i = 0; i < len; i++) {\\n                auto cur = q.front(); q.pop();\\n                for(auto e: graph[cur.first]) {\\n                    int price = cur.second + e.second; \\n                    if(prices[e.first] == -1 || price < prices[e.first]) {\\n                        prices[e.first] = price;\\n                        q.push({e.first, price});\\n                    }\\n                }\\n            }\\n            K--;\\n        }\\n        return prices[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115548,
                "title": "c-solution-using-dynamic-programming",
                "content": "ans[i][j] represents that the minimum cost from node src to node i using steps <= j\nThe initial state is ans[src][0] = 0, which means that from src to src there isn't any cost\nAnd ans[dst][K] means the minimum cost from node src to node dst using steps <= K\n\n```\nclass Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\n    {\n        const int INF = 1e9;\n        K++;\n        vector<vector<int>> ans(n, vector<int>(K+1));\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j <= K; j++)\n            {\n                ans[i][j] = INF;\n            }\n        }\n        ans[src][0] = 0;\n        for(int i = 1; i <= K; i++)\n        {\n            for(int j = 0; j < n; j++)   //To update ans[j][i](using i steps), we copy ans[j][i-1] first\n                ans[j][i] = ans[j][i-1];\n            for(const vector<int>& f: flights)\n            {\n                ans[f[1]][i] = min(ans[f[1]][i], ans[f[0]][i-1] + f[2]);\n            }\n        }\n        if(ans[dst][K] == INF) return -1;\n        return ans[dst][K];\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\n    {\n        const int INF = 1e9;\n        K++;\n        vector<vector<int>> ans(n, vector<int>(K+1));\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j <= K; j++)\n            {\n                ans[i][j] = INF;\n            }\n        }\n        ans[src][0] = 0;\n        for(int i = 1; i <= K; i++)\n        {\n            for(int j = 0; j < n; j++)   //To update ans[j][i](using i steps), we copy ans[j][i-1] first\n                ans[j][i] = ans[j][i-1];\n            for(const vector<int>& f: flights)\n            {\n                ans[f[1]][i] = min(ans[f[1]][i], ans[f[0]][i-1] + f[2]);\n            }\n        }\n        if(ans[dst][K] == INF) return -1;\n        return ans[dst][K];\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373237,
                "title": "java-solution-using-dijkstra-and-bellman-ford-with-explanation",
                "content": "**Dijkstra**\\nInstead of visited array we will use a stop array where stop[i] will store the min number of stops needed to reach i.\\nSo, in future if any other path having greater stops then the current will occur we will ignore that.\\n\\n**Why we can\\'t use boolean visited array?** As if we use visited array, and there can be a case where the smallest path according to Dijkstra algo can have more stops, and in this path we may mark one node visited which can contribute in other path and results in answer will be igonred due to visited.\\n```\\nclass Solution {\\n    class Pair{\\n        int v;\\n        int wt;\\n        int dist;\\n        \\n        Pair(int v, int wt, int dist){\\n            this.v = v;\\n            this.wt = wt;\\n            this.dist = dist;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        ArrayList<ArrayList<Pair>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge : flights){\\n            int u = edge[0];\\n            int v = edge[1];\\n            int wt = edge[2];\\n            \\n            graph.get(u).add(new Pair(v, wt, 0));\\n            \\n        }\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.wt - b.wt);\\n        pq.add(new Pair(src, 0, -1));\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        \\n        while(pq.size() > 0){\\n            Pair p = pq.remove();\\n            if(p.dist > k || stop[p.v] < p.dist)continue;\\n            \\n            stop[p.v] = p.dist;\\n            if(p.v == dst)return p.wt;\\n\\n            for(Pair nbr : graph.get(p.v)){\\n                pq.add(new Pair(nbr.v, p.wt + nbr.wt, p.dist + 1));\\n                \\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Bellman ford**\\nAs in bellman ford, in the i\\'th iteration we would surely have found the best path of i distance, but in some cases i\\'th iteration can result in answer of (i + 1, i + 2 or n) length path, this is because of arrangment of edges.\\nSo, if we use the prev iteration array for checking the weight is smaller or not and updating in current array, we can easily overcome this situation.\\n\\n```\\n\\nclass Solution{\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[] prev = new int[n];\\n        Arrays.fill(prev, Integer.MAX_VALUE);\\n        prev[src] = 0;\\n        \\n        for(int i = 0 ; i <= k; i++){\\n            int[] curr = new int[n];\\n            for(int j = 0; j < n; j++)curr[j] = prev[j];\\n            \\n            for(int[] edge : flights){\\n                int u = edge[0];\\n                int v = edge[1];\\n                int wt = edge[2];\\n                \\n                if(prev[u] != Integer.MAX_VALUE && prev[u] + wt < curr[v]){\\n                    curr[v] = prev[u] + wt;\\n                }\\n            }\\n            for(int j = 0; j < n; j++)prev[j] = curr[j];\\n        }\\n        \\n        return prev[dst] == Integer.MAX_VALUE ? -1 : prev[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int v;\\n        int wt;\\n        int dist;\\n        \\n        Pair(int v, int wt, int dist){\\n            this.v = v;\\n            this.wt = wt;\\n            this.dist = dist;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        ArrayList<ArrayList<Pair>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge : flights){\\n            int u = edge[0];\\n            int v = edge[1];\\n            int wt = edge[2];\\n            \\n            graph.get(u).add(new Pair(v, wt, 0));\\n            \\n        }\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.wt - b.wt);\\n        pq.add(new Pair(src, 0, -1));\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        \\n        while(pq.size() > 0){\\n            Pair p = pq.remove();\\n            if(p.dist > k || stop[p.v] < p.dist)continue;\\n            \\n            stop[p.v] = p.dist;\\n            if(p.v == dst)return p.wt;\\n\\n            for(Pair nbr : graph.get(p.v)){\\n                pq.add(new Pair(nbr.v, p.wt + nbr.wt, p.dist + 1));\\n                \\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n\\nclass Solution{\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[] prev = new int[n];\\n        Arrays.fill(prev, Integer.MAX_VALUE);\\n        prev[src] = 0;\\n        \\n        for(int i = 0 ; i <= k; i++){\\n            int[] curr = new int[n];\\n            for(int j = 0; j < n; j++)curr[j] = prev[j];\\n            \\n            for(int[] edge : flights){\\n                int u = edge[0];\\n                int v = edge[1];\\n                int wt = edge[2];\\n                \\n                if(prev[u] != Integer.MAX_VALUE && prev[u] + wt < curr[v]){\\n                    curr[v] = prev[u] + wt;\\n                }\\n            }\\n            for(int j = 0; j < n; j++)prev[j] = curr[j];\\n        }\\n        \\n        return prev[dst] == Integer.MAX_VALUE ? -1 : prev[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499910,
                "title": "java-dijkstra-with-k-v-nodes-7ms-as-of-sep-2021",
                "content": "For shortest path finding algorhtms, I tend to master one sword and let it kill any monster. This question right here, is designed to trick people who naively wants to kill it using brain dead Dijkstra implementation or simple modifications. No not today. \\n\\nBut the good news is, you can still use Dijkstra algorithm to solve this question, with enough crafting in the way you define graph nodes. In this question, you have to consider each node as a joint state of k steps, and arriving at v node, thus being [k, v] and you would still want to expand best paths provided by your priority queue, just by sorting path cost of those [k,v] states. The only part that needs special care, is when you are expanding the best path when popped out of the p-queue:\\n\\n- **We want to expand a path, when the steps are smaller than current best path\\'s steps**, cause it might leads to final solution in case the best path exceeds step limit.\\n- **We of course still wants to expand a path when we found smaller cost.**\\n- Therefore, we simply do this:\\n\\t- You would need a 2d array of int[][] minCost = new int[k][n] which records best path from source to n node with length k. \\n\\t- For paths with k steps (k edges), we expand when we found a better path with exactly k steps (compare against defined minCost). \\n\\nWe can show that with this definiation of nodes, \\n- We still have path expansion consistency, meaning all path expanded by a given iteration must be larger than current path (dequeued node), thus the dequeuing sequence from priority queue best be non decreasing.  \\n\\t- For more about why consistency matters and Dijkstra should never process a node twice, see consistency check in A* algorithm https://en.wikipedia.org/wiki/A*_search_algorithm\\n\\n- This guarantees each  [k, v] state is only dequeued once, cause future dequeues always have larger edge cost, and will NEVER update mincost[k][v] again.\\n- This net us a overall complexity roughly O((kV + kE) * logX), where X is the max number of elements that can appear in the p-queue. \\n\\t- In some heap implementations, where one can modify priority value, this X = kV (number of nodes) \\n\\t- But for default p-queue implementation in Java, where you cannot modify the priority value, you must enqueue again with better values and record min values in the minCost array; when you found a node with larger values than minCost, you know this guy is outdated by a better value, you simply ditch it. \\n\\t- What is the max number of nodes that can be enqueued? It would be the number of best path expansions, which happens kE times and the queue volume is bounded by kE.\\n\\t- Thus, **time complexity for my below implementation is O((kV + kE) * log(kE)) ~= N^3 log N**\\n\\t- This is essentialy even worse than default Bellman-ford algorithm, which rums at O(NE) = O(N^3) and is much easier to implement under stress. To be honenst, this question + test case is designed for Bellman-ford, if you don\\'t know it, you will have a hard time. I dislike this.\\n\\t\\nDijkstra with kV node modification:\\n```\\nclass Solution {\\n    // modified Dijkstra.\\n    public int findCheapestPrice(int n, int[][] flights, \\n                                 int src, int dst, int k) {\\n        // Build graph.\\n        // node i -> list of (node j, cost)\\n        List<List<int[]>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        \\n        for (int[] f : flights) {\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n        }\\n        \\n        // Queue node is int[] -> loc, cost, stops;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(10,\\n                        (o1, o2) -> o1[1] - o2[1]);\\n        pq.offer(new int[]{src, 0, 0});\\n        \\n        // Min cost tracker.\\n        // min cost for k stop arriving at n node.\\n        int[][] minCost = new int[k + 2][n];\\n        int inf = 1000000;\\n        for (int i = 0; i <= k + 1; i++) {\\n            for (int j = 0; j < n; j++) {\\n                minCost[i][j] = inf;\\n            }\\n        } \\n        \\n        minCost[0][src] = 0;\\n        \\n        // Best first search.\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            \\n            int curNode = cur[0];\\n            int curCost = cur[1];\\n            int curStops = cur[2];\\n            \\n            if (curNode == dst) return curCost;\\n            \\n            // No more stops possible, don\\'t expand.\\n            if (curStops == k + 1) continue;\\n            \\n            // outdated values.\\n            if (curCost > minCost[curStops][cur[0]]) continue;\\n            \\n            // Expand cur best path. \\n            for (int[] e : graph.get(curNode)) {\\n                if (curCost + e[1] < minCost[curStops + 1][e[0]]) {\\n                    // cur -> e[0];\\n                    minCost[curStops + 1][e[0]] = curCost + e[1];\\n                    pq.offer(new int[]{e[0], \\n                                       minCost[curStops + 1][e[0]], \\n                                       curStops + 1});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\nBellman-ford algorithm, finding best path within k steps:\\nJust run the algo k times (or k+1, figure it out by considering a easy case).\\n```\\nclass Solution {\\n    // Bellman ford, natural strategy for best path within\\n    // X range.\\n    // 1 step -> max path len 1 -> 0 stop\\n    // k + 1 step -> path len k+1 -> k stop \\n    public int findCheapestPrice(int n, int[][] flights, \\n                                 int src, int dst, int k) {\\n        int inf = 1000000;\\n        int[] minCost = new int[n];\\n        for (int i = 0; i < n; i++) minCost[i] = inf;\\n        minCost[src] = 0;\\n        \\n        // k + 1 iterations of bellman ford best path expansion.\\n        // i-th iteration results in best path len <= i;\\n        // i+1 th iteration only expands best path len == i, \\n        // cause smaller len best path are expanded in prev iterations.\\n        // So, i+1 iteration has best path len <= i+1;\\n        // So, expanding k+1 rounds, give best path len <= k+1\\n        // Len k + 1 equivalent to k stops.\\n        for (int i = 0; i < k + 1; i++) {\\n            int[] updatedCost = minCost.clone();\\n            for (int[] e : flights) {\\n                // e0 -> e1, cost e2.\\n                // e0 cant be reached.\\n                if (minCost[e[0]] == inf) continue;\\n                \\n                if (minCost[e[0]] + e[2] < updatedCost[e[1]]) {\\n                    updatedCost[e[1]] = minCost[e[0]] + e[2];\\n                }\\n            }\\n            \\n            minCost = updatedCost;\\n        }\\n        \\n        return minCost[dst] == inf ? -1 : minCost[dst];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // modified Dijkstra.\\n    public int findCheapestPrice(int n, int[][] flights, \\n                                 int src, int dst, int k) {\\n        // Build graph.\\n        // node i -> list of (node j, cost)\\n        List<List<int[]>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        \\n        for (int[] f : flights) {\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n        }\\n        \\n        // Queue node is int[] -> loc, cost, stops;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(10,\\n                        (o1, o2) -> o1[1] - o2[1]);\\n        pq.offer(new int[]{src, 0, 0});\\n        \\n        // Min cost tracker.\\n        // min cost for k stop arriving at n node.\\n        int[][] minCost = new int[k + 2][n];\\n        int inf = 1000000;\\n        for (int i = 0; i <= k + 1; i++) {\\n            for (int j = 0; j < n; j++) {\\n                minCost[i][j] = inf;\\n            }\\n        } \\n        \\n        minCost[0][src] = 0;\\n        \\n        // Best first search.\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            \\n            int curNode = cur[0];\\n            int curCost = cur[1];\\n            int curStops = cur[2];\\n            \\n            if (curNode == dst) return curCost;\\n            \\n            // No more stops possible, don\\'t expand.\\n            if (curStops == k + 1) continue;\\n            \\n            // outdated values.\\n            if (curCost > minCost[curStops][cur[0]]) continue;\\n            \\n            // Expand cur best path. \\n            for (int[] e : graph.get(curNode)) {\\n                if (curCost + e[1] < minCost[curStops + 1][e[0]]) {\\n                    // cur -> e[0];\\n                    minCost[curStops + 1][e[0]] = curCost + e[1];\\n                    pq.offer(new int[]{e[0], \\n                                       minCost[curStops + 1][e[0]], \\n                                       curStops + 1});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // Bellman ford, natural strategy for best path within\\n    // X range.\\n    // 1 step -> max path len 1 -> 0 stop\\n    // k + 1 step -> path len k+1 -> k stop \\n    public int findCheapestPrice(int n, int[][] flights, \\n                                 int src, int dst, int k) {\\n        int inf = 1000000;\\n        int[] minCost = new int[n];\\n        for (int i = 0; i < n; i++) minCost[i] = inf;\\n        minCost[src] = 0;\\n        \\n        // k + 1 iterations of bellman ford best path expansion.\\n        // i-th iteration results in best path len <= i;\\n        // i+1 th iteration only expands best path len == i, \\n        // cause smaller len best path are expanded in prev iterations.\\n        // So, i+1 iteration has best path len <= i+1;\\n        // So, expanding k+1 rounds, give best path len <= k+1\\n        // Len k + 1 equivalent to k stops.\\n        for (int i = 0; i < k + 1; i++) {\\n            int[] updatedCost = minCost.clone();\\n            for (int[] e : flights) {\\n                // e0 -> e1, cost e2.\\n                // e0 cant be reached.\\n                if (minCost[e[0]] == inf) continue;\\n                \\n                if (minCost[e[0]] + e[2] < updatedCost[e[1]]) {\\n                    updatedCost[e[1]] = minCost[e[0]] + e[2];\\n                }\\n            }\\n            \\n            minCost = updatedCost;\\n        }\\n        \\n        return minCost[dst] == inf ? -1 : minCost[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686939,
                "title": "python-by-dp-with-bellman-ford-algorithm-w-comment",
                "content": "Python sol by DP with Bellman-Ford algorithm\\n\\n---\\n\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        \\n        price_table = [ float(\\'inf\\') for _ in range(n) ]\\n        \\n        # price of source must be 0\\n        price_table[ src ] = 0\\n\\t\\t\\n        # initialization with 0 transfer\\n        for source, destination, ticket_price in flights:\\n            if source == src:\\n                price_table[destination] = ticket_price\\n        \\n        \\n        # tranfer k times to update price table\\n        for trasfer in range(0, K):\\n            \\n            current_price = [*price_table]\\n            \\n            for source, destination, ticket_price in flights:\\n                \\n                current_price[destination] = min(current_price[destination], price_table[source] + ticket_price )\\n            \\n            # update current price back to price table    \\n            price_table = current_price\\n        \\n        \\n        if price_table[dst] == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return price_table[dst]\\n        \\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Bellman Ford algorithm](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        \\n        price_table = [ float(\\'inf\\') for _ in range(n) ]\\n        \\n        # price of source must be 0\\n        price_table[ src ] = 0\\n\\t\\t\\n        # initialization with 0 transfer\\n        for source, destination, ticket_price in flights:\\n            if source == src:\\n                price_table[destination] = ticket_price\\n        \\n        \\n        # tranfer k times to update price table\\n        for trasfer in range(0, K):\\n            \\n            current_price = [*price_table]\\n            \\n            for source, destination, ticket_price in flights:\\n                \\n                current_price[destination] = min(current_price[destination], price_table[source] + ticket_price )\\n            \\n            # update current price back to price table    \\n            price_table = current_price\\n        \\n        \\n        if price_table[dst] == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return price_table[dst]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099830,
                "title": "leetcode-the-hard-way-explained-line-by-line-3-approaches",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=za7r4Chb3EA&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=26) if you are interested.\\n\\nThere\\'re still other ways to do it - such as modified Dijkstra or BFS. Will include someday when I\\'m free.\\n\\n**Approach 1: DP**\\n\\n```cpp\\n// TC: O(F * K)\\n// SC: O(N * K) \\n// where \\n// - F is the number of flights\\n// - K is the number of stops\\n// - N is the number of cities and K is the number of stops\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // dp[i][j]: min cost to reach city j using at most i edges from src\\n        vector<vector<int>> dp(k + 2, vector<int>(n, INT_MAX));\\n        // base case\\n        for (int i = 0; i <= k + 1; i++) dp[i][src] = 0;\\n        // iterate each stop\\n        for (int i = 1; i <= k + 1; i++) {\\n            // iterate each flight\\n            for (auto f : flights) {\\n                int from = f[0], to = f[1], cost = f[2];\\n                // ensure city `from` is reachable \\n                if (dp[i - 1][from] != INT_MAX) {\\n                    // from + cost -> to\\n                    dp[i][to] = min(dp[i][to], dp[i - 1][from] + cost);   \\n                }\\n            }\\n        }\\n        // if dp[k + 1][dst] == INT_MAX, it means it is unreachable\\n        // else return the cost\\n        return dp[k + 1][dst] == INT_MAX ? -1 : dp[k + 1][dst];\\n    }\\n};\\n```\\n\\n**Approach 2: Bellman Ford**\\n\\n```cpp\\n// TC: O(F * K + N * K)\\n// SC: O(F) \\n// where \\n// - F is the number of flights\\n// - K is the number of stops\\n// - N is the number of cities and K is the number of stops\\nclass Solution {\\npublic:\\n    // https://leetcodethehardway.com/tutorials/graph-theory/bellman-ford-algorithm\\n    template<typename T_a3, typename T_vector>\\n    void bellman_ford(T_a3 &g, T_vector &dist, int src, int mx_edges) {\\n        dist[src] = 0;\\n        for (int i = 0; i <= mx_edges; i++) {\\n            T_vector ndist = dist;\\n            for (auto x : g) {\\n                auto [from, to, cost] = x;\\n                ndist[to] = min(ndist[to], dist[from] + cost);\\n            }\\n            dist = ndist;\\n        }\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // we can directly use bellman ford template here (prerequisite: you need to understand bellman ford algo)\\n        // bellman ford algo is used to find the shortest paths from source node to other nodes in a weighted graph\\n        vector<array<int, 3>> g;\\n        // initially cost with a large value\\n        // cost[i] means the cheapest price from src to city i\\n        vector<int> cost(n, 1e9);\\n        // reconstruct a bit - {src, dst, cost}\\n        for (auto f : flights) g.push_back({f[0], f[1], f[2]});\\n        bellman_ford(g, cost, src, k);\\n        // if cost[dst] == 1e9, it means it is unreachable\\n        // else we can show cost[dst]\\n        return cost[dst] == 1e9 ? -1 : cost[dst];\\n    }\\n};\\n```\\n\\n**Approach 3: Dijkstra\\'s Algorithm**\\n\\nWe can use Dijkstra\\'s Algorithm to find the shortest path. Dijkstra\\'s Algorithm uses a heap for weights of distance we travelled, meaning with a min heap we can always check the path that is currently the shortest. One key difference though is instead of a visited set, we will use a hash map, as we might visit a city early, but run out of stops and a set would prevent us from reaching this city again. So to prevent this we can use a hash map that maps cities to stops, and if we reach a city with fewer stops than last time, we can visit this city again.\\n\\nTime Complexity: $$O((F + C)logC)$$ Where $$F$$ is the number of flights, and $$C$$ is the number of cities. Worst case we must take all flights and visit all cities, updating our heap $$logC$$ times at each city.\\n\\nSpace Complexity: $$O(C)$$ Where $$C$$ is the number of cities. We must create an adjacency list, a heap, and a visited dictionary, all of which scale proportionally to the number of cities.\\n\\n```py\\n# written by @ColeB2\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        # create an adjacency list\\n        adj_list = [[] for _ in range(n)]\\n        # adjacenty list will be a list for cities and prices\\n        # we can fly to from a desitination, i, in the list.\\n        for from_i, to_i, price_i in flights:\\n            adj_list[from_i].append((to_i, price_i))\\n        # heap (price, stops, destination)\\n        heap = [(0, 0, src)]\\n        visited = defaultdict(int)\\n\\n        while heap:\\n            # pop off the lowest price destination in our heap.\\n            # Tracking price, # of stops we took, and destination.\\n            price, stops, dest = heapq.heappop(heap)\\n            # if we reached the destination, return the total price.\\n            if dest == dst:\\n                return price\\n            # Track the destination as visited, and stops to reach it.\\n            visited[dest] = stops\\n            # Loop through all potential flights from current destination.\\n            for to_i, price_i in adj_list[dest]:\\n                # stops > k, it means this path doesn\\'t work.\\n                # also if to destination isn\\'t visited, or it is\\n                # visited, but the # of stops < # of stops it took us\\n                # to reach the city the last time:\\n                if stops <= k and (to_i not in visited or stops < visited[to_i]):\\n                    # add that destination to the queue.\\n                    # price, stops, to destination. Where price is the\\n                    # current running price + price to fly there.\\n                    # The stops should be incremented by 1, and\\n                    # the destination is the to_i value.\\n                    heapq.heappush(heap, (price + price_i, stops + 1, to_i))\\n        # process everything but never reach destination, return -1\\n        return -1\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n// TC: O(F * K)\\n// SC: O(N * K) \\n// where \\n// - F is the number of flights\\n// - K is the number of stops\\n// - N is the number of cities and K is the number of stops\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // dp[i][j]: min cost to reach city j using at most i edges from src\\n        vector<vector<int>> dp(k + 2, vector<int>(n, INT_MAX));\\n        // base case\\n        for (int i = 0; i <= k + 1; i++) dp[i][src] = 0;\\n        // iterate each stop\\n        for (int i = 1; i <= k + 1; i++) {\\n            // iterate each flight\\n            for (auto f : flights) {\\n                int from = f[0], to = f[1], cost = f[2];\\n                // ensure city `from` is reachable \\n                if (dp[i - 1][from] != INT_MAX) {\\n                    // from + cost -> to\\n                    dp[i][to] = min(dp[i][to], dp[i - 1][from] + cost);   \\n                }\\n            }\\n        }\\n        // if dp[k + 1][dst] == INT_MAX, it means it is unreachable\\n        // else return the cost\\n        return dp[k + 1][dst] == INT_MAX ? -1 : dp[k + 1][dst];\\n    }\\n};\\n```\n```cpp\\n// TC: O(F * K + N * K)\\n// SC: O(F) \\n// where \\n// - F is the number of flights\\n// - K is the number of stops\\n// - N is the number of cities and K is the number of stops\\nclass Solution {\\npublic:\\n    // https://leetcodethehardway.com/tutorials/graph-theory/bellman-ford-algorithm\\n    template<typename T_a3, typename T_vector>\\n    void bellman_ford(T_a3 &g, T_vector &dist, int src, int mx_edges) {\\n        dist[src] = 0;\\n        for (int i = 0; i <= mx_edges; i++) {\\n            T_vector ndist = dist;\\n            for (auto x : g) {\\n                auto [from, to, cost] = x;\\n                ndist[to] = min(ndist[to], dist[from] + cost);\\n            }\\n            dist = ndist;\\n        }\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // we can directly use bellman ford template here (prerequisite: you need to understand bellman ford algo)\\n        // bellman ford algo is used to find the shortest paths from source node to other nodes in a weighted graph\\n        vector<array<int, 3>> g;\\n        // initially cost with a large value\\n        // cost[i] means the cheapest price from src to city i\\n        vector<int> cost(n, 1e9);\\n        // reconstruct a bit - {src, dst, cost}\\n        for (auto f : flights) g.push_back({f[0], f[1], f[2]});\\n        bellman_ford(g, cost, src, k);\\n        // if cost[dst] == 1e9, it means it is unreachable\\n        // else we can show cost[dst]\\n        return cost[dst] == 1e9 ? -1 : cost[dst];\\n    }\\n};\\n```\n```py\\n# written by @ColeB2\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        # create an adjacency list\\n        adj_list = [[] for _ in range(n)]\\n        # adjacenty list will be a list for cities and prices\\n        # we can fly to from a desitination, i, in the list.\\n        for from_i, to_i, price_i in flights:\\n            adj_list[from_i].append((to_i, price_i))\\n        # heap (price, stops, destination)\\n        heap = [(0, 0, src)]\\n        visited = defaultdict(int)\\n\\n        while heap:\\n            # pop off the lowest price destination in our heap.\\n            # Tracking price, # of stops we took, and destination.\\n            price, stops, dest = heapq.heappop(heap)\\n            # if we reached the destination, return the total price.\\n            if dest == dst:\\n                return price\\n            # Track the destination as visited, and stops to reach it.\\n            visited[dest] = stops\\n            # Loop through all potential flights from current destination.\\n            for to_i, price_i in adj_list[dest]:\\n                # stops > k, it means this path doesn\\'t work.\\n                # also if to destination isn\\'t visited, or it is\\n                # visited, but the # of stops < # of stops it took us\\n                # to reach the city the last time:\\n                if stops <= k and (to_i not in visited or stops < visited[to_i]):\\n                    # add that destination to the queue.\\n                    # price, stops, to destination. Where price is the\\n                    # current running price + price to fly there.\\n                    # The stops should be incremented by 1, and\\n                    # the destination is the to_i value.\\n                    heapq.heappush(heap, (price + price_i, stops + 1, to_i))\\n        # process everything but never reach destination, return -1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115623,
                "title": "10-line-python-dp-solution-o-n-2-k-time-o-n-space",
                "content": "At every iteration compute the min cost to reach every city.\n\n```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        \"\"\"\n        :type n: int\n        :type flights: List[List[int]]\n        :type src: int\n        :type dst: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        INF=float('inf')\n        mn=[INF]*n\n        mn[src]=0\n        \n        for k in range(K+1):\n            newmn=mn[:]\n            for (a,b, cost) in flights:\n                newmn[b]=min(newmn[b],mn[a]+cost)\n            mn=newmn\n            \n        return mn[dst] if mn[dst]!=INF else -1\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        \"\"\"\n        :type n: int\n        :type flights: List[List[int]]\n        :type src: int\n        :type dst: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        INF=float('inf')\n        mn=[INF]*n\n        mn[src]=0\n        \n        for k in range(K+1):\n            newmn=mn[:]\n            for (a,b, cost) in flights:\n                newmn[b]=min(newmn[b],mn[a]+cost)\n            mn=newmn\n            \n        return mn[dst] if mn[dst]!=INF else -1\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100580,
                "title": "c-dfs-dp-short-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\n    const int inf = 1e8;\\n    int dp[101][101];\\n\\npublic:\\n    int dfs(int node, int k, int dest, vector<vector<int>> &cost, vector<int> adj[])\\n    {\\n        if (k < 0)\\n            return inf;\\n\\n        if (node == dest)\\n            return 0;\\n\\n        if (dp[node][k] != -1)\\n            return dp[node][k];\\n\\n        int ans = inf;\\n        for (auto i : adj[node])\\n            ans = min(ans, cost[node][i] + dfs(i, k - 1, dest, cost, adj));\\n\\n        return dp[node][k] = ans;\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int k)\\n    {\\n        memset(dp, -1, sizeof dp);\\n\\n        vector<vector<int>> cost(n, vector<int>(n));\\n        vector<int> adj[n];\\n        for (auto e : flights)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            cost[e[0]][e[1]] = e[2];\\n        }\\n\\n        int ans = dfs(src, k + 1, dst, cost, adj);\\n        return ans == inf ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    const int inf = 1e8;\\n    int dp[101][101];\\n\\npublic:\\n    int dfs(int node, int k, int dest, vector<vector<int>> &cost, vector<int> adj[])\\n    {\\n        if (k < 0)\\n            return inf;\\n\\n        if (node == dest)\\n            return 0;\\n\\n        if (dp[node][k] != -1)\\n            return dp[node][k];\\n\\n        int ans = inf;\\n        for (auto i : adj[node])\\n            ans = min(ans, cost[node][i] + dfs(i, k - 1, dest, cost, adj));\\n\\n        return dp[node][k] = ans;\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int k)\\n    {\\n        memset(dp, -1, sizeof dp);\\n\\n        vector<vector<int>> cost(n, vector<int>(n));\\n        vector<int> adj[n];\\n        for (auto e : flights)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            cost[e[0]][e[1]] = e[2];\\n        }\\n\\n        int ans = dfs(src, k + 1, dst, cost, adj);\\n        return ans == inf ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181943,
                "title": "readable-javascript-solution",
                "content": "I know this isn\\'t the fastest solution, but it\\'s quite readable and using BFS.\\nBasic idea is \\n1. Construct a map of key/value pair of startingCity and [desitnationCity, price]\\n2. Start from src with price of 0 with stops (K) of K + 1.\\n3. Using queue (BFS), check current node and see if you have already arrived or push nextFlights into the queue\\n4. If you push nextFlights into the queue, sort it by the price (this is mimicing Priority Queue)\\n\\nSlowness comes from unoptimized Priority Queue.\\n\\n```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    let map = new Map();\\n    \\n    for (let i = 0; i < flights.length; i++) {\\n        const [start, end, price] = flights[i];\\n        let edges = map.get(start) || [];\\n        edges.push([end, price]);\\n        map.set(start, edges);\\n    }\\n    \\n    let queue = [[0, src, K + 1]];\\n    \\n    while (queue.length) {\\n        const [price, city, stops] = queue.shift();\\n        if (city === dst) return price;\\n        if (stops > 0) {\\n            const nextFlights = map.get(city) || [];\\n            for (let i = 0; i < nextFlights.length; i++) {\\n                const [next, cost] = nextFlights[i];\\n                queue.push([cost + price, next, stops - 1]);\\n            }\\n            queue.sort((a, b) => a[0] - b[0]);\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    let map = new Map();\\n    \\n    for (let i = 0; i < flights.length; i++) {\\n        const [start, end, price] = flights[i];\\n        let edges = map.get(start) || [];\\n        edges.push([end, price]);\\n        map.set(start, edges);\\n    }\\n    \\n    let queue = [[0, src, K + 1]];\\n    \\n    while (queue.length) {\\n        const [price, city, stops] = queue.shift();\\n        if (city === dst) return price;\\n        if (stops > 0) {\\n            const nextFlights = map.get(city) || [];\\n            for (let i = 0; i < nextFlights.length; i++) {\\n                const [next, cost] = nextFlights[i];\\n                queue.push([cost + price, next, stops - 1]);\\n            }\\n            queue.sort((a, b) => a[0] - b[0]);\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166443,
                "title": "ac-simple-bfs-5ms-no-pq-beats-99-of-submissions",
                "content": "The idea is to perform a BFS from `src` upto only `K` levels. I initially hit a Memory limit but was able to get around by adding a `minPrices` check to skip exploring from a node if it does not give better result.\\nCode below - \\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        //convert flights[] to a weighted graph\\n        //perform BFS starting from src going only max depth of K\\n        //For Each node track the cost associated to reach that node\\n        int min = Integer.MAX_VALUE;\\n        int[][] graph = new int[n][n];\\n        int[] minPrices = new int[n];\\n        for (int[] flight : flights) {\\n            int start = flight[0];\\n            int end = flight[1];\\n            graph[start][end] = flight[2];\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        Queue<Integer> prices = new LinkedList<>();\\n        q.add(src);\\n        prices.add(0);\\n        while (!q.isEmpty() && K >= 0) {\\n            K--;\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int start = q.poll();\\n                int priceTillNow = prices.poll();\\n                for (int j = 0; j < n; j++) {\\n                    int price = graph[start][j];\\n                    if (price > 0) {    //there is a flight\\n                        int curPrice = priceTillNow + price;\\n                        int oldPrice = minPrices[j];\\n                        //If there is a cheaper flight with lesser stops do not add it to q\\n                        if (oldPrice == 0 || oldPrice > curPrice) {\\n                            minPrices[j] = curPrice;\\n                            q.add(j);\\n                            prices.add(curPrice);\\n                            if (j == dst && min > curPrice) {\\n                                min = curPrice;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        //convert flights[] to a weighted graph\\n        //perform BFS starting from src going only max depth of K\\n        //For Each node track the cost associated to reach that node\\n        int min = Integer.MAX_VALUE;\\n        int[][] graph = new int[n][n];\\n        int[] minPrices = new int[n];\\n        for (int[] flight : flights) {\\n            int start = flight[0];\\n            int end = flight[1];\\n            graph[start][end] = flight[2];\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        Queue<Integer> prices = new LinkedList<>();\\n        q.add(src);\\n        prices.add(0);\\n        while (!q.isEmpty() && K >= 0) {\\n            K--;\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int start = q.poll();\\n                int priceTillNow = prices.poll();\\n                for (int j = 0; j < n; j++) {\\n                    int price = graph[start][j];\\n                    if (price > 0) {    //there is a flight\\n                        int curPrice = priceTillNow + price;\\n                        int oldPrice = minPrices[j];\\n                        //If there is a cheaper flight with lesser stops do not add it to q\\n                        if (oldPrice == 0 || oldPrice > curPrice) {\\n                            minPrices[j] = curPrice;\\n                            q.add(j);\\n                            prices.add(curPrice);\\n                            if (j == dst && min > curPrice) {\\n                                min = curPrice;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188471,
                "title": "bfs-level-order-99-49-faster-dijikstra-tle-explanation-with-images",
                "content": "**Approach 1: Using Dijkstra[TLE]**\\nIt happen to be the same idea of Dijkstra\\'s algorithm, but we need to keep the path. \\n*We consider current cost or not but we have to keep the track of path cost*. As currently it\\'s higher but for some other path we may get the minimum value at some other nodes(stops),considering this current cost. Consider Below Example for more clearity.\\n\\n***Code:***\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Approach 1: Using Dijksrta[TLE]\\n         vector<pair<int,int>> adj[n];\\n        // prepare an adjacency list\\n        for(int i = 0; i < flights.size(); i++){\\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            adj[u].push_back({v,w});\\n        }\\n        \\n        // create a distence vetor\\n        vector<int> disTo(n+1,INT_MAX);\\n        disTo[src] = 0;  // src is the source node\\n        \\n        priority_queue< pair<int,pair<int, int>>, vector<pair<int,pair<int, int>>>,greater<pair<int,pair<int,int>>> > pq;\\n        \\n        pq.push({0,{src,k+1}}); // {cost,{node,remainedStops}}\\n                 \\n        while(!pq.empty())\\n        {\\n            int cost = pq.top().first;\\n            int node = pq.top().second.first;\\n            int remStops = pq.top().second.second;\\n            pq.pop();\\n            \\n            if(node == dst){\\n                 return disTo[dst];\\n            }\\n            if(remStops == 0){\\n                 continue;\\n            }\\n            \\n            for(auto it: adj[node])\\n            {\\n                int next = it.first;\\n                int nextDis =it.second;\\n\\t\\t\\t\\t\\n                 if((cost + nextDis) < disTo[next]){\\n                 disTo[next] = cost + nextDis;\\n                }\\n                pq.push({cost + nextDis,{next,remStops-1}}); \\n          // We consider current cost or not but we have to keep the track of path cost, \\n          // As currently it\\'s higher but for some other path we may get the minimum value at some other nodes(stops),considering this current cost.\\n            }\\n        }\\n        \\n        if(disTo[dst] == INT_MAX) return -1;\\n        return disTo[dst];\\n    }\\n};\\n```\\n*NOTE* : You can do it by Dijkstra using DP but here i will be not discussing that.\\n\\n**Approach 2: Using BFS Levelwise Traversal**\\n\\n***Intution*** : Since we are allowed only K stops, so either we can reach the Destination Or Not depend on value of K.\\nSo the idea is to perform BFS K+1 times (considering src also), as we are allowed only K stops so at each level of BFS we will reach to stops with best possible cost.\\n\\n**NOTE:** *We can apply this same approach to all problem where we are bounded with some threshold value, we have to find the minimum path.*\\n\\n*Let\\'s take a example for more clearity:* \\n![image](https://assets.leetcode.com/users/images/054125b6-b556-47e2-bc46-63489468f36a_1656006744.3018532.jpeg)\\n![image](https://assets.leetcode.com/users/images/39f275e6-8f59-437d-9035-dac5a0672c66_1656008056.9923012.jpeg)\\n\\n\\n***Code:***\\n```\\nclass Solution {\\npublic:\\n    // Approach 2: Level Wise BFS \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n         vector<pair<int,int>> adj[n];\\n        // prepare an adjacency list\\n        for(int i = 0; i < flights.size(); i++){\\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            adj[u].push_back({v,w});\\n        }\\n        \\n        // create a distence vetor\\n        vector<int> disTo(n+1,INT_MAX);\\n        disTo[src] = 0;  // src is the source node\\n        \\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,src}); // {{cost,node}}\\n        k = k + 1;    \\n        \\n        while(!q.empty())\\n        {\\n         \\n            int size = q.size();\\n            k--;\\n            if(k < 0) break;\\n            // Do level Wise : Traverse all stops at current level and find best path to each stop\\n            for(int i = 0; i < size; i++)\\n            {\\n              auto curr = q.front(); q.pop();\\n              int node = curr.second;\\n              int cost = curr.first;\\n                 \\n              for(auto it: adj[node])\\n              {\\n                if(cost + it.second < disTo[it.first])\\n                {\\n                   disTo[it.first] = cost + it.second;\\n                   q.push({disTo[it.first],it.first});\\n                }\\n              }\\n             }\\n        }\\n        \\n        if(disTo[dst] == INT_MAX) return -1;\\n        return disTo[dst];\\n    }\\n};\\n```\\nSimiler Problem On 2D : https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/ \\nHope it helps you :)",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Approach 1: Using Dijksrta[TLE]\\n         vector<pair<int,int>> adj[n];\\n        // prepare an adjacency list\\n        for(int i = 0; i < flights.size(); i++){\\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            adj[u].push_back({v,w});\\n        }\\n        \\n        // create a distence vetor\\n        vector<int> disTo(n+1,INT_MAX);\\n        disTo[src] = 0;  // src is the source node\\n        \\n        priority_queue< pair<int,pair<int, int>>, vector<pair<int,pair<int, int>>>,greater<pair<int,pair<int,int>>> > pq;\\n        \\n        pq.push({0,{src,k+1}}); // {cost,{node,remainedStops}}\\n                 \\n        while(!pq.empty())\\n        {\\n            int cost = pq.top().first;\\n            int node = pq.top().second.first;\\n            int remStops = pq.top().second.second;\\n            pq.pop();\\n            \\n            if(node == dst){\\n                 return disTo[dst];\\n            }\\n            if(remStops == 0){\\n                 continue;\\n            }\\n            \\n            for(auto it: adj[node])\\n            {\\n                int next = it.first;\\n                int nextDis =it.second;\\n\\t\\t\\t\\t\\n                 if((cost + nextDis) < disTo[next]){\\n                 disTo[next] = cost + nextDis;\\n                }\\n                pq.push({cost + nextDis,{next,remStops-1}}); \\n          // We consider current cost or not but we have to keep the track of path cost, \\n          // As currently it\\'s higher but for some other path we may get the minimum value at some other nodes(stops),considering this current cost.\\n            }\\n        }\\n        \\n        if(disTo[dst] == INT_MAX) return -1;\\n        return disTo[dst];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // Approach 2: Level Wise BFS \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n         vector<pair<int,int>> adj[n];\\n        // prepare an adjacency list\\n        for(int i = 0; i < flights.size(); i++){\\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            adj[u].push_back({v,w});\\n        }\\n        \\n        // create a distence vetor\\n        vector<int> disTo(n+1,INT_MAX);\\n        disTo[src] = 0;  // src is the source node\\n        \\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,src}); // {{cost,node}}\\n        k = k + 1;    \\n        \\n        while(!q.empty())\\n        {\\n         \\n            int size = q.size();\\n            k--;\\n            if(k < 0) break;\\n            // Do level Wise : Traverse all stops at current level and find best path to each stop\\n            for(int i = 0; i < size; i++)\\n            {\\n              auto curr = q.front(); q.pop();\\n              int node = curr.second;\\n              int cost = curr.first;\\n                 \\n              for(auto it: adj[node])\\n              {\\n                if(cost + it.second < disTo[it.first])\\n                {\\n                   disTo[it.first] = cost + it.second;\\n                   q.push({disTo[it.first],it.first});\\n                }\\n              }\\n             }\\n        }\\n        \\n        if(disTo[dst] == INT_MAX) return -1;\\n        return disTo[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925905,
                "title": "bfs-solution-beats-98-submissions-explanations-are-given",
                "content": "This is no way a medium difficult problem! Its more on the harder side. And I wasted lots of time thinking of a solution using Dijkstra algorithm whereas it could have been easily solved using a simple modified bfs!!\\n\\nI used modified bfs to find all possible \"valid\" paths to the destination node and returned the minimum cost from them. Here, \"valid\" path means it has at most k stops or simply it has total nodes  **less than or equal to (k +2)**.\\nCode with comments is given below. You can comment if you still have any confusion. I will be happy to reply. \\n\\n```\\nclass Solution {\\n    typedef pair<int, int> pii;\\n    typedef tuple<int, int, int> tiii;\\npublic:\\n    const int inf = 1e9;\\n    vector<pii> adj[110];\\n\\n    int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int k) {\\n        for (auto &e: flights)\\n            adj[e[0]].emplace_back(make_pair(e[1], e[2]));\\n\\n        return bfs(src, dst, k, n);\\n    }\\n\\n    int bfs(int src, int dest, int k, int n) {\\n        queue<tiii> q;\\n        vector<int> costs(n, inf); // stores minimum costs to travel to any node from souce using at mosts k+2 nodes\\n        costs[src] = 0; // source to source travel cost is 0\\n        q.push({src, 0, 1}); // {node, cost, stops}\\n\\n        while (!q.empty()) {\\n            auto[currNode, currCost, currTotalNodes] = q.front();\\n            q.pop();\\n\\n            // Having k stops between source and destination equals to total of k + 2 nodes in the path (including source and destination)\\n            // So, if path to currNode already has total k+2 nodes, there is no point to go any further\\n            if (currTotalNodes == k + 2)\\n                continue;\\n\\n            for (auto &[nextNode, cost]: adj[currNode]) { //iterate over all the neighbors of currNode\\n                int nextCost = currCost + cost;\\n                int nextTotalNodes = currTotalNodes + 1;\\n\\n                // Below if condition is the modified version of standard bfs.\\n                // In the standard bfs we don\\'t add a node again to the queue if it has been visited before.\\n                // Here, we may add a node again to the queue if current path to it has less cost than previously traversed paths.\\n                if (nextCost < costs[nextNode]) {\\n                    costs[nextNode] = nextCost; //update costs to reach nextNode\\n                    q.push({nextNode, nextCost, nextTotalNodes});\\n                }\\n            }\\n        }\\n\\n        if (costs[dest] == inf)\\n            return -1;\\n        else return costs[dest];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    typedef pair<int, int> pii;\\n    typedef tuple<int, int, int> tiii;\\npublic:\\n    const int inf = 1e9;\\n    vector<pii> adj[110];\\n\\n    int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int k) {\\n        for (auto &e: flights)\\n            adj[e[0]].emplace_back(make_pair(e[1], e[2]));\\n\\n        return bfs(src, dst, k, n);\\n    }\\n\\n    int bfs(int src, int dest, int k, int n) {\\n        queue<tiii> q;\\n        vector<int> costs(n, inf); // stores minimum costs to travel to any node from souce using at mosts k+2 nodes\\n        costs[src] = 0; // source to source travel cost is 0\\n        q.push({src, 0, 1}); // {node, cost, stops}\\n\\n        while (!q.empty()) {\\n            auto[currNode, currCost, currTotalNodes] = q.front();\\n            q.pop();\\n\\n            // Having k stops between source and destination equals to total of k + 2 nodes in the path (including source and destination)\\n            // So, if path to currNode already has total k+2 nodes, there is no point to go any further\\n            if (currTotalNodes == k + 2)\\n                continue;\\n\\n            for (auto &[nextNode, cost]: adj[currNode]) { //iterate over all the neighbors of currNode\\n                int nextCost = currCost + cost;\\n                int nextTotalNodes = currTotalNodes + 1;\\n\\n                // Below if condition is the modified version of standard bfs.\\n                // In the standard bfs we don\\'t add a node again to the queue if it has been visited before.\\n                // Here, we may add a node again to the queue if current path to it has less cost than previously traversed paths.\\n                if (nextCost < costs[nextNode]) {\\n                    costs[nextNode] = nextCost; //update costs to reach nextNode\\n                    q.push({nextNode, nextCost, nextTotalNodes});\\n                }\\n            }\\n        }\\n\\n        if (costs[dest] == inf)\\n            return -1;\\n        else return costs[dest];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519110,
                "title": "c-dijkstra-optimised-with-dp-new-approach-with-step-by-step-comments-in-code-clean",
                "content": "DIJKSTRA OPTIMISED with DP \\n\\n```\\nclass Solution {\\npublic:\\n    // Dijkstra with DP    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // create adjacenct list where adj[u] consists of a pair (v, weight from u to v )\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto i: flights){\\n            adj[i[0]].push_back({i[1], i[2]});\\n        }\\n        \\n        // create a 2D distance vector (acts like DP), where each element (dis[i][j]) represents the distance of \\'i\\' from \\'src\\' when there are \\'j\\' stops left.\\n        vector<vector<int>> dis(n+1, vector<int>(k+1,INT_MAX));\\n        \\n        \\n        // Dijkstra starts\\n        \\n        // Create a set (acts like priority queue) which holds { present weight or distance , { node, remaining stops } }\\n        set<pair<int,pair<int,int>>> se;\\n        // distance of src from src is 0 and there are k stops left\\n        se.insert({0,{src, k}});\\n        dis[src][k] = 0; // distance of src is 0 when k stops are left\\n        \\n        while(!se.empty()){\\n            // present element\\n            pair<int,pair<int,int>> pres = *(se.begin());\\n            // poping out pres\\n            se.erase(se.begin());\\n            \\n            int u = pres.second.first;\\n            // if reached dst. continue\\n            if( dst == u ) continue;\\n            \\n            // looping through the children of u ( i.e, all the v\\'s )\\n            for(pair<int,int> i : adj[u]){\\n                \\n                int presWeight = pres.first;\\n                int costUtoV = i.second;\\n                int v = i.first;\\n                int remainingK = pres.second.second;\\n                \\n                // if presentWeght + cost of u-> v is less than distance of \\'v\\' with \\'remainingK\\' stops left.  \\n                if(  presWeight + costUtoV < dis[v][remainingK]  ){\\n                    if( remainingK > 0 || (v == dst && remainingK == 0)){\\n                        // updating dis[v][remainingK]\\n                        dis[v][remainingK] = presWeight + costUtoV;\\n                        // pushing it to our set.\\n                        se.insert({costUtoV + presWeight, { v, remainingK-1 }});\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        // loop through all the \\'k\\' possibilities of reaching \\'dst\\' and choose the min\\n        for(int i  :dis[dst]) ans = min(i,ans);\\n        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n\\n~ My own solution.\\nUpvote if you like the solution.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Dijkstra with DP    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // create adjacenct list where adj[u] consists of a pair (v, weight from u to v )\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto i: flights){\\n            adj[i[0]].push_back({i[1], i[2]});\\n        }\\n        \\n        // create a 2D distance vector (acts like DP), where each element (dis[i][j]) represents the distance of \\'i\\' from \\'src\\' when there are \\'j\\' stops left.\\n        vector<vector<int>> dis(n+1, vector<int>(k+1,INT_MAX));\\n        \\n        \\n        // Dijkstra starts\\n        \\n        // Create a set (acts like priority queue) which holds { present weight or distance , { node, remaining stops } }\\n        set<pair<int,pair<int,int>>> se;\\n        // distance of src from src is 0 and there are k stops left\\n        se.insert({0,{src, k}});\\n        dis[src][k] = 0; // distance of src is 0 when k stops are left\\n        \\n        while(!se.empty()){\\n            // present element\\n            pair<int,pair<int,int>> pres = *(se.begin());\\n            // poping out pres\\n            se.erase(se.begin());\\n            \\n            int u = pres.second.first;\\n            // if reached dst. continue\\n            if( dst == u ) continue;\\n            \\n            // looping through the children of u ( i.e, all the v\\'s )\\n            for(pair<int,int> i : adj[u]){\\n                \\n                int presWeight = pres.first;\\n                int costUtoV = i.second;\\n                int v = i.first;\\n                int remainingK = pres.second.second;\\n                \\n                // if presentWeght + cost of u-> v is less than distance of \\'v\\' with \\'remainingK\\' stops left.  \\n                if(  presWeight + costUtoV < dis[v][remainingK]  ){\\n                    if( remainingK > 0 || (v == dst && remainingK == 0)){\\n                        // updating dis[v][remainingK]\\n                        dis[v][remainingK] = presWeight + costUtoV;\\n                        // pushing it to our set.\\n                        se.insert({costUtoV + presWeight, { v, remainingK-1 }});\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        // loop through all the \\'k\\' possibilities of reaching \\'dst\\' and choose the min\\n        for(int i  :dis[dst]) ans = min(i,ans);\\n        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738656,
                "title": "python3-modified-spfa-with-explanation-and-comments",
                "content": "Use SPFA with minor modification. The key idea here is that we create a \"cost_map\" dictionary that stores cities we have visited and the minimum price to get there. During SPFA, if we see a city that is not in the \"visited\" dictionary, we visit it and set/update \"cost_map[city]\" to the price to get there. If it\\'s already in the \"cost_map\" dictionary, we visit it if and only if we can visit it with a lower price. Also, if the current steps >= K, we don\\'t append it to queue. \\n\\nFinally, if the destination is in the \"cost_map\" dictionary, we can return it since we have visited it within K stops and we know that the price is going to be minimum. If destination is not in the \"cost_map\" dictionary, we\\'ve never visited the destination within K stops, return -1.\\n\\n```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        # build adjacency list\\n        neighbors = defaultdict(list)\\n        for source, dest, price in flights:\\n            neighbors[source].append([dest, price])\\n        \\n        # modified SPFA\\n        cost_map = {src: 0} \\n        queue = deque([(src, 0, 0)])\\n        while queue:\\n            city, cost_so_far, stops_taken = queue.popleft()\\n            for next_city, travel_cost in neighbors[city]:\\n                if next_city not in cost_map or travel_cost + cost_so_far < cost_map[next_city]:\\n                    cost_map[next_city] = travel_cost + cost_so_far\\n                    if stops_taken < K:\\n                        queue.append((next_city, cost_map[next_city], stops_taken + 1))\\n\\n        return cost_map[dst] if dst in cost_map else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        # build adjacency list\\n        neighbors = defaultdict(list)\\n        for source, dest, price in flights:\\n            neighbors[source].append([dest, price])\\n        \\n        # modified SPFA\\n        cost_map = {src: 0} \\n        queue = deque([(src, 0, 0)])\\n        while queue:\\n            city, cost_so_far, stops_taken = queue.popleft()\\n            for next_city, travel_cost in neighbors[city]:\\n                if next_city not in cost_map or travel_cost + cost_so_far < cost_map[next_city]:\\n                    cost_map[next_city] = travel_cost + cost_so_far\\n                    if stops_taken < K:\\n                        queue.append((next_city, cost_map[next_city], stops_taken + 1))\\n\\n        return cost_map[dst] if dst in cost_map else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690994,
                "title": "javascript-clean-dijkstra-s-algorithm",
                "content": "```javascript\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    const adjacencyList = new Map();\\n    \\n    for(let [start, end, cost] of flights) {\\n        if(adjacencyList.has(start)) adjacencyList.get(start).push([end, cost]);\\n        else adjacencyList.set(start, [[end, cost]]);\\n    }\\n    \\n    const queue = [[0, src, K+1]];\\n    const visited = new Map();\\n    \\n    while(queue.length) {\\n        queue.sort((a, b) => a[0] - b[0]);\\n        \\n        const [cost, city, stops] = queue.shift();\\n        visited.set(city, stops);\\n        \\n        if(city === dst) return cost;\\n        if(stops <= 0 || !adjacencyList.has(city))  continue;\\n            \\n        for(let [nextCity, nextCost] of adjacencyList.get(city)) {\\n            if(visited.has(nextCity) && visited.get(nextCity) >= stops-1) continue;\\n            queue.push([cost+nextCost, nextCity, stops-1]);\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    const adjacencyList = new Map();\\n    \\n    for(let [start, end, cost] of flights) {\\n        if(adjacencyList.has(start)) adjacencyList.get(start).push([end, cost]);\\n        else adjacencyList.set(start, [[end, cost]]);\\n    }\\n    \\n    const queue = [[0, src, K+1]];\\n    const visited = new Map();\\n    \\n    while(queue.length) {\\n        queue.sort((a, b) => a[0] - b[0]);\\n        \\n        const [cost, city, stops] = queue.shift();\\n        visited.set(city, stops);\\n        \\n        if(city === dst) return cost;\\n        if(stops <= 0 || !adjacencyList.has(city))  continue;\\n            \\n        for(let [nextCity, nextCost] of adjacencyList.get(city)) {\\n            if(visited.has(nextCity) && visited.get(nextCity) >= stops-1) continue;\\n            queue.push([cost+nextCost, nextCity, stops-1]);\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436785,
                "title": "python-solution-dijkstra-s-explained",
                "content": "Update: Modified solution. Hat-tip to @wangken82 for catching a bug, and LC admins for adding new test cases! :)\\n\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        import heapq\\n        from collections import defaultdict\\n\\n        #Make graph\\n        adj_list = defaultdict(list)\\n        for u, v, w in flights:\\n            adj_list[u].append((v,w))\\n\\n        prior_queue = [ (0, -1, src) ] #weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if steps>k:\\n                continue\\n\\n            if node==dst:\\n                return cost\\n\\n            for neighb, weight in adj_list[node]:\\n                heapq.heappush(prior_queue, (cost+weight, steps + 1, neighb))\\n\\n        return -1\\n\\n```\\n\\nDijkstra\\'s is a variant of BFS. The important thing to notice is that when you remove/pop elements from the queue as in a BFS, just pop the one which is closest to the current node - that\\'s it!\\n\\nAnother caveat in this problem though, (unlike regular BFS) is not to mark a node as visited after reaching it through one path. There could be other valid paths that could lead to the same node that we may have not explored - yet. (We usually mark nodes as visited to prevent infinite loops. I.e if node 0 is connected to node 1, and node 1 is connected to node 0, then if you don\\'t mark nodes as visited, an infinite loop is created. Here the graph is a DAG so we won\\'t have that issue) \\n\\nInspired by this gorgeous article: https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e It\\'s beautifully explained here!\\n\\n**Update**: Optimized solution\\n\\nHT to @krishnancmf8 for this optimization\\n\\nPrevent unnecessary exploration of certain nodes, by keeping tracking of how many stops it took to reach that node when it was visited earlier. On subsequent visits, if number of steps it took to reach the node previously, was **lesser** than the current visit, we can safely ignore the current visit.\\n\\nFor. e.g if Node_5 was visited earlier (it means that a previous path to Node_5 cost lesser than the current path), and we stored the number of stops it took to reach Node_5 as 7.  Now, say we are have popped Node_5 again, (remember, this path is costlier), and consider two cases:\\na) Number of steps is 15 (greater than 7), so there\\'s no point exploring this further (why? We have already explored a cheaper path that took less steps)\\nb) Number of steps is 4 (less than 7), so there is a possibility that this path could lead us to solution (why? The earlier path may have been cheaper, but eventually may have have taken longer steps, and hence been invalid) \\n\\n**Note**: best_visited dictionary stores the steps taken to get to a node\\n\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        import heapq\\n        from collections import defaultdict\\n\\n        #Make graph\\n        adj_list = defaultdict(list)\\n        for u, v, w in flights:\\n            adj_list[u].append((v,w))\\n        \\n        best_visited = defaultdict(lambda : math.inf) # Initialized to maximum\\n        \\n        prior_queue = [ (0, -1, src) ] #weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if best_visited[node] <= steps:  #Have seen the node already, and the steps are more than last time\\n                continue\\n\\n            if steps>k:  # More than k stops, invalid\\n                continue\\n\\n            if node==dst: \\n                return cost\\n            \\n            best_visited[node] = steps #Update steps\\n\\n            for neighb, weight in adj_list[node]:\\n\\t\\t\\t\\tif steps + 1 < best_visited[neighb]: #Push neighb into the heap, only if steps+1 is better than the last time it was visited\\n\\t\\t\\t\\t\\theapq.heappush(prior_queue, (cost+weight, steps + 1, neighb))\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        import heapq\\n        from collections import defaultdict\\n\\n        #Make graph\\n        adj_list = defaultdict(list)\\n        for u, v, w in flights:\\n            adj_list[u].append((v,w))\\n\\n        prior_queue = [ (0, -1, src) ] #weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if steps>k:\\n                continue\\n\\n            if node==dst:\\n                return cost\\n\\n            for neighb, weight in adj_list[node]:\\n                heapq.heappush(prior_queue, (cost+weight, steps + 1, neighb))\\n\\n        return -1\\n\\n```\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        import heapq\\n        from collections import defaultdict\\n\\n        #Make graph\\n        adj_list = defaultdict(list)\\n        for u, v, w in flights:\\n            adj_list[u].append((v,w))\\n        \\n        best_visited = defaultdict(lambda : math.inf) # Initialized to maximum\\n        \\n        prior_queue = [ (0, -1, src) ] #weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if best_visited[node] <= steps:  #Have seen the node already, and the steps are more than last time\\n                continue\\n\\n            if steps>k:  # More than k stops, invalid\\n                continue\\n\\n            if node==dst: \\n                return cost\\n            \\n            best_visited[node] = steps #Update steps\\n\\n            for neighb, weight in adj_list[node]:\\n\\t\\t\\t\\tif steps + 1 < best_visited[neighb]: #Push neighb into the heap, only if steps+1 is better than the last time it was visited\\n\\t\\t\\t\\t\\theapq.heappush(prior_queue, (cost+weight, steps + 1, neighb))\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295302,
                "title": "c-dijkstra-algo",
                "content": "Hey, I updated the solution with some lines of explanation. Hope you\\'ll like it.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        using ip = pair<int, int>;\\n        vector<vector<ip>> adj(n);\\n        for (auto& f : flights) adj[f[0]].push_back({f[1], f[2]});\\n        using arr = array<int, 3>;\\n        priority_queue<arr, vector<arr>, greater<arr>> pq;\\n        vector<int> dist(n, INT_MAX);\\n        pq.push({0, src, 0});\\n        while (!pq.empty()) {\\n            auto [cost, node, stops] = pq.top();\\n            pq.pop();\\n            if (node == dst) return cost; // if we found destination -> return current cost.\\n            if (stops > k) continue;\\n\\t\\t\\t// Optimization: if we already visit this node and it has fewer stops in \\n\\t\\t\\t// dist array than in pq we don\\'t need to explore it again.\\n            if (dist[node] != INT_MAX && dist[node] < stops) continue;\\n            dist[node] = stops;\\n            for (auto& [next, price] : adj[node]) {\\n                pq.push({cost + price, next, stops + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        using ip = pair<int, int>;\\n        vector<vector<ip>> adj(n);\\n        for (auto& f : flights) adj[f[0]].push_back({f[1], f[2]});\\n        using arr = array<int, 3>;\\n        priority_queue<arr, vector<arr>, greater<arr>> pq;\\n        vector<int> dist(n, INT_MAX);\\n        pq.push({0, src, 0});\\n        while (!pq.empty()) {\\n            auto [cost, node, stops] = pq.top();\\n            pq.pop();\\n            if (node == dst) return cost; // if we found destination -> return current cost.\\n            if (stops > k) continue;\\n\\t\\t\\t// Optimization: if we already visit this node and it has fewer stops in \\n\\t\\t\\t// dist array than in pq we don\\'t need to explore it again.\\n            if (dist[node] != INT_MAX && dist[node] < stops) continue;\\n            dist[node] = stops;\\n            for (auto& [next, price] : adj[node]) {\\n                pq.push({cost + price, next, stops + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516723,
                "title": "four-method-to-solve-this-program",
                "content": "### BFS\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int[] f : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        k++;\\n        int min = Integer.MAX_VALUE; \\n        int[] count = new int[n];// \\u5224\\u65AD\\u662F\\u5426\\u6709\\u73AF\\n        count[src]++; \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{src,0});\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            if(k--==0) break;\\n            while(size-->0){\\n                int[] cur = queue.poll();\\n                Map<Integer,Integer> next = map.getOrDefault(cur[0],null);\\n                if(next==null) continue;\\n                for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n                    if(cur[1] + entry.getValue() >= min) continue;\\n                    if(entry.getKey()==dst){\\n                        min = Math.min(min,cur[1] + entry.getValue());\\n                        continue;\\n                    } \\n                    if(count[entry.getKey()]++<=n){\\n                        queue.add(new int[]{entry.getKey(),cur[1] + entry.getValue()});    \\n                    }       \\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n```\\n### DFS\\n```\\nint min = Integer.MAX_VALUE;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int f[] : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        visited[src] = true;\\n        dfs(map,visited,0,src,dst,K+1);\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n    private void dfs(Map<Integer,Map<Integer,Integer>> map,boolean[] visited,int val,int cur,int dst,int k){\\n        if(k<0) return;\\n        if(cur==dst){\\n            min = Math.min(min,val);\\n        }\\n        Map<Integer,Integer> next = map.getOrDefault(cur,null);\\n        if(next==null) return;\\n        for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n            if(visited[entry.getKey()]) continue;\\n            if(val+entry.getValue()>=min) continue;\\n            visited[entry.getKey()] = true;\\n            dfs(map,visited,val+entry.getValue(),entry.getKey(),dst,k-1);\\n            visited[entry.getKey()] = false;\\n        }\\n    }\\n```\\n### PriorityQueue\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int[] f : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((x,y)->x[0]-y[0]);\\n        minHeap.add(new int[]{0,src,k+1});\\n        while(!minHeap.isEmpty()){\\n            int[] cur = minHeap.poll();\\n            int price = cur[0], city = cur[1], stop = cur[2];\\n            if(stop < 0) continue;\\n            if(city==dst) return price;\\n            Map<Integer,Integer> next = map.getOrDefault(city,new HashMap<>());\\n            for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n                minHeap.add(new int[]{price+entry.getValue(),entry.getKey(),stop-1});\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n### Dynamic Programming\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[][] dp = new int[k+2][n];\\n        for(int i=0; i<=k+1; i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);    \\n        }\\n        //fly from src to scr cost 0\\n        for(int i=0; i<=k+1; i++){\\n            dp[i][src] = 0;    \\n        }\\n        \\n        for(int i=1; i<=k+1; i++){\\n            for(int[] f: flights){\\n                if(dp[i-1][f[0]]!=Integer.MAX_VALUE){\\n                    dp[i][f[1]] = Math.min(dp[i][f[1]],dp[i-1][f[0]]+f[2]);\\n                }\\n            }\\n        }\\n        return dp[k+1][dst] == Integer.MAX_VALUE ? -1 : dp[k+1][dst];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int[] f : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        k++;\\n        int min = Integer.MAX_VALUE; \\n        int[] count = new int[n];// \\u5224\\u65AD\\u662F\\u5426\\u6709\\u73AF\\n        count[src]++; \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{src,0});\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            if(k--==0) break;\\n            while(size-->0){\\n                int[] cur = queue.poll();\\n                Map<Integer,Integer> next = map.getOrDefault(cur[0],null);\\n                if(next==null) continue;\\n                for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n                    if(cur[1] + entry.getValue() >= min) continue;\\n                    if(entry.getKey()==dst){\\n                        min = Math.min(min,cur[1] + entry.getValue());\\n                        continue;\\n                    } \\n                    if(count[entry.getKey()]++<=n){\\n                        queue.add(new int[]{entry.getKey(),cur[1] + entry.getValue()});    \\n                    }       \\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n```\n```\\nint min = Integer.MAX_VALUE;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int f[] : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        visited[src] = true;\\n        dfs(map,visited,0,src,dst,K+1);\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n    private void dfs(Map<Integer,Map<Integer,Integer>> map,boolean[] visited,int val,int cur,int dst,int k){\\n        if(k<0) return;\\n        if(cur==dst){\\n            min = Math.min(min,val);\\n        }\\n        Map<Integer,Integer> next = map.getOrDefault(cur,null);\\n        if(next==null) return;\\n        for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n            if(visited[entry.getKey()]) continue;\\n            if(val+entry.getValue()>=min) continue;\\n            visited[entry.getKey()] = true;\\n            dfs(map,visited,val+entry.getValue(),entry.getKey(),dst,k-1);\\n            visited[entry.getKey()] = false;\\n        }\\n    }\\n```\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int[] f : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((x,y)->x[0]-y[0]);\\n        minHeap.add(new int[]{0,src,k+1});\\n        while(!minHeap.isEmpty()){\\n            int[] cur = minHeap.poll();\\n            int price = cur[0], city = cur[1], stop = cur[2];\\n            if(stop < 0) continue;\\n            if(city==dst) return price;\\n            Map<Integer,Integer> next = map.getOrDefault(city,new HashMap<>());\\n            for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n                minHeap.add(new int[]{price+entry.getValue(),entry.getKey(),stop-1});\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[][] dp = new int[k+2][n];\\n        for(int i=0; i<=k+1; i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);    \\n        }\\n        //fly from src to scr cost 0\\n        for(int i=0; i<=k+1; i++){\\n            dp[i][src] = 0;    \\n        }\\n        \\n        for(int i=1; i<=k+1; i++){\\n            for(int[] f: flights){\\n                if(dp[i-1][f[0]]!=Integer.MAX_VALUE){\\n                    dp[i][f[1]] = Math.min(dp[i][f[1]],dp[i-1][f[0]]+f[2]);\\n                }\\n            }\\n        }\\n        return dp[k+1][dst] == Integer.MAX_VALUE ? -1 : dp[k+1][dst];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099866,
                "title": "python3-simple-bfs",
                "content": "\\n# Code\\n```\\n\"\"\"\\nRuntime: 106 ms, faster than 88.35%\\nMemory Usage: 15 MB, less than 89.11%\\n\\n\"\"\"\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph, dis = defaultdict(list), [-1 for _ in range(n)]\\n        for f, to, price in flights:\\n            graph[f].append([to, price])\\n\\n        dis[src], q, step = 0, deque([src]), 0\\n\\n        while q and step <= k:\\n            sz = len(q)\\n            new_dis = list(dis)\\n            for _ in range(sz):\\n                cur = q.popleft()\\n                for neighbor in graph[cur]:\\n                    if new_dis[neighbor[0]] == -1 or new_dis[neighbor[0]] > dis[cur]+neighbor[1]:\\n                        new_dis[neighbor[0]] = dis[cur] + neighbor[1]\\n                        q.append(neighbor[0])\\n            step += 1\\n            dis = new_dis\\n\\n        return dis[dst]",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\n# Code\\n```\\n\"\"\"\\nRuntime: 106 ms, faster than 88.35%\\nMemory Usage: 15 MB, less than 89.11%\\n\\n\"\"\"\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph, dis = defaultdict(list), [-1 for _ in range(n)]\\n        for f, to, price in flights:\\n            graph[f].append([to, price])\\n\\n        dis[src], q, step = 0, deque([src]), 0\\n\\n        while q and step <= k:\\n            sz = len(q)\\n            new_dis = list(dis)\\n            for _ in range(sz):\\n                cur = q.popleft()\\n                for neighbor in graph[cur]:\\n                    if new_dis[neighbor[0]] == -1 or new_dis[neighbor[0]] > dis[cur]+neighbor[1]:\\n                        new_dis[neighbor[0]] = dis[cur] + neighbor[1]\\n                        q.append(neighbor[0])\\n            step += 1\\n            dis = new_dis\\n\\n        return dis[dst]",
                "codeTag": "Java"
            },
            {
                "id": 1412918,
                "title": "c-cpp-bfs-dijkstra-algo-level-order",
                "content": "Do like djikstra algorithm just take queue instead of priority queue and do level order traversal\\n\\nOne more level order traversal ques in graph\\nhttps://leetcode.com/problems/minimum-height-trees/\\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n]; \\n        int m = flights.size();\\n        for(int i=0;i<m;i++){\\n            int p = flights[i][0];\\n            int q = flights[i][1];\\n            adj[p].push_back({q,flights[i][2]});\\n        }\\n        queue<pair<int,int>>q; // for level order traversal we use queue\\n        vector<bool> vis(n,0);\\n        q.push({0,src});\\n        vector<int>dist(n,INT_MAX);\\n        dist[src]=0;\\n        k+=1; // add +1 because it is starting from src\\n        while(!q.empty()){\\n            int size=q.size();\\n            k--;\\n            if(k<0) // break statement\\n                break;\\n            for(int i=0;i<size;i++){\\n                auto p = q.front();\\n                int node = p.second;\\n                int wt = p.first;\\n                q.pop();\\n                for(auto x:adj[node]){\\n                    if(x.second+wt<dist[x.first])\\n                    {\\n                        dist[x.first]=x.second+wt;\\n                        q.push({dist[x.first],x.first}); // if we use priority queue then this solution\\n                    }            //may go up in the queue that doesn\\'t gives us level order traversal\\n                }\\n                \\n            }\\n        }\\n        return dist[dst]==INT_MAX?-1:dist[dst];\\n    }\\n```\\n\\nIf you like please do upvote the solution",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n]; \\n        int m = flights.size();\\n        for(int i=0;i<m;i++){\\n            int p = flights[i][0];\\n            int q = flights[i][1];\\n            adj[p].push_back({q,flights[i][2]});\\n        }\\n        queue<pair<int,int>>q; // for level order traversal we use queue\\n        vector<bool> vis(n,0);\\n        q.push({0,src});\\n        vector<int>dist(n,INT_MAX);\\n        dist[src]=0;\\n        k+=1; // add +1 because it is starting from src\\n        while(!q.empty()){\\n            int size=q.size();\\n            k--;\\n            if(k<0) // break statement\\n                break;\\n            for(int i=0;i<size;i++){\\n                auto p = q.front();\\n                int node = p.second;\\n                int wt = p.first;\\n                q.pop();\\n                for(auto x:adj[node]){\\n                    if(x.second+wt<dist[x.first])\\n                    {\\n                        dist[x.first]=x.second+wt;\\n                        q.push({dist[x.first],x.first}); // if we use priority queue then this solution\\n                    }            //may go up in the queue that doesn\\'t gives us level order traversal\\n                }\\n                \\n            }\\n        }\\n        return dist[dst]==INT_MAX?-1:dist[dst];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433024,
                "title": "python-bfs-with-comments-beat-99-65-time-no-fancy-algorithms",
                "content": "Intuition:\\n\\nFor normal BFS traversal, we terminate a searching path if the current node was visited before.\\n\\nFor this problem, we define **seen[pos] = min cost from source to current city**. We terminate a searching path if \\n1) the current city was visited before AND the cost of this path >= seen[pos],\\n2) OR this path contains more than K stops.\\n\\nOtherwise, we keep searching and updating seen[pos].\\n\\n```\\ndef findCheapestPrice(self, n, flights, src, dst, K):\\n        if src == dst: return 0\\n        d, seen = collections.defaultdict(list), collections.defaultdict(lambda: float(\\'inf\\'))\\n        for u, v, p in flights:\\n            d[u] += [(v, p)]\\n    \\n        q = [(src, -1, 0)]\\n        \\n        while q:\\n            pos, k, cost = q.pop(0)\\n            if pos == dst or k == K: continue \\n            for nei, p in d[pos]:\\n                if cost + p >= seen[nei]:\\n                    continue\\n                else:\\n                    seen[nei] = cost+p\\n                    q += [(nei, k+1, cost+p)]\\n                \\n        return seen[dst] if seen[dst] < float(\\'inf\\') else -1\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef findCheapestPrice(self, n, flights, src, dst, K):\\n        if src == dst: return 0\\n        d, seen = collections.defaultdict(list), collections.defaultdict(lambda: float(\\'inf\\'))\\n        for u, v, p in flights:\\n            d[u] += [(v, p)]\\n    \\n        q = [(src, -1, 0)]\\n        \\n        while q:\\n            pos, k, cost = q.pop(0)\\n            if pos == dst or k == K: continue \\n            for nei, p in d[pos]:\\n                if cost + p >= seen[nei]:\\n                    continue\\n                else:\\n                    seen[nei] = cost+p\\n                    q += [(nei, k+1, cost+p)]\\n                \\n        return seen[dst] if seen[dst] < float(\\'inf\\') else -1\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1601771,
                "title": "clean-python-solution-self-explained-dijkstra",
                "content": "```python\\n\"\"\"\\nStandard Dijkstra, except this time instead of only explore the ones with least price\\nWe also need to explore the ones with less steps. So add stepFromSrc to check.\\n\\nTime: O(ELogE), since there will be at most E edges that get pushed into the heap.\\nSpace: O(E)\\n\"\"\"\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        priceFromSrc = {}\\n        stepFromSrc = {}\\n        h = [(0, 0, src)]\\n        G = collections.defaultdict(list)\\n        \\n        #build graph\\n        for s, d, p in flights:\\n            G[s].append((d, p))\\n        \\n        #dijkstra\\n        while h:\\n            price, k, node = heapq.heappop(h)\\n            \\n            if node==dst: return price\\n            if k>K: continue\\n            \\n            for nei, price2 in G[node]:\\n\\t\\t\\t\\t#explore next destination with less price or less steps\\n                if nei not in priceFromSrc or price+price2<=priceFromSrc[nei] or k<stepFromSrc[nei]:\\n                    priceFromSrc[nei] = price+price2\\n                    stepFromSrc[nei] = k\\n                    heapq.heappush(h, (price+price2, k+1, nei))\\n                    \\n        return -1\\n\"\"\"\\nFor more other topics, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\"\"\"\\nStandard Dijkstra, except this time instead of only explore the ones with least price\\nWe also need to explore the ones with less steps. So add stepFromSrc to check.\\n\\nTime: O(ELogE), since there will be at most E edges that get pushed into the heap.\\nSpace: O(E)\\n\"\"\"\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        priceFromSrc = {}\\n        stepFromSrc = {}\\n        h = [(0, 0, src)]\\n        G = collections.defaultdict(list)\\n        \\n        #build graph\\n        for s, d, p in flights:\\n            G[s].append((d, p))\\n        \\n        #dijkstra\\n        while h:\\n            price, k, node = heapq.heappop(h)\\n            \\n            if node==dst: return price\\n            if k>K: continue\\n            \\n            for nei, price2 in G[node]:\\n\\t\\t\\t\\t#explore next destination with less price or less steps\\n                if nei not in priceFromSrc or price+price2<=priceFromSrc[nei] or k<stepFromSrc[nei]:\\n                    priceFromSrc[nei] = price+price2\\n                    stepFromSrc[nei] = k\\n                    heapq.heappush(h, (price+price2, k+1, nei))\\n                    \\n        return -1\\n\"\"\"\\nFor more other topics, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227079,
                "title": "go-golang-python-explanation-with-2-examples-on-dijkstra-s-algorithm-variation",
                "content": "Go(golang)\\n---\\n\\nIn short, it is slow but it helps me to understand the Dijkstra\\'s Algorithm and the Priority Queue implementation. Since I haven\\'t found any discussion threads in Go, I tried to implement it (and submitted it) in Go and hope to help other Go engineers.\\n\\n**Explanation**\\nApparently, It is based on Dijkstra\\'s algorithm. However, since we have an **extra depth constraint**, we are going to **keep the paths** in the queue and **skip using a hashtable** such that we can consider all other possible paths.\\n\\n**The Trickiest Part 1**\\nWhy the first item found to the destination has the least cost???\\n\\nConsider an example,\\n```\\nn=4\\nflights = [[0,1,10],[0,2,20],[1,3,100],[2,3,1]]\\nsrc = 0\\ndst = 3\\nK = 1\\n```\\n**You may worry that the result will be 110**, but actually it doesn\\'t, let\\'s see the reason.\\n\\nLet\\'s go through the iterations of `for pq.Len() > 0`, (in readme for readabilty \\uD83E\\uDD13)\\n```\\nafter 1st iteration: pq will have [10, 20], 10 is 0->1, 20 is 0->2\\nafter 2nd iteration: pq will have [20, 110], 20 is 0->2, 110 is 0->1->3(arrived destination but it is not prioritized due to its high cost)\\nafter 3rd iteration: pq will have [21, 110], 21 is 0->2->3, 110 is 0->1->3\\nafter 4th iteration: since 21 has arrived the destination, we return it as a result\\n```\\n\\n**The Trickiest Part 2**\\n**Why dont we use a hastable** to avoid visiting a node again, like the original Dijkstra\\'s Algorithm?\\n\\nLet\\'s consider a test case\\n```\\nn=4\\nflights = [[0, 1, 1], [0, 2, 5], [1, 2, 1], [2, 3, 1]]\\nsrc = 0\\ndst = 3\\nK = 1\\n```\\nAccording to the original Dijkstra\\'s Algorithm, if we use a hashtable to fix the point as a route member and never visit again, **we will end up missing other paths which have less steps to the destination**.\\n\\nLet\\'s go through the iterations,\\n```\\nafter 1st iteration: pq will have [1, 5], 1 is 0->1, 5 is 0->2\\nafter 2nd iteration: pq will have [2, 5], 2 is 0->1->2, 5 is 0->2 (u see, here we have 2 paths to point2. if we set the 2(0->1->2) in the hashtable and never visit 2 again, we will miss the 5(0->2) which later reaches to the destination)\\nafter 3rd iteration: pq will have [5], 5 is 0->2, we popped 2 and do nothing because its steps-1 == K\\nafter 4th iteration: pq will have [6], 6 is 0->2->3, since 6 has arrived the destination, we return it as a result\\n```\\n\\n**Main function**\\n```go\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n\\n\\t// put flights into a hashtable for lookup\\n\\tflightsMap := make(map[int][][]int)\\n\\tfor _, flight := range flights {\\n\\t\\tfrom := flight[0]\\n\\t\\tif _, x := flightsMap[from]; x {\\n\\t\\t\\tflightsMap[from] = append(flightsMap[from], flight)\\n\\t\\t} else {\\n\\t\\t\\tflightsMap[from] = [][]int{flight}\\n\\t\\t}\\n\\t}\\n\\t// dijkstra\\'s\\n\\tpq := &PriorityQueue{}\\n\\theap.Init(pq)\\n\\theap.Push(pq, &Item{0, src, 0, 0})\\n\\tfor pq.Len() > 0 {\\n\\t\\titem := heap.Pop(pq).(*Item)\\n\\n\\t\\t// this is the trickiest part 1: why first item found is the result?\\n\\t\\tif item.Location == dst {\\n\\t\\t\\treturn item.Cost\\n\\t\\t}\\n\\t\\t\\n\\t\\t// the trickiest part 2: why dont we use a hastable to avoid visiting again?\\n\\n\\t\\tif item.Steps-1 == K {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif _, x := flightsMap[item.Location]; x {\\n\\t\\t\\tcandidates := flightsMap[item.Location]\\n\\t\\t\\tfor _, can := range candidates {\\n\\t\\t\\t\\ti := pq.Len()\\n\\t\\t\\t\\theap.Push(pq, &Item{item.Cost + can[2], can[1], item.Steps + 1, i})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```\\n\\n**Priority Queue**\\nReference: https://golang.org/pkg/container/heap/#example__priorityQueue\\n```\\ntype Item struct {\\n\\tCost     int // The priority of the item in the queue.\\n\\tLocation int // The value of the item; arbitrary.\\n\\tSteps    int // The value of the item; arbitrary.\\n\\t// The index is needed by update and is maintained by the heap.Interface methods.\\n\\tIndex int // The index of the item in the heap.\\n}\\n\\n// A PriorityQueue implements heap.Interface and holds Items.\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\t// We want Pop to give us the highest, not lowest, priority so we use greater than here.\\n\\treturn pq[i].Cost < pq[j].Cost\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].Index = i\\n\\tpq[j].Index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.Index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\titem.Index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n// update modifies the priority and value of an Item in the queue.\\nfunc (pq *PriorityQueue) update(item *Item, cost int, location int, steps int) {\\n\\titem.Cost = cost\\n\\titem.Location = location\\n\\titem.Steps = steps\\n\\theap.Fix(pq, item.Index)\\n}\\n```\\n\\nPython\\n---\\nGive my explanation above. In python, **I want to show you the nuance** how the original Dijkstra\\'s Algorithm can be modified for this question. **I deliberately leave the commented-out lines** which we usually do in the traditional Dijkstra\\'s Algorithm.\\n\\n```\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        \"\"\"\\n        Depth-limied Dijkstra\\'s Algorithm\\n        56ms beats 33.33%\\n        27jan2019\\n        \"\"\"\\n        flightsMap = {}\\n        for flight in flights:\\n            key = flight[0]\\n            if key in flightsMap:\\n                flightsMap[key].append(flight)\\n            else:\\n                flightsMap[key] = [flight]\\n\\n        # dijkstra\\'s\\n        heap = [(0, (src, 0))]\\n        # seen = {}\\n        while len(heap) > 0:\\n            cost, node = heapq.heappop(heap)\\n            location = node[0]\\n            steps = node[1]\\n\\n            # if location in seen and cost <= seen[location]:\\n            #     continue\\n            # seen[location] = cost\\n\\n            if location == dst:\\n                return cost\\n\\n            if steps-1 == K:\\n                continue\\n\\n            if location in flightsMap:\\n                candidates = flightsMap[location]\\n                for can in candidates:\\n                    # if can[1] not in seen:\\n                    temp = (can[1], steps+1)\\n                    heapq.heappush(heap, (cost+can[2], temp))\\n\\n        # if dst in seen:\\n        #     return seen[dst]\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nn=4\\nflights = [[0,1,10],[0,2,20],[1,3,100],[2,3,1]]\\nsrc = 0\\ndst = 3\\nK = 1\\n```\n```\\nafter 1st iteration: pq will have [10, 20], 10 is 0->1, 20 is 0->2\\nafter 2nd iteration: pq will have [20, 110], 20 is 0->2, 110 is 0->1->3(arrived destination but it is not prioritized due to its high cost)\\nafter 3rd iteration: pq will have [21, 110], 21 is 0->2->3, 110 is 0->1->3\\nafter 4th iteration: since 21 has arrived the destination, we return it as a result\\n```\n```\\nn=4\\nflights = [[0, 1, 1], [0, 2, 5], [1, 2, 1], [2, 3, 1]]\\nsrc = 0\\ndst = 3\\nK = 1\\n```\n```\\nafter 1st iteration: pq will have [1, 5], 1 is 0->1, 5 is 0->2\\nafter 2nd iteration: pq will have [2, 5], 2 is 0->1->2, 5 is 0->2 (u see, here we have 2 paths to point2. if we set the 2(0->1->2) in the hashtable and never visit 2 again, we will miss the 5(0->2) which later reaches to the destination)\\nafter 3rd iteration: pq will have [5], 5 is 0->2, we popped 2 and do nothing because its steps-1 == K\\nafter 4th iteration: pq will have [6], 6 is 0->2->3, since 6 has arrived the destination, we return it as a result\\n```\n```go\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n\\n\\t// put flights into a hashtable for lookup\\n\\tflightsMap := make(map[int][][]int)\\n\\tfor _, flight := range flights {\\n\\t\\tfrom := flight[0]\\n\\t\\tif _, x := flightsMap[from]; x {\\n\\t\\t\\tflightsMap[from] = append(flightsMap[from], flight)\\n\\t\\t} else {\\n\\t\\t\\tflightsMap[from] = [][]int{flight}\\n\\t\\t}\\n\\t}\\n\\t// dijkstra\\'s\\n\\tpq := &PriorityQueue{}\\n\\theap.Init(pq)\\n\\theap.Push(pq, &Item{0, src, 0, 0})\\n\\tfor pq.Len() > 0 {\\n\\t\\titem := heap.Pop(pq).(*Item)\\n\\n\\t\\t// this is the trickiest part 1: why first item found is the result?\\n\\t\\tif item.Location == dst {\\n\\t\\t\\treturn item.Cost\\n\\t\\t}\\n\\t\\t\\n\\t\\t// the trickiest part 2: why dont we use a hastable to avoid visiting again?\\n\\n\\t\\tif item.Steps-1 == K {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif _, x := flightsMap[item.Location]; x {\\n\\t\\t\\tcandidates := flightsMap[item.Location]\\n\\t\\t\\tfor _, can := range candidates {\\n\\t\\t\\t\\ti := pq.Len()\\n\\t\\t\\t\\theap.Push(pq, &Item{item.Cost + can[2], can[1], item.Steps + 1, i})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```\n```\\ntype Item struct {\\n\\tCost     int // The priority of the item in the queue.\\n\\tLocation int // The value of the item; arbitrary.\\n\\tSteps    int // The value of the item; arbitrary.\\n\\t// The index is needed by update and is maintained by the heap.Interface methods.\\n\\tIndex int // The index of the item in the heap.\\n}\\n\\n// A PriorityQueue implements heap.Interface and holds Items.\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\t// We want Pop to give us the highest, not lowest, priority so we use greater than here.\\n\\treturn pq[i].Cost < pq[j].Cost\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].Index = i\\n\\tpq[j].Index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.Index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\titem.Index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n// update modifies the priority and value of an Item in the queue.\\nfunc (pq *PriorityQueue) update(item *Item, cost int, location int, steps int) {\\n\\titem.Cost = cost\\n\\titem.Location = location\\n\\titem.Steps = steps\\n\\theap.Fix(pq, item.Index)\\n}\\n```\n```\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        \"\"\"\\n        Depth-limied Dijkstra\\'s Algorithm\\n        56ms beats 33.33%\\n        27jan2019\\n        \"\"\"\\n        flightsMap = {}\\n        for flight in flights:\\n            key = flight[0]\\n            if key in flightsMap:\\n                flightsMap[key].append(flight)\\n            else:\\n                flightsMap[key] = [flight]\\n\\n        # dijkstra\\'s\\n        heap = [(0, (src, 0))]\\n        # seen = {}\\n        while len(heap) > 0:\\n            cost, node = heapq.heappop(heap)\\n            location = node[0]\\n            steps = node[1]\\n\\n            # if location in seen and cost <= seen[location]:\\n            #     continue\\n            # seen[location] = cost\\n\\n            if location == dst:\\n                return cost\\n\\n            if steps-1 == K:\\n                continue\\n\\n            if location in flightsMap:\\n                candidates = flightsMap[location]\\n                for can in candidates:\\n                    # if can[1] not in seen:\\n                    temp = (can[1], steps+1)\\n                    heapq.heappush(heap, (cost+can[2], temp))\\n\\n        # if dst in seen:\\n        #     return seen[dst]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100952,
                "title": "c-bfs-bellman-ford-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan use BFS,Dijksta\\'s Algo,Bellman Ford Algo only thing is check  for stops not exceeding k rest is same as before.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- BFS\\n- Bellman Ford Algo\\n# Complexity\\n- Time complexity:$$O(N*K)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**BFS**\\n```\\nclass Solution {\\npublic:\\n   \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int S, int dst, int k) {\\n        // shortest path algo with a little variation\\n         vector<vector<pair<int, int>>> adj(n);\\n        for (auto& e : flights) {\\n            adj[e[0]].push_back({e[1], e[2]});\\n        }\\n         vector<int>dis(n,INT_MAX);\\n        dis[S]=0;\\n        queue<pair<int,int>>pq;\\n        pq.push({0,S});\\n        int stops=0;\\n        while(stops<=k and !pq.empty()){\\n            int sz=pq.size();\\n            while(sz--){ \\n            auto [dist,node]=pq.front();\\n            pq.pop();\\n            for(auto& [nb,cost]:adj[node]){\\n                int temp=cost+dist;\\n                if(dis[nb]>temp){\\n                    dis[nb]=temp;\\n                    pq.push({temp,nb});\\n                }\\n            }\\n            }\\n            stops++;\\n        }\\n      \\n        return dis[dst]==INT_MAX?-1:dis[dst];\\n    \\n    }\\n};\\n```\\n**BELL MAN FORD ALGO**\\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int S, int dst, int k) {\\n        // shortest path algo with a little variation\\n      \\n         vector<int>dis(n,INT_MAX);\\n        dis[S]=0;\\n        for(int i=0;i<=k;i++){\\n            vector<int>temp(dis);\\n            for(auto x:flights){\\n               if(dis[x[0]]!=INT_MAX){\\n                   temp[x[1]]=min(temp[x[1]],dis[x[0]]+x[2]);\\n               }\\n            }\\n            dis=temp;\\n        }\\n      return dis[dst] == INT_MAX ? -1 : dis[dst];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int S, int dst, int k) {\\n        // shortest path algo with a little variation\\n         vector<vector<pair<int, int>>> adj(n);\\n        for (auto& e : flights) {\\n            adj[e[0]].push_back({e[1], e[2]});\\n        }\\n         vector<int>dis(n,INT_MAX);\\n        dis[S]=0;\\n        queue<pair<int,int>>pq;\\n        pq.push({0,S});\\n        int stops=0;\\n        while(stops<=k and !pq.empty()){\\n            int sz=pq.size();\\n            while(sz--){ \\n            auto [dist,node]=pq.front();\\n            pq.pop();\\n            for(auto& [nb,cost]:adj[node]){\\n                int temp=cost+dist;\\n                if(dis[nb]>temp){\\n                    dis[nb]=temp;\\n                    pq.push({temp,nb});\\n                }\\n            }\\n            }\\n            stops++;\\n        }\\n      \\n        return dis[dst]==INT_MAX?-1:dis[dst];\\n    \\n    }\\n};\\n```\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int S, int dst, int k) {\\n        // shortest path algo with a little variation\\n      \\n         vector<int>dis(n,INT_MAX);\\n        dis[S]=0;\\n        for(int i=0;i<=k;i++){\\n            vector<int>temp(dis);\\n            for(auto x:flights){\\n               if(dis[x[0]]!=INT_MAX){\\n                   temp[x[1]]=min(temp[x[1]],dis[x[0]]+x[2]);\\n               }\\n            }\\n            dis=temp;\\n        }\\n      return dis[dst] == INT_MAX ? -1 : dis[dst];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099936,
                "title": "easy-solution-fully-explained-c-dijkstra-algorithm-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                  Please Upvote If You Find It Helpful.\\n```\\n# Approach: Using Dijkstra\\'s Algorithm\\n<!-- Describe your approach to solving the problem. -->\\nTime Complexity : O(E)\\nSpace Complexity : O(E)\\n\\n# Code\\n```\\n#define pi pair<int, pair<int,int>>\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Create an adjacency list to represent the flights\\n        vector<pair<int, int>> adj[n];\\n        for(auto it : flights){\\n            // for each flight, add an edge from the source city to the destination city with the price of the flight\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        // Create a queue to store the current node, the number of stops, and the price\\n        queue<pi> q;\\n        // Create an array to store the minimum price to reach each city\\n        vector<int> dist(n, 1e9);\\n        // Add the source city with 0 stops and 0 cost {stops,{node, price}}\\n        q.push({0, {src, 0}});\\n        dist[src] = 0;\\n        // Loop through the queue until it is empty\\n        while(!q.empty()){\\n            int stop = q.front().first;\\n            int node = q.front().second.first, price = q.front().second.second;\\n            q.pop();\\n            // If the number of stops is greater than the allowed stops, continue\\n            if(stop > k) continue;\\n            // For each adjacent city, update the minimum price if a cheaper path is found\\n            for(auto it:adj[node]){\\n                int adjN = it.first;\\n                int Nprice = it.second;\\n                if(dist[adjN] > price + Nprice && stop<=k){\\n                    dist[adjN] = price + Nprice;\\n                    q.push({stop+1, {adjN, dist[adjN]}});\\n                }\\n            }\\n        }\\n        // If the minimum price to reach the destination is still the maximum value, return -1\\n        if(dist[dst]==1e9) return -1;\\n        // Otherwise, return the minimum price\\n        return dist[dst];\\n    }\\n};\\n```\\n```\\n                            Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On[ Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n                  Please Upvote If You Find It Helpful.\\n```\n```\\n#define pi pair<int, pair<int,int>>\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Create an adjacency list to represent the flights\\n        vector<pair<int, int>> adj[n];\\n        for(auto it : flights){\\n            // for each flight, add an edge from the source city to the destination city with the price of the flight\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        // Create a queue to store the current node, the number of stops, and the price\\n        queue<pi> q;\\n        // Create an array to store the minimum price to reach each city\\n        vector<int> dist(n, 1e9);\\n        // Add the source city with 0 stops and 0 cost {stops,{node, price}}\\n        q.push({0, {src, 0}});\\n        dist[src] = 0;\\n        // Loop through the queue until it is empty\\n        while(!q.empty()){\\n            int stop = q.front().first;\\n            int node = q.front().second.first, price = q.front().second.second;\\n            q.pop();\\n            // If the number of stops is greater than the allowed stops, continue\\n            if(stop > k) continue;\\n            // For each adjacent city, update the minimum price if a cheaper path is found\\n            for(auto it:adj[node]){\\n                int adjN = it.first;\\n                int Nprice = it.second;\\n                if(dist[adjN] > price + Nprice && stop<=k){\\n                    dist[adjN] = price + Nprice;\\n                    q.push({stop+1, {adjN, dist[adjN]}});\\n                }\\n            }\\n        }\\n        // If the minimum price to reach the destination is still the maximum value, return -1\\n        if(dist[dst]==1e9) return -1;\\n        // Otherwise, return the minimum price\\n        return dist[dst];\\n    }\\n};\\n```\n```\\n                            Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693599,
                "title": "detailed-c-standard-approaches-bfs-approach",
                "content": "It could be solved using **Dijkstra algorithm**, But it could have been easily solved using a simple modified **BFS**!!\\n\\nSpace Complexity: **```O(e * k) + O(n)```**\\nTime Complexity: **```O(e * k)```**\\n(Queue will store at max **(e * k)** nodes for the same reason and push or pop requires **O(1)** time.)\\n\\n**C++ code (BFS) :**\\n```\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // initialize the adjacency list, distance and queue\\n        vector<pair<int, int>> adj[n];\\n        vector<int> dis(n, 1e9);\\n        queue<vector<int>> q;\\n        \\n        // make the adjacency list\\n        for(auto it: flights){\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        \\n        // push the src node to the queue\\n        q.push({0, src, 0});\\n        // mark the distance as 0 (i.e it is the first element)\\n        dis[src] = 0;\\n        \\n        // until queue is empty do the operation\\n        while(!q.empty()){\\n            // take the first element of the queue\\n            int stop = q.front()[0];\\n            int node = q.front()[1];\\n            int cost = q.front()[2];\\n            // remove the first element\\n            q.pop();\\n            \\n            // if we reach destination with k+1 move then stop \\n            // iteration as we reached destination with atmost \\n            // k stops \\n            if(stop > k) continue;\\n            \\n            // check all its adjacent edges\\n            for(auto it: adj[node]){\\n                int adjNode = it.first;\\n                int weight = it.second;\\n                \\n                if(cost + weight < dis[adjNode]) {\\n                    dis[adjNode] = cost + weight;  // update the distance \\n                    q.push({stop+1, adjNode, cost + weight});  // push the adj element and new distance into queue\\n                }\\n            }\\n        }\\n        \\n        // if the distance of the dst is not changed the return -1\\n        // as it is not possible to reach destination\\n        return dis[dst] == 1e9 ? -1 : dis[dst];\\n    }\\n};\\n\\n```\\n\\nPLease upvote if you find this helpful. **:)**\\nFeel free to comment in case of any doubt.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```O(e * k) + O(n)```\n```O(e * k)```\n```\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // initialize the adjacency list, distance and queue\\n        vector<pair<int, int>> adj[n];\\n        vector<int> dis(n, 1e9);\\n        queue<vector<int>> q;\\n        \\n        // make the adjacency list\\n        for(auto it: flights){\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        \\n        // push the src node to the queue\\n        q.push({0, src, 0});\\n        // mark the distance as 0 (i.e it is the first element)\\n        dis[src] = 0;\\n        \\n        // until queue is empty do the operation\\n        while(!q.empty()){\\n            // take the first element of the queue\\n            int stop = q.front()[0];\\n            int node = q.front()[1];\\n            int cost = q.front()[2];\\n            // remove the first element\\n            q.pop();\\n            \\n            // if we reach destination with k+1 move then stop \\n            // iteration as we reached destination with atmost \\n            // k stops \\n            if(stop > k) continue;\\n            \\n            // check all its adjacent edges\\n            for(auto it: adj[node]){\\n                int adjNode = it.first;\\n                int weight = it.second;\\n                \\n                if(cost + weight < dis[adjNode]) {\\n                    dis[adjNode] = cost + weight;  // update the distance \\n                    q.push({stop+1, adjNode, cost + weight});  // push the adj element and new distance into queue\\n                }\\n            }\\n        }\\n        \\n        // if the distance of the dst is not changed the return -1\\n        // as it is not possible to reach destination\\n        return dis[dst] == 1e9 ? -1 : dis[dst];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218027,
                "title": "c-dijkstra-variation-bellman-ford",
                "content": "**1. Dijkstra Variation:**\\n**Note**: This problem can\\'t be solved through Dijkstra without modification. Dijkstra will only revisit path with miniumum weight, but that\\'s not sufficient, we also need to revisit node having higher weight but lesser stops.\\n\\n```\\nFor E.g:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\n0\\n2\\n2\\n\\nDijkstra will assign node 1 weight 4: 0 -> 3 -> 1. Then it will travel node to node 2: 0 -> 3 -> 1 -> 2 giving weight 9.\\nAs soon as we change weight of 1 from 5 to 4 and add a stop through normal Dijkstra, we can\\'t reach correct solution,\\nwhich is to reach node 2 through 0 -> 1 -> 4 -> 2 with weight 7.\\n```\\n**Sum Up**: We need to modify Dijkstra, to consider 2nd path 0->1 even if node 1 has weight 5, but has only 1 stop unlike 1st path where node 1 takes 2 stops.\\n\\nBelow is the code applying same thing, a dry run on above example will improve understanding of this method.\\n**T.C** - O(v + elogv)\\n```\\n#define tii tuple<int, int, int>\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pii> adjList[n];\\n        for(auto& flight: flights){\\n            int source = flight[0], dest = flight[1], price = flight[2];\\n            adjList[source].push_back({dest, price});\\n        }\\n        return dijkstraVariation(adjList, n, src, dst, k);\\n    }\\n    \\n    int dijkstraVariation(vector<pii> adjList[], int n, int node, int dst, int k){\\n        priority_queue<tii, vector<tii>, greater<tii>> minHeap;\\n        vector<int> stops(n, INT_MAX), distance(n, INT_MAX);\\n        \\n        int minDist = INT_MAX;\\n        stops[node] = 0;\\n        distance[node] = 0;\\n        minHeap.push({0,node,0});\\n        \\n        while(!minHeap.empty()){\\n            auto [curDist, curNode, curStops] = minHeap.top();\\n            \\n            minHeap.pop();\\n            if(curNode == dst) return curDist;\\n            if(curStops == k+1) continue;\\n            \\n            auto neighbors = adjList[curNode];\\n            for(auto& neighborPair :neighbors){\\n                int neighbor = neighborPair.first, edgeWt = neighborPair.second;\\n                int nextDistance = curDist + edgeWt, nextStops = curStops+1;\\n                \\n                //This if check is same as normal Dijkstraz: Don\\'t forget to update both distance and stops.\\n                if(distance[neighbor] > nextDistance ){\\n                    distance[neighbor] = nextDistance;\\n                    stops[neighbor] = nextStops;\\n                    minHeap.push({nextDistance, neighbor, nextStops});\\n                }\\n                \\n                //This is main variation from Dijkstra: Don\\'t forget to update both distance and stops.\\n                else if(nextStops < stops[neighbor]){\\n                    distance[neighbor] = nextDistance;\\n                    stops[neighbor] = nextStops;\\n                    minHeap.push({nextDistance, neighbor, nextStops});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**2. Bellman Ford**\\nThis problem can be solved using Bellman Ford algorithm by performing k+1 relaxations, that\\'s it, if after k+1 relaxations price is not INT_MAX, then return price otherwise return -1.\\n\\n**Why we need tempPrice?**\\nLet\\'s take an example.\\n```\\n3\\n[[0,1,100],[1,2,100],[1,2,500]]\\n0\\n2\\n0\\n```\\n\\nYou can take 0 stops in going from 0 to 2, suppose you didn\\'t take temp array, and are making changes directly in price array.\\nYou will make k+1 -> 0+1 = 1 relaxation only.\\n\\n**Let\\'s start: (Not taking temp array)**\\n0 -> 1, original price = price[1] = Infinity, new price = 0+100 -> price[1] = 100.\\n1 -> 2, original price = price[2] = Infinity, new price = 100+100 -> price[2] = 200.\\n0 -> 2, original price = price[2] = 200 (calculated just above) < 500 -> No update.\\n\\nYou see, just because, changes were made directly to price array, we didn\\'t know that we took a stop at 1, and then moved to 2 from 1, that contradicted the condition that we can\\'t take any stops in between.\\n\\nIf you took temp array:\\n**Let\\'s start: (Taking temp array)**\\n0 -> 1, original price = price[1] = Infinity, new price = 0+100 -> tempPrice[1] = 100. //tempPrice is updated, not price.\\n1 -> 2, original price = price[2] = Infinity, new price = price[1] (Infinity) + 100 -> tempPrice[2] = Infinity.\\n0 -> 2, original price = price[2] = Infinity,new price = price[0] + 500 -> which is smaller than infinity -> Update tempPrice[2] = 500.\\n\\nHence price[2] = 500 taking 0 stops in between.\\n\\n**T.C** - \\nBellman Ford: O(ExV)\\nBut, since we have to relax k+1 times: O(ExK)\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        return bellmanFordVariation(flights, n, src, dst, k);\\n    }\\n    \\n    int bellmanFordVariation(vector<vector<int>>& flights, int n, int src, int dst, int k){\\n        vector<int> price(n, 10000000), tempPrice(n, 10000000);\\n        price[src] = tempPrice[src] = 0;\\n        \\n        //Relax k+1 times\\n        for(int i=1; i<=k+1; i++){\\n            for(auto& edge: flights){\\n                int source = edge[0], destination = edge[1], edgeCost = edge[2];\\n                int newCost = price[source] + edgeCost;\\n                \\n                if(newCost < tempPrice[destination]) tempPrice[destination] = newCost;\\n            }\\n\\n\\t\\t\\t//Copy tempPrice to price\\n            for(int i=0; i<n; i++) price[i] = tempPrice[i];\\n        }\\n        return price[dst] == 10000000 ? -1 : price[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nFor E.g:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\n0\\n2\\n2\\n\\nDijkstra will assign node 1 weight 4: 0 -> 3 -> 1. Then it will travel node to node 2: 0 -> 3 -> 1 -> 2 giving weight 9.\\nAs soon as we change weight of 1 from 5 to 4 and add a stop through normal Dijkstra, we can\\'t reach correct solution,\\nwhich is to reach node 2 through 0 -> 1 -> 4 -> 2 with weight 7.\\n```\n```\\n#define tii tuple<int, int, int>\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pii> adjList[n];\\n        for(auto& flight: flights){\\n            int source = flight[0], dest = flight[1], price = flight[2];\\n            adjList[source].push_back({dest, price});\\n        }\\n        return dijkstraVariation(adjList, n, src, dst, k);\\n    }\\n    \\n    int dijkstraVariation(vector<pii> adjList[], int n, int node, int dst, int k){\\n        priority_queue<tii, vector<tii>, greater<tii>> minHeap;\\n        vector<int> stops(n, INT_MAX), distance(n, INT_MAX);\\n        \\n        int minDist = INT_MAX;\\n        stops[node] = 0;\\n        distance[node] = 0;\\n        minHeap.push({0,node,0});\\n        \\n        while(!minHeap.empty()){\\n            auto [curDist, curNode, curStops] = minHeap.top();\\n            \\n            minHeap.pop();\\n            if(curNode == dst) return curDist;\\n            if(curStops == k+1) continue;\\n            \\n            auto neighbors = adjList[curNode];\\n            for(auto& neighborPair :neighbors){\\n                int neighbor = neighborPair.first, edgeWt = neighborPair.second;\\n                int nextDistance = curDist + edgeWt, nextStops = curStops+1;\\n                \\n                //This if check is same as normal Dijkstraz: Don\\'t forget to update both distance and stops.\\n                if(distance[neighbor] > nextDistance ){\\n                    distance[neighbor] = nextDistance;\\n                    stops[neighbor] = nextStops;\\n                    minHeap.push({nextDistance, neighbor, nextStops});\\n                }\\n                \\n                //This is main variation from Dijkstra: Don\\'t forget to update both distance and stops.\\n                else if(nextStops < stops[neighbor]){\\n                    distance[neighbor] = nextDistance;\\n                    stops[neighbor] = nextStops;\\n                    minHeap.push({nextDistance, neighbor, nextStops});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n3\\n[[0,1,100],[1,2,100],[1,2,500]]\\n0\\n2\\n0\\n```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        return bellmanFordVariation(flights, n, src, dst, k);\\n    }\\n    \\n    int bellmanFordVariation(vector<vector<int>>& flights, int n, int src, int dst, int k){\\n        vector<int> price(n, 10000000), tempPrice(n, 10000000);\\n        price[src] = tempPrice[src] = 0;\\n        \\n        //Relax k+1 times\\n        for(int i=1; i<=k+1; i++){\\n            for(auto& edge: flights){\\n                int source = edge[0], destination = edge[1], edgeCost = edge[2];\\n                int newCost = price[source] + edgeCost;\\n                \\n                if(newCost < tempPrice[destination]) tempPrice[destination] = newCost;\\n            }\\n\\n\\t\\t\\t//Copy tempPrice to price\\n            for(int i=0; i<n; i++) price[i] = tempPrice[i];\\n        }\\n        return price[dst] == 10000000 ? -1 : price[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684443,
                "title": "javascript-10-lines-of-sweet-bellman-ford",
                "content": "```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    let M = Array(n).fill().map((_, i) => i===src ? 0 : Infinity);\\n    for(let k=0; k<K+1; k++) {\\n        let N = [...M];\\n        for(let [from, to, price] of flights) {\\n            N[to] = Math.min(N[to], M[from] + price);\\n        }\\n        M = [...N];\\n    }\\n    return M[dst] != Infinity ? M[dst] : -1\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    let M = Array(n).fill().map((_, i) => i===src ? 0 : Infinity);\\n    for(let k=0; k<K+1; k++) {\\n        let N = [...M];\\n        for(let [from, to, price] of flights) {\\n            N[to] = Math.min(N[to], M[from] + price);\\n        }\\n        M = [...N];\\n    }\\n    return M[dst] != Infinity ? M[dst] : -1\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 405376,
                "title": "swift-bfs-easy-to-understand",
                "content": "We will be using BFS to solve this question.\\n\\n1. Create a graph where the key is the departure city and the value is the arrival city and the flight cost.\\n2. Create a queue that contains an object which keeps track of the current city, number of stops and the total running cost.\\n3. Populate the queue with the first city and the number of stops (0) with the total running cost (0). \\n4. For each element in the queue we will travel to each neighboring city and keep track of the number of stops and running costs.\\n5. Stop exploring if the current city is the destination city or the total running cost is greater than the minimum cost or the number of stops is greater than K.\\n\\n```\\ntypealias element = (city: Int, stops: Int, runningCost: Int)\\n\\nfunc findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ K: Int) -> Int {\\n\\tvar graph = [Int:[(Int, Int)]]()\\n\\n\\tfor flight in flights {\\n\\t\\tgraph[flight[0], default: []].append((flight[1], flight[2]))\\n\\t}\\n\\n\\tvar queue = [element]()\\n\\tqueue.append((city: src, stops: 0, runningCost: 0))\\n\\n\\tvar minCost = Int.max\\n\\n\\twhile !queue.isEmpty {\\n\\t\\tlet (city, stops, runningCost) = queue.removeFirst()\\n\\n\\t\\tif city == dst {\\n\\t\\t\\tminCost = min(minCost, runningCost)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif stops > K || runningCost > minCost {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor (nextCity, flightCost) in graph[city] ?? [] {\\n\\t\\t\\tqueue.append((nextCity, stops + 1, runningCost + flightCost))\\n\\t\\t}\\n\\t}\\n\\n\\treturn minCost != Int.max ? minCost : -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypealias element = (city: Int, stops: Int, runningCost: Int)\\n\\nfunc findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ K: Int) -> Int {\\n\\tvar graph = [Int:[(Int, Int)]]()\\n\\n\\tfor flight in flights {\\n\\t\\tgraph[flight[0], default: []].append((flight[1], flight[2]))\\n\\t}\\n\\n\\tvar queue = [element]()\\n\\tqueue.append((city: src, stops: 0, runningCost: 0))\\n\\n\\tvar minCost = Int.max\\n\\n\\twhile !queue.isEmpty {\\n\\t\\tlet (city, stops, runningCost) = queue.removeFirst()\\n\\n\\t\\tif city == dst {\\n\\t\\t\\tminCost = min(minCost, runningCost)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif stops > K || runningCost > minCost {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor (nextCity, flightCost) in graph[city] ?? [] {\\n\\t\\t\\tqueue.append((nextCity, stops + 1, runningCost + flightCost))\\n\\t\\t}\\n\\t}\\n\\n\\treturn minCost != Int.max ? minCost : -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137426,
                "title": "one-line-modification-in-dijstara-algorithm-c",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    vector<vector<pair<int,int>>> graph;\\n    vector<int> dis;\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        graph.resize(n);\\n        dis.resize(n,INT_MAX);\\n        \\n        for(int i = 0 ; i<flights.size() ; i++){\\n            \\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            \\n            graph[u].push_back({v,w});\\n        }\\n        \\n        queue<tuple<int,int,int>> pq;\\n        pq.push({0, src , 0});      //  dis , source , no of stops\\n         \\n        dis[src] = 0;\\n        \\n        while(!pq.empty()){\\n            \\n            auto [d,u,st] = pq.front();\\n            pq.pop();\\n            \\n            \\n            for(auto [v , w] : graph[u]){\\n                \\n                if(d + w < dis[v]  && st<=k){\\n            \\n                    dis[v] = d + w;\\n                    \\n                    pq.push({dis[v], v, st+1});\\n                }\\n                \\n            }\\n        }\\n        \\n        if(dis[dst]==INT_MAX)return -1;\\n        \\n        return dis[dst];\\n        \\n    }\\n    \\n   \\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    vector<vector<pair<int,int>>> graph;\\n    vector<int> dis;\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        graph.resize(n);\\n        dis.resize(n,INT_MAX);\\n        \\n        for(int i = 0 ; i<flights.size() ; i++){\\n            \\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            \\n            graph[u].push_back({v,w});\\n        }\\n        \\n        queue<tuple<int,int,int>> pq;\\n        pq.push({0, src , 0});      //  dis , source , no of stops\\n         \\n        dis[src] = 0;\\n        \\n        while(!pq.empty()){\\n            \\n            auto [d,u,st] = pq.front();\\n            pq.pop();\\n            \\n            \\n            for(auto [v , w] : graph[u]){\\n                \\n                if(d + w < dis[v]  && st<=k){\\n            \\n                    dis[v] = d + w;\\n                    \\n                    pq.push({dis[v], v, st+1});\\n                }\\n                \\n            }\\n        }\\n        \\n        if(dis[dst]==INT_MAX)return -1;\\n        \\n        return dis[dst];\\n        \\n    }\\n    \\n   \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352199,
                "title": "c-easy-solution-explanation-bellman-ford",
                "content": "It is standard Bellman Ford  with just 2 small modifications :\\n1) We won\\'t allow relaxation beyond K to make sure cheapestPrice doesn\\'t have more than K stops\\n2) In each round of relaxation, changes will be done in temporary distance(price) array to ensure current path-length doesn\\'t go beyond current iteration number. \\n\\n( For clear understanding for temp: you may take example of a linear graph with source and destination at two ends and see how normal Bellman Ford behaves if edges are arranged from source to destination vs when using temporary distance array for modifications )\\n\\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int end, int k) {\\n        vector<int> dst(n,1e7);\\n        vector<int> temp(n,1e7);\\n        dst[src]=0;\\n        temp[src]=0;\\n        for(int i=0;i<=k;++i)\\n        {\\n            for(vector<int> j:flights)\\n            {\\n                if(temp[j[1]] > dst[j[0]]+j[2])\\n                    temp[j[1]] = dst[j[0]]+j[2];\\n            }\\n            for(int j=0;j<n;++j)\\n                dst[j] = temp[j];\\n        }\\n        if(dst[end]==1e7)\\n            return -1;\\n        else\\n            return dst[end];\\n    }",
                "solutionTags": [],
                "code": "It is standard Bellman Ford  with just 2 small modifications :\\n1) We won\\'t allow relaxation beyond K to make sure cheapestPrice doesn\\'t have more than K stops\\n2) In each round of relaxation, changes will be done in temporary distance(price) array to ensure current path-length doesn\\'t go beyond current iteration number. \\n\\n( For clear understanding for temp: you may take example of a linear graph with source and destination at two ends and see how normal Bellman Ford behaves if edges are arranged from source to destination vs when using temporary distance array for modifications )\\n\\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int end, int k) {\\n        vector<int> dst(n,1e7);\\n        vector<int> temp(n,1e7);\\n        dst[src]=0;\\n        temp[src]=0;\\n        for(int i=0;i<=k;++i)\\n        {\\n            for(vector<int> j:flights)\\n            {\\n                if(temp[j[1]] > dst[j[0]]+j[2])\\n                    temp[j[1]] = dst[j[0]]+j[2];\\n            }\\n            for(int j=0;j<n;++j)\\n                dst[j] = temp[j];\\n        }\\n        if(dst[end]==1e7)\\n            return -1;\\n        else\\n            return dst[end];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1233858,
                "title": "java-dijkstra-s-use-visited-map-to-avoid-tle",
                "content": "\\n\\n```\\n \\n public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n        ArrayList<HashMap<Integer,Integer>> map=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            map.add(new HashMap<>());\\n        }\\n        \\n        for(int[] arr:flights){   \\n            map.get(arr[0]).put(arr[1],arr[2]);\\n        }\\n        \\n        Map<Integer, Integer> visited = new HashMap<>();\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[2]-b[2]);\\n        \\n        pq.offer(new int[]{src,-1,0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] rn=pq.poll();\\n            \\n           \\n            int city = rn[0];\\n            int stops = rn[1];\\n            int price = rn[2];\\n           \\n           \\n            if(city==dst){\\n                return price;\\n            }\\n            \\n            visited.put(city, stops); \\n            \\n            if(stops==k)continue;\\n               \\n            \\n                for(int val:map.get(city).keySet()){\\n                     if (!visited.containsKey(val) || stops < visited.get(val)) {\\n                    pq.offer(new int[]{val,stops+1,price+map.get(city).get(val)});\\n                     }\\n                }   \\n         \\n        }\\n        \\n        return -1;\\n   \\n    }\\n,,,",
                "solutionTags": [],
                "code": "\\n\\n```\\n \\n public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n        ArrayList<HashMap<Integer,Integer>> map=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            map.add(new HashMap<>());\\n        }\\n        \\n        for(int[] arr:flights){   \\n            map.get(arr[0]).put(arr[1],arr[2]);\\n        }\\n        \\n        Map<Integer, Integer> visited = new HashMap<>();\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[2]-b[2]);\\n        \\n        pq.offer(new int[]{src,-1,0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] rn=pq.poll();\\n            \\n           \\n            int city = rn[0];\\n            int stops = rn[1];\\n            int price = rn[2];\\n           \\n           \\n            if(city==dst){\\n                return price;\\n            }\\n            \\n            visited.put(city, stops); \\n            \\n            if(stops==k)continue;\\n               \\n            \\n                for(int val:map.get(city).keySet()){\\n                     if (!visited.containsKey(val) || stops < visited.get(val)) {\\n                    pq.offer(new int[]{val,stops+1,price+map.get(city).get(val)});\\n                     }\\n                }   \\n         \\n        }\\n        \\n        return -1;\\n   \\n    }\\n,,,",
                "codeTag": "Unknown"
            },
            {
                "id": 207128,
                "title": "two-java-solutions-one-is-dp-and-the-other-is-dijkstra",
                "content": "Time Complexity for this solution is O(KN), k is stop and N is the number of cities\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        //dp[i][j] denotes the cheapest price within i-1 stops, stop in j city\\n        long[][] dp = new long[K+2][n];\\n        for (long[] d : dp) Arrays.fill(d, Integer.MAX_VALUE);\\n        dp[0][src] = 0;\\n        for (int i = 1; i < K+2; i++) {\\n            dp[i][src] = 0;\\n            for (int[] f : flights) {\\n                dp[i][f[1]] = Math.min(dp[i][f[1]], dp[i-1][f[0]] + f[2]);\\n            }\\n        }\\n        return dp[K+1][dst] == Integer.MAX_VALUE ? -1 : (int)dp[K+1][dst];\\n    }\\n```\\nTime Complexity is O(ElogV) E is the length of flights and V is the number of cities\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) map.put(i, new HashMap<>());\\n        for (int[] f : flights){\\n            map.get(f[0]).put(f[1], f[2]);\\n        } \\n        Queue<int[]> pq = new PriorityQueue<>((a, b) ->a[0]-b[0]);\\n        pq.add(new int[] {0, src, -1});\\n        while (!pq.isEmpty()) {\\n            int[] temp = pq.poll();\\n            int cost = temp[0], ID = temp[1], stop = temp[2];\\n            if (ID == dst) return cost;\\n            if (stop < k) {\\n                Map<Integer, Integer> hs = map.getOrDefault(ID, new HashMap<>());\\n                for (int a : hs.keySet()) {\\n                    pq.add(new int[] {cost + hs.get(a), a, stop+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        //dp[i][j] denotes the cheapest price within i-1 stops, stop in j city\\n        long[][] dp = new long[K+2][n];\\n        for (long[] d : dp) Arrays.fill(d, Integer.MAX_VALUE);\\n        dp[0][src] = 0;\\n        for (int i = 1; i < K+2; i++) {\\n            dp[i][src] = 0;\\n            for (int[] f : flights) {\\n                dp[i][f[1]] = Math.min(dp[i][f[1]], dp[i-1][f[0]] + f[2]);\\n            }\\n        }\\n        return dp[K+1][dst] == Integer.MAX_VALUE ? -1 : (int)dp[K+1][dst];\\n    }\\n```\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) map.put(i, new HashMap<>());\\n        for (int[] f : flights){\\n            map.get(f[0]).put(f[1], f[2]);\\n        } \\n        Queue<int[]> pq = new PriorityQueue<>((a, b) ->a[0]-b[0]);\\n        pq.add(new int[] {0, src, -1});\\n        while (!pq.isEmpty()) {\\n            int[] temp = pq.poll();\\n            int cost = temp[0], ID = temp[1], stop = temp[2];\\n            if (ID == dst) return cost;\\n            if (stop < k) {\\n                Map<Integer, Integer> hs = map.getOrDefault(ID, new HashMap<>());\\n                for (int a : hs.keySet()) {\\n                    pq.add(new int[] {cost + hs.get(a), a, stop+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100173,
                "title": "c-bfs-solution-very-easy-dijkstra-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBreadth-First Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- maintain a adj list with src -> {dst,cost}\\n- make a queue for pending node(pn)\\n- push stops,node,cost\\n- a distance vector & dist of src = 0\\n- perform normal BFS & check if adj[node] dist can be change within stops <=k\\n- if yes then update dist[currnode] & push to queue {stops+1,{currnode,updatedcost}}\\n- return dist[dst]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto it : flights){\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        queue<pair<int,pair<int,int>>> pn;\\n        pn.push({0,{src,0}});\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        while(!pn.empty()){\\n            auto front = pn.front();\\n            pn.pop();\\n            int stops = front.first;\\n            int node = front.second.first;\\n            int distance = front.second.second;\\n            if(stops>k)continue;\\n            for(auto it:adj[node]){\\n                int adjnode = it.first;\\n                int d = it.second;\\n                if(distance + d<dist[adjnode]&&stops<=k){\\n                    dist[adjnode] = distance + d;\\n                    pn.push({stops+1,{adjnode,distance+d}});\\n                }\\n            }\\n        }\\n        if(dist[dst]==1e9)return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto it : flights){\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        queue<pair<int,pair<int,int>>> pn;\\n        pn.push({0,{src,0}});\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        while(!pn.empty()){\\n            auto front = pn.front();\\n            pn.pop();\\n            int stops = front.first;\\n            int node = front.second.first;\\n            int distance = front.second.second;\\n            if(stops>k)continue;\\n            for(auto it:adj[node]){\\n                int adjnode = it.first;\\n                int d = it.second;\\n                if(distance + d<dist[adjnode]&&stops<=k){\\n                    dist[adjnode] = distance + d;\\n                    pn.push({stops+1,{adjnode,distance+d}});\\n                }\\n            }\\n        }\\n        if(dist[dst]==1e9)return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420325,
                "title": "queue-bfs-similar-to-dijkstras-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int,int>>>g(n);\\n        for(auto& i:flights) g[i[0]].push_back({i[1],i[2]});\\n        vector<int>dist(n,INT_MAX);\\n        dist[src]=0;\\n        queue<pair<int,int>>pq;\\n        pq.push({0,src});\\n        k+=1;\\n        while(!pq.empty() && k--){\\n            int n=pq.size();\\n            while(n--){\\n                int d=pq.front().first,s=pq.front().second;\\n                pq.pop();\\n                for(auto& i:g[s]){\\n                    if(dist[i.first]>d+i.second){\\n                        dist[i.first]=d+i.second;\\n                        pq.push({dist[i.first],i.first});\\n                    } \\n                }                \\n            }\\n        }\\n        return dist[dst]==INT_MAX? -1:dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int,int>>>g(n);\\n        for(auto& i:flights) g[i[0]].push_back({i[1],i[2]});\\n        vector<int>dist(n,INT_MAX);\\n        dist[src]=0;\\n        queue<pair<int,int>>pq;\\n        pq.push({0,src});\\n        k+=1;\\n        while(!pq.empty() && k--){\\n            int n=pq.size();\\n            while(n--){\\n                int d=pq.front().first,s=pq.front().second;\\n                pq.pop();\\n                for(auto& i:g[s]){\\n                    if(dist[i.first]>d+i.second){\\n                        dist[i.first]=d+i.second;\\n                        pq.push({dist[i.first],i.first});\\n                    } \\n                }                \\n            }\\n        }\\n        return dist[dst]==INT_MAX? -1:dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278081,
                "title": "python-bellman-ford-vs-spfa-vs-bfs",
                "content": "This problem is good to compare different solutions of shortest path algos: \\n1. Bellman-Ford\\n2. SPFA\\n3. BFS\\n\\nIn fact, the 3 solutions are quite similar: do `k+1` round relaxations and find the shortest path from `src` to `dst`. \\nOn the other hand, the difference is also obvious. If we consider Bellman-Ford as a benchmark, SPFA and BFS are optimazations based on different **PRUNING** strategies.\\n\\n**Bellman-Ford**\\n[Bellman-Ford](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) is based on relaxation. Each round of relaxation, we iteratve ALL the edges and do the relaxation based on the `prices` we got from previous round.\\n In the `k`-th round of relaxation, we could find the min prices for cities whose path from source is no more than `k` edges.\\n Therefore, we do `k+1` round relaxations, instead of the traditional `V-1` rounds.\\n```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n        prices = [inf] * n\\n        prices[src] = 0\\n        for _ in range(k+1):\\n            next_prices = [d for d in prices]\\n            for a, b, p in flights:\\n                if prices[a] + p < next_prices[b]:\\n                    next_prices[b] = prices[a] + p\\n            prices = next_prices\\n        return prices[dst] if prices[dst] != inf else -1\\n```\\n\\n**SPFA**\\nSPFA, or [Shortest Path Faster Algorithm](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm), is an optimazation of Bellman-Ford. Instead of iterate all edges  during a round of relaxation, we maintain a list of cities whose price is updated in this round. These cities are the ones we should visit in the next round.\\n\\n```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(dict)\\n        for a, b, p in flights:\\n            graph[a][b] = p\\n            \\n        prices = [inf] * n\\n        prices[src] = 0\\n        \\n        q = [src]\\n        nstops = 0\\n        \\n        while q and nstops <= k:\\n            next_q = []\\n            next_prices = [p for p in prices]\\n            for city in q:\\n                for nxt in graph[city]:\\n                    if prices[city] + graph[city][nxt] < next_prices[nxt]:\\n                        next_prices[nxt] = prices[city] + graph[city][nxt]\\n                        next_q.append(nxt)\\n            q = next_q\\n            prices = next_prices\\n            nstops += 1\\n            \\n        return -1 if prices[dst] == inf else prices[dst]\\n```\\n\\n**BFS**\\nBFS is another optimization of Bellman_Ford for this problem. We consider number of stops as the level of BFS in the city graph. For each city in visited in `nstops` level, add all its children to the next level, i.e. `nstops + 1` level. Maintain a min price for each ciy during BFS. The way we prune the BFS tree is: \\n- If we find the price to a city is higher than or equal to what we keep in `prices`, we could prune this branch, because it is obviously more enpensive then what we considered when we updated `prices[city]` the last time.\\n- If we reach `dst` during BFS, we don\\'t have to keep searching its children, because it won\\'t give a lower price to `dst`.\\n\\n```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n        graph = defaultdict(dict)\\n        for a, b, p in flights:\\n            graph[a][b] = p\\n            \\n        prices = {city: inf for city in range(n)}\\n        \\n        # price, city\\n        q = [(0, src)]\\n        stops = 0\\n        \\n        while q and stops <= k + 1:\\n\\n            next_q = []\\n            for price, city in q:\\n                if price > prices[city]:\\n                    continue\\n                prices[city] = price\\n                if city == dst:\\n                    continue\\n                for nxt in graph[city]:\\n                    next_q.append((price + graph[city][nxt], nxt))\\n                \\n            stops += 1\\n            q = next_q\\n            \\n        return prices[dst] if prices[dst] != inf else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n        prices = [inf] * n\\n        prices[src] = 0\\n        for _ in range(k+1):\\n            next_prices = [d for d in prices]\\n            for a, b, p in flights:\\n                if prices[a] + p < next_prices[b]:\\n                    next_prices[b] = prices[a] + p\\n            prices = next_prices\\n        return prices[dst] if prices[dst] != inf else -1\\n```\n```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(dict)\\n        for a, b, p in flights:\\n            graph[a][b] = p\\n            \\n        prices = [inf] * n\\n        prices[src] = 0\\n        \\n        q = [src]\\n        nstops = 0\\n        \\n        while q and nstops <= k:\\n            next_q = []\\n            next_prices = [p for p in prices]\\n            for city in q:\\n                for nxt in graph[city]:\\n                    if prices[city] + graph[city][nxt] < next_prices[nxt]:\\n                        next_prices[nxt] = prices[city] + graph[city][nxt]\\n                        next_q.append(nxt)\\n            q = next_q\\n            prices = next_prices\\n            nstops += 1\\n            \\n        return -1 if prices[dst] == inf else prices[dst]\\n```\n```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n        graph = defaultdict(dict)\\n        for a, b, p in flights:\\n            graph[a][b] = p\\n            \\n        prices = {city: inf for city in range(n)}\\n        \\n        # price, city\\n        q = [(0, src)]\\n        stops = 0\\n        \\n        while q and stops <= k + 1:\\n\\n            next_q = []\\n            for price, city in q:\\n                if price > prices[city]:\\n                    continue\\n                prices[city] = price\\n                if city == dst:\\n                    continue\\n                for nxt in graph[city]:\\n                    next_q.append((price + graph[city][nxt], nxt))\\n                \\n            stops += 1\\n            q = next_q\\n            \\n        return prices[dst] if prices[dst] != inf else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 687660,
                "title": "c-python-bfs-template-and-bellman-ford",
                "content": "\\nApproach 1: BFS+template:\\n```\\nclass Solution { // BFS: BEST; Time/Space: O(n^(K+1)), O(n^(K+1))\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        int ans = INT_MAX;\\n        unordered_map<int, vector<pair<int, int>> > schedules;\\n        for(auto flight: flights)            \\n            schedules[flight[0]].emplace_back(flight[1], flight[2]); //okay\\n            //schedules[flight[0]].push_back({flight[1], flight[2]}); //Note1             \\n        queue<pair<int, int>> q{{{src, 0}}}; // it costs 0 to reach \\'src\\'\\n        for(int step = 0; !q.empty() && step <= K+1; step++){\\n            for(int size = q.size(); size-->0;){\\n                auto [target, cost] = q.front();q.pop();   //step1: current node                \\n                if(target == dst) {\\n                    ans = min(ans, cost);\\n                    continue; //Note4:\\n                }\\n                for(auto& next: schedules[target]){   //step2: check next nodes\\n                    if(cost + next.second > ans ) continue; //Note2: pruning\\n                    if(step == K + 1 && next.first != dst) continue; //Note5\\n                    q.emplace(next.first, cost + next.second); //Note3                    \\n                }\\n            }\\n        }\\n        return ans==INT_MAX? -1: ans;                             \\n    }          \\n};\\n/*\\nNote1: key->value means: src->{dst, cost}\\nNote2: pruning by best cost by far\\nNote3: why not need marking visited? Checking City 2 in Example 1. You may revist same city in different steps\\nNote4: Optional. If we reach destination, we don\\'t need to process target\\'s neighbor\\nNote5: Optional. If this is the last iteration, we should only update neighbor == target; otherwise we might create other minCost that require more than k stops\\n*/\\n```\\n\\nApproach 2: Python, Bellman-Ford Alogrithm:\\n```\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        prices = [float(\\'inf\\')] * n \\n        prices[src]=0\\n        \\n        for i in range(k+1):\\n            tempPrice = prices.copy()\\n            for s, d, p in flights:\\n                if tempPrice[s] < float(\\'inf\\'):\\n                    if tempPrice[d] > prices[s]+p:\\n                        tempPrice[d] = prices[s]+p\\n            prices = tempPrice.copy()\\n        \\n        return -1 if prices[dst] == float(\\'inf\\') else prices[dst]\\n```\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution { // BFS: BEST; Time/Space: O(n^(K+1)), O(n^(K+1))\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        int ans = INT_MAX;\\n        unordered_map<int, vector<pair<int, int>> > schedules;\\n        for(auto flight: flights)            \\n            schedules[flight[0]].emplace_back(flight[1], flight[2]); //okay\\n            //schedules[flight[0]].push_back({flight[1], flight[2]}); //Note1             \\n        queue<pair<int, int>> q{{{src, 0}}}; // it costs 0 to reach \\'src\\'\\n        for(int step = 0; !q.empty() && step <= K+1; step++){\\n            for(int size = q.size(); size-->0;){\\n                auto [target, cost] = q.front();q.pop();   //step1: current node                \\n                if(target == dst) {\\n                    ans = min(ans, cost);\\n                    continue; //Note4:\\n                }\\n                for(auto& next: schedules[target]){   //step2: check next nodes\\n                    if(cost + next.second > ans ) continue; //Note2: pruning\\n                    if(step == K + 1 && next.first != dst) continue; //Note5\\n                    q.emplace(next.first, cost + next.second); //Note3                    \\n                }\\n            }\\n        }\\n        return ans==INT_MAX? -1: ans;                             \\n    }          \\n};\\n/*\\nNote1: key->value means: src->{dst, cost}\\nNote2: pruning by best cost by far\\nNote3: why not need marking visited? Checking City 2 in Example 1. You may revist same city in different steps\\nNote4: Optional. If we reach destination, we don\\'t need to process target\\'s neighbor\\nNote5: Optional. If this is the last iteration, we should only update neighbor == target; otherwise we might create other minCost that require more than k stops\\n*/\\n```\n```\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        prices = [float(\\'inf\\')] * n \\n        prices[src]=0\\n        \\n        for i in range(k+1):\\n            tempPrice = prices.copy()\\n            for s, d, p in flights:\\n                if tempPrice[s] < float(\\'inf\\'):\\n                    if tempPrice[d] > prices[s]+p:\\n                        tempPrice[d] = prices[s]+p\\n            prices = tempPrice.copy()\\n        \\n        return -1 if prices[dst] == float(\\'inf\\') else prices[dst]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504130,
                "title": "java-bfs-prim-s-algorithm-minimum-spanning-tree",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        // pair<src_city, pair<dest_city, price>>\\n        Map<Integer, Map<Integer, Integer>> g = buildGraph(flights);\\n        \\n        Queue<Flight> q = new PriorityQueue<>(Comparator.comparingInt(f -> f.cost));\\n        \\n        q.add(new Flight(0, src, 0));\\n        \\n        while (!q.isEmpty()) {\\n            Flight f = q.poll();\\n            \\n            if (f.hops > K + 1) {\\n                continue;\\n            }\\n            \\n            if (f.to == dst) {\\n                return f.cost;\\n            }\\n            \\n            for (Map.Entry<Integer, Integer> u : g.getOrDefault(f.to, new HashMap<>()).entrySet()) {\\n                int to = u.getKey();\\n                \\n                int costSum = f.cost + u.getValue();\\n                q.add(new Flight(costSum, to, f.hops + 1));\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    Map<Integer, Map<Integer, Integer>> buildGraph(int[][] flights) {\\n        Map<Integer, Map<Integer, Integer>> g = new HashMap<>();\\n        \\n        for (int[] edge : flights) {\\n            Map<Integer, Integer> u = g.getOrDefault(edge[0], new HashMap<>());\\n            u.put(edge[1], edge[2]);\\n            \\n            g.put(edge[0], u);            \\n        }\\n        \\n        return g;\\n    }\\n    \\n    class Flight {\\n        int cost;\\n        int to;\\n        int hops;\\n        \\n        Flight(int cost, int to, int hops) {\\n            this.cost = cost;\\n            this.to = to;\\n            this.hops = hops;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        // pair<src_city, pair<dest_city, price>>\\n        Map<Integer, Map<Integer, Integer>> g = buildGraph(flights);\\n        \\n        Queue<Flight> q = new PriorityQueue<>(Comparator.comparingInt(f -> f.cost));\\n        \\n        q.add(new Flight(0, src, 0));\\n        \\n        while (!q.isEmpty()) {\\n            Flight f = q.poll();\\n            \\n            if (f.hops > K + 1) {\\n                continue;\\n            }\\n            \\n            if (f.to == dst) {\\n                return f.cost;\\n            }\\n            \\n            for (Map.Entry<Integer, Integer> u : g.getOrDefault(f.to, new HashMap<>()).entrySet()) {\\n                int to = u.getKey();\\n                \\n                int costSum = f.cost + u.getValue();\\n                q.add(new Flight(costSum, to, f.hops + 1));\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    Map<Integer, Map<Integer, Integer>> buildGraph(int[][] flights) {\\n        Map<Integer, Map<Integer, Integer>> g = new HashMap<>();\\n        \\n        for (int[] edge : flights) {\\n            Map<Integer, Integer> u = g.getOrDefault(edge[0], new HashMap<>());\\n            u.put(edge[1], edge[2]);\\n            \\n            g.put(edge[0], u);            \\n        }\\n        \\n        return g;\\n    }\\n    \\n    class Flight {\\n        int cost;\\n        int to;\\n        int hops;\\n        \\n        Flight(int cost, int to, int hops) {\\n            this.cost = cost;\\n            this.to = to;\\n            this.hops = hops;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362377,
                "title": "python-dijkstra-with-detailed-comments-and-explanation",
                "content": "*-- Based on Dijsktra in the solution tab but with more comments and explanations --*\\n**IDEA:**\\nIn a basic Dijkstra algorithm, the only basis upon which one path is given priority over another\\nis the cost. In this problem however, there is an additional constraint; length of route or (number of stops)\\n\\nA slight modification can be introduced to basic Dijsktra to count for both (cost and length)\\nJust like in a normal Dijkstra, we have to keep track of the cost needed to reach a node in weightd dict;\\n\\n\\tweights = {\\n\\t\\t\\t\\tA : cost to reach node A,\\n\\t\\t\\t\\tB : cost to reach node B,\\n\\t\\t\\t\\t...,\\n\\t\\t\\t\\t..,\\n\\t\\t\\t\\t.\\n\\t\\t\\t  }\\n\\nBut we know that in the context of this problem we could reach the same node via two different routes and it\\'s possible that the more expensive route would be the way to go if the lesser-costly route had more than K stops between src (source node) and dst (destination node). So we have to keep track of all routes to the node and compare on the basis of (cost and number of stops). Hence our modified dict will look something like this\\nlook something like this:\\n\\n\\t\\tweights = {\\n\\t\\t\\t\\t(k1, A) : cost to reach node A taking k1 stops, ---- (*)\\n\\t\\t\\t\\t(k2, B) : cost to reach node B taking k2 steps,\\n\\t\\t\\t\\t(k3, A) : cost to reach node B taking k3 steps, ---- (*)\\n\\t\\t\\t\\t...,\\n\\t\\t\\t\\t..,\\n\\t\\t\\t\\t.\\n\\t\\t\\t  }\\n\\n\\t\\t(*) notice how we have two records that pertain to the same node (node A)\\n\\t\\tin the dict but with different k\\n\\nAn additional modifcation is also needed to be able to use the described approach. Instead of using a visited set to keep track of seen nodes so we don\\'t visit them again. We have to come up with a more nuanced elimination method as we no more can afford to exclude (eliminate) a node solely on the basis that we have seen it before. We are only allowed to exclude a node (not push it to the heap) if:\\n\\n- node seen before and node\\'s cost last time we saw it was less than current cost\\n- Or, node seen before and node\\'s number of steps was less last time we saw it\\n```\\nif cost > weights.get((k, node), float(\\'inf\\')) or k > K:\\n\\t\\tcontinue\\n```\\nThe logic here is simply this; if I\\'ve already seen a node via a cheaper route or via a route that had less number of stops, then I don\\'t\\nneed to consider it.\\n\\n**Final Code**\\n\\n```\\n        \\ndef findCheapestPrice(n, flights, src, dst, K):\\n\\t\\t# Build the graph:\\n        from collections import defaultdict\\n        d = defaultdict(list)\\n        for u, v, w in flights:\\n            d[u].append((w,v)) # directed\\n        \\n        # Apply Dijkstra:\\n        from heapq import heappop, heappush\\n        h = [(0, -1, src)] # cost, k, node\\n        weights = {} # instead of pre-processing the weights dict with placeholder values of inf and 0, we do it on the fly\\n        while h:\\n            cost, k, node = heappop(h)\\n            if cost > weights.get((k, node), float(\\'inf\\')) or \\\\\\n            k > K:\\n                continue # don\\'t even bother to add to heap\\n            if node == dst:\\n                return cost\\n            for edgeCost, nei in d[node]:\\n                newCost = edgeCost + cost\\n                if weights.get((k+1, nei), float(\\'inf\\')) > newCost:\\n                    weights[(k+1, nei)] = newCost\\n                    heappush(h, (newCost, k+1, nei))\\n        return -1 # all nodes visited but no dst found, so return -1\\n```\\n\\n**Initial code passing 35/41 test cases as of 8/19/19**\\nIn the code below, I naively used a visited set to keep tarck of the explored nodes and to make sure I don\\'t visit them again\\n```\\n# apply Dijsktra:\\nh = [(0, src, 0)] # format = (cost, src, steps)\\nvisited = set()\\nfrom heapq import heappop, heappush\\nwhile h:\\n\\tcheapest_cost, cheapest_node, stops = heappop(h)\\n\\tvisited.add(cheapest_node) \\n\\tif stops <= K:\\n\\t\\tfor edge_cost, nei in d[cheapest_node]:\\n\\t\\t\\tif weights[cheapest_node] + edge_cost < weights[nei]:\\n\\t\\t\\t\\tif nei not in visited:\\n\\t\\t\\t\\t\\tweights[nei] = weights[cheapest_node] + edge_cost\\n\\t\\t\\t\\t\\theappush(h, (weights[nei], nei, stops+1))\\nreturn weights[dst]\\n```\\n\\n**A test case where initial code would fail**\\n - see image:\\n\\n![image](https://assets.leetcode.com/users/abadawi/image_1566238824.png)\\n\\n- visualized:\\nBecause node 2 has been visited once via path (0 -> 1 -> 2), node 2 has been marked visited and thus was excluded from the preferred path -path with one stop- (0 -> 2 -> 3). See image:\\n\\n![image](https://assets.leetcode.com/users/abadawi/image_1566239428.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```\\nif cost > weights.get((k, node), float(\\'inf\\')) or k > K:\\n\\t\\tcontinue\\n```\n```\\n        \\ndef findCheapestPrice(n, flights, src, dst, K):\\n\\t\\t# Build the graph:\\n        from collections import defaultdict\\n        d = defaultdict(list)\\n        for u, v, w in flights:\\n            d[u].append((w,v)) # directed\\n        \\n        # Apply Dijkstra:\\n        from heapq import heappop, heappush\\n        h = [(0, -1, src)] # cost, k, node\\n        weights = {} # instead of pre-processing the weights dict with placeholder values of inf and 0, we do it on the fly\\n        while h:\\n            cost, k, node = heappop(h)\\n            if cost > weights.get((k, node), float(\\'inf\\')) or \\\\\\n            k > K:\\n                continue # don\\'t even bother to add to heap\\n            if node == dst:\\n                return cost\\n            for edgeCost, nei in d[node]:\\n                newCost = edgeCost + cost\\n                if weights.get((k+1, nei), float(\\'inf\\')) > newCost:\\n                    weights[(k+1, nei)] = newCost\\n                    heappush(h, (newCost, k+1, nei))\\n        return -1 # all nodes visited but no dst found, so return -1\\n```\n```\\n# apply Dijsktra:\\nh = [(0, src, 0)] # format = (cost, src, steps)\\nvisited = set()\\nfrom heapq import heappop, heappush\\nwhile h:\\n\\tcheapest_cost, cheapest_node, stops = heappop(h)\\n\\tvisited.add(cheapest_node) \\n\\tif stops <= K:\\n\\t\\tfor edge_cost, nei in d[cheapest_node]:\\n\\t\\t\\tif weights[cheapest_node] + edge_cost < weights[nei]:\\n\\t\\t\\t\\tif nei not in visited:\\n\\t\\t\\t\\t\\tweights[nei] = weights[cheapest_node] + edge_cost\\n\\t\\t\\t\\t\\theappush(h, (weights[nei], nei, stops+1))\\nreturn weights[dst]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3101719,
                "title": "java-dfs-memoization-approach",
                "content": "```\\n// Approach #1: DFS + Memoization Approach\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<int[]>> adjList = new HashMap<>();\\n        \\n        for (int[] flight : flights) \\n            adjList.computeIfAbsent(flight[0], value -> new ArrayList<int[]>())\\n                .add(new int[] { flight[1], flight[2] });\\n\\t\\t\\t\\t\\n\\t\\tInteger[][] memo = new Integer[n + 1][k + 1];\\n        int minPrice = dfs(adjList, src, dst, memo, k);\\n\\t\\t\\n        return minPrice == Integer.MAX_VALUE ? -1: minPrice;\\n    }\\n    \\n    private int dfs(Map<Integer, List<int[]>> adjList, int curr, int dst, Integer[][] memo, int k) {   \\n        if (curr == dst)\\n\\t\\t\\treturn 0;\\n        \\n\\t\\tif (k < 0 || !adjList.containsKey(curr))\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n        \\n\\t\\tif (memo[curr][k] != null) \\n\\t\\t\\t return memo[curr][k];\\n        \\n\\t\\tint minPrice = Integer.MAX_VALUE;\\n\\t\\t\\n        for (int[] next : adjList.get(curr)) {\\n\\t\\t\\tint price = dfs(adjList, next[0], dst, memo, k - 1);\\n\\t\\t\\t\\n            if (price != Integer.MAX_VALUE) \\n                minPrice = Math.min(minPrice, price + next[1]);\\n        }\\n\\t\\t\\n        return memo[curr][k] = minPrice;\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n// Approach #1: DFS + Memoization Approach\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<int[]>> adjList = new HashMap<>();\\n        \\n        for (int[] flight : flights) \\n            adjList.computeIfAbsent(flight[0], value -> new ArrayList<int[]>())\\n                .add(new int[] { flight[1], flight[2] });\\n\\t\\t\\t\\t\\n\\t\\tInteger[][] memo = new Integer[n + 1][k + 1];\\n        int minPrice = dfs(adjList, src, dst, memo, k);\\n\\t\\t\\n        return minPrice == Integer.MAX_VALUE ? -1: minPrice;\\n    }\\n    \\n    private int dfs(Map<Integer, List<int[]>> adjList, int curr, int dst, Integer[][] memo, int k) {   \\n        if (curr == dst)\\n\\t\\t\\treturn 0;\\n        \\n\\t\\tif (k < 0 || !adjList.containsKey(curr))\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n        \\n\\t\\tif (memo[curr][k] != null) \\n\\t\\t\\t return memo[curr][k];\\n        \\n\\t\\tint minPrice = Integer.MAX_VALUE;\\n\\t\\t\\n        for (int[] next : adjList.get(curr)) {\\n\\t\\t\\tint price = dfs(adjList, next[0], dst, memo, k - 1);\\n\\t\\t\\t\\n            if (price != Integer.MAX_VALUE) \\n                minPrice = Math.min(minPrice, price + next[1]);\\n        }\\n\\t\\t\\n        return memo[curr][k] = minPrice;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066105,
                "title": "python-easy-solution-using-dijkstra-s-algorithm",
                "content": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        #Make graph\\n        adj_list = {i:[] for i in range(n)}\\n        for frm, to, price in flights:\\n            adj_list[frm].append((to, price))\\n        \\n        best_visited = [2**31]*n # Initialized to maximum\\n        \\n        prior_queue = [ (0, -1, src) ]  # weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if best_visited[node] <= steps:  # Have seen the node already, and the current steps are more than last time\\n                continue\\n\\n            if steps > k:  # More than k stops, invalid\\n                continue\\n\\n            if node==dst:  # reach the destination # as priority_queue is a minHeap so this cost is the most minimum cost.\\n                return cost\\n            \\n            best_visited[node] = steps # Update steps\\n\\n            for neighb, weight in adj_list[node]:\\n                heapq.heappush(prior_queue, (cost + weight, steps + 1, neighb))\\n\\n        return -1\\n\\t\\t\\n# Time: O(n * len(flights) * log(n))\\n# Space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        #Make graph\\n        adj_list = {i:[] for i in range(n)}\\n        for frm, to, price in flights:\\n            adj_list[frm].append((to, price))\\n        \\n        best_visited = [2**31]*n # Initialized to maximum\\n        \\n        prior_queue = [ (0, -1, src) ]  # weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if best_visited[node] <= steps:  # Have seen the node already, and the current steps are more than last time\\n                continue\\n\\n            if steps > k:  # More than k stops, invalid\\n                continue\\n\\n            if node==dst:  # reach the destination # as priority_queue is a minHeap so this cost is the most minimum cost.\\n                return cost\\n            \\n            best_visited[node] = steps # Update steps\\n\\n            for neighb, weight in adj_list[node]:\\n                heapq.heappush(prior_queue, (cost + weight, steps + 1, neighb))\\n\\n        return -1\\n\\t\\t\\n# Time: O(n * len(flights) * log(n))\\n# Space: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513235,
                "title": "java-dijkstra-solution",
                "content": "```\\n// Dijkstra Solution\\n// Note 1: Check whether node.stop > k\\n// Note 2: Add to heap 1) distance is shorter; 2) number of stops are less.\\n// Time complexity: O(N + ElogN)\\n// Space complexity: O(N)\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        List<Node>[] graph = new ArrayList[n];\\n        buildGraph(graph, flights);\\n        int[] prices = new int[n];\\n        int[] stops = new int[n];\\n        Arrays.fill(prices, Integer.MAX_VALUE);\\n        Arrays.fill(stops, Integer.MAX_VALUE);\\n        prices[src] = 0;\\n        stops[src] = 0;\\n        PriorityQueue<Node> heap = new PriorityQueue<>((n1, n2) -> Integer.compare(n1.price, n2.price));\\n        heap.add(new Node(src, 0, 0));  // id, price, stop\\n        while (!heap.isEmpty()) {\\n            Node node = heap.poll();\\n            if (node.id == dst) return node.price;\\n            if (node.stop > k) continue;\\n            for (Node neighbor : graph[node.id]) {\\n                int nextCost = node.price + neighbor.price;\\n                int nextStop = node.stop+1;\\n                if (prices[neighbor.id] > nextCost) {\\n                    // if nextCost is less than price, update prices and stops array, and explore the neighbor.\\n                    prices[neighbor.id] = nextCost;\\n                    stops[neighbor.id] = nextStop;\\n                    heap.add(new Node(neighbor.id, nextCost, nextStop));\\n                } else if (stops[neighbor.id] > node.stop) {\\n                    // if node.stop < stops[neighbor.label], explore the neighbor.\\n                    heap.add(new Node(neighbor.id, nextCost, nextStop));\\n                }\\n            }\\n        }\\n        return prices[dst] == Integer.MAX_VALUE ? -1 : prices[dst];\\n    }\\n    \\n    private void buildGraph(List<Node>[] graph, int[][] flights) {\\n        for (int i = 0; i < graph.length; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] flight : flights) {\\n            int from = flight[0], to = flight[1], price = flight[2];\\n            graph[from].add(new Node(to, price, 0));\\n        }\\n    }\\n    \\n    static class Node {\\n        int id, price, stop;\\n        Node(int id, int price, int stop) {\\n            this.id = id;\\n            this.price = price;\\n            this.stop = stop;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Dijkstra Solution\\n// Note 1: Check whether node.stop > k\\n// Note 2: Add to heap 1) distance is shorter; 2) number of stops are less.\\n// Time complexity: O(N + ElogN)\\n// Space complexity: O(N)\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        List<Node>[] graph = new ArrayList[n];\\n        buildGraph(graph, flights);\\n        int[] prices = new int[n];\\n        int[] stops = new int[n];\\n        Arrays.fill(prices, Integer.MAX_VALUE);\\n        Arrays.fill(stops, Integer.MAX_VALUE);\\n        prices[src] = 0;\\n        stops[src] = 0;\\n        PriorityQueue<Node> heap = new PriorityQueue<>((n1, n2) -> Integer.compare(n1.price, n2.price));\\n        heap.add(new Node(src, 0, 0));  // id, price, stop\\n        while (!heap.isEmpty()) {\\n            Node node = heap.poll();\\n            if (node.id == dst) return node.price;\\n            if (node.stop > k) continue;\\n            for (Node neighbor : graph[node.id]) {\\n                int nextCost = node.price + neighbor.price;\\n                int nextStop = node.stop+1;\\n                if (prices[neighbor.id] > nextCost) {\\n                    // if nextCost is less than price, update prices and stops array, and explore the neighbor.\\n                    prices[neighbor.id] = nextCost;\\n                    stops[neighbor.id] = nextStop;\\n                    heap.add(new Node(neighbor.id, nextCost, nextStop));\\n                } else if (stops[neighbor.id] > node.stop) {\\n                    // if node.stop < stops[neighbor.label], explore the neighbor.\\n                    heap.add(new Node(neighbor.id, nextCost, nextStop));\\n                }\\n            }\\n        }\\n        return prices[dst] == Integer.MAX_VALUE ? -1 : prices[dst];\\n    }\\n    \\n    private void buildGraph(List<Node>[] graph, int[][] flights) {\\n        for (int i = 0; i < graph.length; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] flight : flights) {\\n            int from = flight[0], to = flight[1], price = flight[2];\\n            graph[from].add(new Node(to, price, 0));\\n        }\\n    }\\n    \\n    static class Node {\\n        int id, price, stop;\\n        Node(int id, int price, int stop) {\\n            this.id = id;\\n            this.price = price;\\n            this.stop = stop;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427241,
                "title": "c-12ms-99-75-simple-bfs-commented",
                "content": "Runtime: 12 ms, faster than 99.75% of C++ online submissions for Cheapest Flights Within K Stops.\\nMemory Usage: 13.4 MB, less than 59.70% of C++ online submissions for Cheapest Flights Within K Stops.\\n```\\nclass Solution {\\npublic:\\n  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n    vector<vector<pair<int,int>>>g(n);\\n    vector<int>costs (n,INT_MAX);\\n    int answer = INT_MAX;\\n    \\n    for(auto &f: flights) g[f[0]].push_back({f[1], f[2]});     //current = {neigbour, cost to it}\\n    \\n    queue<tuple<int,int,int>> q;\\n    q.push({0,src,-1});                                        //total cost, to, tmp k\\n    while(!q.empty()){\\n      auto[tc, tt, tk] = q.front(); q.pop();\\n      if(tt == dst) {answer = min(tc, answer); continue;}\\n      if(tk++ == k || costs[tt] < tc) continue;\\n      costs[tt] = tc;\\n      \\n      for(auto &[n, c]: g[tt])                                 // &[neigbour, cost to it] \\n        if(tc + c < costs[n]) q.push({tc + c, n, tk});\\n    }\\n    \\n    return answer == INT_MAX ? -1 : answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n    vector<vector<pair<int,int>>>g(n);\\n    vector<int>costs (n,INT_MAX);\\n    int answer = INT_MAX;\\n    \\n    for(auto &f: flights) g[f[0]].push_back({f[1], f[2]});     //current = {neigbour, cost to it}\\n    \\n    queue<tuple<int,int,int>> q;\\n    q.push({0,src,-1});                                        //total cost, to, tmp k\\n    while(!q.empty()){\\n      auto[tc, tt, tk] = q.front(); q.pop();\\n      if(tt == dst) {answer = min(tc, answer); continue;}\\n      if(tk++ == k || costs[tt] < tc) continue;\\n      costs[tt] = tc;\\n      \\n      for(auto &[n, c]: g[tt])                                 // &[neigbour, cost to it] \\n        if(tc + c < costs[n]) q.push({tc + c, n, tk});\\n    }\\n    \\n    return answer == INT_MAX ? -1 : answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381417,
                "title": "my-java-solution-using-dijkstras-algorithm",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        if (flights == null || flights.length == 0 || n <= 0 || k < 0)\\n            return -1;\\n        List<List<Pair>> graph = buildGraph(flights, n);\\n        PriorityQueue<City> minHeap = new PriorityQueue<>((city1, city2) -> Integer.compare(city1.costFromSrc, city2.costFromSrc));\\n        // source, distance from src to current city, cost from src to currency city\\n        minHeap.offer(new City(src, 0, 0));\\n        Map<Integer, Integer> visited = new HashMap<>();\\n        while (!minHeap.isEmpty()) {\\n            City currentCity = minHeap.poll();\\n            if (visited.containsKey(currentCity.city) && visited.get(currentCity.city) <= currentCity.distanceFromSrc)\\n                continue;\\n            if (currentCity.city == dst)\\n                return currentCity.costFromSrc;\\n            if (currentCity.distanceFromSrc > k)\\n                continue;\\n            visited.put(currentCity.city, currentCity.distanceFromSrc);\\n            List<Pair> neighbour = graph.get(currentCity.city);\\n            for (Pair pair : neighbour) {\\n                minHeap.offer(new City(pair.destination, currentCity.distanceFromSrc + 1, currentCity.costFromSrc + pair.price));\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public List<List<Pair>> buildGraph(int [][] flights, int n) {\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i=0; i<n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] flight : flights) {\\n            graph.get(flight[0]).add(new Pair(flight[1], flight[2]));\\n        }\\n        return graph;\\n    }\\n}\\n\\nclass City {\\n    int city;\\n    // means the number of stops from source\\n    int distanceFromSrc;\\n    int costFromSrc;\\n    public City(int city, int distanceFromSrc, int costFromSrc) {\\n        this.city = city;\\n        this.distanceFromSrc = distanceFromSrc;\\n        this.costFromSrc = costFromSrc;\\n    }\\n}\\n\\nclass Pair {\\n    int destination;\\n    int price;\\n    public Pair(int destination, int price) {\\n        this.destination = destination;\\n        this.price = price;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        if (flights == null || flights.length == 0 || n <= 0 || k < 0)\\n            return -1;\\n        List<List<Pair>> graph = buildGraph(flights, n);\\n        PriorityQueue<City> minHeap = new PriorityQueue<>((city1, city2) -> Integer.compare(city1.costFromSrc, city2.costFromSrc));\\n        // source, distance from src to current city, cost from src to currency city\\n        minHeap.offer(new City(src, 0, 0));\\n        Map<Integer, Integer> visited = new HashMap<>();\\n        while (!minHeap.isEmpty()) {\\n            City currentCity = minHeap.poll();\\n            if (visited.containsKey(currentCity.city) && visited.get(currentCity.city) <= currentCity.distanceFromSrc)\\n                continue;\\n            if (currentCity.city == dst)\\n                return currentCity.costFromSrc;\\n            if (currentCity.distanceFromSrc > k)\\n                continue;\\n            visited.put(currentCity.city, currentCity.distanceFromSrc);\\n            List<Pair> neighbour = graph.get(currentCity.city);\\n            for (Pair pair : neighbour) {\\n                minHeap.offer(new City(pair.destination, currentCity.distanceFromSrc + 1, currentCity.costFromSrc + pair.price));\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public List<List<Pair>> buildGraph(int [][] flights, int n) {\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i=0; i<n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] flight : flights) {\\n            graph.get(flight[0]).add(new Pair(flight[1], flight[2]));\\n        }\\n        return graph;\\n    }\\n}\\n\\nclass City {\\n    int city;\\n    // means the number of stops from source\\n    int distanceFromSrc;\\n    int costFromSrc;\\n    public City(int city, int distanceFromSrc, int costFromSrc) {\\n        this.city = city;\\n        this.distanceFromSrc = distanceFromSrc;\\n        this.costFromSrc = costFromSrc;\\n    }\\n}\\n\\nclass Pair {\\n    int destination;\\n    int price;\\n    public Pair(int destination, int price) {\\n        this.destination = destination;\\n        this.price = price;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687441,
                "title": "java-dijkstra-s-solution-easy-solution-with-explanations",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        if(flights.length==0) return -1;\\n        \\n        HashMap<Integer, List<int []>> graph = new HashMap<>();\\n        \\n        for(int[] flight: flights){\\n            \\n            if(!graph.containsKey(flight[0])){\\n                graph.put(flight[0], new ArrayList<int[]>());\\n            }\\n            \\n            graph.get(flight[0]).add(new int[]{flight[1], flight[2]});\\n        }\\n        \\n        \\n        PriorityQueue<Node> q = new PriorityQueue<Node>((a,b) -> (a.cost - b.cost));\\n        \\n        q.add(new Node(src, 0, -1));\\n        \\n        while(!q.isEmpty()){\\n            \\n            Node curr = q.poll();\\n            \\n            if(curr.city == dst){\\n                return curr.cost;\\n            }\\n            \\n            if(curr.stop<K){\\n                List<int []> nexts = graph.getOrDefault(curr.city, new ArrayList<int[]>());\\n                \\n                for(int[] next: nexts){\\n                    q.add(new Node(next[0], curr.cost+next[1], curr.stop+1));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n\\nclass Node {\\n    int city;\\n    int cost;\\n    int stop;\\n    \\n    public Node(int city, int cost, int stop){\\n        this.city = city;\\n        this.cost = cost;\\n        this.stop = stop;\\n    }\\n}\\n```\\n\\nhttps://youtu.be/UK1SqJH3p_M",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        if(flights.length==0) return -1;\\n        \\n        HashMap<Integer, List<int []>> graph = new HashMap<>();\\n        \\n        for(int[] flight: flights){\\n            \\n            if(!graph.containsKey(flight[0])){\\n                graph.put(flight[0], new ArrayList<int[]>());\\n            }\\n            \\n            graph.get(flight[0]).add(new int[]{flight[1], flight[2]});\\n        }\\n        \\n        \\n        PriorityQueue<Node> q = new PriorityQueue<Node>((a,b) -> (a.cost - b.cost));\\n        \\n        q.add(new Node(src, 0, -1));\\n        \\n        while(!q.isEmpty()){\\n            \\n            Node curr = q.poll();\\n            \\n            if(curr.city == dst){\\n                return curr.cost;\\n            }\\n            \\n            if(curr.stop<K){\\n                List<int []> nexts = graph.getOrDefault(curr.city, new ArrayList<int[]>());\\n                \\n                for(int[] next: nexts){\\n                    q.add(new Node(next[0], curr.cost+next[1], curr.stop+1));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n\\nclass Node {\\n    int city;\\n    int cost;\\n    int stop;\\n    \\n    public Node(int city, int cost, int stop){\\n        this.city = city;\\n        this.cost = cost;\\n        this.stop = stop;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100116,
                "title": "java-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse BFS starting from the `src` city and limiting the traversal to `k+1` levels. Keep track of the cost of the trip so far until every city on the way to the destination. If a city can be reached in multiple ways, remember the lowest cost option. We will either reach the `dst` city within `k+1` iterations or not. Return the correct answer accordingly.\\n\\n# Complexity\\n- Time complexity: $$O(N+E*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N+E*k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n    List<int[]>[] adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var flight : flights)\\n      adj[flight[0]].add(new int[] {flight[1], flight[2]});\\n\\n    var costToCity = new int[n];\\n    Arrays.fill(costToCity, Integer.MAX_VALUE);\\n\\n    var queue = new ArrayDeque<int[]>();\\n    queue.offer(new int[] {src, 0});\\n\\n    while (k-- >= 0 && !queue.isEmpty()) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var stop = queue.poll();\\n        if (stop[1] >= costToCity[stop[0]])\\n          continue;\\n\\n        costToCity[stop[0]] = stop[1];\\n\\n        for (var flight : adj[stop[0]]) {\\n          if (flight[0] == dst)\\n            costToCity[dst] = Math.min(costToCity[dst], stop[1] + flight[1]);\\n          else\\n            queue.offer(new int[] {flight[0], stop[1] + flight[1]});\\n        }\\n      }\\n    }\\n    return costToCity[dst] == Integer.MAX_VALUE ? -1 : costToCity[dst];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n    List<int[]>[] adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var flight : flights)\\n      adj[flight[0]].add(new int[] {flight[1], flight[2]});\\n\\n    var costToCity = new int[n];\\n    Arrays.fill(costToCity, Integer.MAX_VALUE);\\n\\n    var queue = new ArrayDeque<int[]>();\\n    queue.offer(new int[] {src, 0});\\n\\n    while (k-- >= 0 && !queue.isEmpty()) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var stop = queue.poll();\\n        if (stop[1] >= costToCity[stop[0]])\\n          continue;\\n\\n        costToCity[stop[0]] = stop[1];\\n\\n        for (var flight : adj[stop[0]]) {\\n          if (flight[0] == dst)\\n            costToCity[dst] = Math.min(costToCity[dst], stop[1] + flight[1]);\\n          else\\n            queue.offer(new int[] {flight[0], stop[1] + flight[1]});\\n        }\\n      }\\n    }\\n    return costToCity[dst] == Integer.MAX_VALUE ? -1 : costToCity[dst];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099806,
                "title": "c-simple",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int FindCheapestPrice(int n, int[][] flights, int src, int dst, int k)   \\n    {\\n        int[] dist = new int[n];\\n        Array.Fill(dist, int.MaxValue);\\n        dist[src] = 0;\\n        for (int i = 0; i <= k; i++)\\n        {\\n            int[] temp = dist.ToArray();\\n            foreach (int[] flight in flights)\\n            {\\n                if (dist[flight[0]] != int.MaxValue) \\n                {\\n                    temp[flight[1]] = Math.Min(temp[flight[1]], dist[flight[0]] + flight[2]);\\n                }\\n            }\\n            dist = temp;\\n        }\\n        return dist[dst] == int.MaxValue ? -1 : dist[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int FindCheapestPrice(int n, int[][] flights, int src, int dst, int k)   \\n    {\\n        int[] dist = new int[n];\\n        Array.Fill(dist, int.MaxValue);\\n        dist[src] = 0;\\n        for (int i = 0; i <= k; i++)\\n        {\\n            int[] temp = dist.ToArray();\\n            foreach (int[] flight in flights)\\n            {\\n                if (dist[flight[0]] != int.MaxValue) \\n                {\\n                    temp[flight[1]] = Math.Min(temp[flight[1]], dist[flight[0]] + flight[2]);\\n                }\\n            }\\n            dist = temp;\\n        }\\n        return dist[dst] == int.MaxValue ? -1 : dist[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893568,
                "title": "bellman-ford-algorithm-in-python",
                "content": "# Intuition\\nBellman-Ford is a pretty fun way to approach this problem, and is quite straightforward to both understand and implement once you get the hang of it.\\n\\nDjikstra\\'s currently encounters a TLE in Python, so I figured it would be useful to showcase a solution which is still capable of beating the LC test cases. Additionally, this is just a really fun problem to show the algorithm on, since the reasoning is quite straightforward.  \\n\\n# Approach\\nThe Bellman-Ford algorithm is a means of finding the shortest distance from a starting node to an ending node. In this case, the code is slightly modified since we are only permitted K connections between the start and destination; as such, a temporary array is required, which will be used to update the cost array during each loop.\\n\\nFirst, initialize your list of edges (in this case a defaultdict) and your starting cost array, with some unattainably high value (in this case float(\\'inf\\')). \\n\\nNext, begin the process of iterating through the edges K + 1 times (it is K + 1 times since we are concerned only with K *connections* rather than K *flights*).\\n\\nWith each iteration, create an initial temporary array by copying the current cost array. Iterate through each node, updating the cost to reach it in the temporary array by using its *current* cost plus the weight of the respective edge compared against the *temporary* cost.\\n\\nOnce you have looped through each node, update the current cost array with the temporary array, and continue to loop K more times.\\n\\nWith the K+1 loops complete, return the cost to reach the destination, if it is not the large value you set prior, in which case the problem indicates that you should return -1.\\n\\n\\n# Complexity\\nLetting E be the number of edges, N be the number of nodes and K being the number of allowed connections:\\n- Time complexity:\\nO(K * (N + E)) - All nodes, edges are iterated through a maximum of K+1 times\\n\\n- Space complexity:\\nO(N) - Two arrays containing N costs to reach a given node\\n# Code\\n```\\n\"\"\"\\nBellman-Ford Algorithm\\n0. Construct edgeDict, inital cost array\\n1. Iterate through vertexes K+1 times\\n    0. Create temp array based off current costs\\n    1. Update each node in the temp array with the minimum of the current temporary value and the non-temporary costs + edge weight\\n    2. Update the non-temporary array with the current temporary array\\n3. Return the cost to reach the destination, if it is not float(\\'inf\\')\\n\"\"\"\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        edgeDict = collections.defaultdict(list)\\n        for vertex, edge, weight in flights:\\n            edgeDict[vertex].append((edge, weight))\\n\\n        costs = [float(\\'inf\\') for _ in range(n)]\\n        costs[src] = 0\\n        \\n        for _ in range(k + 1):\\n            temp = costs.copy()\\n            for vertex in range(n):\\n                for edge, weight in edgeDict[vertex]:\\n                    temp[edge] = min(temp[edge], costs[vertex] + weight)\\n            costs = temp\\n        \\n        if temp[dst] != float(\\'inf\\'):\\n            return temp[dst]\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\nBellman-Ford Algorithm\\n0. Construct edgeDict, inital cost array\\n1. Iterate through vertexes K+1 times\\n    0. Create temp array based off current costs\\n    1. Update each node in the temp array with the minimum of the current temporary value and the non-temporary costs + edge weight\\n    2. Update the non-temporary array with the current temporary array\\n3. Return the cost to reach the destination, if it is not float(\\'inf\\')\\n\"\"\"\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        edgeDict = collections.defaultdict(list)\\n        for vertex, edge, weight in flights:\\n            edgeDict[vertex].append((edge, weight))\\n\\n        costs = [float(\\'inf\\') for _ in range(n)]\\n        costs[src] = 0\\n        \\n        for _ in range(k + 1):\\n            temp = costs.copy()\\n            for vertex in range(n):\\n                for edge, weight in edgeDict[vertex]:\\n                    temp[edge] = min(temp[edge], costs[vertex] + weight)\\n            costs = temp\\n        \\n        if temp[dst] != float(\\'inf\\'):\\n            return temp[dst]\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953963,
                "title": "javascript-bellman-ford-time-o-e-k-easy-and-fast",
                "content": "```\\nvar findCheapestPrice = function (n, flights, src, dst, k) {\\n    let prices = new Array(n).fill(Infinity);\\n    prices[src] = 0;\\n\\n    for (let i = 0; i < k + 1; i++) {\\n        let tmpPrices = [...prices];\\n        for (let [s, d, p] of flights) {\\n            if (prices[s] === Infinity) continue;\\n            if (prices[s] + p < tmpPrices[d]) tmpPrices[d] = prices[s] + p;\\n        }\\n        prices = [...tmpPrices];\\n    }\\n\\n    return prices[dst] === Infinity ? -1 : prices[dst];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\nvar findCheapestPrice = function (n, flights, src, dst, k) {\\n    let prices = new Array(n).fill(Infinity);\\n    prices[src] = 0;\\n\\n    for (let i = 0; i < k + 1; i++) {\\n        let tmpPrices = [...prices];\\n        for (let [s, d, p] of flights) {\\n            if (prices[s] === Infinity) continue;\\n            if (prices[s] + p < tmpPrices[d]) tmpPrices[d] = prices[s] + p;\\n        }\\n        prices = [...tmpPrices];\\n    }\\n\\n    return prices[dst] === Infinity ? -1 : prices[dst];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522443,
                "title": "c-bellman-ford-algorithm-bfs-bottom-up-dp-relax-operation-for-k-1-times",
                "content": "```\\nclass Solution {\\npublic:\\n    //Bellman Ford Algorithm\\n    int shortestPath(vector<vector<int>>& flights,int src,int dst,int k,int n){\\n        vector<int> dist(n,INT_MAX);\\n        dist[src] = 0;\\n        for(int count=0; count<=k; count++){\\n            vector<int> temp = dist;\\n            for(vector<int>& v: flights){\\n                if(dist[v[0]] == INT_MAX)\\n                    continue;\\n\\t\\t\\t\\t//Relax Operation\\n                if(temp[v[1]] > dist[v[0]] + v[2])\\n                    temp[v[1]] = dist[v[0]] + v[2];\\n            }\\n            dist = temp;\\n        }\\n        return (dist[dst] == INT_MAX ? -1 : dist[dst]);\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        return shortestPath(flights,src,dst,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Bellman Ford Algorithm\\n    int shortestPath(vector<vector<int>>& flights,int src,int dst,int k,int n){\\n        vector<int> dist(n,INT_MAX);\\n        dist[src] = 0;\\n        for(int count=0; count<=k; count++){\\n            vector<int> temp = dist;\\n            for(vector<int>& v: flights){\\n                if(dist[v[0]] == INT_MAX)\\n                    continue;\\n\\t\\t\\t\\t//Relax Operation\\n                if(temp[v[1]] > dist[v[0]] + v[2])\\n                    temp[v[1]] = dist[v[0]] + v[2];\\n            }\\n            dist = temp;\\n        }\\n        return (dist[dst] == INT_MAX ? -1 : dist[dst]);\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        return shortestPath(flights,src,dst,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352180,
                "title": "easy-to-understand-java-solution-dynamic-programming",
                "content": "This is the Java version of the easy dynamic programming solution from [here.](https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/686774/SUGGESTION-FOR-BEGINNERS-BFS-or-DIJKSHTRA-or-DP)  PriorityQueue based solutions now give Time limit exceeded. \\n\\n```\\n\\n public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n\\t\\t//dp[i][j] means the minimum distance to reach from src to j with atmost i edges. \\n\\t\\t//Note that, we need atmost k stops, so it means atmost k+1 edges are permitted.\\n\\t\\t//Hence array is initialized with k+2 size.\\n        int[][] dp = new int[k+2][n];\\n        \\n\\t\\t//initiallly, we assume that minimum distance to any point from the source is infinity. \\n        for(int i=0; i<=k+1; i++){\\n           for(int j=0; j<n; j++){\\n\\t\\t      //Distance from source to source is always zero, irrespective of the number of stops/edges permitted. \\n\\t\\t\\t  //Otherwise, we assume Integer.MAX_VALUE unless it is possible to reach destination. \\n               dp[i][j] = j==src?0:Integer.MAX_VALUE;\\n           } \\n        }\\n              \\n        for(int i=1; i<=k+1; i++){\\n            for(int j=0;j<flights.length;j++){           \\n                int[] flight = flights[j];         \\n                int source = flight[0];\\n                int destination = flight[1];\\n                int price = flight[2];\\n         \\n\\t\\t        //We can reach destination in atmost k stops, only if the source/previous stop can be reachable in k-1 stops. Otherwise, it is impossible to reach the destination within k stops. \\n                if(dp[i-1][source] != Integer.MAX_VALUE){\\n                    dp[i][destination]= Math.min(dp[i][destination], dp[i-1][source] + price);\\n                }                \\n            }            \\n        }\\n        \\n        return dp[k+1][dst]==Integer.MAX_VALUE?-1:dp[k+1][dst];\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n\\t\\t//dp[i][j] means the minimum distance to reach from src to j with atmost i edges. \\n\\t\\t//Note that, we need atmost k stops, so it means atmost k+1 edges are permitted.\\n\\t\\t//Hence array is initialized with k+2 size.\\n        int[][] dp = new int[k+2][n];\\n        \\n\\t\\t//initiallly, we assume that minimum distance to any point from the source is infinity. \\n        for(int i=0; i<=k+1; i++){\\n           for(int j=0; j<n; j++){\\n\\t\\t      //Distance from source to source is always zero, irrespective of the number of stops/edges permitted. \\n\\t\\t\\t  //Otherwise, we assume Integer.MAX_VALUE unless it is possible to reach destination. \\n               dp[i][j] = j==src?0:Integer.MAX_VALUE;\\n           } \\n        }\\n              \\n        for(int i=1; i<=k+1; i++){\\n            for(int j=0;j<flights.length;j++){           \\n                int[] flight = flights[j];         \\n                int source = flight[0];\\n                int destination = flight[1];\\n                int price = flight[2];\\n         \\n\\t\\t        //We can reach destination in atmost k stops, only if the source/previous stop can be reachable in k-1 stops. Otherwise, it is impossible to reach the destination within k stops. \\n                if(dp[i-1][source] != Integer.MAX_VALUE){\\n                    dp[i][destination]= Math.min(dp[i][destination], dp[i-1][source] + price);\\n                }                \\n            }            \\n        }\\n        \\n        return dp[k+1][dst]==Integer.MAX_VALUE?-1:dp[k+1][dst];\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246845,
                "title": "java-bellman-ford-algorithm",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n//         Bellman Ford\\n        \\n        int[] path = new int[n];\\n        Arrays.fill(path, Integer.MAX_VALUE);\\n        path[src] = 0;\\n        \\n        for(int i = 0; i<=k; i++){\\n            int temp[] = path.clone(); // temp array is used so that at kth iteration only node at k\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   // stops away can fill\\n            for(int j = 0; j<flights.length; j++){\\n                int u = flights[j][0];\\n                int v = flights[j][1];\\n                int wt = flights[j][2];\\n                \\n                if(path[u] != Integer.MAX_VALUE){\\n                    temp[v] = Math.min(temp[v], path[u] + wt);\\n                }\\n            }\\n            path = temp;\\n        }\\n        \\n        return path[dst] == Integer.MAX_VALUE ? -1 : path[dst];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n//         Bellman Ford\\n        \\n        int[] path = new int[n];\\n        Arrays.fill(path, Integer.MAX_VALUE);\\n        path[src] = 0;\\n        \\n        for(int i = 0; i<=k; i++){\\n            int temp[] = path.clone(); // temp array is used so that at kth iteration only node at k\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   // stops away can fill\\n            for(int j = 0; j<flights.length; j++){\\n                int u = flights[j][0];\\n                int v = flights[j][1];\\n                int wt = flights[j][2];\\n                \\n                if(path[u] != Integer.MAX_VALUE){\\n                    temp[v] = Math.min(temp[v], path[u] + wt);\\n                }\\n            }\\n            path = temp;\\n        }\\n        \\n        return path[dst] == Integer.MAX_VALUE ? -1 : path[dst];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164459,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int Solve(int src,int dst,int k,unordered_map<int,unordered_map<int,int>> &adj){\\n        if(src == dst){\\n            return 0;\\n        }\\n        if(k < 0){\\n            return INT_MAX;\\n        }\\n        \\n        if(dp[src][k] != -1){\\n            return dp[src][k];\\n        }\\n        // else go for all valid adjacent stations \\n        int ans = INT_MAX;\\n        for(auto it : adj[src]){\\n           int t = Solve(it.first,dst,k-1,adj);\\n            if(t == INT_MAX){\\n                continue;\\n            }\\n           ans = min(ans,it.second + t);\\n        }\\n        dp[src][k] = ans;\\n        return ans;\\n        \\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int,unordered_map<int,int>>adj;\\n        for(auto it : flights){\\n            adj[it[0]][it[1]]  = it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int dp[n+1][k+1];\\n        \\n        int t = Solve(src,dst,K,adj);\\n        if(t == INT_MAX){\\n            return -1;\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int Solve(int src,int dst,int k,unordered_map<int,unordered_map<int,int>> &adj){\\n        if(src == dst){\\n            return 0;\\n        }\\n        if(k < 0){\\n            return INT_MAX;\\n        }\\n        \\n        if(dp[src][k] != -1){\\n            return dp[src][k];\\n        }\\n        // else go for all valid adjacent stations \\n        int ans = INT_MAX;\\n        for(auto it : adj[src]){\\n           int t = Solve(it.first,dst,k-1,adj);\\n            if(t == INT_MAX){\\n                continue;\\n            }\\n           ans = min(ans,it.second + t);\\n        }\\n        dp[src][k] = ans;\\n        return ans;\\n        \\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int,unordered_map<int,int>>adj;\\n        for(auto it : flights){\\n            adj[it[0]][it[1]]  = it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int dp[n+1][k+1];\\n        \\n        int t = Solve(src,dst,K,adj);\\n        if(t == INT_MAX){\\n            return -1;\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790296,
                "title": "readable-python-djikstra",
                "content": "Use -k to evaluate cheapest paths with less stops first\\n\\n````\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        graph = {}\\n\\n        for u in range(n):\\n            graph[u] = []\\n\\n        for u,v,w in flights:\\n            graph[u].append((v,w))\\n\\n        heap = [(0,-K,src)]\\n\\n        while heap:\\n            (cost,i,u) = heapq.heappop(heap)\\n\\n            if u == dst:\\n                return cost\\n\\n            for v,w in graph[u]:\\n                nc = cost + w\\n\\n                if i <= 0:\\n                    heapq.heappush(heap, (nc,i+1,v))\\n\\n        return -1        \\n````",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "````\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        graph = {}\\n\\n        for u in range(n):\\n            graph[u] = []\\n\\n        for u,v,w in flights:\\n            graph[u].append((v,w))\\n\\n        heap = [(0,-K,src)]\\n\\n        while heap:\\n            (cost,i,u) = heapq.heappop(heap)\\n\\n            if u == dst:\\n                return cost\\n\\n            for v,w in graph[u]:\\n                nc = cost + w\\n\\n                if i <= 0:\\n                    heapq.heappush(heap, (nc,i+1,v))\\n\\n        return -1        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 686863,
                "title": "neat-dijkstra-java",
                "content": "```java\\nclass Solution {\\n    private final List<List<int[]>> graph = new ArrayList<>();\\n\\n    private void init(int n, int[][] flights) {\\n        for (int i = 0; i < n; i++)\\n            graph.add(new ArrayList<>());\\n        for (int[] flight : flights)\\n            graph.get(flight[0]).add(new int[]{flight[1], flight[2]});\\n    }\\n\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        init(n, flights);\\n        Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\\n        queue.offer(new int[]{src, 0, 0});\\n        while (!queue.isEmpty()) {\\n            int[] current = queue.poll();\\n            int city = current[0], distance = current[1], cost = current[2];\\n            if (city == dst)\\n                return cost;\\n            if (distance <= K) {\\n                for (int[] child : graph.get(city)) {\\n                    queue.offer(new int[]{child[0], distance + 1, cost + child[1]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    private final List<List<int[]>> graph = new ArrayList<>();\\n\\n    private void init(int n, int[][] flights) {\\n        for (int i = 0; i < n; i++)\\n            graph.add(new ArrayList<>());\\n        for (int[] flight : flights)\\n            graph.get(flight[0]).add(new int[]{flight[1], flight[2]});\\n    }\\n\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        init(n, flights);\\n        Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\\n        queue.offer(new int[]{src, 0, 0});\\n        while (!queue.isEmpty()) {\\n            int[] current = queue.poll();\\n            int city = current[0], distance = current[1], cost = current[2];\\n            if (city == dst)\\n                return cost;\\n            if (distance <= K) {\\n                for (int[] child : graph.get(city)) {\\n                    queue.offer(new int[]{child[0], distance + 1, cost + child[1]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433848,
                "title": "bellman-ford-solution",
                "content": "\\'\\'\\'\\n        similar bellman-ford, relax each edge k time to update dist to all point.\\n        each loop will use last (k-1)th time\\'s result to update new dist.\\n        difference with bellman-ford is, it is time restricted,\\n        original bellman-ford will use dist[v]=min(dist[v],dist[u] + w),but dist[u] may be updated in the same iteration.\\n        which may cause one iteration generate more than one relax.\\n        thus use copyed array to store .new result, which ensure each time relax only relax on last level array.\\n        \\'\\'\\'\\n```class Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst,k):#up to k times\\n        dist=[float(\\'inf\\')]*n#dist to dst.\\n        dist[src]=0\\n        for _ in range(k+1):\\n            new_dist=dist[:]\\n            for x,y,dis in flights:\\n                new_dist[y]=min(new_dist[y],dist[x]+dis)\\n            dist=new_dist\\n                \\n        return dist[dst] if dist[dst]!=float(\\'inf\\') else -1\\n        \\n\\t\\t",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n        similar bellman-ford, relax each edge k time to update dist to all point.\\n        each loop will use last (k-1)th time\\'s result to update new dist.\\n        difference with bellman-ford is, it is time restricted,\\n        original bellman-ford will use dist[v]=min(dist[v],dist[u] + w),but dist[u] may be updated in the same iteration.\\n        which may cause one iteration generate more than one relax.\\n        thus use copyed array to store .new result, which ensure each time relax only relax on last level array.\\n        \\'\\'\\'\\n```class Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst,k):#up to k times\\n        dist=[float(\\'inf\\')]*n#dist to dst.\\n        dist[src]=0\\n        for _ in range(k+1):\\n            new_dist=dist[:]\\n            for x,y,dis in flights:\\n                new_dist[y]=min(new_dist[y],dist[x]+dis)\\n            dist=new_dist\\n                \\n        return dist[dst] if dist[dst]!=float(\\'inf\\') else -1\\n        \\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 292696,
                "title": "java-dp-solution",
                "content": "dp[i][j] means within i flights, the min cost to city j.\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        double[][] dp = new double[K + 2][n];\\n        for (int i = 0; i < K + 2; i++) {\\n        \\tfor (int j = 0; j < n; j++) {\\n        \\t\\tdp[i][j] = 1e9;\\n        \\t}\\n        }\\n        dp[0][src] = 0;\\n        for (int i = 1; i <= K + 1; i++) {\\n        \\tdp[i][src] = 0;\\n        \\tfor (int[] flight : flights) {\\n        \\t\\tdp[i][flight[1]] = Math.min(dp[i][flight[1]], dp[i - 1][flight[0]] + flight[2]);\\n        \\t}\\n        }\\n        return dp[K + 1][dst] >= 1e9 ? -1 : (int)dp[K + 1][dst];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        double[][] dp = new double[K + 2][n];\\n        for (int i = 0; i < K + 2; i++) {\\n        \\tfor (int j = 0; j < n; j++) {\\n        \\t\\tdp[i][j] = 1e9;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 226772,
                "title": "js-beat-100-using-dp",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} flights\\n * @param {number} src\\n * @param {number} dst\\n * @param {number} K\\n * @return {number}\\n */\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n  var mn = new Array(n + 1).fill(Infinity);\\n  mn[src] = 0;\\n  for(var k = 0; k < K + 1; k++){\\n    var newmn = [].concat(mn);\\n    for(var i = 0; i < flights.length; i++){\\n      var f = flights[i], a = f[0], b = f[1], c = f[2];\\n      newmn[b] = Math.min(newmn[b], mn[a] + c);\\n    }\\n    mn = [].concat(newmn);\\n  }\\n  return mn[dst] != Infinity ? mn[dst] : -1\\n};\\n```\\nRuntime: 80 ms, faster than 100.00% of JavaScript online submissions for Cheapest Flights Within K Stops.",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} flights\\n * @param {number} src\\n * @param {number} dst\\n * @param {number} K\\n * @return {number}\\n */\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n  var mn = new Array(n + 1).fill(Infinity);\\n  mn[src] = 0;\\n  for(var k = 0; k < K + 1; k++){\\n    var newmn = [].concat(mn);\\n    for(var i = 0; i < flights.length; i++){\\n      var f = flights[i], a = f[0], b = f[1], c = f[2];\\n      newmn[b] = Math.min(newmn[b], mn[a] + c);\\n    }\\n    mn = [].concat(newmn);\\n  }\\n  return mn[dst] != Infinity ? mn[dst] : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115570,
                "title": "bfs-with-small-tweak-to-guarantee-k-stops",
                "content": "Many posts on the discussion here for this problem doesn't produce valid output for this input:\n```\n4\n[[0,1,100],[0,2,300],[0,3,500],[1,2,100],[2,3,100]]\n0\n3\n1\n```\nBecause if you simply allow the BFS to run 2 iterations (with k = 1), the distance between 0 and 3 would reduce to 300 because of this path (0->1->2->3), we shouldn't allow 2 to update 3 in the last iteration.If you write out what's in the queue and manually run it you will see what I'm saying. The trick is to only allow updates for destination in the last iteration.\n\n```\npublic class Solution\n{\n\tpublic int FindCheapestPrice(int n, int[,] flights, int src, int dst, int K) {\n\t\tvar nodes = this.InitializeGraph(flights);\n\n\t\tvar queue = new Queue<int>();\n\t\tvar cost = new Queue<int>();\n\t\tforeach (var airport in nodes.Keys) {\n\t\t\tnodes[airport].MinCost = Int32.MaxValue;\n\t\t}\n\n\t\tnodes[src].MinCost = 0;\n\t\tqueue.Enqueue(src);\n\t\tcost.Enqueue(0);\n\n\t\tint stops = 0;\n\t\twhile (queue.Count != 0) {\n\t\t\tif (stops > K) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint size = queue.Count;\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tvar currentNode = nodes[queue.Dequeue()];\n\t\t\t\tint currentCost = cost.Dequeue();\n\n\t\t\t\t// Optional: If we reach destination, we don't need to process target's neighbor\n\t\t\t\tif (currentNode.Label == dst) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach (var neighbor in currentNode.Neighbors.Keys) {\n\t\t\t\t\t// If this is the last iteration, we should only update neighbor == target\n\t\t\t\t\t// otherwise we might create other minCost that require more than k stops\n\t\t\t\t\tif (stops == K && neighbor != dst) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint nextCost = currentCost + currentNode.Neighbors[neighbor];\n\t\t\t\t\tif (nextCost < nodes[neighbor].MinCost) {\n\t\t\t\t\t\tnodes[neighbor].MinCost = nextCost;\n\t\t\t\t\t\tqueue.Enqueue(neighbor);\n\t\t\t\t\t\tcost.Enqueue(nextCost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstops++;\n\t\t}\n\n\t\tif (nodes[dst].MinCost == Int32.MaxValue) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn nodes[dst].MinCost;\n\t}\n\n\tprivate Dictionary<int, Node> InitializeGraph(int[,] flights) {\n\t\tvar nodes = new Dictionary<int, Node>();\n\t\tfor(int f = 0; f < flights.GetLength(0); f++) {\n\t\t\tvar from = flights[f,0];\n\t\t\tvar to = flights[f, 1];\n\t\t\tvar cost = flights[f, 2];\n\n\t\t\tif (!nodes.ContainsKey(from)) {\n\t\t\t\tnodes[from] = new Node(from);\n\t\t\t}\n\n\t\t\tif (!nodes.ContainsKey(to)) {\n\t\t\t\tnodes[to] = new Node(to);\n\t\t\t}\n\t\t\tnodes[from].Neighbors[to] = cost;\n\t\t}\n\n\t\treturn nodes;\n\t}\n}\n\npublic class Node\n{\n\tpublic int Label { get; set; }\n\tpublic Dictionary<int, int> Neighbors { get; }\n\tpublic int MinCost { get; set; }\n\n\tpublic Node(int label) {\n\t\tthis.Label = label;\n\t\tthis.Neighbors = new Dictionary<int, int>();\n\t}\n}\n```",
                "solutionTags": [],
                "code": "```\n4\n[[0,1,100],[0,2,300],[0,3,500],[1,2,100],[2,3,100]]\n0\n3\n1\n```\n```\npublic class Solution\n{\n\tpublic int FindCheapestPrice(int n, int[,] flights, int src, int dst, int K) {\n\t\tvar nodes = this.InitializeGraph(flights);\n\n\t\tvar queue = new Queue<int>();\n\t\tvar cost = new Queue<int>();\n\t\tforeach (var airport in nodes.Keys) {\n\t\t\tnodes[airport].MinCost = Int32.MaxValue;\n\t\t}\n\n\t\tnodes[src].MinCost = 0;\n\t\tqueue.Enqueue(src);\n\t\tcost.Enqueue(0);\n\n\t\tint stops = 0;\n\t\twhile (queue.Count != 0) {\n\t\t\tif (stops > K) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint size = queue.Count;\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tvar currentNode = nodes[queue.Dequeue()];\n\t\t\t\tint currentCost = cost.Dequeue();\n\n\t\t\t\t// Optional: If we reach destination, we don't need to process target's neighbor\n\t\t\t\tif (currentNode.Label == dst) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach (var neighbor in currentNode.Neighbors.Keys) {\n\t\t\t\t\t// If this is the last iteration, we should only update neighbor == target\n\t\t\t\t\t// otherwise we might create other minCost that require more than k stops\n\t\t\t\t\tif (stops == K && neighbor != dst) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint nextCost = currentCost + currentNode.Neighbors[neighbor];\n\t\t\t\t\tif (nextCost < nodes[neighbor].MinCost) {\n\t\t\t\t\t\tnodes[neighbor].MinCost = nextCost;\n\t\t\t\t\t\tqueue.Enqueue(neighbor);\n\t\t\t\t\t\tcost.Enqueue(nextCost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstops++;\n\t\t}\n\n\t\tif (nodes[dst].MinCost == Int32.MaxValue) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn nodes[dst].MinCost;\n\t}\n\n\tprivate Dictionary<int, Node> InitializeGraph(int[,] flights) {\n\t\tvar nodes = new Dictionary<int, Node>();\n\t\tfor(int f = 0; f < flights.GetLength(0); f++) {\n\t\t\tvar from = flights[f,0];\n\t\t\tvar to = flights[f, 1];\n\t\t\tvar cost = flights[f, 2];\n\n\t\t\tif (!nodes.ContainsKey(from)) {\n\t\t\t\tnodes[from] = new Node(from);\n\t\t\t}\n\n\t\t\tif (!nodes.ContainsKey(to)) {\n\t\t\t\tnodes[to] = new Node(to);\n\t\t\t}\n\t\t\tnodes[from].Neighbors[to] = cost;\n\t\t}\n\n\t\treturn nodes;\n\t}\n}\n\npublic class Node\n{\n\tpublic int Label { get; set; }\n\tpublic Dictionary<int, int> Neighbors { get; }\n\tpublic int MinCost { get; set; }\n\n\tpublic Node(int label) {\n\t\tthis.Label = label;\n\t\tthis.Neighbors = new Dictionary<int, int>();\n\t}\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 115500,
                "title": "adapted-dijkstra-python",
                "content": "\n> **Note: The code has been updated at 2018-2-18 17:33:41 (MST) to fix a bug pointed by @chang17 and @jray319. Thanks!**\n> Their test case should be added in. The testcases for the contest did not cover those.\n> The fix makes the solution not really a Dijkstra that it is losing some property that Dijkstra has to use a priority queue. Instead, it falls into a BFS like solution.\n> But since I effectively adapt it from Dijkstra, I decide to remain the original code in the bottom for anyone who is interested in the changes.\n\n\nThis is basically an implementation for the Dijkstra algorithm based on the description in the book \"Cracking the coding interview\", page 634. Its description is really clear.\nThe only thing that is \"adapted\" is highlighted in the code ```# this two lines are important``` below.\n\nUsing vanila Dijkstra can help us figure out the shortest weighted path from the ```src``` to ```dst```.\nBut then we lose the information of those paths that can reach ```dst``` with less stop.\nSo I record the information into the ```results``` list. Once it somehow reaches the ```dst``` from a path, we record it.\n\n```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        remain, ret, stop = [], float('inf'), 0\n        weights = [sys.maxint for i in range(n)]\n        graph = [{} for i in range(n)]\n        for s,d,w in flights:\n            graph[s][d]=w\n\n        heapq.heappush(remain, (0, src))\n        weights[src] = 0\n        while remain and stop <= K:\n            tmp, remain = remain, []\n            while tmp:\n                weight, node = heapq.heappop(tmp)\n                for tonode, toweight in graph[node].items():\n                    if weights[tonode] > weight + toweight:\n                        weights[tonode] = weight + toweight\n                        heapq.heappush(remain, (weights[tonode], tonode))    \n                    # this two lines are important\n                    if tonode == dst and weights[tonode]<ret:\n                        ret = weights[tonode]\n            stop+=1\n        return ret if ret < float('inf') else -1\n```\n\n**==========================================**\n> Below is the original code, that passed the testcases in the system but did not pass the testcase from @chang17 and @jray319\n> This adaptation and fix itself to me is a very interesting and great lesson to learn Dijkstra, maybe just because this is my first time implementing a Dijkstra.\n> hope you enjoy it too!\n\n```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        def getcount():\n            pre, count = dst, 0\n            while previous[pre] is not None:\n                count += 1\n                pre = previous[pre]\n            return count-1\n        \n        remain, results = [], []\n        graph = [{} for i in range(n)]\n        previous = [None for i in range(n)]\n        weights = [sys.maxint for i in range(n)]\n        for s,d,w in flights:\n            graph[s][d]=w\n\n        heapq.heappush(remain, (0, src))\n        weights[src] = 0\n        \n        while remain:\n            weight, node = heapq.heappop(remain)\n            for tonode, toweight in graph[node].items():\n                if weights[tonode] > weight + toweight:\n                    weights[tonode] = weight + toweight\n                    heapq.heappush(remain, (weights[tonode], tonode))\n                    previous[tonode] = node\n                if tonode == dst:\n                    heapq.heappush(results, (weights[tonode], getcount()))\n                        \n        while results:\n            w, count = heapq.heappop(results)\n            if count<=K:\n                return w        \n        return -1\n            \n```\n\nThe test cases:\nfrom @chang17,\n```\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n```\nfrom @jray319,\n```\n4\n[[0,1,1],[1,2,1],[2,3,1],[0,2,100]]\n0\n3\n1\n```",
                "solutionTags": [],
                "code": "```# this two lines are important```\n```src```\n```dst```\n```dst```\n```results```\n```dst```\n```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        remain, ret, stop = [], float('inf'), 0\n        weights = [sys.maxint for i in range(n)]\n        graph = [{} for i in range(n)]\n        for s,d,w in flights:\n            graph[s][d]=w\n\n        heapq.heappush(remain, (0, src))\n        weights[src] = 0\n        while remain and stop <= K:\n            tmp, remain = remain, []\n            while tmp:\n                weight, node = heapq.heappop(tmp)\n                for tonode, toweight in graph[node].items():\n                    if weights[tonode] > weight + toweight:\n                        weights[tonode] = weight + toweight\n                        heapq.heappush(remain, (weights[tonode], tonode))    \n                    # this two lines are important\n                    if tonode == dst and weights[tonode]<ret:\n                        ret = weights[tonode]\n            stop+=1\n        return ret if ret < float('inf') else -1\n```\n```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        def getcount():\n            pre, count = dst, 0\n            while previous[pre] is not None:\n                count += 1\n                pre = previous[pre]\n            return count-1\n        \n        remain, results = [], []\n        graph = [{} for i in range(n)]\n        previous = [None for i in range(n)]\n        weights = [sys.maxint for i in range(n)]\n        for s,d,w in flights:\n            graph[s][d]=w\n\n        heapq.heappush(remain, (0, src))\n        weights[src] = 0\n        \n        while remain:\n            weight, node = heapq.heappop(remain)\n            for tonode, toweight in graph[node].items():\n                if weights[tonode] > weight + toweight:\n                    weights[tonode] = weight + toweight\n                    heapq.heappush(remain, (weights[tonode], tonode))\n                    previous[tonode] = node\n                if tonode == dst:\n                    heapq.heappush(results, (weights[tonode], getcount()))\n                        \n        while results:\n            w, count = heapq.heappop(results)\n            if count<=K:\n                return w        \n        return -1\n            \n```\n```\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n```\n```\n4\n[[0,1,1],[1,2,1],[2,3,1],[0,2,100]]\n0\n3\n1\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100437,
                "title": "c-bfs-full-explanation-dijkstra-s-algo-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int src,int dst,int k,int n,vector<vector<int>> adj[])\\n    {\\n        queue<vector<int>> q;                       // make queue of vector for storing {node,dist,stop}\\n        q.push({src,0,0});                          // {node,dist,stop}\\n        vector<int> dis(n,INT_MAX);                 // for keep traking of minimum dist for every node\\n        dis[src]=0;                                 // src to src will be 0\\n        \\n        // BFS\\n        while(!q.empty())\\n        {\\n            int node = q.front()[0];\\n            int cost = q.front()[1];\\n            int stop = q.front()[2];\\n            q.pop();\\n            \\n            if(stop>k) continue;                     // if stop is bigger than k then just continue no need to find cost\\n            \\n            // check adjacency nodes\\n            for(auto &it : adj[node])\\n            {\\n                int nexNode = it[0];                 // nextNode\\n                int nexWeight = it[1];               // nextNode Weight\\n                \\n                // if i am having better option then took that and push it into queue with stop+1, as i used node as a stop\\n                if(cost +  nexWeight < dis[nexNode])\\n                {\\n                    dis[nexNode] = cost + nexWeight;                     // taking min cost for nexNode\\n                    q.push({nexNode, dis[nexNode],stop+1});\\n                }\\n            }\\n        }\\n        \\n        if(dis[dst]==INT_MAX) return -1;                // if I didn\\'t reached to my dst then return -1\\n        else return dis[dst];                           // return min cost for dst node from  dis\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        // Directed Graph\\n        vector<vector<int>> adj[n];\\n        for(auto &it : flights)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        \\n        // Function calling for BFS\\n        int ans = solve(src,dst,k,n,adj);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int src,int dst,int k,int n,vector<vector<int>> adj[])\\n    {\\n        queue<vector<int>> q;                       // make queue of vector for storing {node,dist,stop}\\n        q.push({src,0,0});                          // {node,dist,stop}\\n        vector<int> dis(n,INT_MAX);                 // for keep traking of minimum dist for every node\\n        dis[src]=0;                                 // src to src will be 0\\n        \\n        // BFS\\n        while(!q.empty())\\n        {\\n            int node = q.front()[0];\\n            int cost = q.front()[1];\\n            int stop = q.front()[2];\\n            q.pop();\\n            \\n            if(stop>k) continue;                     // if stop is bigger than k then just continue no need to find cost\\n            \\n            // check adjacency nodes\\n            for(auto &it : adj[node])\\n            {\\n                int nexNode = it[0];                 // nextNode\\n                int nexWeight = it[1];               // nextNode Weight\\n                \\n                // if i am having better option then took that and push it into queue with stop+1, as i used node as a stop\\n                if(cost +  nexWeight < dis[nexNode])\\n                {\\n                    dis[nexNode] = cost + nexWeight;                     // taking min cost for nexNode\\n                    q.push({nexNode, dis[nexNode],stop+1});\\n                }\\n            }\\n        }\\n        \\n        if(dis[dst]==INT_MAX) return -1;                // if I didn\\'t reached to my dst then return -1\\n        else return dis[dst];                           // return min cost for dst node from  dis\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        // Directed Graph\\n        vector<vector<int>> adj[n];\\n        for(auto &it : flights)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        \\n        // Function calling for BFS\\n        int ans = solve(src,dst,k,n,adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099981,
                "title": "java-easy-understanding-graph-shortest-path",
                "content": "# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int prev[]=new int[n];\\n        Arrays.fill(prev,Integer.MAX_VALUE);\\n        prev[src]=0;\\n        for(int i=0;i<=k;i++){\\n            int cur[]=new int[n];\\n            for(int j=0;j<n;j++) cur[j]=prev[j];\\n                for(int e[]:flights){\\n                    int u=e[0],v=e[1],wt=e[2];\\n                    if(prev[u]!=Integer.MAX_VALUE&&prev[u]+wt<cur[v]){\\n                        cur[v]=prev[u]+wt;\\n                    }\\n                }\\n            for(int j=0;j<n;j++) prev[j]=cur[j];\\n        }\\n        return prev[dst]==Integer.MAX_VALUE?-1:prev[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int prev[]=new int[n];\\n        Arrays.fill(prev,Integer.MAX_VALUE);\\n        prev[src]=0;\\n        for(int i=0;i<=k;i++){\\n            int cur[]=new int[n];\\n            for(int j=0;j<n;j++) cur[j]=prev[j];\\n                for(int e[]:flights){\\n                    int u=e[0],v=e[1],wt=e[2];\\n                    if(prev[u]!=Integer.MAX_VALUE&&prev[u]+wt<cur[v]){\\n                        cur[v]=prev[u]+wt;\\n                    }\\n                }\\n            for(int j=0;j<n;j++) prev[j]=cur[j];\\n        }\\n        return prev[dst]==Integer.MAX_VALUE?-1:prev[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099921,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/zWZLw81HSks\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} flights\\n * @param {number} src\\n * @param {number} dst\\n * @param {number} k\\n * @return {number}\\n */\\nvar findCheapestPrice = function(n, flights, src, dst, k) {\\n    let map = {}\\n\\n    for(let [x,y,z] of flights){\\n        if(!map[y]) map[y] = []\\n        map[y].push([x,y,z])\\n    }\\n\\n    let min = Infinity;\\n\\n    let iterate = (end,sum,count)=>{\\n        if(count>k || sum >min) return;\\n\\n        if(end == src){\\n            min = Math.min(min,sum)\\n            return;\\n        }\\n        if(!map[end]) return;\\n\\n        for(let [x,y,z] of map[end]){\\n            iterate(x,sum+z,count+1)\\n        }\\n    }\\n    iterate(dst,0,-1)\\n    return min == Infinity ? -1 : min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} flights\\n * @param {number} src\\n * @param {number} dst\\n * @param {number} k\\n * @return {number}\\n */\\nvar findCheapestPrice = function(n, flights, src, dst, k) {\\n    let map = {}\\n\\n    for(let [x,y,z] of flights){\\n        if(!map[y]) map[y] = []\\n        map[y].push([x,y,z])\\n    }\\n\\n    let min = Infinity;\\n\\n    let iterate = (end,sum,count)=>{\\n        if(count>k || sum >min) return;\\n\\n        if(end == src){\\n            min = Math.min(min,sum)\\n            return;\\n        }\\n        if(!map[end]) return;\\n\\n        for(let [x,y,z] of map[end]){\\n            iterate(x,sum+z,count+1)\\n        }\\n    }\\n    iterate(dst,0,-1)\\n    return min == Infinity ? -1 : min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099807,
                "title": "python-simple-modified-dijkstra",
                "content": "# Code\\n```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        G = defaultdict(list)\\n        for v, w, d in flights:\\n            G[v].append((w,d))\\n        h = [(0, 0, src)]\\n        visited = set()\\n        while h:\\n            d, curk, v = heappop(h)\\n            if v == dst: return d\\n            if (v, curk) in visited or curk > k: continue\\n            visited.add((v, curk))\\n            for w, ecost in G[v]:\\n                heappush(h, (d+ecost, curk + 1, w))\\n        return -1\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        G = defaultdict(list)\\n        for v, w, d in flights:\\n            G[v].append((w,d))\\n        h = [(0, 0, src)]\\n        visited = set()\\n        while h:\\n            d, curk, v = heappop(h)\\n            if v == dst: return d\\n            if (v, curk) in visited or curk > k: continue\\n            visited.add((v, curk))\\n            for w, ecost in G[v]:\\n                heappush(h, (d+ecost, curk + 1, w))\\n        return -1\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099788,
                "title": "c-easy-dfs-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<pair<int, int>>>& adj, vector<vector<int>>&dp, int& target, int maxFlightsAllowed, int curr)\\n    {\\n        if (curr == target) return 0;\\n        if (maxFlightsAllowed == 0) return INT_MAX;\\n        if (dp[curr][maxFlightsAllowed] != -1) return dp[curr][maxFlightsAllowed];\\n        \\n        int mnPrice = INT_MAX;\\n        for (pair<int, int>& adjNode : adj[curr])\\n        {\\n            int nextStop = adjNode.first;\\n            int flightPrice = adjNode.second;\\n            if (flightPrice == -1) continue; //already visited node\\n            \\n            adjNode.second = -1; //mark visited\\n            //====================================================================\\n            int priceToTarget = solve(adj, dp, target, maxFlightsAllowed - 1, nextStop);\\n            int totalPrice = (priceToTarget == INT_MAX)? INT_MAX : flightPrice + priceToTarget;\\n            mnPrice = min(mnPrice, totalPrice);\\n            //=======================================================================\\n            adjNode.second = flightPrice; //unmark visited\\n        }\\n        return dp[curr][maxFlightsAllowed] = mnPrice;\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        vector<vector<pair<int, int>>>adj(n);\\n        for (vector<int>&flight : flights) adj[flight[0]].push_back({flight[1], flight[2]});\\n        \\n        k++; //flightsAllowed = stopsAllowed(k) + 1\\n        vector<vector<int>>dp(n, vector<int>(k + 1, -1));\\n        int bestPrice = solve(adj, dp, dst, k, src);\\n        return (bestPrice == INT_MAX? -1 : bestPrice);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<pair<int, int>>>& adj, vector<vector<int>>&dp, int& target, int maxFlightsAllowed, int curr)\\n    {\\n        if (curr == target) return 0;\\n        if (maxFlightsAllowed == 0) return INT_MAX;\\n        if (dp[curr][maxFlightsAllowed] != -1) return dp[curr][maxFlightsAllowed];\\n        \\n        int mnPrice = INT_MAX;\\n        for (pair<int, int>& adjNode : adj[curr])\\n        {\\n            int nextStop = adjNode.first;\\n            int flightPrice = adjNode.second;\\n            if (flightPrice == -1) continue; //already visited node\\n            \\n            adjNode.second = -1; //mark visited\\n            //====================================================================\\n            int priceToTarget = solve(adj, dp, target, maxFlightsAllowed - 1, nextStop);\\n            int totalPrice = (priceToTarget == INT_MAX)? INT_MAX : flightPrice + priceToTarget;\\n            mnPrice = min(mnPrice, totalPrice);\\n            //=======================================================================\\n            adjNode.second = flightPrice; //unmark visited\\n        }\\n        return dp[curr][maxFlightsAllowed] = mnPrice;\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        vector<vector<pair<int, int>>>adj(n);\\n        for (vector<int>&flight : flights) adj[flight[0]].push_back({flight[1], flight[2]});\\n        \\n        k++; //flightsAllowed = stopsAllowed(k) + 1\\n        vector<vector<int>>dp(n, vector<int>(k + 1, -1));\\n        int bestPrice = solve(adj, dp, dst, k, src);\\n        return (bestPrice == INT_MAX? -1 : bestPrice);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671408,
                "title": "c-dijkstra-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto it: flights){\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        \\n        queue<pair<int,pair<int,int>>> q;\\n        \\n        //{stops,{node,dist}};\\n        q.push({0,{src,0}});\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int stops = it.first;\\n            int node = it.second.first;\\n            int cost = it.second.second;\\n            \\n            if(stops > k) continue;\\n            for(auto itr: adj[node]){\\n                int adjNode = itr.first;\\n                int edW = itr.second;\\n                \\n                if(cost + edW < dist[adjNode] && stops <= k)\\n                {\\n                    dist[adjNode] = cost + edW;\\n                    q.push({stops+1,{adjNode,cost + edW}});\\n                }\\n            }\\n        }\\n        \\n        if(dist[dst] == 1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto it: flights){\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        \\n        queue<pair<int,pair<int,int>>> q;\\n        \\n        //{stops,{node,dist}};\\n        q.push({0,{src,0}});\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int stops = it.first;\\n            int node = it.second.first;\\n            int cost = it.second.second;\\n            \\n            if(stops > k) continue;\\n            for(auto itr: adj[node]){\\n                int adjNode = itr.first;\\n                int edW = itr.second;\\n                \\n                if(cost + edW < dist[adjNode] && stops <= k)\\n                {\\n                    dist[adjNode] = cost + edW;\\n                    q.push({stops+1,{adjNode,cost + edW}});\\n                }\\n            }\\n        }\\n        \\n        if(dist[dst] == 1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085006,
                "title": "simple-js-solution-w-comments-dfs-dijkstra-s-bellman-ford",
                "content": "```\\n/**\\n * DFS - Memoization\\n * *Time: O(V x K)\\n * *Space: O(V x K + V^2), V x K => space by memoization\\n */\\n// Runtime: 217 ms, faster than 20.38% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 52.4 MB, less than 18.21% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  const graph = {};\\n  const memo = {};\\n\\n  for (const [x, y, price] of flights) {\\n    if (!graph[x]) graph[x] = [];\\n    graph[x].push([y, price]);\\n  }\\n\\n  const traverse = (x, stops) => {\\n    const key = `${x}-${stops}`;\\n    let min = Infinity; // min price\\n\\n    // destination reached: add cost from destination to src\\n    if (x === dst) return 0;\\n    if (stops === 0) return -1;\\n    if (!graph[x]) return -1;\\n    if (memo[key]) return memo[key];\\n\\n    for (const [y, price] of graph[x]) {\\n      const total = traverse(y, stops - 1);\\n\\n      if (total === -1) continue; // invalid route: continue\\n      min = Math.min(min, total + price); // valid route: update min cost\\n    }\\n\\n    // memoize node-stops: min price\\n    // price can change for each node based on number of stops\\n    memo[key] = min;\\n    return min !== Infinity ? min : -1;\\n  };\\n\\n  const output = traverse(src, k + 1);\\n  return output !== Infinity ? output : -1;\\n};\\n\\n/**\\n * Dijkstra\\'s Algorithm\\n * *Time: O((V + E) x log V)\\n * *Space: O(V^2)\\n */\\n// Runtime: 182 ms, faster than 28.26% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 48.7 MB, less than 50.54% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  const graph = {};\\n\\n  for (const [x, y, price] of flights) {\\n    if (!graph[x]) graph[x] = [];\\n    graph[x].push([y, price]);\\n  }\\n\\n  const dp = Array.from({ length: n }, () => Infinity);\\n  dp[src] = 0;\\n\\n  const pq = [[src, 0, k + 1]]; // x, cost, stops\\n\\n  while (pq.length) {\\n    const [x, total, stops] = pq.shift();\\n\\n    if (x === dst) continue; // continue to find cheapest path\\n    if (stops === 0) continue; // exausted number of steps\\n    if (!graph[x]) continue;\\n\\n    for (const [y, price] of graph[x]) {\\n\\t// update destination cost if cheaper\\n      if (dp[y] > total + price) {\\n        dp[y] = total + price;\\n        pq.push([y, total + price, stops - 1]);\\n      }\\n    }\\n  }\\n\\n  return dp[dst] !== Infinity ? dp[dst] : -1;\\n};\\n\\n/**\\n * Bellman-Ford\\n * K = K + 1 iterations || E = number of edges || N = number of elements\\n * *Time: O(K x E)\\n * *Space: O(N)\\n */\\n// Runtime: 92 ms, faster than 91.54% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 41.5 MB, less than 89.34% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  let dp = Array.from({ length: n + 1 }, () => Infinity);\\n  dp[src] = 0;\\n\\n  // starting from source: visiting k + 1 verticies\\n  // if possible: visit all possible path to destination\\n  for (i = 0; i < k + 1; i++) {\\n    const temp = [...dp]; // array for comparison\\n\\n    // find cheapeast price for each path\\n    for (const [x, y, price] of flights) {\\n      if (dp[x] === Infinity) continue;\\n      temp[y] = Math.min(temp[y], dp[x] + price); // get cost from src -> dst and update\\n    }\\n\\n    dp = temp;\\n  }\\n\\n  return dp[dst] !== Infinity ? dp[dst] : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * DFS - Memoization\\n * *Time: O(V x K)\\n * *Space: O(V x K + V^2), V x K => space by memoization\\n */\\n// Runtime: 217 ms, faster than 20.38% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 52.4 MB, less than 18.21% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  const graph = {};\\n  const memo = {};\\n\\n  for (const [x, y, price] of flights) {\\n    if (!graph[x]) graph[x] = [];\\n    graph[x].push([y, price]);\\n  }\\n\\n  const traverse = (x, stops) => {\\n    const key = `${x}-${stops}`;\\n    let min = Infinity; // min price\\n\\n    // destination reached: add cost from destination to src\\n    if (x === dst) return 0;\\n    if (stops === 0) return -1;\\n    if (!graph[x]) return -1;\\n    if (memo[key]) return memo[key];\\n\\n    for (const [y, price] of graph[x]) {\\n      const total = traverse(y, stops - 1);\\n\\n      if (total === -1) continue; // invalid route: continue\\n      min = Math.min(min, total + price); // valid route: update min cost\\n    }\\n\\n    // memoize node-stops: min price\\n    // price can change for each node based on number of stops\\n    memo[key] = min;\\n    return min !== Infinity ? min : -1;\\n  };\\n\\n  const output = traverse(src, k + 1);\\n  return output !== Infinity ? output : -1;\\n};\\n\\n/**\\n * Dijkstra\\'s Algorithm\\n * *Time: O((V + E) x log V)\\n * *Space: O(V^2)\\n */\\n// Runtime: 182 ms, faster than 28.26% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 48.7 MB, less than 50.54% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  const graph = {};\\n\\n  for (const [x, y, price] of flights) {\\n    if (!graph[x]) graph[x] = [];\\n    graph[x].push([y, price]);\\n  }\\n\\n  const dp = Array.from({ length: n }, () => Infinity);\\n  dp[src] = 0;\\n\\n  const pq = [[src, 0, k + 1]]; // x, cost, stops\\n\\n  while (pq.length) {\\n    const [x, total, stops] = pq.shift();\\n\\n    if (x === dst) continue; // continue to find cheapest path\\n    if (stops === 0) continue; // exausted number of steps\\n    if (!graph[x]) continue;\\n\\n    for (const [y, price] of graph[x]) {\\n\\t// update destination cost if cheaper\\n      if (dp[y] > total + price) {\\n        dp[y] = total + price;\\n        pq.push([y, total + price, stops - 1]);\\n      }\\n    }\\n  }\\n\\n  return dp[dst] !== Infinity ? dp[dst] : -1;\\n};\\n\\n/**\\n * Bellman-Ford\\n * K = K + 1 iterations || E = number of edges || N = number of elements\\n * *Time: O(K x E)\\n * *Space: O(N)\\n */\\n// Runtime: 92 ms, faster than 91.54% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 41.5 MB, less than 89.34% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  let dp = Array.from({ length: n + 1 }, () => Infinity);\\n  dp[src] = 0;\\n\\n  // starting from source: visiting k + 1 verticies\\n  // if possible: visit all possible path to destination\\n  for (i = 0; i < k + 1; i++) {\\n    const temp = [...dp]; // array for comparison\\n\\n    // find cheapeast price for each path\\n    for (const [x, y, price] of flights) {\\n      if (dp[x] === Infinity) continue;\\n      temp[y] = Math.min(temp[y], dp[x] + price); // get cost from src -> dst and update\\n    }\\n\\n    dp = temp;\\n  }\\n\\n  return dp[dst] !== Infinity ? dp[dst] : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924993,
                "title": "python-dijkstra-best-first-search-with-explaination",
                "content": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int: \\n        # construct graph\\n        graph = defaultdict(list)   # key is \\'from\\', value is \\'(to, price)\\'\\n        for from_node, to_node, price in flights:\\n            graph[from_node].append((to_node, price))\\n        \\n        # best-first search/dijkstra (allowing duplicate visit if previous visits do not meet stop requirement)\\n        heap = [(0, -1, src)]   # (cost, stop, node)\\n        min_k = defaultdict(lambda: float(\\'inf\\'))\\n        min_k[src] = 0\\n        while heap:\\n            cost, stop, node = heapq.heappop(heap)\\n            if min_k[node] < stop:  # ignore the path if less-stop path exist\\n                continue\\n            min_k[node] = stop\\n            # check if node is destination\\n            if node == dst:\\n                return cost\\n            # update neighbors\\n            for to_node, to_cost in graph[node]:\\n                if stop+1 <= k:\\n                    heapq.heappush(heap, (cost+to_cost, stop+1, to_node))\\n                    \\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int: \\n        # construct graph\\n        graph = defaultdict(list)   # key is \\'from\\', value is \\'(to, price)\\'\\n        for from_node, to_node, price in flights:\\n            graph[from_node].append((to_node, price))\\n        \\n        # best-first search/dijkstra (allowing duplicate visit if previous visits do not meet stop requirement)\\n        heap = [(0, -1, src)]   # (cost, stop, node)\\n        min_k = defaultdict(lambda: float(\\'inf\\'))\\n        min_k[src] = 0\\n        while heap:\\n            cost, stop, node = heapq.heappop(heap)\\n            if min_k[node] < stop:  # ignore the path if less-stop path exist\\n                continue\\n            min_k[node] = stop\\n            # check if node is destination\\n            if node == dst:\\n                return cost\\n            # update neighbors\\n            for to_node, to_cost in graph[node]:\\n                if stop+1 <= k:\\n                    heapq.heappush(heap, (cost+to_cost, stop+1, to_node))\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759094,
                "title": "easy-c-solution-bellman-ford-detailed-explanation",
                "content": "```\\n#define MAX_DIST 1e6 // greater than (n-1) edges * 1e4 (max price)\\n//here INT_MAX doesnt work since INT_MAX+INT_MAX would give overflow \\n//but if vector is declared with long long int, then it wont give any error\\n\\n//or simply use int for vector but put prev[src]=0 and a condition inside \\n//for loop that ensures prev[f[0]]<INT_MAX\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        if (src == dst) \\n            return 0;\\n        \\n        vector<int> curr(n, MAX_DIST);      //keeps price to reach vertices, using atmost mth edges\\n        vector<int> prev;                   //keeps price to reach vertices, using atmost m-1th edges\\n        \\n        curr[src] = 0;                      //since price taken to reach from src to src = 0\\n        \\n        k++;                                //since atmost k stops are allowed\\n        while(k--){\\n            prev.assign(curr.begin(), curr.end());          //pass by value, and not reference\\n            for(auto f: flights)\\n                curr[f[1]] = min(curr[f[1]], prev[f[0]] + f[2]);\\n        }\\n        \\n        return (curr[dst] == MAX_DIST) ? -1 : curr[dst];    //if there exists no path, i.e MAX_DIST so returning -1\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define MAX_DIST 1e6 // greater than (n-1) edges * 1e4 (max price)\\n//here INT_MAX doesnt work since INT_MAX+INT_MAX would give overflow \\n//but if vector is declared with long long int, then it wont give any error\\n\\n//or simply use int for vector but put prev[src]=0 and a condition inside \\n//for loop that ensures prev[f[0]]<INT_MAX\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        if (src == dst) \\n            return 0;\\n        \\n        vector<int> curr(n, MAX_DIST);      //keeps price to reach vertices, using atmost mth edges\\n        vector<int> prev;                   //keeps price to reach vertices, using atmost m-1th edges\\n        \\n        curr[src] = 0;                      //since price taken to reach from src to src = 0\\n        \\n        k++;                                //since atmost k stops are allowed\\n        while(k--){\\n            prev.assign(curr.begin(), curr.end());          //pass by value, and not reference\\n            for(auto f: flights)\\n                curr[f[1]] = min(curr[f[1]], prev[f[0]] + f[2]);\\n        }\\n        \\n        return (curr[dst] == MAX_DIST) ? -1 : curr[dst];    //if there exists no path, i.e MAX_DIST so returning -1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678316,
                "title": "how-to-approach-such-problems",
                "content": "1. One way to solve is exhausting all the possible cases, you can use dfs (backtracking) something like in this problem https://leetcode.com/problems/maximum-path-quality-of-a-graph/, (backtracking works in this case because it has very few edges and you will prune the irrelevant cases using the current time+next edge time crosses the time limit) and backtracking works by unvisiting the node when we are done with that.\\n2. Now coming back to this problem, we could have use backtracking here as well but since there is no such restrictions on number of edges and the number of stops can also be high, thus backtracking will not be efficient here\\n3. Now there are multiple ways to solve this problem\\n\\ti. We can use DFS here as well, but problem with using DFS here is when we visit some node there can be efficient way to come to this node with  some other route (from some other ancestor of the current path via other path), so it becomes difficult, so lets think in reverse way, how about filling the answers from down to up? (assume our destination is in down position and source is our root) now from  any intermediate node there can be multiple paths to destination with different costs but we need to find out the one which uses atmost k stops, thus we need to keep track of stops also, hence we use dp[u][stops] as the min cost for reaching destination from u using \"stops\" stops and this will be \\n```\\ndp[u][stops] = min(dist[v][stops-1]+(cost of (u,v)); // v are the children of u node\\n```\\nthus code is like\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int> > adj[101];\\n    int dest;\\n    int ans=INT_MAX;\\n    int tot_stops;\\n    bool vis[101]={0};\\n    int dp[101][101];\\n    int dfs(int u,int stops){\\n        // for a node its optimal value can come from its child\\n        if(u==dest){\\n            return 0;\\n        }\\n        if(stops<=-1)return INT_MAX;\\n        if(dp[u][stops]!=-1)return dp[u][stops];\\n        int ret_val=INT_MAX;\\n        for(auto [v,p]: adj[u]){\\n            int val = dfs(v,stops-1);\\n\\t\\t\\t// if impossible to reach the destination from v\\n            if(val!=INT_MAX)\\n            ret_val = min(ret_val, p+val);\\n        }\\n        return dp[u][stops]=ret_val;  \\n    }\\n    \\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        for(int i=0;i<n;i++){\\n            adj[i].clear();\\n            vis[i]=0;\\n            for(int j=0;j<=k;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<flights.size();i++){\\n            adj[flights[i][0]].push_back({flights[i][1],flights[i][2]});\\n        }\\n        dest=dst;\\n        tot_stops=k+1;\\n        ans = dfs(src,k);\\n        return (ans>(1e9))?-1:ans; \\n    }\\n};\\n```\\n\\nii. Dijkstra approach\\n1. Dijkstra can also work because we need to findout the shortest path from source to destination, just that we do not need to exceed the number of stops, only tricky part is , the shortest path should not exceed the number of stops, thus add a check to not put nodes if their level becomes greater than k\\n```\\nif(l>k+1)continue;\\n```\\nwhole code is\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int> > adj[101];\\n    \\n    int dijkstra(int n, int src, int dst, int k){\\n        vector<int> dist(n+1,(1e9));\\n        dist[src]=0;\\n        set<pair<pair<int,int>,int> > setds;\\n        setds.insert({{0,src},0});\\n        int ans=1e9;\\n        while(!setds.empty()){\\n            auto it=setds.begin();\\n            int d=it->first.first;\\n            int u=it->first.second;\\n            int l=it->second;\\n            setds.erase(it);\\n            if(l>k+1)continue;\\n            if(u==dst){\\n                    return d;\\n            }\\n            for(auto [v,p]:adj[u])\\n            {\\n                if(d+p<(1e9) && l<=k){\\n                    setds.insert({{d+p,v},l+1});\\n                }\\n            }\\n        }\\n        return  ans;\\n        \\n    }\\n    \\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        for(int i=0;i<flights.size();i++){\\n            adj[flights[i][0]].push_back({flights[i][1],flights[i][2]});\\n        }\\n        int ans=dijkstra(n,src,dst,k);\\n        return (ans>=(1e9))?-1:ans; \\n    }\\n}\\n```\\nthe beauty here is you will always reach at the optimal path to destination at first occurrence that is why there is a return statement in code\\n```\\nif(u==dst){\\n                    return d;\\n            }\\n```\\nThis is true because in dijkstra we always get the best path till some intermediate node and thus greedily going forward, and we already keeping check if stops exceeds the limit do not push the node in set\\n3. BFS approach there also you can keep track of level and it is similar to Dijkstra, just that answer is minimum and do not push over the stops count\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndp[u][stops] = min(dist[v][stops-1]+(cost of (u,v)); // v are the children of u node\\n```\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int> > adj[101];\\n    int dest;\\n    int ans=INT_MAX;\\n    int tot_stops;\\n    bool vis[101]={0};\\n    int dp[101][101];\\n    int dfs(int u,int stops){\\n        // for a node its optimal value can come from its child\\n        if(u==dest){\\n            return 0;\\n        }\\n        if(stops<=-1)return INT_MAX;\\n        if(dp[u][stops]!=-1)return dp[u][stops];\\n        int ret_val=INT_MAX;\\n        for(auto [v,p]: adj[u]){\\n            int val = dfs(v,stops-1);\\n\\t\\t\\t// if impossible to reach the destination from v\\n            if(val!=INT_MAX)\\n            ret_val = min(ret_val, p+val);\\n        }\\n        return dp[u][stops]=ret_val;  \\n    }\\n    \\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        for(int i=0;i<n;i++){\\n            adj[i].clear();\\n            vis[i]=0;\\n            for(int j=0;j<=k;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<flights.size();i++){\\n            adj[flights[i][0]].push_back({flights[i][1],flights[i][2]});\\n        }\\n        dest=dst;\\n        tot_stops=k+1;\\n        ans = dfs(src,k);\\n        return (ans>(1e9))?-1:ans; \\n    }\\n};\\n```\n```\\nif(l>k+1)continue;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int> > adj[101];\\n    \\n    int dijkstra(int n, int src, int dst, int k){\\n        vector<int> dist(n+1,(1e9));\\n        dist[src]=0;\\n        set<pair<pair<int,int>,int> > setds;\\n        setds.insert({{0,src},0});\\n        int ans=1e9;\\n        while(!setds.empty()){\\n            auto it=setds.begin();\\n            int d=it->first.first;\\n            int u=it->first.second;\\n            int l=it->second;\\n            setds.erase(it);\\n            if(l>k+1)continue;\\n            if(u==dst){\\n                    return d;\\n            }\\n            for(auto [v,p]:adj[u])\\n            {\\n                if(d+p<(1e9) && l<=k){\\n                    setds.insert({{d+p,v},l+1});\\n                }\\n            }\\n        }\\n        return  ans;\\n        \\n    }\\n    \\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        for(int i=0;i<flights.size();i++){\\n            adj[flights[i][0]].push_back({flights[i][1],flights[i][2]});\\n        }\\n        int ans=dijkstra(n,src,dst,k);\\n        return (ans>=(1e9))?-1:ans; \\n    }\\n}\\n```\n```\\nif(u==dst){\\n                    return d;\\n            }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229100,
                "title": "dfs-c-dp-memoization-faster-than-80-with-explanation",
                "content": "```\\n/*\\nThis is a simple dfs approach:\\n1. Create an adjacency list for graph. Here, graph[i] stores all the edges ith vertex has in form of \\n{destination, price} pair.\\n2. Since the destination is not changing the unique state of dp depends on : source, number of stops\\nTherefore we need a 2d dp array.\\n3. We pass k + 1 stops, as everytime we encounter a city, we subtract a stop. So even if we \\nencounter destination, we would have subtracted an additional stop, so + 1.\\n4. Rest is simple dfs, if we encounter a city, we explore all the flights from that city\\nIf that city is destination, we stop our function.\\n5. Memoize the solution for better runtime.\\n\\n*/\\nclass Solution {\\npublic:\\n    int helper(int src, int dest, vector<pair<int, int>> graph[], int k, int dp[100][102]) {\\n        if(k < 0)\\n            return INT_MAX; //number of stops exceeds what is max allowed\\n        if(src == dest)\\n            return 0;\\n        if(dp[src][k] != -1)\\n            return dp[src][k];\\n        int ans = INT_MAX;\\n        for(int i = 0; i < graph[src].size(); i++) {\\n            int a = helper(graph[src][i].first, dest, graph, k - 1, dp);\\n            ans = min(ans, (a == INT_MAX) ? a : a + graph[src][i].second); //if path not possible a = int_max\\n\\t\\t\\t//else currCost = a + currEdgeWeight\\n        }\\n        return dp[src][k] = ans;\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int numFlights = flights.size();\\n        vector<pair<int, int>> graph[n];\\n        int dp[100][102];\\n        memset(dp, -1, sizeof(dp));\\n        for(int i = 0; i < numFlights; i++) {\\n            graph[flights[i][0]].push_back({flights[i][1], flights[i][2]}); //adjacency list\\n        }\\n        int ans = helper(src, dst, graph, k + 1, dp);\\n        return (ans == INT_MAX) ? -1 : ans; //if path not possible return -1\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n/*\\nThis is a simple dfs approach:\\n1. Create an adjacency list for graph. Here, graph[i] stores all the edges ith vertex has in form of \\n{destination, price} pair.\\n2. Since the destination is not changing the unique state of dp depends on : source, number of stops\\nTherefore we need a 2d dp array.\\n3. We pass k + 1 stops, as everytime we encounter a city, we subtract a stop. So even if we \\nencounter destination, we would have subtracted an additional stop, so + 1.\\n4. Rest is simple dfs, if we encounter a city, we explore all the flights from that city\\nIf that city is destination, we stop our function.\\n5. Memoize the solution for better runtime.\\n\\n*/\\nclass Solution {\\npublic:\\n    int helper(int src, int dest, vector<pair<int, int>> graph[], int k, int dp[100][102]) {\\n        if(k < 0)\\n            return INT_MAX; //number of stops exceeds what is max allowed\\n        if(src == dest)\\n            return 0;\\n        if(dp[src][k] != -1)\\n            return dp[src][k];\\n        int ans = INT_MAX;\\n        for(int i = 0; i < graph[src].size(); i++) {\\n            int a = helper(graph[src][i].first, dest, graph, k - 1, dp);\\n            ans = min(ans, (a == INT_MAX) ? a : a + graph[src][i].second); //if path not possible a = int_max\\n\\t\\t\\t//else currCost = a + currEdgeWeight\\n        }\\n        return dp[src][k] = ans;\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int numFlights = flights.size();\\n        vector<pair<int, int>> graph[n];\\n        int dp[100][102];\\n        memset(dp, -1, sizeof(dp));\\n        for(int i = 0; i < numFlights; i++) {\\n            graph[flights[i][0]].push_back({flights[i][1], flights[i][2]}); //adjacency list\\n        }\\n        int ans = helper(src, dst, graph, k + 1, dp);\\n        return (ans == INT_MAX) ? -1 : ans; //if path not possible return -1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140858,
                "title": "easy-c-solution-using-dijkstra",
                "content": "```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        // Make adj matrix with src->{dst, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n        for (int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][2], flights[i][1]});\\n        }\\n        \\n        // Make priority queue based on {distance, node, Steps_remaining}\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> myq;\\n        myq.push({0, src, K+1});\\n        \\n        while (!myq.empty()) {\\n            auto temp = myq.top();\\n            myq.pop();\\n            int dist  = temp[0];\\n            int node  = temp[1];\\n            int steps = temp[2];\\n            //cout << \"Node is \" << node << \" distance is \" << dist << \" steps are \" << steps << endl;\\n            \\n             if (steps < 0 ) {\\n                // Don\\'t do anything\\n                continue;\\n            }\\n            \\n            // Check if we reached the node\\n            if (node == dst) {\\n                return dist;\\n            }\\n            \\n           \\n            \\n            //Push all the neighboring nodes in the queue\\n            for (int i = 0; i < adj[node].size(); i++) {\\n                int neigh = adj[node][i].second;\\n                int dist2 = adj[node][i].first;\\n                //cout << \"node is \" << node << \" neigh is \" << neigh <<  \" dist2 is \" << dist2 << endl;\\n                myq.push({dist2+dist, neigh, steps-1});\\n            }\\n        }\\n                         \\n        return -1;\\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        // Make adj matrix with src->{dst, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n        for (int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][2], flights[i][1]});\\n        }\\n        \\n        // Make priority queue based on {distance, node, Steps_remaining}\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> myq;\\n        myq.push({0, src, K+1});\\n        \\n        while (!myq.empty()) {\\n            auto temp = myq.top();\\n            myq.pop();\\n            int dist  = temp[0];\\n            int node  = temp[1];\\n            int steps = temp[2];\\n            //cout << \"Node is \" << node << \" distance is \" << dist << \" steps are \" << steps << endl;\\n            \\n             if (steps < 0 ) {\\n                // Don\\'t do anything\\n                continue;\\n            }\\n            \\n            // Check if we reached the node\\n            if (node == dst) {\\n                return dist;\\n            }\\n            \\n           \\n            \\n            //Push all the neighboring nodes in the queue\\n            for (int i = 0; i < adj[node].size(); i++) {\\n                int neigh = adj[node][i].second;\\n                int dist2 = adj[node][i].first;\\n                //cout << \"node is \" << node << \" neigh is \" << neigh <<  \" dist2 is \" << dist2 << endl;\\n                myq.push({dist2+dist, neigh, steps-1});\\n            }\\n        }\\n                         \\n        return -1;\\n    }\\n\\t\\'\\'\\'",
                "codeTag": "C++"
            },
            {
                "id": 846768,
                "title": "c-commented-dijkstra-s-explained-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\\n    {\\n        // creating a weighted graph\\n        vector<vector<pair<int, int>>> graph(n);\\n        \\n        for(auto i: flights)\\n        {\\n            graph[i[0]].push_back({i[1], i[2]});\\n        }\\n        \\n        // creating a min heap or a priority queue\\n        // having distance, src and nodes left(where we can stop)\\n        // priority queu will be based upon distance, the node with least distance will\\n        // come on top\\n        priority_queue < pair<int, pair<int, int> > , vector < pair <int, pair<int, int> > > , greater<pair<int, pair<int, int> > > > pq;\\n        \\n        pq.push( {0, { src, K} });\\n           \\n        // applying Dijkstra\\'s Algorithm for shortest path from single source         \\n        while(!pq.empty())\\n        {\\n          pair<int, pair<int, int> > node = pq.top();\\n          pq.pop();\\n            \\n          // if current node is destination, return cost uptill now  \\n          if(node.second.first == dst)\\n            return node.first;\\n            \\n          // if nodes that we can visit is finished, skip this node  \\n          if(node.second.second < 0)\\n              continue;\\n           \\n          // now iterate over other nodes of the current node - distance will be\\n          // distance uptill this node + dist from this node to that neighbour node\\n          // and nodes which we can visit will be on less.\\n          for(auto i: graph[node.second.first])\\n          {\\n            pq.push({(node.first + i.second),{i.first,(node.second.second-1)}});\\n          }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\\n    {\\n        // creating a weighted graph\\n        vector<vector<pair<int, int>>> graph(n);\\n        \\n        for(auto i: flights)\\n        {\\n            graph[i[0]].push_back({i[1], i[2]});\\n        }\\n        \\n        // creating a min heap or a priority queue\\n        // having distance, src and nodes left(where we can stop)\\n        // priority queu will be based upon distance, the node with least distance will\\n        // come on top\\n        priority_queue < pair<int, pair<int, int> > , vector < pair <int, pair<int, int> > > , greater<pair<int, pair<int, int> > > > pq;\\n        \\n        pq.push( {0, { src, K} });\\n           \\n        // applying Dijkstra\\'s Algorithm for shortest path from single source         \\n        while(!pq.empty())\\n        {\\n          pair<int, pair<int, int> > node = pq.top();\\n          pq.pop();\\n            \\n          // if current node is destination, return cost uptill now  \\n          if(node.second.first == dst)\\n            return node.first;\\n            \\n          // if nodes that we can visit is finished, skip this node  \\n          if(node.second.second < 0)\\n              continue;\\n           \\n          // now iterate over other nodes of the current node - distance will be\\n          // distance uptill this node + dist from this node to that neighbour node\\n          // and nodes which we can visit will be on less.\\n          for(auto i: graph[node.second.first])\\n          {\\n            pq.push({(node.first + i.second),{i.first,(node.second.second-1)}});\\n          }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762644,
                "title": "variant-of-dijkstra-algorithm",
                "content": "Two changes from Dijkstra algorithm: 1. when we relax an edge (u, v) with cost/weight w, we do not overwrite v\\'s cost. Instead, we just insert another node into the priority queue, so the original node is kept at the queue (because the old one might have shorter distance even though it has higher cost). 2. we do not relax an edge if it is beyond our limit for K stops.\\n```\\nclass Solution {\\n    using PII = pair<int, int>; // neighbor idx, path cost\\n    using TIII = tuple<int, int, int>;  // cost, idx, distance\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<PII>> graph(n, vector<PII>());\\n        for (auto& flight : flights) {\\n            graph[flight[0]].emplace_back(flight[1], flight[2]);\\n        }\\n\\n        priority_queue<TIII, vector<TIII>, greater<>> pq;\\n        pq.emplace(0, src, 0);\\n\\n        while (!pq.empty()) {\\n            auto [cost, idx, distance] = pq.top();\\n            if (idx == dst) return cost;\\n            pq.pop();\\n            for (auto [neighborIdx, pathCost] : graph[idx]) {\\n                if (distance <= K) {\\n                    pq.emplace(cost + pathCost, neighborIdx, distance + 1);\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    using PII = pair<int, int>; // neighbor idx, path cost\\n    using TIII = tuple<int, int, int>;  // cost, idx, distance\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<PII>> graph(n, vector<PII>());\\n        for (auto& flight : flights) {\\n            graph[flight[0]].emplace_back(flight[1], flight[2]);\\n        }\\n\\n        priority_queue<TIII, vector<TIII>, greater<>> pq;\\n        pq.emplace(0, src, 0);\\n\\n        while (!pq.empty()) {\\n            auto [cost, idx, distance] = pq.top();\\n            if (idx == dst) return cost;\\n            pq.pop();\\n            for (auto [neighborIdx, pathCost] : graph[idx]) {\\n                if (distance <= K) {\\n                    pq.emplace(cost + pathCost, neighborIdx, distance + 1);\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687119,
                "title": "c-bellman-ford-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<int>distance(n,1e8);\\n        distance[src] = 0;\\n        \\n        for (int i = 0; i<=K;i++)\\n            \\n        {    vector<int>temp(distance);\\n            for (auto e : flights)\\n            {\\n                \\n               \\n                int a,b,w;\\n                a = e[0];\\n                b = e[1];\\n                w = e[2];\\n                temp[b] = min(temp[b],distance[a]+w);\\n                \\n                \\n                \\n                \\n            }\\n            \\n            distance = temp;\\n            \\n            \\n        }\\n        \\n        if (distance[dst] == 1e8)\\n            return -1;\\n        return distance[dst];\\n    }\\n};\\n\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<int>distance(n,1e8);\\n        distance[src] = 0;\\n        \\n        for (int i = 0; i<=K;i++)\\n            \\n        {    vector<int>temp(distance);\\n            for (auto e : flights)\\n            {\\n                \\n               \\n                int a,b,w;\\n                a = e[0];\\n                b = e[1];\\n                w = e[2];\\n                temp[b] = min(temp[b],distance[a]+w);\\n                \\n                \\n                \\n                \\n            }\\n            \\n            distance = temp;\\n            \\n            \\n        }\\n        \\n        if (distance[dst] == 1e8)\\n            return -1;\\n        return distance[dst];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605725,
                "title": "fast-java-bellman-ford-based-solution-with-explanation",
                "content": "Bellmand Ford Algorithm: https://www.javatpoint.com/bellman-ford-algorithm\\n\\nFor K stops, we have K + 1 edges, thus we relax K + 1 times using Bellmand Ford Algorithm. Note here we have ``int[] tmpDist = Arrays.copyOf(dist, dist.length);`` together with ``if (dist[u] == Integer.MAX_VALUE) continue;``, because we want to take 1 step at a time by only visiting new nodes that are reachable from previous iteration.\\n\\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[src] = 0;\\n        for (int i = 0; i <= K; i++) {\\n            int[] tmpDist = Arrays.copyOf(dist, dist.length);\\n            for (int[] edge : flights) {\\n                int u = edge[0];\\n                if (dist[u] == Integer.MAX_VALUE) continue;\\n                int v = edge[1];\\n                int w = edge[2];\\n                tmpDist[v] = Math.min(tmpDist[v], dist[u] + w);\\n            }\\n            dist = tmpDist;\\n        }\\n        return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[src] = 0;\\n        for (int i = 0; i <= K; i++) {\\n            int[] tmpDist = Arrays.copyOf(dist, dist.length);\\n            for (int[] edge : flights) {\\n                int u = edge[0];\\n                if (dist[u] == Integer.MAX_VALUE) continue;\\n                int v = edge[1];\\n                int w = edge[2];\\n                tmpDist[v] = Math.min(tmpDist[v], dist[u] + w);\\n            }\\n            dist = tmpDist;\\n        }\\n        return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 518000,
                "title": "java-simplified-dijkstra-based-approach-with-video-explanation",
                "content": "This snippet is actually from happygirlzt\\'s youtube channel.\\nIt\\'s very clean code and she has a great explanation of the problem in her video at: https://www.youtube.com/watch?v=H8EeY58LLz0\\n\\nReposting it here, as I found it useful and I\\'m surprised that she doesn\\'t have more followers.\\n\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[][] matrix = new int[n][n];\\n        for (int[] flight: flights) {\\n            matrix[flight[0]][flight[1]] = flight[2];\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\n        pq.offer(new int[]{0, src, K + 1});\\n        \\n        \\n        while(!pq.isEmpty()) {\\n            int[] item = pq.poll();\\n            int price = item[0];\\n            int place = item[1];\\n            int kLeft = item[2];\\n            \\n            if (place == dst) {\\n                return price;\\n            }\\n            \\n            if (kLeft > 0) {\\n                for (int i = 0; i < n; i++) {\\n                    if (matrix[place][i] > 0) {\\n                        pq.offer(new int[]{price + matrix[place][i], i, kLeft - 1});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[][] matrix = new int[n][n];\\n        for (int[] flight: flights) {\\n            matrix[flight[0]][flight[1]] = flight[2];\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\n        pq.offer(new int[]{0, src, K + 1});\\n        \\n        \\n        while(!pq.isEmpty()) {\\n            int[] item = pq.poll();\\n            int price = item[0];\\n            int place = item[1];\\n            int kLeft = item[2];\\n            \\n            if (place == dst) {\\n                return price;\\n            }\\n            \\n            if (kLeft > 0) {\\n                for (int i = 0; i < n; i++) {\\n                    if (matrix[place][i] > 0) {\\n                        pq.offer(new int[]{price + matrix[place][i], i, kLeft - 1});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486697,
                "title": "c-faster-than-100-00-of-c-online-submissions-with-explanation",
                "content": "```\\n// Runtime: 4 ms, faster than 100.00% of C++ online submissions for Cheapest Flights Within K Stops.\\nclass Solution {\\npublic:\\n    /*\\n        Approach:\\n        1. Even though the problem appears to be like a good candidate for applying Dijkstra\\'s algo,\\n           it can be solved using just BFS. ( Ofcourse Dijkstra is a variant of BFS ).\\n        2. Construct the graph from the given flights.\\n        3. Perform a BFS from src to dst with the following constraint to reduce spurious computations:\\n           a. The # of hops to reach any city should not be > K + 1( we can have K stops, ( K + 1 )th is dst ) \\n           b. The new distance to current node\\'s neighbor should not be > minDist of neighbor.\\n        4. The above conditions( 3a and 3b ) reduce the boundary of the search drastically.\\n        \\n        In other words, the problem is really to find the minimum cost path of length at most ( K + 1 ) of all the paths from src -> dst.\\n        \\n        Note: The problem could be solved using DFS as well using constraints described in 3a and 3b above.\\n    \\n    */\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector< vector< pair< long, long > > > graph( n, vector< pair< long, long > >() );\\n        queue< tuple< long, long, long > > q; // dist, hops, city\\n\\n        for( auto &i : flights ) {\\n            int from, to, dist, hops;\\n            from = i[ 0 ], to = i[ 1 ], dist = i[ 2 ];\\n            \\n            graph[ from ].emplace_back( to, dist );\\n            if( from == src ) {\\n                dist = hops = 0;\\n            } else {\\n                dist = hops = INT_MAX;\\n            }\\n        }\\n\\n        q.emplace( 0, 0, src );\\n        vector< long > minDist( n, INT_MAX ); // maintain minDist of each node.\\n        minDist[ src ] = 0;\\n        while( not q.empty() ) {\\n            long currCity, currDist, currHops;\\n            tie( currDist, currHops, currCity ) = q.front(), q.pop();\\n            // cout << \"Curr: \" << currCity\\n            //      << \", currDist: \" << currDist\\n            //      << \", currHops: \" << currHops << endl;\\n            if( minDist[ currCity ] > currDist ) continue;\\n            for( auto &n : graph[ currCity ] ) {\\n                // cout << \"    : \" << n.first << \", dist: \" << n.second << endl;\\n                if( currDist + n.second > minDist[ n.first ] or currHops + 1 > K + 1 ) continue;\\n                q.emplace( currDist + n.second, currHops + 1, n.first );\\n                minDist[ n.first ] = min( minDist[ n.first ], currDist + n.second );\\n             }\\n        }\\n        \\n        return ( minDist[ dst ] == INT_MAX ) ? -1 : minDist[ dst ];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Runtime: 4 ms, faster than 100.00% of C++ online submissions for Cheapest Flights Within K Stops.\\nclass Solution {\\npublic:\\n    /*\\n        Approach:\\n        1. Even though the problem appears to be like a good candidate for applying Dijkstra\\'s algo,\\n           it can be solved using just BFS. ( Ofcourse Dijkstra is a variant of BFS ).\\n        2. Construct the graph from the given flights.\\n        3. Perform a BFS from src to dst with the following constraint to reduce spurious computations:\\n           a. The # of hops to reach any city should not be > K + 1( we can have K stops, ( K + 1 )th is dst ) \\n           b. The new distance to current node\\'s neighbor should not be > minDist of neighbor.\\n        4. The above conditions( 3a and 3b ) reduce the boundary of the search drastically.\\n        \\n        In other words, the problem is really to find the minimum cost path of length at most ( K + 1 ) of all the paths from src -> dst.\\n        \\n        Note: The problem could be solved using DFS as well using constraints described in 3a and 3b above.\\n    \\n    */\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector< vector< pair< long, long > > > graph( n, vector< pair< long, long > >() );\\n        queue< tuple< long, long, long > > q; // dist, hops, city\\n\\n        for( auto &i : flights ) {\\n            int from, to, dist, hops;\\n            from = i[ 0 ], to = i[ 1 ], dist = i[ 2 ];\\n            \\n            graph[ from ].emplace_back( to, dist );\\n            if( from == src ) {\\n                dist = hops = 0;\\n            } else {\\n                dist = hops = INT_MAX;\\n            }\\n        }\\n\\n        q.emplace( 0, 0, src );\\n        vector< long > minDist( n, INT_MAX ); // maintain minDist of each node.\\n        minDist[ src ] = 0;\\n        while( not q.empty() ) {\\n            long currCity, currDist, currHops;\\n            tie( currDist, currHops, currCity ) = q.front(), q.pop();\\n            // cout << \"Curr: \" << currCity\\n            //      << \", currDist: \" << currDist\\n            //      << \", currHops: \" << currHops << endl;\\n            if( minDist[ currCity ] > currDist ) continue;\\n            for( auto &n : graph[ currCity ] ) {\\n                // cout << \"    : \" << n.first << \", dist: \" << n.second << endl;\\n                if( currDist + n.second > minDist[ n.first ] or currHops + 1 > K + 1 ) continue;\\n                q.emplace( currDist + n.second, currHops + 1, n.first );\\n                minDist[ n.first ] = min( minDist[ n.first ], currDist + n.second );\\n             }\\n        }\\n        \\n        return ( minDist[ dst ] == INT_MAX ) ? -1 : minDist[ dst ];\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 481874,
                "title": "javascript-solution-dijkstra-algorithm",
                "content": "### The idea\\n1. Use Dijkstra algorithm (please understand it if you are not familiar)\\n2. The code is slow, due to 2 reasons:\\n\\t1. the usage of `Object` instead of `Map`, because I think `Object` looks cleaner\\n\\t2. the lack of implementation of proper `priority queue`\\n``` javascript\\nvar findCheapestPrice1 = function(n, flights, src, dst, K) {\\n\\t /**\\n     * {\\n     *  \\'FROM\\': {\\n     *          \"DST 1\" : 100,\\n     *          \"DST 2\" : 200\\n     *          }\\n     * }\\n     */\\n    let flightHash = {};\\n    for (let flight of flights) {\\n        let [from, to, price] = flight;\\n        if (flightHash[from] == null) flightHash[from] = {};\\n        flightHash[from][to] = price;\\n    }\\n\\n    // initialize\\n    // Saves the minimun price to a destination at certain stops\\n    // Use the array index to indicate stops\\n    let minPrice = {src:[0]};\\n \\n    // [price, stop, location]\\n    // price: the price to a location\\n    let pq = [[0, 0, src]];\\n\\n    while (pq.length != 0) {\\n        let [price, stop, from] = pq.shift();\\n        if (stop > K + 1 || (minPrice[from] && price > minPrice[from][stop])) continue;\\n        if (from == dst) return price;\\n        let to = flightHash[from];\\n        for (let t in to) {\\n            if (minPrice[t]==null) minPrice[t] = [];\\n            let costToNext = price + to[t];\\n            if (costToNext > minPrice[t][stop+1]) continue;\\n            minPrice[t][stop+1] = costToNext;\\n            pq.push([costToNext, stop + 1, t]);\\n        }\\n        pq.sort((a,b)=>a[0]-b[0]);\\n    }\\n\\n    return -1;\\n};\\n```\\nFor this particular question, unlike other typical dijkstra problems, the algorithm does\\'t really need to compare new cost with previous saved cost. I think the reason is:\\n1. `If (stop > K + 1) continue;` this constraint ensures that we won\\'t get a result thats very cheap but exceed stop constraints\\n 2. Because the way PQ works, we will always get the cheapest entry, thus even if we push noisy, more expensive entries into the PQ, they certainly won\\'t have the chance to be looked at \\n ```\\n var findCheapestPrice = function(n, flights, src, dst, K) {\\n    let flightHash = {};\\n    for (let flight of flights) {\\n        let [from, to, price] = flight;\\n        if (flightHash[from] == null) flightHash[from] = {};\\n        flightHash[from][to] = price;\\n    }\\n \\n    let pq = [[0, 0, src]];\\n\\n    while (pq.length != 0) {\\n        let [price, stop, from] = pq.shift();\\n        if (stop > K + 1) continue;\\n        if (from == dst) return price;\\n        let to = flightHash[from];\\n        for (let t in to) {\\n            let costToNext = price + to[t];\\n            pq.push([costToNext, stop + 1, t]);\\n        }\\n        pq.sort((a,b)=>a[0]-b[0]);\\n    }\\n\\n    return -1;\\n};\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar findCheapestPrice1 = function(n, flights, src, dst, K) {\\n\\t /**\\n     * {\\n     *  \\'FROM\\': {\\n     *          \"DST 1\" : 100,\\n     *          \"DST 2\" : 200\\n     *          }\\n     * }\\n     */\\n    let flightHash = {};\\n    for (let flight of flights) {\\n        let [from, to, price] = flight;\\n        if (flightHash[from] == null) flightHash[from] = {};\\n        flightHash[from][to] = price;\\n    }\\n\\n    // initialize\\n    // Saves the minimun price to a destination at certain stops\\n    // Use the array index to indicate stops\\n    let minPrice = {src:[0]};\\n \\n    // [price, stop, location]\\n    // price: the price to a location\\n    let pq = [[0, 0, src]];\\n\\n    while (pq.length != 0) {\\n        let [price, stop, from] = pq.shift();\\n        if (stop > K + 1 || (minPrice[from] && price > minPrice[from][stop])) continue;\\n        if (from == dst) return price;\\n        let to = flightHash[from];\\n        for (let t in to) {\\n            if (minPrice[t]==null) minPrice[t] = [];\\n            let costToNext = price + to[t];\\n            if (costToNext > minPrice[t][stop+1]) continue;\\n            minPrice[t][stop+1] = costToNext;\\n            pq.push([costToNext, stop + 1, t]);\\n        }\\n        pq.sort((a,b)=>a[0]-b[0]);\\n    }\\n\\n    return -1;\\n};\\n```\n```\\n var findCheapestPrice = function(n, flights, src, dst, K) {\\n    let flightHash = {};\\n    for (let flight of flights) {\\n        let [from, to, price] = flight;\\n        if (flightHash[from] == null) flightHash[from] = {};\\n        flightHash[from][to] = price;\\n    }\\n \\n    let pq = [[0, 0, src]];\\n\\n    while (pq.length != 0) {\\n        let [price, stop, from] = pq.shift();\\n        if (stop > K + 1) continue;\\n        if (from == dst) return price;\\n        let to = flightHash[from];\\n        for (let t in to) {\\n            let costToNext = price + to[t];\\n            pq.push([costToNext, stop + 1, t]);\\n        }\\n        pq.sort((a,b)=>a[0]-b[0]);\\n    }\\n\\n    return -1;\\n};\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 359391,
                "title": "c-straightforward-queue-map-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int, vector<pair<int, int>>> mm;\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n\\n        // city to cost\\n        queue<pair<int, int>> qu;\\n\\n        for(auto it : flights) {\\n            mm[it[0]].push_back({it[1], it[2]});\\n        }\\n\\n        qu.push({src, 0});\\n\\n        int count = 0;\\n        int res = INT_MAX;\\n        while(!qu.empty()) {\\n            if(count++ > K+1) break;\\n            int size = qu.size();\\n            for(int i = 0; i < size; i++) {\\n                pair<int, int> temp = qu.front();\\n                qu.pop();\\n                int city = temp.first;\\n                int cost = temp.second;\\n\\n                if(city == dst) {\\n                    res = min(res, cost);\\n                    continue;\\n                }\\n\\n                for(auto it : mm[city]) {\\n                    it.second += cost;\\n                    if(dist[it.first] < it.second) continue;\\n                    dist[it.first] = it.second;\\n                    qu.push({it.first, it.second});\\n                }\\n            }\\n        }\\n\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int, vector<pair<int, int>>> mm;\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n\\n        // city to cost\\n        queue<pair<int, int>> qu;\\n\\n        for(auto it : flights) {\\n            mm[it[0]].push_back({it[1], it[2]});\\n        }\\n\\n        qu.push({src, 0});\\n\\n        int count = 0;\\n        int res = INT_MAX;\\n        while(!qu.empty()) {\\n            if(count++ > K+1) break;\\n            int size = qu.size();\\n            for(int i = 0; i < size; i++) {\\n                pair<int, int> temp = qu.front();\\n                qu.pop();\\n                int city = temp.first;\\n                int cost = temp.second;\\n\\n                if(city == dst) {\\n                    res = min(res, cost);\\n                    continue;\\n                }\\n\\n                for(auto it : mm[city]) {\\n                    it.second += cost;\\n                    if(dist[it.first] < it.second) continue;\\n                    dist[it.first] = it.second;\\n                    qu.push({it.first, it.second});\\n                }\\n            }\\n        }\\n\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280711,
                "title": "golang-bfs-dfs-dijkstra",
                "content": "Distinguised with original graph traversal, here we shouldn\\'t avoid travelling on the visited node. Because the shortest path may not satisfy the stops restriction, but the longer path may do. \\n#### BFS, level-order traversal.\\n```\\nimport \"container/list\"\\n\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    ret := MAX_INT\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n    level := 0\\n    for queue.Len() != 0 && level <= K + 1 {\\n        size := queue.Len()\\n        for i := 0; i < size; i++ {\\n            e := queue.Front()\\n            queue.Remove(e)\\n            curr := e.Value.([]int)\\n            if curr[0] == dst && ret > curr[1]{ ret = curr[1] }\\n            for _, edge := range graph[curr[0]] {\\n                if tempCost := curr[1] + edge[1]; tempCost < ret {\\n                    queue.PushBack([]int{edge[0], tempCost})\\n                }\\n            } \\n        }\\n        level++\\n    }\\n    if ret == MAX_INT { return -1 } else { return ret }\\n}\\n```\\n\\n#### DFS\\n``` golang\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    ret := MAX_INT\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    DFS(src, 0, 0, graph, dst, K, &ret)\\n    if ret == MAX_INT { return -1 } else { return ret }\\n}\\n\\n\\nfunc DFS(root, dist, depth int, graph [][][]int, dst, K int, min *int) {\\n    if depth > K + 1 { return }\\n    if root == dst && dist < *min { *min = dist }\\n    for _, edge := range graph[root] {\\n        if temp := dist + edge[1]; temp < *min {\\n            DFS(edge[0], temp, depth+1, graph, dst, K, min)\\n        }\\n    }\\n}\\n```\\n\\n#### Variant of Dijkstra using min-heap\\n```\\nimport \"container/heap\"\\n\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    h := &NodeHeap{}\\n    heap.Init(h)\\n    heap.Push(h, &Node{src, 0, 0})\\n    for h.Len() != 0 {\\n        currNode := heap.Pop(h).(*Node)\\n        currId := currNode.id\\n        if currId == dst { return currNode.dist }\\n        // 2. update the neighbors and heap.\\n        if currNode.stops <= K { // !!!\\n            for _, edge := range graph[currId] {\\n                heap.Push(h, &Node{edge[0], currNode.dist + edge[1], currNode.stops + 1})\\n\\t        }\\n        }\\n    }\\n    return -1\\n}\\n\\ntype Node struct { id, dist, stops int }\\ntype NodeHeap []*Node\\n\\nfunc (h NodeHeap) Swap(i, j int) {\\n    h[i], h[j] = h[j], h[i]\\n}\\nfunc (h NodeHeap) Less(i, j int) bool { return h[i].dist < h[j].dist }\\nfunc (h NodeHeap) Len() int { return len(h) }\\nfunc (h *NodeHeap) Push(v interface{}) { *h = append(*h, v.(*Node)) }\\nfunc (h *NodeHeap) Pop() interface{} {\\n    ret := (*h)[len(*h)-1]\\n    *h = (*h)[:len(*h)-1]\\n    return ret\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport \"container/list\"\\n\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    ret := MAX_INT\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n    level := 0\\n    for queue.Len() != 0 && level <= K + 1 {\\n        size := queue.Len()\\n        for i := 0; i < size; i++ {\\n            e := queue.Front()\\n            queue.Remove(e)\\n            curr := e.Value.([]int)\\n            if curr[0] == dst && ret > curr[1]{ ret = curr[1] }\\n            for _, edge := range graph[curr[0]] {\\n                if tempCost := curr[1] + edge[1]; tempCost < ret {\\n                    queue.PushBack([]int{edge[0], tempCost})\\n                }\\n            } \\n        }\\n        level++\\n    }\\n    if ret == MAX_INT { return -1 } else { return ret }\\n}\\n```\n``` golang\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    ret := MAX_INT\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    DFS(src, 0, 0, graph, dst, K, &ret)\\n    if ret == MAX_INT { return -1 } else { return ret }\\n}\\n\\n\\nfunc DFS(root, dist, depth int, graph [][][]int, dst, K int, min *int) {\\n    if depth > K + 1 { return }\\n    if root == dst && dist < *min { *min = dist }\\n    for _, edge := range graph[root] {\\n        if temp := dist + edge[1]; temp < *min {\\n            DFS(edge[0], temp, depth+1, graph, dst, K, min)\\n        }\\n    }\\n}\\n```\n```\\nimport \"container/heap\"\\n\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    h := &NodeHeap{}\\n    heap.Init(h)\\n    heap.Push(h, &Node{src, 0, 0})\\n    for h.Len() != 0 {\\n        currNode := heap.Pop(h).(*Node)\\n        currId := currNode.id\\n        if currId == dst { return currNode.dist }\\n        // 2. update the neighbors and heap.\\n        if currNode.stops <= K { // !!!\\n            for _, edge := range graph[currId] {\\n                heap.Push(h, &Node{edge[0], currNode.dist + edge[1], currNode.stops + 1})\\n\\t        }\\n        }\\n    }\\n    return -1\\n}\\n\\ntype Node struct { id, dist, stops int }\\ntype NodeHeap []*Node\\n\\nfunc (h NodeHeap) Swap(i, j int) {\\n    h[i], h[j] = h[j], h[i]\\n}\\nfunc (h NodeHeap) Less(i, j int) bool { return h[i].dist < h[j].dist }\\nfunc (h NodeHeap) Len() int { return len(h) }\\nfunc (h *NodeHeap) Push(v interface{}) { *h = append(*h, v.(*Node)) }\\nfunc (h *NodeHeap) Pop() interface{} {\\n    ret := (*h)[len(*h)-1]\\n    *h = (*h)[:len(*h)-1]\\n    return ret\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 238116,
                "title": "python-simple-dijkstra",
                "content": "```py\\ndef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\"\"\"\\n\\t:type n: int\\n\\t:type flights: List[List[int]]\\n\\t:type src: int\\n\\t:type dst: int\\n\\t:type K: int\\n\\t:rtype: int\\n\\t\"\"\"\\n\\t# construct graph\\n\\tgraph = defaultdict(list)\\n\\tfor u, v, w in flights:\\n\\t\\tgraph[u].append((v, w))\\n\\n\\t# dist, idx, path_len\\n\\tq = [(0, src, 1)]\\n\\tmax_path_len = K + 2\\n\\twhile q:\\n\\t\\tdist, idx, path_len = heappop(q)\\n\\t\\tif path_len > max_path_len:\\n\\t\\t\\tcontinue\\n\\t\\tif idx == dst:\\n\\t\\t\\treturn dist\\n\\t\\tfor v, w in graph[idx]:\\n\\t\\t\\theappush(q, (dist+w, v, path_len+1))\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\ndef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\"\"\"\\n\\t:type n: int\\n\\t:type flights: List[List[int]]\\n\\t:type src: int\\n\\t:type dst: int\\n\\t:type K: int\\n\\t:rtype: int\\n\\t\"\"\"\\n\\t# construct graph\\n\\tgraph = defaultdict(list)\\n\\tfor u, v, w in flights:\\n\\t\\tgraph[u].append((v, w))\\n\\n\\t# dist, idx, path_len\\n\\tq = [(0, src, 1)]\\n\\tmax_path_len = K + 2\\n\\twhile q:\\n\\t\\tdist, idx, path_len = heappop(q)\\n\\t\\tif path_len > max_path_len:\\n\\t\\t\\tcontinue\\n\\t\\tif idx == dst:\\n\\t\\t\\treturn dist\\n\\t\\tfor v, w in graph[idx]:\\n\\t\\t\\theappush(q, (dist+w, v, path_len+1))\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 180314,
                "title": "dijkstra-with-modification",
                "content": "* What is Dijkstra Algorithm and where to apply\\nDijkstra Algorithm aims to solve problem in a directed/undirected & weighted (weights are bigger than 0) graph, from source to all nodes with optimal path and cost.\\n\\n* How does it work\\n1. creates a min heap with initial node (source node) with cost of 0\\n2. expand the next node in heap with smallest value, if this is a terminate node, then return value\\n3. add current node to closed, add all unclosed neighbor of this node to heap and repeat second step\\n\\nIn this problem a pure Dijkstra Algorithm (see this https://leetcode.com/problems/network-delay-time/description/ ) won\\'t apply, because we are not necessarily finding the optimal solution, but should limit with K stops. Thus instead of adding explored nodes to closed set, we check if current count is over K.\\n\\n```\\nclass Solution {\\n    \\n    /**\\n    Dijkstra shortest weighted distance\\n    */\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int[] flight : flights) {\\n            int from = flight[0];\\n            int to = flight[1];\\n            int price = flight[2];\\n            map.putIfAbsent(from, new HashMap<>());\\n            map.get(from).put(to, price);\\n        }\\n        // place, cost\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) ->  a[1] - b[1] );\\n        pq.offer(new int[]{ src, 0, 0 });\\n        while (!pq.isEmpty()) {\\n            int[] current = pq.poll();\\n            int city = current[0];\\n            int cost = current[1];\\n            int count = current[2];\\n            if (count > K + 1) continue;\\n            if (city == dst) {\\n                return cost;\\n            }\\n            if (map.containsKey(city)) {\\n                Map<Integer, Integer> nexts = map.get(city);\\n                for (int nextCity : nexts.keySet()) {\\n                    pq.offer(new int[]{ nextCity, cost + nexts.get(nextCity), count + 1 });\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    /**\\n    Dijkstra shortest weighted distance\\n    */\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int[] flight : flights) {\\n            int from = flight[0];\\n            int to = flight[1];\\n            int price = flight[2];\\n            map.putIfAbsent(from, new HashMap<>());\\n            map.get(from).put(to, price);\\n        }\\n        // place, cost\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) ->  a[1] - b[1] );\\n        pq.offer(new int[]{ src, 0, 0 });\\n        while (!pq.isEmpty()) {\\n            int[] current = pq.poll();\\n            int city = current[0];\\n            int cost = current[1];\\n            int count = current[2];\\n            if (count > K + 1) continue;\\n            if (city == dst) {\\n                return cost;\\n            }\\n            if (map.containsKey(city)) {\\n                Map<Integer, Integer> nexts = map.get(city);\\n                for (int nextCity : nexts.keySet()) {\\n                    pq.offer(new int[]{ nextCity, cost + nexts.get(nextCity), count + 1 });\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869043,
                "title": "easy-c-solution-dijkstra-with-time-complexity-e-log-v",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe could use dijkstra here but the only problem seems to be appear is extra constraint of atmost k stops.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s suppose we are at a node before the destination node.So, can now be reach to the destination node from all the nodes just before destination node if we are able to reach atleast one of the these nodes. The answer is YES, because it\\'s take only 1 stops from all such nodes. Can\\'t we think opposite that we will go from the destination node to the neighbour node which is at least distance. If any of these node is able to reach to the source first. Then, that will be our answer. **So We will traverse the graph from destination to source not from the source to destination while applying dijkstra**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO((number of edges)*log(number of nodes))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(number of nodes+ number of edges)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int, int>> adj[n];\\n        k=k+1;\\n        for(auto x: flights)\\n        {\\n            adj[x[1]].push_back({x[0], x[2]});\\n        }\\n        //{cost, {node, stops}}\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pendingNodes;\\n        vector<int> minCost(n, INT_MAX);\\n        pendingNodes.push({0, {dst, 0}});\\n        minCost[dst]=0;\\n        while(!pendingNodes.empty())\\n        {\\n            int cost=pendingNodes.top().first;\\n            int node=pendingNodes.top().second.first;\\n            int stops=pendingNodes.top().second.second;\\n            if(node==src)\\n            return cost;\\n            pendingNodes.pop();\\n            for(auto x: adj[node])\\n            {\\nif((cost+x.second)<minCost[x.first] && (stops+1)<=k)\\n{\\nminCost[x.first]=cost+x.second;\\npendingNodes.push({minCost[x.first], {x.first, stops+1}});\\n}\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int, int>> adj[n];\\n        k=k+1;\\n        for(auto x: flights)\\n        {\\n            adj[x[1]].push_back({x[0], x[2]});\\n        }\\n        //{cost, {node, stops}}\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pendingNodes;\\n        vector<int> minCost(n, INT_MAX);\\n        pendingNodes.push({0, {dst, 0}});\\n        minCost[dst]=0;\\n        while(!pendingNodes.empty())\\n        {\\n            int cost=pendingNodes.top().first;\\n            int node=pendingNodes.top().second.first;\\n            int stops=pendingNodes.top().second.second;\\n            if(node==src)\\n            return cost;\\n            pendingNodes.pop();\\n            for(auto x: adj[node])\\n            {\\nif((cost+x.second)<minCost[x.first] && (stops+1)<=k)\\n{\\nminCost[x.first]=cost+x.second;\\npendingNodes.push({minCost[x.first], {x.first, stops+1}});\\n}\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776481,
                "title": "c-simple-and-concise-easy-to-understand",
                "content": "# Approach\\n- We solve this problem using djikstra\\'s algo\\n- After implementing djikstra\\'s algo we check cost for each possible and return the minimum of all\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> dis(n, vector<int>(k + 2, 1e9));\\n        vector<vector<pair<int, int>>> adjList(n);\\n        for (const auto& flight : flights) {\\n            adjList[flight[0]].push_back({flight[1], flight[2]});\\n        }\\n\\n        dis[src][0] = 0;\\n        set<vector<int>> s;\\n        s.insert({0, src, 0});\\n\\n        while (!s.empty()) {\\n            vector<int> v = *(s.begin());\\n            s.erase(s.begin());\\n            int cost = v[0], sr = v[1], stops = v[2];\\n\\n            if (sr == dst) {\\n                return cost;\\n            }\\n\\n            if (stops <= k) {\\n                for (const auto& neighbor : adjList[sr]) {\\n                    int node = neighbor.first, c = neighbor.second;\\n                    if (dis[node][stops + 1] > cost + c) {\\n                        dis[node][stops + 1] = cost + c;\\n                        s.insert({dis[node][stops + 1], node, stops + 1});\\n                    }\\n                }\\n            }\\n        }\\n\\n        int result = 1e9;\\n        for(int i = 0; i <= k + 1; i++) {\\n            result = min(result, dis[dst][i]);\\n        }\\n        \\n        return result == 1e9 ? -1 : result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> dis(n, vector<int>(k + 2, 1e9));\\n        vector<vector<pair<int, int>>> adjList(n);\\n        for (const auto& flight : flights) {\\n            adjList[flight[0]].push_back({flight[1], flight[2]});\\n        }\\n\\n        dis[src][0] = 0;\\n        set<vector<int>> s;\\n        s.insert({0, src, 0});\\n\\n        while (!s.empty()) {\\n            vector<int> v = *(s.begin());\\n            s.erase(s.begin());\\n            int cost = v[0], sr = v[1], stops = v[2];\\n\\n            if (sr == dst) {\\n                return cost;\\n            }\\n\\n            if (stops <= k) {\\n                for (const auto& neighbor : adjList[sr]) {\\n                    int node = neighbor.first, c = neighbor.second;\\n                    if (dis[node][stops + 1] > cost + c) {\\n                        dis[node][stops + 1] = cost + c;\\n                        s.insert({dis[node][stops + 1], node, stops + 1});\\n                    }\\n                }\\n            }\\n        }\\n\\n        int result = 1e9;\\n        for(int i = 0; i <= k + 1; i++) {\\n            result = min(result, dis[dst][i]);\\n        }\\n        \\n        return result == 1e9 ? -1 : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311492,
                "title": "best-o-e-solution",
                "content": "# Approach\\nDijkstra\\'s Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(E)$$\\n\\n- Space complexity:\\n$$O(V + E)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector <pair<int, int>> adj[n];\\n        for (auto it: flights) \\n            adj[it[0]].push_back({it[1], it[2]});\\n        queue <pair<int , pair<int, int>>> q;\\n        q.push({0, {0, src}});\\n        vector <int> cost(n, 1e9);\\n        cost[src] = 0;\\n        while (!q.empty()) {\\n            int stops = q.front().first;\\n            int ct = q.front().second.first;\\n            int node = q.front().second.second;\\n            q.pop();    \\n            if (stops > k)\\n                continue;\\n            for (auto it: adj[node]) {\\n                int adjNode = it.first;\\n                int wt = it.second;\\n                if (ct + wt < cost[adjNode]) {\\n                    cost[adjNode] = ct + wt;\\n                    q.push({stops+1, {ct + wt, adjNode}});\\n                }\\n            }\\n        }\\n        if (cost[dst] == 1e9)\\n            return -1;\\n        return cost[dst];    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector <pair<int, int>> adj[n];\\n        for (auto it: flights) \\n            adj[it[0]].push_back({it[1], it[2]});\\n        queue <pair<int , pair<int, int>>> q;\\n        q.push({0, {0, src}});\\n        vector <int> cost(n, 1e9);\\n        cost[src] = 0;\\n        while (!q.empty()) {\\n            int stops = q.front().first;\\n            int ct = q.front().second.first;\\n            int node = q.front().second.second;\\n            q.pop();    \\n            if (stops > k)\\n                continue;\\n            for (auto it: adj[node]) {\\n                int adjNode = it.first;\\n                int wt = it.second;\\n                if (ct + wt < cost[adjNode]) {\\n                    cost[adjNode] = ct + wt;\\n                    q.push({stops+1, {ct + wt, adjNode}});\\n                }\\n            }\\n        }\\n        if (cost[dst] == 1e9)\\n            return -1;\\n        return cost[dst];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104523,
                "title": "java-dijkstra-commented",
                "content": "# Please Upvote \\uD83D\\uDE07\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        // map of <node (from) -> <node (to), cost of from - to>>\\n        Map<Integer, List<int[]>> adj = new HashMap<>();\\n        for (int[] f : flights) {\\n            adj.putIfAbsent(f[0], new ArrayList<>());\\n            adj.get(f[0]).add(new int[] {f[1], f[2]});\\n        }\\n\\n        // array to record minimum steps to reach a particular node\\n        int[] stops = new int[n];\\n        Arrays.fill(stops, Integer.MAX_VALUE);  // initialise with int_max\\n\\n        // min heap which will always give us least cost journey\\n        // {node, cost_from_src_node, number_of_stops_from_src_node}\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {src, 0, 0});    // starts with node 0, cost 0 and 0 steps\\n\\n        while (!pq.isEmpty()) {\\n            int[] currDetails = pq.poll();\\n            int currNode = currDetails[0];\\n            int costSoFar = currDetails[1];\\n            int stepsSoFar = currDetails[2];\\n\\n            // till the current node, if we have already encountered a path wi lesser stops\\n            // or if the number of stops exceeds the limit, we will skip\\n            if (stepsSoFar > stops[currNode] || stepsSoFar > k + 1) {\\n                continue;\\n            }\\n            // otherwise, it means that we have reached the current node with lesser number of stops\\n            // so we put the that new number of stops so far at index \\'currNode\\'\\n            stops[currNode] = stepsSoFar;\\n            if (currNode == dst) {  // if current node is our destination\\n                return costSoFar;   // return the cost incurred so far\\n            }\\n            // if we don\\'t haveany outoing edge from our current node,\\n            // means we can\\'t move further, therefore skip\\n            if (!adj.containsKey(currNode)) {\\n                continue;\\n            }\\n            // else, record all the nodes we can visit from current node\\n            for (int[] next : adj.get(currNode)) {\\n                int nextNode = next[0];\\n                // the cost till next node is current cost so far + \\n                // cost of travelling from current node to next node (edge weight)\\n                int costToNextNode = costSoFar + next[1];\\n                // push them to the heap (we take one more step so \\'steps + 1\\')\\n                pq.offer(new int[] {nextNode, costToNextNode, stepsSoFar + 1});\\n            }\\n        }\\n\\n        // if in any way, we didn\\'t reach dst, we will return -1\\n        return -1;\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n``` java []\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<int[]>> adj = new HashMap<>();\\n        for (int[] f : flights) {\\n            adj.putIfAbsent(f[0], new ArrayList<>());\\n            adj.get(f[0]).add(new int[] {f[1], f[2]});\\n        }\\n\\n        int[] stops = new int[n];\\n        Arrays.fill(stops, Integer.MAX_VALUE);  \\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {src, 0, 0});    \\n\\n        while (!pq.isEmpty()) {\\n            int[] currDetails = pq.poll();\\n            int currNode = currDetails[0];\\n            int costSoFar = currDetails[1];\\n            int stepsSoFar = currDetails[2];\\n\\n            if (stepsSoFar > stops[currNode] || stepsSoFar > k + 1) {\\n                continue;\\n            }\\n            stops[currNode] = stepsSoFar;\\n            if (currNode == dst) {  \\n                return costSoFar;   \\n            }\\n            if (!adj.containsKey(currNode)) {\\n                continue;\\n            }\\n            for (int[] next : adj.get(currNode)) {\\n                pq.offer(new int[] {next[0], costSoFar + next[1], stepsSoFar + 1});\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n---\\n\\n\\nLet $$e$$ be the number of flights and $$n$$ be number of cities in the given problem.\\n\\n### Time complexity: $$O(n + e*k *log(e*k))$$\\n\\n- Let\\'s assume any node `A` is popped out of the queue in an iteration. If the steps taken to visit `A `are more than `stops[currNode]`, we do not iterate over the neighbors of `A`. However, we will iterate over neighbors of `A` if the steps are less than `stops[A]`, which can be true `k` times. `A` can be popped the first time with `k` steps, followed by `k-1` steps, and so on until `1` step. The same argument would be valid for any other node like `A`. As a result, each edge can only be processed `k` times, resulting in $$O(e * k)$$ elements being processed.\\n- It will take the priority queue $$O(e*k *log(e*k))$$ time to push or pop $$O(e * k)$$ elements.\\n- We\\'ve added $$O(n)$$ time by using the stops array.\\n\\n\\n### Space complexity: $$O(n + e * k)$$\\n\\nWe are using the `adj` map, which requires $$O(e)$$ memory. The `stops` array would require $$O(n)$$ memory. As previously stated, the priority queue can only have $$O(e * k)$$ elements.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        // map of <node (from) -> <node (to), cost of from - to>>\\n        Map<Integer, List<int[]>> adj = new HashMap<>();\\n        for (int[] f : flights) {\\n            adj.putIfAbsent(f[0], new ArrayList<>());\\n            adj.get(f[0]).add(new int[] {f[1], f[2]});\\n        }\\n\\n        // array to record minimum steps to reach a particular node\\n        int[] stops = new int[n];\\n        Arrays.fill(stops, Integer.MAX_VALUE);  // initialise with int_max\\n\\n        // min heap which will always give us least cost journey\\n        // {node, cost_from_src_node, number_of_stops_from_src_node}\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {src, 0, 0});    // starts with node 0, cost 0 and 0 steps\\n\\n        while (!pq.isEmpty()) {\\n            int[] currDetails = pq.poll();\\n            int currNode = currDetails[0];\\n            int costSoFar = currDetails[1];\\n            int stepsSoFar = currDetails[2];\\n\\n            // till the current node, if we have already encountered a path wi lesser stops\\n            // or if the number of stops exceeds the limit, we will skip\\n            if (stepsSoFar > stops[currNode] || stepsSoFar > k + 1) {\\n                continue;\\n            }\\n            // otherwise, it means that we have reached the current node with lesser number of stops\\n            // so we put the that new number of stops so far at index \\'currNode\\'\\n            stops[currNode] = stepsSoFar;\\n            if (currNode == dst) {  // if current node is our destination\\n                return costSoFar;   // return the cost incurred so far\\n            }\\n            // if we don\\'t haveany outoing edge from our current node,\\n            // means we can\\'t move further, therefore skip\\n            if (!adj.containsKey(currNode)) {\\n                continue;\\n            }\\n            // else, record all the nodes we can visit from current node\\n            for (int[] next : adj.get(currNode)) {\\n                int nextNode = next[0];\\n                // the cost till next node is current cost so far + \\n                // cost of travelling from current node to next node (edge weight)\\n                int costToNextNode = costSoFar + next[1];\\n                // push them to the heap (we take one more step so \\'steps + 1\\')\\n                pq.offer(new int[] {nextNode, costToNextNode, stepsSoFar + 1});\\n            }\\n        }\\n\\n        // if in any way, we didn\\'t reach dst, we will return -1\\n        return -1;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<int[]>> adj = new HashMap<>();\\n        for (int[] f : flights) {\\n            adj.putIfAbsent(f[0], new ArrayList<>());\\n            adj.get(f[0]).add(new int[] {f[1], f[2]});\\n        }\\n\\n        int[] stops = new int[n];\\n        Arrays.fill(stops, Integer.MAX_VALUE);  \\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {src, 0, 0});    \\n\\n        while (!pq.isEmpty()) {\\n            int[] currDetails = pq.poll();\\n            int currNode = currDetails[0];\\n            int costSoFar = currDetails[1];\\n            int stepsSoFar = currDetails[2];\\n\\n            if (stepsSoFar > stops[currNode] || stepsSoFar > k + 1) {\\n                continue;\\n            }\\n            stops[currNode] = stepsSoFar;\\n            if (currNode == dst) {  \\n                return costSoFar;   \\n            }\\n            if (!adj.containsKey(currNode)) {\\n                continue;\\n            }\\n            for (int[] next : adj.get(currNode)) {\\n                pq.offer(new int[] {next[0], costSoFar + next[1], stepsSoFar + 1});\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102418,
                "title": "python3-95-ms-faster-than-98-82-of-python3",
                "content": "```\\ndef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph, dis = defaultdict(list), [-1 for _ in range(n)]\\n        for f, to, price in flights:\\n            graph[f].append([to, price])\\n        dis[src], q, step = 0, deque([src]), 0\\n        while q and step <= k:\\n            sz = len(q)\\n            new_dis = list(dis)\\n            for _ in range(sz):\\n                cur = q.popleft()\\n                for neighbor in graph[cur]:\\n                    if new_dis[neighbor[0]] == -1 or new_dis[neighbor[0]] > dis[cur]+neighbor[1]:\\n                        new_dis[neighbor[0]] = dis[cur] + neighbor[1]\\n                        q.append(neighbor[0])\\n            step += 1\\n            dis = new_dis\\n        return dis[dst]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph, dis = defaultdict(list), [-1 for _ in range(n)]\\n        for f, to, price in flights:\\n            graph[f].append([to, price])\\n        dis[src], q, step = 0, deque([src]), 0\\n        while q and step <= k:\\n            sz = len(q)\\n            new_dis = list(dis)\\n            for _ in range(sz):\\n                cur = q.popleft()\\n                for neighbor in graph[cur]:\\n                    if new_dis[neighbor[0]] == -1 or new_dis[neighbor[0]] > dis[cur]+neighbor[1]:\\n                        new_dis[neighbor[0]] = dis[cur] + neighbor[1]\\n                        q.append(neighbor[0])\\n            step += 1\\n            dis = new_dis\\n        return dis[dst]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3101649,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        #define ppi pair<int, int> \\n        vector<ppi> adj[n];\\n        for(auto v:flights)\\n        adj[v[0]].push_back({v[1], v[2]});\\n        queue<ppi> q;\\n        q.push({src, 0});\\n        vector<int> dist(n, 1e9);\\n        int stops=0;\\n        while(stops<=k && !q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto [u, d]=q.front();\\n                q.pop();\\n                for(auto [v, w]:adj[u])\\n                {\\n                    if(dist[v]>d+w)\\n                    {\\n                        dist[v]=d+w;\\n                        q.push({v, dist[v]});\\n                    }\\n                }\\n            }\\n            stops++;\\n        }\\n        if(dist[dst]==1e9)\\n        return -1;\\n        return dist[dst];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        #define ppi pair<int, int> \\n        vector<ppi> adj[n];\\n        for(auto v:flights)\\n        adj[v[0]].push_back({v[1], v[2]});\\n        queue<ppi> q;\\n        q.push({src, 0});\\n        vector<int> dist(n, 1e9);\\n        int stops=0;\\n        while(stops<=k && !q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto [u, d]=q.front();\\n                q.pop();\\n                for(auto [v, w]:adj[u])\\n                {\\n                    if(dist[v]>d+w)\\n                    {\\n                        dist[v]=d+w;\\n                        q.push({v, dist[v]});\\n                    }\\n                }\\n            }\\n            stops++;\\n        }\\n        if(dist[dst]==1e9)\\n        return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100504,
                "title": "java-based-on-dijkstra-edge-relaxation",
                "content": "Sharing my solution for fun. It\\'s not optimal but another solution which one can learn from and brain storm :)\\n\\n# Intuition\\nWe want to run a relxation algorithm on the edges, exactly like Dijkstra. The nuance here is that we must also account the amount of moves we have taken. If we find a vertex with a longer distance but smaller moves, we must still explore it because maybe previously we didn\\'t have enough moves to reach the destination.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n        // Build graph\\n        // node -> [[neighbor,distance]]\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for(int i = 0; i < n; i++) graph.put(i, new ArrayList<>());\\n        \\n        for(int[] flight : flights) {\\n            int u = flight[0];\\n            int v = flight[1];\\n            int w = flight[2];\\n            graph.get(u).add(new int[] {v, w});\\n        }\\n        \\n        // int[] -> [node, distance, moves] for every index\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        int[] distance = new int[n];\\n        Arrays.fill(distance, -1);\\n\\n        int[] maxMovesUpToNode = new int[n];\\n        Arrays.fill(maxMovesUpToNode, Integer.MAX_VALUE);\\n\\n        // Initial mark\\n        distance[src] = 0;\\n        pq.offer(new int[] {src, 0, 0});\\n        \\n        // Run Relaxation Algorithm\\n        while(!pq.isEmpty()) {\\n            int[] element = pq.poll();\\n            int node = element[0];\\n            int dis = element[1];\\n            int moves = element[2];\\n\\n            if(maxMovesUpToNode[node] < moves) continue;\\n            maxMovesUpToNode[node] = moves;\\n            \\n            for(int[] edge : graph.get(node)) {\\n                int neighbor = edge[0], weight = edge[1];\\n                \\n                int neighborNewDistance = weight + dis;\\n                if(distance[neighbor] == -1 || neighborNewDistance < distance[neighbor]) {\\n                    distance[neighbor] = neighborNewDistance;\\n                }\\n                // If we have moves left.\\n                if(k != moves) {\\n                    pq.offer(new int[] {neighbor, neighborNewDistance, moves + 1});\\n                }\\n            }\\n        }\\n        \\n        \\n        return distance[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n        // Build graph\\n        // node -> [[neighbor,distance]]\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for(int i = 0; i < n; i++) graph.put(i, new ArrayList<>());\\n        \\n        for(int[] flight : flights) {\\n            int u = flight[0];\\n            int v = flight[1];\\n            int w = flight[2];\\n            graph.get(u).add(new int[] {v, w});\\n        }\\n        \\n        // int[] -> [node, distance, moves] for every index\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        int[] distance = new int[n];\\n        Arrays.fill(distance, -1);\\n\\n        int[] maxMovesUpToNode = new int[n];\\n        Arrays.fill(maxMovesUpToNode, Integer.MAX_VALUE);\\n\\n        // Initial mark\\n        distance[src] = 0;\\n        pq.offer(new int[] {src, 0, 0});\\n        \\n        // Run Relaxation Algorithm\\n        while(!pq.isEmpty()) {\\n            int[] element = pq.poll();\\n            int node = element[0];\\n            int dis = element[1];\\n            int moves = element[2];\\n\\n            if(maxMovesUpToNode[node] < moves) continue;\\n            maxMovesUpToNode[node] = moves;\\n            \\n            for(int[] edge : graph.get(node)) {\\n                int neighbor = edge[0], weight = edge[1];\\n                \\n                int neighborNewDistance = weight + dis;\\n                if(distance[neighbor] == -1 || neighborNewDistance < distance[neighbor]) {\\n                    distance[neighbor] = neighborNewDistance;\\n                }\\n                // If we have moves left.\\n                if(k != moves) {\\n                    pq.offer(new int[] {neighbor, neighborNewDistance, moves + 1});\\n                }\\n            }\\n        }\\n        \\n        \\n        return distance[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988160,
                "title": "c-solution-dijkstra-s-algorithm",
                "content": "# Please Upvote If You Find It Helpful.\\n# Approach: Using Dijkstra\\'s Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\n#define pi pair<int, pair<int,int>>\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int, int>> adj[n];\\n        for(auto it : flights){\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        queue<pi> q;\\n        vector<int> dist(n, 1e9);\\n        //{stops,{node, price}}\\n        q.push({0, {src, 0}});\\n        dist[src] = 0;\\n        while(!q.empty()){\\n            int stop = q.front().first;\\n            int node = q.front().second.first, price = q.front().second.second;\\n            q.pop();\\n            if(stop > k) continue;\\n            for(auto it:adj[node]){\\n                int adjN = it.first;\\n                int Nprice = it.second;\\n                if(dist[adjN] > price + Nprice && stop<=k){\\n                    dist[adjN] = price + Nprice;\\n                    q.push({stop+1, {adjN, dist[adjN]}});\\n                }\\n            }\\n        }\\n        if(dist[dst]==1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pi pair<int, pair<int,int>>\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int, int>> adj[n];\\n        for(auto it : flights){\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        queue<pi> q;\\n        vector<int> dist(n, 1e9);\\n        //{stops,{node, price}}\\n        q.push({0, {src, 0}});\\n        dist[src] = 0;\\n        while(!q.empty()){\\n            int stop = q.front().first;\\n            int node = q.front().second.first, price = q.front().second.second;\\n            q.pop();\\n            if(stop > k) continue;\\n            for(auto it:adj[node]){\\n                int adjN = it.first;\\n                int Nprice = it.second;\\n                if(dist[adjN] > price + Nprice && stop<=k){\\n                    dist[adjN] = price + Nprice;\\n                    q.push({stop+1, {adjN, dist[adjN]}});\\n                }\\n            }\\n        }\\n        if(dist[dst]==1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590919,
                "title": "modified-djikstra-s-prioritize-stops-before-the-cost-in-the-priority-queue",
                "content": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        \\n        maxHops = k+1\\n        \\n        graph = defaultdict(list)\\n        \\n        for (u,v,w) in flights:\\n            graph[u].append((v,w))\\n            \\n        \\n        cost = [float(\\'inf\\')]*n \\n        \\n        cost[src] = 0\\n        \\n        # here no. of stops is the first value used to sort ahead of the cost\\n        # This ensure we explore the shorter routes first!\\n        heap = [( 0, cost[src] ,src)]\\n        \\n        while heap:\\n            curStops, curCost, curNode = heappop(heap)\\n            \\n            for nbr,w in graph[curNode]:\\n                \\n                nextStops = curStops + 1\\n                nextCost = curCost + w\\n                \\n                # Don\\'t add to pq if the stops crosses the limit\\n                if nextCost < cost[nbr] and nextStops <= k+1:\\n                    cost[nbr] = nextCost\\n                    heappush(heap, ( nextStops, nextCost, nbr ))\\n            \\n    \\n        if cost[dst] != float(\\'inf\\'):\\n            return cost[dst]\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        \\n        maxHops = k+1\\n        \\n        graph = defaultdict(list)\\n        \\n        for (u,v,w) in flights:\\n            graph[u].append((v,w))\\n            \\n        \\n        cost = [float(\\'inf\\')]*n \\n        \\n        cost[src] = 0\\n        \\n        # here no. of stops is the first value used to sort ahead of the cost\\n        # This ensure we explore the shorter routes first!\\n        heap = [( 0, cost[src] ,src)]\\n        \\n        while heap:\\n            curStops, curCost, curNode = heappop(heap)\\n            \\n            for nbr,w in graph[curNode]:\\n                \\n                nextStops = curStops + 1\\n                nextCost = curCost + w\\n                \\n                # Don\\'t add to pq if the stops crosses the limit\\n                if nextCost < cost[nbr] and nextStops <= k+1:\\n                    cost[nbr] = nextCost\\n                    heappush(heap, ( nextStops, nextCost, nbr ))\\n            \\n    \\n        if cost[dst] != float(\\'inf\\'):\\n            return cost[dst]\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489340,
                "title": "c-priority-queue-bfs-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto x:flights)\\n        {\\n            adj[x[0]].push_back({x[1],x[2]});\\n        }\\n        priority_queue< vector<int> ,vector<vector<int>>,greater<vector<int>>> pq;\\n        vector<int> stops(n,INT_MAX);\\n        pq.push({0,src,0});\\n        while(pq.size()!=0)\\n        {\\n            vector<int> v=pq.top();\\n            pq.pop();\\n            int current_stops=v[2],node=v[1],cost=v[0];\\n            if(node==dst)\\n                return cost;                               \\n            /* case1->if we have previously reached this node with \\n            less stops then no need to traverse this again with more stops\\n             case2-> if we have crossed the limit of maximum possible stops in both the cases we are\\n             not traversing further*/\\n            if(stops[node]<current_stops || current_stops>k)\\n                continue;\\n            stops[node]=current_stops;\\n            for(auto x:adj[node])\\n            {\\n                pq.push({cost+x.second,x.first,current_stops+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto x:flights)\\n        {\\n            adj[x[0]].push_back({x[1],x[2]});\\n        }\\n        priority_queue< vector<int> ,vector<vector<int>>,greater<vector<int>>> pq;\\n        vector<int> stops(n,INT_MAX);\\n        pq.push({0,src,0});\\n        while(pq.size()!=0)\\n        {\\n            vector<int> v=pq.top();\\n            pq.pop();\\n            int current_stops=v[2],node=v[1],cost=v[0];\\n            if(node==dst)\\n                return cost;                               \\n            /* case1->if we have previously reached this node with \\n            less stops then no need to traverse this again with more stops\\n             case2-> if we have crossed the limit of maximum possible stops in both the cases we are\\n             not traversing further*/\\n            if(stops[node]<current_stops || current_stops>k)\\n                continue;\\n            stops[node]=current_stops;\\n            for(auto x:adj[node])\\n            {\\n                pq.push({cost+x.second,x.first,current_stops+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386606,
                "title": "c-python-min-heap-dijkstra-algorithm",
                "content": "**C++ Code**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t#define f first\\n\\t\\t#define s second\\n\\t\\tint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k){\\n\\t\\t\\tpriority_queue< array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;\\n\\t\\t\\tunordered_map<int, vector<pair<int,int>>> g;\\n\\n\\t\\t\\tfor(auto& f : flights){\\n\\t\\t\\t\\tg[f[0]].push_back({f[1],f[2]});\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> dis(n,INT_MAX);\\n\\t\\t\\tpq.push({0,src,0});\\n\\t\\t\\twhile(!pq.empty()){\\n\\t\\t\\t\\tint c = pq.top()[0];            \\n\\t\\t\\t\\tint cur = pq.top()[1];\\n\\t\\t\\t\\tint lvl = pq.top()[2]; \\n\\t\\t\\t\\tpq.pop();  \\n\\t\\t\\t\\tif(cur==dst) return c;\\n\\t\\t\\t\\tif(lvl > k || lvl >= dis[cur]) continue;\\n\\t\\t\\t\\tdis[cur] = lvl;\\n\\t\\t\\t\\tfor(auto& nei : g[cur]){\\n\\t\\t\\t\\t\\tpq.push({c+nei.s, nei.f, lvl+1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\n**Python Code**\\n\\n\\tclass Solution:\\n\\t\\tdef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tfor u,v,w in flights: graph[u].append((v,w))\\n\\n\\t\\t\\tpq = [(0,src,0)]\\n\\t\\t\\tdis = [float(\\'inf\\')]*n\\n\\n\\t\\t\\twhile pq:\\n\\t\\t\\t\\tc,n,l = heappop(pq)\\n\\t\\t\\t\\tif n==dst: return c\\n\\t\\t\\t\\tif l > k or l>= dis[n]: continue\\n\\t\\t\\t\\tdis[n] = l\\n\\t\\t\\t\\tfor v,w in graph[n]:\\n\\t\\t\\t\\t\\theappush(pq,(c+w,v,l+1))\\n\\t\\t\\treturn -1\\n\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t#define f first\\n\\t\\t#define s second\\n\\t\\tint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k){\\n\\t\\t\\tpriority_queue< array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;\\n\\t\\t\\tunordered_map<int, vector<pair<int,int>>> g;\\n\\n\\t\\t\\tfor(auto& f : flights){\\n\\t\\t\\t\\tg[f[0]].push_back({f[1],f[2]}",
                "codeTag": "Java"
            },
            {
                "id": 2332195,
                "title": "java-bellman-ford-with-k-stops-using-2-arrays-5-ms",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[]dist = new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[src] = 0;\\n        \\n        for(int i=1;i<=k+1;i++){\\n            int []dp1 = dist.clone();\\n            for(int []flight : flights){\\n                int u = flight[0];\\n                int v = flight[1];\\n                int uv = flight[2];\\n                \\n                if(dist[u] != Integer.MAX_VALUE){\\n                    dp1[v] = Math.min(dp1[v],dist[u] + uv);\\n                }\\n            }\\n            dist = dp1;\\n        }\\n        \\n        if(dist[dst] == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return dist[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[]dist = new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[src] = 0;\\n        \\n        for(int i=1;i<=k+1;i++){\\n            int []dp1 = dist.clone();\\n            for(int []flight : flights){\\n                int u = flight[0];\\n                int v = flight[1];\\n                int uv = flight[2];\\n                \\n                if(dist[u] != Integer.MAX_VALUE){\\n                    dp1[v] = Math.min(dp1[v],dist[u] + uv);\\n                }\\n            }\\n            dist = dp1;\\n        }\\n        \\n        if(dist[dst] == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return dist[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827190,
                "title": "java-dfs-dp-clean-code",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int graph[][] = new int[n][n];\\n        \\n        //creating matrix that represents grpah\\n        //graph[i][j] = price to travel from i to j\\n        for (int i = 0; i < flights.length; i++) {\\n            graph[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        \\n        //find cheapest price with k stops(k + 1 flights)\\n        int ans = findCheapestPrice(src, dst, graph, k + 1, new int[n + 1][n + 1][k + 2]);\\n        \\n        return ans >= 1000000 ? -1 : ans;\\n    }\\n    \\n    /*\\n        finds cheapest price with k flights from src to dst \\n\\t\\tO(N * N * K)\\n    */\\n    int findCheapestPrice(int src, int dst, int graph[][], int k, int dp[][][]) {\\n        \\n        //reached to destination\\n        if (dst == src) {\\n            return 0;\\n        }\\n        \\n        //no more flights left\\n        if (k == 0) {\\n            return 1000000;\\n        }\\n        \\n        //already calculated then return\\n        if (dp[src][dst][k] != 0) {\\n            return dp[src][dst][k];\\n        }\\n        \\n        \\n        //initializing min to some greater number\\n        //for each possible edge from src in graph traverse and caluculate distance\\n        //keep  minimum distance \\n        int min = 1000000;\\n        for (int i = 0; i < graph[src].length; i++) {\\n            if (graph[src][i] != 0) {\\n                min = Math.min(min, graph[src][i] + findCheapestPrice(i, dst, graph, k - 1, dp));\\n            }\\n        }\\n        \\n        return dp[src][dst][k] = min; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int graph[][] = new int[n][n];\\n        \\n        //creating matrix that represents grpah\\n        //graph[i][j] = price to travel from i to j\\n        for (int i = 0; i < flights.length; i++) {\\n            graph[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        \\n        //find cheapest price with k stops(k + 1 flights)\\n        int ans = findCheapestPrice(src, dst, graph, k + 1, new int[n + 1][n + 1][k + 2]);\\n        \\n        return ans >= 1000000 ? -1 : ans;\\n    }\\n    \\n    /*\\n        finds cheapest price with k flights from src to dst \\n\\t\\tO(N * N * K)\\n    */\\n    int findCheapestPrice(int src, int dst, int graph[][], int k, int dp[][][]) {\\n        \\n        //reached to destination\\n        if (dst == src) {\\n            return 0;\\n        }\\n        \\n        //no more flights left\\n        if (k == 0) {\\n            return 1000000;\\n        }\\n        \\n        //already calculated then return\\n        if (dp[src][dst][k] != 0) {\\n            return dp[src][dst][k];\\n        }\\n        \\n        \\n        //initializing min to some greater number\\n        //for each possible edge from src in graph traverse and caluculate distance\\n        //keep  minimum distance \\n        int min = 1000000;\\n        for (int i = 0; i < graph[src].length; i++) {\\n            if (graph[src][i] != 0) {\\n                min = Math.min(min, graph[src][i] + findCheapestPrice(i, dst, graph, k - 1, dp));\\n            }\\n        }\\n        \\n        return dp[src][dst][k] = min; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738709,
                "title": "c-solutions-with-explanation",
                "content": "# 1. Brief explanation to relaxatioin\\n![image](https://assets.leetcode.com/users/images/ec432558-bacf-44c2-a0bf-717ff557c03f_1643783358.1116207.jpeg)\\nFor example, if we see a flight from city *i* to city *j* with price *p*, then the new minimal distance from source to *j* could be updated as shown in the formula below.\\n<img src=\"http://latex.codecogs.com/svg.image?dist[j] = min(dist[j], dist[i]+p)\" title=\"form1\" />\\n\\nThis is called relaxation in graph theory.\\n\\n\\n# 2. Suboptimal solution\\nThis problem requires the solution to be within *k* stops, meaning that the path we find can not exceed *k+1* edges.\\nIt means that while solving this problem, we might have to check some intermediate solutions that are not optimal.\\n\\nTaking the image below, for example, assuming that the source city is 0 and destination city is 3;\\nWhen *k* equals 1, we might be stuck at city 2 whose optimal (minimal) distance is 2 with the number of stops as 2 if we do not consider the intermediate solution where the distance from the source is 5 with the number of stops as 1.\\n![image](https://assets.leetcode.com/users/images/10cb4ad0-16ae-46ea-ad99-545c36940349_1643784894.322046.jpeg)\\n\\n\\n# 3. Bellman-Ford\\nIn each iteration, we go through every edge in the vector *flights*.\\nIn the other words, each iteration we are computing the smallest distance from each city to source city within *(number of iterations - 1)* stops.\\n\\nNote that we could not update to the same distance vector or we may update a distance to a city multiple times in one iteration. (e.g. city *a* updates city *b*, and city *b* updates city *c* right after.)I\\n```\\n#define MAX_DIST 1e6 // greater than (n-1) edges * 1e4 (max price)\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<int> dist(n, MAX_DIST);\\n        vector<int> old_dist;\\n        \\n        dist[src] = 0;\\n        \\n        k++; // k stops -> k+1 iterations\\n        while(k--){\\n            old_dist.assign(dist.begin(), dist.end());\\n            for(auto& f: flights){\\n                dist[f[1]] = min(dist[f[1]], old_dist[f[0]] + f[2]);\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst];\\n    }\\n};\\n```\\n\\n# 4. Breadth-First Search\\nFirst of all, I prepare an adjacent list *adj*, where *adj[i]* is a unordered_map mapping the indices of cities where we can fly from city i to their respective prices of flights.\\n\\nThen we perform a breadth-first search starting from the source city.\\nFor each iteration, we are checking a set of cities that are *(number of iterations)* away from the source city.\\n```\\n#define MAX_DIST 1e6\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n\\t    // adjacent list\\n        vector<unordered_map<int, int>> adj(n); // src: to->weight\\n        for(auto& f: flights)\\n            adj[f[0]][f[1]] = f[2];\\n\\n        vector<int> dist(n, MAX_DIST);\\n        \\n        queue<vector<int>> q;\\n        q.push({src, 0});\\n        \\n        k++;\\n        while(k--){\\n            int q_size = q.size();\\n            while(q_size--){\\n                auto x = q.front(); q.pop();\\n                int cur_idx = x[0];\\n                int cur_dist = x[1];\\n                \\n                for(auto p: adj[cur_idx]){\\n                    int new_dist = p.second + cur_dist;\\n                    if(new_dist < dist[p.first]){\\n                        q.push({p.first, new_dist});\\n                        dist[p.first] = new_dist;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst]; \\n    }\\n};\\n```\\n\\n# 5. Dijkstra\\nMy implementation with Dijkastra is basically the same as the code in the solution.\\nApart from that I move the line ```stop[new_idx] = new_stop;``` into the if scope doing relaxation.\\n\\nThe problem with the Dijkstra solution is that it will always go for the solution with the smallest distance regardless of the number of stops.\\nTherefore, I add a vector named *stop* recording the *number of stops* with the smallest distance for any city.\\nWhen there is an intermediate solution with a greater distance and a smaller *number of stops*, we will have to push it into priority_queue and check for possible better solutions for other cities.\\n```\\n#define MAX_DIST 1e6\\n#define vi vector<int>\\n\\nclass Solution {\\nprivate:\\n    class cmp {\\n    public:\\n        size_t operator()(const vi& v1, const vi& v2) const{ // {index, distance, stops}\\n            return v1[1] > v2[1]; // vector with smallest distance pop first\\n        }\\n    };\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // adjacent list\\n        vector<unordered_map<int, int>> adj(n);\\n        for(auto f: flights)\\n            adj[f[0]][f[1]] = f[2];\\n        \\n        // dist vector\\n        vector<int> dist(n, MAX_DIST);\\n        \\n        // stop vector\\n        vector<int> stop(n, n);\\n        \\n        // priority queue for dijkstra\\n        priority_queue<vi, vector<vi>, cmp> pq;\\n        pq.push({src, 0, 0}); // src with 0 dist, 0 stops\\n        dist[src] = 0;\\n        stop[src] = 0;\\n        \\n        // dijkstra\\n        while(!pq.empty()){\\n            vi cur = pq.top(); pq.pop(); // pop smallest distance\\n            \\n            int cur_idx = cur[0];\\n            int cur_dist = cur[1];\\n            int cur_stop = cur[2];\\n\\n            if(cur_idx == dst)\\n                return cur_dist;\\n            \\n            if(cur_stop == k + 1)\\n                continue;\\n\\n            for(auto& p: adj[cur_idx]){\\n                int new_idx = p.first;\\n                int new_dist = cur_dist + p.second;\\n                int new_stop = cur_stop + 1;\\n                \\n                if(new_dist < dist[new_idx]){ // relaxation\\n                    dist[new_idx] = new_dist;\\n                    pq.push({new_idx, new_dist, new_stop});\\n                    stop[new_idx] = new_stop;\\n                }\\n                else if(new_stop < stop[new_idx]){\\n                    pq.push({new_idx, new_dist, new_stop});\\n                }\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define MAX_DIST 1e6 // greater than (n-1) edges * 1e4 (max price)\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<int> dist(n, MAX_DIST);\\n        vector<int> old_dist;\\n        \\n        dist[src] = 0;\\n        \\n        k++; // k stops -> k+1 iterations\\n        while(k--){\\n            old_dist.assign(dist.begin(), dist.end());\\n            for(auto& f: flights){\\n                dist[f[1]] = min(dist[f[1]], old_dist[f[0]] + f[2]);\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst];\\n    }\\n};\\n```\n```\\n#define MAX_DIST 1e6\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n\\t    // adjacent list\\n        vector<unordered_map<int, int>> adj(n); // src: to->weight\\n        for(auto& f: flights)\\n            adj[f[0]][f[1]] = f[2];\\n\\n        vector<int> dist(n, MAX_DIST);\\n        \\n        queue<vector<int>> q;\\n        q.push({src, 0});\\n        \\n        k++;\\n        while(k--){\\n            int q_size = q.size();\\n            while(q_size--){\\n                auto x = q.front(); q.pop();\\n                int cur_idx = x[0];\\n                int cur_dist = x[1];\\n                \\n                for(auto p: adj[cur_idx]){\\n                    int new_dist = p.second + cur_dist;\\n                    if(new_dist < dist[p.first]){\\n                        q.push({p.first, new_dist});\\n                        dist[p.first] = new_dist;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst]; \\n    }\\n};\\n```\n```stop[new_idx] = new_stop;```\n```\\n#define MAX_DIST 1e6\\n#define vi vector<int>\\n\\nclass Solution {\\nprivate:\\n    class cmp {\\n    public:\\n        size_t operator()(const vi& v1, const vi& v2) const{ // {index, distance, stops}\\n            return v1[1] > v2[1]; // vector with smallest distance pop first\\n        }\\n    };\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // adjacent list\\n        vector<unordered_map<int, int>> adj(n);\\n        for(auto f: flights)\\n            adj[f[0]][f[1]] = f[2];\\n        \\n        // dist vector\\n        vector<int> dist(n, MAX_DIST);\\n        \\n        // stop vector\\n        vector<int> stop(n, n);\\n        \\n        // priority queue for dijkstra\\n        priority_queue<vi, vector<vi>, cmp> pq;\\n        pq.push({src, 0, 0}); // src with 0 dist, 0 stops\\n        dist[src] = 0;\\n        stop[src] = 0;\\n        \\n        // dijkstra\\n        while(!pq.empty()){\\n            vi cur = pq.top(); pq.pop(); // pop smallest distance\\n            \\n            int cur_idx = cur[0];\\n            int cur_dist = cur[1];\\n            int cur_stop = cur[2];\\n\\n            if(cur_idx == dst)\\n                return cur_dist;\\n            \\n            if(cur_stop == k + 1)\\n                continue;\\n\\n            for(auto& p: adj[cur_idx]){\\n                int new_idx = p.first;\\n                int new_dist = cur_dist + p.second;\\n                int new_stop = cur_stop + 1;\\n                \\n                if(new_dist < dist[new_idx]){ // relaxation\\n                    dist[new_idx] = new_dist;\\n                    pq.push({new_idx, new_dist, new_stop});\\n                    stop[new_idx] = new_stop;\\n                }\\n                else if(new_stop < stop[new_idx]){\\n                    pq.push({new_idx, new_dist, new_stop});\\n                }\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719520,
                "title": "2-solutions-dijkstra-and-bellman-ford",
                "content": "k stops means atmost k+1 distance\\n\\nDIJKSTRA\\n```\\nclass Solution {\\n    class Edge{\\n        int v;\\n        int wt;\\n        int dist;\\n        \\n        Edge(int v, int wt, int dist){\\n            this.v = v;\\n            this.wt = wt;\\n            this.dist = dist;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        k++;\\n        ArrayList<ArrayList<Edge>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge : flights){\\n            int u = edge[0];\\n            int v = edge[1];\\n            int wt = edge[2];\\n            \\n            graph.get(u).add(new Edge(v, wt, 1));\\n            \\n        }\\n        \\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> a.wt - b.wt);\\n        pq.add(new Edge(src, 0, 0));\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        \\n        while(pq.size() > 0){\\n            Edge p = pq.remove();\\n            if(p.dist > k || stop[p.v] < p.dist)continue;\\n            \\n            stop[p.v] = p.dist;\\n            if(p.v == dst)return p.wt;\\n\\n            for(Edge nbr : graph.get(p.v)){\\n                pq.add(new Edge(nbr.v, p.wt + nbr.wt, p.dist + 1));\\n                \\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n\\nBELLMAN-FORD\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n\\t//here dp[i,j] means reaching jth vertex using atmost i hops\\n        int[][] dp = new int[k+2][n];\\n\\n        for(int i=0;i<k+2;i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);\\n        }]\\n        \\n        for(int i = 0; i <= k+1; i++){\\n            dp[i][src] = 0; // src is at a dist 0, no matter how many hops u take\\n        }\\n        \\n        for(int i = 1; i <= k+1; i++){\\n            for(int[] f: flights){\\n                int u = f[0];\\n                int v = f[1];\\n                int w = f[2];\\n                \\n                if(dp[i-1][u] != Integer.MAX_VALUE)\\n                    dp[i][v] = Math.min(dp[i][v], dp[i-1][u] + w);\\n            }\\n        }\\n        \\n        return (dp[k+1][dst] == Integer.MAX_VALUE)? -1: dp[k+1][dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Edge{\\n        int v;\\n        int wt;\\n        int dist;\\n        \\n        Edge(int v, int wt, int dist){\\n            this.v = v;\\n            this.wt = wt;\\n            this.dist = dist;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        k++;\\n        ArrayList<ArrayList<Edge>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge : flights){\\n            int u = edge[0];\\n            int v = edge[1];\\n            int wt = edge[2];\\n            \\n            graph.get(u).add(new Edge(v, wt, 1));\\n            \\n        }\\n        \\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> a.wt - b.wt);\\n        pq.add(new Edge(src, 0, 0));\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        \\n        while(pq.size() > 0){\\n            Edge p = pq.remove();\\n            if(p.dist > k || stop[p.v] < p.dist)continue;\\n            \\n            stop[p.v] = p.dist;\\n            if(p.v == dst)return p.wt;\\n\\n            for(Edge nbr : graph.get(p.v)){\\n                pq.add(new Edge(nbr.v, p.wt + nbr.wt, p.dist + 1));\\n                \\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n\\t//here dp[i,j] means reaching jth vertex using atmost i hops\\n        int[][] dp = new int[k+2][n];\\n\\n        for(int i=0;i<k+2;i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);\\n        }]\\n        \\n        for(int i = 0; i <= k+1; i++){\\n            dp[i][src] = 0; // src is at a dist 0, no matter how many hops u take\\n        }\\n        \\n        for(int i = 1; i <= k+1; i++){\\n            for(int[] f: flights){\\n                int u = f[0];\\n                int v = f[1];\\n                int w = f[2];\\n                \\n                if(dp[i-1][u] != Integer.MAX_VALUE)\\n                    dp[i][v] = Math.min(dp[i][v], dp[i-1][u] + w);\\n            }\\n        }\\n        \\n        return (dp[k+1][dst] == Integer.MAX_VALUE)? -1: dp[k+1][dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689620,
                "title": "c-bellman-ford-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        vector <int> distance(n ,INT_MAX);\\n        distance[src] = 0;\\n        \\n        for(int i = 0 ; i < k + 1; i ++){\\n            \\n            vector <int> copy(distance);\\n            for(auto flight : flights){\\n                int u = flight[0];\\n                int v = flight[1];\\n                int w = flight[2];\\n                \\n                if(distance[u] != INT_MAX and (distance[u] + w < copy[v])){\\n                    copy[v] = distance[u] + w;\\n                }\\n            }\\n            \\n            distance = copy;\\n        }\\n        \\n        \\n        return (distance[dst] == INT_MAX ? -1 : distance[dst]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        vector <int> distance(n ,INT_MAX);\\n        distance[src] = 0;\\n        \\n        for(int i = 0 ; i < k + 1; i ++){\\n            \\n            vector <int> copy(distance);\\n            for(auto flight : flights){\\n                int u = flight[0];\\n                int v = flight[1];\\n                int w = flight[2];\\n                \\n                if(distance[u] != INT_MAX and (distance[u] + w < copy[v])){\\n                    copy[v] = distance[u] + w;\\n                }\\n            }\\n            \\n            distance = copy;\\n        }\\n        \\n        \\n        return (distance[dst] == INT_MAX ? -1 : distance[dst]);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449409,
                "title": "simple-python-o-v-elogv-dijkstra-solution",
                "content": "```Python\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(list)\\n        for a, b, price in flights:\\n            graph[a].append((b, price))\\n        \\n        node2minNstop = {i: float(\"inf\") for i in range(n)}\\n        pq = [(0, src, -1)]\\n        while pq:\\n            dist_from_src, node, n_stops = heappop(pq)\\n            if node == dst:\\n                return dist_from_src\\n\\t\\t\\t# skip current iteration if number of stops exceeds maximum\\n\\t\\t\\t# or we can reach current node with fewer stops. Suppose we\\'ve\\n\\t\\t\\t# visited this node before, by the property of Dijkstra we must have found\\n\\t\\t\\t# a path with lower cost to this node before. The only reason we might want\\n\\t\\t\\t# to visit it again is if we can visit it with fewer stops. If this is not the case, we\\n\\t\\t\\t# skip.\\n            if n_stops >= min(k, node2minNstop[node]):\\n                continue\\n            node2minNstop[node] = n_stops\\n            for neighbor, dist_to_neighbor in graph[node]:\\n                heappush(pq, (dist_from_src+dist_to_neighbor, neighbor, n_stops+1))\\n                    \\n        return -1\\n    \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(list)\\n        for a, b, price in flights:\\n            graph[a].append((b, price))\\n        \\n        node2minNstop = {i: float(\"inf\") for i in range(n)}\\n        pq = [(0, src, -1)]\\n        while pq:\\n            dist_from_src, node, n_stops = heappop(pq)\\n            if node == dst:\\n                return dist_from_src\\n\\t\\t\\t# skip current iteration if number of stops exceeds maximum\\n\\t\\t\\t# or we can reach current node with fewer stops. Suppose we\\'ve\\n\\t\\t\\t# visited this node before, by the property of Dijkstra we must have found\\n\\t\\t\\t# a path with lower cost to this node before. The only reason we might want\\n\\t\\t\\t# to visit it again is if we can visit it with fewer stops. If this is not the case, we\\n\\t\\t\\t# skip.\\n            if n_stops >= min(k, node2minNstop[node]):\\n                continue\\n            node2minNstop[node] = n_stops\\n            for neighbor, dist_to_neighbor in graph[node]:\\n                heappush(pq, (dist_from_src+dist_to_neighbor, neighbor, n_stops+1))\\n                    \\n        return -1\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398215,
                "title": "modified-dijkstra-no-tle",
                "content": "Standard Dijkstra\\'s algorithm uses visit set to keep track of the vertices already included in the shortest path, so to not traverse them again.\\nBut here we need to traverse them again as stops maybe less. \\n\\nIdea is to keep a visit map (`vis[vertex] = stops`) with the stops for all the traversed vertices \\nNow if the same vertex is traversed again with stops `>=` stops present in the visit map, then that can be ignored as we already have the shortest distance for that many stops. It will remove all the redundant traversals.\\n\\n\\n```\\n\\n\\tpublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<Integer[]>> adj = new HashMap();\\n        int[] vis = new int[n];\\n        Arrays.fill(vis, Integer.MAX_VALUE);\\n        for(int[] flightcost : flights){\\n            adj.computeIfAbsent(flightcost[0], z -> new ArrayList()).add(new Integer[]{flightcost[1],flightcost[2]});\\n        }\\n        //Priority queue contains Integer array with 3 elements in order -> vertex, cost, stop \\n        Queue<Integer[]> que = new PriorityQueue<Integer[]>((o1,o2) -> {return o1[1]-o2[1];});        \\n        que.add(new Integer[]{src, 0, -1});\\n        \\n        while(!que.isEmpty()){\\n            Integer[] cur = que.poll();\\n            Integer curVertex = cur[0], curCost = cur[1], curStops = cur[2];\\n            if(curVertex == dst) return curCost;\\n\\t\\t\\t\\n            if(vis[curVertex] <= curStops || curStops == k || !adj.containsKey(curVertex)) continue;\\n            vis[curVertex] = curStops;\\n            for(Integer[] next : adj.get(curVertex)){\\n                que.add(new Integer[]{next[0], curCost + next[1], curStops+1});\\n            }            \\n        }\\n        return -1;\\n    }\\n\\t\\n\\n",
                "solutionTags": [],
                "code": "Standard Dijkstra\\'s algorithm uses visit set to keep track of the vertices already included in the shortest path, so to not traverse them again.\\nBut here we need to traverse them again as stops maybe less. \\n\\nIdea is to keep a visit map (`vis[vertex] = stops`) with the stops for all the traversed vertices \\nNow if the same vertex is traversed again with stops `>=` stops present in the visit map, then that can be ignored as we already have the shortest distance for that many stops. It will remove all the redundant traversals.\\n\\n\\n```\\n\\n\\tpublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<Integer[]>> adj = new HashMap();\\n        int[] vis = new int[n];\\n        Arrays.fill(vis, Integer.MAX_VALUE);\\n        for(int[] flightcost : flights){\\n            adj.computeIfAbsent(flightcost[0], z -> new ArrayList()).add(new Integer[]{flightcost[1],flightcost[2]});\\n        }\\n        //Priority queue contains Integer array with 3 elements in order -> vertex, cost, stop \\n        Queue<Integer[]> que = new PriorityQueue<Integer[]>((o1,o2) -> {return o1[1]-o2[1];});        \\n        que.add(new Integer[]{src, 0, -1});\\n        \\n        while(!que.isEmpty()){\\n            Integer[] cur = que.poll();\\n            Integer curVertex = cur[0], curCost = cur[1], curStops = cur[2];\\n            if(curVertex == dst) return curCost;\\n\\t\\t\\t\\n            if(vis[curVertex] <= curStops || curStops == k || !adj.containsKey(curVertex)) continue;\\n            vis[curVertex] = curStops;\\n            for(Integer[] next : adj.get(curVertex)){\\n                que.add(new Integer[]{next[0], curCost + next[1], curStops+1});\\n            }            \\n        }\\n        return -1;\\n    }\\n\\t\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1301173,
                "title": "easiest-c-code-12ms-small-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        vector<pair<int,int> > V[n+1] ;\\n        for(auto x:flights)\\n        {\\n            V[x[0]].push_back({x[1],x[2]}) ;\\n        }\\n        \\n        \\n        queue<pair<int,pair<int,int> > > Q ;\\n        Q.push({src,{0,0}}) ;\\n        \\n        int PRICE[n+1] ;\\n        for(int i=0 ; i<n+1 ; i++) PRICE[i]=INT_MAX ; \\n        PRICE[src]=0 ;\\n        \\n        while(!Q.empty())\\n        {\\n                int node = Q.front().first ;\\n                int dist = Q.front().second.first ;\\n                int cash = Q.front().second.second ;\\n\\n                Q.pop() ;\\n                for(auto child:V[node])\\n                {   \\n                    int jane_ka_price = child.second ; \\n                    int u = child.first ;\\n                    if(PRICE[u]>cash+jane_ka_price && dist<=K)\\n                    {\\n                        PRICE[u] = cash+jane_ka_price ;\\n                        Q.push({u,{dist+1,PRICE[u]} }) ;\\n                    }\\n                }\\n        }\\n\\n        return (PRICE[dst]<INT_MAX)? PRICE[dst]:-1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        vector<pair<int,int> > V[n+1] ;\\n        for(auto x:flights)\\n        {\\n            V[x[0]].push_back({x[1],x[2]}) ;\\n        }\\n        \\n        \\n        queue<pair<int,pair<int,int> > > Q ;\\n        Q.push({src,{0,0}}) ;\\n        \\n        int PRICE[n+1] ;\\n        for(int i=0 ; i<n+1 ; i++) PRICE[i]=INT_MAX ; \\n        PRICE[src]=0 ;\\n        \\n        while(!Q.empty())\\n        {\\n                int node = Q.front().first ;\\n                int dist = Q.front().second.first ;\\n                int cash = Q.front().second.second ;\\n\\n                Q.pop() ;\\n                for(auto child:V[node])\\n                {   \\n                    int jane_ka_price = child.second ; \\n                    int u = child.first ;\\n                    if(PRICE[u]>cash+jane_ka_price && dist<=K)\\n                    {\\n                        PRICE[u] = cash+jane_ka_price ;\\n                        Q.push({u,{dist+1,PRICE[u]} }) ;\\n                    }\\n                }\\n        }\\n\\n        return (PRICE[dst]<INT_MAX)? PRICE[dst]:-1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219308,
                "title": "bfs-bellman-ford-solution-dfs-dijkstra-s-cannot-ac",
                "content": "\\nIt\\'s 2021 now, but most of the highest-voted posts were written in 2018/2019. They discussed about BFS, DFS, Dijkstra\\'s, and Bellman-Ford. However, I find that (probably because LeetCode added more restrictive testcases), currenly only BFS and Bellman-Ford passes the test (I only verified this in C++). Nevertheless, in this post, we will discuss DFS, BFS, Dijkstra\\'s and Bellman-Ford.\\n\\n\\n\\n## BFS & DFS (TLE)\\n\\nWalk for at most k steps from `src` and report the price if`dst` is reached. Note that:\\n\\n- a node can be traversed more than once, as a path with more nodes can have shorter cost;\\n- Do early pruning by checking if `currPrice + price > minPrice`. This avoid infinite loops (but might traverse a loop multiple times).\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // BFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n        \\n        int minPrice = INT_MAX;\\n        queue<pair<int, int>> q({{src, 0}});\\n        for (int i = 0; i <= k+1 && !q.empty(); ++i) {\\n            int len = q.size();\\n            while (len-- > 0) {\\n                pair<int, int> p = q.front(); q.pop();\\n                int curr = p.first, currPrice = p.second;\\n                if (curr == dst) {\\n                    minPrice = min(minPrice, currPrice);\\n                    continue;\\n                }\\n\\n                for (pair<int, int>& nextP : F[curr]) {\\n                    int next = nextP.first, price = nextP.second;\\n                \\n                    if (currPrice+price > minPrice) // pruning\\n                        continue;\\n\\n                    minPrices[next] = currPrice+price;\\n                    q.push({next, price+currPrice});\\n                }\\n            }\\n        }\\n        return minPrice == INT_MAX ? -1 : minPrice;\\n    }\\n};\\n```\\n\\n\\n\\nThe DFS solution is almost the same, except that when backtracking, use `visited` to avoid loops (each loop traversed at most once).\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // DFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n    \\n        int res = INT_MAX;\\n        vector<int> visited(n, false);\\n        visited[src] = true;\\n        dfs(F, visited, src, dst, k+1, 0, res);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\n    void dfs(unordered_map<int, vector<pair<int, int>>>& F, vector<int>& visited, \\n             int src, int dst, int k, int currPrice, int& res) {\\n        if (src == dst) {\\n            res = min(res, currPrice);\\n            return;\\n        }\\n        if (k == 0) {\\n            return;\\n        }\\n\\n        for (auto p : F[src]) {\\n            auto [next, price] = p;\\n            if (visited[next] || currPrice+price > res) // pruning\\n                continue;\\n\\n            visited[next] = true;\\n            dfs(F, visited, next, dst, k-1, currPrice+price, res);\\n            visited[next] = false;\\n        }\\n    }\\n};\\n```\\n\\nHowever, both approaches above fail for TLE on LeetCode.\\n\\n\\n\\n\\n\\n## BFS with more aggressive pruning (AC)\\n\\nCan we prune more with BFS? Yes, `currPrice + price > minPrice` in the previous BFS solution might take several rounds in a loop before stopping, can we do better?\\n\\nYes. Whenever a node is traversed, remeber the min cost taken to reach the node. If the current cost at `u` is greater than the previous cost, then there\\'s no point continuing. Here\\'s the reason:\\n\\n- In BFS, a later traversal to `u` means the current path is longer than previous path;\\n- It\\'s possible for a later traversal (i.e., a path with more nodes on it) to have shorter cost, and this is the path we must consider;\\n- However, if a later traversal (i.e. a path with more nodes on it) has larger cost than previous path, just stop.\\n\\nBased on this idea, we have the following code:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // BFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n        \\n        unordered_map<int, int> minPrices; \\n        int minPrice = INT_MAX;\\n        queue<pair<int, int>> q({{src, 0}});\\n        for (int i = 0; i <= k+1 && !q.empty(); ++i) {\\n            int len = q.size();\\n            while (len-- > 0) {\\n                pair<int, int> p = q.front(); q.pop();\\n                int curr = p.first, currPrice = p.second;\\n                if (curr == dst) {\\n                    minPrice = min(minPrice, currPrice);\\n                    continue;\\n                }\\n\\n                for (pair<int, int>& nextP : F[curr]) {\\n                    int next = nextP.first, price = nextP.second;\\n                \\n                    // [Important] BFS early stop\\n                    // A node can be traversed more than once, because a path with more steps might have smaller cost;\\n                    // However, if a path with more steps have larger cost, there is no point continuing.\\n                    if (minPrices.count(next) > 0 && minPrices[next] < currPrice+price)\\n                        continue;\\n\\n                    minPrices[next] = currPrice+price;\\n                    q.push({next, price+currPrice});\\n                }\\n            }\\n        }\\n        return minPrice == INT_MAX ? -1 : minPrice;\\n    }\\n}\\n```\\n\\nIt\\'s not easy to implement the same idea with DFS: an earlier, unsuccessful traversal needs to clear the entries it filled in `minPrices`, but it\\'s not straightforward to do that.\\n\\n\\n\\n## Dijkstra\\'s Algorithm (TLE)\\n\\nAlgorithm: [Wiki](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Dijkstra\\'s algorithm\\n        typedef tuple<int,int,int> ti;\\n\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n\\n        priority_queue<ti, vector<ti>, greater<ti>> pq; // <cost, node, steps>\\n        pq.push({0, src, k+1});\\n        while (!pq.empty()) {\\n            auto [currPrice, node, k] = pq.top(); pq.pop();\\n            if (node == dst) return currPrice;\\n            if (k == 0) continue;\\n            for (auto [next, price] : F[node]) {\\n                pq.push({currPrice+price, next, k-1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThe idea is similar to Dijkstra\\'s algorithm. But note that we are not using `visited` to avoid revisiting a node, and not using `minDistances` to remeber the minimum distance to each node. Reason: the restriction of `k` stops. The final result might not be the shortest path - we might need to pick a path with fewer stops but higher cost.\\n\\nDijkstra\\'s algorithm timeouts on LeetCode.\\n\\nDetailed explanation on Dijkstra\\'s algorithm implementation: [link](https://leetcode.com/problems/path-with-maximum-probability/discuss/732293/Dijkstra\\'s-algorithm-implementation-C%2B%2B).\\n\\n\\n\\n## Bellman-Ford (AC)\\n\\nAlgorithm: [Wiki](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Bellman Ford\\n        vector<int> dp(n, INT_MAX);\\n        dp[src] = 0;\\n        for (int i = 0; i < k+1; ++i) {\\n            vector<int> temp = dp;\\n            for (vector<int>& f : flights) {\\n                int u = f[0], v = f[1], price = f[2];\\n                if (temp[u] == INT_MAX) continue;\\n                dp[v] = min(dp[v], temp[u]+price); \\n            }\\n        }\\n        return dp[dst] == INT_MAX ? -1 : dp[dst];\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n## Note\\n\\nThe complexity of Dijkstra\\'s algorithm is O(VlogV), while the complexity of Bellman-Ford is O(VE). Why Dijkstra\\'s TLE but Bellman-Ford AC? Actually, we implement different from the original Dijkstra\\'s, so the complexity is actually higher. \\n\\nTODO: Time complexity analysis.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // BFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n        \\n        int minPrice = INT_MAX;\\n        queue<pair<int, int>> q({{src, 0}});\\n        for (int i = 0; i <= k+1 && !q.empty(); ++i) {\\n            int len = q.size();\\n            while (len-- > 0) {\\n                pair<int, int> p = q.front(); q.pop();\\n                int curr = p.first, currPrice = p.second;\\n                if (curr == dst) {\\n                    minPrice = min(minPrice, currPrice);\\n                    continue;\\n                }\\n\\n                for (pair<int, int>& nextP : F[curr]) {\\n                    int next = nextP.first, price = nextP.second;\\n                \\n                    if (currPrice+price > minPrice) // pruning\\n                        continue;\\n\\n                    minPrices[next] = currPrice+price;\\n                    q.push({next, price+currPrice});\\n                }\\n            }\\n        }\\n        return minPrice == INT_MAX ? -1 : minPrice;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // DFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n    \\n        int res = INT_MAX;\\n        vector<int> visited(n, false);\\n        visited[src] = true;\\n        dfs(F, visited, src, dst, k+1, 0, res);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\n    void dfs(unordered_map<int, vector<pair<int, int>>>& F, vector<int>& visited, \\n             int src, int dst, int k, int currPrice, int& res) {\\n        if (src == dst) {\\n            res = min(res, currPrice);\\n            return;\\n        }\\n        if (k == 0) {\\n            return;\\n        }\\n\\n        for (auto p : F[src]) {\\n            auto [next, price] = p;\\n            if (visited[next] || currPrice+price > res) // pruning\\n                continue;\\n\\n            visited[next] = true;\\n            dfs(F, visited, next, dst, k-1, currPrice+price, res);\\n            visited[next] = false;\\n        }\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // BFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n        \\n        unordered_map<int, int> minPrices; \\n        int minPrice = INT_MAX;\\n        queue<pair<int, int>> q({{src, 0}});\\n        for (int i = 0; i <= k+1 && !q.empty(); ++i) {\\n            int len = q.size();\\n            while (len-- > 0) {\\n                pair<int, int> p = q.front(); q.pop();\\n                int curr = p.first, currPrice = p.second;\\n                if (curr == dst) {\\n                    minPrice = min(minPrice, currPrice);\\n                    continue;\\n                }\\n\\n                for (pair<int, int>& nextP : F[curr]) {\\n                    int next = nextP.first, price = nextP.second;\\n                \\n                    // [Important] BFS early stop\\n                    // A node can be traversed more than once, because a path with more steps might have smaller cost;\\n                    // However, if a path with more steps have larger cost, there is no point continuing.\\n                    if (minPrices.count(next) > 0 && minPrices[next] < currPrice+price)\\n                        continue;\\n\\n                    minPrices[next] = currPrice+price;\\n                    q.push({next, price+currPrice});\\n                }\\n            }\\n        }\\n        return minPrice == INT_MAX ? -1 : minPrice;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Dijkstra\\'s algorithm\\n        typedef tuple<int,int,int> ti;\\n\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n\\n        priority_queue<ti, vector<ti>, greater<ti>> pq; // <cost, node, steps>\\n        pq.push({0, src, k+1});\\n        while (!pq.empty()) {\\n            auto [currPrice, node, k] = pq.top(); pq.pop();\\n            if (node == dst) return currPrice;\\n            if (k == 0) continue;\\n            for (auto [next, price] : F[node]) {\\n                pq.push({currPrice+price, next, k-1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Bellman Ford\\n        vector<int> dp(n, INT_MAX);\\n        dp[src] = 0;\\n        for (int i = 0; i < k+1; ++i) {\\n            vector<int> temp = dp;\\n            for (vector<int>& f : flights) {\\n                int u = f[0], v = f[1], price = f[2];\\n                if (temp[u] == INT_MAX) continue;\\n                dp[v] = min(dp[v], temp[u]+price); \\n            }\\n        }\\n        return dp[dst] == INT_MAX ? -1 : dp[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195431,
                "title": "most-voted-priorityqueue-solution-getting-timing-out",
                "content": "The priority queue solution provided in most voted post is getting TLE for below use-case.\\n\\n```\\n13\\n[[11,12,74],[1,8,91],[4,6,13],[7,6,39],[5,12,8],[0,12,54],[8,4,32],[0,11,4],[4,0,91],[11,7,64],[6,3,88],[8,5,80],[11,10,91],[10,0,60],[8,7,92],[12,6,78],[6,2,8],[4,3,54],[3,11,76],[3,12,23],[11,6,79],[6,12,36],[2,11,100],[2,5,49],[7,0,17],[5,8,95],[3,9,98],[8,10,61],[2,12,38],[5,7,58],[9,4,37],[8,6,79],[9,0,1],[2,3,12],[7,10,7],[12,10,52],[7,2,68],[12,2,100],[6,9,53],[7,4,90],[0,5,43],[11,2,52],[11,8,50],[12,4,38],[7,9,94],[2,7,38],[3,7,88],[9,12,20],[12,0,26],[10,5,38],[12,8,50],[0,2,77],[11,0,13],[9,10,76],[2,6,67],[5,6,34],[9,7,62],[5,3,67]]\\n10\\n1\\n10\\n```\\n\\nCode\\n\\n```\\n Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] f:flights)\\n        {\\n            map.putIfAbsent(f[0],new ArrayList<>());\\n            map.get(f[0]).add(new int[]{f[1],f[2]});\\n        }\\n        PriorityQueue<int[]> q=new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Integer.compare(o1[0],o2[0]);\\n            }\\n        });\\n        q.offer(new int[]{0,src,K+1});\\n        while(!q.isEmpty())\\n        {\\n            int[] c=q.poll();\\n            int cost=c[0];\\n            int curr=c[1];\\n            int stop=c[2];\\n            if(curr==dst)\\n                return cost;\\n            if(stop>0)\\n            {\\n                if(!map.containsKey(curr))\\n                    continue;\\n                for(int[] next:map.get(curr))\\n                {\\n                    q.add(new int[]{cost+next[1],next[0],stop-1});\\n                }\\n            }\\n        }\\n        return -1;\\n```",
                "solutionTags": [],
                "code": "```\\n13\\n[[11,12,74],[1,8,91],[4,6,13],[7,6,39],[5,12,8],[0,12,54],[8,4,32],[0,11,4],[4,0,91],[11,7,64],[6,3,88],[8,5,80],[11,10,91],[10,0,60],[8,7,92],[12,6,78],[6,2,8],[4,3,54],[3,11,76],[3,12,23],[11,6,79],[6,12,36],[2,11,100],[2,5,49],[7,0,17],[5,8,95],[3,9,98],[8,10,61],[2,12,38],[5,7,58],[9,4,37],[8,6,79],[9,0,1],[2,3,12],[7,10,7],[12,10,52],[7,2,68],[12,2,100],[6,9,53],[7,4,90],[0,5,43],[11,2,52],[11,8,50],[12,4,38],[7,9,94],[2,7,38],[3,7,88],[9,12,20],[12,0,26],[10,5,38],[12,8,50],[0,2,77],[11,0,13],[9,10,76],[2,6,67],[5,6,34],[9,7,62],[5,3,67]]\\n10\\n1\\n10\\n```\n```\\n Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] f:flights)\\n        {\\n            map.putIfAbsent(f[0],new ArrayList<>());\\n            map.get(f[0]).add(new int[]{f[1],f[2]});\\n        }\\n        PriorityQueue<int[]> q=new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Integer.compare(o1[0],o2[0]);\\n            }\\n        });\\n        q.offer(new int[]{0,src,K+1});\\n        while(!q.isEmpty())\\n        {\\n            int[] c=q.poll();\\n            int cost=c[0];\\n            int curr=c[1];\\n            int stop=c[2];\\n            if(curr==dst)\\n                return cost;\\n            if(stop>0)\\n            {\\n                if(!map.containsKey(curr))\\n                    continue;\\n                for(int[] next:map.get(curr))\\n                {\\n                    q.add(new int[]{cost+next[1],next[0],stop-1});\\n                }\\n            }\\n        }\\n        return -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152831,
                "title": "c-explained-dijkstra-algo",
                "content": "Code has been commented below:\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        vector<vector<pair<int,int>>> adj(n);\\n //create a directed weighted graph from given edges in flights       \\n        for(int i=0;i<flights.size();i++){\\n           adj[flights[i][0]].push_back({flights[i][2], flights[i][1]}); \\n        }\\n        \\n//we use priority queue in ascending order of weights to process vertices\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> q;\\n\\n//push the start vertex \"src\" with weight 0 as a node is connected to itself no weight\\n//needed and the steps k+1, we use k+1 instead of k bcoz if we can visit k nodes as a stop\\n// it means we can visit k+1 edges\\n        \\n        q.push({0,{src, K+1}});\\n        \\n//Loop until q is not empty\\n        while(!q.empty()){\\n            auto node = q.top(); //get the front element with samllest weight in q\\n            q.pop();    ///remove the processed pair\\n            \\n            int cost = node.first;  //weight or cost of currently popped pair\\n            int v = node.second.first;  //the vertex\\n            int steps_left = node.second.second; //steps left currenlty\\n            \\n    //if steps_left becomes <0 this means we have exceeded the number of stops allowed from src to dst\\n            if(steps_left<0)continue;\\n//else if w have reached the dst return the cost of that path\\n            if(dst == v)return cost;\\n//Nowe we loop all the neighbour of vertex v above and add the cost of visiting and also\\n//reduce the steps_left and then push it in priority_queue to be processes further\\n            for(auto temp: adj[v]){\\n                int cost_to = temp.first;\\n              int to = temp.second;\\n                \\n                q.push({cost+cost_to, {to,steps_left-1}});\\n            }\\n            \\n        }\\n//if at last we are unable to reach dst from ource with given number of stops then return -1\\n       return -1;\\n    }\\n};\\n```\\n**Do upvote if explanation was useful & you liked the code :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        vector<vector<pair<int,int>>> adj(n);\\n //create a directed weighted graph from given edges in flights       \\n        for(int i=0;i<flights.size();i++){\\n           adj[flights[i][0]].push_back({flights[i][2], flights[i][1]}); \\n        }\\n        \\n//we use priority queue in ascending order of weights to process vertices\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> q;\\n\\n//push the start vertex \"src\" with weight 0 as a node is connected to itself no weight\\n//needed and the steps k+1, we use k+1 instead of k bcoz if we can visit k nodes as a stop\\n// it means we can visit k+1 edges\\n        \\n        q.push({0,{src, K+1}});\\n        \\n//Loop until q is not empty\\n        while(!q.empty()){\\n            auto node = q.top(); //get the front element with samllest weight in q\\n            q.pop();    ///remove the processed pair\\n            \\n            int cost = node.first;  //weight or cost of currently popped pair\\n            int v = node.second.first;  //the vertex\\n            int steps_left = node.second.second; //steps left currenlty\\n            \\n    //if steps_left becomes <0 this means we have exceeded the number of stops allowed from src to dst\\n            if(steps_left<0)continue;\\n//else if w have reached the dst return the cost of that path\\n            if(dst == v)return cost;\\n//Nowe we loop all the neighbour of vertex v above and add the cost of visiting and also\\n//reduce the steps_left and then push it in priority_queue to be processes further\\n            for(auto temp: adj[v]){\\n                int cost_to = temp.first;\\n              int to = temp.second;\\n                \\n                q.push({cost+cost_to, {to,steps_left-1}});\\n            }\\n            \\n        }\\n//if at last we are unable to reach dst from ource with given number of stops then return -1\\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915497,
                "title": "beat-99-2-c-solution-very-easy-to-understand-if-you-know-dijkstra-s-algorithm",
                "content": "Here is Dijkstra\\'s Algorithm\\n\\n```\\n    void dijkastra(vector<vector<pair<int,int>>> &graph) { \\n        int n = graph.size();\\n        vector<int> cost(n, INT_MAX); \\n        vector<int> parent(n, -1); \\n        vector<bool> visited(n, false); \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; \\n\\n        int src = 0; \\n        pq.push(make_pair(0, src)); \\n        cost[src] = 0; \\n\\n        while (!pq.empty()) { \\n            int u = pq.top().second; \\n            pq.pop(); \\n\\n            if (visited[u]) {\\n                continue;\\n            }\\n            visited[u] = true; \\n\\n            for (auto &[v, weight] : graph[u]) {\\n                if (visited[v]) {\\n                    continue;\\n                }\\n                int cost0 = cost[u] + weight;\\n                if (cost[v] > cost0) {\\n                    cost[v] = cost0; \\n                    pq.push(make_pair(cost[v], v)); \\n                    parent[v] = u; \\n                } \\n            } \\n        } \\n    } \\n\\n```\\n\\nHere is the solution similar to Dijkstra:\\n\\nTime Complexity: O(dV log(dV)) where d is the max in degree of a node. a node can be put in the heap at most d times. \\nSpace Complexity: O(dV) for the heap. O(E+V) for the graph. So O(dV) in total.\\n\\nAny better analysis?\\n\\n\\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<pair<int, int> > > graph(n);\\n        for (auto & f : flights) {\\n            graph[f[0]].push_back({f[1], f[2]});\\n        }\\n        \\n        typedef tuple<int, int, int> Type;\\n        priority_queue<Type, vector<Type>, std::greater<Type>> que;\\n        vector<pair<int, int> > cost(n, {INT_MAX, INT_MAX}); //dist, k\\n  \\n        que.emplace(0, -1, src);        \\n        while(que.size()) {\\n            auto [dist, cur_k, cur] = que.top();\\n            que.pop();\\n            \\n            if (cur == dst && cur_k <= K) {\\n                return dist;\\n            }\\n            if (cur_k >= K) {\\n                continue;\\n            }\\n            \\n            // similar to check visited\\n            if (dist >= cost[cur].first && cur_k >= cost[cur].second) {\\n                continue;\\n            }\\n            // similar to update visited\\n            if (dist <= cost[cur].first && cur_k <= cost[cur].second) {\\n                cost[cur] = {dist, cur_k};\\n            }\\n            \\n            for (auto [ne, edge] : graph[cur]) {\\n                int dist0 = dist + edge;\\n                // similar to check visited\\n                if (dist0 < cost[ne].first || cur_k + 1 < cost[ne].second) {\\n                    que.emplace(dist0, cur_k + 1, ne);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\nYou can remove checking visited. However, it\\'s significantly slower because of more nodes in heap:\\n\\n```\\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<pair<int, int> > > graph(n);\\n        for (auto & f : flights) {\\n            graph[f[0]].push_back({f[1], f[2]});\\n        }\\n        \\n        typedef tuple<int, int, int> Type;\\n        priority_queue<Type, vector<Type>, std::greater<Type>> que;\\n  \\n        que.emplace(0, -1, src);        \\n        while(que.size()) {\\n            auto [dist, cur_k, cur] = que.top();\\n            que.pop();\\n            \\n            if (cur == dst && cur_k <= K) {\\n                return dist;\\n            }\\n            if (cur_k >= K) {\\n                continue;\\n            }\\n            \\n            for (auto [ne, edge] : graph[cur]) {\\n                int dist0 = dist + edge;\\n                que.emplace(dist0, cur_k + 1, ne);\\n            }\\n        }\\n        return -1;\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    void dijkastra(vector<vector<pair<int,int>>> &graph) { \\n        int n = graph.size();\\n        vector<int> cost(n, INT_MAX); \\n        vector<int> parent(n, -1); \\n        vector<bool> visited(n, false); \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; \\n\\n        int src = 0; \\n        pq.push(make_pair(0, src)); \\n        cost[src] = 0; \\n\\n        while (!pq.empty()) { \\n            int u = pq.top().second; \\n            pq.pop(); \\n\\n            if (visited[u]) {\\n                continue;\\n            }\\n            visited[u] = true; \\n\\n            for (auto &[v, weight] : graph[u]) {\\n                if (visited[v]) {\\n                    continue;\\n                }\\n                int cost0 = cost[u] + weight;\\n                if (cost[v] > cost0) {\\n                    cost[v] = cost0; \\n                    pq.push(make_pair(cost[v], v)); \\n                    parent[v] = u; \\n                } \\n            } \\n        } \\n    } \\n\\n```\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<pair<int, int> > > graph(n);\\n        for (auto & f : flights) {\\n            graph[f[0]].push_back({f[1], f[2]});\\n        }\\n        \\n        typedef tuple<int, int, int> Type;\\n        priority_queue<Type, vector<Type>, std::greater<Type>> que;\\n        vector<pair<int, int> > cost(n, {INT_MAX, INT_MAX}); //dist, k\\n  \\n        que.emplace(0, -1, src);        \\n        while(que.size()) {\\n            auto [dist, cur_k, cur] = que.top();\\n            que.pop();\\n            \\n            if (cur == dst && cur_k <= K) {\\n                return dist;\\n            }\\n            if (cur_k >= K) {\\n                continue;\\n            }\\n            \\n            // similar to check visited\\n            if (dist >= cost[cur].first && cur_k >= cost[cur].second) {\\n                continue;\\n            }\\n            // similar to update visited\\n            if (dist <= cost[cur].first && cur_k <= cost[cur].second) {\\n                cost[cur] = {dist, cur_k};\\n            }\\n            \\n            for (auto [ne, edge] : graph[cur]) {\\n                int dist0 = dist + edge;\\n                // similar to check visited\\n                if (dist0 < cost[ne].first || cur_k + 1 < cost[ne].second) {\\n                    que.emplace(dist0, cur_k + 1, ne);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 707448,
                "title": "c-3-approaches-top-down-dp-dijkstra-s-algorithm-bellman-ford-algorithm",
                "content": "***Approach1-TOP DOWN DP***\\n```\\nclass Solution {\\npublic:\\n    int getCheapFlight(vector<vector<pair<int,int>>> &adjL, int src, int &dst, int K, vector<vector<int>> &dp){        \\n        if(src==dst)\\n            return 0;\\n        if(K<0)\\n            return -1;\\n        if(dp[src][K]){            \\n            return dp[src][K];\\n        }\\n        \\n        int minCost=INT_MAX;\\n        for(auto x:adjL[src]){            \\n                int cost = getCheapFlight(adjL, x.first, dst, K-1, dp);    \\n                if(cost!=-1)\\n                    minCost = min(minCost,cost+x.second);            \\n        }\\n        if(minCost==INT_MAX)\\n            dp[src][K] = -1;\\n        else\\n            dp[src][K] = minCost;\\n        return dp[src][K];\\n    }\\n\\t\\n\\tint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) { \\n        vector<vector<pair<int,int>>> adjL(n);                \\n        for(auto x:flights){            \\n            adjL[x[0]].push_back({x[1],x[2]});\\n        }\\n        \\n        int cost = getCheapFlight(adjL, src, dst, K, dp);\\n        if(cost==0)\\n            return -1;\\n        return cost;\\n    }\\n}\\n```\\n\\n***Approach2- Dijkstra algorithm***\\n```\\ntypedef tuple<int,int,int> tupl;\\n\\nvector<vector<pair<int,int>>> adjL(n);                \\n        for(auto x:flights){            \\n            adjL[x[0]].push_back({x[1],x[2]});\\n        }\\n\\t\\t\\npriority_queue<tupl, vector<tupl>, greater<tupl>> pq;        \\n        pq.push({0,src,K});\\n        int cost=0;\\n        if(src==dst) return 0;            \\n        while(!pq.empty()){                               \\n            tupl t = pq.top();\\n            pq.pop();            \\n            int cc = get<0>(t);\\n            int vert = get<1>(t);\\n            int newk = get<2>(t);            \\n            if(vert==dst){                    \\n                return cc;\\n            }\\n            if(newk>=0){\\n                for(auto x:adjL[vert]){                                                        \\n                    pq.push({cc+x.second, x.first, newk-1});\\n                }\\n            }                                    \\n        }\\n        return -1;\\n```\\n\\n***Approach3-Bellman Ford***\\n```\\n vector<int> prev(n+1,INT_MAX);\\n        prev[src]=0;\\n        for(int i=0;i<=K;i++){\\n            vector<int> curr(prev);\\n            \\n            for(int i=0;i<flights.size();i++){\\n                int s = flights[i][0];\\n                int d = flights[i][1];\\n                int w = flights[i][2];\\n                if(prev[s]!=INT_MAX && (prev[s]+w)<curr[d]){\\n                    curr[d] = prev[s]+w;\\n                }                                \\n            }\\n            prev=curr;\\n        }\\n        if(prev[dst]==INT_MAX) return -1;\\n        return prev[dst];\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCheapFlight(vector<vector<pair<int,int>>> &adjL, int src, int &dst, int K, vector<vector<int>> &dp){        \\n        if(src==dst)\\n            return 0;\\n        if(K<0)\\n            return -1;\\n        if(dp[src][K]){            \\n            return dp[src][K];\\n        }\\n        \\n        int minCost=INT_MAX;\\n        for(auto x:adjL[src]){            \\n                int cost = getCheapFlight(adjL, x.first, dst, K-1, dp);    \\n                if(cost!=-1)\\n                    minCost = min(minCost,cost+x.second);            \\n        }\\n        if(minCost==INT_MAX)\\n            dp[src][K] = -1;\\n        else\\n            dp[src][K] = minCost;\\n        return dp[src][K];\\n    }\\n\\t\\n\\tint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) { \\n        vector<vector<pair<int,int>>> adjL(n);                \\n        for(auto x:flights){            \\n            adjL[x[0]].push_back({x[1],x[2]});\\n        }\\n        \\n        int cost = getCheapFlight(adjL, src, dst, K, dp);\\n        if(cost==0)\\n            return -1;\\n        return cost;\\n    }\\n}\\n```\n```\\ntypedef tuple<int,int,int> tupl;\\n\\nvector<vector<pair<int,int>>> adjL(n);                \\n        for(auto x:flights){            \\n            adjL[x[0]].push_back({x[1],x[2]});\\n        }\\n\\t\\t\\npriority_queue<tupl, vector<tupl>, greater<tupl>> pq;        \\n        pq.push({0,src,K});\\n        int cost=0;\\n        if(src==dst) return 0;            \\n        while(!pq.empty()){                               \\n            tupl t = pq.top();\\n            pq.pop();            \\n            int cc = get<0>(t);\\n            int vert = get<1>(t);\\n            int newk = get<2>(t);            \\n            if(vert==dst){                    \\n                return cc;\\n            }\\n            if(newk>=0){\\n                for(auto x:adjL[vert]){                                                        \\n                    pq.push({cc+x.second, x.first, newk-1});\\n                }\\n            }                                    \\n        }\\n        return -1;\\n```\n```\\n vector<int> prev(n+1,INT_MAX);\\n        prev[src]=0;\\n        for(int i=0;i<=K;i++){\\n            vector<int> curr(prev);\\n            \\n            for(int i=0;i<flights.size();i++){\\n                int s = flights[i][0];\\n                int d = flights[i][1];\\n                int w = flights[i][2];\\n                if(prev[s]!=INT_MAX && (prev[s]+w)<curr[d]){\\n                    curr[d] = prev[s]+w;\\n                }                                \\n            }\\n            prev=curr;\\n        }\\n        if(prev[dst]==INT_MAX) return -1;\\n        return prev[dst];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690997,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Perform Bellman-Ford to build current `cur` minimum distances from previous `pre` minimum distances via `K + 1` edge relaxations for the single-source-shortest-paths for `K` hops to find the minimum distance from source `S` to target `T` (if it exists), ie. we use the past to formulate the future.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findCheapestPrice(N: Int, E: Array<IntArray>, S: Int, T: Int, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var pre = IntArray(N) { INF }; pre[S] = 0\\n        for (i in 0..K) {\\n            var cur = pre.copyOf()\\n            for ((u, v, w) in E)\\n                cur[v] = Math.min(cur[v], pre[u] + w)\\n            pre = cur\\n        }\\n        return if (pre[T] != INF) pre[T] else -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (N, E, S, T, K) => {\\n    let pre = Array(N).fill(Infinity); pre[S] = 0;\\n    while (0 <= K--) {\\n        let cur = [...pre];\\n        for (let [u, v, w] of E)\\n            cur[v] = Math.min(cur[v], pre[u] + w);\\n        pre = cur;\\n    }\\n    return pre[T] != Infinity ? pre[T] : -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findCheapestPrice(self, N: int, E: List[List[int]], S: int, T: int, K: int, INF = int(1e9 + 7)) -> int:\\n        pre = [INF] * N; pre[S] = 0\\n        for _ in range(K + 1):\\n            cur = pre[:]\\n            for u, v, w in E:\\n                cur[v] = min(cur[v], pre[u] + w)\\n            pre = cur\\n        return pre[T] if pre[T] != INF else -1\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn find_cheapest_price(N: i32, E: VVI, S: i32, T: i32, K: i32) -> i32 {\\n        let (N, S, T) = (N as usize, S as usize, T as usize);\\n        let INF = 1e9 as i32 + 7;\\n        let mut pre = vec![INF; N]; pre[S] = 0;\\n        for _ in 0..=K {\\n            let mut cur = pre.clone();\\n            for edge in &E {\\n                let (u, v, w) = (edge[0] as usize, edge[1] as usize, edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w);\\n            }\\n            pre = cur;\\n        }\\n        if pre[T] != INF { pre[T] } else { -1 }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findCheapestPrice(int N, VVI& E, int S, int T, int K, int INF = 1e9 + 7) {\\n        VI pre(N, INF); pre[S] = 0;\\n        while (0 <= K--) {\\n            VI cur{ pre };\\n            for (auto& edge: E) {\\n                auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[T] != INF ? pre[T] : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Past solutions from October 2, 2020**\\n\\n**Solution #1:**\\n\\nPerform DFS + BT to find the minimum `cost` from `start` to target `T`.  The `cost` of each DFS path explored is accumulated as the recursive stack approaches the base cases.\\n\\n* **Base Cases:**\\n\\t* *Case 1:* we reached the target `T`, thus the minimum `cost` is recorded as the `best`\\n\\t* *Case 2:* all `k` hops are exhausted, simply `return` to allow the recursive stack to unwind and backtrack to the next DFS path to recursively explore.\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (_, E, start, T, hops, adj = new Map(), best = Infinity) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, cost = 0, seen = new Set()) => {\\n        if (u == T)\\n            best = Math.min(best, cost); // best is the minimum cost \\uD83C\\uDFAF\\n        if (u == T || !k)\\n            return; // destination reached or k-hops exhausted: stop \\uD83D\\uDED1\\n        seen.add(u); // \\uD83D\\uDC40 \\u2705 forward-tracking\\n        for (let [v, w] of [...adj.get(u) || []])\\n            if (!seen.has(v) && cost + w < best) // pruning condition: cost + w < best \\uD83E\\uDD14\\n                go(v, k - 1, cost + w, seen);\\n        seen.delete(u); // \\uD83D\\uDC40 \\u274C back-tracking\\n    };\\n    go();\\n    return best < Infinity ? best : -1;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>;\\n    Adj adj;\\n    int T, best;\\n    void go(int u, int k, int cost = 0, Set&& seen = {}) {\\n        if (u == T)\\n            best = min(best, cost); // best is the minimum cost \\uD83C\\uDFAF\\n        if (u == T || !k)\\n            return; // target T destination reached or k-hops exhausted: stop \\uD83D\\uDED1\\n        seen.insert(u); // \\uD83D\\uDC40 \\u2705 forward-tracking\\n        for (auto [v, w]: adj[u])\\n            if (seen.find(v) == seen.end() && cost + w < best) // pruning condition: cost + w < best \\uD83E\\uDD14\\n                go(v, k - 1, cost + w, move(seen));\\n        seen.erase(u); // \\uD83D\\uDC40 \\u274C back-tracking\\n    }\\npublic:\\n    int findCheapestPrice(int _, VVI& E, int start, int T_, int hops, int INF = int(1e9 + 7)) {\\n        T = T_;\\n        best = INF;\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        go(start, hops + 1);\\n        return best < INF ? best : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #2:**\\n\\nAn astute observer will notice its obviously silly to perform DFS + BT.  Solution #1 is so very inefficient that a pruning condition is necessary to avoid TLE.  An improved DFS solution simply uses memoization to store previously solved sub-problems (ie. use dynamic programming).  The cost `w` of each edge (`u`,`v`) is accumulated as the recursive stack unwinds, and each sub-problem\\'s optimal solution is stored in the memo `m`.\\n\\n**Summary:**\\n\\n[\\uD83C\\uDFA8 The **ART** of dynamic programming](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    let m = [...Array(N)].map(_ => Array(hops + 2).fill(-1)); // +2 because for V vertices there are V+1 edges and +1 for the memo itself to be 0..hops+1 inclusive\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, min = Infinity) => {\\n        if (m[u][k] > -1)\\n            return m[u][k]; // memo \\uD83E\\uDD14\\n        if (u == T)\\n            return m[u][k] = 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return m[u][k] = Infinity; // all k hops exhausted \\u274C\\n        for (let [v, w] of [...adj.get(u) || []])\\n            min = Math.min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return m[u][k] = min;\\n    };\\n    return go() < Infinity ? go() : -1;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>; // u -> [v, w] == edge u -> v with cost w\\n    Adj adj;\\n    int T;\\n    VVI m;\\n    static constexpr auto INF = int(1e9 + 7);\\n    int go(int u, int k, int min = INF) {\\n        if (m[u][k] > -1)\\n            return m[u][k]; // memo \\uD83E\\uDD14\\n        if (u == T)\\n            return m[u][k] = 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return m[u][k] = INF; // all k hops exhausted \\u274C\\n        for (auto [v, w]: adj[u])\\n            min = std::min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return m[u][k] = min;\\n    }\\npublic:\\n    int findCheapestPrice(int N, VVI& E, int start, int T_, int hops) {\\n        T = T_;\\n        m = VVI(N, VI(hops + 2, -1)); // +2 because for V vertices there are V+1 edges and +1 for the memo itself to be 0..hops+1 inclusive\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto ans = go(start, hops + 1);\\n        return ans < INF ? ans : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #2 - Supplemental:** it may be easier to understand this DFS algorithm without the memo.  The memo might make this solution look scary at first glance, however, this solution is fundamentally simple and concise.\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, min = Infinity) => {\\n        if (u == T)\\n            return 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return Infinity; // all k hops exhausted \\u274C\\n        for (let [v, w] of [...adj.get(u) || []])\\n            min = Math.min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return min;\\n    };\\n    return go() < Infinity ? go() : -1;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>; // u -> [v, w] == edge u -> v with cost w\\n    Adj adj;\\n    int T;\\n    static constexpr auto INF = int(1e9 + 7);\\n    int go(int u, int k, int min = INF) {\\n        if (u == T)\\n            return 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return INF; // all k hops exhaused \\u274C\\n        for (auto [v, w]: adj[u])\\n            min = std::min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return min;\\n    }\\npublic:\\n    int findCheapestPrice(int _, VVI& E, int start, int T_, int hops) {\\n        T = T_;\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto ans = go(start, hops + 1);\\n        return ans < INF ? ans : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #3:** Use [Bellman-Ford](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) to relax edges `u`,`v` of cost `w`\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (N, E, start, T, hops) => {\\n    let k = hops + 1;\\n    let pre = Array(N).fill(Infinity);\\n    pre[start] = 0;\\n    while (k--) { // relax all edges k times\\n        // bellman-ford: dist[v] = min(dist[v], dist[u] + w) ie. relax edge u,v of cost w\\n        // however, use previous and current to avoid overwritting our previous optimal edge relaxations\\n        // which we still need to read from in order to derive our current optimal edge relaxations for each k-th hop\\n        let cur = [...pre]; // derive current from previous \\uD83E\\uDD14 ie. update current optimal edge relaxations based upon previous optimal edge relaxations\\n        E.forEach(([u, v, w]) => cur[v] = Math.min(cur[v], pre[u] + w)); // relax all edges u,v of cost w for optimal distance to v \\uD83C\\uDFAF\\n        [pre, cur] = [cur, pre]; // persist current as previous via swap \\uD83E\\uDD14\\n    }\\n    return pre[T] < Infinity ? pre[T] : -1;\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findCheapestPrice(int N, VVI& E, int start, int T, int hops, int INF = int(1e9 + 7)) {\\n        auto k = hops + 1;\\n        VI pre(N, INF);\\n        pre[start] = 0;\\n        while (k--) { // relax all edges k times\\n            // bellman-ford: dist[v] = min(dist[v], dist[u] + w) ie. relax edge u,v of cost w\\n            // however, use previous and current to avoid overwritting our previous optimal edge relaxations\\n            // which we still need to read from in order to derive our current optimal edge relaxations for each k-th hop\\n            auto cur{ pre }; // derive current from previous \\uD83E\\uDD14 ie. update current optimal edge relaxations based upon previous optimal edge relaxations\\n            for (auto& edge: E) {\\n                auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w); // relax all edges u,v of cost w for optimal distance to v \\uD83C\\uDFAF\\n            }\\n            swap(pre, cur); // persist current as previous via swap \\uD83E\\uDD14\\n        }\\n        return pre[T] < INF ? pre[T] : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #4:** [SPFA](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm) is a natural progression from [Bellman-Ford](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm).  Simply enqueue each current relaxed edge for each next k-th hop of edge relaxations.  And process each k-th hop per queue length.  Thus, we only relax *relevant* edges with SPFA rather than relaxing *all* edges with BF.  Since the code changes from BF to SPFA is straightforward, I\\'ve omitted comments in these solutions.\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let k = hops + 1;\\n    let pre = Array(N).fill(Infinity);\\n    pre[start] = 0;\\n    let q = [ start ];\\n    while (k--) {\\n        let cur = [...pre];\\n        let len = q.length;\\n        while (len--) {\\n            let u = q.shift();\\n            for (let [v, w] of [...adj.get(u) || []])\\n                if (cur[v] > pre[u] + w)\\n                    cur[v] = pre[u] + w, q.push(v);\\n        }\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[T] < Infinity ? pre[T] : -1;\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>;\\n    int findCheapestPrice(int N, VVI& E, int start, int T, int hops, Adj adj = {}, int INF = int(1e9 + 7)) {\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto k = hops + 1;\\n        VI pre(N, INF);\\n        pre[start] = 0;\\n        queue<int> q{{ start }};\\n        while (k--) {\\n            auto cur{ pre };\\n            int len = q.size();\\n            while (len--) {\\n                auto u = q.front(); q.pop();\\n                for (auto [v, w]: adj[u])\\n                    if (cur[v] > pre[u] + w)\\n                        cur[v] = pre[u] + w, q.push(v);                \\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[T] < INF ? pre[T] : -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findCheapestPrice(N: Int, E: Array<IntArray>, S: Int, T: Int, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var pre = IntArray(N) { INF }; pre[S] = 0\\n        for (i in 0..K) {\\n            var cur = pre.copyOf()\\n            for ((u, v, w) in E)\\n                cur[v] = Math.min(cur[v], pre[u] + w)\\n            pre = cur\\n        }\\n        return if (pre[T] != INF) pre[T] else -1\\n    }\\n}\\n```\n```\\nlet findCheapestPrice = (N, E, S, T, K) => {\\n    let pre = Array(N).fill(Infinity); pre[S] = 0;\\n    while (0 <= K--) {\\n        let cur = [...pre];\\n        for (let [u, v, w] of E)\\n            cur[v] = Math.min(cur[v], pre[u] + w);\\n        pre = cur;\\n    }\\n    return pre[T] != Infinity ? pre[T] : -1;\\n};\\n```\n```\\nclass Solution:\\n    def findCheapestPrice(self, N: int, E: List[List[int]], S: int, T: int, K: int, INF = int(1e9 + 7)) -> int:\\n        pre = [INF] * N; pre[S] = 0\\n        for _ in range(K + 1):\\n            cur = pre[:]\\n            for u, v, w in E:\\n                cur[v] = min(cur[v], pre[u] + w)\\n            pre = cur\\n        return pre[T] if pre[T] != INF else -1\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn find_cheapest_price(N: i32, E: VVI, S: i32, T: i32, K: i32) -> i32 {\\n        let (N, S, T) = (N as usize, S as usize, T as usize);\\n        let INF = 1e9 as i32 + 7;\\n        let mut pre = vec![INF; N]; pre[S] = 0;\\n        for _ in 0..=K {\\n            let mut cur = pre.clone();\\n            for edge in &E {\\n                let (u, v, w) = (edge[0] as usize, edge[1] as usize, edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w);\\n            }\\n            pre = cur;\\n        }\\n        if pre[T] != INF { pre[T] } else { -1 }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findCheapestPrice(int N, VVI& E, int S, int T, int K, int INF = 1e9 + 7) {\\n        VI pre(N, INF); pre[S] = 0;\\n        while (0 <= K--) {\\n            VI cur{ pre };\\n            for (auto& edge: E) {\\n                auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[T] != INF ? pre[T] : -1;\\n    }\\n};\\n```\n```\\nlet findCheapestPrice = (_, E, start, T, hops, adj = new Map(), best = Infinity) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, cost = 0, seen = new Set()) => {\\n        if (u == T)\\n            best = Math.min(best, cost); // best is the minimum cost \\uD83C\\uDFAF\\n        if (u == T || !k)\\n            return; // destination reached or k-hops exhausted: stop \\uD83D\\uDED1\\n        seen.add(u); // \\uD83D\\uDC40 \\u2705 forward-tracking\\n        for (let [v, w] of [...adj.get(u) || []])\\n            if (!seen.has(v) && cost + w < best) // pruning condition: cost + w < best \\uD83E\\uDD14\\n                go(v, k - 1, cost + w, seen);\\n        seen.delete(u); // \\uD83D\\uDC40 \\u274C back-tracking\\n    };\\n    go();\\n    return best < Infinity ? best : -1;\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>;\\n    Adj adj;\\n    int T, best;\\n    void go(int u, int k, int cost = 0, Set&& seen = {}) {\\n        if (u == T)\\n            best = min(best, cost); // best is the minimum cost \\uD83C\\uDFAF\\n        if (u == T || !k)\\n            return; // target T destination reached or k-hops exhausted: stop \\uD83D\\uDED1\\n        seen.insert(u); // \\uD83D\\uDC40 \\u2705 forward-tracking\\n        for (auto [v, w]: adj[u])\\n            if (seen.find(v) == seen.end() && cost + w < best) // pruning condition: cost + w < best \\uD83E\\uDD14\\n                go(v, k - 1, cost + w, move(seen));\\n        seen.erase(u); // \\uD83D\\uDC40 \\u274C back-tracking\\n    }\\npublic:\\n    int findCheapestPrice(int _, VVI& E, int start, int T_, int hops, int INF = int(1e9 + 7)) {\\n        T = T_;\\n        best = INF;\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        go(start, hops + 1);\\n        return best < INF ? best : -1;\\n    }\\n};\\n```\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    let m = [...Array(N)].map(_ => Array(hops + 2).fill(-1)); // +2 because for V vertices there are V+1 edges and +1 for the memo itself to be 0..hops+1 inclusive\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, min = Infinity) => {\\n        if (m[u][k] > -1)\\n            return m[u][k]; // memo \\uD83E\\uDD14\\n        if (u == T)\\n            return m[u][k] = 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return m[u][k] = Infinity; // all k hops exhausted \\u274C\\n        for (let [v, w] of [...adj.get(u) || []])\\n            min = Math.min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return m[u][k] = min;\\n    };\\n    return go() < Infinity ? go() : -1;\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>; // u -> [v, w] == edge u -> v with cost w\\n    Adj adj;\\n    int T;\\n    VVI m;\\n    static constexpr auto INF = int(1e9 + 7);\\n    int go(int u, int k, int min = INF) {\\n        if (m[u][k] > -1)\\n            return m[u][k]; // memo \\uD83E\\uDD14\\n        if (u == T)\\n            return m[u][k] = 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return m[u][k] = INF; // all k hops exhausted \\u274C\\n        for (auto [v, w]: adj[u])\\n            min = std::min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return m[u][k] = min;\\n    }\\npublic:\\n    int findCheapestPrice(int N, VVI& E, int start, int T_, int hops) {\\n        T = T_;\\n        m = VVI(N, VI(hops + 2, -1)); // +2 because for V vertices there are V+1 edges and +1 for the memo itself to be 0..hops+1 inclusive\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto ans = go(start, hops + 1);\\n        return ans < INF ? ans : -1;\\n    }\\n};\\n```\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, min = Infinity) => {\\n        if (u == T)\\n            return 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return Infinity; // all k hops exhausted \\u274C\\n        for (let [v, w] of [...adj.get(u) || []])\\n            min = Math.min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return min;\\n    };\\n    return go() < Infinity ? go() : -1;\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>; // u -> [v, w] == edge u -> v with cost w\\n    Adj adj;\\n    int T;\\n    static constexpr auto INF = int(1e9 + 7);\\n    int go(int u, int k, int min = INF) {\\n        if (u == T)\\n            return 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return INF; // all k hops exhaused \\u274C\\n        for (auto [v, w]: adj[u])\\n            min = std::min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return min;\\n    }\\npublic:\\n    int findCheapestPrice(int _, VVI& E, int start, int T_, int hops) {\\n        T = T_;\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto ans = go(start, hops + 1);\\n        return ans < INF ? ans : -1;\\n    }\\n};\\n```\n```\\nlet findCheapestPrice = (N, E, start, T, hops) => {\\n    let k = hops + 1;\\n    let pre = Array(N).fill(Infinity);\\n    pre[start] = 0;\\n    while (k--) { // relax all edges k times\\n        // bellman-ford: dist[v] = min(dist[v], dist[u] + w) ie. relax edge u,v of cost w\\n        // however, use previous and current to avoid overwritting our previous optimal edge relaxations\\n        // which we still need to read from in order to derive our current optimal edge relaxations for each k-th hop\\n        let cur = [...pre]; // derive current from previous \\uD83E\\uDD14 ie. update current optimal edge relaxations based upon previous optimal edge relaxations\\n        E.forEach(([u, v, w]) => cur[v] = Math.min(cur[v], pre[u] + w)); // relax all edges u,v of cost w for optimal distance to v \\uD83C\\uDFAF\\n        [pre, cur] = [cur, pre]; // persist current as previous via swap \\uD83E\\uDD14\\n    }\\n    return pre[T] < Infinity ? pre[T] : -1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findCheapestPrice(int N, VVI& E, int start, int T, int hops, int INF = int(1e9 + 7)) {\\n        auto k = hops + 1;\\n        VI pre(N, INF);\\n        pre[start] = 0;\\n        while (k--) { // relax all edges k times\\n            // bellman-ford: dist[v] = min(dist[v], dist[u] + w) ie. relax edge u,v of cost w\\n            // however, use previous and current to avoid overwritting our previous optimal edge relaxations\\n            // which we still need to read from in order to derive our current optimal edge relaxations for each k-th hop\\n            auto cur{ pre }; // derive current from previous \\uD83E\\uDD14 ie. update current optimal edge relaxations based upon previous optimal edge relaxations\\n            for (auto& edge: E) {\\n                auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w); // relax all edges u,v of cost w for optimal distance to v \\uD83C\\uDFAF\\n            }\\n            swap(pre, cur); // persist current as previous via swap \\uD83E\\uDD14\\n        }\\n        return pre[T] < INF ? pre[T] : -1;\\n    }\\n};\\n```\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let k = hops + 1;\\n    let pre = Array(N).fill(Infinity);\\n    pre[start] = 0;\\n    let q = [ start ];\\n    while (k--) {\\n        let cur = [...pre];\\n        let len = q.length;\\n        while (len--) {\\n            let u = q.shift();\\n            for (let [v, w] of [...adj.get(u) || []])\\n                if (cur[v] > pre[u] + w)\\n                    cur[v] = pre[u] + w, q.push(v);\\n        }\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[T] < Infinity ? pre[T] : -1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>;\\n    int findCheapestPrice(int N, VVI& E, int start, int T, int hops, Adj adj = {}, int INF = int(1e9 + 7)) {\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto k = hops + 1;\\n        VI pre(N, INF);\\n        pre[start] = 0;\\n        queue<int> q{{ start }};\\n        while (k--) {\\n            auto cur{ pre };\\n            int len = q.size();\\n            while (len--) {\\n                auto u = q.front(); q.pop();\\n                for (auto [v, w]: adj[u])\\n                    if (cur[v] > pre[u] + w)\\n                        cur[v] = pre[u] + w, q.push(v);                \\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[T] < INF ? pre[T] : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688278,
                "title": "simple-bfs-variant-with-python3-o-n-2-time-and-space",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        for s, d, price in flights:\\n            graph[s].append((d, price))\\n        seen = [float(\\'inf\\')] * n\\n        seen[src] = 0\\n        q = deque([(src, -1, 0)])\\n        while q:\\n            node, stops, node_cost = q.popleft()\\n            if node == dst or stops == K:\\n                continue\\n            for nei, price in graph[node]:\\n                if (nei_cost := node_cost+price) >= seen[nei]:\\n                    continue\\n                seen[nei] = nei_cost\\n                q.append((nei, stops+1, nei_cost))\\n    \\n        return seen[dst] if seen[dst] != float(\\'inf\\') else -1\\n```\\n\\nFun fact: The number of this flight problem is 787 :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        for s, d, price in flights:\\n            graph[s].append((d, price))\\n        seen = [float(\\'inf\\')] * n\\n        seen[src] = 0\\n        q = deque([(src, -1, 0)])\\n        while q:\\n            node, stops, node_cost = q.popleft()\\n            if node == dst or stops == K:\\n                continue\\n            for nei, price in graph[node]:\\n                if (nei_cost := node_cost+price) >= seen[nei]:\\n                    continue\\n                seen[nei] = nei_cost\\n                q.append((nei, stops+1, nei_cost))\\n    \\n        return seen[dst] if seen[dst] != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687434,
                "title": "c-easy-solution-dfs",
                "content": "Time Complexity: **O(K * V * V)** in which V is the number of cities within the range K stops.\\n```\\npublic int FindCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n  var minCost = int.MaxValue;\\n  var adj = Enumerable.Range(0, n).ToDictionary(x => x, x => new List<(int, int)>());\\n  foreach(var f in flights) {\\n    adj[f[0]].Add((f[1],f[2]));\\n  }\\n\\n  var costs = new int[n];\\n  Array.Fill(costs, int.MaxValue);\\n  costs[src] = 0;\\n  //DFS(src, K + 1, 0);\\n  BFS();\\n\\n  return minCost == int.MaxValue ? -1 : minCost;\\n\\n  void DFS(int x, int k, int cost) {\\n    if (k < 0) return;\\n\\n    if (x == dst) {\\n      minCost = cost;\\n      return;\\n    }\\n\\n    if (!adj.ContainsKey(x)) return;\\n\\n    foreach (var neigbor in adj[x]) {\\n      var newCost = cost + neigbor.Item2;\\n      if (newCost > minCost || newCost > costs[neigbor.Item1]) continue;\\n\\n      costs[neigbor.Item1] = newCost;\\n      DFS(neigbor.Item1, k - 1, newCost);\\n    }\\n  }\\n\\n  void BFS() {\\n    var q = new Queue<int[]>();\\n    q.Enqueue(new[] {src, 0});\\n\\n    var stops = 0;\\n    while(q.Count > 0 && stops < K + 1){\\n      var cnt = q.Count;\\n      while(cnt > 0){\\n        cnt--;\\n        var node = q.Dequeue();       \\n\\n        foreach(var neigbor in adj[node[0]]){\\n          var cost = node[1] + neigbor.Item2;\\n          if(cost > minCost || cost > costs[neigbor.Item1]) continue;\\n\\n          if(neigbor.Item1 == dst){\\n            minCost = Math.Min(minCost, cost);\\n            continue;\\n          }          \\n\\n          costs[neigbor.Item1] = cost;          \\n          q.Enqueue(new[] {neigbor.Item1, cost});\\n        }\\n      }\\n      ++stops;\\n    }\\n  }    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic int FindCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n  var minCost = int.MaxValue;\\n  var adj = Enumerable.Range(0, n).ToDictionary(x => x, x => new List<(int, int)>());\\n  foreach(var f in flights) {\\n    adj[f[0]].Add((f[1],f[2]));\\n  }\\n\\n  var costs = new int[n];\\n  Array.Fill(costs, int.MaxValue);\\n  costs[src] = 0;\\n  //DFS(src, K + 1, 0);\\n  BFS();\\n\\n  return minCost == int.MaxValue ? -1 : minCost;\\n\\n  void DFS(int x, int k, int cost) {\\n    if (k < 0) return;\\n\\n    if (x == dst) {\\n      minCost = cost;\\n      return;\\n    }\\n\\n    if (!adj.ContainsKey(x)) return;\\n\\n    foreach (var neigbor in adj[x]) {\\n      var newCost = cost + neigbor.Item2;\\n      if (newCost > minCost || newCost > costs[neigbor.Item1]) continue;\\n\\n      costs[neigbor.Item1] = newCost;\\n      DFS(neigbor.Item1, k - 1, newCost);\\n    }\\n  }\\n\\n  void BFS() {\\n    var q = new Queue<int[]>();\\n    q.Enqueue(new[] {src, 0});\\n\\n    var stops = 0;\\n    while(q.Count > 0 && stops < K + 1){\\n      var cnt = q.Count;\\n      while(cnt > 0){\\n        cnt--;\\n        var node = q.Dequeue();       \\n\\n        foreach(var neigbor in adj[node[0]]){\\n          var cost = node[1] + neigbor.Item2;\\n          if(cost > minCost || cost > costs[neigbor.Item1]) continue;\\n\\n          if(neigbor.Item1 == dst){\\n            minCost = Math.Min(minCost, cost);\\n            continue;\\n          }          \\n\\n          costs[neigbor.Item1] = cost;          \\n          q.Enqueue(new[] {neigbor.Item1, cost});\\n        }\\n      }\\n      ++stops;\\n    }\\n  }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686787,
                "title": "python-super-short-o-k-len-flights-solution-with-o-n-space",
                "content": "(explanation in comment below)\\n```\\nclass Solution:\\n    import math\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        dist = [math.inf]*n\\n        dist[src] = 0\\n        for _ in range(K+1):\\n            olddist = dist[:]\\n            for f in flights:\\n                dist[f[1]] = min(dist[f[1]], olddist[f[0]] + f[2])\\n        return dist[dst] if dist[dst] < math.inf else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    import math\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        dist = [math.inf]*n\\n        dist[src] = 0\\n        for _ in range(K+1):\\n            olddist = dist[:]\\n            for f in flights:\\n                dist[f[1]] = min(dist[f[1]], olddist[f[0]] + f[2])\\n        return dist[dst] if dist[dst] < math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550074,
                "title": "simple-python-solution-with-explanation-using-min-heap-priority-queue-and-links-to-other-resources",
                "content": "```\\n# In this solution, we start at the \\'src\\' city and traverse to the next\\n# cities which have minimum cost and stops < k until we find our destination.\\n\\n# At first, you may be tempted to use a BFS and search the nodes in the queue \\n# with minimum cost. This should work but using a min heap is faster than a queue\\n# because it can give you the minimum element with O(1) time instead of O(n).\\n\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        \"\"\"\\n        :type n: int\\n        :type flights: List[List[int]]\\n        :type src: int\\n        :type dst: int\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Adjacency list as a hash map\\n        flight_map = collections.defaultdict(list)\\n        for origin, destination, cost in flights:\\n            flight_map[origin].append((destination,cost))\\n\\n        #Initially push \\'src\\' into the heap with stops=-1 and cost=0\\n        heap = []\\n        heapq.heappush(heap, (0,-1,src)) # (cost,stops,destination)\\n        visited = set() # Use a set to avoid unnecessary nodes in the heap, in case the graph has cycles\\n        while heap:\\n            cost, stops, city = heapq.heappop(heap)\\n            visited.add(city)\\n            \\n            if city == dst:\\n                return cost\\n            \\n            if stops < K: # can add another stop\\n                for next_city, flight_cost in flight_map[city]:\\n                    if next_city not in visited:\\n                        # pushes the next city into the heap and increse total cost and stops\\n                        heapq.heappush(heap, (cost+flight_cost,stops+1,next_city))\\n        \\n        return -1\\n```\\n\\nHeapq Python reference: https://docs.python.org/2/library/heapq.html\\n\\nIf you want to learn more about the theory behind heaps, check\\n out this video from Abdul Bari: https://www.youtube.com/watch?v=HqPJF2L5h9U&t=1s\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n# In this solution, we start at the \\'src\\' city and traverse to the next\\n# cities which have minimum cost and stops < k until we find our destination.\\n\\n# At first, you may be tempted to use a BFS and search the nodes in the queue \\n# with minimum cost. This should work but using a min heap is faster than a queue\\n# because it can give you the minimum element with O(1) time instead of O(n).\\n\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        \"\"\"\\n        :type n: int\\n        :type flights: List[List[int]]\\n        :type src: int\\n        :type dst: int\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Adjacency list as a hash map\\n        flight_map = collections.defaultdict(list)\\n        for origin, destination, cost in flights:\\n            flight_map[origin].append((destination,cost))\\n\\n        #Initially push \\'src\\' into the heap with stops=-1 and cost=0\\n        heap = []\\n        heapq.heappush(heap, (0,-1,src)) # (cost,stops,destination)\\n        visited = set() # Use a set to avoid unnecessary nodes in the heap, in case the graph has cycles\\n        while heap:\\n            cost, stops, city = heapq.heappop(heap)\\n            visited.add(city)\\n            \\n            if city == dst:\\n                return cost\\n            \\n            if stops < K: # can add another stop\\n                for next_city, flight_cost in flight_map[city]:\\n                    if next_city not in visited:\\n                        # pushes the next city into the heap and increse total cost and stops\\n                        heapq.heappush(heap, (cost+flight_cost,stops+1,next_city))\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434585,
                "title": "java-dijkstra-s-algorithm-clean-and-easy-to-understand",
                "content": "The idea is Dijkstra\\'s Algorithm. However, we need to modify it. \\n\\n**Brief Explanation of Correctness:**\\nThe proof of Dijkstra\\'s Algorithm will not be repeated here. We just say that the original graph G can be modified into a subgraph G\\' where only the nodes and edges can be visited in (K+1) steps are kept (not sure if dst is included).\\n\\nIf we run Dijkstra\\'s on subgraph G\\' and dst is in G\\', it should be shortest path from src to dst.\\n\\n**Algorithm:**\\nInitially push the src into the heap\\nfor every step:\\n    1. check if the current top element in heap is dst. If so return its costFromSrc;\\n    2. Push every adjacent edge into the heap if the distance is less than k;\\n    3. If it is larger than k, no more neighbors get pushed into the heap;\\nIf until the end, we cannot find dst, return -1;\\n\\n```java\\nclass Pair {\\n\\tint city, cost;\\n\\n\\tPair(int city, int cost) {\\n\\t\\tthis.city = city;\\n\\t\\tthis.cost = cost;\\n\\t}\\n}\\n\\nclass City {\\n\\tint city, distFromSrc, costFromSrc;\\n\\n\\tCity(int city, int distFromSrc, int cost) {\\n\\t\\tthis.city = city;\\n\\t\\tthis.distFromSrc = distFromSrc;\\n\\t\\tthis.costFromSrc = cost;\\n\\t}\\n}\\n\\nclass Solution {\\n\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n    \\t// DFS\\n        if(n <= 0 || flights == null || flights.length == 0 || K < 0)\\n        \\treturn -1;\\n\\n        List<List<Pair>> graph = new ArrayList<>();\\n        this.buildGraph(graph, n, flights);\\n\\n        Queue<City> pQueue = new PriorityQueue<>((City c1, City c2) -> c1.costFromSrc - c2.costFromSrc);\\n        pQueue.offer(new City(src, 0, 0));\\n\\n        int totalCost = 0;\\n\\n        while (!pQueue.isEmpty()) {\\n        \\tCity top = pQueue.poll();\\n\\n        \\tif (top.city == dst) {\\n        \\t\\treturn top.costFromSrc;\\n        \\t}\\n\\n        \\tif (top.distFromSrc > K) {\\n        \\t\\tcontinue;\\n        \\t}\\n\\n        \\tList<Pair> neighbors = graph.get(top.city);\\n        \\tfor (Pair neighbor: neighbors) {\\n        \\t\\tpQueue.offer(new City(neighbor.city, top.distFromSrc + 1, top.costFromSrc + neighbor.cost));\\n        \\t}\\n        }\\n\\n        return -1;\\n    }\\n\\n    private void buildGraph(List<List<Pair>> graph, int n, int[][] flights) {\\n    \\tfor (int i = 0; i < n; i++) {\\n    \\t\\tgraph.add(new ArrayList<>());\\n    \\t}\\n\\n    \\tfor (int[] flight: flights) {\\n    \\t\\tgraph.get(flight[0]).add(new Pair(flight[1], flight[2]));\\n    \\t}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Pair {\\n\\tint city, cost;\\n\\n\\tPair(int city, int cost) {\\n\\t\\tthis.city = city;\\n\\t\\tthis.cost = cost;\\n\\t}\\n}\\n\\nclass City {\\n\\tint city, distFromSrc, costFromSrc;\\n\\n\\tCity(int city, int distFromSrc, int cost) {\\n\\t\\tthis.city = city;\\n\\t\\tthis.distFromSrc = distFromSrc;\\n\\t\\tthis.costFromSrc = cost;\\n\\t}\\n}\\n\\nclass Solution {\\n\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n    \\t// DFS\\n        if(n <= 0 || flights == null || flights.length == 0 || K < 0)\\n        \\treturn -1;\\n\\n        List<List<Pair>> graph = new ArrayList<>();\\n        this.buildGraph(graph, n, flights);\\n\\n        Queue<City> pQueue = new PriorityQueue<>((City c1, City c2) -> c1.costFromSrc - c2.costFromSrc);\\n        pQueue.offer(new City(src, 0, 0));\\n\\n        int totalCost = 0;\\n\\n        while (!pQueue.isEmpty()) {\\n        \\tCity top = pQueue.poll();\\n\\n        \\tif (top.city == dst) {\\n        \\t\\treturn top.costFromSrc;\\n        \\t}\\n\\n        \\tif (top.distFromSrc > K) {\\n        \\t\\tcontinue;\\n        \\t}\\n\\n        \\tList<Pair> neighbors = graph.get(top.city);\\n        \\tfor (Pair neighbor: neighbors) {\\n        \\t\\tpQueue.offer(new City(neighbor.city, top.distFromSrc + 1, top.costFromSrc + neighbor.cost));\\n        \\t}\\n        }\\n\\n        return -1;\\n    }\\n\\n    private void buildGraph(List<List<Pair>> graph, int n, int[][] flights) {\\n    \\tfor (int i = 0; i < n; i++) {\\n    \\t\\tgraph.add(new ArrayList<>());\\n    \\t}\\n\\n    \\tfor (int[] flight: flights) {\\n    \\t\\tgraph.get(flight[0]).add(new Pair(flight[1], flight[2]));\\n    \\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371274,
                "title": "java-dijikstra",
                "content": "```\\nclass CustomComp implements Comparator<int[]>{\\n    public int compare(int[] a, int[] b){\\n        return a[0] - b[0];\\n    }\\n}\\nclass Solution {\\n    ArrayList<int[]>[] graph;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] flight: flights){\\n            graph[flight[0]].add(new int[]{flight[1], flight[2]});\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new CustomComp());\\n        pq.offer(new int[]{0, src, K+1});\\n        while(!pq.isEmpty()){\\n            int[] cur = pq.poll();\\n            if(cur[1] == dst) return cur[0];\\n            if(cur[2]>0){\\n                for(int[] nxt: graph[cur[1]]){\\n                    pq.offer(new int[]{cur[0]+nxt[1], nxt[0], cur[2]-1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomComp implements Comparator<int[]>{\\n    public int compare(int[] a, int[] b){\\n        return a[0] - b[0];\\n    }\\n}\\nclass Solution {\\n    ArrayList<int[]>[] graph;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] flight: flights){\\n            graph[flight[0]].add(new int[]{flight[1], flight[2]});\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new CustomComp());\\n        pq.offer(new int[]{0, src, K+1});\\n        while(!pq.isEmpty()){\\n            int[] cur = pq.poll();\\n            if(cur[1] == dst) return cur[0];\\n            if(cur[2]>0){\\n                for(int[] nxt: graph[cur[1]]){\\n                    pq.offer(new int[]{cur[0]+nxt[1], nxt[0], cur[2]-1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234286,
                "title": "javascript-solution",
                "content": "```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    const graph = buildGraph(flights)\\n\\n    const queue = []\\n    queue.push([src, 0])\\n    \\n    let minCost = Infinity\\n    \\n    for (let stopsRemain = K + 1; stopsRemain >= 0; stopsRemain--) {\\n        let levelSize = queue.length\\n        for (let i = 0; i < levelSize; i++) {\\n            let [cur, costSoFar] = queue.shift()\\n            \\n            if (costSoFar > minCost) {\\n                continue\\n            }\\n            \\n            if (cur === dst) {\\n                minCost = Math.min(minCost, costSoFar)\\n                continue\\n            }\\n            \\n            let neighbors = graph[cur] || []\\n            for (let [nei, cost] of neighbors) {\\n                queue.push([nei, costSoFar + cost])\\n            }\\n        }\\n    }\\n    \\n    return minCost === Infinity ? -1 : minCost\\n};\\n\\nfunction buildGraph(edges) {\\n    const graph = {}\\n    for (let [src, dst, w] of edges) {\\n        graph[src] = graph[src] || []\\n        graph[src].push([dst, w])\\n    }\\n    return graph\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    const graph = buildGraph(flights)\\n\\n    const queue = []\\n    queue.push([src, 0])\\n    \\n    let minCost = Infinity\\n    \\n    for (let stopsRemain = K + 1; stopsRemain >= 0; stopsRemain--) {\\n        let levelSize = queue.length\\n        for (let i = 0; i < levelSize; i++) {\\n            let [cur, costSoFar] = queue.shift()\\n            \\n            if (costSoFar > minCost) {\\n                continue\\n            }\\n            \\n            if (cur === dst) {\\n                minCost = Math.min(minCost, costSoFar)\\n                continue\\n            }\\n            \\n            let neighbors = graph[cur] || []\\n            for (let [nei, cost] of neighbors) {\\n                queue.push([nei, costSoFar + cost])\\n            }\\n        }\\n    }\\n    \\n    return minCost === Infinity ? -1 : minCost\\n};\\n\\nfunction buildGraph(edges) {\\n    const graph = {}\\n    for (let [src, dst, w] of edges) {\\n        graph[src] = graph[src] || []\\n        graph[src].push([dst, w])\\n    }\\n    return graph\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125551,
                "title": "easy-understanding-dp-in-java-o-n-n-k-9ms",
                "content": "It is obvious that filights within **K** stops is cheaper than **K-1** stops. So there is a very simple DP idea. We maintain a table DP\\\\[K]\\\\[N]. We could deduce K from K-1 as code below.\\n```\\n   public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int matrix[][] = new int[n][n];\\n        for (int i=0; i < flights.length; i++) {\\n            matrix[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        //dp[k][i] stores min value from src to i, when k stops are reached\\n        int dp[][] = new int[K+1][n];\\n        for (int i = 0; i<n; i++) {\\n            if(matrix[src][i] > 0)\\n                dp[0][i] = matrix[src][i];\\n            else \\n                dp[0][i] = Integer.MAX_VALUE;\\n        }\\n        \\n        int k=1;\\n        for (; k <=K; k++) {\\n            boolean changed = false;\\n            for (int i=0; i <n; i++) {\\n                dp[k][i] = dp[k-1][i];\\n                for (int j=0; j<n; j++) {\\n                    if (j != i) {\\n                        if ( dp[k-1][j] != Integer.MAX_VALUE && matrix[j][i] != 0) {\\n                            if (dp[k][i] > dp[k-1][j]+matrix[j][i]) {\\n                                dp[k][i] = dp[k-1][j]+matrix[j][i];\\n                                changed = true;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            if (!changed) break;\\n        }\\n        k = Integer.min(K, k);\\n        return  dp[k][dst] == Integer.MAX_VALUE ? -1: dp[k][dst];\\n    }\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n   public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int matrix[][] = new int[n][n];\\n        for (int i=0; i < flights.length; i++) {\\n            matrix[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        //dp[k][i] stores min value from src to i, when k stops are reached\\n        int dp[][] = new int[K+1][n];\\n        for (int i = 0; i<n; i++) {\\n            if(matrix[src][i] > 0)\\n                dp[0][i] = matrix[src][i];\\n            else \\n                dp[0][i] = Integer.MAX_VALUE;\\n        }\\n        \\n        int k=1;\\n        for (; k <=K; k++) {\\n            boolean changed = false;\\n            for (int i=0; i <n; i++) {\\n                dp[k][i] = dp[k-1][i];\\n                for (int j=0; j<n; j++) {\\n                    if (j != i) {\\n                        if ( dp[k-1][j] != Integer.MAX_VALUE && matrix[j][i] != 0) {\\n                            if (dp[k][i] > dp[k-1][j]+matrix[j][i]) {\\n                                dp[k][i] = dp[k-1][j]+matrix[j][i];\\n                                changed = true;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            if (!changed) break;\\n        }\\n        k = Integer.min(K, k);\\n        return  dp[k][dst] == Integer.MAX_VALUE ? -1: dp[k][dst];\\n    }\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3224322,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static class pair{\\n        int v , w ;\\n        pair( int v , int w )\\n        {\\n            this.v = v ;\\n            this.w = w ;\\n        }\\n    }\\n    static class tuple{\\n        int  n , stops , cost ;\\n        tuple( int  n ,int stops ,int cost)\\n        {\\n            this.n = n ;\\n            this.stops = stops ;\\n            this.cost = cost;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        ArrayList<ArrayList<pair>> adj = new ArrayList<>();\\n        for (int i = 0; i < n  ; i++) {\\n            adj.add( new ArrayList<>());\\n        }\\n        for (int i = 0; i < flights.length; i++) {\\n            adj.get( flights[i][0] ).add( new pair( flights[i][1] , flights[i][2] ) );\\n        }\\n\\n        int dis[] = new int[n];\\n        Arrays.fill( dis , Integer.MAX_VALUE);\\n        dis[src] = 0 ;\\n\\n        Queue<tuple> q = new LinkedList<>();\\n        q.add( new tuple(src , 0 , 0 ));\\n        while (!q.isEmpty())\\n        {\\n            tuple t = q.poll();\\n            int u = t.n;\\n            int stops = t.stops;\\n            int cost = t.cost ;\\n\\n            if( stops>k ) continue;\\n\\n            for (int i = 0; i < adj.get(u).size(); i++) {\\n                int v = adj.get(u).get(i).v;\\n                int w = adj.get(u).get(i).w;\\n\\n                if( cost+w < dis[v] && stops<=k )\\n                {\\n                    dis[v] = cost+w;\\n                    q.add( new tuple(v , stops+1 , dis[v] ));\\n                }\\n            }\\n\\n        }\\n\\n        if( dis[dst] ==Integer.MAX_VALUE) return -1 ;\\n        else return dis[dst] ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static class pair{\\n        int v , w ;\\n        pair( int v , int w )\\n        {\\n            this.v = v ;\\n            this.w = w ;\\n        }\\n    }\\n    static class tuple{\\n        int  n , stops , cost ;\\n        tuple( int  n ,int stops ,int cost)\\n        {\\n            this.n = n ;\\n            this.stops = stops ;\\n            this.cost = cost;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        ArrayList<ArrayList<pair>> adj = new ArrayList<>();\\n        for (int i = 0; i < n  ; i++) {\\n            adj.add( new ArrayList<>());\\n        }\\n        for (int i = 0; i < flights.length; i++) {\\n            adj.get( flights[i][0] ).add( new pair( flights[i][1] , flights[i][2] ) );\\n        }\\n\\n        int dis[] = new int[n];\\n        Arrays.fill( dis , Integer.MAX_VALUE);\\n        dis[src] = 0 ;\\n\\n        Queue<tuple> q = new LinkedList<>();\\n        q.add( new tuple(src , 0 , 0 ));\\n        while (!q.isEmpty())\\n        {\\n            tuple t = q.poll();\\n            int u = t.n;\\n            int stops = t.stops;\\n            int cost = t.cost ;\\n\\n            if( stops>k ) continue;\\n\\n            for (int i = 0; i < adj.get(u).size(); i++) {\\n                int v = adj.get(u).get(i).v;\\n                int w = adj.get(u).get(i).w;\\n\\n                if( cost+w < dis[v] && stops<=k )\\n                {\\n                    dis[v] = cost+w;\\n                    q.add( new tuple(v , stops+1 , dis[v] ));\\n                }\\n            }\\n\\n        }\\n\\n        if( dis[dst] ==Integer.MAX_VALUE) return -1 ;\\n        else return dis[dst] ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101972,
                "title": "striver-concept-modified-dijkstra-algorithm",
                "content": "# Intuition\\nReading the problem description itself class for a classical dijkstra algorithm. The only modification is the restriction of a maximum number of flights that we can take. If you don\\'t know Dijkstra, check it out in the Leetcode Explore-Cards or somewhere else.\\n\\nDijkstra is basically a modified BFS through a graph, where instead of the queue, we use a priority queue or heap tho push and get our next position from.\\n\\nThis enables us to always reach nodes with their lowest cost first, if we use cost as the key for the min-heap/priority queue.\\n\\nIn this questions there is one additional problem: Normally we terminate Dijkstra as soon as we reach a node that already has been processed, because we already found the lowest cost for travelling to this one.\\n\\nHere this would cause problem, since we could maybe travel cheaper to a certain city, but exceeded or really stressed our maximum number of flights.\\n\\nTherefore we terminate Dijkstra not on the lowest found cost but on the number of flight we took to get there. Still, because of the heap condition, we can terminate as soon as we reach the destination node as this will be guaranteed with the lowest cost (if the number of flights is acceptable, we should check that before exiting).\\n\\nThis will cause us to visit a node a maximum of K instead of only one time, but that is a tradeoff we need to make.\\n\\n\\n# Approach\\n\\nModified Dijkstra (termination condition modified). Also keep in mind that the number of flights taken is the the number of cities visited - 1.\\n> Quote\\n\\n# Code\\n```\\nfrom heapq import *\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(dict)\\n        for u, v, p in flights:\\n            graph[u][v] = p\\n        \\n        seen = {}\\n        pq = []\\n        heappush(pq, (0, 0, src))\\n        \\n        while pq:\\n            cost, hops, city = heappop(pq)\\n            seen[city] = hops\\n            \\n            if city == dst:\\n                return cost\\n            \\n            if hops > k:\\n                continue\\n            \\n            for next_city, next_cost in graph[city].items():\\n                if next_city in seen and seen[next_city] <= hops:\\n                    continue\\n                heappush(pq, (cost + next_cost, hops + 1, next_city))\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(dict)\\n        for u, v, p in flights:\\n            graph[u][v] = p\\n        \\n        seen = {}\\n        pq = []\\n        heappush(pq, (0, 0, src))\\n        \\n        while pq:\\n            cost, hops, city = heappop(pq)\\n            seen[city] = hops\\n            \\n            if city == dst:\\n                return cost\\n            \\n            if hops > k:\\n                continue\\n            \\n            for next_city, next_cost in graph[city].items():\\n                if next_city in seen and seen[next_city] <= hops:\\n                    continue\\n                heappush(pq, (cost + next_cost, hops + 1, next_city))\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101838,
                "title": "python-simple-python-solution-using-bfs-graph",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 104 ms, faster than 91.42% of Python3 online submissions for Cheapest Flights Within K Stops.\\n# Memory Usage: 15.3 MB, less than 54.38% of Python3 online submissions for Cheapest Flights Within K Stops.\\n\\n\\tclass Solution:\\n\\t\\tdef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n\\t\\t\\tgraph = {}\\n\\n\\t\\t\\tfor city in range(n):\\n\\t\\t\\t\\tgraph[city] = []\\n\\n\\t\\t\\tfor flight in flights:\\n\\n\\t\\t\\t\\tsource, destination , price = flight\\n\\n\\t\\t\\t\\tgraph[source].append((destination, price))\\n\\n\\t\\t\\tdq = deque()\\n\\t\\t\\tdq.append((0 , src, 0))\\n\\n\\t\\t\\tprice = [10000000] * n\\n\\t\\t\\tprice[src] = 0\\n\\n\\t\\t\\twhile dq:\\n\\n\\t\\t\\t\\tcurrent_stop , current_city , current_price = dq.popleft()\\n\\n\\t\\t\\t\\tif current_stop > k:\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tfor next_city, cost in graph[current_city]:\\n\\n\\t\\t\\t\\t\\tif current_price + cost < price[next_city]:\\n\\t\\t\\t\\t\\t\\tprice[next_city] = current_price + cost\\n\\n\\t\\t\\t\\t\\t\\tdq.append((current_stop + 1, next_city , price[next_city]))\\n\\n\\t\\t\\tif price[dst] == 10000000:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn price[dst]\\n\\t\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution:\\n\\t\\tdef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n\\t\\t\\tgraph = {}",
                "codeTag": "Java"
            },
            {
                "id": 3100917,
                "title": "java-easy-solution-upvote-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   Relaxing the edge\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   Bellman Ford\\n   ![WhatsApp Image 2023-01-26 at 13.46.58.jpeg](https://assets.leetcode.com/users/images/d48374f6-69b5-41ce-a3d1-84d6eabaf86a_1674721102.0172527.jpeg)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n     O(K*E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(N)\\n                           Upvote it\\n![1725_upvote.png](https://assets.leetcode.com/users/images/aa0ae41f-b9a1-4f7a-b2cc-3a3e76f2743d_1674721466.8494942.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n       int cost[] = new int[n];\\n       Arrays.fill(cost, Integer.MAX_VALUE);\\n       cost[src] = 0;\\n       int count = 0;\\n       int tempcost[] = cost.clone();\\n       while(count <= k)\\n       {\\n           tempcost = cost.clone();\\n           for(int[] flight : flights)\\n           {\\n               int s = flight[0];\\n               int d = flight[1];\\n               int c = flight[2];\\n\\n               if(cost[s] != Integer.MAX_VALUE && (cost[s] + c ) < tempcost[d])\\n               {\\n                   tempcost[d] = cost[s] + c;\\n               }\\n           }\\n           cost = tempcost;\\n           count++;\\n       }\\n       if(cost[dst] == Integer.MAX_VALUE)\\n       {\\n           return -1;\\n       }\\n       return cost[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n       int cost[] = new int[n];\\n       Arrays.fill(cost, Integer.MAX_VALUE);\\n       cost[src] = 0;\\n       int count = 0;\\n       int tempcost[] = cost.clone();\\n       while(count <= k)\\n       {\\n           tempcost = cost.clone();\\n           for(int[] flight : flights)\\n           {\\n               int s = flight[0];\\n               int d = flight[1];\\n               int c = flight[2];\\n\\n               if(cost[s] != Integer.MAX_VALUE && (cost[s] + c ) < tempcost[d])\\n               {\\n                   tempcost[d] = cost[s] + c;\\n               }\\n           }\\n           cost = tempcost;\\n           count++;\\n       }\\n       if(cost[dst] == Integer.MAX_VALUE)\\n       {\\n           return -1;\\n       }\\n       return cost[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100885,
                "title": "java-solution-explained",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int first, second;\\n        public Pair(int first, int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    class Tuple {\\n        int first, second, third;\\n        Tuple(int first, int second, int third){\\n            this.first = first;\\n            this.second = second;\\n            this.third = third;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        // we need to store the Adjacent nodes and edge weights.\\n        // so we need Pair.\\n        List<List<Pair>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        int m = flights.length;\\n        for(int i = 0; i < m; i++){\\n            adj.get(flights[i][0]).add(new Pair(flights[i][1], flights[i][2]));\\n        }\\n        Queue<Tuple> q = new LinkedList<>();\\n        // {stops, {node, dist}}\\n        q.add(new Tuple(0, src, 0));\\n        // declear the distance array. with same size n.\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, (int) 1e9);\\n        // distance to source is 0.\\n        dist[src] = 0;\\n        // T -> O(n) = E = flights.size().\\n        while(!q.isEmpty()){\\n            Tuple it = q.remove();\\n            int stops = it.first;\\n            int node = it.second;\\n            int cost = it.third;\\n            // if stops is greater then k mean no need to go further.\\n            if(stops > k) continue;\\n            for(Pair iter: adj.get(node)){\\n                // Adjacent node.\\n                int adjNode = iter.first;\\n                // edge weight.\\n                int edW = iter.second;\\n                // if cost + edge weight is < then distance of adjacent node && stops <= k.\\n                // mean we have to update our distance array.\\n                if(cost + edW < dist[adjNode] && stops <= k){\\n                    dist[adjNode] = cost + edW;\\n                    // increment the stops by 1, \\n                    // adjacent node,\\n                    // cost + edge weight.\\n                    q.add(new Tuple(stops + 1, adjNode, cost + edW));\\n                }\\n            }\\n        }\\n        // if the distance to destination is 1e9 means we never reach so, return -1.\\n        if(dist[dst] == (int) 1e9) return -1;\\n        return dist[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int first, second;\\n        public Pair(int first, int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    class Tuple {\\n        int first, second, third;\\n        Tuple(int first, int second, int third){\\n            this.first = first;\\n            this.second = second;\\n            this.third = third;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        // we need to store the Adjacent nodes and edge weights.\\n        // so we need Pair.\\n        List<List<Pair>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        int m = flights.length;\\n        for(int i = 0; i < m; i++){\\n            adj.get(flights[i][0]).add(new Pair(flights[i][1], flights[i][2]));\\n        }\\n        Queue<Tuple> q = new LinkedList<>();\\n        // {stops, {node, dist}}\\n        q.add(new Tuple(0, src, 0));\\n        // declear the distance array. with same size n.\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, (int) 1e9);\\n        // distance to source is 0.\\n        dist[src] = 0;\\n        // T -> O(n) = E = flights.size().\\n        while(!q.isEmpty()){\\n            Tuple it = q.remove();\\n            int stops = it.first;\\n            int node = it.second;\\n            int cost = it.third;\\n            // if stops is greater then k mean no need to go further.\\n            if(stops > k) continue;\\n            for(Pair iter: adj.get(node)){\\n                // Adjacent node.\\n                int adjNode = iter.first;\\n                // edge weight.\\n                int edW = iter.second;\\n                // if cost + edge weight is < then distance of adjacent node && stops <= k.\\n                // mean we have to update our distance array.\\n                if(cost + edW < dist[adjNode] && stops <= k){\\n                    dist[adjNode] = cost + edW;\\n                    // increment the stops by 1, \\n                    // adjacent node,\\n                    // cost + edge weight.\\n                    q.add(new Tuple(stops + 1, adjNode, cost + edW));\\n                }\\n            }\\n        }\\n        // if the distance to destination is 1e9 means we never reach so, return -1.\\n        if(dist[dst] == (int) 1e9) return -1;\\n        return dist[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100612,
                "title": "recursion-memoization-tabulation-space-optimization",
                "content": "# Upvote if you my Like Solution\\n\\n# 1. Intuition : Recursion\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Recursion Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int k, int src, int dst, int n, vector<vector<int>>& adj) {\\n        // Base Case\\n        if(k < 0) return 1e7;\\n        if(src == dst) return 0;\\n\\n        // Recursive Case\\n        int ans = 1e7;\\n        for(int i = 0; i < n; i++) {\\n            if(adj[src][i] != -1) ans = min(ans, adj[src][i]+f(k-1, i, dst, n, adj));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        int val = f(k+1, src, dst, n, adj);\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\\n\\n# 2. Intuition : Memoization\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O((k+1)*(n^2)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) + O((k+2)*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Memoization Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int stops, int source, int destination, int n, vector<vector<int>>& adj, vector<vector<int>>& dp) {\\n        // Base Case\\n        if(stops < 0) return 1e7;\\n        if(source == destination) return 0;\\n\\n        // Recursive Case\\n        if(dp[stops][source] != -1) return dp[stops][source];\\n        int ans = 1e7;\\n        for(int i = 0; i < n; i++) {\\n            if(adj[source][i] != -1) ans = min(ans, adj[source][i]+f(stops-1, i, destination, n, adj, dp));\\n        }\\n\\n        return dp[stops][source] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<vector<int>> dp(k+2, vector<int> (n, -1));\\n        int val = f(k+1, src, dst, n, adj, dp);\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\\n\\n# 3. Intuition : Tabulation\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O((k+1)*(n^2)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O((k+2)*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Tabulation Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<vector<int>> dp(k+2, vector<int> (n, 0));\\n\\n        for(int stops = 0; stops <= k+1; stops++) {\\n            for(int source = n-1; source >= 0; source--) {\\n                if(source == dst) dp[stops][source] = 0;\\n                else {\\n                    int ans = 1e7;\\n                    for(int i = 0; i < n; i++) {\\n                        if(adj[source][i] != -1) {\\n                            int tp = (stops == 0 ? 1e7 : adj[source][i]+dp[stops-1][i]);\\n                            ans = min(ans, tp);\\n                        }\\n                    }\\n                    dp[stops][source] = ans;\\n                }\\n            }\\n        }\\n\\n        int val = dp[k+1][src];\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\\n\\n# 4. Intuition : Space Optimization\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O((k+1)*(n^2)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Space Optimization Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<int> prev(n, 0), cur(n, 0);\\n\\n        for(int stops = 0; stops <= k+1; stops++) {\\n            for(int source = n-1; source >= 0; source--) {\\n                if(source == dst) cur[source] = 0;\\n                else {\\n                    int ans = 1e7;\\n                    for(int i = 0; i < n; i++) {\\n                        if(adj[source][i] != -1) {\\n                            int tp = (stops == 0 ? 1e7 : adj[source][i]+prev[i]);\\n                            ans = min(ans, tp);\\n                        }\\n                    }\\n                    cur[source] = ans;\\n                }\\n            }\\n            prev = cur;\\n        }\\n\\n        int val = prev[src];\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(int k, int src, int dst, int n, vector<vector<int>>& adj) {\\n        // Base Case\\n        if(k < 0) return 1e7;\\n        if(src == dst) return 0;\\n\\n        // Recursive Case\\n        int ans = 1e7;\\n        for(int i = 0; i < n; i++) {\\n            if(adj[src][i] != -1) ans = min(ans, adj[src][i]+f(k-1, i, dst, n, adj));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        int val = f(k+1, src, dst, n, adj);\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int f(int stops, int source, int destination, int n, vector<vector<int>>& adj, vector<vector<int>>& dp) {\\n        // Base Case\\n        if(stops < 0) return 1e7;\\n        if(source == destination) return 0;\\n\\n        // Recursive Case\\n        if(dp[stops][source] != -1) return dp[stops][source];\\n        int ans = 1e7;\\n        for(int i = 0; i < n; i++) {\\n            if(adj[source][i] != -1) ans = min(ans, adj[source][i]+f(stops-1, i, destination, n, adj, dp));\\n        }\\n\\n        return dp[stops][source] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<vector<int>> dp(k+2, vector<int> (n, -1));\\n        int val = f(k+1, src, dst, n, adj, dp);\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<vector<int>> dp(k+2, vector<int> (n, 0));\\n\\n        for(int stops = 0; stops <= k+1; stops++) {\\n            for(int source = n-1; source >= 0; source--) {\\n                if(source == dst) dp[stops][source] = 0;\\n                else {\\n                    int ans = 1e7;\\n                    for(int i = 0; i < n; i++) {\\n                        if(adj[source][i] != -1) {\\n                            int tp = (stops == 0 ? 1e7 : adj[source][i]+dp[stops-1][i]);\\n                            ans = min(ans, tp);\\n                        }\\n                    }\\n                    dp[stops][source] = ans;\\n                }\\n            }\\n        }\\n\\n        int val = dp[k+1][src];\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<int> prev(n, 0), cur(n, 0);\\n\\n        for(int stops = 0; stops <= k+1; stops++) {\\n            for(int source = n-1; source >= 0; source--) {\\n                if(source == dst) cur[source] = 0;\\n                else {\\n                    int ans = 1e7;\\n                    for(int i = 0; i < n; i++) {\\n                        if(adj[source][i] != -1) {\\n                            int tp = (stops == 0 ? 1e7 : adj[source][i]+prev[i]);\\n                            ans = min(ans, tp);\\n                        }\\n                    }\\n                    cur[source] = ans;\\n                }\\n            }\\n            prev = cur;\\n        }\\n\\n        int val = prev[src];\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100357,
                "title": "happy-republic-day-my-java-o-n-k-solution-using-memoization",
                "content": "\\n# Approach\\nUsed Recursion to go through all possible paths from source to destination, and took the price with the most minimum value\\nRecursion was giving TLE as expected\\nSo we have to take a dp of 2-dimensions to eliminate TLE\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] a, int src, int dst, int k) {\\n        List<List<List<Integer>>> graph = new ArrayList<>();\\n        int i,m=a.length;\\n        for(i=0;i<n;i++)\\n            graph.add(new ArrayList<>());\\n        for(i=0;i<m;i++)\\n        {\\n            ArrayList<Integer> tmp=new ArrayList<>();\\n            tmp.add(a[i][1]); tmp.add(a[i][2]);\\n            graph.get(a[i][0]).add(tmp);\\n        }\\n        int dp[][]=new int[n][k+2];\\n        for(int it[]:dp)\\n        Arrays.fill(it,-1);\\n        int ans=dfs(graph,src,dst,k+1,dp);\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n    public int dfs(List<List<List<Integer>>> graph,int src,int dst,int k,int dp[][])\\n    {\\n        if(k<0)  return Integer.MAX_VALUE;\\n        if(src==dst) return 0;\\n        if(dp[src][k]!=-1) return dp[src][k];\\n        int min=Integer.MAX_VALUE;\\n        for(List<Integer> it:graph.get(src))\\n        {\\n            int cho=it.get(0); int price=it.get(1);\\n            int cheap=dfs(graph,cho,dst,k-1,dp);\\n            if(cheap!=Integer.MAX_VALUE)\\n            min=Math.min(min,cheap+price);\\n        }\\n        return dp[src][k]=min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] a, int src, int dst, int k) {\\n        List<List<List<Integer>>> graph = new ArrayList<>();\\n        int i,m=a.length;\\n        for(i=0;i<n;i++)\\n            graph.add(new ArrayList<>());\\n        for(i=0;i<m;i++)\\n        {\\n            ArrayList<Integer> tmp=new ArrayList<>();\\n            tmp.add(a[i][1]); tmp.add(a[i][2]);\\n            graph.get(a[i][0]).add(tmp);\\n        }\\n        int dp[][]=new int[n][k+2];\\n        for(int it[]:dp)\\n        Arrays.fill(it,-1);\\n        int ans=dfs(graph,src,dst,k+1,dp);\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n    public int dfs(List<List<List<Integer>>> graph,int src,int dst,int k,int dp[][])\\n    {\\n        if(k<0)  return Integer.MAX_VALUE;\\n        if(src==dst) return 0;\\n        if(dp[src][k]!=-1) return dp[src][k];\\n        int min=Integer.MAX_VALUE;\\n        for(List<Integer> it:graph.get(src))\\n        {\\n            int cho=it.get(0); int price=it.get(1);\\n            int cheap=dfs(graph,cho,dst,k-1,dp);\\n            if(cheap!=Integer.MAX_VALUE)\\n            min=Math.min(min,cheap+price);\\n        }\\n        return dp[src][k]=min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100109,
                "title": "rust-elixir-solutions",
                "content": "Was going for a DP approach, but seems that they are officially called Bellman-Ford algorithm.\\n# Rust\\n```rust\\nimpl Solution {\\n    pub fn find_cheapest_price(n: i32, flights: Vec<Vec<i32>>, src: i32, dst: i32, k: i32) -> i32 {\\n        let mut adj = vec![Vec::new(); n as usize];\\n        for v in flights.iter() {\\n            adj[v[0] as usize].push((v[1] as usize, v[2]));\\n        }\\n        let mut cost = vec![i32::MAX; n as usize];\\n        cost[src as usize] = 0;\\n        for _ in 0..=k {\\n            let mut cost2 = cost.clone();\\n            for i in 0..n as usize {\\n                if cost[i] != i32::MAX {\\n                    for &(j, price) in adj[i].iter() {\\n                        cost2[j] = cost2[j].min(cost[i] + price);\\n                    }\\n                }\\n            }\\n            cost = cost2;\\n        }\\n        match cost[dst as usize] {\\n            i32::MAX => -1,\\n            x => x,\\n        }\\n    }\\n}\\n```\\n# Elixir\\nNot building the adjacency list and just iterate through `flights`.\\nThe result code is very compact.\\n```elixir\\ndefmodule Solution do\\n  @spec find_cheapest_price(n :: integer, flights :: [[integer]], src :: integer, dst :: integer, k :: integer) :: integer\\n  def find_cheapest_price(n, flights, src, dst, k) do\\n    Enum.reduce(0..k, %{src => 0}, fn _, cost ->\\n      Enum.reduce(flights, cost, fn [i, j, price], cost2 ->\\n        case Map.get(cost, i) do\\n          nil -> cost2\\n          x -> Map.update(cost2, j, x + price, &(min(&1, x + price)))\\n        end\\n      end)\\n    end)\\n    |> Map.get(dst, -1)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn find_cheapest_price(n: i32, flights: Vec<Vec<i32>>, src: i32, dst: i32, k: i32) -> i32 {\\n        let mut adj = vec![Vec::new(); n as usize];\\n        for v in flights.iter() {\\n            adj[v[0] as usize].push((v[1] as usize, v[2]));\\n        }\\n        let mut cost = vec![i32::MAX; n as usize];\\n        cost[src as usize] = 0;\\n        for _ in 0..=k {\\n            let mut cost2 = cost.clone();\\n            for i in 0..n as usize {\\n                if cost[i] != i32::MAX {\\n                    for &(j, price) in adj[i].iter() {\\n                        cost2[j] = cost2[j].min(cost[i] + price);\\n                    }\\n                }\\n            }\\n            cost = cost2;\\n        }\\n        match cost[dst as usize] {\\n            i32::MAX => -1,\\n            x => x,\\n        }\\n    }\\n}\\n```\n```elixir\\ndefmodule Solution do\\n  @spec find_cheapest_price(n :: integer, flights :: [[integer]], src :: integer, dst :: integer, k :: integer) :: integer\\n  def find_cheapest_price(n, flights, src, dst, k) do\\n    Enum.reduce(0..k, %{src => 0}, fn _, cost ->\\n      Enum.reduce(flights, cost, fn [i, j, price], cost2 ->\\n        case Map.get(cost, i) do\\n          nil -> cost2\\n          x -> Map.update(cost2, j, x + price, &(min(&1, x + price)))\\n        end\\n      end)\\n    end)\\n    |> Map.get(dst, -1)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3100092,
                "title": "python-sort-dfs-136-ms-faster-than-67-24",
                "content": "**Solution 1: DFS**\\nhttps://leetcode.com/submissions/detail/885406469/\\nRuntime: **136 ms**, faster than 67.24% of Python3 online submissions for Cheapest Flights Within K Stops.\\nMemory Usage: 15.2 MB, less than 54.38% of Python3 online submissions for Cheapest Flights Within K Stops.\\nP.S. If it is not sorted, the runtime would be around **1521 ms**.\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        NO_ROUTE = -1\\n        frs, tos = defaultdict(list), set() ## convert flights to dictionary/set form\\n        flights.sort(key=lambda x:x[2], reverse=True)\\n        for fr,to,price in flights:\\n            frs[fr].append([to, price])\\n            tos.add(to)\\n        if src not in frs or dst not in tos: return NO_ROUTE ## early exit\\n        \\n        cheapest, l = float(\\'inf\\'), [[t,p,0] for t,p in frs[src]]\\n        while l: ## dfs\\n            to, price, stop = l.pop()\\n            if price>=cheapest: continue\\n            if to==dst: \\n                cheapest = price\\n            elif stop<k and to in frs:\\n                for t,p in frs[to]:\\n                    if price+p<cheapest:\\n                        l += [[t, price+p, stop+1]]\\n        return cheapest if cheapest!=float(\\'inf\\') else NO_ROUTE\\n```\\n\\n**Solution 2: naive BFS, Memory Limit Exceeded**\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        NO_ROUTE = -1\\n        \\n        fs = dict() ## convert flights to dictionary form\\n        for fr,to,price in flights:\\n            if fr in fs:\\n                fs[fr].append([to, price])\\n            else:\\n                fs[fr] = [[to, price]]\\n                \\n        if src not in fs: return NO_ROUTE ## edge case\\n        \\n        cheapest, l = None, fs[src]\\n        for i in range(k+1):\\n            if not l: break\\n            l_new = []\\n            for t1,p1 in l:\\n                if t1==dst: \\n                    cheapest = min(cheapest,p1) if cheapest else p1\\n                elif i<=k and t1 in fs: \\n                    l_new += [[t2,p1+p2] for t2,p2 in fs[t1]]\\n            l = l_new.copy()\\n        return cheapest if cheapest else NO_ROUTE\\n```\\nP.S. A working BFS solution would be like these. A cheaper route to a city must be always updated.\\nhttps://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/3100018/Python-BFS-solution\\nhttps://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/3100076/Python3-O(N-%2B-EK)-BFS\\n\\n**Large test cases**\\nhttps://leetcode.com/submissions/detail/885388076/testcase/  \\nhttps://leetcode.com/submissions/detail/885396480/testcase/",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        NO_ROUTE = -1\\n        frs, tos = defaultdict(list), set() ## convert flights to dictionary/set form\\n        flights.sort(key=lambda x:x[2], reverse=True)\\n        for fr,to,price in flights:\\n            frs[fr].append([to, price])\\n            tos.add(to)\\n        if src not in frs or dst not in tos: return NO_ROUTE ## early exit\\n        \\n        cheapest, l = float(\\'inf\\'), [[t,p,0] for t,p in frs[src]]\\n        while l: ## dfs\\n            to, price, stop = l.pop()\\n            if price>=cheapest: continue\\n            if to==dst: \\n                cheapest = price\\n            elif stop<k and to in frs:\\n                for t,p in frs[to]:\\n                    if price+p<cheapest:\\n                        l += [[t, price+p, stop+1]]\\n        return cheapest if cheapest!=float(\\'inf\\') else NO_ROUTE\\n```\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        NO_ROUTE = -1\\n        \\n        fs = dict() ## convert flights to dictionary form\\n        for fr,to,price in flights:\\n            if fr in fs:\\n                fs[fr].append([to, price])\\n            else:\\n                fs[fr] = [[to, price]]\\n                \\n        if src not in fs: return NO_ROUTE ## edge case\\n        \\n        cheapest, l = None, fs[src]\\n        for i in range(k+1):\\n            if not l: break\\n            l_new = []\\n            for t1,p1 in l:\\n                if t1==dst: \\n                    cheapest = min(cheapest,p1) if cheapest else p1\\n                elif i<=k and t1 in fs: \\n                    l_new += [[t2,p1+p2] for t2,p2 in fs[t1]]\\n            l = l_new.copy()\\n        return cheapest if cheapest else NO_ROUTE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099840,
                "title": "let-s-learn-kotlin-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS through the graph, keeping a state value of `(location, cost_so_far, stops_so_far)` in the queue.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Construct the `graph` for BFS. Specifically, for each node, we need to know all of its outgoing flights and how much they cost.\\n2. Instantiate a global array to track the `cheapest` means of arrival at each node.\\n3. At each iteration of BFS, disregard if the stops or cost are too high. Otherwise, update `cheapest` and add all the adjacent nodes to the queue.\\n    - Note: I initially set `stops = -1`. This is because `k` is being used to count the maximum number of layovers and arriving at your destination doesn\\'t count. So, if `k = 0`, we want to make sure a single iteration of BFS is still run.    \\n4. Return the cost to get to `dst` if we were able to get there.\\n\\n#### Disclaimer\\n@artemasoyan has a better [solution](https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/2877062/kotlin-belman-ford/) using the Bellman-Ford algorithm, which all the top submissions are copying. BFS here is a more standard approach, only ~20ms slower, and realistic to be expected in an interview. \\n\\n# Complexity\\n- Time complexity: $$O(N + F*K)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N + F*K)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun findCheapestPrice(n: Int, flights: Array<IntArray>, src: Int, dst: Int, k: Int): Int {\\n        // Build graph\\n        val graph: Array<MutableList<IntArray>> = Array(n) { mutableListOf<IntArray>() }\\n        for ((from, to, cost) in flights) {\\n            graph[from].add(intArrayOf(to, cost))\\n        }\\n\\n        // BFS\\n        var cheapest = IntArray(n) { Int.MAX_VALUE }\\n        var queue = LinkedList<IntArray>()\\n        queue.add(intArrayOf(src, 0, -1))\\n        while (queue.isNotEmpty()) {\\n            val (loc, cost, stops) = queue.poll()\\n            if (stops > k || cost >= cheapest[loc]) {\\n                continue\\n            }\\n            cheapest[loc] = cost\\n            for ((dest, price) in graph[loc]) {\\n                queue.add(intArrayOf(dest, cost + price, stops + 1))\\n            }\\n        }\\n        return if (cheapest[dst] == Int.MAX_VALUE) -1 else cheapest[dst]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    fun findCheapestPrice(n: Int, flights: Array<IntArray>, src: Int, dst: Int, k: Int): Int {\\n        // Build graph\\n        val graph: Array<MutableList<IntArray>> = Array(n) { mutableListOf<IntArray>() }\\n        for ((from, to, cost) in flights) {\\n            graph[from].add(intArrayOf(to, cost))\\n        }\\n\\n        // BFS\\n        var cheapest = IntArray(n) { Int.MAX_VALUE }\\n        var queue = LinkedList<IntArray>()\\n        queue.add(intArrayOf(src, 0, -1))\\n        while (queue.isNotEmpty()) {\\n            val (loc, cost, stops) = queue.poll()\\n            if (stops > k || cost >= cheapest[loc]) {\\n                continue\\n            }\\n            cheapest[loc] = cost\\n            for ((dest, price) in graph[loc]) {\\n                queue.add(intArrayOf(dest, cost + price, stops + 1))\\n            }\\n        }\\n        return if (cheapest[dst] == Int.MAX_VALUE) -1 else cheapest[dst]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066930,
                "title": "beats-95-most-efficient-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& f, int src, int dst, int k) {\\n        queue<pair<int,pair<int,int>>>pq;\\n        vector<int>dist(n,1e9);\\n        pq.push({0,{0,src}});\\n        vector<vector<pair<int,int>>>v(n+1);\\n        for(int i=0;i<f.size();i++){\\n            v[f[i][0]].push_back({f[i][1],f[i][2]});\\n        }\\n        // for(int i=0;i<n;i++)\\n        while(pq.empty()==false){\\n            auto x=pq.front();\\n            int stop=x.first;\\n            int dis=x.second.first;\\n            int node=x.second.second;\\n            pq.pop();\\n            if(stop>k) continue;\\n            for(auto it:v[node]){\\n                if(dis+it.second<dist[it.first] && stop<=k){\\n                    dist[it.first]=dis+it.second;\\n                    pq.push({stop+1,{dist[it.first],it.first}});   \\n                }   \\n            }\\n        }\\n        if(dist[dst]==1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& f, int src, int dst, int k) {\\n        queue<pair<int,pair<int,int>>>pq;\\n        vector<int>dist(n,1e9);\\n        pq.push({0,{0,src}});\\n        vector<vector<pair<int,int>>>v(n+1);\\n        for(int i=0;i<f.size();i++){\\n            v[f[i][0]].push_back({f[i][1],f[i][2]});\\n        }\\n        // for(int i=0;i<n;i++)\\n        while(pq.empty()==false){\\n            auto x=pq.front();\\n            int stop=x.first;\\n            int dis=x.second.first;\\n            int node=x.second.second;\\n            pq.pop();\\n            if(stop>k) continue;\\n            for(auto it:v[node]){\\n                if(dis+it.second<dist[it.first] && stop<=k){\\n                    dist[it.first]=dis+it.second;\\n                    pq.push({stop+1,{dist[it.first],it.first}});   \\n                }   \\n            }\\n        }\\n        if(dist[dst]==1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065571,
                "title": "swift-bfs",
                "content": "**BFS (accepted answer)**\\n```\\nclass Solution {\\n    func findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ k: Int) -> Int {\\n        let graph = flights.reduce(into: [Int: [(Int, cost: Int)]]()) { graph, weightedEdge in\\n            graph[weightedEdge[1], default:.init()].append((weightedEdge[0], weightedEdge[2]))\\n        }\\n        \\n        var cheapestPrice = Int.max\\n        var stops = 0\\n        var bfs = [(dst, 0)]\\n        while !bfs.isEmpty && stops <= k {\\n            bfs = bfs.flatMap { cur in\\n                (graph[cur.0] ?? []).compactMap { next in\\n                    let newCost = cur.1 + next.1\\n                    guard newCost < cheapestPrice else { return nil }\\n                    if next.0 == src {\\n                        cheapestPrice = min(cheapestPrice, newCost)\\n                        return nil\\n                    }\\n                    return (next.0, newCost)\\n                }\\n            }\\n            stops += 1\\n        }\\n        return cheapestPrice == Int.max ? -1 : cheapestPrice\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ k: Int) -> Int {\\n        let graph = flights.reduce(into: [Int: [(Int, cost: Int)]]()) { graph, weightedEdge in\\n            graph[weightedEdge[1], default:.init()].append((weightedEdge[0], weightedEdge[2]))\\n        }\\n        \\n        var cheapestPrice = Int.max\\n        var stops = 0\\n        var bfs = [(dst, 0)]\\n        while !bfs.isEmpty && stops <= k {\\n            bfs = bfs.flatMap { cur in\\n                (graph[cur.0] ?? []).compactMap { next in\\n                    let newCost = cur.1 + next.1\\n                    guard newCost < cheapestPrice else { return nil }\\n                    if next.0 == src {\\n                        cheapestPrice = min(cheapestPrice, newCost)\\n                        return nil\\n                    }\\n                    return (next.0, newCost)\\n                }\\n            }\\n            stops += 1\\n        }\\n        return cheapestPrice == Int.max ? -1 : cheapestPrice\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877062,
                "title": "kotlin-belman-ford",
                "content": "```kotlin\\nclass Solution {\\n    fun findCheapestPrice(n: Int, flights: Array<IntArray>, src: Int, dst: Int, k: Int): Int {\\n        var dist = IntArray(n) { Int.MAX_VALUE }\\n        dist[src] = 0\\n        \\n        for (i in 0..k) {\\n            val temp = dist.copyOf()\\n            flights.forEach { (from, to, cost) -> \\n                if (dist[from] == Int.MAX_VALUE) return@forEach                \\n                temp[to] = Math.min(temp[to], dist[from] + cost)    \\n            }\\n            dist = temp\\n        }\\n        return if (dist[dst] == Int.MAX_VALUE) -1 else dist[dst]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun findCheapestPrice(n: Int, flights: Array<IntArray>, src: Int, dst: Int, k: Int): Int {\\n        var dist = IntArray(n) { Int.MAX_VALUE }\\n        dist[src] = 0\\n        \\n        for (i in 0..k) {\\n            val temp = dist.copyOf()\\n            flights.forEach { (from, to, cost) -> \\n                if (dist[from] == Int.MAX_VALUE) return@forEach                \\n                temp[to] = Math.min(temp[to], dist[from] + cost)    \\n            }\\n            dist = temp\\n        }\\n        return if (dist[dst] == Int.MAX_VALUE) -1 else dist[dst]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860363,
                "title": "dijkstra-s-algorithm-beats-90",
                "content": "\\n# Code\\n```\\nclass Tuple\\n{\\n    int stops;\\n    int node;\\n    int dist;\\n    public Tuple(int s,int node,int dis)\\n    {\\n        stops=s;\\n        this.node=node;\\n        dist=dis;\\n    }\\n}\\nclass Pairs\\n{\\n    int stop;\\n    int distance;\\n    public Pairs(int s,int d)\\n    {\\n        stop=s;\\n        distance=d;\\n    }\\n}\\nclass Solution \\n{\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) \\n    {\\n        List<List<Pairs>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)  adj.add(new ArrayList<Pairs>());\\n\\n        for(int i=0;i<flights.length;i++)\\n            adj.get(flights[i][0]).add(new Pairs(flights[i][1],flights[i][2]));\\n        \\n        //since we use priorityQueue on K, which increaeses by K+1\\n        //we can use a queue instead of a PQ\\n        //the least K stays at the top\\n        //PQ adds extra time complexity\\n        Queue<Tuple> queue=new LinkedList<>();\\n        int[] dist=new int[n];\\n        Tuple start=new Tuple(0,src,0);\\n        queue.add(start);\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n\\n        while(!queue.isEmpty())\\n        {\\n            Tuple top=queue.peek();\\n            queue.remove();\\n            int stops=top.stops;\\n            int node=top.node;\\n            int distance=top.dist;\\n            for(Pairs curr : adj.get(node))\\n            {\\n                int destination=curr.stop;\\n                int amount=curr.distance;\\n                //reaching the destination dosent count as K+1\\n                if(stops<=k && dist[destination]>distance+amount)\\n                {\\n                    dist[destination]=distance+amount;\\n                    queue.add(new Tuple(stops+1,destination,distance+amount));\\n                }\\n            }\\n        }\\n        int ans=dist[dst];\\n        return (ans==Integer.MAX_VALUE) ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Tuple\\n{\\n    int stops;\\n    int node;\\n    int dist;\\n    public Tuple(int s,int node,int dis)\\n    {\\n        stops=s;\\n        this.node=node;\\n        dist=dis;\\n    }\\n}\\nclass Pairs\\n{\\n    int stop;\\n    int distance;\\n    public Pairs(int s,int d)\\n    {\\n        stop=s;\\n        distance=d;\\n    }\\n}\\nclass Solution \\n{\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) \\n    {\\n        List<List<Pairs>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)  adj.add(new ArrayList<Pairs>());\\n\\n        for(int i=0;i<flights.length;i++)\\n            adj.get(flights[i][0]).add(new Pairs(flights[i][1],flights[i][2]));\\n        \\n        //since we use priorityQueue on K, which increaeses by K+1\\n        //we can use a queue instead of a PQ\\n        //the least K stays at the top\\n        //PQ adds extra time complexity\\n        Queue<Tuple> queue=new LinkedList<>();\\n        int[] dist=new int[n];\\n        Tuple start=new Tuple(0,src,0);\\n        queue.add(start);\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n\\n        while(!queue.isEmpty())\\n        {\\n            Tuple top=queue.peek();\\n            queue.remove();\\n            int stops=top.stops;\\n            int node=top.node;\\n            int distance=top.dist;\\n            for(Pairs curr : adj.get(node))\\n            {\\n                int destination=curr.stop;\\n                int amount=curr.distance;\\n                //reaching the destination dosent count as K+1\\n                if(stops<=k && dist[destination]>distance+amount)\\n                {\\n                    dist[destination]=distance+amount;\\n                    queue.add(new Tuple(stops+1,destination,distance+amount));\\n                }\\n            }\\n        }\\n        int ans=dist[dst];\\n        return (ans==Integer.MAX_VALUE) ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826119,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        queue<array<int,3>> pq;\\n        \\n        pq.push({0,src,0});\\n        \\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        vector<vector<int>> adj[n];\\n        \\n        for(auto i : flights)\\n        {\\n            int x = i[0], y = i[1], wt = i[2];\\n            \\n            adj[x].push_back({y,wt});\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            auto node = pq.front();\\n            pq.pop();\\n            \\n            int u = node[1];\\n            int steps = node[2];\\n            int d = node[0];\\n            \\n            if(steps>k)\\n                continue;\\n            \\n            for(auto i : adj[u])\\n            {\\n                int v = i[0];\\n                int wt = i[1];\\n                \\n                if(dist[v] > wt+d && steps<=k)\\n                {\\n                    dist[v] = wt+d;\\n                    pq.push({dist[v],v,steps+1});\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        return dist[dst] == 1e9 ? -1 : dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        queue<array<int,3>> pq;\\n        \\n        pq.push({0,src,0});\\n        \\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        vector<vector<int>> adj[n];\\n        \\n        for(auto i : flights)\\n        {\\n            int x = i[0], y = i[1], wt = i[2];\\n            \\n            adj[x].push_back({y,wt});\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            auto node = pq.front();\\n            pq.pop();\\n            \\n            int u = node[1];\\n            int steps = node[2];\\n            int d = node[0];\\n            \\n            if(steps>k)\\n                continue;\\n            \\n            for(auto i : adj[u])\\n            {\\n                int v = i[0];\\n                int wt = i[1];\\n                \\n                if(dist[v] > wt+d && steps<=k)\\n                {\\n                    dist[v] = wt+d;\\n                    pq.push({dist[v],v,steps+1});\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        return dist[dst] == 1e9 ? -1 : dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808078,
                "title": "c-max-heap-solution-dijkstra-s-algorithm",
                "content": "\\n**<<<<<<<UpVote**\\n\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto flight : flights){\\n            adj[flight[0]].push_back({flight[1],flight[2]});\\n        }\\n        // {distance,{destination,stops}}\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        pq.push({0,{src,0}});\\n        vector<int> distance(n+1,1e9);\\n        distance[src]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int dist= it.first;\\n            int curLoc=it.second.first;\\n            int stops=it.second.second;\\n            pq.pop();\\n            for(auto loc : adj[curLoc] ){\\n                if((dist+loc.second) < distance[loc.first] && (stops+1)<=k+1){\\n                    distance[loc.first]=dist+loc.second;\\n                    pq.push ({distance[loc.first],{loc.first,stops+1}});\\n                    \\n                }\\n            }\\n        }\\n        return  distance[dst]==1e9?-1:distance[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto flight : flights){\\n            adj[flight[0]].push_back({flight[1],flight[2]});\\n        }\\n        // {distance,{destination,stops}}\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        pq.push({0,{src,0}});\\n        vector<int> distance(n+1,1e9);\\n        distance[src]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int dist= it.first;\\n            int curLoc=it.second.first;\\n            int stops=it.second.second;\\n            pq.pop();\\n            for(auto loc : adj[curLoc] ){\\n                if((dist+loc.second) < distance[loc.first] && (stops+1)<=k+1){\\n                    distance[loc.first]=dist+loc.second;\\n                    pq.push ({distance[loc.first],{loc.first,stops+1}});\\n                    \\n                }\\n            }\\n        }\\n        return  distance[dst]==1e9?-1:distance[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435316,
                "title": "standard-bellman-ford-algo-easy-explanation",
                "content": "Idea behind Belloman ford algorithm:\\n\\t**If a vertex is `k` edges away from source, it\\'s shortest path can found in `k` iterations (or Ralaxes).**\\n\\nAlgorithm:\\n`Instead N-1 iterate for k+1 (because for k stops there will be k+2 nodes in the path from src to dst).`\\n\\nwe took temp array in code to store distance because we only have to update distance of node if it is atmost i away.\\nEx. let\\'s say edegs 1->2 and 2->3\\nif we dont take temp array then in the first iteration itself distance of node 3 will get updated, As when 2->3 edge come distance of node 2 is already updated.\\n\\n\\nPlease upvote if it helps!!\\n\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n        for(int i=0; i<=k; i++) {\\n            vector<int> temp(dist);\\n            for(auto &e: flights) {\\n                int u = e[0], v = e[1], w = e[2];\\n                if(dist[u] != INT_MAX && temp[v] > dist[u] + w) temp[v] = dist[u] + w;\\n            }\\n            dist = temp;\\n        }\\n        //please upvote!\\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n        for(int i=0; i<=k; i++) {\\n            vector<int> temp(dist);\\n            for(auto &e: flights) {\\n                int u = e[0], v = e[1], w = e[2];\\n                if(dist[u] != INT_MAX && temp[v] > dist[u] + w) temp[v] = dist[u] + w;\\n            }\\n            dist = temp;\\n        }\\n        //please upvote!\\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564581,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1704521,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774750,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1714552,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774778,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1574329,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1566952,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1567042,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774631,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1775170,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1564581,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1704521,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774750,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1714552,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774778,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1574329,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1566952,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1567042,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774631,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1775170,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1755433,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1775622,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1775341,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1774793,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1575891,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1569551,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1775590,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1774973,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1774869,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1774857,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1774662,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 1654496,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 2064270,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 2052131,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 2050858,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 2028947,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 2013521,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 1973786,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 1963735,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 1958406,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 1951494,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1932453,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1919808,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1886820,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1870785,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1844052,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1842309,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1821968,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1814208,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1803634,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1779717,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775728,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775567,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775557,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775546,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775541,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775282,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775173,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775159,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775110,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775092,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1775069,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1775037,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1775020,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774954,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774950,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774847,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774810,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774807,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774801,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            }
        ]
    }
]