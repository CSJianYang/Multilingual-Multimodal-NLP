[
    {
        "title": "Substring XOR Queries",
        "question_content": "You are given a binary string s, and a 2D integer array queries where queries[i] = [firsti, secondi].\nFor the ith query, find the shortest substring of s whose decimal value, val, yields secondi when bitwise XORed with firsti. In other words, val ^ firsti == secondi.\nThe answer to the ith query is the endpoints (0-indexed) of the substring [lefti, righti] or [-1, -1] if no such substring exists. If there are multiple answers, choose the one with the minimum lefti.\nReturn an array ans where ans[i] = [lefti, righti] is the answer to the ith query.\nA substring is a contiguous non-empty sequence of characters within a string.\n&nbsp;\nExample 1:\n\nInput: s = \"101101\", queries = [[0,5],[1,2]]\nOutput: [[0,2],[2,3]]\nExplanation: For the first query the substring in range [0,2] is \"101\" which has a decimal value of 5, and 5 ^ 0 = 5, hence the answer to the first query is [0,2]. In the second query, the substring in range [2,3] is \"11\", and has a decimal value of 3, and 3 ^ 1 = 2.&nbsp;So, [2,3] is returned for the second query. \n\nExample 2:\n\nInput: s = \"0101\", queries = [[12,8]]\nOutput: [[-1,-1]]\nExplanation: In this example there is no substring that answers the query, hence [-1,-1] is returned.\n\nExample 3:\n\nInput: s = \"1\", queries = [[4,5]]\nOutput: [[0,0]]\nExplanation: For this example, the substring in range [0,0] has a decimal value of 1, and 1 ^ 4 = 5. So, the answer is [0,0].\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 104\n\ts[i] is either '0' or '1'.\n\t1 <= queries.length <= 105\n\t0 <= firsti, secondi <= 109",
        "solutions": [
            {
                "id": 3174092,
                "title": "o-32-n-hash-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Our numbers can be between $$ 0<=num<=2^{31} $$.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n* For this question, we are given the hint that $$lefti=10^9$$ and $$righti <=10^9$$\\n\\n* So we can simply simulate the answer and for ith index we will check its next 31 values if we encounter a number .\\n* We will store it in the map only if it was not present in the map previously\\nthis way we have found all possible substrings as per the conditions specified in the question\\n\\n* now for $$query[i]$$, we know that ` val^lefti = righti `can be written as `val= lefti^righti`.\\n* So simply loop through the query and find whether that element is present in the map.\\n* If the `lefti^righti` of `query[i]` is present then push the map value in the answer array\\nelse push `{-1,-1}` in the answer.\\n\\n# Complexity\\n- Time complexity:`O(32*n)`\\n- Space complexity:`O(32*n)` (worst case)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- - Space complexity:`O(32*n)` (worst case) -->\\n\\n# Code\\n```\\n#define ll long long \\n#define pii pair<int,int>\\n#define f first\\n#define s second\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& qu) \\n    {\\n        int n=s.size(),q=qu.size();\\n        vector<vector<int>>ans;  \\n        unordered_map<ll,pii>map;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                if(!map.count(0)) map[0]=make_pair(i,i);\\n                continue;\\n            }\\n            long long num=0;\\n            for(int j=i;j<=min(i+32,n-1);j++){\\n                num = (num << 1) + (s[j] - \\'0\\');\\n                if(!map.count(num)) map[num] = make_pair(i,j);                \\n            }\\n        }\\n        for(int i=0;i<q;i++){\\n            int num=qu[i][0] ^ qu[i][1];\\n            if(map.count(num)) ans.push_back({map[num].f,map[num].s});\\n            else   ans.push_back({-1,-1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\n#define ll long long \\n#define pii pair<int,int>\\n#define f first\\n#define s second\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& qu) \\n    {\\n        int n=s.size(),q=qu.size();\\n        vector<vector<int>>ans;  \\n        unordered_map<ll,pii>map;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                if(!map.count(0)) map[0]=make_pair(i,i);\\n                continue;\\n            }\\n            long long num=0;\\n            for(int j=i;j<=min(i+32,n-1);j++){\\n                num = (num << 1) + (s[j] - \\'0\\');\\n                if(!map.count(num)) map[num] = make_pair(i,j);                \\n            }\\n        }\\n        for(int i=0;i<q;i++){\\n            int num=qu[i][0] ^ qu[i][1];\\n            if(map.count(num)) ans.push_back({map[num].f,map[num].s});\\n            else   ans.push_back({-1,-1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174169,
                "title": "python-hashmap",
                "content": "# **Intuition**\\n`val ^ first == second`\\n`val ^ first ^ first == second ^ first`\\n`val == second ^ first`\\n<br>\\n\\n# **Solution 1: TLE**\\nFor each query `[first, second]`,\\ncalculate `val = second ^ first`\\nand `val` binary string `x`.\\n\\nFind the `i = s.find(x)`,\\nif `i < 0`, `x` not a substring of `s`\\nif `i >= 0`, `x` not a substring of `s`.\\nreturn the position of first subtstring `x` in `s`.\\n<br>\\n\\nTime `O(30QN)`\\nSpace `O(30Q)`\\nwhere `N = s.length`\\n\\nFor each query,\\nfind a string with length at most 30 in `s`,\\ncomplexity is `O(30N)`.\\n<br>\\n\\n**Python**\\n```py\\n    def substringXorQueries(self, s, queries):\\n        res = []\\n        for fir, sec in queries:\\n            x = bin(sec ^ fir)[2:]\\n            i = s.find(x)\\n            res += [[-1, -1]] if i < 0 else [[i, i + len(x) - 1]]\\n        return res\\n```\\n<br>\\n\\n# Solution 2: HashMap\\nCalculate the value for all bianry string\\nand record in a hashmap `seen`.\\n\\nFor each query `[first, second]`,\\ncalculate `val = second ^ first`\\nand return `seen[val]`.\\n\\nIf never seen, return the default value `[-1,-1]`\\n\\nTime `O(30N + Q)`\\nSpace `O(30N)`\\nwhere `N = s.length`\\n\\n```py\\n    def substringXorQueries(self, s, queries):\\n        n = len(s)\\n        seen = defaultdict(lambda: [-1, -1])\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'0\\':\\n                seen[0] = [i, i]\\n                continue\\n            v = 0\\n            for j in range(i, n):\\n                v = v * 2 + int(s[j])\\n                if v > 2 ** 32: break\\n                seen[v] = [i, j]\\n        return [seen[sec ^ fir] for fir, sec in queries]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```py\\n    def substringXorQueries(self, s, queries):\\n        res = []\\n        for fir, sec in queries:\\n            x = bin(sec ^ fir)[2:]\\n            i = s.find(x)\\n            res += [[-1, -1]] if i < 0 else [[i, i + len(x) - 1]]\\n        return res\\n```\n```py\\n    def substringXorQueries(self, s, queries):\\n        n = len(s)\\n        seen = defaultdict(lambda: [-1, -1])\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'0\\':\\n                seen[0] = [i, i]\\n                continue\\n            v = 0\\n            for j in range(i, n):\\n                v = v * 2 + int(s[j])\\n                if v > 2 ** 32: break\\n                seen[v] = [i, j]\\n        return [seen[sec ^ fir] for fir, sec in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3174035,
                "title": "hashmap-o-n-30",
                "content": "This looks like O(n * n), but since queries are integers, it is O(n * 30). We process each substring, and add it\\'s value to a hashmap with {i, j} as a value.\\n\\nWhen we process queries, we look for the `q[0] ^ q[1]` value in the hashmap (since `q[0] ^ q[0] ^ q[1] == q[1]`).\\n\\n> Check out the alternative solution below where we reverse these steps.\\n\\nCaveats:\\n- We skip substrings starting with `0` so that we store shortest substrings for each value.\\n- We map the very first substring to a value (so that we store minimum `left_i`).\\n- We need a special handing for `0` value - we map it to `{i, i}`, where `i` is the smallest index when `s[i] == \\'0\\'`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        m = defaultdict(lambda: [-1, -1])\\n        for i, ch in enumerate(s):\\n            val = 0\\n            for j in range(i, min(i + 30, len(s))):\\n                val = val * 2 + ord(s[j]) - ord(\"0\")\\n                if val not in m:\\n                    m[val] = [i, j]\\n                if ch == \"0\":\\n                    break\\n        return [m[f ^ s] for f, s in queries] \\n```\\n\\n**C++**\\n```cpp\\nvector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n    unordered_map<int, vector<int>> m;\\n    vector<vector<int>> res;\\n    for (int i = 0; i < s.size(); ++i) {\\n        long long val = 0;\\n        for (int j = i; j < min(i + 30, (int)s.size()); ++j) {\\n            val = (val << 1) + (s[j] == \\'1\\');\\n            if (m.count(val) == 0)\\n                m[val] = {i, j};\\n            if (s[i] == \\'0\\')\\n                break;\\n        }\\n    }\\n    for (const auto &q : queries)\\n        if (auto it = m.find(q[0] ^ q[1]); it != end(m))\\n            res.push_back(it->second);\\n        else\\n            res.push_back({-1, -1});\\n    return res;\\n}\\n```\\n## Alternative Solution\\nInstead of adding all values we can get from the string, we add values from queries.\\n\\nThen, we build values from the string, and check if a value is the one we need for a query.\\n\\n> This approach would be beneficial if the string is large, and the number of queried values is not that big. \\n\\nNote that we remove the matching value from a hashmap, so that it won\\u2019t be processed again, and the result is populated with the string with smallest `left_i`.\\n\\n**C++**\\n```cpp\\nvector<vector<int>> substringXorQueries(string s, vector<vector<int>>& qs) {\\n    vector<vector<int>> res(qs.size(), {-1, -1});\\n    unordered_map<int, vector<int>> m;\\n    for (int i = 0; i < qs.size(); ++i)\\n        m[qs[i][0] ^ qs[i][1]].push_back(i);\\n    for (int i = 0; i < s.size(); ++i) {\\n        long long val = 0;\\n        for (int sz = 0; sz < 30 && i + sz < s.size(); ++sz) {\\n            val = (val << 1) + (s[i + sz] == \\'1\\');\\n            if (auto it = m.find(val); it != end(m)) {\\n                for (auto idx : it->second)\\n                    res[idx] = {i, i + sz};\\n                m.erase(it);\\n            }\\n            if (s[i] == \\'0\\')\\n                break;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        m = defaultdict(lambda: [-1, -1])\\n        for i, ch in enumerate(s):\\n            val = 0\\n            for j in range(i, min(i + 30, len(s))):\\n                val = val * 2 + ord(s[j]) - ord(\"0\")\\n                if val not in m:\\n                    m[val] = [i, j]\\n                if ch == \"0\":\\n                    break\\n        return [m[f ^ s] for f, s in queries] \\n```\n```cpp\\nvector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n    unordered_map<int, vector<int>> m;\\n    vector<vector<int>> res;\\n    for (int i = 0; i < s.size(); ++i) {\\n        long long val = 0;\\n        for (int j = i; j < min(i + 30, (int)s.size()); ++j) {\\n            val = (val << 1) + (s[j] == \\'1\\');\\n            if (m.count(val) == 0)\\n                m[val] = {i, j};\\n            if (s[i] == \\'0\\')\\n                break;\\n        }\\n    }\\n    for (const auto &q : queries)\\n        if (auto it = m.find(q[0] ^ q[1]); it != end(m))\\n            res.push_back(it->second);\\n        else\\n            res.push_back({-1, -1});\\n    return res;\\n}\\n```\n```cpp\\nvector<vector<int>> substringXorQueries(string s, vector<vector<int>>& qs) {\\n    vector<vector<int>> res(qs.size(), {-1, -1});\\n    unordered_map<int, vector<int>> m;\\n    for (int i = 0; i < qs.size(); ++i)\\n        m[qs[i][0] ^ qs[i][1]].push_back(i);\\n    for (int i = 0; i < s.size(); ++i) {\\n        long long val = 0;\\n        for (int sz = 0; sz < 30 && i + sz < s.size(); ++sz) {\\n            val = (val << 1) + (s[i + sz] == \\'1\\');\\n            if (auto it = m.find(val); it != end(m)) {\\n                for (auto idx : it->second)\\n                    res[idx] = {i, i + sz};\\n                m.erase(it);\\n            }\\n            if (s[i] == \\'0\\')\\n                break;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174171,
                "title": "video-editorial-cpp-o-n-tc-and-sc-solution",
                "content": "# Intuition\\n\\nIf we simply xor the values provided in each query then the problem becomes finding that value in the string. [if we are supposed to find $a$ s.t. $a$xor$b$ =$c$ then we need to find $a$=$b$xor$c$ ]. This is the easy part. \\nNow how do we find the required numbers in the string? Since the magnitude of the numbers is 10^9 hence that also becomes easy. A 10^9 number requires 31 bit in total for representation. So finding all substrings of length 31 is trivial and can be done easily in o(n) time, but still I\\u2019ll explain that a bit. [algo part2]\\n1.\\tStart from every index i. \\n2.\\tGo till j where j ranges from i to min (len of string, i+33) \\n    [info] We don\\u2019t want more than 33 as numbers having length of binary representation more than 33 would be huge and unnecessary\\n3.\\tStore these numbers and the corresponding left, right indices of substring in a relevant data structure. \\n\\nThe code below is self explanatory still if you have a doubt then you can let me know. \\n \\n\\nThis a video tutorial of the same logic -> https://www.youtube.com/watch?v=GHyZTvwMrfo\\n\\n# Complexity\\n- Time complexity:\\n $$O(n*33)$$ \\n\\n- Space complexity:\\n $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=queries.size();\\n        vector<long long> res;\\n        unordered_map<long long,pair<int,int>> found;\\n        vector<vector<int>> ans(n,vector<int>(2,-1));\\n        \\n        for(auto& q:queries){\\n            long long first=q[0],second=q[1];\\n            res.push_back(first^second);\\n        }\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\'){          // it doesn\\'t make sense to construct a non 0 string with leading 0s\\n                if(!found.count(0)) found[0]={i,i};\\n                continue;\\n            }\\n            long long val=0;            // the number considering the current string as a binary string. \\n            for(int j=i;j<min((int)s.size(),i+33);j++){\\n                val*=2;\\n                if(s[j]==\\'1\\')   val++;\\n                if(!found.count(val))   found[val]={i,j};\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(found.count(res[i])){        // if such a number exist in the string.\\n                ans[i]={found[res[i]].first,found[res[i]].second};\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=queries.size();\\n        vector<long long> res;\\n        unordered_map<long long,pair<int,int>> found;\\n        vector<vector<int>> ans(n,vector<int>(2,-1));\\n        \\n        for(auto& q:queries){\\n            long long first=q[0],second=q[1];\\n            res.push_back(first^second);\\n        }\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\'){          // it doesn\\'t make sense to construct a non 0 string with leading 0s\\n                if(!found.count(0)) found[0]={i,i};\\n                continue;\\n            }\\n            long long val=0;            // the number considering the current string as a binary string. \\n            for(int j=i;j<min((int)s.size(),i+33);j++){\\n                val*=2;\\n                if(s[j]==\\'1\\')   val++;\\n                if(!found.count(val))   found[val]={i,j};\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(found.count(res[i])){        // if such a number exist in the string.\\n                ans[i]={found[res[i]].first,found[res[i]].second};\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174153,
                "title": "python3-xor-and-dict-map",
                "content": "![image.png](https://assets.leetcode.com/users/images/e9dfe353-b0d5-4fc0-a2a3-557ca70567ab_1676179964.356461.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, v: List[List[int]]) -> List[List[int]]:\\n        def cmp():\\n            return -2\\n        ans=[]\\n        mp=defaultdict(cmp)\\n        for i in v:\\n            x=bin((i[0]^i[1]))[2:]\\n            if mp[x]!=-2:\\n                if mp[x]==-1:\\n                    ans+=[[-1,-1]]\\n                else:\\n                    ans+=[[mp[x],mp[x]+len(x)-1]]\\n                continue \\n            y=s.find(x)\\n            if y==-1:\\n                ans+=[[-1,-1]]\\n            else:\\n                ans+=[[y,y+len(x)-1]]\\n            mp[x]=y\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, v: List[List[int]]) -> List[List[int]]:\\n        def cmp():\\n            return -2\\n        ans=[]\\n        mp=defaultdict(cmp)\\n        for i in v:\\n            x=bin((i[0]^i[1]))[2:]\\n            if mp[x]!=-2:\\n                if mp[x]==-1:\\n                    ans+=[[-1,-1]]\\n                else:\\n                    ans+=[[mp[x],mp[x]+len(x)-1]]\\n                continue \\n            y=s.find(x)\\n            if y==-1:\\n                ans+=[[-1,-1]]\\n            else:\\n                ans+=[[y,y+len(x)-1]]\\n            mp[x]=y\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174167,
                "title": "simple-solution-tc-o-n-32-cpp",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<vector<int>> substringXorQueries(string s, vector<vector<int>> &q)\\n{\\n\\n    map<int, vector<int>> ans;\\n    int n = s.size();\\n    for (int i = 0; i < n; ++i)\\n    {\\n\\n        int cur = 0;\\n\\n        for (int j = 0; j < min(31, n - i); ++j)\\n        {\\n\\n            cur <<= 1;\\n            cur += (int)(s[i + j] - \\'0\\');\\n\\n            if (ans.find(cur) == ans.end())\\n            {\\n                ans[cur] = {i, i + j};\\n            }\\n            else\\n            {\\n                if (j < ans[cur][1] - ans[cur][0])\\n                {\\n\\n                    ans[cur] = {i, i + j};\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> ret;\\n    for (auto u : q)\\n    {\\n        int z = u[1] ^ u[0];\\n\\n        if (ans.find(z) != ans.end())\\n        {\\n            ret.push_back({ans[z]});\\n        }\\n        else\\n        {\\n            ret.push_back({-1, -1});\\n        }\\n    }\\n    return ret;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<vector<int>> substringXorQueries(string s, vector<vector<int>> &q)\\n{\\n\\n    map<int, vector<int>> ans;\\n    int n = s.size();\\n    for (int i = 0; i < n; ++i)\\n    {\\n\\n        int cur = 0;\\n\\n        for (int j = 0; j < min(31, n - i); ++j)\\n        {\\n\\n            cur <<= 1;\\n            cur += (int)(s[i + j] - \\'0\\');\\n\\n            if (ans.find(cur) == ans.end())\\n            {\\n                ans[cur] = {i, i + j};\\n            }\\n            else\\n            {\\n                if (j < ans[cur][1] - ans[cur][0])\\n                {\\n\\n                    ans[cur] = {i, i + j};\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> ret;\\n    for (auto u : q)\\n    {\\n        int z = u[1] ^ u[0];\\n\\n        if (ans.find(z) != ans.end())\\n        {\\n            ret.push_back({ans[z]});\\n        }\\n        else\\n        {\\n            ret.push_back({-1, -1});\\n        }\\n    }\\n    return ret;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174010,
                "title": "c-frequency-map-bit-trick-o-500-n",
                "content": "**Proof of O(500 * N):**\\nDue to the numbers being <=1e9, no number can be represented by more than 32 bits. In other words, all substrings that we should ever consider should be of length <= 32. So we will have substrings of length 1, 31, 2, 30, 3, 29... This sums up to 33 * 16 = 528.\\n\\n**Approach:**\\nWe just need to generate all substrings of length <= 31 and store their indices in a map by[value, {left,right}].\\n\\n**Proof of Correctness:** \\nXOR values are unique so the \\'shortest substring\\' part of the question is irrelevant. The only thing we need to account for is leading 0\\'s.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        map<int, vector<int>> freq;\\n        for(int i = 0; i < s.length(); i++){\\n            long long num = 0;\\n            for(int j = i, k = 0; j >= 0 && k<=31; j--, k++){\\n                int bit = s[j]-\\'0\\';\\n                num += (bit<<k);\\n                vector<int> v = {j, i};\\n                if(num<INT_MAX && freq.find(num) == freq.end()) {\\n                    freq[num] = v;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto & i : queries){\\n            int target = (i[0] ^ i[1]);\\n            if(freq.find(target) != freq.end()){\\n                ans.push_back(freq[target]);\\n            }\\n            else ans.push_back({-1, -1});\\n        }\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        map<int, vector<int>> freq;\\n        for(int i = 0; i < s.length(); i++){\\n            long long num = 0;\\n            for(int j = i, k = 0; j >= 0 && k<=31; j--, k++){\\n                int bit = s[j]-\\'0\\';\\n                num += (bit<<k);\\n                vector<int> v = {j, i}",
                "codeTag": "Java"
            },
            {
                "id": 3174233,
                "title": "python-simple-preprocessing-hashing-solution-o-n-32",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution string length can\\'t be over 32($2^{32}$).\\nThe approach is simple. Just preprocess all the bit string under 32 length.\\n\\n## Why can we calculate the answer like `a^b` ?\\n$$ A \\\\oplus X = B $$ \\n$$ X = A \\\\oplus B $$ \\n\\n## Note that we must process reversely\\nAnd we must process reversely because of description `there are multiple answers, choose the one with the minimum left.`\\n# Complexity\\n- Time complexity: $O(N \\\\times 32) $\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(N \\\\times 32) $\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        finder = defaultdict(lambda: [-1, -1])\\n        for l in range(33, 0, -1):\\n            for i in range(len(s)-l, -1, -1):\\n                finder[int(s[i:i+l], 2)] = [i, i+l-1]\\n        ans = []\\n        for a, b in queries:\\n            ans.append(finder[a^b])\\n        return ans\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        finder = defaultdict(lambda: [-1, -1])\\n        for l in range(33, 0, -1):\\n            for i in range(len(s)-l, -1, -1):\\n                finder[int(s[i:i+l], 2)] = [i, i+l-1]\\n        ans = []\\n        for a, b in queries:\\n            ans.append(finder[a^b])\\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177338,
                "title": "python-3-6-lines-xor-algebra-w-explanation-and-example-t-m-1467-ms-79-mb",
                "content": "Properties of the XOR binary operation:\\n```\\n          \\u2022 Associative: (a^b)^c = a^(b^c)\\n          \\u2022 Identity:        a^0 = a`\\n          \\u2022 Inverse:         a^a = 0\\n```\\nThese properties imply that the number`val`such that`first^val == second` is `first^second`:\\n```\\n            first^val == second`\\n            first^(first^val) == `first^second  \\n            (first^first)^val == `first^second   (Associative)\\n                        0^val == `first^second   (Inverse)\\n                          val == `first^second   (Identity)\\n```\\nThus, this problem reduces to finding the first occurrence of the binary representation of `first^second`in the string`s`. \\n\\nBefore we answer the queries, we build a`dict`to contain that first occurrence, if it exists. We then answer each query with`d[val]`.                          \\n# The Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n                                \\n        d, ans, n = defaultdict(lambda:[-1,-1]), [], len(s) \\n                                                    # Example:\\n        for j in range(min(32,n)):                  # s= \\'101101\\'  queries = [[0,5],[1,2]]\\n            for i in range(n-j):\\n                                                    # d = {1:[0,0],  0:[1,1],  2:[0,1],  3:[2,3],  5:[0,2],\\n                num = int(s[i:i+j+1], 2)            #      6:[2,4], 11:[0,3], 13:[2,5], 22:[0,4], 45:[0,5]}\\n                if num not in d: d[num] = [i, i+j]\\n\\n        return [d[a^b] for a, b in queries]         #  return [d[0^5], d[1^2]] = [d[5], d[3]] \\n                                                    #                          = [[0,2], [2,3]]\\n```\\n[https://leetcode.com/problems/substring-xor-queries/submissions/896697049/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n          \\u2022 Associative: (a^b)^c = a^(b^c)\\n          \\u2022 Identity:        a^0 = a`\\n          \\u2022 Inverse:         a^a = 0\\n```\n```\\n            first^val == second`\\n            first^(first^val) == `first^second  \\n            (first^first)^val == `first^second   (Associative)\\n                        0^val == `first^second   (Inverse)\\n                          val == `first^second   (Identity)\\n```\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n                                \\n        d, ans, n = defaultdict(lambda:[-1,-1]), [], len(s) \\n                                                    # Example:\\n        for j in range(min(32,n)):                  # s= \\'101101\\'  queries = [[0,5],[1,2]]\\n            for i in range(n-j):\\n                                                    # d = {1:[0,0],  0:[1,1],  2:[0,1],  3:[2,3],  5:[0,2],\\n                num = int(s[i:i+j+1], 2)            #      6:[2,4], 11:[0,3], 13:[2,5], 22:[0,4], 45:[0,5]}\\n                if num not in d: d[num] = [i, i+j]\\n\\n        return [d[a^b] for a, b in queries]         #  return [d[0^5], d[1^2]] = [d[5], d[3]] \\n                                                    #                          = [[0,2], [2,3]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175085,
                "title": "hashmap-uninspired-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        unordered_map<int,pair<int,int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            string temp=\"\";\\n          \\n         \\n           \\n            for(int j=i;j<min(i+31,n);j++)\\n            {\\n              //  cout<<\"in\"<<endl;\\n                temp+=s[j];\\n                int temp2=stoi(temp,0,2);\\n               // auto it=mp[temp2];\\n                if(mp.find(temp2)==mp.end())\\n                {\\n                    mp[temp2]={i,j};\\n                }\\n                else{\\n                    auto it=mp[temp2];\\n                    int temp3=it.second-it.first;\\n                    if(j-i<temp3)\\n                    {\\n                        mp[temp2]={i,j};\\n                    }\\n                }\\n                \\n               \\n              //  cout<<temp2<<\" \"<<i<<\" \"<<j<<endl;\\n               \\n\\n                \\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto &it:queries)\\n        {\\n            int temp3=it[0]^it[1];\\n            int flag=0;\\n            if(mp.find(temp3)!=mp.end())\\n            {\\n                ans.push_back({mp[temp3].first,mp[temp3].second});\\n                flag=1;\\n            }\\n            if(!flag)ans.push_back({-1,-1});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        unordered_map<int,pair<int,int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            string temp=\"\";\\n          \\n         \\n           \\n            for(int j=i;j<min(i+31,n);j++)\\n            {\\n              //  cout<<\"in\"<<endl;\\n                temp+=s[j];\\n                int temp2=stoi(temp,0,2);\\n               // auto it=mp[temp2];\\n                if(mp.find(temp2)==mp.end())\\n                {\\n                    mp[temp2]={i,j};\\n                }\\n                else{\\n                    auto it=mp[temp2];\\n                    int temp3=it.second-it.first;\\n                    if(j-i<temp3)\\n                    {\\n                        mp[temp2]={i,j};\\n                    }\\n                }\\n                \\n               \\n              //  cout<<temp2<<\" \"<<i<<\" \"<<j<<endl;\\n               \\n\\n                \\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto &it:queries)\\n        {\\n            int temp3=it[0]^it[1];\\n            int flag=0;\\n            if(mp.find(temp3)!=mp.end())\\n            {\\n                ans.push_back({mp[temp3].first,mp[temp3].second});\\n                flag=1;\\n            }\\n            if(!flag)ans.push_back({-1,-1});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3301914,
                "title": "java-hashmap-explained",
                "content": "# Previous post got removed \\u2639\\uFE0F\\n---\\n![image.png](https://assets.leetcode.com/users/images/de89c313-8fde-4ae2-a1db-0c6108836768_1678914746.6648712.png)\\n\\n---\\n### Explanation:\\nWe will store every number (given by each 32-bit binary substring) possible from `s` and store it in a map along with the start and end indices of that substring (the first occurrence).\\n\\nEach element in `queries` is an array `[first, second]`.\\nWe need to find every possible substring (their start and end indices) such that \\n`val ^ first = second` where `val` is the **decimal value of particular substring**.\\n\\nWe can modify the equation to make our job easier:\\n\\n![image.png](https://assets.leetcode.com/users/images/f99c0430-5416-443c-a279-abb32f34f7ad_1676195702.8834856.png)\\n\\nWe already had stored all possible decimal values from `s` in a map.\\nThen we will iterate over `queries` and get the value: `queries[i][0] ^ queries[i][1]` i.e. `first ^ second` and check if the value exists in the map. If yes, we put the start and end indices in the answer array otherwise we will put `{-1, -1}`.\\n\\n---\\n### Code:\\n``` \\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        // We will create a hashmap to store all the possible \\n        // decimal values that our given string can offer\\n        // A number can have at max 32 bits\\n        // So a we can take a substring of length at max 32 \\n        // and convert it to a decimal value\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            // leading 0\\n            if (s.charAt(i) == \\'0\\') {\\n                // put the 0 along with its start and end (left & right)\\n                map.putIfAbsent(0, new int[] {i, i});\\n                continue;   // move on\\n            }\\n            \\n            // otherwise we will create the decimal value\\n            int num = 0;\\n            // iterate from here an create decimal value for each binary substring\\n            for (int j = i; j < s.length() && j < i + 32; j++) {\\n                num *= 2;   \\n                num += (s.charAt(j) - \\'0\\');\\n                // put the number in the map along with its start and end \\n                map.putIfAbsent(num, new int[] {i, j});\\n            }\\n\\n            // we want to keep the minimum left in case of multiple same numbers\\n            // putIfAbsent() puts the first ever instance found into the map\\n            // if we encounter same number again, it won\\'t overwrite (like put()) \\n            // because we already have the number (key) with its start & end \\n        }\\n\\n        // initialise answer array\\n        int[][] ans = new int[queries.length][2];\\n        int i = 0;\\n        for (int[] q : queries) {\\n            int val = q[0] ^ q[1];  // get the xor value\\n            // if the value exists in the map, we put its {left, right} in ans\\n            // else put {-1, -1} at that place\\n            ans[i++] = map.getOrDefault(val, new int[] {-1, -1});\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n``` \\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                map.putIfAbsent(0, new int[] {i, i});\\n                continue;  \\n            }\\n\\n            int num = 0;\\n            for (int j = i; j < s.length() && j < i + 32; j++) {\\n                num *= 2;   \\n                num += (s.charAt(j) - \\'0\\');\\n                map.putIfAbsent(num, new int[] {i, j});\\n            }\\n        }\\n\\n        int[][] ans = new int[queries.length][2];\\n        int i = 0;\\n        for (int[] q : queries) {\\n            int val = q[0] ^ q[1];  \\n            ans[i++] = map.getOrDefault(val, new int[] {-1, -1});\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n--- \\n##### Time complexity: $$O(n * min(n, 32)) + O(n)$$\\n##### Space complexity: $$O(n ^ 2)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "``` \\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        // We will create a hashmap to store all the possible \\n        // decimal values that our given string can offer\\n        // A number can have at max 32 bits\\n        // So a we can take a substring of length at max 32 \\n        // and convert it to a decimal value\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            // leading 0\\n            if (s.charAt(i) == \\'0\\') {\\n                // put the 0 along with its start and end (left & right)\\n                map.putIfAbsent(0, new int[] {i, i});\\n                continue;   // move on\\n            }\\n            \\n            // otherwise we will create the decimal value\\n            int num = 0;\\n            // iterate from here an create decimal value for each binary substring\\n            for (int j = i; j < s.length() && j < i + 32; j++) {\\n                num *= 2;   \\n                num += (s.charAt(j) - \\'0\\');\\n                // put the number in the map along with its start and end \\n                map.putIfAbsent(num, new int[] {i, j});\\n            }\\n\\n            // we want to keep the minimum left in case of multiple same numbers\\n            // putIfAbsent() puts the first ever instance found into the map\\n            // if we encounter same number again, it won\\'t overwrite (like put()) \\n            // because we already have the number (key) with its start & end \\n        }\\n\\n        // initialise answer array\\n        int[][] ans = new int[queries.length][2];\\n        int i = 0;\\n        for (int[] q : queries) {\\n            int val = q[0] ^ q[1];  // get the xor value\\n            // if the value exists in the map, we put its {left, right} in ans\\n            // else put {-1, -1} at that place\\n            ans[i++] = map.getOrDefault(val, new int[] {-1, -1});\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n``` \\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                map.putIfAbsent(0, new int[] {i, i});\\n                continue;  \\n            }\\n\\n            int num = 0;\\n            for (int j = i; j < s.length() && j < i + 32; j++) {\\n                num *= 2;   \\n                num += (s.charAt(j) - \\'0\\');\\n                map.putIfAbsent(num, new int[] {i, j});\\n            }\\n        }\\n\\n        int[][] ans = new int[queries.length][2];\\n        int i = 0;\\n        for (int[] q : queries) {\\n            int val = q[0] ^ q[1];  \\n            ans[i++] = map.getOrDefault(val, new int[] {-1, -1});\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180686,
                "title": "javascript-easy-solution-5-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[][]}\\n */\\n1. var substringXorQueries = function(s, queries) {\\n    \\n    var ans=[];\\n    for(let i=0;i<queries.length;i++)\\n        {\\n            var x=queries[i][0]^queries[i][1];\\n            var y=x.toString(2);\\n            var j=s.indexOf(y);\\n            if(j==-1)ans.push([j,j]);\\n            else ans.push([j,j+y.length-1]);\\n        }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[][]}\\n */\\n1. var substringXorQueries = function(s, queries) {\\n    \\n    var ans=[];\\n    for(let i=0;i<queries.length;i++)\\n        {\\n            var x=queries[i][0]^queries[i][1];\\n            var y=x.toString(2);\\n            var j=s.indexOf(y);\\n            if(j==-1)ans.push([j,j]);\\n            else ans.push([j,j+y.length-1]);\\n        }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3176365,
                "title": "video-editorial-hindi-sliding-window-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can simplify the value \\'x\\'^l = r for query [l,r] --> x = l^r ,\\nNow is it optimal to find **Decimal** value for each substring?\\nWhat is the optimal lenght which will contribute to answer of query ?\\nThe max xor value can be stored in 31 bit , so do we need to find **Decimal** value for larger lenght than 30 ? **NO**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind **Decimal** value for each substring of length <=31 , we will use sliding window and map and start finding value for smaller length them move to larger length from (1 to 31) . This will make sure we get smallest substring occuring first added in our hasmap/map for particular value \\'x\\' . 11 --> 3 and 011-> 3 but if we go smaller to large we will not consider 011 for 3 . \\n\\n Video Link ( Hindi ):- [https://www.youtube.com/watch?v=ZB6OdFGaUW4](Editorialmap)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(32*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>>ans;\\n         \\n\\n        set<string>used;\\n        used.insert(\"-1\");\\n        map<string,pair<int,int>>P;\\n        int n = s.size();\\n        //we will consider string upto 31 length\\n        //as 2^31 > max xor value possible\\n        //it will require atmax 31 bits or length string to represent the max value\\n        for(int i=1;i<=min(31,n);++i){\\n            \\n            string temp = \"\";\\n            for(int j=0;j<i;++j){\\n                temp += s[j];\\n            }\\n            //we store the first index of occurence \\n            //of each binary string\\n            if(used.find(temp) == used.end()){\\n                used.insert(temp);\\n                P[temp] = {0,i-1};\\n            }\\n            \\n            for(int j=i;j<s.size();++j){\\n                temp += s[j];\\n                temp.erase(temp.begin());\\n                //removing the first character\\n                //adding current character \\n                //to have binary string of \\'i\\' length\\n                if(used.find(temp) == used.end()){\\n                  used.insert(temp);\\n                  P[temp] = {j-i+1,j};\\n                 }\\n            }\\n            \\n        }\\n        \\n        \\n        for(auto&x:queries){\\n            long long left = x[0];\\n            long long right = x[1];\\n            left^=right;\\n            \\n            string temp = bitset<32>(left).to_string();\\n            string find = \"\";\\n            int f = 0;\\n            for(int i=0;i<32;++i){\\n                if(f)find += temp[i];\\n                else{\\n                    if(temp[i] == \\'1\\'){\\n                        f=1;\\n                        find += temp[i];\\n                    }\\n                    else{\\n                        if(i == 31)find += \"0\";\\n                    }\\n                }\\n            }\\n            //here we are findinng the binary string of XOR value of \\n            // left and right -- X ^ left = right --> X = right ^ left\\n            //so we are finding X and check if there is any substring \\n            //with same binary string as of \\'X\\'\\n            if(used.find(find)!=used.end()){\\n                ans.push_back({P[find].first,P[find].second});\\n            }\\n            else ans.push_back({-1,-1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>>ans;\\n         \\n\\n        set<string>used;\\n        used.insert(\"-1\");\\n        map<string,pair<int,int>>P;\\n        int n = s.size();\\n        //we will consider string upto 31 length\\n        //as 2^31 > max xor value possible\\n        //it will require atmax 31 bits or length string to represent the max value\\n        for(int i=1;i<=min(31,n);++i){\\n            \\n            string temp = \"\";\\n            for(int j=0;j<i;++j){\\n                temp += s[j];\\n            }\\n            //we store the first index of occurence \\n            //of each binary string\\n            if(used.find(temp) == used.end()){\\n                used.insert(temp);\\n                P[temp] = {0,i-1};\\n            }\\n            \\n            for(int j=i;j<s.size();++j){\\n                temp += s[j];\\n                temp.erase(temp.begin());\\n                //removing the first character\\n                //adding current character \\n                //to have binary string of \\'i\\' length\\n                if(used.find(temp) == used.end()){\\n                  used.insert(temp);\\n                  P[temp] = {j-i+1,j};\\n                 }\\n            }\\n            \\n        }\\n        \\n        \\n        for(auto&x:queries){\\n            long long left = x[0];\\n            long long right = x[1];\\n            left^=right;\\n            \\n            string temp = bitset<32>(left).to_string();\\n            string find = \"\";\\n            int f = 0;\\n            for(int i=0;i<32;++i){\\n                if(f)find += temp[i];\\n                else{\\n                    if(temp[i] == \\'1\\'){\\n                        f=1;\\n                        find += temp[i];\\n                    }\\n                    else{\\n                        if(i == 31)find += \"0\";\\n                    }\\n                }\\n            }\\n            //here we are findinng the binary string of XOR value of \\n            // left and right -- X ^ left = right --> X = right ^ left\\n            //so we are finding X and check if there is any substring \\n            //with same binary string as of \\'X\\'\\n            if(used.find(find)!=used.end()){\\n                ans.push_back({P[find].first,P[find].second});\\n            }\\n            else ans.push_back({-1,-1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174242,
                "title": "c-hash-map-easy-approch-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we use a map to make calculation fast to avoid TLE.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*32) where n is the length of the given string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n) for making map.\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<vector<int>> solve(string s,vector<vector<int>> &queries) {\\n        map<int,vector<int>> mp;\\n        int n=s.size();\\n        for(int i=0 ; i<n ; ++i) {\\n            ll val=0;\\n            ll cnt=1;\\n            \\n            int j=i;\\n            while(j>=max(0,i-32)){\\n                if(s[j]==\\'0\\') cnt *= 2;\\n                else {\\n                    val = val+cnt;\\n                    cnt = cnt*2;\\n                }\\n                \\n                if(mp.find(val)==mp.end()) mp[val] = {j,i};\\n                j--;\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(auto i: queries){\\n            if(mp.find((i[0]^i[1]))==mp.end()) ans.push_back({-1,-1});\\n            else ans.push_back(mp[i[0]^i[1]]);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        return solve(s,queries);;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<vector<int>> solve(string s,vector<vector<int>> &queries) {\\n        map<int,vector<int>> mp;\\n        int n=s.size();\\n        for(int i=0 ; i<n ; ++i) {\\n            ll val=0;\\n            ll cnt=1;\\n            \\n            int j=i;\\n            while(j>=max(0,i-32)){\\n                if(s[j]==\\'0\\') cnt *= 2;\\n                else {\\n                    val = val+cnt;\\n                    cnt = cnt*2;\\n                }\\n                \\n                if(mp.find(val)==mp.end()) mp[val] = {j,i};\\n                j--;\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(auto i: queries){\\n            if(mp.find((i[0]^i[1]))==mp.end()) ans.push_back({-1,-1});\\n            else ans.push_back(mp[i[0]^i[1]]);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        return solve(s,queries);;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175033,
                "title": "c-easy-code-unordered-map",
                "content": "\\n# Complexity\\n- Time complexity: **O(30*n + q)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(30*n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   \\n# Code\\n```\\nclass Solution\\n{\\n#define ll long long\\npublic:\\n    unordered_map<ll, vector<int>> m;\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>> &q)\\n    {\\n        int n = s.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (s[i] == \\'0\\')\\n            {\\n                if (m.find(0) == m.end())\\n                {\\n                    m[0] = {i, i};\\n                }\\n            }\\n            else\\n            {\\n                ll a = 0;\\n                for (int j = i; j < min(30+i,n); j++)\\n                {\\n                    a *= 2;\\n                    if (s[j] == \\'1\\')\\n                        a++;\\n                    if (m.find(a) == m.end())\\n                    {\\n                        m[a] = {i, j};\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> d;\\n        for (auto x : q)\\n        {\\n            long long an = x[0] ^ x[1];\\n            cout << an << \" \";\\n            if (m.find(an) != m.end())\\n            {\\n                d.push_back({m[an]});\\n            }\\n            else\\n                d.push_back({-1, -1});\\n        }\\n        return d;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/e1e1cca7-cedd-4fa7-90ba-d43a030ce60b_1676186830.7100778.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n#define ll long long\\npublic:\\n    unordered_map<ll, vector<int>> m;\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>> &q)\\n    {\\n        int n = s.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (s[i] == \\'0\\')\\n            {\\n                if (m.find(0) == m.end())\\n                {\\n                    m[0] = {i, i};\\n                }\\n            }\\n            else\\n            {\\n                ll a = 0;\\n                for (int j = i; j < min(30+i,n); j++)\\n                {\\n                    a *= 2;\\n                    if (s[j] == \\'1\\')\\n                        a++;\\n                    if (m.find(a) == m.end())\\n                    {\\n                        m[a] = {i, j};\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> d;\\n        for (auto x : q)\\n        {\\n            long long an = x[0] ^ x[1];\\n            cout << an << \" \";\\n            if (m.find(an) != m.end())\\n            {\\n                d.push_back({m[an]});\\n            }\\n            else\\n                d.push_back({-1, -1});\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3174873,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int,vector<int>> mp;\\n        int i,j,n = s.length(),x;\\n        for(i = 0; i < s.length(); i++){\\n            x = 0;\\n            for(j = 0; i+j<s.length()&&j<32;j++){\\n                x = (x<<1)+(s[j+i]==\\'1\\');\\n                if(mp.count(x)==0){\\n                    mp[x].push_back(i);\\n                    mp[x].push_back(i+j);\\n                }\\n                if(s[i]==\\'0\\')break;\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto &i: queries){\\n            if(mp.count(i[0]^i[1])){\\n                ans.push_back(mp[(i[0]^i[1])]);\\n            }else{\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int,vector<int>> mp;\\n        int i,j,n = s.length(),x;\\n        for(i = 0; i < s.length(); i++){\\n            x = 0;\\n            for(j = 0; i+j<s.length()&&j<32;j++){\\n                x = (x<<1)+(s[j+i]==\\'1\\');\\n                if(mp.count(x)==0){\\n                    mp[x].push_back(i);\\n                    mp[x].push_back(i+j);\\n                }\\n                if(s[i]==\\'0\\')break;\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto &i: queries){\\n            if(mp.count(i[0]^i[1])){\\n                ans.push_back(mp[(i[0]^i[1])]);\\n            }else{\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174772,
                "title": "check-substrings-having-length-30-precise-intuitive-map",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        \\n        map<int,vector<int>> mp;\\n        \\n        int n=s.size();\\n        for(int i=n-1;i>=0;i--){   // moving from end because we have to return the leftmost substring\\n            long long num=0;\\n            for(int j=i;j>=max(0,i-30);j--){\\n                \\n                if(s[j]==\\'1\\'){                      // {value,{i,j}} as in map;\\n                   num+=pow(2,i-j);\\n\\n                    mp[num]={j,i};\\n                }else{\\n                    mp[0]={j,j};\\n                }\\n            }\\n        }\\n        vector<vector<int>> fin;\\n        for(int i=0;i<q.size();i++){\\n            int res=q[i][0]^q[i][1];\\n            if(mp.find(res)!=mp.end()){\\n                fin.push_back(mp[res]);\\n            }else{\\n                fin.push_back({-1,-1});\\n            }\\n        }return fin;\\n    }\\n};",
                "solutionTags": [
                    "String",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        \\n        map<int,vector<int>> mp;\\n        \\n        int n=s.size();\\n        for(int i=n-1;i>=0;i--){   // moving from end because we have to return the leftmost substring\\n            long long num=0;\\n            for(int j=i;j>=max(0,i-30);j--){\\n                \\n                if(s[j]==\\'1\\'){                      // {value,{i,j}",
                "codeTag": "Java"
            },
            {
                "id": 3174429,
                "title": "python3-preprocessing",
                "content": "\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        seen = {}\\n        for i, ch in enumerate(s):\\n            if ch == \\'1\\': \\n                val = 0\\n                for j in range(i, min(len(s), i+30)): \\n                    val <<= 1\\n                    if s[j] == \\'1\\': val ^= 1\\n                    seen.setdefault(val, [i, j])\\n            else: seen.setdefault(0, [i, i])\\n        return [seen.get(x^y, [-1, -1]) for x, y in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        seen = {}\\n        for i, ch in enumerate(s):\\n            if ch == \\'1\\': \\n                val = 0\\n                for j in range(i, min(len(s), i+30)): \\n                    val <<= 1\\n                    if s[j] == \\'1\\': val ^= 1\\n                    seen.setdefault(val, [i, j])\\n            else: seen.setdefault(0, [i, i])\\n        return [seen.get(x^y, [-1, -1]) for x, y in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174247,
                "title": "java-o-1e4-2-oj-limit-o-1e9",
                "content": "`10000` indicates we could pre-compute in n^2 way.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int m = queries.length;\\n        int[][] ret = new int[m][];\\n\\n        int n = s.length();\\n        Map<Integer, int[]> map = new HashMap<>();\\n        map.put(0, new int[]{s.indexOf(\"0\"),s.indexOf(\"0\")});\\n        int[] not = new int[]{-1, -1};\\n\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\'0\\') continue;\\n            for (int j = i + 1; j <= n; j++) {\\n                String sub = s.substring(i, j);\\n                if (sub.length() > Integer.toBinaryString(Integer.MAX_VALUE).length()) break;\\n                // if (map.contains)\\n                map.putIfAbsent(Integer.parseInt(sub, 2), new int[]{i, j - 1});\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            int x = queries[i][0] ^ queries[i][1];\\n\\n            if (map.containsKey(x)) {\\n                ret[i] = map.get(x);\\n            } else {\\n                ret[i] = not;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int m = queries.length;\\n        int[][] ret = new int[m][];\\n\\n        int n = s.length();\\n        Map<Integer, int[]> map = new HashMap<>();\\n        map.put(0, new int[]{s.indexOf(\"0\"),s.indexOf(\"0\")});\\n        int[] not = new int[]{-1, -1};\\n\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\'0\\') continue;\\n            for (int j = i + 1; j <= n; j++) {\\n                String sub = s.substring(i, j);\\n                if (sub.length() > Integer.toBinaryString(Integer.MAX_VALUE).length()) break;\\n                // if (map.contains)\\n                map.putIfAbsent(Integer.parseInt(sub, 2), new int[]{i, j - 1});\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            int x = queries[i][0] ^ queries[i][1];\\n\\n            if (map.containsKey(x)) {\\n                ret[i] = map.get(x);\\n            } else {\\n                ret[i] = not;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174081,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\nbool cmp(const pi&a, const pi&b){\\n    const auto&[xs, xe]=a;\\n    const auto&[ys, ye]=b;\\n    ll szx=xe-xs+1, szy=ye-ys+1;\\n    return (szx==szy?xs<ys:szx<szy);\\n}\\n\\nvector<vector<int>> substringXorQueries(const string&s, vector<vector<int>>&q) {\\n    ll n=s.size();\\n    unordered_map<ll, pi>ump;\\n    for(ll i=0;i<n;++i){\\n        ll num=0;\\n        for(ll j=i;j>-1 && i-j+1<33;--j){\\n            ll cur=s[j]-\\'0\\';\\n            num=(cur<<(i-j))+num;\\n            if(ump.find(num)==ump.end() || cmp({j, i}, ump[num])){\\n                ump[num]={j,i};\\n            }\\n        }\\n    }\\n    ll m=q.size();\\n    vi(vi(int))ans(m, {-1, -1});\\n    for(ll i=0;i<m;++i){\\n        ll xo=q[i][0]^q[i][1];\\n        if(ump.find(xo)!=ump.end()){\\n            ans[i]={(int)ump[xo].first, (int)ump[xo].second};\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\nbool cmp(const pi&a, const pi&b){\\n    const auto&[xs, xe]=a;\\n    const auto&[ys, ye]=b;\\n    ll szx=xe-xs+1, szy=ye-ys+1;\\n    return (szx==szy?xs<ys:szx<szy);\\n}\\n\\nvector<vector<int>> substringXorQueries(const string&s, vector<vector<int>>&q) {\\n    ll n=s.size();\\n    unordered_map<ll, pi>ump;\\n    for(ll i=0;i<n;++i){\\n        ll num=0;\\n        for(ll j=i;j>-1 && i-j+1<33;--j){\\n            ll cur=s[j]-\\'0\\';\\n            num=(cur<<(i-j))+num;\\n            if(ump.find(num)==ump.end() || cmp({j, i}, ump[num])){\\n                ump[num]={j,i};\\n            }\\n        }\\n    }\\n    ll m=q.size();\\n    vi(vi(int))ans(m, {-1, -1});\\n    for(ll i=0;i<m;++i){\\n        ll xo=q[i][0]^q[i][1];\\n        if(ump.find(xo)!=ump.end()){\\n            ans[i]={(int)ump[xo].first, (int)ump[xo].second};\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196859,
                "title": "simple-bit-manipulation-concept-pre-computation-concept-well-commented",
                "content": "# Intuition and Approach\\nGiven num range is 0 <= ele <= 10 ^ 9\\nso from the gvn string we can try to **make every 32 bit possible num** and then can store it in map. After that can try to find target num in map.\\n\\ngvn [a, b]\\nWe have to find a number whose XOR with a should give b\\nHere target num is number which we\\'ll get after xoring.\\n***Concept***\\n**a XOR b = c\\na XOR c = b**\\nso try to find c in map\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: **O(32 * n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //Here we are preComputing every 32 bit number tht we can form\\n    void makeFreqMap(string& s, map<int, pair<int, int>>& mp) { //forming num from right side of str like for string \"1001\" nums will 1, 2, 4, 9\\n\\n        for(int i = 0; i < s.size(); i++) { //TC: O(32 * n)\\n            int num = 0;\\n            if(s[i] == \\'0\\') { //if starting bit is 0 then number will always be 0\\n                if(mp.find(num) == mp.end()) {\\n                    mp[num] = {i, i};\\n                }\\n                continue;\\n            }\\n            for(int j = i; j < i + 31 && j < s.size(); j++) { //becoz num will be <= 10^9 31 will cover that\\n                num = (s[j] == \\'1\\') ? ((num << 1) | 1) : (num << 1);\\n\\n                if(mp.find(num) == mp.end()) {\\n                    mp[num] = {i, j};\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        map<int, pair<int, int>> mp; //will have ele and it\\'s index starting point and ending point\\n        makeFreqMap(s, mp);\\n\\n        vector<vector<int>> res;\\n\\n        for(int i = 0; i < queries.size(); i++) {\\n            int st = queries[i][0], end = queries[i][1];\\n            int xorr = st ^ end;\\n\\n            if(mp.find(xorr) == mp.end()) { //if xorr is present then return it\\'s index otherwise return -1, -1\\n                res.push_back({-1, -1});\\n            }\\n            else {\\n                res.push_back({mp[xorr].first, mp[xorr].second});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //Here we are preComputing every 32 bit number tht we can form\\n    void makeFreqMap(string& s, map<int, pair<int, int>>& mp) { //forming num from right side of str like for string \"1001\" nums will 1, 2, 4, 9\\n\\n        for(int i = 0; i < s.size(); i++) { //TC: O(32 * n)\\n            int num = 0;\\n            if(s[i] == \\'0\\') { //if starting bit is 0 then number will always be 0\\n                if(mp.find(num) == mp.end()) {\\n                    mp[num] = {i, i};\\n                }\\n                continue;\\n            }\\n            for(int j = i; j < i + 31 && j < s.size(); j++) { //becoz num will be <= 10^9 31 will cover that\\n                num = (s[j] == \\'1\\') ? ((num << 1) | 1) : (num << 1);\\n\\n                if(mp.find(num) == mp.end()) {\\n                    mp[num] = {i, j};\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        map<int, pair<int, int>> mp; //will have ele and it\\'s index starting point and ending point\\n        makeFreqMap(s, mp);\\n\\n        vector<vector<int>> res;\\n\\n        for(int i = 0; i < queries.size(); i++) {\\n            int st = queries[i][0], end = queries[i][1];\\n            int xorr = st ^ end;\\n\\n            if(mp.find(xorr) == mp.end()) { //if xorr is present then return it\\'s index otherwise return -1, -1\\n                res.push_back({-1, -1});\\n            }\\n            else {\\n                res.push_back({mp[xorr].first, mp[xorr].second});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184341,
                "title": "intuitive-java-solution-easy-to-understand",
                "content": "# Intuition\\nThere are 3 things to consider here\\n1. XOR \\na ^ b = c \\na ^ c = b\\nb ^ c = a\\nUsing this logic, we can get the value = queries[i][0] ^ queries[i][1]\\n2. queries range is integer so O(n * n) becomes O(n * 30)\\n3. We can skip substrings starting with \\'0\\' so as to keep the length of substring to minimum.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n * 30) ~ O(n)\\n\\n\\n> PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int[][] ans = new int[queries.length][2];\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                map.putIfAbsent(0, new int[]{i, i});\\n                continue;  //skip substring starting with \\'0\\'\\n            }\\n            int value = 0; \\n        \\n            for(int j = i; j <= Math.min(i + 30, s.length() - 1); j++) {\\n                value = (value << 1) + (s.charAt(j) - \\'0\\');\\n                map.putIfAbsent(value, new int[]{i, j});\\n            }\\n        }\\n        int i = 0;\\n        for(int[] q: queries ) {\\n            ans[i++] = map.getOrDefault(q[0] ^ q[1], new int[] {-1, -1}); \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int[][] ans = new int[queries.length][2];\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                map.putIfAbsent(0, new int[]{i, i});\\n                continue;  //skip substring starting with \\'0\\'\\n            }\\n            int value = 0; \\n        \\n            for(int j = i; j <= Math.min(i + 30, s.length() - 1); j++) {\\n                value = (value << 1) + (s.charAt(j) - \\'0\\');\\n                map.putIfAbsent(value, new int[]{i, j});\\n            }\\n        }\\n        int i = 0;\\n        for(int[] q: queries ) {\\n            ans[i++] = map.getOrDefault(q[0] ^ q[1], new int[] {-1, -1}); \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182917,
                "title": "general-string-matching-with-multiple-queries-in-o-q-m-log-n",
                "content": "# Intuition\\nIf you do val = first xor second for each query the problem becomes this:\\n\\n*Given a text and a list of words find the first occurrence of each word in text.*\\n\\nI\\'m going to explain a general approach that works with all the characters of alphabet and not only \\'1\\' and \\'0\\'.\\n\\nThere are various approaches to solve this problem such like [Polynomial Rolling Hash](https://en.wikipedia.org/wiki/Rolling_hash), [Aho-Corasick algorithm](https://cp-algorithms.com/string/aho_corasick.html), [Suffix automaton](https://cp-algorithms.com/string/suffix-automaton.html) but i\\'m going to use [Suffix Array](https://web.stanford.edu/class/cs97si/suffix-array.pdf) data structure to solve this problem.\\n\\n# Approach\\nWhat is a suffix array?\\n\\nA suffix array is an array of integers that represent the starting indexes of the all the suffixes of a given string, after the suffixes are sorted.\\n\\nFor example given `string s = \"banana#\"`. The text ends with the special sentinel character # that is unique and lexicographically smaller than any other character (this is a necesary step for the correct construcction of the suffix array). The string has the following suffixes:\\n\\n<table>\\n    <thead>\\n        <tr>\\n            <td>index</td>\\n            <td>Suffix</td>\\n        </tr>    \\n    </thead>\\n    <tbody>\\n        <tr>\\n            <td>0</td>\\n            <td>banana#</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\n            <td>anana#</td>\\n        </tr>\\n        <tr>\\n            <td>2</td>\\n            <td>nana#</td>\\n        </tr>\\n        <tr>\\n            <td>3</td>\\n            <td>ana#</td>\\n        </tr>\\n        <tr>\\n            <td>4</td>\\n            <td>na#</td>\\n        </tr>\\n        <tr>\\n            <td>5</td>\\n            <td>a#</td>\\n        </tr>\\n        <tr>\\n            <td>6</td>\\n            <td>#</td>\\n        </tr>\\n    </tbody>\\n</table>\\n\\nAfter sort:\\n\\n<table>\\n    <thead>\\n        <tr>\\n            <td>index</td>\\n            <td>Suffix</td>\\n        </tr>    \\n    </thead>\\n    <tbody>\\n        <tr>\\n            <td>6</td>\\n            <td>#</td>\\n        </tr>\\n        <tr>\\n            <td>5</td>\\n            <td>a#</td>\\n        </tr>\\n        <tr>\\n            <td>3</td>\\n            <td>ana#</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\n            <td>anana#</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\n            <td>banana#</td>\\n        </tr>\\n        <tr>\\n            <td>4</td>\\n            <td>na#</td>\\n        </tr>\\n        <tr>\\n            <td>2</td>\\n            <td>nana#</td>\\n        </tr>\\n    </tbody>\\n</table>\\n\\nRemenber the suffix array is **only the array of integers** then the SA(suffix array) for \"banana\" is `sa = [6, 5, 3, 1, 0, 4, 2]`. If you want to retrieve some suffix go to the original string at `s[sa[i]]`.\\n\\nI\\xB4m not going to explain how build the SA in an efficient way there are many online resources for that, just be aware that construct the suffix array takes time complexity $$O(n*log^2(n)) $$ or $$O(n*log(n))$$ where $$n$$ is the length of original string.\\n\\nNow how to find a word in the string using the SA. *Every substring is a prefix of some suffix* and the suffixes are sorted so can use **binary search** to find if the word matches with some suffix like searching words in a dictionary. This can be done using the C++ build-in compare fuction for strings witch return values are the following:\\n\\n<table>\\n    <thead>\\n        <tr>\\n            <td>Return value</td>\\n            <td>Relation between compared string and comparing string</td>\\n        </tr>    \\n    </thead>\\n    <tbody>\\n        <tr>\\n            <td>0</td>\\n            <td>They compare equal\\n</td>\\n        </tr>\\n        <tr>\\n            <td>less than 0</td>\\n            <td>Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter.</td>\\n        </tr>\\n        <tr>\\n            <td>bigger thah 0</td>\\n            <td>Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer.</td>\\n        </tr>\\n    </tbody>\\n</table>  \\n\\nIf current suffix compares bigger or equal then keep searching the fisrt half of SA, similarity current suffix compares smaller then go second half. The string comparation takes $$O(m)$$ where $$m = word.length()$$, so to answer if a given word is present in the string takes time complexity $$O(m * log(n))$$ per query.  \\n\\nAlmost finished only need to handle the case were various suffixes contains the given word, how to be sure of return the first occurrence?\\n\\nFor example given `string s = \"111010110\";` the SA is:\\n\\n<table>\\n    <thead>\\n        <tr>\\n            <td>index</td>\\n            <td>sa[index]</td>\\n            <td>Suffix</td>\\n        </tr>    \\n    </thead>\\n    <tbody>\\n        <tr>\\n            <td>0</td>\\n            <td>9</td>\\n            <td>#</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\n            <td>8</td>\\n            <td>0#</td>\\n        </tr>\\n    <tr>\\n        <td>2</td>\\n        <td>3</td>\\n        <td>010110#</td>\\n    </tr>\\n    <tr>\\n        <td>3</td>\\n        <td>5</td>\\n        <td>0110#</td>\\n    </tr>\\n    <tr>\\n        <td>4</td>\\n        <td>7</td>\\n        <td>10#</td>\\n    </tr>\\n    <tR>\\n        <td>5</td>\\n        <td>2</td>\\n        <td>1010110#</td>\\n    </tr>\\n    <tr>\\n        <td>6</td>\\n        <td>4</td>\\n        <td>10110#</td>\\n    </tr>\\n    <tr>\\n        <td>7</td>\\n        <td>6</td>\\n        <td>110#</td>\\n    </tr>\\n    <tr>\\n        <td>8</td>\\n        <td>1</td>\\n        <td>11010110#</td>\\n    </tr>\\n    <tr>\\n        <td>9</td>\\n        <td>0</td>\\n        <td>111010110#</td>\\n    </tr>\\n    </tbody>\\n</table>\\n\\nSuppose we are looking for `word = \"0\"`, there are three suffix that matches word and the most left is the one at middle, then among all suffixes that contains word we need the minimum one in this case `min(sa[1], sa[2], sa[3]) = sa[2] = 3`.\\n\\nGiven an array of integers and some range $$(L,R)$$, how to find the minimum element between the range?\\n\\nThis is a classic problem in competitve programming called [Range Minimum Query (RMQ)](https://cp-algorithms.com/sequences/rmq.html) there are many approaches to solve this problem. Because the array is inmutable i used a sparse table, sparce table preprocess the array in $$O(n *log(n))$$ and answer queries in $$O(1)$$.      \\n\\n# Complexity\\n\\nTime complexity:\\n- Build Suffix array $$O(n * log^2(n))$$\\n- Build Sparse Table $$O(n *log(n))$$\\n- Answer one query $$O(m * log(n))$$ where $$m$$ is at most 30\\n- Answer all queryes $$O(Q * 30 * log(n))$$  \\n\\nSpace complexity:\\n- Store suffix array $$O(n)$$\\n- Store sparse table $$O(n * log(n))$$\\n\\n# Conclusion\\n\\nSuffix array is a usefull data structure to solve many problems involving strings for example count the number of differen substrings, Longest palindromic substring, longest common substring\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    struct SparseTable {\\n        int n;\\n        vector<int> a;\\n        vector<vector<int>> rmq;\\n\\n        SparseTable(vector<int>& _a) : a(_a), n(_a.size()) {\\n            rmq.assign(n, vector<int>(18));\\n            for (int i = 0; i < n; ++i) rmq[i][0] = i;\\n            for (int j = 1; (1 << j) <= n; j++) {\\n                for (int i = 0; i + (1 << j) - 1 < n; i++) {\\n                    int x = rmq[i][j - 1];\\n                    int y = rmq[i + (1 << (j - 1))][j - 1];\\n                    rmq[i][j] = (a[x] < a[y]) ? x : y;\\n                }\\n            }\\n        }\\n\\n        int query(int i, int j) {\\n            int k = 31 - __builtin_clz(j - i + 1);\\n            int x = rmq[i][k];\\n            int y = rmq[j - (1 << k) + 1][k];\\n            return a[x] < a[y] ? x : y;\\n        }\\n    };\\n\\n    struct SuffixArray {\\n        string s;\\n        vector<int> sa, rank;\\n\\n        SuffixArray(const string &s) : s(s), sa(s.size()), rank(s.size()) {\\n            int n = s.size();\\n            for (int i = 0; i < n; i++)\\n                sa[i] = i, rank[i] = (int)s[i];\\n            vector<int> tmp(n);\\n            for (int h = 1; tmp[n - 1] != n - 1; h *= 2) {\\n                auto cmp = [&](int i, int j) {\\n                    if (rank[i] != rank[j]) return rank[i] < rank[j];\\n                    return (i + h < n && j + h < n ? rank[i + h] < rank[j + h] : i > j);\\n                };\\n                sort(sa.begin(), sa.end(), cmp);\\n                for (int i = 0; i < n - 1; i++)\\n                    tmp[i + 1] = tmp[i] + cmp(sa[i], sa[i + 1]);\\n                for (int i = 0; i < n; i++)\\n                    rank[sa[i]] = tmp[i]; \\n            }\\n        }\\n    };\\n\\n    // Return the index of first suffix compares EQUAL or GREATER than string p\\n    int lowerbound(const SuffixArray &SA, const string &p) {\\n        int n = SA.s.size(), low = 0, hig = n;\\n        while (low < hig) {\\n            int mid = (low + hig) / 2;\\n            int res = SA.s.compare(SA.sa[mid], p.size(), p);\\n            if (res >= 0)\\n                hig = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        return low;\\n    }\\n    \\n    // Return the index of first suffix compares stricly GREATER than string p\\n    // Notice lowerbound and upperbound return the same value when all suffix not match with p \\n    int upperbound(const SuffixArray &SA, const string &p) {\\n        int n = SA.s.size(), low = 0, hig = n;\\n        while (low < hig) {\\n            int mid = (low + hig) / 2;\\n            int res = SA.s.compare(SA.sa[mid], p.size(), p);\\n            if (res <= 0)\\n                low = mid + 1;\\n            else\\n                hig = mid;\\n        }\\n        return low;\\n    }\\n\\n    // Converts number x in binary\\n    string binary(int x) {\\n        if (x == 0) return \"0\";\\n        string s;\\n        while (x) {\\n            if (x & 1)\\n                s.push_back(\\'1\\');\\n            else\\n                s.push_back(\\'0\\');\\n            x /= 2;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n    \\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        s.push_back(\\'#\\');\\n        SuffixArray sa(s);\\n        SparseTable st(sa.sa);\\n\\n        vector<vector<int>> ans;\\n        for (auto q : queries) {\\n            int x = q[0] ^ q[1];\\n            string word = binary(x);\\n            int l = lowerbound(sa, word); // O(m * log(n))\\n            int r = upperbound(sa, word); // O(m * log(n))\\n            vector<int> rango{-1,-1};\\n            // Some suffix matches with word\\n            if (l <= n and sa.s.compare(sa.sa[l], word.size(), word) == 0) {\\n                int mostLeft = st.query(l, r - 1); // O(1)\\n                rango[0] = sa.sa[mostLeft];\\n                rango[1] = sa.sa[mostLeft] + int(word.size()) - 1;\\n            }\\n            ans.push_back(rango);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    \\n    struct SparseTable {\\n        int n;\\n        vector<int> a;\\n        vector<vector<int>> rmq;\\n\\n        SparseTable(vector<int>& _a) : a(_a), n(_a.size()) {\\n            rmq.assign(n, vector<int>(18));\\n            for (int i = 0; i < n; ++i) rmq[i][0] = i;\\n            for (int j = 1; (1 << j) <= n; j++) {\\n                for (int i = 0; i + (1 << j) - 1 < n; i++) {\\n                    int x = rmq[i][j - 1];\\n                    int y = rmq[i + (1 << (j - 1))][j - 1];\\n                    rmq[i][j] = (a[x] < a[y]) ? x : y;\\n                }\\n            }\\n        }\\n\\n        int query(int i, int j) {\\n            int k = 31 - __builtin_clz(j - i + 1);\\n            int x = rmq[i][k];\\n            int y = rmq[j - (1 << k) + 1][k];\\n            return a[x] < a[y] ? x : y;\\n        }\\n    };\\n\\n    struct SuffixArray {\\n        string s;\\n        vector<int> sa, rank;\\n\\n        SuffixArray(const string &s) : s(s), sa(s.size()), rank(s.size()) {\\n            int n = s.size();\\n            for (int i = 0; i < n; i++)\\n                sa[i] = i, rank[i] = (int)s[i];\\n            vector<int> tmp(n);\\n            for (int h = 1; tmp[n - 1] != n - 1; h *= 2) {\\n                auto cmp = [&](int i, int j) {\\n                    if (rank[i] != rank[j]) return rank[i] < rank[j];\\n                    return (i + h < n && j + h < n ? rank[i + h] < rank[j + h] : i > j);\\n                };\\n                sort(sa.begin(), sa.end(), cmp);\\n                for (int i = 0; i < n - 1; i++)\\n                    tmp[i + 1] = tmp[i] + cmp(sa[i], sa[i + 1]);\\n                for (int i = 0; i < n; i++)\\n                    rank[sa[i]] = tmp[i]; \\n            }\\n        }\\n    };\\n\\n    // Return the index of first suffix compares EQUAL or GREATER than string p\\n    int lowerbound(const SuffixArray &SA, const string &p) {\\n        int n = SA.s.size(), low = 0, hig = n;\\n        while (low < hig) {\\n            int mid = (low + hig) / 2;\\n            int res = SA.s.compare(SA.sa[mid], p.size(), p);\\n            if (res >= 0)\\n                hig = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        return low;\\n    }\\n    \\n    // Return the index of first suffix compares stricly GREATER than string p\\n    // Notice lowerbound and upperbound return the same value when all suffix not match with p \\n    int upperbound(const SuffixArray &SA, const string &p) {\\n        int n = SA.s.size(), low = 0, hig = n;\\n        while (low < hig) {\\n            int mid = (low + hig) / 2;\\n            int res = SA.s.compare(SA.sa[mid], p.size(), p);\\n            if (res <= 0)\\n                low = mid + 1;\\n            else\\n                hig = mid;\\n        }\\n        return low;\\n    }\\n\\n    // Converts number x in binary\\n    string binary(int x) {\\n        if (x == 0) return \"0\";\\n        string s;\\n        while (x) {\\n            if (x & 1)\\n                s.push_back(\\'1\\');\\n            else\\n                s.push_back(\\'0\\');\\n            x /= 2;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n    \\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        s.push_back(\\'#\\');\\n        SuffixArray sa(s);\\n        SparseTable st(sa.sa);\\n\\n        vector<vector<int>> ans;\\n        for (auto q : queries) {\\n            int x = q[0] ^ q[1];\\n            string word = binary(x);\\n            int l = lowerbound(sa, word); // O(m * log(n))\\n            int r = upperbound(sa, word); // O(m * log(n))\\n            vector<int> rango{-1,-1};\\n            // Some suffix matches with word\\n            if (l <= n and sa.s.compare(sa.sa[l], word.size(), word) == 0) {\\n                int mostLeft = st.query(l, r - 1); // O(1)\\n                rango[0] = sa.sa[mostLeft];\\n                rango[1] = sa.sa[mostLeft] + int(word.size()) - 1;\\n            }\\n            ans.push_back(rango);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180666,
                "title": "c-map-brute",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        val ^ first = second\\n        val = first ^ second;\\n        \\n        \\n        map <val, pair<i, j>>\\n        \\n        101101\\n        \\n        1\\n        10\\n        101\\n        1011\\n        10110\\n        101101\\n        0\\n        01\\n        011\\n        0110\\n        01101\\n        1\\n        11\\n        110\\n        1101\\n        1\\n        10\\n        101\\n        0\\n        01\\n        0\\n        \\n        \\n        11110010100101001011010\\n    \\n    */\\n       long long bin_to_dec(string x){\\n        int val = 0; long long multi = 1;\\n        \\n        for(int i = x.size() - 1 ; i >= 0 ; i--){\\n            val += multi * (x[i] - \\'0\\');\\n            multi *= 2;\\n        }\\n        \\n        return val;\\n    }\\n    \\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size(), fxors = 0;;\\n        vector<string>subs;\\n        unordered_map<int, pair<int, int>> mp;\\n        \\n        // Finding if there exists a \\'0\\' in the string\\n        for(int i= 0; i < n; i++)if(s[i] == \\'0\\'){mp[0] = {i, i}; break;}\\n        \\n        // Getting all substrings and removing the trailing zeroes\\n        for(int i = 0 ; i < s.size(); i++){\\n            string ss = \"\";\\n            int count = 0;\\n            if(s[i] == \\'1\\'){\\n                for(int j = i ; j < s.size() && count < 32; j++){\\n                    ss += s[j];\\n                    count++;\\n                    int val = bin_to_dec(ss);\\n                    if(mp.find(val) != mp.end())continue;\\n                    mp[val] = make_pair(i, j);\\n                }\\n            }\\n        }\\n        \\n        // Getting the answers\\n        vector<vector<int>>res;\\n        for(int i = 0 ; i < queries.size() ; i++){\\n            fxors = queries[i][0] ^ queries[i][1];\\n            if(mp.find(fxors) != mp.end())res.push_back({mp[fxors].first, mp[fxors].second});\\n            else res.push_back({-1, -1});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        val ^ first = second\\n        val = first ^ second;\\n        \\n        \\n        map <val, pair<i, j>>\\n        \\n        101101\\n        \\n        1\\n        10\\n        101\\n        1011\\n        10110\\n        101101\\n        0\\n        01\\n        011\\n        0110\\n        01101\\n        1\\n        11\\n        110\\n        1101\\n        1\\n        10\\n        101\\n        0\\n        01\\n        0\\n        \\n        \\n        11110010100101001011010\\n    \\n    */\\n       long long bin_to_dec(string x){\\n        int val = 0; long long multi = 1;\\n        \\n        for(int i = x.size() - 1 ; i >= 0 ; i--){\\n            val += multi * (x[i] - \\'0\\');\\n            multi *= 2;\\n        }\\n        \\n        return val;\\n    }\\n    \\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size(), fxors = 0;;\\n        vector<string>subs;\\n        unordered_map<int, pair<int, int>> mp;\\n        \\n        // Finding if there exists a \\'0\\' in the string\\n        for(int i= 0; i < n; i++)if(s[i] == \\'0\\'){mp[0] = {i, i}; break;}\\n        \\n        // Getting all substrings and removing the trailing zeroes\\n        for(int i = 0 ; i < s.size(); i++){\\n            string ss = \"\";\\n            int count = 0;\\n            if(s[i] == \\'1\\'){\\n                for(int j = i ; j < s.size() && count < 32; j++){\\n                    ss += s[j];\\n                    count++;\\n                    int val = bin_to_dec(ss);\\n                    if(mp.find(val) != mp.end())continue;\\n                    mp[val] = make_pair(i, j);\\n                }\\n            }\\n        }\\n        \\n        // Getting the answers\\n        vector<vector<int>>res;\\n        for(int i = 0 ; i < queries.size() ; i++){\\n            fxors = queries[i][0] ^ queries[i][1];\\n            if(mp.find(fxors) != mp.end())res.push_back({mp[fxors].first, mp[fxors].second});\\n            else res.push_back({-1, -1});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180540,
                "title": "intutive-c-soln-using-map-commented-easy-to-understand",
                "content": "# Intuition\\n- we will precompute the first  occurence of all possible subsstring without leading zero \\n- store their starting and ending index in a map\\n- Now we ll take querries .\\n- By using xor properties we ll take xor of both element of each query . And convert it to its binary form\\n- By using map we will find its position\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string bin(int req){\\n       // converting number to its binary representation\\n       if(req==0)return \"0\";\\n       string s=\"\";\\n       while(req){\\n           if(req&1)s.push_back(\\'1\\');\\n           else s.push_back(\\'0\\');\\n           req/=2;\\n\\n       }\\n       reverse(s.begin(),s.end());\\n       return s;\\n   } \\nvoid solv(string&s,map<string,vector<int>>&m){\\n    // precomputation  the first occurence of a substring\\n     for(int i=0;i<s.length();i++){\\n             string str=\"\";\\n            if(s[i]==\\'0\\'){\\n// shortest substring will not contain leading zero so we ll neglect leading zeros\\n               str.push_back(\\'0\\');\\n                if(m.find(str)==m.end())\\n                    m[str]={i,i};\\n                  \\n                continue;\\n            }\\n      for(int j=i;j<s.length();j++){\\n  if(str.length()>30)break; \\n  // 2 to power 30 will be greater than 1e9; so we ll not go beyond the 30 size string\\n                str.push_back(s[j]);\\n                if(m.find(str)==m.end())m[str]={i,j};\\n            }\\n        }\\n    \\n }\\n\\n vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        vector<vector<int>>ans;\\n        map<string,vector<int>>m;\\n        solv(s,m);\\n        \\n    for(int i=0;i<q.size(); i++){\\n            \\n     int req=q[i][0]^q[i][1]; \\n     // using xor property if(a^b=c)then b^c=a\\n // we ll find the first occurence of binary representation of req\\n        \\n        string str=bin(req);\\n        if(m.find(str)==m.end())ans.push_back({-1,-1});\\n         else ans.push_back(m[str]);\\n            \\n    }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string bin(int req){\\n       // converting number to its binary representation\\n       if(req==0)return \"0\";\\n       string s=\"\";\\n       while(req){\\n           if(req&1)s.push_back(\\'1\\');\\n           else s.push_back(\\'0\\');\\n           req/=2;\\n\\n       }\\n       reverse(s.begin(),s.end());\\n       return s;\\n   } \\nvoid solv(string&s,map<string,vector<int>>&m){\\n    // precomputation  the first occurence of a substring\\n     for(int i=0;i<s.length();i++){\\n             string str=\"\";\\n            if(s[i]==\\'0\\'){\\n// shortest substring will not contain leading zero so we ll neglect leading zeros\\n               str.push_back(\\'0\\');\\n                if(m.find(str)==m.end())\\n                    m[str]={i,i};\\n                  \\n                continue;\\n            }\\n      for(int j=i;j<s.length();j++){\\n  if(str.length()>30)break; \\n  // 2 to power 30 will be greater than 1e9; so we ll not go beyond the 30 size string\\n                str.push_back(s[j]);\\n                if(m.find(str)==m.end())m[str]={i,j};\\n            }\\n        }\\n    \\n }\\n\\n vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        vector<vector<int>>ans;\\n        map<string,vector<int>>m;\\n        solv(s,m);\\n        \\n    for(int i=0;i<q.size(); i++){\\n            \\n     int req=q[i][0]^q[i][1]; \\n     // using xor property if(a^b=c)then b^c=a\\n // we ll find the first occurence of binary representation of req\\n        \\n        string str=bin(req);\\n        if(m.find(str)==m.end())ans.push_back({-1,-1});\\n         else ans.push_back(m[str]);\\n            \\n    }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175252,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map <int,pair<int,int>> ump;\\n        int curr,n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'0\\' && ump.find(0) == ump.end()){\\n                ump[0] = {i,i};\\n                continue;\\n            }\\n            else if(s[i] == \\'0\\')\\n                continue;\\n            curr = 0;\\n            for(int j=i;j<min(31+i,n);j++){\\n                curr <<=1 ;\\n                curr += s[j]-\\'0\\';\\n                if(ump.find(curr) == ump.end()){\\n                    ump[curr] = {i,j};\\n                }\\n             }\\n        }\\n        // cout << ump[5].first << ump[5].second << endl;\\n        vector <vector<int>> ans;\\n        for(auto &it:queries){\\n            curr = it[0] ^ it[1];\\n            if(ump.find(curr) == ump.end())\\n                ans.push_back({-1,-1});\\n            else\\n                ans.push_back({ump[curr].first,ump[curr].second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map <int,pair<int,int>> ump;\\n        int curr,n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'0\\' && ump.find(0) == ump.end()){\\n                ump[0] = {i,i};\\n                continue;\\n            }\\n            else if(s[i] == \\'0\\')\\n                continue;\\n            curr = 0;\\n            for(int j=i;j<min(31+i,n);j++){\\n                curr <<=1 ;\\n                curr += s[j]-\\'0\\';\\n                if(ump.find(curr) == ump.end()){\\n                    ump[curr] = {i,j};\\n                }\\n             }\\n        }\\n        // cout << ump[5].first << ump[5].second << endl;\\n        vector <vector<int>> ans;\\n        for(auto &it:queries){\\n            curr = it[0] ^ it[1];\\n            if(ump.find(curr) == ump.end())\\n                ans.push_back({-1,-1});\\n            else\\n                ans.push_back({ump[curr].first,ump[curr].second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3174410,
                "title": "c-pre-hash",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, vector<int>> h;\\n        for (int i = 1; i < 31; i++) {\\n            for (int j = 0; j + i <= s.size(); j++) {\\n                auto v = bitset<32>(s.substr(j, i)).to_ulong();\\n                if (auto f = h.find(v); f == h.end()) {\\n                    h[v] = {j, i + j - 1};\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        ans.reserve(queries.size());\\n        for (const auto& q : queries) {\\n            auto qq = q[0] ^ q[1];\\n            if (auto f = h.find(qq); f != h.end()) {\\n                ans.push_back(f->second);\\n            } else {\\n                ans.push_back({-1, -1});\\n            }\\n        }\\n        return ans;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, vector<int>> h;\\n        for (int i = 1; i < 31; i++) {\\n            for (int j = 0; j + i <= s.size(); j++) {\\n                auto v = bitset<32>(s.substr(j, i)).to_ulong();\\n                if (auto f = h.find(v); f == h.end()) {\\n                    h[v] = {j, i + j - 1};\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        ans.reserve(queries.size());\\n        for (const auto& q : queries) {\\n            auto qq = q[0] ^ q[1];\\n            if (auto f = h.find(qq); f != h.end()) {\\n                ans.push_back(f->second);\\n            } else {\\n                ans.push_back({-1, -1});\\n            }\\n        }\\n        return ans;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174407,
                "title": "window-from-1-to-30",
                "content": "\\nAs range from 0 <= first, second <= 10^9\\n\\nXOR of both will go max upto 1e9 which contain 30 bit at max..\\n\\nSo we need to find all substring from length 1 to 30 and convert to decimal and store {i,j} pair in map in O(n*30)\\n\\nfor every query we simply find if xor exist or not in O(logn) per query\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(string a){\\n        \\n       \\n        int ans = 0;\\n        int j = 0;\\n        for(int i = a.length()-1;i>=0;i--)\\n        {\\n            ans = ans + (a[i]-\\'0\\')*(int)(pow(2,j));\\n            j++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q){\\n        \\n        \\n        int l = s.length();\\n        map<int,vector<pair<int,int>>> mp;\\n       \\n        \\n        for(int i = 1;i<=30;i++)\\n        {\\n            for(int j = 0;j<=l-i;j++){\\n                int x = f(s.substr(j,i));\\n                mp[x].push_back({j,j+i-1});\\n            }\\n        }\\n        \\n     \\n        vector<vector<int>> ans;\\n        \\n        \\n        for(auto a : q){\\n            \\n           int f = (a[0] ^ a[1]);\\n           if(mp.find(f) != mp.end()){\\n               auto x = mp[f];\\n               ans.push_back({x[0].first,x[0].second});\\n           }  \\n           else\\n               ans.push_back({-1,-1});\\n          \\n           \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(string a){\\n        \\n       \\n        int ans = 0;\\n        int j = 0;\\n        for(int i = a.length()-1;i>=0;i--)\\n        {\\n            ans = ans + (a[i]-\\'0\\')*(int)(pow(2,j));\\n            j++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q){\\n        \\n        \\n        int l = s.length();\\n        map<int,vector<pair<int,int>>> mp;\\n       \\n        \\n        for(int i = 1;i<=30;i++)\\n        {\\n            for(int j = 0;j<=l-i;j++){\\n                int x = f(s.substr(j,i));\\n                mp[x].push_back({j,j+i-1});\\n            }\\n        }\\n        \\n     \\n        vector<vector<int>> ans;\\n        \\n        \\n        for(auto a : q){\\n            \\n           int f = (a[0] ^ a[1]);\\n           if(mp.find(f) != mp.end()){\\n               auto x = mp[f];\\n               ans.push_back({x[0].first,x[0].second});\\n           }  \\n           else\\n               ans.push_back({-1,-1});\\n          \\n           \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174311,
                "title": "o-n-32-solution-using-hash-map-and-pre-computation-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet query be denoted by q then we need to find any shortest substring of s such that it\\'s decimal value xored with first query parameter equals to second query parameter, i.e.\\n\\n```\\ndecimalValue(someSubstring(s)) ^ q.first = q.second\\n\\ntake xor with q.first on both sides :\\n\\ndecimalValue(someSubstring(s)) ^ q.first ^ q.first = q.second ^ q.first\\ndecimalValue(someSubstring(s)) = q.second ^ q.first\\n\\n```\\n\\nThe question is now reduced to find shortest substring of s that has a decimal value of `q.second ^ q.first`\\nSince `q.second ^ q.first` is an integer value upto $$10^9$$ it can conatin upto $$32$$ bits only.\\nWe can pre compute all substrings of `length greater than equal to 1  and less than equal to 32`\\nWe can use `queue` to store the current window of size $$k$$ where $$1=<k<=32$$\\n\\n\\n# Complexity\\n**Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n######        O(n*32) ~ O(n)\\n\\n**Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n######        O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //function to get number of bits in an integer\\n    int get(int x ){\\n        if(x==0) return 1;\\n        int cnt=0;\\n        while(x){\\n            cnt++;\\n            x/=2;\\n        }\\n        return cnt;   \\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string &s, vector<vector<int>>& queries) {\\n        unordered_map<long,int> m;\\n        for(int k=1;k<=min((int)s.length(),31);k++){\\n            queue<bool> q;\\n            long ans=0;\\n//first store the decimal value of length k substring\\n            for(int i=0;i<k;i++){\\n                ans*=2;\\n                q.push(s[i]-\\'0\\');\\n                ans+=(s[i]-\\'0\\');\\n                \\n            }\\n//if current value is not stored in map store the left index of the value\\n            if(!m.count(ans))\\n            m[ans] =0;\\n            int j= 1;\\n//use a sliding window of size k to process all substrings \\n            for(int i = k;i<s.length();i++){\\n//if the front of the queue is 1 then we need to remove the contribution of that bit in decimal value\\n                if(q.front()==1){\\n                    ans-=(1<<(k-1));\\n                }\\n//left shift value to adjust new bit\\n                ans*=2;\\n                q.pop();\\n                q.push(s[i]-\\'0\\');\\n                ans+=(s[i]-\\'0\\');\\n//if not already present mark the starting index of the value\\n                if(!m.count(ans)){\\n                     m[ans] =j;   \\n                }\\n               \\n                j++;\\n//increment starting index\\n            }\\n        }\\n        vector<vector<int> > ans;\\n        for(auto x:queries){\\n            int y = (x[0]^x[1]);\\n            if(!m.count(y)) ans.push_back({-1,-1});\\n            else ans.push_back({m[y],m[y]+get(y)-1});\\n//store in ans the left index , left index + size of the substring(in binary representation)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ndecimalValue(someSubstring(s)) ^ q.first = q.second\\n\\ntake xor with q.first on both sides :\\n\\ndecimalValue(someSubstring(s)) ^ q.first ^ q.first = q.second ^ q.first\\ndecimalValue(someSubstring(s)) = q.second ^ q.first\\n\\n```\n```\\nclass Solution {\\npublic:\\n    //function to get number of bits in an integer\\n    int get(int x ){\\n        if(x==0) return 1;\\n        int cnt=0;\\n        while(x){\\n            cnt++;\\n            x/=2;\\n        }\\n        return cnt;   \\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string &s, vector<vector<int>>& queries) {\\n        unordered_map<long,int> m;\\n        for(int k=1;k<=min((int)s.length(),31);k++){\\n            queue<bool> q;\\n            long ans=0;\\n//first store the decimal value of length k substring\\n            for(int i=0;i<k;i++){\\n                ans*=2;\\n                q.push(s[i]-\\'0\\');\\n                ans+=(s[i]-\\'0\\');\\n                \\n            }\\n//if current value is not stored in map store the left index of the value\\n            if(!m.count(ans))\\n            m[ans] =0;\\n            int j= 1;\\n//use a sliding window of size k to process all substrings \\n            for(int i = k;i<s.length();i++){\\n//if the front of the queue is 1 then we need to remove the contribution of that bit in decimal value\\n                if(q.front()==1){\\n                    ans-=(1<<(k-1));\\n                }\\n//left shift value to adjust new bit\\n                ans*=2;\\n                q.pop();\\n                q.push(s[i]-\\'0\\');\\n                ans+=(s[i]-\\'0\\');\\n//if not already present mark the starting index of the value\\n                if(!m.count(ans)){\\n                     m[ans] =j;   \\n                }\\n               \\n                j++;\\n//increment starting index\\n            }\\n        }\\n        vector<vector<int> > ans;\\n        for(auto x:queries){\\n            int y = (x[0]^x[1]);\\n            if(!m.count(y)) ans.push_back({-1,-1});\\n            else ans.push_back({m[y],m[y]+get(y)-1});\\n//store in ans the left index , left index + size of the substring(in binary representation)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174238,
                "title": "c-tc-o-n-sc-o-n-explained-with-comments",
                "content": "TC -> O(n * (32*32)) => O(n)\\nSC -> O(n)\\n```\\nclass Solution {\\n#define ll long long\\n    unordered_map<ll,vector<int>> mp;  // to store values which can be generted from substrings of string s with its corresponding start and end points\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int val= min(31, (int)s.length()); // to get at max window of size 31 because at max 31 bits can make all positive integer values\\n        for(int i=1; i<=val; i++){\\n            vals(i,s); // calling for every window from 1 to 31\\n        }\\n        vector<vector<int>> ans;\\n        for(auto i: queries){\\n            // if a^b==x then a^x==b hence we will get the val which we have to find by doing first^second \\n            if(mp.find(i[0]^i[1])!=mp.end()){ \\n                ans.push_back(mp[i[0]^i[1]]);\\n            }\\n            else ans.push_back({-1,-1});\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void vals(int k, string &s){\\n        deque<ll> q;\\n        int i=0;\\n        for(i=0; i<s.length(); i++){\\n            if(i>=k){\\n                ll val=0, cnt=0;\\n                for(auto j: q){ // iterating over queue\\n                    cnt++;\\n                    val+= (j*pow(2,(int)q.size()-cnt)); // getting the value from window of size k\\n                }\\n                if(mp.find(val)==mp.end()){\\n                    mp[val]= {i-(int)q.size(),i-1}; // if value exist then don\\'t update because we need left to be minimum\\n                }\\n                q.pop_front(); // pop front value from deque to maintain window of size k\\n            }\\n            if(s[i]==\\'0\\')\\n            q.push_back(0);\\n            else q.push_back(1);\\n        }\\n        ll val=0, cnt=0;\\n        for(auto j: q){\\n            cnt++;\\n            val+= (j*pow(2,(int)q.size()-cnt));\\n        }\\n        if(mp.find(val)==mp.end()){\\n            mp[val]= {i-(int)q.size(),i-1};\\n        }\\n        return;\\n    }\\n};\\n```\\nPlease upvote if you liked the solution ^_^",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n#define ll long long\\n    unordered_map<ll,vector<int>> mp;  // to store values which can be generted from substrings of string s with its corresponding start and end points\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int val= min(31, (int)s.length()); // to get at max window of size 31 because at max 31 bits can make all positive integer values\\n        for(int i=1; i<=val; i++){\\n            vals(i,s); // calling for every window from 1 to 31\\n        }\\n        vector<vector<int>> ans;\\n        for(auto i: queries){\\n            // if a^b==x then a^x==b hence we will get the val which we have to find by doing first^second \\n            if(mp.find(i[0]^i[1])!=mp.end()){ \\n                ans.push_back(mp[i[0]^i[1]]);\\n            }\\n            else ans.push_back({-1,-1});\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void vals(int k, string &s){\\n        deque<ll> q;\\n        int i=0;\\n        for(i=0; i<s.length(); i++){\\n            if(i>=k){\\n                ll val=0, cnt=0;\\n                for(auto j: q){ // iterating over queue\\n                    cnt++;\\n                    val+= (j*pow(2,(int)q.size()-cnt)); // getting the value from window of size k\\n                }\\n                if(mp.find(val)==mp.end()){\\n                    mp[val]= {i-(int)q.size(),i-1}; // if value exist then don\\'t update because we need left to be minimum\\n                }\\n                q.pop_front(); // pop front value from deque to maintain window of size k\\n            }\\n            if(s[i]==\\'0\\')\\n            q.push_back(0);\\n            else q.push_back(1);\\n        }\\n        ll val=0, cnt=0;\\n        for(auto j: q){\\n            cnt++;\\n            val+= (j*pow(2,(int)q.size()-cnt));\\n        }\\n        if(mp.find(val)==mp.end()){\\n            mp[val]= {i-(int)q.size(),i-1};\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174146,
                "title": "python-clean-solution",
                "content": "use a dict to store numbers we can get from s\\n- number 10^9 can be represent with 30 bit\\n- for each index i, only need to look forward at most 30 bits\\n- for each number, store the shortest substring index\\n\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        dt, n = {}, len(s)\\n        for i in range(n):\\n            t = 0\\n            for j in range(i, min(i + 30, n)):\\n                t = (t << 1) | int(s[j])\\n                if t not in dt or dt[t][1] - dt[t][0] > j - i:\\n                    dt[t] = [i, j]\\n            \\n        return [dt.get(fir ^ sec, [-1, -1]) for fir, sec in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        dt, n = {}, len(s)\\n        for i in range(n):\\n            t = 0\\n            for j in range(i, min(i + 30, n)):\\n                t = (t << 1) | int(s[j])\\n                if t not in dt or dt[t][1] - dt[t][0] > j - i:\\n                    dt[t] = [i, j]\\n            \\n        return [dt.get(fir ^ sec, [-1, -1]) for fir, sec in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174132,
                "title": "hashmap-with-binary-substrings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Firstly, we simplify the equation `val ^ first = second`, by xoring with first on both sides which gives `val = second ^ first`\\n- now we just need to check if the binary representation of val exists in s, which will take  rougly linear time for checking existence.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Using a hashmap would help but storing all substrings would not be feasible\\n- Since val is an int value we know the size won\\'t exceed 32, hence we store a hashmap for each size of val which would make the lookup time constant.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        \\n        // stores all xored binary substrings that needs to be searches\\n        String[] substring = new String[queries.length];\\n        // stores all the sizes of the substrings\\n        Set<Integer> sizes = new HashSet<>();\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            substring[i] = Integer.toBinaryString(queries[i][0] ^ queries[i][1]);\\n            sizes.add(substring[i].length());\\n        }\\n        \\n        // map[size] -> map[binary_substring] -> leftmost_index\\n        Map<Integer, Map<String, Integer>> map = new HashMap<>();\\n        \\n        for (int size : sizes) {\\n            map.put(size, new HashMap<>());\\n            for (int i = 0; i <= s.length() - size; i++) {\\n                String key = s.substring(i, i + size );\\n                if (map.get(size).containsKey(key))\\n                    continue;\\n                map.get(size).put(key, i);\\n            }\\n        }\\n\\n        int[][] res = new int[queries.length][];\\n\\n        for (int i = 0 ;i < queries.length; i++) {\\n            int size = substring[i].length();\\n            if (map.get(size).containsKey(substring[i])) \\n                res[i] = new int[]{map.get(size).get(substring[i]), map.get(size).get(substring[i]) + size - 1};\\n            else\\n                res[i] = new int[]{-1, -1};\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        \\n        // stores all xored binary substrings that needs to be searches\\n        String[] substring = new String[queries.length];\\n        // stores all the sizes of the substrings\\n        Set<Integer> sizes = new HashSet<>();\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            substring[i] = Integer.toBinaryString(queries[i][0] ^ queries[i][1]);\\n            sizes.add(substring[i].length());\\n        }\\n        \\n        // map[size] -> map[binary_substring] -> leftmost_index\\n        Map<Integer, Map<String, Integer>> map = new HashMap<>();\\n        \\n        for (int size : sizes) {\\n            map.put(size, new HashMap<>());\\n            for (int i = 0; i <= s.length() - size; i++) {\\n                String key = s.substring(i, i + size );\\n                if (map.get(size).containsKey(key))\\n                    continue;\\n                map.get(size).put(key, i);\\n            }\\n        }\\n\\n        int[][] res = new int[queries.length][];\\n\\n        for (int i = 0 ;i < queries.length; i++) {\\n            int size = substring[i].length();\\n            if (map.get(size).containsKey(substring[i])) \\n                res[i] = new int[]{map.get(size).get(substring[i]), map.get(size).get(substring[i]) + size - 1};\\n            else\\n                res[i] = new int[]{-1, -1};\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174051,
                "title": "python-logical-solution",
                "content": "# Approach\\na^b=c => b^c=a\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, q: List[List[int]]) -> List[List[int]]:\\n        ot=[]\\n        n=len(q)\\n        for i in range(n) :\\n            het=q[i][0]^q[i][1]\\n            # print(q[i][0],q[i][1],het)\\n            x=bin(het)[2:]\\n            # print(het,x)\\n            if x in s :\\n                gojo=s.find(x)\\n                # print(gojo)\\n                ot.append([gojo,gojo+len(str(x))-1])\\n            else :\\n                ot.append([-1,-1])\\n        return ot\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, q: List[List[int]]) -> List[List[int]]:\\n        ot=[]\\n        n=len(q)\\n        for i in range(n) :\\n            het=q[i][0]^q[i][1]\\n            # print(q[i][0],q[i][1],het)\\n            x=bin(het)[2:]\\n            # print(het,x)\\n            if x in s :\\n                gojo=s.find(x)\\n                # print(gojo)\\n                ot.append([gojo,gojo+len(str(x))-1])\\n            else :\\n                ot.append([-1,-1])\\n        return ot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174026,
                "title": "c-o-nlogn-with-explanation-clean",
                "content": "# Solution \\n\\nWe want to find a $val$ such that \\n$first$ $XOR$ $val = second$ \\n\\nThis is equivalent to \\n$val = first$ $XOR$ $second$ \\nbecause XOR is its self inverse.\\n\\nAdditionally, the constraint on the queries ($q < 10^9$) guarentees that we only need 30 bits at most, because for all bits left of the 30th bit, we can ignore leading 0s, and leading 1s would make the decimal value of the substring be greater than the query. \\n\\nWe can loop through each substring of length less than or equal to 30, and increment our answer for that value accordingly, using map. This is in $O(Nlog^3A_i)$. Alternatively, we fix the left of each substring and go right, whcih works in $O(Nlog^2A_i)$. If we use an unordered_map, we can decrease this further to $O(NlogN)$, although the constant factor is quite high. \\n\\nMy implementation is $O(Nlog^2N)$, but changing map to unordered_map makes it $O(NlogN)$. \\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        //ans[x] = shortest substring that is x in decimal form \\n        map<int, vector<int>> ans; \\n        int n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            //fix the left of the substring \\n            int cur = 0; \\n            //go right until r-l+1 > 30 or end of string \\n            for (int j = 0; j < min(31, n-i); ++j) {\\n                //left shift count, add current bit\\n                cur <<= 1; \\n                cur += (int) (s[i+j]-\\'0\\'); \\n\\n                if (ans.find(cur) == ans.end()) {\\n                    ans[cur] = {i, i+j}; \\n                } else {\\n                    if (j < ans[cur][1] - ans[cur][0]) { \\n                        //modify answer if current is shorter\\n                        ans[cur] = {i, i+j}; \\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ret; \\n        for (auto u: queries) {\\n            int z = u[1] ^ u[0]; \\n            //process queries \\n            if (ans.find(z) != ans.end()) {\\n                ret.push_back({ans[z]}); \\n            } else {\\n                ret.push_back({-1, -1});\\n            }\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        //ans[x] = shortest substring that is x in decimal form \\n        map<int, vector<int>> ans; \\n        int n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            //fix the left of the substring \\n            int cur = 0; \\n            //go right until r-l+1 > 30 or end of string \\n            for (int j = 0; j < min(31, n-i); ++j) {\\n                //left shift count, add current bit\\n                cur <<= 1; \\n                cur += (int) (s[i+j]-\\'0\\'); \\n\\n                if (ans.find(cur) == ans.end()) {\\n                    ans[cur] = {i, i+j}; \\n                } else {\\n                    if (j < ans[cur][1] - ans[cur][0]) { \\n                        //modify answer if current is shorter\\n                        ans[cur] = {i, i+j}; \\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ret; \\n        for (auto u: queries) {\\n            int z = u[1] ^ u[0]; \\n            //process queries \\n            if (ans.find(z) != ans.end()) {\\n                ret.push_back({ans[z]}); \\n            } else {\\n                ret.push_back({-1, -1});\\n            }\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082100,
                "title": "python3-clean-solution-beginner-friendly",
                "content": "# Intuition\\n- Any 10^9 number can be represented by 30 bits, hence we only need to look forward 30 number\\n- We can get the target binary to fulfil the query by XOR-ing first and second.\\n- Since len(queries) > len(s) by alot it is better to preprocess S into a dict of possible values\\n\\n# Approach\\n- I iterated s from the back so if multiple string produces the same decimal number, the left most one would be taken\\n- I skipped `s[i] == \\'0\\'` so that the binary generated will not start with a 0\\n- int(value,2) converts the String value with base 2 into a decimal integer\\n\\n# Complexity\\n- Time complexity:\\nO(n*30)\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        df = {}\\n        n = len(s)\\n        for i in range(n-1, -1, -1):\\n            if s[i] == \\'0\\':\\n                df[0] = [i,i]\\n                continue\\n            for j in range(min(n,i+30), i, -1):\\n                df[int(s[i:j],2)] = [i,j-1]\\n\\n        return [df.get(a^b,[-1,-1]) for a,b in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        df = {}\\n        n = len(s)\\n        for i in range(n-1, -1, -1):\\n            if s[i] == \\'0\\':\\n                df[0] = [i,i]\\n                continue\\n            for j in range(min(n,i+30), i, -1):\\n                df[int(s[i:j],2)] = [i,j-1]\\n\\n        return [df.get(a^b,[-1,-1]) for a,b in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082088,
                "title": "python-beats-100-for-time-and-memory-clean-solution",
                "content": "# Intuition\\n- Any 10^9 number can be represented by 30 bits, hence we only need to look forward 30 number\\n- We can get the target binary to fulfil the query by XOR-ing first and second.\\n- Since len(queries) > len(s) by alot it is better to preprocess S into a dict of possible values\\n\\n# Approach\\n- I iterated s from the back so if multiple string produces the same decimal number, the left most one would be taken\\n- I skipped `s[i] == \\'0\\'` so that the binary generated will not start with a 0\\n- int(value,2) converts the String value with base 2 into a decimal integer\\n\\n# Complexity\\n- Time complexity:\\nO(n*30)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def substringXorQueries(self, s, queries):\\n        \"\"\"\\n        :type s: str\\n        :type queries: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        df = {}\\n        n = len(s)\\n        for i in range(n-1, -1, -1):\\n            if s[i] == \\'0\\':\\n                df[0] = [i,i]\\n                continue\\n            for j in range(min(n,i+30), i, -1):\\n                df[int(s[i:j],2)] = [i,j-1]\\n\\n        return [df.get(a^b,[-1,-1]) for a,b in queries]\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def substringXorQueries(self, s, queries):\\n        \"\"\"\\n        :type s: str\\n        :type queries: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        df = {}\\n        n = len(s)\\n        for i in range(n-1, -1, -1):\\n            if s[i] == \\'0\\':\\n                df[0] = [i,i]\\n                continue\\n            for j in range(min(n,i+30), i, -1):\\n                df[int(s[i:j],2)] = [i,j-1]\\n\\n        return [df.get(a^b,[-1,-1]) for a,b in queries]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040548,
                "title": "golang-hash-table-solution",
                "content": "# Code\\n```go\\nfunc substringXorQueries(s string, queries [][]int) [][]int {\\n\\tqueryHash := make(map[int][]int)\\n\\tfor _, query := range queries {\\n\\t\\tqueryHash[query[0]^query[1]] = make([]int, 0, 2)\\n\\t}\\nloop:\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == \\'0\\' {\\n\\t\\t\\tif len(queryHash[0]) == 0 {\\n\\t\\t\\t\\tqueryHash[0] = []int{i, i}\\n\\t\\t\\t}\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcurValue := 0\\n\\t\\tfor wide := 1; wide < 32; wide++ {\\n\\t\\t\\tidx := i+wide-1\\n\\t\\t\\tif idx >= len(s) {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t\\tcurValue = curValue << 1 + int(s[idx]-\\'0\\')\\n\\t\\t\\tif len(queryHash[curValue]) == 0 {\\n\\t\\t\\t\\tqueryHash[curValue] = []int{i, idx}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tresult := make([][]int, 0, len(queries))\\n\\tfor _, query := range queries {\\n\\t\\tv := queryHash[query[0]^query[1]]\\n\\t\\tif len(v) == 0 {\\n\\t\\t\\tresult = append(result, []int{-1, -1})\\n\\t\\t} else {\\n\\t\\t\\tresult = append(result, v)\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```go\\nfunc substringXorQueries(s string, queries [][]int) [][]int {\\n\\tqueryHash := make(map[int][]int)\\n\\tfor _, query := range queries {\\n\\t\\tqueryHash[query[0]^query[1]] = make([]int, 0, 2)\\n\\t}\\nloop:\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == \\'0\\' {\\n\\t\\t\\tif len(queryHash[0]) == 0 {\\n\\t\\t\\t\\tqueryHash[0] = []int{i, i}\\n\\t\\t\\t}\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcurValue := 0\\n\\t\\tfor wide := 1; wide < 32; wide++ {\\n\\t\\t\\tidx := i+wide-1\\n\\t\\t\\tif idx >= len(s) {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t\\tcurValue = curValue << 1 + int(s[idx]-\\'0\\')\\n\\t\\t\\tif len(queryHash[curValue]) == 0 {\\n\\t\\t\\t\\tqueryHash[curValue] = []int{i, idx}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tresult := make([][]int, 0, len(queries))\\n\\tfor _, query := range queries {\\n\\t\\tv := queryHash[query[0]^query[1]]\\n\\t\\tif len(v) == 0 {\\n\\t\\t\\tresult = append(result, []int{-1, -1})\\n\\t\\t} else {\\n\\t\\t\\tresult = append(result, v)\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968790,
                "title": "c-beats-100-speed-and-memory",
                "content": "# Intuition\\nIterating over the array at every query seems too slow. There has to be a way to find all substrings possible and save them.\\n\\n# Approach\\nPut all substring found in s in a Dictionary. We only need to go up to length 32 because ints have 32 bits so a binary string of an int will never be over 32 chars.\\nA further improvment could be to not remember sub strings with trailling zeros since we don\\'t need them.\\n\\n# Complexity\\nS being the length of the string and Q being the length of the queries array\\n- Time complexity: O(S + Q)\\n\\n- Space complexity: O(S)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] SubstringXorQueries(string s, int[][] queries) {\\n        Dictionary<string, int> subStrings = new Dictionary<string, int>();\\n        for(int i = 1; i <= 32; i++) {\\n            for(int j = 0; j + i <= s.Length; j++) {\\n                string sub = s.Substring(j, i);\\n                if(!subStrings.ContainsKey(sub)) {\\n                    subStrings[sub] = j;\\n                }\\n            }\\n        }\\n        int[][] ans = new int[queries.Length][];\\n        for(int i = 0; i < queries.Length; i++) {\\n            int toFind = queries[i][0] ^ queries[i][1];\\n            string toFindBin = Convert.ToString(toFind, 2);\\n            if(subStrings.TryGetValue(toFindBin, out int found)) {\\n                ans[i] = new int[] {found, found + toFindBin.Length - 1};\\n            } else {\\n                ans[i] = new int[] {-1, -1};\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] SubstringXorQueries(string s, int[][] queries) {\\n        Dictionary<string, int> subStrings = new Dictionary<string, int>();\\n        for(int i = 1; i <= 32; i++) {\\n            for(int j = 0; j + i <= s.Length; j++) {\\n                string sub = s.Substring(j, i);\\n                if(!subStrings.ContainsKey(sub)) {\\n                    subStrings[sub] = j;\\n                }\\n            }\\n        }\\n        int[][] ans = new int[queries.Length][];\\n        for(int i = 0; i < queries.Length; i++) {\\n            int toFind = queries[i][0] ^ queries[i][1];\\n            string toFindBin = Convert.ToString(toFind, 2);\\n            if(subStrings.TryGetValue(toFindBin, out int found)) {\\n                ans[i] = new int[] {found, found + toFindBin.Length - 1};\\n            } else {\\n                ans[i] = new int[] {-1, -1};\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905716,
                "title": "c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        int n = s.length();\\n        map<int, int> mpL;\\n        map<int, int> mpR;\\n        int sum, twoPow;\\n        for(int i = 1; i <= min(30, n); i++){\\n            twoPow = pow(2, i-1);\\n            sum = 0;\\n            for(int j = 0; j < i; j++){\\n                if(s[j] == \\'1\\')\\n                    sum += twoPow;\\n                twoPow /= 2;\\n            }\\n            if(mpL.find(sum) == mpL.end()){\\n                mpL[sum] = 0;\\n                mpR[sum] = i-1;\\n            }\\n            twoPow = pow(2, i-1);\\n            for(int j = 1; j <= (n - i); j++){\\n                if(s[j-1] == \\'1\\')\\n                    sum -= twoPow;\\n                sum = sum << 1;\\n                if(s[j + i - 1] == \\'1\\')\\n                    sum += 1;\\n                if(mpL.find(sum) == mpL.end()){\\n                    mpL[sum] = j;\\n                    mpR[sum] = j+i-1;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(q);\\n        int xorr;\\n        for(int i = 0; i < q; i++){\\n            xorr = queries[i][0] ^ queries[i][1];\\n            if(mpL.find(xorr) != mpL.end())\\n                ans[i] = {mpL[xorr], mpR[xorr]};\\n            else\\n                ans[i] = {-1, -1};\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        int n = s.length();\\n        map<int, int> mpL;\\n        map<int, int> mpR;\\n        int sum, twoPow;\\n        for(int i = 1; i <= min(30, n); i++){\\n            twoPow = pow(2, i-1);\\n            sum = 0;\\n            for(int j = 0; j < i; j++){\\n                if(s[j] == \\'1\\')\\n                    sum += twoPow;\\n                twoPow /= 2;\\n            }\\n            if(mpL.find(sum) == mpL.end()){\\n                mpL[sum] = 0;\\n                mpR[sum] = i-1;\\n            }\\n            twoPow = pow(2, i-1);\\n            for(int j = 1; j <= (n - i); j++){\\n                if(s[j-1] == \\'1\\')\\n                    sum -= twoPow;\\n                sum = sum << 1;\\n                if(s[j + i - 1] == \\'1\\')\\n                    sum += 1;\\n                if(mpL.find(sum) == mpL.end()){\\n                    mpL[sum] = j;\\n                    mpR[sum] = j+i-1;\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(q);\\n        int xorr;\\n        for(int i = 0; i < q; i++){\\n            xorr = queries[i][0] ^ queries[i][1];\\n            if(mpL.find(xorr) != mpL.end())\\n                ans[i] = {mpL[xorr], mpR[xorr]};\\n            else\\n                ans[i] = {-1, -1};\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670059,
                "title": "c-solution-full-explanation",
                "content": "# Approach\\n1) We can simplify val^first=second as val=second^first by taking xor with first on both sides we know(x^x=0 and x^0=x).\\n\\n2) According to contraints given (\"0 <= first, second<= 10^9\")\\nand we need 30 bits to represent 10^9 hence we take strings only upto length of 31.\\n\\n3) We store the value of substrings and their indexes in a map\\nand update indexes if we get that same value in smaller lengths of strings.\\n\\n4). We iterate over queries and store the indexes of val in ans(if exists).\\n\\n# Complexity\\n- Time complexity:O(31n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n\\n        unordered_map<int,pair<int,int>>m;\\n        int n=s.length();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int curr=0;\\n\\n            for(int j=0;j<min(31,n-i);j++)\\n            {\\n                curr <<= 1;\\n                curr += (int)(s[i + j] - \\'0\\');\\n\\n                if(m.find(curr)==m.end())\\n                {\\n                    m[curr]={i,i+j};\\n                }\\n                else\\n                {\\n                    if(j<m[curr].second-m[curr].first)\\n                        m[curr]={i,i+j};\\n                }\\n\\n            }\\n        }\\n            vector<vector<int>>ans;\\n            \\n            for(auto q:queries)\\n            {\\n                int x=q[1]^q[0];\\n                vector<int>v={-1,-1};\\n                if(m.find(x)!=m.end())\\n                {\\n                    v[0]=m[x].first;\\n                    v[1]=m[x].second;\\n                }\\n                ans.push_back(v);\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n\\n        unordered_map<int,pair<int,int>>m;\\n        int n=s.length();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int curr=0;\\n\\n            for(int j=0;j<min(31,n-i);j++)\\n            {\\n                curr <<= 1;\\n                curr += (int)(s[i + j] - \\'0\\');\\n\\n                if(m.find(curr)==m.end())\\n                {\\n                    m[curr]={i,i+j};\\n                }\\n                else\\n                {\\n                    if(j<m[curr].second-m[curr].first)\\n                        m[curr]={i,i+j};\\n                }\\n\\n            }\\n        }\\n            vector<vector<int>>ans;\\n            \\n            for(auto q:queries)\\n            {\\n                int x=q[1]^q[0];\\n                vector<int>v={-1,-1};\\n                if(m.find(x)!=m.end())\\n                {\\n                    v[0]=m[x].first;\\n                    v[1]=m[x].second;\\n                }\\n                ans.push_back(v);\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446749,
                "title": "python-beats-100-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        pos = {}\\n        n = len(s)\\n        for i in range(n):\\n            if s[i] == \\'0\\':\\n                if 0 not in pos:\\n                    pos[0] = i\\n                continue\\n            num = 0\\n            for j in range(i, min(i+32, n)):\\n                if s[j] == \\'1\\': num = (num<<1) | 1\\n                else: num <<= 1\\n                if num not in pos:\\n                    pos[num] = i\\n        # print(pos)\\n        ans = []\\n        for f, s in queries:\\n            n = f^s\\n            # print(f,s,n)\\n            p = pos.get(n)\\n            if p is None:\\n                ans.append((-1, -1))\\n            else:\\n                l = math.floor(math.log2(n)) if n else 0\\n                ans.append((p, p+l))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        pos = {}\\n        n = len(s)\\n        for i in range(n):\\n            if s[i] == \\'0\\':\\n                if 0 not in pos:\\n                    pos[0] = i\\n                continue\\n            num = 0\\n            for j in range(i, min(i+32, n)):\\n                if s[j] == \\'1\\': num = (num<<1) | 1\\n                else: num <<= 1\\n                if num not in pos:\\n                    pos[num] = i\\n        # print(pos)\\n        ans = []\\n        for f, s in queries:\\n            n = f^s\\n            # print(f,s,n)\\n            p = pos.get(n)\\n            if p is None:\\n                ans.append((-1, -1))\\n            else:\\n                l = math.floor(math.log2(n)) if n else 0\\n                ans.append((p, p+l))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429338,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        mp = {}\\n        res = []\\n        for sub in range(1,31):\\n            i,j=0,sub\\n            while j<=len(s):\\n                mp.setdefault(int(s[i:j],2),(i,j-1))\\n                i+=1\\n                j+=1\\n                \\n        for first,second in queries:\\n            k = first^second\\n            if k in mp:\\n                res.append(mp[k])\\n            else:\\n                res.append([-1,-1])\\n                \\n        return res\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        mp = {}\\n        res = []\\n        for sub in range(1,31):\\n            i,j=0,sub\\n            while j<=len(s):\\n                mp.setdefault(int(s[i:j],2),(i,j-1))\\n                i+=1\\n                j+=1\\n                \\n        for first,second in queries:\\n            k = first^second\\n            if k in mp:\\n                res.append(mp[k])\\n            else:\\n                res.append([-1,-1])\\n                \\n        return res\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405560,
                "title": "hash-map",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[][]}\\n */\\nvar substringXorQueries = function(s, queries) {\\n  const memo = new Array(30);\\n  const n = s.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    if (s[i] === \\'0\\') {\\n      if (!memo[0]) memo[0] = [i, i];\\n      continue;\\n    }\\n\\n    let num = 0;\\n    for (let j = i; j < Math.min(i + 30, n); j++) {\\n      num = (num << 1) | +s[j];\\n      if (!memo[num]) memo[num] = [i, j];\\n    }\\n  }\\n\\n  return queries.map(([a, b]) => memo[a ^ b] ?? [-1, -1]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[][]}\\n */\\nvar substringXorQueries = function(s, queries) {\\n  const memo = new Array(30);\\n  const n = s.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    if (s[i] === \\'0\\') {\\n      if (!memo[0]) memo[0] = [i, i];\\n      continue;\\n    }\\n\\n    let num = 0;\\n    for (let j = i; j < Math.min(i + 30, n); j++) {\\n      num = (num << 1) | +s[j];\\n      if (!memo[num]) memo[num] = [i, j];\\n    }\\n  }\\n\\n  return queries.map(([a, b]) => memo[a ^ b] ?? [-1, -1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3360268,
                "title": "substring-xor-queries-c-explained-solution",
                "content": "**Do Upvote If Found Helpful !!!**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is quite interesting and needs bit of observations to be solved. Now basically we are given a binary string and we need to perform xor queries on them. The Naive approach would give you a cubic runtime. The first observation to see is that the number we need to find in each query is just **query[i][0] XOR query[i][1]** because of the famous XOR propery that if **a xor b = c then a xor c = b and b xor c = a**. Now after we know about what number we need to find, we need to work on how efficiently we can find this substring in **S**. Now since we know that our numbers lie within **32 bit range**, thus therefore starting from any index **i**, we only need to check a substring upto the next **30 or 31 characters**. In other words, its enough to check a substring starting at index **i upto i + 30** cause any extra character simply means a number out of **32 bit range** and we know for sure that its not possible for the given problem constraints. Thus you can just store for every index **i**, the next **30 characters**, the number formed by it and corresponding start and end index of that substring. If already present, no need to update as in case of multiple shortest string, we need the one with minimum start. **Remember : shortest substring is actually the binary equivalent of answer value itself**. A small note that no need to start a substring with first character as **0** cause preceeding zeros have no impact on value of a number. Thus just ignore them. Using a map, you can do all queries within the required time. Rest implementation goes below : \\n\\n# Complexity\\n- Time complexity: **O(31N + Qlog(31N)) ---> O(QlogN)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(31N) ---> O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        ios_base::sync_with_stdio(0);\\n        map<ll,pair<int,int>>mp;\\n        int n = s.size();\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'1\\'){\\n                ll prod = 0;\\n                for(int j = 0; j < min(31,n-i); j++){\\n                    if(s[i+j] == \\'1\\'){\\n                        prod++;\\n                    }\\n                    if(mp.find(prod) == mp.end()){\\n                        mp[prod] = {i,i+j};\\n                    }\\n                    prod *= 2LL;\\n                }\\n            }\\n            else{\\n                if(mp.find(0) == mp.end()){\\n                    mp[0] = {i,i};\\n                }\\n            }\\n        }\\n        int q = queries.size();\\n        vector<vector<int>>ans;\\n        for(int i = 0; i < q; i++){\\n            ll x = queries[i][0] ^ queries[i][1];\\n            if(mp.find(x) != mp.end()){\\n                ans.push_back({mp[x].first,mp[x].second});\\n            }\\n            else{\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        ios_base::sync_with_stdio(0);\\n        map<ll,pair<int,int>>mp;\\n        int n = s.size();\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'1\\'){\\n                ll prod = 0;\\n                for(int j = 0; j < min(31,n-i); j++){\\n                    if(s[i+j] == \\'1\\'){\\n                        prod++;\\n                    }\\n                    if(mp.find(prod) == mp.end()){\\n                        mp[prod] = {i,i+j};\\n                    }\\n                    prod *= 2LL;\\n                }\\n            }\\n            else{\\n                if(mp.find(0) == mp.end()){\\n                    mp[0] = {i,i};\\n                }\\n            }\\n        }\\n        int q = queries.size();\\n        vector<vector<int>>ans;\\n        for(int i = 0; i < q; i++){\\n            ll x = queries[i][0] ^ queries[i][1];\\n            if(mp.find(x) != mp.end()){\\n                ans.push_back({mp[x].first,mp[x].second});\\n            }\\n            else{\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331705,
                "title": "c-hashmap-sliding-window",
                "content": "# Intuition\\nWe should check for val such that val^first = second. But we know that if val^first = second then first^second = val.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size(), m = queries.size();\\n        vector<vector<int>> ans(m,vector<int>(2,-1));\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<m;i++){\\n            mp[queries[i][0]^queries[i][1]].push_back(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                int val = 0;\\n                for(int j=0;j<31 && i+j<n;j++){\\n                    val = val*2 + (s[i+j]-\\'0\\');\\n                    if(mp[val].size()>0){\\n                        for(auto x:mp[val]){\\n                            ans[x]={i,i+j};\\n                        }\\n                        mp.erase(val);\\n                    }\\n                }\\n            }\\n            else if(mp[0].size()>0){\\n                for(auto x:mp[0]){\\n                    ans[x]={i,i};\\n                }\\n                mp.erase(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size(), m = queries.size();\\n        vector<vector<int>> ans(m,vector<int>(2,-1));\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<m;i++){\\n            mp[queries[i][0]^queries[i][1]].push_back(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                int val = 0;\\n                for(int j=0;j<31 && i+j<n;j++){\\n                    val = val*2 + (s[i+j]-\\'0\\');\\n                    if(mp[val].size()>0){\\n                        for(auto x:mp[val]){\\n                            ans[x]={i,i+j};\\n                        }\\n                        mp.erase(val);\\n                    }\\n                }\\n            }\\n            else if(mp[0].size()>0){\\n                for(auto x:mp[0]){\\n                    ans[x]={i,i};\\n                }\\n                mp.erase(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262134,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, pair<int, int>> map;\\n        for(int i=s.size()-1;i>=0;i--) {\\n            int cur = 0;\\n            for(int j=0;j<31 && i+j<s.size();j++) {\\n                cur = (cur<<1)| (s[i+j] - \\'0\\');\\n                if(map.count(cur) > 0) {\\n                    auto& ele = map[cur];\\n                    if(ele.second - ele.first + 1 >= j + 1){\\n                           ele.first = i;\\n                           ele.second = i+j; \\n                    }\\n                }else {\\n                    map[cur] = {i, i+j};\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> res;\\n        for(auto& query: queries) {\\n            int left = query[0];\\n            int right = query[1];\\n            right = right^left;\\n            if(map.count(right) > 0) {\\n                auto& interval = map[right];\\n                res.push_back({interval.first, interval.second});\\n            }else {\\n                res.push_back({-1, -1});\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, pair<int, int>> map;\\n        for(int i=s.size()-1;i>=0;i--) {\\n            int cur = 0;\\n            for(int j=0;j<31 && i+j<s.size();j++) {\\n                cur = (cur<<1)| (s[i+j] - \\'0\\');\\n                if(map.count(cur) > 0) {\\n                    auto& ele = map[cur];\\n                    if(ele.second - ele.first + 1 >= j + 1){\\n                           ele.first = i;\\n                           ele.second = i+j; \\n                    }\\n                }else {\\n                    map[cur] = {i, i+j};\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> res;\\n        for(auto& query: queries) {\\n            int left = query[0];\\n            int right = query[1];\\n            right = right^left;\\n            if(map.count(right) > 0) {\\n                auto& interval = map[right];\\n                res.push_back({interval.first, interval.second});\\n            }else {\\n                res.push_back({-1, -1});\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246121,
                "title": "c-map",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(queries.size(), {-1, -1});\\n        unordered_map<long long, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++){\\n            for(int j = i; j < s.size() && j < i + 32; j++){\\n                string sb = s.substr(i, j-i+1);\\n                long long n = stol(sb, 0, 2);\\n                if(mp.find(n) == mp.end()) mp[n] = {i, j};\\n                else if(j - i < mp[n][1] - mp[n][0]) mp[n] = {i, j};\\n            }\\n        }\\n        for(int i = 0; i < queries.size(); i++){\\n            int val = queries[i][0] ^ queries[i][1];\\n            if(mp.find(val) == mp.end()) continue;\\n            else ans[i] = mp[val];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans(queries.size(), {-1, -1});\\n        unordered_map<long long, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++){\\n            for(int j = i; j < s.size() && j < i + 32; j++){\\n                string sb = s.substr(i, j-i+1);\\n                long long n = stol(sb, 0, 2);\\n                if(mp.find(n) == mp.end()) mp[n] = {i, j};\\n                else if(j - i < mp[n][1] - mp[n][0]) mp[n] = {i, j};\\n            }\\n        }\\n        for(int i = 0; i < queries.size(); i++){\\n            int val = queries[i][0] ^ queries[i][1];\\n            if(mp.find(val) == mp.end()) continue;\\n            else ans[i] = mp[val];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228608,
                "title": "c-golang-map",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.length();\\n        unordered_map<int, vector<int>> Map;\\n        for(int i = 0; i < n; i++) {\\n            int val = 0;\\n            for(int j = 0; j <= 30; j++) {\\n                if(i + j >= s.length()) continue;\\n                val = val * 2 + (s[i + j] - \\'0\\'); \\n                if(Map.find(val) == Map.end() || j < Map[val][1] - Map[val][0])\\n                    Map[val] = {i, i + j};\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(vector<int> query: queries) {\\n            int target = query[0] xor query[1];\\n            if(Map.find(target) == Map.end()) \\n                ans.push_back({-1, -1});\\n            else\\n                ans.push_back(Map[target]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc substringXorQueries(s string, queries [][]int) [][]int {\\n    var n int = len(s)\\n    Map := make(map[int][]int)\\n    for i := 0; i < n; i++ {\\n        var key int = 0\\n        for j := 0; j <= 30; j++ {\\n            if i + j >= n {continue}\\n            key = key * 2 + int(s[i + j] - \\'0\\') \\n            if val, ok := Map[key]; !ok || j < val[1] - val[0] {\\n                Map[key] = []int{i, i + j}\\n            }  \\n        }\\n    }\\n    ans := [][]int{}\\n    for _, query := range queries {\\n        var target int = query[0] ^ query[1]\\n        if val, ok := Map[target]; ok {\\n            ans = append(ans, val)\\n        } else {\\n            ans = append(ans, []int{-1, -1})\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.length();\\n        unordered_map<int, vector<int>> Map;\\n        for(int i = 0; i < n; i++) {\\n            int val = 0;\\n            for(int j = 0; j <= 30; j++) {\\n                if(i + j >= s.length()) continue;\\n                val = val * 2 + (s[i + j] - \\'0\\'); \\n                if(Map.find(val) == Map.end() || j < Map[val][1] - Map[val][0])\\n                    Map[val] = {i, i + j};\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(vector<int> query: queries) {\\n            int target = query[0] xor query[1];\\n            if(Map.find(target) == Map.end()) \\n                ans.push_back({-1, -1});\\n            else\\n                ans.push_back(Map[target]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc substringXorQueries(s string, queries [][]int) [][]int {\\n    var n int = len(s)\\n    Map := make(map[int][]int)\\n    for i := 0; i < n; i++ {\\n        var key int = 0\\n        for j := 0; j <= 30; j++ {\\n            if i + j >= n {continue}\\n            key = key * 2 + int(s[i + j] - \\'0\\') \\n            if val, ok := Map[key]; !ok || j < val[1] - val[0] {\\n                Map[key] = []int{i, i + j}\\n            }  \\n        }\\n    }\\n    ans := [][]int{}\\n    for _, query := range queries {\\n        var target int = query[0] ^ query[1]\\n        if val, ok := Map[target]; ok {\\n            ans = append(ans, val)\\n        } else {\\n            ans = append(ans, []int{-1, -1})\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227240,
                "title": "c",
                "content": "# Intution :\\r\\nval ^ first == second\\r\\nval = first ^ second\\r\\n\\r\\n#code :\\r\\n```\\r\\n<!-- Method - 1 -->\\r\\nclass Solution\\r\\n{\\r\\npublic:\\r\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>> &queries)\\r\\n    {\\r\\n        vector<vector<int>> res;\\r\\n        for (int i = 0; i < queries.size(); i++)\\r\\n        {\\r\\n            int val = queries[i][0] ^ queries[i][1];\\r\\n            bitset<64> bit(val);\\r\\n            string str = bit.to_string();\\r\\n            auto it = str.find(\\'1\\');\\r\\n            if (it == string::npos)\\r\\n            {\\r\\n                str = \"0\";\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                str = str.substr(it);\\r\\n            }   \\r\\n            if (s.find(str) == string::npos)\\r\\n            {\\r\\n                res.push_back({-1, -1});\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                int idx1 = s.find(str), idx2 = idx1 + (str.size() - 1;\\r\\n                res.push_back({idx1, idx2});\\r\\n            }\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n};\\r\\n<!-- Method - 2 -->\\r\\nclass Solution {\\r\\npublic:\\r\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>> &queries)\\r\\n{\\r\\n    unordered_map<int, pair<int, int>> seen;\\r\\n    for (int i = 0; i < s.size(); i++)\\r\\n    {\\r\\n        string str;\\r\\n        for (int j = i; j < min(int(s.size()),i + 32); j++)\\r\\n        {\\r\\n            str = s.substr(i, j - i + 1);\\r\\n            long val = stol(str, nullptr, 2);\\r\\n            if (!seen.count(val) || (j - i + 1 < seen[val].second - seen[val].first + 1))\\r\\n                seen[val] = {i, j};\\r\\n        }\\r\\n    }\\r\\n\\r\\n    vector<vector<int>> res;\\r\\n\\r\\n    for (int i = 0; i < queries.size(); i++)\\r\\n    {\\r\\n        int val = queries[i][0] ^ queries[i][1];\\r\\n        if (seen.count(val))\\r\\n        {\\r\\n            res.push_back({seen[val].first, seen[val].second});\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            res.push_back({-1, -1});\\r\\n        }\\r\\n    }\\r\\n    return res;\\r\\n}\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\n<!-- Method - 1 -->\\r\\nclass Solution\\r\\n{\\r\\npublic:\\r\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>> &queries)\\r\\n    {\\r\\n        vector<vector<int>> res;\\r\\n        for (int i = 0; i < queries.size(); i++)\\r\\n        {\\r\\n            int val = queries[i][0] ^ queries[i][1];\\r\\n            bitset<64> bit(val);\\r\\n            string str = bit.to_string();\\r\\n            auto it = str.find(\\'1\\');\\r\\n            if (it == string::npos)\\r\\n            {\\r\\n                str = \"0\";\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                str = str.substr(it);\\r\\n            }   \\r\\n            if (s.find(str) == string::npos)\\r\\n            {\\r\\n                res.push_back({-1, -1});\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                int idx1 = s.find(str), idx2 = idx1 + (str.size() - 1;\\r\\n                res.push_back({idx1, idx2});\\r\\n            }\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n};\\r\\n<!-- Method - 2 -->\\r\\nclass Solution {\\r\\npublic:\\r\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>> &queries)\\r\\n{\\r\\n    unordered_map<int, pair<int, int>> seen;\\r\\n    for (int i = 0; i < s.size(); i++)\\r\\n    {\\r\\n        string str;\\r\\n        for (int j = i; j < min(int(s.size()),i + 32); j++)\\r\\n        {\\r\\n            str = s.substr(i, j - i + 1);\\r\\n            long val = stol(str, nullptr, 2);\\r\\n            if (!seen.count(val) || (j - i + 1 < seen[val].second - seen[val].first + 1))\\r\\n                seen[val] = {i, j};\\r\\n        }\\r\\n    }\\r\\n\\r\\n    vector<vector<int>> res;\\r\\n\\r\\n    for (int i = 0; i < queries.size(); i++)\\r\\n    {\\r\\n        int val = queries[i][0] ^ queries[i][1];\\r\\n        if (seen.count(val))\\r\\n        {\\r\\n            res.push_back({seen[val].first, seen[val].second});\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            res.push_back({-1, -1});\\r\\n        }\\r\\n    }\\r\\n    return res;\\r\\n}\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220647,
                "title": "c-bits-hashmap-beginner-friendly-solution",
                "content": "# Code\\n```\\nclass Solution\\n{\\n\\tpublic:\\nvector<vector < int>> substringXorQueries(string s, vector<vector < int>> &queries)\\n\\t\\t{\\n\\t\\t\\tvector<vector < int>> res;\\n\\n\\t\\t\\tunordered_map<int, vector < int>> mp;\\n\\t\\t\\tint N = s.length(), ocur_zero = -1;\\n\\t\\t\\tfor (int i = 0; i < N; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint val = 0;\\n\\t\\t\\t\\tif (s[i] == \\'0\\' && ocur_zero == -1)\\n\\t\\t\\t\\t\\tocur_zero = i;\\n\\t\\t\\t\\tif (s[i] == \\'0\\')\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tstring str;\\n\\t\\t\\t\\tfor (int j = i; j - i < 31 && j < N; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tval <<= 1;\\n\\t\\t\\t\\t\\tval += (int)(s[j] - \\'0\\');\\n\\t\\t\\t\\t\\tstr += s[j];\\n\\t\\t\\t\\t\\tif (mp.find(val) == mp.end())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmp[val] = { i, j\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (mp[val][1] - mp[val][0] > j - i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tmp.erase(val);\\n\\t\\t\\t\\t\\t\\t\\tmp[val] = { i, j\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto x: queries)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint a = x[0], b = x[1];\\n\\t\\t\\t\\tint val = a ^ b;\\n\\t\\t\\t\\tcout << val << endl;\\n\\t\\t\\t\\tif (val == 0)\\n\\t\\t\\t\\t\\tres.push_back({ ocur_zero, ocur_zero });\\n\\t\\t\\t\\telse if (mp.find(val) != mp.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tres.push_back(mp[val]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tres.push_back({-1, -1 });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tpublic:\\nvector<vector < int>> substringXorQueries(string s, vector<vector < int>> &queries)\\n\\t\\t{\\n\\t\\t\\tvector<vector < int>> res;\\n\\n\\t\\t\\tunordered_map<int, vector < int>> mp;\\n\\t\\t\\tint N = s.length(), ocur_zero = -1;\\n\\t\\t\\tfor (int i = 0; i < N; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint val = 0;\\n\\t\\t\\t\\tif (s[i] == \\'0\\' && ocur_zero == -1)\\n\\t\\t\\t\\t\\tocur_zero = i;\\n\\t\\t\\t\\tif (s[i] == \\'0\\')\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tstring str;\\n\\t\\t\\t\\tfor (int j = i; j - i < 31 && j < N; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tval <<= 1;\\n\\t\\t\\t\\t\\tval += (int)(s[j] - \\'0\\');\\n\\t\\t\\t\\t\\tstr += s[j];\\n\\t\\t\\t\\t\\tif (mp.find(val) == mp.end())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmp[val] = { i, j\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (mp[val][1] - mp[val][0] > j - i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tmp.erase(val);\\n\\t\\t\\t\\t\\t\\t\\tmp[val] = { i, j\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto x: queries)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint a = x[0], b = x[1];\\n\\t\\t\\t\\tint val = a ^ b;\\n\\t\\t\\t\\tcout << val << endl;\\n\\t\\t\\t\\tif (val == 0)\\n\\t\\t\\t\\t\\tres.push_back({ ocur_zero, ocur_zero });\\n\\t\\t\\t\\telse if (mp.find(val) != mp.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tres.push_back(mp[val]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tres.push_back({-1, -1 });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3212616,
                "title": "expand-from-each-index-and-try-find-queried-numbers",
                "content": "# Intuition\\n* `val ^ first == second` can be transformed as `val = first ^ second`\\n* at each index, we try to find numbers begin with that index\\n* any numbers that are in the queries that were not found before, gets recorded\\n\\n# Complexity\\n- Time complexity: $$O(32 n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(Q)$$, where $$Q$$ means the size of $$queries$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  fun substringXorQueries(s: String, queries: Array<IntArray>): Array<IntArray> {\\n    val N = s.length\\n    val indices = queries.withIndex().groupBy (\\n      keySelector = { it.value[0] xor it.value[1] },\\n      valueTransform = {it.index}\\n    ).toMutableMap()\\n    val res = Array(queries.size) { IntArray(2) { -1 } }\\n    fun helper (value: Int, left: Int, right: Int) {\\n      (indices.remove(value) ?: return).forEach {\\n        res[it][0] = left\\n        res[it][1] = right\\n      }\\n    }\\n    for (i in 0 until N) {\\n      if (s[i] == \\'0\\') {\\n        helper(0, i, i)\\n      } else {\\n        var tmp = 0L\\n        for (j in i until N) {\\n          tmp = (tmp shl 1) + (s[j] - \\'0\\')\\n          if (tmp > Int.MAX_VALUE) break\\n          helper(tmp.toInt(), i, j)\\n        }\\n      }\\n    }\\n    return res\\n  }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n  fun substringXorQueries(s: String, queries: Array<IntArray>): Array<IntArray> {\\n    val N = s.length\\n    val indices = queries.withIndex().groupBy (\\n      keySelector = { it.value[0] xor it.value[1] },\\n      valueTransform = {it.index}\\n    ).toMutableMap()\\n    val res = Array(queries.size) { IntArray(2) { -1 } }\\n    fun helper (value: Int, left: Int, right: Int) {\\n      (indices.remove(value) ?: return).forEach {\\n        res[it][0] = left\\n        res[it][1] = right\\n      }\\n    }\\n    for (i in 0 until N) {\\n      if (s[i] == \\'0\\') {\\n        helper(0, i, i)\\n      } else {\\n        var tmp = 0L\\n        for (j in i until N) {\\n          tmp = (tmp shl 1) + (s[j] - \\'0\\')\\n          if (tmp > Int.MAX_VALUE) break\\n          helper(tmp.toInt(), i, j)\\n        }\\n      }\\n    }\\n    return res\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210293,
                "title": "why-30-bits-limit-explained-o-n-2-to-o-n-30-approach-handwritten-explanation",
                "content": "# How does the optimization works?\\n![WhatsApp Image 2023-02-20 at 7.52.49 PM.jpeg](https://assets.leetcode.com/users/images/7b7e373e-4744-4e49-b9cb-20f64c4d7bec_1676903139.291979.jpeg)\\n\\n### Constraints\\n- 1 <= s.length <= 10^4\\n- s[i] is either \\'0\\' or \\'1\\'.\\n- 1 <= queries.length <= 10^5\\n- **0 <= firsti, secondi <= 10^9**\\n\\n\\n# Complexity\\n- Time complexity:O(N*30)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(10^9) values at max\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define PII pair<int,int>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, PII> mpp;\\n        for(int i=0;i<s.size(); i++){\\n            if(s[i] == \\'0\\') {\\n                //but an edge case: what if it is 0 val itself, so put into map\\n                if(mpp.find(0)==mpp.end()) mpp[0]={i,i}; //1st occurance only\\n                continue; // as we need the shortest string\\n                // start with 0 skip, 0110 => 110 it should\\n            }\\n            for(int j=i; j<min(i+31, (int)s.size()); j++){\\n                string str = s.substr(i,j-i+1);\\n                int val = stoi(str, nullptr, 2);\\n                if(mpp.find(val) == mpp.end()){\\n                    //not there\\n                    mpp[val] = {i,j};\\n                }\\n            }\\n\\n        }\\n\\n        vector<vector<int>> ans;\\n        for(auto q : queries){\\n            int val = q[0] ^ q[1];\\n            if(mpp.count(val) > 0){\\n                ans.push_back({mpp[val].first, mpp[val].second});\\n            }\\n            else{\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n#define PII pair<int,int>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, PII> mpp;\\n        for(int i=0;i<s.size(); i++){\\n            if(s[i] == \\'0\\') {\\n                //but an edge case: what if it is 0 val itself, so put into map\\n                if(mpp.find(0)==mpp.end()) mpp[0]={i,i}; //1st occurance only\\n                continue; // as we need the shortest string\\n                // start with 0 skip, 0110 => 110 it should\\n            }\\n            for(int j=i; j<min(i+31, (int)s.size()); j++){\\n                string str = s.substr(i,j-i+1);\\n                int val = stoi(str, nullptr, 2);\\n                if(mpp.find(val) == mpp.end()){\\n                    //not there\\n                    mpp[val] = {i,j};\\n                }\\n            }\\n\\n        }\\n\\n        vector<vector<int>> ans;\\n        for(auto q : queries){\\n            int val = q[0] ^ q[1];\\n            if(mpp.count(val) > 0){\\n                ans.push_back({mpp[val].first, mpp[val].second});\\n            }\\n            else{\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205765,
                "title": "c-using-map-for-aligning-all-the-integer-generated-from-sub-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlign all the intergers generated as substrings of `s`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrom the description, the equation `val ^ first_i == second_i` means `val == first_i ^ second_i`. Thus, each query corresponds to an integer. Using this result, the description is rewritten as follows.\\n\\n>> Find the first index of `s` representing the integer given as `first_i ^ second_i`.\\n\\nMy algorithm is as follows. ALl the integers generated from the string `s` and their first indecies are set in a map. Its key is an integer made from `s` and its corresponding value is the first index, The length of an integer can be easily calculated. So once the query `[left, right]` is given, then calculate the value `left ^ right` and find the index from the map using that value as a key.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nUsing C++ map, O(n log n). If a hash map is used, O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) with C++ map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int get_sub_binary(const string& s, const int left, const int right) const {\\n        // return a decimal value denoted by a substring with the range [left, right).\\n        int v = 0;\\n        for(int i=left;i<right;i++){\\n            v = v << 1;\\n            if(s[i] == \\'1\\')\\n              v = v + 1;\\n        }\\n        return v;\\n    }\\n    int get_length(int x) const {\\n        int v = 0;\\n        if(x == 0)\\n          return 1;\\n        while(x > 0){\\n            v++;\\n            x = x >> 1;\\n        }\\n        return v;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        map<int, int> m;\\n        vector<vector<int>> ans;\\n        for(int n=1;n<=32;n++){\\n            for(int i=0;i+n-1<s.size();i++){\\n                int v = get_sub_binary(s, i, i+n);\\n                if(m.count(v) == 0){\\n                    m.insert(make_pair(v, i));\\n                }\\n            }\\n        }\\n        for(const auto& q : queries){\\n            int v = q[0] ^ q[1];\\n            auto iter = m.find(v);\\n            if(iter != m.end()){\\n                int len = get_length(iter->first);\\n                ans.push_back({iter->second, iter->second + len - 1});\\n            }else{\\n                ans.push_back({-1, -1});         \\n            }\\n        }\\n        return move(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int get_sub_binary(const string& s, const int left, const int right) const {\\n        // return a decimal value denoted by a substring with the range [left, right).\\n        int v = 0;\\n        for(int i=left;i<right;i++){\\n            v = v << 1;\\n            if(s[i] == \\'1\\')\\n              v = v + 1;\\n        }\\n        return v;\\n    }\\n    int get_length(int x) const {\\n        int v = 0;\\n        if(x == 0)\\n          return 1;\\n        while(x > 0){\\n            v++;\\n            x = x >> 1;\\n        }\\n        return v;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        map<int, int> m;\\n        vector<vector<int>> ans;\\n        for(int n=1;n<=32;n++){\\n            for(int i=0;i+n-1<s.size();i++){\\n                int v = get_sub_binary(s, i, i+n);\\n                if(m.count(v) == 0){\\n                    m.insert(make_pair(v, i));\\n                }\\n            }\\n        }\\n        for(const auto& q : queries){\\n            int v = q[0] ^ q[1];\\n            auto iter = m.find(v);\\n            if(iter != m.end()){\\n                int len = get_length(iter->first);\\n                ans.push_back({iter->second, iter->second + len - 1});\\n            }else{\\n                ans.push_back({-1, -1});         \\n            }\\n        }\\n        return move(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200703,
                "title": "easy-simple-c-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int,int>mp;\\n\\t//         storing first occurence of zero\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'0\\'){\\n                mp[0]=i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n\\t//             ignoring s[i]=0 as starting bit because we want to find smallest string and 010 has 3 bits and 10 has 2 bits and both represent 2\\n            if(s[i]==\\'1\\')\\n            {\\n                string tmp;\\n                int j=i;\\n                while(j<s.size())\\n                {\\n                    tmp+=s[j];\\n                    int last_index=j-i+1;\\n                    if(last_index > 30)\\n                        break;\\n                    j++;\\n\\t//                     find binary value in decimal\\n                    long long ans=0;\\n                    for(int k=0;k<tmp.size();k++)\\n                    {\\n                        ans=(ans*2)+(tmp[k]==\\'1\\'?1:0);\\n                    }\\n                    if(mp.find(ans)!=mp.end())\\n                        continue;\\n                    mp[ans]=i;\\n                }\\n            }\\n        }\\n\\t//         now traversing the queries vector \\n        vector<vector<int>> res;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long val=queries[i][0]^queries[i][1];\\n            if(mp.find(val)!=mp.end())\\n            {\\n                int temp=val;\\n                int last_index=0;\\n                if(temp==0)\\n                    last_index+=1;\\n                while(temp>0){\\n                    temp/=2;\\n                    last_index+=1;\\n                }\\n                vector<int>tp;\\n                tp.push_back(mp[val]);\\n                tp.push_back(mp[val]+last_index-1);\\n                res.push_back(tp);\\n            }\\n            else\\n            {\\n                vector<int>tp;\\n                tp.push_back(-1);tp.push_back(-1);\\n                res.push_back(tp);\\n            }\\n        }\\n        return res;      \\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int,int>mp;\\n\\t//         storing first occurence of zero\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'0\\'){\\n                mp[0]=i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3196950,
                "title": "rust-solution",
                "content": "# Code\\n```\\nconst MAX_LENGTH: usize = 30;\\n\\nimpl Solution {\\n    pub fn substring_xor_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut hm = std::collections::HashMap::new();\\n        let mut zero_found = false;\\n        let bytes = s.as_bytes();\\n\\n        for (start, b) in bytes.iter().map(|&b| (b - b\\'0\\') as i32).enumerate() {\\n            if b == 0 {\\n                if !zero_found {\\n                    hm.insert(0, (start, start));\\n                    zero_found = true;\\n                }\\n            } else {\\n                let mut num = 0;\\n                let end = (start + MAX_LENGTH).min(bytes.len());\\n                bytes[start..end].iter().enumerate().for_each(|(i, &b)| {\\n                    num = (num << 1) + (b - b\\'0\\') as i32;\\n                    hm.entry(num).or_insert((start, start + i));\\n                })\\n            }\\n        }\\n\\n        queries\\n            .iter()\\n            .map(|q| {\\n                let val = q[0] ^ q[1];\\n                match hm.get(&val) {\\n                    Some(&(start, end)) => vec![start as i32, end as i32],\\n                    None => vec![-1, -1],\\n                }\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Hash Table",
                    "String",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nconst MAX_LENGTH: usize = 30;\\n\\nimpl Solution {\\n    pub fn substring_xor_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut hm = std::collections::HashMap::new();\\n        let mut zero_found = false;\\n        let bytes = s.as_bytes();\\n\\n        for (start, b) in bytes.iter().map(|&b| (b - b\\'0\\') as i32).enumerate() {\\n            if b == 0 {\\n                if !zero_found {\\n                    hm.insert(0, (start, start));\\n                    zero_found = true;\\n                }\\n            } else {\\n                let mut num = 0;\\n                let end = (start + MAX_LENGTH).min(bytes.len());\\n                bytes[start..end].iter().enumerate().for_each(|(i, &b)| {\\n                    num = (num << 1) + (b - b\\'0\\') as i32;\\n                    hm.entry(num).or_insert((start, start + i));\\n                })\\n            }\\n        }\\n\\n        queries\\n            .iter()\\n            .map(|q| {\\n                let val = q[0] ^ q[1];\\n                match hm.get(&val) {\\n                    Some(&(start, end)) => vec![start as i32, end as i32],\\n                    None => vec![-1, -1],\\n                }\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3196870,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s, queries):\\n        dict1, result, n = defaultdict(lambda:[-1,-1]), [], len(s)\\n\\n        for j in range(min(32,n)):\\n            for i in range(n-j):\\n                num = int(s[i:i+j+1],2)\\n                if num not in dict1: dict1[num] = [i,i+j]\\n\\n        return [dict1[a^b] for a,b in queries]\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s, queries):\\n        dict1, result, n = defaultdict(lambda:[-1,-1]), [], len(s)\\n\\n        for j in range(min(32,n)):\\n            for i in range(n-j):\\n                num = int(s[i:i+j+1],2)\\n                if num not in dict1: dict1[num] = [i,i+j]\\n\\n        return [dict1[a^b] for a,b in queries]\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195613,
                "title": "c-easy-o-30-n",
                "content": "# Complexity\\n- Time complexity:\\nO(30 * N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, vector<int>> m;\\n        vector<vector<int>> res;\\n        for (int i = 0; i < s.size(); ++i) {\\n            long long val = 0;\\n            for (int j = i; j < min(i + 30, (int)s.size()); ++j) {\\n                val = (val << 1) + (s[j] == \\'1\\');\\n                if (m.count(val) == 0)\\n                    m[val] = {i, j};\\n                if (s[i] == \\'0\\')\\n                    break;\\n            }\\n        }\\n        for(auto& query : queries){\\n            int val = query[0]^query[1];\\n            if (m.count(val) != 0) res.push_back(m[val]);\\n            else res.push_back({-1,-1});\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, vector<int>> m;\\n        vector<vector<int>> res;\\n        for (int i = 0; i < s.size(); ++i) {\\n            long long val = 0;\\n            for (int j = i; j < min(i + 30, (int)s.size()); ++j) {\\n                val = (val << 1) + (s[j] == \\'1\\');\\n                if (m.count(val) == 0)\\n                    m[val] = {i, j};\\n                if (s[i] == \\'0\\')\\n                    break;\\n            }\\n        }\\n        for(auto& query : queries){\\n            int val = query[0]^query[1];\\n            if (m.count(val) != 0) res.push_back(m[val]);\\n            else res.push_back({-1,-1});\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190821,
                "title": "python-clear-solution",
                "content": "```\\ndef substringXorQueries(self, s: str, qs: List[List[int]]) -> List[List[int]]:\\n\\td = {0:[1, s.index(\\'0\\'), s.index(\\'0\\')]} if \\'0\\' in s else {}\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i]==\\'0\\':\\n\\t\\t\\tcontinue\\n\\t\\tfor k in range(1,33):\\n\\t\\t\\tn = int(s[i:i+k], 2)\\n\\t\\t\\tif n not in d:\\n\\t\\t\\t\\td[n] = [k, i, i+k-1] #length, start, end\\n\\t\\t\\telse:\\n\\t\\t\\t\\td[n] = min(d[n], [k, i, i+k-1])\\n\\treturn [d[x^y][1:] if x^y in d else [-1, -1] for x, y in qs]\\n```",
                "solutionTags": [],
                "code": "```\\ndef substringXorQueries(self, s: str, qs: List[List[int]]) -> List[List[int]]:\\n\\td = {0:[1, s.index(\\'0\\'), s.index(\\'0\\')]} if \\'0\\' in s else {}\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i]==\\'0\\':\\n\\t\\t\\tcontinue\\n\\t\\tfor k in range(1,33):\\n\\t\\t\\tn = int(s[i:i+k], 2)\\n\\t\\t\\tif n not in d:\\n\\t\\t\\t\\td[n] = [k, i, i+k-1] #length, start, end\\n\\t\\t\\telse:\\n\\t\\t\\t\\td[n] = min(d[n], [k, i, i+k-1])\\n\\treturn [d[x^y][1:] if x^y in d else [-1, -1] for x, y in qs]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3189137,
                "title": "go-the-easiest-solution-beats-100-memory",
                "content": "# Code\\n```\\nfunc substringXorQueries(s string, queries [][]int) [][]int {\\n\\tn := len(queries)\\n\\tans := make([][]int, 0, n)\\n\\n\\tfor _, q := range queries {\\n\\t\\ttarget := strconv.FormatInt(int64(q[0]^q[1]), 2)\\n\\t\\tif ind := strings.Index(s, target); ind != -1 {\\n\\t\\t\\tans = append(ans, []int{ind, ind + len(target)-1})\\n\\t\\t} else {\\n\\t\\t\\tans = append(ans, []int{-1, -1})\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc substringXorQueries(s string, queries [][]int) [][]int {\\n\\tn := len(queries)\\n\\tans := make([][]int, 0, n)\\n\\n\\tfor _, q := range queries {\\n\\t\\ttarget := strconv.FormatInt(int64(q[0]^q[1]), 2)\\n\\t\\tif ind := strings.Index(s, target); ind != -1 {\\n\\t\\t\\tans = append(ans, []int{ind, ind + len(target)-1})\\n\\t\\t} else {\\n\\t\\t\\tans = append(ans, []int{-1, -1})\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3187893,
                "title": "c-c-efficent-trie-and-hashmap-solutions-o-n-time-o-n-space",
                "content": "# Intuition\\nI tried to figure out if there was a clever way of doing things that I was missing. In the end I decided there wasn\\'t, and so instead focused on finding an efficent manner of looking up the substrings in the input array.\\n\\n# Approach\\nI a couple of approaches, but ultimately I wanted to index all the possible substrings of length 30 or less (30 being the maximum required to represent 10^9 in binary).\\n\\n1. Using a hashtable that can be accessed via an integer key, that stores the start/end index of the first occurance.\\n2. Using a trie to store the reverse substrings (those substrings read from right to left). This is because it is easier to turn a number into it\\'s binary representation from least significant to most significant digit.\\n\\nIn both cases, I kept 30 progress values, each one using more substring digits than the previous. This means I only have to read a single character of the substring at each step. For the hashtable solution, the 30 values are built up by bitwise shifting and adding the new digit, while in the case of the trie, the progress values are the depth inside the trie.\\n\\nFinally, to avoid duplicating code, I use an offset to which trie is being updated. Basically a rolling buffer of the current state.\\n\\nUltimately I think the trie solutions are better, and more flexible, but present both for the reader.\\n\\n# Complexity\\n- Time complexity O(30 * n) -> O(n):\\n- Each step in the input string causes upto 30 updates.\\n\\n- Space complexity O(n):\\n\\n# C++ Trie Solution\\n```c++\\n  struct substring_trie {\\n    std::unique_ptr<substring_trie> next[2];\\n    int start;\\n    int end;\\n  };\\n\\n  vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n    // Build a trie of all the substrings, in reverse\\n    substring_trie trie;\\n    memset(&trie, 0, sizeof(trie));\\n    substring_trie* tries[30];\\n    int num_tries = 0;\\n    for (int i = s.size() - 1; 0 <= i; --i) {\\n      num_tries = std::min(num_tries + 1, 30);\\n      tries[i % 30] = &trie;\\n      for (int j = 0; j < num_tries; ++j) {\\n        // tries is a rolling buffer, so begins at a different offset each time\\n        substring_trie*& curr = tries[(i + j) % 30];\\n        // Add a new depth to the trie if required.\\n        auto& next = curr->next[\\'1\\' == s[i]];\\n        if (!next) {\\n          next.reset(new substring_trie);\\n        }\\n\\n        // Keep updating the start/end index. Since we\\'re going back to front, the index\\n        // will be the earliest when we\\'re done.\\n        curr = next.get();\\n        curr->start = i;\\n        curr->end = i + j;\\n      }\\n    }\\n\\n    // Try and find each query in the substrings\\n    std::vector<std::vector<int>> ret;\\n    ret.reserve(queries.size());\\n    for (const auto& query : queries) {\\n      // Try and look up the target from least significant digit to most significant\\n      int target = query[0] ^ query[1];\\n      substring_trie* curr = &trie;\\n      do {\\n        curr = curr->next[target & 1].get();\\n      } while (curr && (target >>= 1));\\n\\n      if (curr) {\\n        ret.emplace_back(std::initializer_list<int>{curr->start, curr->end});\\n      } else {\\n        ret.emplace_back(std::initializer_list<int>{-1, -1});\\n      }\\n    }\\n    return ret;\\n  }\\n```\\n\\n# C Trie Solution\\nVery similar to the C++ solution, but with extra code to handle the allocation and deallocation required for c solutions.\\n```c\\nstruct substring_trie {\\n\\tstruct substring_trie* next[2];\\n\\tint start;\\n\\tint end;\\n};\\n\\nstatic\\nvoid substring_trie_unit(struct substring_trie* obj) {\\n\\tfor (int i = 0; i < 2; ++i) {\\n\\t\\tif (obj->next[i]) {\\n\\t\\t\\tsubstring_trie_unit(obj->next[i]);\\n\\t\\t\\tfree(obj->next[i]);\\n\\t\\t}\\n\\t}\\n}\\n\\nint** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes) {\\n\\t/* Build all the substrings (in reverse) into the trie */\\n\\tconst int len = strlen(s);\\n\\tint num_tries = 0;\\n\\tstruct substring_trie trie;\\n\\tmemset(&trie, 0, sizeof(trie));\\n\\tstruct substring_trie* tries[30];\\n\\tmemset(tries, 0, sizeof(tries));\\n\\tfor (int i = len - 1; 0 <= i; --i) {\\n\\t\\tnum_tries = (30 == num_tries) ? num_tries : (num_tries + 1);\\n\\t\\ttries[i % 30] = &trie;\\n\\t\\tfor (int j = 0; j < num_tries; ++j) {\\n\\t\\t\\tstruct substring_trie** next_ptr = &tries[(i + j) % 30]->next[\\'1\\' == s[i]];\\n\\t\\t\\tif (!*next_ptr) {\\n\\t\\t\\t\\t*next_ptr = calloc(1, sizeof(**next_ptr));\\n\\t\\t\\t}\\n\\t\\t\\ttries[(i + j) % 30] = *next_ptr;\\n\\t\\t\\ttries[(i + j) % 30]->start = i;\\n\\t\\t\\ttries[(i + j) % 30]->end = i + j;\\n\\t\\t}\\n\\t}\\n\\n\\t/* Try and find each query in the trie */\\n\\tint** ret = malloc(queriesSize * sizeof(*ret));\\n\\t*returnSize = queriesSize;\\n\\t*returnColumnSizes = malloc(queriesSize * sizeof(**returnColumnSizes));\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tret[i] = malloc(2 * sizeof(**ret));\\n\\t\\t(*returnColumnSizes)[i] = 2;\\n\\t\\tstruct substring_trie* curr = &trie;\\n\\t\\tint target = queries[i][0] ^ queries[i][1];\\n\\t\\tdo {\\n\\t\\t\\tcurr = curr->next[target & 1];\\n\\t\\t} while (curr && (target >>= 1));\\n\\t\\tif (curr) {\\n\\t\\t\\tret[i][0] = curr->start;\\n\\t\\t\\tret[i][1] = curr->end;\\n\\t\\t} else {\\n\\t\\t\\tret[i][0] = -1;\\n\\t\\t\\tret[i][1] = -1;\\n\\t\\t}\\n\\t}\\n\\n\\tsubstring_trie_unit(&trie);\\n\\treturn ret;\\n}\\n```\\n\\n# C Hashmap Substrings Solution\\nUsing the automatically included uthash.\\n```c\\nstruct substring_hash {\\n\\tint key;\\n\\tint start;\\n\\tint end;\\n\\tUT_hash_handle hh;\\n};\\n\\nstatic int imin(int a, int b) { return (a < b) ? a : b; }\\n\\nint** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes) {\\n\\t/* Add all possible substring to the hashtable */\\n\\tstruct substring_hash* table = NULL;\\n\\tint fingerprints[30] = {0};\\n\\tint num_fingers = 0;\\n\\tfor (int i = 0; s[i]; ++i) {\\n\\t\\t/* Convert the substrings into an integer value for faster compare */\\n\\t\\tnum_fingers = imin(num_fingers + 1, 30);\\n\\t\\tint prev_fingerprint = 0;\\n\\t\\tfor (int j = 0; j < num_fingers; ++j) {\\n\\t\\t\\tint new_fingerprint = (prev_fingerprint << 1) + (\\'1\\' == s[i]);\\n\\t\\t\\tprev_fingerprint = fingerprints[j];\\n\\t\\t\\tfingerprints[j] = new_fingerprint;\\n\\t\\t\\tstruct substring_hash* entry;\\n\\t\\t\\tHASH_FIND_INT(table, &new_fingerprint, entry);\\n\\t\\t\\tif (!entry) {\\n\\t\\t\\t\\tentry = malloc(sizeof(*entry));\\n\\t\\t\\t\\tentry->key = new_fingerprint;\\n\\t\\t\\t\\tentry->start = i - j;\\n\\t\\t\\t\\tentry->end = i;\\n\\t\\t\\t\\tHASH_ADD_INT(table, key, entry);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/* Search for each query in the hashtable */\\n\\tint** ret = malloc(queriesSize * sizeof(*ret));\\n\\t*returnSize = queriesSize;\\n\\t*returnColumnSizes = malloc(queriesSize * sizeof(**returnColumnSizes));\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tret[i] = malloc(2 * sizeof(*ret[i]));\\n\\t\\t(*returnColumnSizes)[i] = 2;\\n\\t\\tstruct substring_hash* entry;\\n\\t\\tint target = queries[i][0] ^ queries[i][1];\\n\\t\\tHASH_FIND_INT(table, &target, entry);\\n\\t\\tif (entry) {\\n\\t\\t\\tret[i][0] = entry->start;\\n\\t\\t\\tret[i][1] = entry->end;\\n\\t\\t} else {\\n\\t\\t\\tret[i][0] = -1;\\n\\t\\t\\tret[i][1] = -1;\\n\\t\\t}\\n\\t}\\n\\n\\tstruct substring_hash* del_entry;\\n\\tstruct substring_hash* tmp_entry;\\n\\tHASH_ITER(hh, table, del_entry, tmp_entry) {\\n\\t\\tHASH_DEL(table, del_entry);\\n\\t\\tfree(del_entry);\\n\\t}\\n\\n\\treturn ret;\\n}\\n```\\n\\n# C Hashmap Queries Solution\\nAlternatively we could hash all the queries and then procress the string and look up each substring.\\n\\nThe catch is that multiple queries will have the same value the XOR and so we must support multiple entries for the same key. I did this with a simple link list inside the hash node `target_hash`\\n```c\\nstruct target_hash {\\n\\tint key;\\n\\t/* Used to handle the case where muliple entries have the same key */\\n\\tstruct target_hash* next;\\n\\tUT_hash_handle hh;\\n};\\n\\nstatic\\nvoid write_response(struct target_hash* entry, int idx, struct target_hash* entries_start, int** response_out) {\\n\\tint start_idx = idx;\\n\\tint end_idx = idx;\\n\\tint target = entry->key;\\n\\twhile (target >>= 1) {\\n\\t\\t--start_idx;\\n\\t}\\n\\n\\tdo {\\n\\t\\tint ret_idx = entry - entries_start;\\n\\t\\tresponse_out[ret_idx][0] = start_idx;\\n\\t\\tresponse_out[ret_idx][1] = end_idx;\\n\\t} while (entry = entry->next);\\n}\\n\\nint** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = malloc(queriesSize * sizeof(*ret));\\n\\t*returnColumnSizes = malloc(queriesSize * sizeof(**returnColumnSizes));\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tret[i] = malloc(2 * sizeof(**ret));\\n\\t\\t(*returnColumnSizes)[i] = 2;\\n\\t}\\n\\t*returnSize = queriesSize;\\n\\n\\tstruct target_hash* table = NULL;\\n\\tstruct target_hash* const entries = malloc(queriesSize * sizeof(*entries));\\n\\tstruct target_hash* entry;\\n\\n\\t/* \\n\\tHash all the queries. To support duplicate keys, the entries with a\\n\\tduplicate key are inserted into a single link list starting at the\\n\\tfirst entry with the key\\n\\t*/\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tint target = queries[i][0] ^ queries[i][1];\\n\\t\\tHASH_FIND_INT(table, &target, entry);\\n\\t\\tif (!entry) {\\n\\t\\t\\t/* New key */\\n\\t\\t\\tentries[i].key = target;\\n\\t\\t\\tentries[i].next = NULL;\\n\\t\\t\\tHASH_ADD_INT(table, key, &entries[i]);\\n\\t\\t} else {\\n\\t\\t\\t/* Key is not unique */\\n\\t\\t\\tentries[i].next = entry->next;\\n\\t\\t\\tentry->next = &entries[i];\\n\\t\\t}\\n\\t}\\n\\n\\tint fingerprint[31];\\n\\tint num_fingers = 0;\\n\\tfor (int i = 0; s[i]; ++i) {\\n\\t\\t/* \\n\\t\\tBuild the next fingerprint by left shifting the previous fingerprints\\n\\t\\tand adding the new character.\\n\\t\\t*/\\n\\t\\tnum_fingers = (30 == num_fingers) ? 30 : (num_fingers + 1);\\n\\t\\tfor (int j = num_fingers - 1; j; --j) {\\n\\t\\t\\tfingerprint[j] = (fingerprint[j - 1] << 1) + (\\'1\\' == s[i]);\\n\\t\\t\\tHASH_FIND_INT(table, &fingerprint[j], entry);\\n\\t\\t\\tif (entry) {\\n\\t\\t\\t\\twrite_response(entry, i, entries, ret);\\n\\t\\t\\t\\tHASH_DEL(table, entry);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t/* New fingerprint of from the single character */\\n\\t\\tfingerprint[0] = (\\'1\\' == s[i]);\\n\\t\\tHASH_FIND_INT(table, &fingerprint[0], entry);\\n\\t\\tif (entry) {\\n\\t\\t\\twrite_response(entry, i, entries, ret);\\n\\t\\t\\tHASH_DEL(table, entry);\\n\\t\\t}\\n\\t}\\n\\n\\t/* Any remaining queries have no response */\\n\\tstruct target_hash* tmp;\\n\\tHASH_ITER(hh, table, entry, tmp) {\\n\\t\\tdo {\\n\\t\\t\\tret[entry - entries][0] = -1;\\n\\t\\t\\tret[entry - entries][1] = -1;\\n\\t\\t} while ((entry = entry->next));\\n\\t}\\n\\tHASH_CLEAR(hh, table);\\n\\n\\tfree(entries);\\n\\treturn ret;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\n  struct substring_trie {\\n    std::unique_ptr<substring_trie> next[2];\\n    int start;\\n    int end;\\n  };\\n\\n  vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n    // Build a trie of all the substrings, in reverse\\n    substring_trie trie;\\n    memset(&trie, 0, sizeof(trie));\\n    substring_trie* tries[30];\\n    int num_tries = 0;\\n    for (int i = s.size() - 1; 0 <= i; --i) {\\n      num_tries = std::min(num_tries + 1, 30);\\n      tries[i % 30] = &trie;\\n      for (int j = 0; j < num_tries; ++j) {\\n        // tries is a rolling buffer, so begins at a different offset each time\\n        substring_trie*& curr = tries[(i + j) % 30];\\n        // Add a new depth to the trie if required.\\n        auto& next = curr->next[\\'1\\' == s[i]];\\n        if (!next) {\\n          next.reset(new substring_trie);\\n        }\\n\\n        // Keep updating the start/end index. Since we\\'re going back to front, the index\\n        // will be the earliest when we\\'re done.\\n        curr = next.get();\\n        curr->start = i;\\n        curr->end = i + j;\\n      }\\n    }\\n\\n    // Try and find each query in the substrings\\n    std::vector<std::vector<int>> ret;\\n    ret.reserve(queries.size());\\n    for (const auto& query : queries) {\\n      // Try and look up the target from least significant digit to most significant\\n      int target = query[0] ^ query[1];\\n      substring_trie* curr = &trie;\\n      do {\\n        curr = curr->next[target & 1].get();\\n      } while (curr && (target >>= 1));\\n\\n      if (curr) {\\n        ret.emplace_back(std::initializer_list<int>{curr->start, curr->end});\\n      } else {\\n        ret.emplace_back(std::initializer_list<int>{-1, -1});\\n      }\\n    }\\n    return ret;\\n  }\\n```\n```c\\nstruct substring_trie {\\n\\tstruct substring_trie* next[2];\\n\\tint start;\\n\\tint end;\\n};\\n\\nstatic\\nvoid substring_trie_unit(struct substring_trie* obj) {\\n\\tfor (int i = 0; i < 2; ++i) {\\n\\t\\tif (obj->next[i]) {\\n\\t\\t\\tsubstring_trie_unit(obj->next[i]);\\n\\t\\t\\tfree(obj->next[i]);\\n\\t\\t}\\n\\t}\\n}\\n\\nint** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes) {\\n\\t/* Build all the substrings (in reverse) into the trie */\\n\\tconst int len = strlen(s);\\n\\tint num_tries = 0;\\n\\tstruct substring_trie trie;\\n\\tmemset(&trie, 0, sizeof(trie));\\n\\tstruct substring_trie* tries[30];\\n\\tmemset(tries, 0, sizeof(tries));\\n\\tfor (int i = len - 1; 0 <= i; --i) {\\n\\t\\tnum_tries = (30 == num_tries) ? num_tries : (num_tries + 1);\\n\\t\\ttries[i % 30] = &trie;\\n\\t\\tfor (int j = 0; j < num_tries; ++j) {\\n\\t\\t\\tstruct substring_trie** next_ptr = &tries[(i + j) % 30]->next[\\'1\\' == s[i]];\\n\\t\\t\\tif (!*next_ptr) {\\n\\t\\t\\t\\t*next_ptr = calloc(1, sizeof(**next_ptr));\\n\\t\\t\\t}\\n\\t\\t\\ttries[(i + j) % 30] = *next_ptr;\\n\\t\\t\\ttries[(i + j) % 30]->start = i;\\n\\t\\t\\ttries[(i + j) % 30]->end = i + j;\\n\\t\\t}\\n\\t}\\n\\n\\t/* Try and find each query in the trie */\\n\\tint** ret = malloc(queriesSize * sizeof(*ret));\\n\\t*returnSize = queriesSize;\\n\\t*returnColumnSizes = malloc(queriesSize * sizeof(**returnColumnSizes));\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tret[i] = malloc(2 * sizeof(**ret));\\n\\t\\t(*returnColumnSizes)[i] = 2;\\n\\t\\tstruct substring_trie* curr = &trie;\\n\\t\\tint target = queries[i][0] ^ queries[i][1];\\n\\t\\tdo {\\n\\t\\t\\tcurr = curr->next[target & 1];\\n\\t\\t} while (curr && (target >>= 1));\\n\\t\\tif (curr) {\\n\\t\\t\\tret[i][0] = curr->start;\\n\\t\\t\\tret[i][1] = curr->end;\\n\\t\\t} else {\\n\\t\\t\\tret[i][0] = -1;\\n\\t\\t\\tret[i][1] = -1;\\n\\t\\t}\\n\\t}\\n\\n\\tsubstring_trie_unit(&trie);\\n\\treturn ret;\\n}\\n```\n```c\\nstruct substring_hash {\\n\\tint key;\\n\\tint start;\\n\\tint end;\\n\\tUT_hash_handle hh;\\n};\\n\\nstatic int imin(int a, int b) { return (a < b) ? a : b; }\\n\\nint** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes) {\\n\\t/* Add all possible substring to the hashtable */\\n\\tstruct substring_hash* table = NULL;\\n\\tint fingerprints[30] = {0};\\n\\tint num_fingers = 0;\\n\\tfor (int i = 0; s[i]; ++i) {\\n\\t\\t/* Convert the substrings into an integer value for faster compare */\\n\\t\\tnum_fingers = imin(num_fingers + 1, 30);\\n\\t\\tint prev_fingerprint = 0;\\n\\t\\tfor (int j = 0; j < num_fingers; ++j) {\\n\\t\\t\\tint new_fingerprint = (prev_fingerprint << 1) + (\\'1\\' == s[i]);\\n\\t\\t\\tprev_fingerprint = fingerprints[j];\\n\\t\\t\\tfingerprints[j] = new_fingerprint;\\n\\t\\t\\tstruct substring_hash* entry;\\n\\t\\t\\tHASH_FIND_INT(table, &new_fingerprint, entry);\\n\\t\\t\\tif (!entry) {\\n\\t\\t\\t\\tentry = malloc(sizeof(*entry));\\n\\t\\t\\t\\tentry->key = new_fingerprint;\\n\\t\\t\\t\\tentry->start = i - j;\\n\\t\\t\\t\\tentry->end = i;\\n\\t\\t\\t\\tHASH_ADD_INT(table, key, entry);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/* Search for each query in the hashtable */\\n\\tint** ret = malloc(queriesSize * sizeof(*ret));\\n\\t*returnSize = queriesSize;\\n\\t*returnColumnSizes = malloc(queriesSize * sizeof(**returnColumnSizes));\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tret[i] = malloc(2 * sizeof(*ret[i]));\\n\\t\\t(*returnColumnSizes)[i] = 2;\\n\\t\\tstruct substring_hash* entry;\\n\\t\\tint target = queries[i][0] ^ queries[i][1];\\n\\t\\tHASH_FIND_INT(table, &target, entry);\\n\\t\\tif (entry) {\\n\\t\\t\\tret[i][0] = entry->start;\\n\\t\\t\\tret[i][1] = entry->end;\\n\\t\\t} else {\\n\\t\\t\\tret[i][0] = -1;\\n\\t\\t\\tret[i][1] = -1;\\n\\t\\t}\\n\\t}\\n\\n\\tstruct substring_hash* del_entry;\\n\\tstruct substring_hash* tmp_entry;\\n\\tHASH_ITER(hh, table, del_entry, tmp_entry) {\\n\\t\\tHASH_DEL(table, del_entry);\\n\\t\\tfree(del_entry);\\n\\t}\\n\\n\\treturn ret;\\n}\\n```\n```c\\nstruct target_hash {\\n\\tint key;\\n\\t/* Used to handle the case where muliple entries have the same key */\\n\\tstruct target_hash* next;\\n\\tUT_hash_handle hh;\\n};\\n\\nstatic\\nvoid write_response(struct target_hash* entry, int idx, struct target_hash* entries_start, int** response_out) {\\n\\tint start_idx = idx;\\n\\tint end_idx = idx;\\n\\tint target = entry->key;\\n\\twhile (target >>= 1) {\\n\\t\\t--start_idx;\\n\\t}\\n\\n\\tdo {\\n\\t\\tint ret_idx = entry - entries_start;\\n\\t\\tresponse_out[ret_idx][0] = start_idx;\\n\\t\\tresponse_out[ret_idx][1] = end_idx;\\n\\t} while (entry = entry->next);\\n}\\n\\nint** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = malloc(queriesSize * sizeof(*ret));\\n\\t*returnColumnSizes = malloc(queriesSize * sizeof(**returnColumnSizes));\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tret[i] = malloc(2 * sizeof(**ret));\\n\\t\\t(*returnColumnSizes)[i] = 2;\\n\\t}\\n\\t*returnSize = queriesSize;\\n\\n\\tstruct target_hash* table = NULL;\\n\\tstruct target_hash* const entries = malloc(queriesSize * sizeof(*entries));\\n\\tstruct target_hash* entry;\\n\\n\\t/* \\n\\tHash all the queries. To support duplicate keys, the entries with a\\n\\tduplicate key are inserted into a single link list starting at the\\n\\tfirst entry with the key\\n\\t*/\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tint target = queries[i][0] ^ queries[i][1];\\n\\t\\tHASH_FIND_INT(table, &target, entry);\\n\\t\\tif (!entry) {\\n\\t\\t\\t/* New key */\\n\\t\\t\\tentries[i].key = target;\\n\\t\\t\\tentries[i].next = NULL;\\n\\t\\t\\tHASH_ADD_INT(table, key, &entries[i]);\\n\\t\\t} else {\\n\\t\\t\\t/* Key is not unique */\\n\\t\\t\\tentries[i].next = entry->next;\\n\\t\\t\\tentry->next = &entries[i];\\n\\t\\t}\\n\\t}\\n\\n\\tint fingerprint[31];\\n\\tint num_fingers = 0;\\n\\tfor (int i = 0; s[i]; ++i) {\\n\\t\\t/* \\n\\t\\tBuild the next fingerprint by left shifting the previous fingerprints\\n\\t\\tand adding the new character.\\n\\t\\t*/\\n\\t\\tnum_fingers = (30 == num_fingers) ? 30 : (num_fingers + 1);\\n\\t\\tfor (int j = num_fingers - 1; j; --j) {\\n\\t\\t\\tfingerprint[j] = (fingerprint[j - 1] << 1) + (\\'1\\' == s[i]);\\n\\t\\t\\tHASH_FIND_INT(table, &fingerprint[j], entry);\\n\\t\\t\\tif (entry) {\\n\\t\\t\\t\\twrite_response(entry, i, entries, ret);\\n\\t\\t\\t\\tHASH_DEL(table, entry);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t/* New fingerprint of from the single character */\\n\\t\\tfingerprint[0] = (\\'1\\' == s[i]);\\n\\t\\tHASH_FIND_INT(table, &fingerprint[0], entry);\\n\\t\\tif (entry) {\\n\\t\\t\\twrite_response(entry, i, entries, ret);\\n\\t\\t\\tHASH_DEL(table, entry);\\n\\t\\t}\\n\\t}\\n\\n\\t/* Any remaining queries have no response */\\n\\tstruct target_hash* tmp;\\n\\tHASH_ITER(hh, table, entry, tmp) {\\n\\t\\tdo {\\n\\t\\t\\tret[entry - entries][0] = -1;\\n\\t\\t\\tret[entry - entries][1] = -1;\\n\\t\\t} while ((entry = entry->next));\\n\\t}\\n\\tHASH_CLEAR(hh, table);\\n\\n\\tfree(entries);\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3187666,
                "title": "python-easy-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        l=len(s) #get length of the given string\\n        d={} #create empty hashmap\\n        n=min(32,l) # integer upto 10**9 can be represented within 32 bits, hence we need all substrings upto 32 bits length. Also, length of the given string could be < 32.\\n        for i in range(n): # generate all substrings of i+1 length\\n            for j in range(l-i): # iterate on starting index of substrings\\n                x=s[j:j+i+1] # substring \\n                if int(x,2) not in d: # we need the first occurrence of decimal representation of the generated substring, so we ignore if it reoccurs.\\n                    d[int(x,2)]=[j,j+i] # store decimal value : indices range in given string\\n        ans=[] # create empty array\\n        for q in queries: # iterate on queries\\n            x=q[0]^q[1] # val^first = second, hence val = first^second\\n            if x in d: # look for computed val in hashmap and append ans with indices\\n                ans.append(d[x])\\n            else:\\n                ans.append([-1,-1]) #  append ans with [-1,-1] if val isn\\'t found in hashmap\\n        return ans\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        l=len(s) #get length of the given string\\n        d={} #create empty hashmap\\n        n=min(32,l) # integer upto 10**9 can be represented within 32 bits, hence we need all substrings upto 32 bits length. Also, length of the given string could be < 32.\\n        for i in range(n): # generate all substrings of i+1 length\\n            for j in range(l-i): # iterate on starting index of substrings\\n                x=s[j:j+i+1] # substring \\n                if int(x,2) not in d: # we need the first occurrence of decimal representation of the generated substring, so we ignore if it reoccurs.\\n                    d[int(x,2)]=[j,j+i] # store decimal value : indices range in given string\\n        ans=[] # create empty array\\n        for q in queries: # iterate on queries\\n            x=q[0]^q[1] # val^first = second, hence val = first^second\\n            if x in d: # look for computed val in hashmap and append ans with indices\\n                ans.append(d[x])\\n            else:\\n                ans.append([-1,-1]) #  append ans with [-1,-1] if val isn\\'t found in hashmap\\n        return ans\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185688,
                "title": "612-ms",
                "content": "```ruby\\ndef substring_xor_queries a, q\\n    h, n, a = {}, [-1, -1], a.bytes.map! { _1 - 48 }\\n    i = a.index 0; h[0] = [i, i] if i\\n    i = a.index 1; h[1] = [i, i] if i\\n    for i in 0..(z = a.size) - 2\\n        next if a[i] == 0\\n        v = 1\\n        for j in i + 1...[i + 30, z].min\\n            v = (v << 1) | a[j]\\n            h[v] ||= [i, j]\\n        end\\n    end\\n    q.map! { h[_1.first ^ _1.last] || n }\\nend\\n```\\n714 ms\\n```ruby\\ndef substring_xor_queries a, q\\n    h, n, a = {}, [-1, -1], a.bytes.map! { _1 - 48 }\\n    (1..[30, a.size].min).each do | w |\\n        m, d = (1 << w) - 1, w - 1\\n        h[v = a[0, w].join.to_i(2)] ||= [0, d]\\n        for i in w...a.size\\n            v = ((v << 1) | a[i]) & m\\n            h[v] ||= [i - d, i]\\n        end\\n    end\\n    q.map! { h[_1.first ^ _1.last] || n }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef substring_xor_queries a, q\\n    h, n, a = {}, [-1, -1], a.bytes.map! { _1 - 48 }\\n    i = a.index 0; h[0] = [i, i] if i\\n    i = a.index 1; h[1] = [i, i] if i\\n    for i in 0..(z = a.size) - 2\\n        next if a[i] == 0\\n        v = 1\\n        for j in i + 1...[i + 30, z].min\\n            v = (v << 1) | a[j]\\n            h[v] ||= [i, j]\\n        end\\n    end\\n    q.map! { h[_1.first ^ _1.last] || n }\\nend\\n```\n```ruby\\ndef substring_xor_queries a, q\\n    h, n, a = {}, [-1, -1], a.bytes.map! { _1 - 48 }\\n    (1..[30, a.size].min).each do | w |\\n        m, d = (1 << w) - 1, w - 1\\n        h[v = a[0, w].join.to_i(2)] ||= [0, d]\\n        for i in w...a.size\\n            v = ((v << 1) | a[i]) & m\\n            h[v] ||= [i - d, i]\\n        end\\n    end\\n    q.map! { h[_1.first ^ _1.last] || n }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3182578,
                "title": "c-hashmap-95-solution",
                "content": "# Approach\\nI found out that we can have faster lookups if we simply store every possible substring as int keys in a unordered_map (as opposed to storing string keys). \\n\\nWe also can optimize keys stored by not storing any starting at 0 bit, as they are irrevelant. For case that query[0] == query[1] we need to store singular zero though (or lack of).\\n\\nEven though we have 10^4 * 32 map nodes at most, this solution is in 93% percentile in memory usage, so I guess it is not that bad memory wise. The map name \"prefix\" is misleading, ignore that.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> result;\\n        result.reserve(queries.size());\\n        \\n        unordered_map<int, pair<int, int>> prefix;\\n        bool was0 = false;\\n        \\n        for (int i = 0; i < s.size(); ++i)\\n        {\\n            int current = s[i] == \\'0\\' ? 0 : 1;\\n            \\n            if (current == 0)\\n            {\\n                if (!was0)\\n                {\\n                    was0 = true;\\n                    prefix.insert({0, {i, i + 1}});\\n                }\\n                continue;\\n            }\\n            \\n            int j = 1;\\n            for (; j < 32 && i + j < s.size(); ++j)\\n            {\\n                prefix.insert({current, {i, i + j}});\\n                current = current << 1;\\n                current += (s[i + j] == \\'1\\');\\n            }\\n            prefix.insert({current, {i, i + j}});\\n        }\\n        \\n        for (const auto& q : queries)\\n        {\\n            int needed = q[1] ^ q[0];\\n            \\n            auto it = prefix.find(needed);\\n            \\n            if (it == prefix.end())\\n            {\\n                result.push_back({-1, -1});\\n            }\\n            else\\n            {\\n                result.push_back({\\n                    it->second.first, \\n                    it->second.second - 1});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> result;\\n        result.reserve(queries.size());\\n        \\n        unordered_map<int, pair<int, int>> prefix;\\n        bool was0 = false;\\n        \\n        for (int i = 0; i < s.size(); ++i)\\n        {\\n            int current = s[i] == \\'0\\' ? 0 : 1;\\n            \\n            if (current == 0)\\n            {\\n                if (!was0)\\n                {\\n                    was0 = true;\\n                    prefix.insert({0, {i, i + 1}});\\n                }\\n                continue;\\n            }\\n            \\n            int j = 1;\\n            for (; j < 32 && i + j < s.size(); ++j)\\n            {\\n                prefix.insert({current, {i, i + j}});\\n                current = current << 1;\\n                current += (s[i + j] == \\'1\\');\\n            }\\n            prefix.insert({current, {i, i + j}});\\n        }\\n        \\n        for (const auto& q : queries)\\n        {\\n            int needed = q[1] ^ q[0];\\n            \\n            auto it = prefix.find(needed);\\n            \\n            if (it == prefix.end())\\n            {\\n                result.push_back({-1, -1});\\n            }\\n            else\\n            {\\n                result.push_back({\\n                    it->second.first, \\n                    it->second.second - 1});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182368,
                "title": "c-easy-beginner-friendly-code-bit-manipulation-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    // 2^30 solves the problem\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        \\n        unordered_map<int,vector<int>> mpp;\\n        \\n        for(int i=0;i<n;i++){  // Just in case, first==second, only lord 0 can save us\\n            if(s[i]==\\'0\\'){\\n                mpp[0]={i,i};\\n                break;\\n            }\\n        }\\n        \\n        for(int right=n-1;right>=0;right--){\\n            int decimalRep=0;\\n            int k=0;\\n            for(int left=right;left>=0 && right-j<=30;left--){ // only 30 bits is max possible as per constraints\\n                if(s[left]==\\'1\\'){\\n                    decimalRep+=pow(2,k);\\n                    if(mpp.find(decimalRep)==mpp.end() || mpp[decimalRep][0]>left){ // if absent, or update min left possible\\n                       mpp[decimalRep]={left,right};\\n                    }\\n                }\\n                k++;\\n            }\\n        }\\n        \\n        \\n        int Q=queries.size();\\n        vector<vector<int>> res(Q,{-1,-1});\\n\\n        for(int i=0;i<Q;i++){\\n            int first=queries[i][0];\\n            int second=queries[i][1];\\n            int T=second^first;\\n            \\n            if(mpp.find(T)!=mpp.end()){\\n                res[i]=mpp[T];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 2^30 solves the problem\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        \\n        unordered_map<int,vector<int>> mpp;\\n        \\n        for(int i=0;i<n;i++){  // Just in case, first==second, only lord 0 can save us\\n            if(s[i]==\\'0\\'){\\n                mpp[0]={i,i};\\n                break;\\n            }\\n        }\\n        \\n        for(int right=n-1;right>=0;right--){\\n            int decimalRep=0;\\n            int k=0;\\n            for(int left=right;left>=0 && right-j<=30;left--){ // only 30 bits is max possible as per constraints\\n                if(s[left]==\\'1\\'){\\n                    decimalRep+=pow(2,k);\\n                    if(mpp.find(decimalRep)==mpp.end() || mpp[decimalRep][0]>left){ // if absent, or update min left possible\\n                       mpp[decimalRep]={left,right};\\n                    }\\n                }\\n                k++;\\n            }\\n        }\\n        \\n        \\n        int Q=queries.size();\\n        vector<vector<int>> res(Q,{-1,-1});\\n\\n        for(int i=0;i<Q;i++){\\n            int first=queries[i][0];\\n            int second=queries[i][1];\\n            int T=second^first;\\n            \\n            if(mpp.find(T)!=mpp.end()){\\n                res[i]=mpp[T];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181540,
                "title": "c-solution-o-n-time-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given queries where `queries[i] = [first\\u1D62, second\\u1D62]`. We need to find a val such that `val ^ first\\u1D62 == second\\u1D62`.\\nNow,\\n=> `val ^ first\\u1D62 == second\\u1D62`\\n=> `val ^ first\\u1D62 ^ first\\u1D62 == second\\u1D62 ^ first\\u1D62`\\n=> `val == first\\u1D62 ^ second\\u1D62`\\nSo, for each query `queries[i] = [first\\u1D62, second\\u1D62]`, we need to find a val such that `val == first\\u1D62 ^ second\\u1D62`.\\n\\nNow, to find the val, we can preprocess and calculate all the possible values from the binary string of maximum length 32.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## binaryToDecimal function\\nTakes a binary string as an input and returns its integer equivalent.\\n\\n## substringXorQueries function\\n- First, preprocess and store all the possible values. Since if two strings have same value, we need string with less characters, we only change a map value if that condition is satisfied.\\n- Then, we can simply iterate over the query array and check if a particular value is present in the map or not.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long binaryToDecimal(string str) {\\n        long long int dec_num = 0LL;\\n        long long int power = 0LL;\\n        int n = str.size();\\n        for(int i=n-1; i>=0; --i) {\\n            if(str[i] == \\'1\\') dec_num = (1LL) * (dec_num + (1LL<<power));\\n            power++;\\n        }\\n        return dec_num;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        unordered_map <long long int, vector <int>> mp;\\n        for (int i=0; i<n; ++i) {\\n            for (int j=i; j>=0 && j>=i-32; --j) {\\n                string curr = s.substr(j, i - j + 1);\\n                long long int val = binaryToDecimal(curr);\\n                if (mp.find(val) == mp.end() || ((mp[val][1] - mp[val][0]) > (i - j))) mp[val] = {j, i} {\\n                    if  mp[val] = {j, i};\\n                }\\n            }\\n        }\\n        vector <vector <int>> ans;\\n        for (vector <int> query: queries) {\\n            int xorValue = (1LL) * (query[0] ^ query[1]);\\n            if (mp.find(xorValue) == mp.end()) ans.push_back({-1, -1});\\n            else ans.push_back(mp[xorValue]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Bit Manipulation",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long binaryToDecimal(string str) {\\n        long long int dec_num = 0LL;\\n        long long int power = 0LL;\\n        int n = str.size();\\n        for(int i=n-1; i>=0; --i) {\\n            if(str[i] == \\'1\\') dec_num = (1LL) * (dec_num + (1LL<<power));\\n            power++;\\n        }\\n        return dec_num;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        unordered_map <long long int, vector <int>> mp;\\n        for (int i=0; i<n; ++i) {\\n            for (int j=i; j>=0 && j>=i-32; --j) {\\n                string curr = s.substr(j, i - j + 1);\\n                long long int val = binaryToDecimal(curr);\\n                if (mp.find(val) == mp.end() || ((mp[val][1] - mp[val][0]) > (i - j))) mp[val] = {j, i} {\\n                    if  mp[val] = {j, i};\\n                }\\n            }\\n        }\\n        vector <vector <int>> ans;\\n        for (vector <int> query: queries) {\\n            int xorValue = (1LL) * (query[0] ^ query[1]);\\n            if (mp.find(xorValue) == mp.end()) ans.push_back({-1, -1});\\n            else ans.push_back(mp[xorValue]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181314,
                "title": "clean-hashmap-solution",
                "content": "# Intuition\\nThe idea is to store all (upto 32 digits long) binary substrings of `\"s\"` in a hashmap and then check the hashmap for each query.\\n\\nHere is the logic to enumerate all non-zero binary substrings of a string of length 1 to 32:\\n```\\nfor (int i=0; i<s.length(); i++)\\n{\\n    if (s[i]==\\'0\\') continue;\\n    int num = 0;\\n    for (int j=i; j<min(i+32,s.length()); j++) \\n    {\\n        num = (num<<1) + (s[j]-\\'0\\');\\n        cout << \"substring:\" << s.substr(i,j-i+1) << \",value:\" << num << endl; \\n    }\\n}\\n```\\nWe just need to expand this logic to also consider the substring `\"0\"` and also to create a hashmap of `num: [i,j]` instead of just printing. \\n\\nThe hashmap stores the positions of first instance of a substring.\\n\\nWhile querying, we are looking for `query[0]^query[1]` because `a^c=b => c=a^b`. If we find it in hashmap we append its positions to result else append `[-1,-1]`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \\n    {\\n        unordered_map<int, vector<int>> H;\\n        for (int i=0; i<s.length(); i++)\\n        {\\n            if (s[i]==\\'0\\')\\n            {\\n                if (!H.count(0)) H[0]={i,i}; \\n                continue;\\n            }\\n            int num = 0;\\n            for (int j=i; j<min(i+32,(int)s.length()); j++) \\n            {\\n                num = (num<<1)+(s[j]-\\'0\\');\\n                if (!H.count(num)) H[num] = {i,j};\\n            }\\n        }\\n        vector<vector<int>> res;\\n        for (auto &query: queries)\\n        {\\n            int val = query[0]^query[1];\\n            if (H.count(val)) res.push_back(H[val]);\\n            else res.push_back({-1,-1});\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\nTC: $O(n+m)$, SC: $O(n+m)$ where $n=\\\\vert s \\\\vert$, $m=\\\\vert Q \\\\vert $\\n\\n### Note on limits\\nActually we can also change the for loop to only consider substrings of upto 30 digits long: `for (int j=i; j<min(i+30,(int)s.length()); j++)`. This is because both `first` and `second` are in the range $[0,10^9]$, we know that $10^9$ in binary is 30 digits long. Hence their XOR can be at max 30 digits long ie their maximum value can be `2^{30}-1`.\\n\\nIn the current solution written above, the hashmap will also contain -ve numbers which is not useful for us but does us no harm. By changing 32 to 30 in the for loop, we can make hashmap a little bit smaller.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor (int i=0; i<s.length(); i++)\\n{\\n    if (s[i]==\\'0\\') continue;\\n    int num = 0;\\n    for (int j=i; j<min(i+32,s.length()); j++) \\n    {\\n        num = (num<<1) + (s[j]-\\'0\\');\\n        cout << \"substring:\" << s.substr(i,j-i+1) << \",value:\" << num << endl; \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \\n    {\\n        unordered_map<int, vector<int>> H;\\n        for (int i=0; i<s.length(); i++)\\n        {\\n            if (s[i]==\\'0\\')\\n            {\\n                if (!H.count(0)) H[0]={i,i}; \\n                continue;\\n            }\\n            int num = 0;\\n            for (int j=i; j<min(i+32,(int)s.length()); j++) \\n            {\\n                num = (num<<1)+(s[j]-\\'0\\');\\n                if (!H.count(num)) H[num] = {i,j};\\n            }\\n        }\\n        vector<vector<int>> res;\\n        for (auto &query: queries)\\n        {\\n            int val = query[0]^query[1];\\n            if (H.count(val)) res.push_back(H[val]);\\n            else res.push_back({-1,-1});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3180885,
                "title": "golang-203-ms-22-6-mb",
                "content": "# Complexity\\n- Time complexity: $$O(s.length + queries.length)$$\\n- Space complexity: $$O(s.length)$$\\n# Code\\n```\\nfunc min(a, b int16) int16 {\\n\\tif a <= b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc substringXorQueries(s string, queries [][]int) [][]int {\\n\\th := make(map[uint32][2]int16)\\n\\tvar nums [30]uint32\\n\\tfor i, iEnd := int16(0), int16(len(s)); i < iEnd; i++ {\\n\\t\\tfor j := min(29, i); j > 0; j-- {\\n\\t\\t\\tif nums[j-1] != 0 {\\n\\t\\t\\t\\tnums[j] = (nums[j-1] << 1) + uint32(s[i]-\\'0\\')\\n\\t\\t\\t\\tif _, exist := h[nums[j]]; !exist {\\n\\t\\t\\t\\t\\th[nums[j]] = [2]int16{i - j, i}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnums[j] = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnums[0] = uint32(s[i] - \\'0\\')\\n\\t\\tif _, exist := h[nums[0]]; !exist {\\n\\t\\t\\th[nums[0]] = [2]int16{i, i}\\n\\t\\t}\\n\\t}\\n\\tfor _, query := range queries {\\n\\t\\tif pos, exist := h[uint32(query[0]^query[1])]; exist {\\n\\t\\t\\tquery[0] = int(pos[0])\\n\\t\\t\\tquery[1] = int(pos[1])\\n\\t\\t} else {\\n\\t\\t\\tquery[0] = -1\\n\\t\\t\\tquery[1] = -1\\n\\t\\t}\\n\\t}\\n\\treturn queries\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc min(a, b int16) int16 {\\n\\tif a <= b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc substringXorQueries(s string, queries [][]int) [][]int {\\n\\th := make(map[uint32][2]int16)\\n\\tvar nums [30]uint32\\n\\tfor i, iEnd := int16(0), int16(len(s)); i < iEnd; i++ {\\n\\t\\tfor j := min(29, i); j > 0; j-- {\\n\\t\\t\\tif nums[j-1] != 0 {\\n\\t\\t\\t\\tnums[j] = (nums[j-1] << 1) + uint32(s[i]-\\'0\\')\\n\\t\\t\\t\\tif _, exist := h[nums[j]]; !exist {\\n\\t\\t\\t\\t\\th[nums[j]] = [2]int16{i - j, i}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnums[j] = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnums[0] = uint32(s[i] - \\'0\\')\\n\\t\\tif _, exist := h[nums[0]]; !exist {\\n\\t\\t\\th[nums[0]] = [2]int16{i, i}\\n\\t\\t}\\n\\t}\\n\\tfor _, query := range queries {\\n\\t\\tif pos, exist := h[uint32(query[0]^query[1])]; exist {\\n\\t\\t\\tquery[0] = int(pos[0])\\n\\t\\t\\tquery[1] = int(pos[1])\\n\\t\\t} else {\\n\\t\\t\\tquery[0] = -1\\n\\t\\t\\tquery[1] = -1\\n\\t\\t}\\n\\t}\\n\\treturn queries\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3180869,
                "title": "typescript-substring-xor-queries",
                "content": "\\n# Code\\n```\\nfunction getBinary(num:number): string {\\n    let str = new Array(30).fill(0);\\n    let temp = 30;\\n    let firstOne = -1;\\n    while(temp >= 0 && num > 0) {\\n        if(num - 2**temp >= 0) {\\n            if(firstOne < 0) {\\n                firstOne = 30-temp-1;\\n            }\\n            str[30-temp-1] = 1;\\n            num = num - 2**temp;\\n        }\\n        temp--;\\n    }\\n    return str.slice(firstOne).join(\\'\\');\\n}\\n\\nfunction substringXorQueries(s: string, queries: number[][]): number[][] {\\n    let ans = [];\\n    for(let i=0; i<queries.length; i++) {\\n        let findNum = getBinary(queries[i][0] ^ queries[i][1]);\\n        let index = s.indexOf(findNum);\\n        index > -1 ? ans.push([index, index+findNum.length-1]) : ans.push([-1, -1])\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction getBinary(num:number): string {\\n    let str = new Array(30).fill(0);\\n    let temp = 30;\\n    let firstOne = -1;\\n    while(temp >= 0 && num > 0) {\\n        if(num - 2**temp >= 0) {\\n            if(firstOne < 0) {\\n                firstOne = 30-temp-1;\\n            }\\n            str[30-temp-1] = 1;\\n            num = num - 2**temp;\\n        }\\n        temp--;\\n    }\\n    return str.slice(firstOne).join(\\'\\');\\n}\\n\\nfunction substringXorQueries(s: string, queries: number[][]): number[][] {\\n    let ans = [];\\n    for(let i=0; i<queries.length; i++) {\\n        let findNum = getBinary(queries[i][0] ^ queries[i][1]);\\n        let index = s.indexOf(findNum);\\n        index > -1 ? ans.push([index, index+findNum.length-1]) : ans.push([-1, -1])\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3180802,
                "title": "cpp-bitmanipulation-hashmap-nit-delhi-akash-kumar",
                "content": "# Intuition\\nsince maximum xor can be $$10^9$$ so I have come up with the intuition of storing all the number into hash map. because in 30 bit all number of range [0,$$10^9$$] will be included.\\n\\n# Approach\\nstarting from each index taking all the number string upto 30 unit bit and storing them into my hashmap. \\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertDecimal(string &binaryString){\\n        long long binaryVal=0,x=0;\\n        for(int i=binaryString.length()-1;i>=0;i--){\\n            if(binaryString[i]==\\'1\\'){\\n                binaryVal+=pow(2,x);\\n            }\\n            x++;\\n        }\\n        \\n        return binaryVal;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        //map of key=number and pair<int,int> first=index1 and second=index2\\n        map<int,pair<int,int> > hashedIndex;\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            //now till maximum 30 length it is possible to form the number.\\n            \\n            if(s[i]==\\'0\\')\\n            {\\n                if(hashedIndex.find(0)==hashedIndex.end())\\n                    hashedIndex[0]={i,i};\\n                continue;\\n            }\\n            string binaryString=\"\";\\n            int len=s.length();\\n            if(i+30<s.length())\\n             len=i+30;\\n            for(int j=i;j<len;j++){\\n                binaryString+=s[j];\\n                \\n                int binaryValue=convertDecimal(binaryString);\\n                \\n                //look into hash map if found then leave;\\n                if(hashedIndex.find(binaryValue)==hashedIndex.end()){\\n                    hashedIndex[binaryValue]={i,j};\\n                }\\n            }\\n        }\\n        \\n      vector<vector<int> > xorIndexRes;\\n      for(int i=0;i<queries.size();i++){\\n          int first=queries[i][0],second=queries[i][1];\\n          int xorVal=first^second;\\n          if(hashedIndex.find(xorVal)!=hashedIndex.end())\\n          {\\n              int lIndex=hashedIndex[xorVal].first,rIndex=hashedIndex[xorVal].second;\\n              xorIndexRes.push_back({lIndex,rIndex});\\n          }else\\n              xorIndexRes.push_back({-1,-1});\\n      }\\n        \\n        \\n        return xorIndexRes;\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertDecimal(string &binaryString){\\n        long long binaryVal=0,x=0;\\n        for(int i=binaryString.length()-1;i>=0;i--){\\n            if(binaryString[i]==\\'1\\'){\\n                binaryVal+=pow(2,x);\\n            }\\n            x++;\\n        }\\n        \\n        return binaryVal;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        //map of key=number and pair<int,int> first=index1 and second=index2\\n        map<int,pair<int,int> > hashedIndex;\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            //now till maximum 30 length it is possible to form the number.\\n            \\n            if(s[i]==\\'0\\')\\n            {\\n                if(hashedIndex.find(0)==hashedIndex.end())\\n                    hashedIndex[0]={i,i};\\n                continue;\\n            }\\n            string binaryString=\"\";\\n            int len=s.length();\\n            if(i+30<s.length())\\n             len=i+30;\\n            for(int j=i;j<len;j++){\\n                binaryString+=s[j];\\n                \\n                int binaryValue=convertDecimal(binaryString);\\n                \\n                //look into hash map if found then leave;\\n                if(hashedIndex.find(binaryValue)==hashedIndex.end()){\\n                    hashedIndex[binaryValue]={i,j};\\n                }\\n            }\\n        }\\n        \\n      vector<vector<int> > xorIndexRes;\\n      for(int i=0;i<queries.size();i++){\\n          int first=queries[i][0],second=queries[i][1];\\n          int xorVal=first^second;\\n          if(hashedIndex.find(xorVal)!=hashedIndex.end())\\n          {\\n              int lIndex=hashedIndex[xorVal].first,rIndex=hashedIndex[xorVal].second;\\n              xorIndexRes.push_back({lIndex,rIndex});\\n          }else\\n              xorIndexRes.push_back({-1,-1});\\n      }\\n        \\n        \\n        return xorIndexRes;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180774,
                "title": "a-few-solutions",
                "content": "For each query `a`,`b` of the input array `A`, find the index of the binary substring representation of `a ^ b` within the input string `S`.\\n\\n**Notes to avoid TLE:**\\n\\n* We preprocess `S` via a window of size `k = 1..30` inclusive to store binary values ending at index `i` non-inclusive in a map `m`\\n* Since the query values are less-than-or-equal to `1e9`, ie. 1 billion, we only need to consider binary representations less-than 2<sup>30</sup>\\n    * this is why we constrain the window size `k` upper bound to `30` inclusive\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun substringXorQueries(S: String, A: Array<IntArray>): Array<IntArray> {\\n        var m = mutableMapOf<Int, IntArray>()\\n        for (k in 1..Math.min(S.length + 1, 30)) {\\n            for (i in k..S.length) {\\n                var x = S.substring(i - k, i).toInt(2)\\n                if (!m.contains(x))\\n                    m[x] = intArrayOf(i - k, i - 1)\\n            }\\n        }\\n        return A.map{ (a, b) -> m[a xor b] ?: intArrayOf(-1, -1) }.toTypedArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet substringXorQueries = (S, A, m = new Map()) => {\\n    for (let k = 1; k <= Math.min(S.length, 30); ++k) {\\n        for (let i = k; i <= S.length; ++i) {\\n            let x = parseInt(S.substr(i - k, k), 2);\\n            if (!m.has(x))\\n                m.set(x, [i - k, i - 1]);\\n        }\\n    }\\n    return A.map(([a, b]) => m.has(a ^ b) ? m.get(a ^ b) : [-1, -1]);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def substringXorQueries(self, S: str, A: List[List[int]]) -> List[List[int]]:\\n        m = {}\\n        for k in range(1, min(30, len(S)) + 1):\\n            for i in range(k, len(S) + 1):\\n                x = int(S[i - k:i], 2)\\n                if x not in m:\\n                    m[x] = [i - k, i - 1]\\n        return [m[a ^ b] if a ^ b in m else [-1, -1] for a, b in A]\\n```\\n\\n*Python3: two-liner (just for fun)*\\n```\\nclass Solution:\\n    def substringXorQueries(self, S: str, A: List[List[int]]) -> List[List[int]]:\\n        m = {int(S[i - k:i], 2): [i - k, i - 1] for k in range(1, min(len(S), 30) + 1)[::-1] for i in range(k, len(S) + 1)[::-1]}\\n        return [m[a ^ b] if a ^ b in m else [-1, -1] for a, b in A]\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn substring_xor_queries(S: String, A: VVI) -> VVI {\\n        let mut m = HashMap::new();\\n        for k in 1..=min(S.len(), 30 as usize) {\\n            for i in k..=S.len() {\\n                let x = i32::from_str_radix(&S[i - k..i], 2).unwrap();\\n                if !m.contains_key(&x) {\\n                    m.insert(x, vec![(i - k) as i32, (i - 1) as i32]);\\n                }\\n            }\\n        }\\n        let mut ans = vec![];\\n        for pair in A {\\n            let (a, b) = (pair[0], pair[1]);\\n            if m.contains_key(&(a ^ b)) {\\n                let v = m.get(&(a ^ b)).unwrap();\\n                ans.push(vec![v[0].clone(), v[1].clone()]);\\n            } else {\\n                ans.push(vec![-1, -1]);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, VI>;\\n    VVI substringXorQueries(string S, VVI& A, Map m = {}, VVI ans = {}) {\\n        for (auto k{ 1 }; k <= min(S.size(), 30UL); ++k) {\\n            for (auto i{ k }; i <= S.size(); ++i) {\\n                auto x = stoi(S.substr(i - k, k), nullptr, 2);\\n                if (m.find(x) == m.end())\\n                    m[x] = {i - k, i - 1};\\n            }\\n        }\\n        transform(A.begin(), A.end(), back_inserter(ans), [&](auto& pair) {\\n            auto [a, b] = tie(pair[0], pair[1]);\\n            return m.find(a ^ b) != m.end() ? m[a ^ b] : VI{-1, -1};\\n        });\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun substringXorQueries(S: String, A: Array<IntArray>): Array<IntArray> {\\n        var m = mutableMapOf<Int, IntArray>()\\n        for (k in 1..Math.min(S.length + 1, 30)) {\\n            for (i in k..S.length) {\\n                var x = S.substring(i - k, i).toInt(2)\\n                if (!m.contains(x))\\n                    m[x] = intArrayOf(i - k, i - 1)\\n            }\\n        }\\n        return A.map{ (a, b) -> m[a xor b] ?: intArrayOf(-1, -1) }.toTypedArray()\\n    }\\n}\\n```\n```\\nlet substringXorQueries = (S, A, m = new Map()) => {\\n    for (let k = 1; k <= Math.min(S.length, 30); ++k) {\\n        for (let i = k; i <= S.length; ++i) {\\n            let x = parseInt(S.substr(i - k, k), 2);\\n            if (!m.has(x))\\n                m.set(x, [i - k, i - 1]);\\n        }\\n    }\\n    return A.map(([a, b]) => m.has(a ^ b) ? m.get(a ^ b) : [-1, -1]);\\n};\\n```\n```\\nclass Solution:\\n    def substringXorQueries(self, S: str, A: List[List[int]]) -> List[List[int]]:\\n        m = {}\\n        for k in range(1, min(30, len(S)) + 1):\\n            for i in range(k, len(S) + 1):\\n                x = int(S[i - k:i], 2)\\n                if x not in m:\\n                    m[x] = [i - k, i - 1]\\n        return [m[a ^ b] if a ^ b in m else [-1, -1] for a, b in A]\\n```\n```\\nclass Solution:\\n    def substringXorQueries(self, S: str, A: List[List[int]]) -> List[List[int]]:\\n        m = {int(S[i - k:i], 2): [i - k, i - 1] for k in range(1, min(len(S), 30) + 1)[::-1] for i in range(k, len(S) + 1)[::-1]}\\n        return [m[a ^ b] if a ^ b in m else [-1, -1] for a, b in A]\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn substring_xor_queries(S: String, A: VVI) -> VVI {\\n        let mut m = HashMap::new();\\n        for k in 1..=min(S.len(), 30 as usize) {\\n            for i in k..=S.len() {\\n                let x = i32::from_str_radix(&S[i - k..i], 2).unwrap();\\n                if !m.contains_key(&x) {\\n                    m.insert(x, vec![(i - k) as i32, (i - 1) as i32]);\\n                }\\n            }\\n        }\\n        let mut ans = vec![];\\n        for pair in A {\\n            let (a, b) = (pair[0], pair[1]);\\n            if m.contains_key(&(a ^ b)) {\\n                let v = m.get(&(a ^ b)).unwrap();\\n                ans.push(vec![v[0].clone(), v[1].clone()]);\\n            } else {\\n                ans.push(vec![-1, -1]);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, VI>;\\n    VVI substringXorQueries(string S, VVI& A, Map m = {}, VVI ans = {}) {\\n        for (auto k{ 1 }; k <= min(S.size(), 30UL); ++k) {\\n            for (auto i{ k }; i <= S.size(); ++i) {\\n                auto x = stoi(S.substr(i - k, k), nullptr, 2);\\n                if (m.find(x) == m.end())\\n                    m[x] = {i - k, i - 1};\\n            }\\n        }\\n        transform(A.begin(), A.end(), back_inserter(ans), [&](auto& pair) {\\n            auto [a, b] = tie(pair[0], pair[1]);\\n            return m.find(a ^ b) != m.end() ? m[a ^ b] : VI{-1, -1};\\n        });\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180526,
                "title": "fundamental-approach-c-bit-manip-xor",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        unordered_map<int, pair<int, int>> umap;\\n        for(int i=0;i<n;i++) {\\n            int curVal = 0;\\n            for(int j=0;j<min(31, n-i);j++) {\\n                curVal <<= 1;\\n                curVal += int(s[i+j]-\\'0\\');\\n                if(umap.find(curVal) == umap.end()) {\\n                    umap[curVal] = {i, i+j};\\n                }\\n                else if(j < umap[curVal].second-umap[curVal].first)\\n                    umap[curVal] = {i, i+j};\\n            }\\n        } \\n        vector<vector<int>> out;\\n        for(auto q: queries) {\\n            int val = q[0]^q[1];\\n            if(umap.find(val) != umap.end()) {\\n                out.push_back({umap[val].first, umap[val].second});\\n            }\\n            else {\\n                out.push_back({-1, -1});\\n            }\\n        }\\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: YouTube Channel (DeepCodes)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        unordered_map<int, pair<int, int>> umap;\\n        for(int i=0;i<n;i++) {\\n            int curVal = 0;\\n            for(int j=0;j<min(31, n-i);j++) {\\n                curVal <<= 1;\\n                curVal += int(s[i+j]-\\'0\\');\\n                if(umap.find(curVal) == umap.end()) {\\n                    umap[curVal] = {i, i+j};\\n                }\\n                else if(j < umap[curVal].second-umap[curVal].first)\\n                    umap[curVal] = {i, i+j};\\n            }\\n        } \\n        vector<vector<int>> out;\\n        for(auto q: queries) {\\n            int val = q[0]^q[1];\\n            if(umap.find(val) != umap.end()) {\\n                out.push_back({umap[val].first, umap[val].second});\\n            }\\n            else {\\n                out.push_back({-1, -1});\\n            }\\n        }\\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: YouTube Channel (DeepCodes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180176,
                "title": "hashmap-binary-string-c",
                "content": "# Complexity\\n- Time complexity: O(32*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>>ans(queries.size());\\n        map<string,int>m;\\n        for(int i=0; i<s.length(); i++){\\n            string d=\"\";\\n            for(int j=i; j<s.length(); j++){\\n                if(d.length()>32) break;\\n                d+=s[j];\\n                if(m[d]){continue;}\\n                else{\\n                    m[d]=i+1;\\n                }\\n            }\\n        }\\n        for(int i=0; i<queries.size(); i++){\\n            int val=(queries[i][0]^queries[i][1]);\\n            string curr=\"\";\\n            if(val==0) curr=\"0\";\\n            while(val>0){\\n                curr+=char(val%2+\\'0\\');\\n                val/=2;\\n            }\\n            reverse(curr.begin(),curr.end());\\n            if(m[curr]){\\n                ans[i].push_back(m[curr]-1);\\n                ans[i].push_back(m[curr]+curr.length()-2);\\n            }\\n            else{\\n                ans[i].push_back(-1);\\n                ans[i].push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>>ans(queries.size());\\n        map<string,int>m;\\n        for(int i=0; i<s.length(); i++){\\n            string d=\"\";\\n            for(int j=i; j<s.length(); j++){\\n                if(d.length()>32) break;\\n                d+=s[j];\\n                if(m[d]){continue;}\\n                else{\\n                    m[d]=i+1;\\n                }\\n            }\\n        }\\n        for(int i=0; i<queries.size(); i++){\\n            int val=(queries[i][0]^queries[i][1]);\\n            string curr=\"\";\\n            if(val==0) curr=\"0\";\\n            while(val>0){\\n                curr+=char(val%2+\\'0\\');\\n                val/=2;\\n            }\\n            reverse(curr.begin(),curr.end());\\n            if(m[curr]){\\n                ans[i].push_back(m[curr]-1);\\n                ans[i].push_back(m[curr]+curr.length()-2);\\n            }\\n            else{\\n                ans[i].push_back(-1);\\n                ans[i].push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179864,
                "title": "o-n-32-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        \\n        vector<vector<int>> ans;\\n        map<int ,vector<int>> Rf;//<value,range>\\n        int n=s.length();\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if(i>=n)break;\\n            \\n           long long int val=0;\\n            int l=i;\\n            while(l>=0)\\n            {\\n                val = val+(s[n-1-i+l]-\\'0\\')*(1<<(i-l));\\n                l--;\\n            }\\n            \\n            if(Rf[val].size()==0)\\n            {\\n                Rf[val]={n-1-i,n-1};\\n            }\\n            else\\n            {\\n                if(i+1 < Rf[val][1]-Rf[val][0]+1) Rf[val]={n-1-i,n-1};\\n                 \\n                else if(i+1 == Rf[val][1]-Rf[val][0]+1)\\n                {\\n                    if(n-1-i < Rf[val][0])\\n                    {\\n                         Rf[val]={n-1-i,n-1};\\n                    }\\n                }\\n            }\\n            \\n            long long int Val_To_add = (1<<i);\\n            \\n            int pointer = n-2-i;\\n            \\n            while(pointer>=0)\\n            {\\n                val=val/2;\\n                val=val+(Val_To_add)*(s[pointer]-\\'0\\');\\n                \\n             if(Rf[val].size())\\n              {\\n                if(i+1 < Rf[val][1]-Rf[val][0]+1) Rf[val]={pointer,pointer+i};\\n                 \\n                else if(i+1 == Rf[val][1]-Rf[val][0]+1)\\n                {\\n                    if(pointer < Rf[val][0])\\n                    {\\n                         Rf[val]={pointer,pointer+i};\\n                    }\\n                }\\n                 \\n              }     \\n                else\\n                {\\n                    Rf[val]={pointer,pointer+i};\\n                }\\n\\n                pointer--;\\n            }\\n                 \\n        }\\n        \\n        for(auto p:q)\\n        {\\n            int vl = (p[0]^p[1]);\\n            \\n            if(Rf[vl].size())\\n            {\\n                ans.push_back(Rf[vl]);\\n            }\\n            else\\n            {\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        \\n        vector<vector<int>> ans;\\n        map<int ,vector<int>> Rf;//<value,range>\\n        int n=s.length();\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if(i>=n)break;\\n            \\n           long long int val=0;\\n            int l=i;\\n            while(l>=0)\\n            {\\n                val = val+(s[n-1-i+l]-\\'0\\')*(1<<(i-l));\\n                l--;\\n            }\\n            \\n            if(Rf[val].size()==0)\\n            {\\n                Rf[val]={n-1-i,n-1};\\n            }\\n            else\\n            {\\n                if(i+1 < Rf[val][1]-Rf[val][0]+1) Rf[val]={n-1-i,n-1};\\n                 \\n                else if(i+1 == Rf[val][1]-Rf[val][0]+1)\\n                {\\n                    if(n-1-i < Rf[val][0])\\n                    {\\n                         Rf[val]={n-1-i,n-1};\\n                    }\\n                }\\n            }\\n            \\n            long long int Val_To_add = (1<<i);\\n            \\n            int pointer = n-2-i;\\n            \\n            while(pointer>=0)\\n            {\\n                val=val/2;\\n                val=val+(Val_To_add)*(s[pointer]-\\'0\\');\\n                \\n             if(Rf[val].size())\\n              {\\n                if(i+1 < Rf[val][1]-Rf[val][0]+1) Rf[val]={pointer,pointer+i};\\n                 \\n                else if(i+1 == Rf[val][1]-Rf[val][0]+1)\\n                {\\n                    if(pointer < Rf[val][0])\\n                    {\\n                         Rf[val]={pointer,pointer+i};\\n                    }\\n                }\\n                 \\n              }     \\n                else\\n                {\\n                    Rf[val]={pointer,pointer+i};\\n                }\\n\\n                pointer--;\\n            }\\n                 \\n        }\\n        \\n        for(auto p:q)\\n        {\\n            int vl = (p[0]^p[1]);\\n            \\n            if(Rf[vl].size())\\n            {\\n                ans.push_back(Rf[vl]);\\n            }\\n            else\\n            {\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179453,
                "title": "python3-o-30n-dict-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*a ^ b = c* => *b ^ c = a*\\nAs the query range is [0, 10 ** 9], which means the max binary bits is 30.\\nWe use a dict to store all first occeurence of number.\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        dt = dict()\\n        for i in range(len(s)):\\n            cur = int(s[i])\\n            if cur not in dt: dt[cur] = [i, i]\\n            if cur == 0: continue\\n            for j in range(i + 1, min(len(s), i + 30)):\\n                cur = cur * 2 + int(s[j])\\n                if cur not in dt: dt[cur] = [i, j]\\n        return [dt[s ^ e] if s ^ e in dt else [-1, -1] for s, e in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        dt = dict()\\n        for i in range(len(s)):\\n            cur = int(s[i])\\n            if cur not in dt: dt[cur] = [i, i]\\n            if cur == 0: continue\\n            for j in range(i + 1, min(len(s), i + 30)):\\n                cur = cur * 2 + int(s[j])\\n                if cur not in dt: dt[cur] = [i, j]\\n        return [dt[s ^ e] if s ^ e in dt else [-1, -1] for s, e in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179252,
                "title": "best-solution-in-c-tc-o-n-30",
                "content": "# Code\\n#### **PLease Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int binaryToDecimal(string str){\\n        int val=0,n=str.size();\\n        for(int i=0;i<n;i++){\\n            int x=str[n-i-1] - \\'0\\';\\n            val+=x<<i;\\n        }\\n        return val;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans;\\n        int n=s.size();\\n        unordered_map<int,pair<int,int>> mp;\\n        for(int i=0;i<n;i++){  // this will insert first occurring 0 into the map(if present & then break)\\n            if(s[i]==\\'0\\'){\\n                mp[0]={i,i};\\n                break;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                int j=0;\\n                string str=\"\";\\n                while((i+j)<n && j!=30){\\n                    str+=s[i+j];\\n                    int val=binaryToDecimal(str);\\n                    if(mp.find(val)==mp.end())\\n                        mp[val]={i,i+j};\\n                    j++;\\n                }\\n            }\\n        }\\n        for(auto it:queries){\\n            int x=it[0]^it[1];\\n            if(mp.find(x)!=mp.end()){\\n                auto gt=mp[x];\\n                ans.push_back({gt.first,gt.second});\\n            }\\n            else\\n                ans.push_back({-1,-1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryToDecimal(string str){\\n        int val=0,n=str.size();\\n        for(int i=0;i<n;i++){\\n            int x=str[n-i-1] - \\'0\\';\\n            val+=x<<i;\\n        }\\n        return val;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans;\\n        int n=s.size();\\n        unordered_map<int,pair<int,int>> mp;\\n        for(int i=0;i<n;i++){  // this will insert first occurring 0 into the map(if present & then break)\\n            if(s[i]==\\'0\\'){\\n                mp[0]={i,i};\\n                break;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                int j=0;\\n                string str=\"\";\\n                while((i+j)<n && j!=30){\\n                    str+=s[i+j];\\n                    int val=binaryToDecimal(str);\\n                    if(mp.find(val)==mp.end())\\n                        mp[val]={i,i+j};\\n                    j++;\\n                }\\n            }\\n        }\\n        for(auto it:queries){\\n            int x=it[0]^it[1];\\n            if(mp.find(x)!=mp.end()){\\n                auto gt=mp[x];\\n                ans.push_back({gt.first,gt.second});\\n            }\\n            else\\n                ans.push_back({-1,-1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179198,
                "title": "java-map",
                "content": "```\\n    //1.Map\\n    //Runtime: 38ms 66%; Memory: 100.4MB 16%\\n    //Time: O(L * 30 + N); Space: (L * 30)\\n    //let L be the length of input string S, let N be the number of queries,\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        //pre-compute\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                map.putIfAbsent(0, new int[] {i, i});\\n                continue;\\n            }\\n\\n            //1000_000_000 : 2^30\\n            int val = 0;\\n            for (int j = i; j < Math.min(i + 30, s.length()); j++) {\\n                val <<= 1;\\n                val += (s.charAt(j) - \\'0\\');\\n                map.putIfAbsent(val, new int[] {i, j});\\n            }\\n        }\\n\\n        //query\\n        int[][] res = new int[queries.length][2];\\n        for (int i = 0; i < queries.length; i++)\\n            res[i] = map.getOrDefault(queries[i][0] ^ queries[i][1], new int[]{-1, -1});\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\n    //1.Map\\n    //Runtime: 38ms 66%; Memory: 100.4MB 16%\\n    //Time: O(L * 30 + N); Space: (L * 30)\\n    //let L be the length of input string S, let N be the number of queries,\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        //pre-compute\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                map.putIfAbsent(0, new int[] {i, i});\\n                continue;\\n            }\\n\\n            //1000_000_000 : 2^30\\n            int val = 0;\\n            for (int j = i; j < Math.min(i + 30, s.length()); j++) {\\n                val <<= 1;\\n                val += (s.charAt(j) - \\'0\\');\\n                map.putIfAbsent(val, new int[] {i, j});\\n            }\\n        }\\n\\n        //query\\n        int[][] res = new int[queries.length][2];\\n        for (int i = 0; i < queries.length; i++)\\n            res[i] = map.getOrDefault(queries[i][0] ^ queries[i][1], new int[]{-1, -1});\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3178652,
                "title": "python-hashmap-simple-code",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(lambda:-1)\\n        n = len(s)\\n        for i in range(n):\\n            for j in range(i,min(i+31,n)):\\n                v = s[i:j+1]\\n                if d[v] == -1:\\n                    d[v] = i\\n        res = []\\n        for x,y in queries:\\n            v = bin(x^y)[2:]\\n            if d[v] == -1:\\n                res.append([-1,-1])\\n            else:\\n                res.append([d[v],d[v]+len(v)-1])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(lambda:-1)\\n        n = len(s)\\n        for i in range(n):\\n            for j in range(i,min(i+31,n)):\\n                v = s[i:j+1]\\n                if d[v] == -1:\\n                    d[v] = i\\n        res = []\\n        for x,y in queries:\\n            v = bin(x^y)[2:]\\n            if d[v] == -1:\\n                res.append([-1,-1])\\n            else:\\n                res.append([d[v],d[v]+len(v)-1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178355,
                "title": "go-map",
                "content": "```\\nfunc s2b(v string) int {\\n\\te := len(v) - 1\\n\\tif e > 63 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tvar b int = 0\\n\\tfor i := range v {\\n\\t\\tif v[i] == 49 {\\n\\t\\t\\tb |= 1\\n\\t\\t}\\n\\t\\tif i != e {\\n\\t\\t\\tb <<= 1\\n\\t\\t}\\n\\t}\\n\\treturn b\\n}\\n\\nfunc substringXorQueries(s string, q [][]int) [][]int {\\n\\tmin := func(a, b int) int {\\n\\t\\tif a < b {\\n\\t\\t\\treturn a\\n\\t\\t}\\n\\t\\treturn b\\n\\t}\\n\\n\\ttr := make(map[int][2]int)\\n\\tf := false\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == 48 {\\n\\t\\t\\tif f {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tf = true\\n\\t\\t\\ttr[0] = [2]int{i, i}\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor j := i; j < min(i+30, len(s)); j++ {\\n\\t\\t\\tss := s2b(s[i : j+1])\\n\\t\\t\\tif _, ok := tr[ss]; ok {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\ttr[ss] = [2]int{i, j}\\n\\t\\t}\\n\\t}\\n\\n\\tans := make([][]int, len(q))\\n\\tfor i := 0; i < len(q); i++ {\\n\\t\\tv := q[i][0] ^ q[i][1]\\n\\t\\tif x, ok := tr[v]; ok {\\n\\t\\t\\tans[i] = []int{x[0], x[1]}\\n\\t\\t} else {\\n\\t\\t\\tans[i] = []int{-1, -1}\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc s2b(v string) int {\\n\\te := len(v) - 1\\n\\tif e > 63 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tvar b int = 0\\n\\tfor i := range v {\\n\\t\\tif v[i] == 49 {\\n\\t\\t\\tb |= 1\\n\\t\\t}\\n\\t\\tif i != e {\\n\\t\\t\\tb <<= 1\\n\\t\\t}\\n\\t}\\n\\treturn b\\n}\\n\\nfunc substringXorQueries(s string, q [][]int) [][]int {\\n\\tmin := func(a, b int) int {\\n\\t\\tif a < b {\\n\\t\\t\\treturn a\\n\\t\\t}\\n\\t\\treturn b\\n\\t}\\n\\n\\ttr := make(map[int][2]int)\\n\\tf := false\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == 48 {\\n\\t\\t\\tif f {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tf = true\\n\\t\\t\\ttr[0] = [2]int{i, i}\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor j := i; j < min(i+30, len(s)); j++ {\\n\\t\\t\\tss := s2b(s[i : j+1])\\n\\t\\t\\tif _, ok := tr[ss]; ok {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\ttr[ss] = [2]int{i, j}\\n\\t\\t}\\n\\t}\\n\\n\\tans := make([][]int, len(q))\\n\\tfor i := 0; i < len(q); i++ {\\n\\t\\tv := q[i][0] ^ q[i][1]\\n\\t\\tif x, ok := tr[v]; ok {\\n\\t\\t\\tans[i] = []int{x[0], x[1]}\\n\\t\\t} else {\\n\\t\\t\\tans[i] = []int{-1, -1}\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3178211,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                map.putIfAbsent(0, new int[] {i, i});\\n                continue;  \\n            }\\n\\n            int num = 0;\\n            for (int j = i; j < s.length() && j < i + 32; j++) {\\n                num *= 2;   \\n                num += (s.charAt(j) - \\'0\\');\\n                map.putIfAbsent(num, new int[] {i, j});\\n            }\\n        }\\n\\n        int[][] ans = new int[queries.length][2];\\n        int i = 0;\\n        for (int[] q : queries) {\\n            int val = q[0] ^ q[1];  \\n            ans[i++] = map.getOrDefault(val, new int[] {-1, -1});\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                map.putIfAbsent(0, new int[] {i, i});\\n                continue;  \\n            }\\n\\n            int num = 0;\\n            for (int j = i; j < s.length() && j < i + 32; j++) {\\n                num *= 2;   \\n                num += (s.charAt(j) - \\'0\\');\\n                map.putIfAbsent(num, new int[] {i, j});\\n            }\\n        }\\n\\n        int[][] ans = new int[queries.length][2];\\n        int i = 0;\\n        for (int[] q : queries) {\\n            int val = q[0] ^ q[1];  \\n            ans[i++] = map.getOrDefault(val, new int[] {-1, -1});\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178177,
                "title": "c-hash-map-o-32-2-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, vector<int>> r;\\n        for (int len = 1; len < 32; ++len) {\\n            for (int i = 0; i + len <= s.size(); ++i) {\\n                int v = 0;\\n                for (int j = 0; j < len; ++j) {\\n                    v = (v << 1) | (s[i + j] - \\'0\\');\\n                }\\n                if (!r.count(v)) {\\n                    r[v] = vector<int>{i, i + len - 1};\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> res;\\n        for (auto q : queries) {\\n            int v = q[0] ^ q[1];\\n            if (r.count(v)) {\\n                res.push_back(r[v]);\\n            } else {\\n                res.push_back({-1, -1});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, vector<int>> r;\\n        for (int len = 1; len < 32; ++len) {\\n            for (int i = 0; i + len <= s.size(); ++i) {\\n                int v = 0;\\n                for (int j = 0; j < len; ++j) {\\n                    v = (v << 1) | (s[i + j] - \\'0\\');\\n                }\\n                if (!r.count(v)) {\\n                    r[v] = vector<int>{i, i + len - 1};\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> res;\\n        for (auto q : queries) {\\n            int v = q[0] ^ q[1];\\n            if (r.count(v)) {\\n                res.push_back(r[v]);\\n            } else {\\n                res.push_back({-1, -1});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177937,
                "title": "python-hash-map-to-record-the-first-range-that-represents-a-number-explained",
                "content": "Build a hash map to record the first range that represents a number.\\n\\n(1) For each index of the string, we only need to check upto the next 32 index since a signed integer is 31 bits long;\\n(2) For each query, we compute the query[0] ^ query[1] and check if this number is in the hash map\\n`val ^ query[0] = query[1] --> val ^ query[0] ^ query[0] = query[1] ^ query[0] --> val = query[0] ^ query[1]`\\n\\n\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        num_dict = dict()\\n        idx = 0\\n        while idx < len(s):\\n            # only check the number start with bit \\'1\\' to reduce cases\\n            if s[idx] == \\'1\\':\\n                for j in range(1, 32):\\n                    if idx + j <= len(s):\\n                        num = int(s[idx:idx + j], 2)\\n                        if num not in num_dict:\\n                            num_dict[num] = [idx, idx + j - 1]\\n            elif 0 not in num_dict:\\n                num_dict[0] = [idx, idx]\\n            idx += 1\\n        \\n        ans = []\\n        for query in queries:\\n            num = query[0] ^ query[1]\\n            if num in num_dict:\\n                ans.append(num_dict[num])\\n            else:\\n                ans.append([-1, -1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        num_dict = dict()\\n        idx = 0\\n        while idx < len(s):\\n            # only check the number start with bit \\'1\\' to reduce cases\\n            if s[idx] == \\'1\\':\\n                for j in range(1, 32):\\n                    if idx + j <= len(s):\\n                        num = int(s[idx:idx + j], 2)\\n                        if num not in num_dict:\\n                            num_dict[num] = [idx, idx + j - 1]\\n            elif 0 not in num_dict:\\n                num_dict[0] = [idx, idx]\\n            idx += 1\\n        \\n        ans = []\\n        for query in queries:\\n            num = query[0] ^ query[1]\\n            if num in num_dict:\\n                ans.append(num_dict[num])\\n            else:\\n                ans.append([-1, -1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177901,
                "title": "swift-hashmap-9-sloc",
                "content": "**See Also:** [**ALT APPROACH USING TRIES**](https://leetcode.com/problems/substring-xor-queries/discuss/3177837/Swift-or-Trie)\\n\\n---\\n\\n**HashMap, hardcoded window width of 30, which handles all test cases (accepted answer)**\\n```\\nclass Solution {\\n    func substringXorQueries(_ s: String, _ queries: [[Int]]) -> [[Int]] {\\n        let s = Array(s), zeroIndex = s.firstIndex(of: \"0\") ?? -1\\n        var hashMap = [0: [zeroIndex, zeroIndex]]\\n        \\n        for left in s.indices where s[left] != \"0\" {\\n            for right in left ..< min(left + 30, s.count) {\\n                let key = s[left...right].reduce(0) { key, ch in (key << 1) + (ch == \"1\" ? 1 : 0) }\\n                hashMap[key] = hashMap[key] ?? [left, right] \\n            }\\n        }\\n        \\n        return queries.map { query in hashMap[query[0] ^ query[1]] ?? [-1,-1] }\\n    }\\n}\\n```\\n\\n----\\n\\n**HashMap, calculating minimum window width (accepted answer)**\\n```\\nclass Solution {\\n    func substringXorQueries(_ s: String, _ queries: [[Int]]) -> [[Int]] {\\n        let s = Array(s), zeroIndex = s.firstIndex(of: \"0\") ?? -1\\n        var hashMap = [0: [zeroIndex, zeroIndex]]\\n        \\n        let qMax = queries.reduce(0) { qMax, query in max(qMax, query[0] ^ query[1]) }\\n        var windowWidth = 1\\n        while 1 << windowWidth <= qMax {\\n            windowWidth += 1\\n        }\\n        \\n        for left in s.indices where s[left] != \"0\" {\\n            for right in left ..< min(left + windowWidth, s.count) {\\n                let key = s[left...right].reduce(0) { key, ch in (key << 1) + (ch == \"1\" ? 1 : 0)}\\n                hashMap[key] = hashMap[key] ?? [left, right] \\n            }\\n        }\\n        \\n        return queries.map { query in hashMap[query[0] ^ query[1]] ?? [-1,-1] }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func substringXorQueries(_ s: String, _ queries: [[Int]]) -> [[Int]] {\\n        let s = Array(s), zeroIndex = s.firstIndex(of: \"0\") ?? -1\\n        var hashMap = [0: [zeroIndex, zeroIndex]]\\n        \\n        for left in s.indices where s[left] != \"0\" {\\n            for right in left ..< min(left + 30, s.count) {\\n                let key = s[left...right].reduce(0) { key, ch in (key << 1) + (ch == \"1\" ? 1 : 0) }\\n                hashMap[key] = hashMap[key] ?? [left, right] \\n            }\\n        }\\n        \\n        return queries.map { query in hashMap[query[0] ^ query[1]] ?? [-1,-1] }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func substringXorQueries(_ s: String, _ queries: [[Int]]) -> [[Int]] {\\n        let s = Array(s), zeroIndex = s.firstIndex(of: \"0\") ?? -1\\n        var hashMap = [0: [zeroIndex, zeroIndex]]\\n        \\n        let qMax = queries.reduce(0) { qMax, query in max(qMax, query[0] ^ query[1]) }\\n        var windowWidth = 1\\n        while 1 << windowWidth <= qMax {\\n            windowWidth += 1\\n        }\\n        \\n        for left in s.indices where s[left] != \"0\" {\\n            for right in left ..< min(left + windowWidth, s.count) {\\n                let key = s[left...right].reduce(0) { key, ch in (key << 1) + (ch == \"1\" ? 1 : 0)}\\n                hashMap[key] = hashMap[key] ?? [left, right] \\n            }\\n        }\\n        \\n        return queries.map { query in hashMap[query[0] ^ query[1]] ?? [-1,-1] }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177837,
                "title": "swift-trie",
                "content": "**SEE ALSO:** [**HASHMAP SOLUTION**](https://leetcode.com/problems/substring-xor-queries/discuss/3177901/Swift-or-HashMap-or-9-SLOC)\\n\\n---\\n\\n**Trie Approach (accepted answer)**\\n\\u26A0\\uFE0F - slower, more memory consumption, more code than hashmap solution.\\n```\\nclass Solution {\\n    func substringXorQueries(_ s: String, _ queries: [[Int]]) -> [[Int]] {\\n        class TrieNode {\\n            var indices = [Int]()\\n            var children = [Character:TrieNode]()\\n        }\\n\\n        let s = Array(s)\\n        var result = Array(repeating:[-1,-1], count: queries.count)\\n        var trieRoot = TrieNode()\\n\\n        for (index,query) in queries.enumerated() {\\n            var t = [Character]()\\n            var q = query[0] ^ query[1]\\n            while q > 0 {\\n                t += [\"0\",\"1\"][q&1]\\n                q >>= 1\\n            }\\n            var runner = trieRoot\\n            for ch in t.isEmpty ? [\"0\"] : t.reversed() {\\n                runner.children[ch] = runner.children[ch] ?? TrieNode()\\n                runner = runner.children[ch]!\\n            }\\n            runner.indices.append(index)\\n        }\\n\\n        var left = 0, remaining = queries.count\\n        while left < s.count && remaining > 0 {\\n            var runner = trieRoot, right = left\\n            while right < s.count, let next = runner.children[s[right]] {\\n                next.indices.forEach { i in result[i] = [left, right] }\\n                remaining -= next.indices.count\\n                next.indices = []\\n                runner = next\\n                right += 1\\n            }\\n            left += 1\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func substringXorQueries(_ s: String, _ queries: [[Int]]) -> [[Int]] {\\n        class TrieNode {\\n            var indices = [Int]()\\n            var children = [Character:TrieNode]()\\n        }\\n\\n        let s = Array(s)\\n        var result = Array(repeating:[-1,-1], count: queries.count)\\n        var trieRoot = TrieNode()\\n\\n        for (index,query) in queries.enumerated() {\\n            var t = [Character]()\\n            var q = query[0] ^ query[1]\\n            while q > 0 {\\n                t += [\"0\",\"1\"][q&1]\\n                q >>= 1\\n            }\\n            var runner = trieRoot\\n            for ch in t.isEmpty ? [\"0\"] : t.reversed() {\\n                runner.children[ch] = runner.children[ch] ?? TrieNode()\\n                runner = runner.children[ch]!\\n            }\\n            runner.indices.append(index)\\n        }\\n\\n        var left = 0, remaining = queries.count\\n        while left < s.count && remaining > 0 {\\n            var runner = trieRoot, right = left\\n            while right < s.count, let next = runner.children[s[right]] {\\n                next.indices.forEach { i in result[i] = [left, right] }\\n                remaining -= next.indices.count\\n                next.indices = []\\n                runner = next\\n                right += 1\\n            }\\n            left += 1\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177804,
                "title": "integer-binary-size-is-limited-to-32-bit-enumerate-all-possible-values-from-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ninteger binary size is limited to 32 bit\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nenumerate all possible values from s, store the value, start index.\\nenumerate 10^4 * 32 times.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(max(len(queries), len(s)*32))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(len(s)*32)\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        vi = {}\\n        n = len(s)\\n        for i in range(n):\\n            e = min(32, n-i)\\n            for j in range(1, e+1):\\n                if s[i:i+j] in vi:\\n                    continue\\n                vi[s[i: i+j]] = (i, i+j-1)\\n        \\n        for s1, s2 in queries:\\n            t = s1^s2\\n            t = bin(t)[2:]\\n            if t in vi:\\n                res.append(vi[t])\\n            else:\\n                res.append((-1, -1))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        vi = {}\\n        n = len(s)\\n        for i in range(n):\\n            e = min(32, n-i)\\n            for j in range(1, e+1):\\n                if s[i:i+j] in vi:\\n                    continue\\n                vi[s[i: i+j]] = (i, i+j-1)\\n        \\n        for s1, s2 in queries:\\n            t = s1^s2\\n            t = bin(t)[2:]\\n            if t in vi:\\n                res.append(vi[t])\\n            else:\\n                res.append((-1, -1))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177799,
                "title": "c-hashmap-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string &s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        unordered_map <int, pair<int, int>> m;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'0\\') {\\n                if(!m.count(0)) m[0] = {i, i};\\n                continue;\\n            }\\n            string str = \"\";\\n            for(int j = i; j <= min(n - 1, i + 30); j++) {\\n                str += s[j];\\n                int val = stoi(str, 0, 2);\\n                if(!m.count(val)) m[val] = {i, j};\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(auto &q: queries) {\\n            int val = q[0] ^ q[1];\\n            if(m.count(val)) ans.push_back({m[val].first, m[val].second});\\n            else ans.push_back({-1, -1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string &s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        unordered_map <int, pair<int, int>> m;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'0\\') {\\n                if(!m.count(0)) m[0] = {i, i};\\n                continue;\\n            }\\n            string str = \"\";\\n            for(int j = i; j <= min(n - 1, i + 30); j++) {\\n                str += s[j];\\n                int val = stoi(str, 0, 2);\\n                if(!m.count(val)) m[val] = {i, j};\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(auto &q: queries) {\\n            int val = q[0] ^ q[1];\\n            if(m.count(val)) ans.push_back({m[val].first, m[val].second});\\n            else ans.push_back({-1, -1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177238,
                "title": "python-breaking-constraints-with-substring-mapping",
                "content": "# Intuition\\nQuick refresher on XOR operation: a^b = c => c^a = b =>  b^c = a\\nIdea is to void runing time where maximum length of binary string and number of queries multiply O(SxQ), anything faster will do. \\nIdea is to use fact that binary numbers will be within range of 32 bits, this can be used to precalculate cuts upto length of 32. This is some constant time over string length wich is eqvivalent to O(S). On precalculating record first index where substring appears, this will be used later to give each query O(1) time. At the end run query which will produce O(Q + S) runing time.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(Q + S)\\n\\n- Space complexity:\\nO(Q + S)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def find(self, s):\\n        index = self.mp[s]\\n        if index != -1: return [index, index + len(s) - 1]\\n        return [index,index]\\n\\n    def precalculate(self, s):\\n        self.mp = defaultdict(lambda: -1)\\n        for i in range(len(s)):\\n            substring = \\'\\'\\n            for j in range(32):\\n                if i + j == len(s): break\\n                substring += s[i+j]\\n                if self.mp[substring] == -1:\\n                    self.mp[substring] = i\\n\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        self.precalculate(s)\\n        return [self.find(bin(first ^ second)[2:]) for first, second in queries]\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Bit Manipulation",
                    "Hash Function"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def find(self, s):\\n        index = self.mp[s]\\n        if index != -1: return [index, index + len(s) - 1]\\n        return [index,index]\\n\\n    def precalculate(self, s):\\n        self.mp = defaultdict(lambda: -1)\\n        for i in range(len(s)):\\n            substring = \\'\\'\\n            for j in range(32):\\n                if i + j == len(s): break\\n                substring += s[i+j]\\n                if self.mp[substring] == -1:\\n                    self.mp[substring] = i\\n\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        self.precalculate(s)\\n        return [self.find(bin(first ^ second)[2:]) for first, second in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177155,
                "title": "unordered-map-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<long, pair<int,int>> map;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                int n = 0;\\n                if(map.find(0) == map.end())\\n                {\\n                    map[0] = make_pair(i, i);\\n                }\\n            }\\n            if(s[i] == \\'1\\')\\n            {\\n                long n = 1;\\n                if(map.find(n) == map.end())\\n                {\\n                    map[n] = make_pair(i, i);\\n                }\\n                for(int k = 1; k <= 32 && k + i < s.size() ; k++)\\n                {\\n                    n = n * 2 + (s[i+k] -\\'0\\');\\n                    if(map.find(n) == map.end())\\n                         map[n] = make_pair(i, i+k);\\n                }\\n            }\\n        }\\n        vector<vector<int>> ret;\\n        ret.clear();\\n        for(auto q: queries)\\n        {\\n            vector<int> tmp(2);\\n            int val = q[0] ^ q[1];\\n            if(map.find(val) == map.end())\\n            {\\n                tmp[0] = -1;\\n                tmp[1] = -1;\\n            }\\n            else\\n            {\\n                tmp[0] = map[val].first;\\n                tmp[1] = map[val].second;\\n            }\\n            ret.push_back(tmp);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<long, pair<int,int>> map;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                int n = 0;\\n                if(map.find(0) == map.end())\\n                {\\n                    map[0] = make_pair(i, i);\\n                }\\n            }\\n            if(s[i] == \\'1\\')\\n            {\\n                long n = 1;\\n                if(map.find(n) == map.end())\\n                {\\n                    map[n] = make_pair(i, i);\\n                }\\n                for(int k = 1; k <= 32 && k + i < s.size() ; k++)\\n                {\\n                    n = n * 2 + (s[i+k] -\\'0\\');\\n                    if(map.find(n) == map.end())\\n                         map[n] = make_pair(i, i+k);\\n                }\\n            }\\n        }\\n        vector<vector<int>> ret;\\n        ret.clear();\\n        for(auto q: queries)\\n        {\\n            vector<int> tmp(2);\\n            int val = q[0] ^ q[1];\\n            if(map.find(val) == map.end())\\n            {\\n                tmp[0] = -1;\\n                tmp[1] = -1;\\n            }\\n            else\\n            {\\n                tmp[0] = map[val].first;\\n                tmp[1] = map[val].second;\\n            }\\n            ret.push_back(tmp);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177100,
                "title": "c-map-precomputation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> res;\\n        map<long long,pair<int,int>>m;\\n        for(int i=0;i<s.size();i++){\\n            long long x=1;\\n            long long ans=0;\\n            for(int j=0;j<60;j++){\\n                if(i+j>=s.size()) continue;\\n                if(s[i+j]!=\\'0\\') ans++;\\n                x*=2;\\n                if(m.count(ans)==0) m[ans]={i,i+j};\\n                else{\\n                    if(m[ans].second-m[ans].first>j) m[ans]={i,i+j};\\n                }\\n                ans*=2;\\n            }\\n        }\\n        int n=queries.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            long long left=queries[i][0];\\n            long long right=queries[i][1];\\n            long long val= (right ^ left);\\n            if(m.count(val)!=0)\\n            res.push_back({m[val].first,m[val].second});\\n            else\\n                res.push_back({-1,-1});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> res;\\n        map<long long,pair<int,int>>m;\\n        for(int i=0;i<s.size();i++){\\n            long long x=1;\\n            long long ans=0;\\n            for(int j=0;j<60;j++){\\n                if(i+j>=s.size()) continue;\\n                if(s[i+j]!=\\'0\\') ans++;\\n                x*=2;\\n                if(m.count(ans)==0) m[ans]={i,i+j};\\n                else{\\n                    if(m[ans].second-m[ans].first>j) m[ans]={i,i+j};\\n                }\\n                ans*=2;\\n            }\\n        }\\n        int n=queries.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            long long left=queries[i][0];\\n            long long right=queries[i][1];\\n            long long val= (right ^ left);\\n            if(m.count(val)!=0)\\n            res.push_back({m[val].first,m[val].second});\\n            else\\n                res.push_back({-1,-1});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176938,
                "title": "c-simple-pre-compute-all-possible-decimal-value-and-store-in-a-map-0-n-32-m",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        unordered_map<long long, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++){\\n            long long curr = 0;\\n            for(int j = 0; j < min(32, n - i); j++){\\n                curr *= 2;\\n                curr += (s[i + j] - \\'0\\');\\n                if(mp.find(curr) == mp.end()){\\n                    mp[curr] = {i, i + j};\\n                }\\n                else if(j < mp[curr][1] - mp[curr][0]) mp[curr] = {i, i + j};\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto query : queries){\\n            int key = query[0] ^ query[1];\\n            if(mp.find(key) != mp.end()){\\n                ans.push_back(mp[key]);\\n            }\\n            else ans.push_back({-1, -1});\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        unordered_map<long long, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++){\\n            long long curr = 0;\\n            for(int j = 0; j < min(32, n - i); j++){\\n                curr *= 2;\\n                curr += (s[i + j] - \\'0\\');\\n                if(mp.find(curr) == mp.end()){\\n                    mp[curr] = {i, i + j}",
                "codeTag": "Java"
            },
            {
                "id": 3176899,
                "title": "1sentence-val-first-second-val-first-second-use-trie-to-match-first-second",
                "content": "# Code\\n```\\nclass Node:\\n    def __init__(self):\\n        self.leafOf = []\\n        self.left, self.right = None, None\\n\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        toFind = [format(first ^ second, \\'b\\') for first, second in queries]\\n        root = Node()\\n        for i, vir in enumerate(toFind):\\n            cur = root\\n            for c in vir:\\n                if c == \\'0\\':\\n                    if cur.left == None:\\n                        cur.left = Node()\\n                    cur = cur.left\\n                else:\\n                    if cur.right == None:\\n                        cur.right = Node()\\n                    cur = cur.right\\n            cur.leafOf.append(i)\\n        ret = [[-1, -1] for _ in range(len(toFind))]\\n        iterators = []\\n        for i, c in enumerate(s):\\n            newIterators = []\\n            iterators.append((i, root))\\n            for start, pos in iterators:\\n                if c == \\'0\\' and pos.left:\\n                    pos = pos.left\\n                elif c == \\'1\\' and pos.right:\\n                    pos = pos.right\\n                else:\\n                    continue\\n                newIterators.append((start, pos))\\n                for leaf in pos.leafOf:\\n                    if ret[leaf][0] == -1:\\n                        ret[leaf] = [start, i]\\n            iterators = newIterators\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.leafOf = []\\n        self.left, self.right = None, None\\n\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        toFind = [format(first ^ second, \\'b\\') for first, second in queries]\\n        root = Node()\\n        for i, vir in enumerate(toFind):\\n            cur = root\\n            for c in vir:\\n                if c == \\'0\\':\\n                    if cur.left == None:\\n                        cur.left = Node()\\n                    cur = cur.left\\n                else:\\n                    if cur.right == None:\\n                        cur.right = Node()\\n                    cur = cur.right\\n            cur.leafOf.append(i)\\n        ret = [[-1, -1] for _ in range(len(toFind))]\\n        iterators = []\\n        for i, c in enumerate(s):\\n            newIterators = []\\n            iterators.append((i, root))\\n            for start, pos in iterators:\\n                if c == \\'0\\' and pos.left:\\n                    pos = pos.left\\n                elif c == \\'1\\' and pos.right:\\n                    pos = pos.right\\n                else:\\n                    continue\\n                newIterators.append((start, pos))\\n                for leaf in pos.leafOf:\\n                    if ret[leaf][0] == -1:\\n                        ret[leaf] = [start, i]\\n            iterators = newIterators\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176821,
                "title": "rust-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) Scan from left to the right, find the first 32 bit number.\\n2) For non-zero number, only start with digit 1. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn substring_xor_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let n = s.len();\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut mp = HashMap::<i32, (i32, i32)>::new();\\n        \\n        for i in 0 .. n {\\n            let mut val = 0;\\n            for j in 0 .. 32 {\\n                if j + i == n { break }\\n                if j > 0 && s[i] == \\'0\\' { break }\\n                \\n                val = 2 * val + (s[i + j] as u8 - \\'0\\' as u8) as i32;\\n                if mp.contains_key(&val) { continue }\\n                \\n                mp.insert(val, (i as i32, i as i32 + j as i32));\\n            }\\n        }\\n        \\n        let m = queries.len();\\n        let mut ret = vec![vec![-1, -1]; m];\\n        \\n        for i in 0 .. m {\\n            if let Some(p) = mp.get(&(queries[i][0] ^ queries[i][1])) { ret[i] = vec![p.0, p.1]; }\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn substring_xor_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let n = s.len();\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut mp = HashMap::<i32, (i32, i32)>::new();\\n        \\n        for i in 0 .. n {\\n            let mut val = 0;\\n            for j in 0 .. 32 {\\n                if j + i == n { break }\\n                if j > 0 && s[i] == \\'0\\' { break }\\n                \\n                val = 2 * val + (s[i + j] as u8 - \\'0\\' as u8) as i32;\\n                if mp.contains_key(&val) { continue }\\n                \\n                mp.insert(val, (i as i32, i as i32 + j as i32));\\n            }\\n        }\\n        \\n        let m = queries.len();\\n        let mut ret = vec![vec![-1, -1]; m];\\n        \\n        for i in 0 .. m {\\n            if let Some(p) = mp.get(&(queries[i][0] ^ queries[i][1])) { ret[i] = vec![p.0, p.1]; }\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3176530,
                "title": "swift-solution-using-dictionary-o-n-min-n-32-on-32bit-int",
                "content": "# Code\\n```\\nclass Solution {\\n    func substringXorQueries(_ s: String, _ queries: [[Int]]) -> [[Int]] {\\n        var map: [Int: [Int]] = [:]\\n        let s = Array(s)\\n\\n        for i in 0..<s.count {\\n            if s[i] == \"0\" {\\n                if map[0] == nil {\\n                    map[0] = [i, i]\\n                }\\n                continue\\n            }\\n\\n            var num = 0\\n\\n            for j in i..<min(s.count, i + 32) {\\n                num = num << 1\\n                num += s[j] == \"1\" ? 1 : 0\\n                if map[num] == nil {\\n                    map[num] = [i, j]\\n                }\\n            }\\n        }\\n\\n        var res: [[Int]] = []\\n\\n        for query in queries {\\n            res.append(map[query[0] ^ query[1], default: [-1, -1]])\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func substringXorQueries(_ s: String, _ queries: [[Int]]) -> [[Int]] {\\n        var map: [Int: [Int]] = [:]\\n        let s = Array(s)\\n\\n        for i in 0..<s.count {\\n            if s[i] == \"0\" {\\n                if map[0] == nil {\\n                    map[0] = [i, i]\\n                }\\n                continue\\n            }\\n\\n            var num = 0\\n\\n            for j in i..<min(s.count, i + 32) {\\n                num = num << 1\\n                num += s[j] == \"1\" ? 1 : 0\\n                if map[num] == nil {\\n                    map[num] = [i, j]\\n                }\\n            }\\n        }\\n\\n        var res: [[Int]] = []\\n\\n        for query in queries {\\n            res.append(map[query[0] ^ query[1], default: [-1, -1]])\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176385,
                "title": "short-crisp-most-easy-c-solution-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string decToBinary(int n)\\n{\\n    string bin;\\n \\n    int i = 0;\\n    while (n > 0) {\\n \\n        bin+=to_string(n % 2);\\n        n = n / 2;\\n    }\\n        if(bin.size()==0)\\n            bin.push_back(\\'0\\');\\n    return bin;\\n}\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n       map<string,pair<int,int>>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            string str;\\n            for(int j=i;j<min(i+30,n);j++)\\n            {\\n                str+=s[j];\\n                if(mp.find(str)==mp.end())\\n                {\\n                     mp[str]={i,j};\\n                }\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int xored=queries[i][0]^queries[i][1];\\n            string val=decToBinary(xored);\\n            reverse(val.begin(),val.end());\\n            if(mp.find(val)!=mp.end())\\n            {\\n                ans.push_back({mp[val].first,mp[val].second});\\n            }\\n            else\\n            {\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decToBinary(int n)\\n{\\n    string bin;\\n \\n    int i = 0;\\n    while (n > 0) {\\n \\n        bin+=to_string(n % 2);\\n        n = n / 2;\\n    }\\n        if(bin.size()==0)\\n            bin.push_back(\\'0\\');\\n    return bin;\\n}\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n       map<string,pair<int,int>>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            string str;\\n            for(int j=i;j<min(i+30,n);j++)\\n            {\\n                str+=s[j];\\n                if(mp.find(str)==mp.end())\\n                {\\n                     mp[str]={i,j};\\n                }\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int xored=queries[i][0]^queries[i][1];\\n            string val=decToBinary(xored);\\n            reverse(val.begin(),val.end());\\n            if(mp.find(val)!=mp.end())\\n            {\\n                ans.push_back({mp[val].first,mp[val].second});\\n            }\\n            else\\n            {\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176190,
                "title": "o-n-32-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = s.size();\\n        for(int i=0 ;i<n ;i++){\\n            if(s[i]==\\'0\\'){ \\n                mp[s[i]-\\'0\\'] = {i,i};\\n                break;\\n            }\\n        }\\n        for(int i=0 ;i<n ;i++){\\n            if(s[i]==\\'1\\'){ \\n                mp[s[i]-\\'0\\'] = {i,i};\\n                break;\\n            }\\n        }\\n        for(int i=0 ;i<n ;i++){\\n            if(s[i]==\\'1\\')\\n            {   int k =0;\\n                int val = 1;\\n                for(int j=i+1 ;j<n && j<=31+i ;j++){\\n                    val = ((val<<1)+ ((s[j]==\\'1\\' && j!=i)?1:0)); //  1 0 0  \\n                    k++;\\n                    if(mp.find(val)== mp.end()) mp[val] = {i,j};\\n                    \\n                }   \\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto it :queries){\\n            int xorval = it[0]^it[1];\\n            if(mp.find(xorval)!=mp.end()) ans.push_back({mp[xorval]});\\n            else ans.push_back({-1,-1});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nTC : O(n*32) \\n// n for traversing to entire array and 32 is for internal traversing through substring up constant length of 32 \\n// pls up vote if u like solution any doubts pls comment it out ill reach u ....\\nSC: O(n)\\n// For using hashmap to store the value of all subarray xor\\'s",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = s.size();\\n        for(int i=0 ;i<n ;i++){\\n            if(s[i]==\\'0\\'){ \\n                mp[s[i]-\\'0\\'] = {i,i};\\n                break;\\n            }\\n        }\\n        for(int i=0 ;i<n ;i++){\\n            if(s[i]==\\'1\\'){ \\n                mp[s[i]-\\'0\\'] = {i,i};\\n                break;\\n            }\\n        }\\n        for(int i=0 ;i<n ;i++){\\n            if(s[i]==\\'1\\')\\n            {   int k =0;\\n                int val = 1;\\n                for(int j=i+1 ;j<n && j<=31+i ;j++){\\n                    val = ((val<<1)+ ((s[j]==\\'1\\' && j!=i)?1:0)); //  1 0 0  \\n                    k++;\\n                    if(mp.find(val)== mp.end()) mp[val] = {i,j};\\n                    \\n                }   \\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto it :queries){\\n            int xorval = it[0]^it[1];\\n            if(mp.find(xorval)!=mp.end()) ans.push_back({mp[xorval]});\\n            else ans.push_back({-1,-1});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176112,
                "title": "go-python-o-32-n-time-o-32-n-space",
                "content": "# Complexity\\n- Time complexity: $$O(32*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(32*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc substringXorQueries(s string, queries [][]int) [][]int {\\n    substring := make(map[int64][]int)\\n    for l:=33; l>0; l--{\\n        for i:=len(s)-l;i>=0;i--{\\n            st := s[i:i+l]\\n            num, _ := strconv.ParseInt(st, 2, 64)\\n            substring[num] = []int{i, i+l-1}\\n        }\\n    }\\n    ans := make([][]int,len(queries))\\n    for i,q := range(queries){\\n        a := q[0]\\n        b := q[1]\\n        if value,ok := substring[int64(a^b)]; ok{\\n            ans[i] = value\\n        }else{\\n            ans[i] = []int{-1,-1}\\n        }\\n    }\\n    return ans\\n}\\n```\\n```python []\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        substring = defaultdict(lambda: [-1, -1])\\n        for l in range(33, 0, -1):\\n            for i in range(len(s)-l, -1, -1):\\n                substring[int(s[i:i+l], 2)] = [i, i+l-1]\\n        ans = []\\n        for a, b in queries:\\n            ans.append(substring[a^b])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Hash Table",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```golang []\\nfunc substringXorQueries(s string, queries [][]int) [][]int {\\n    substring := make(map[int64][]int)\\n    for l:=33; l>0; l--{\\n        for i:=len(s)-l;i>=0;i--{\\n            st := s[i:i+l]\\n            num, _ := strconv.ParseInt(st, 2, 64)\\n            substring[num] = []int{i, i+l-1}\\n        }\\n    }\\n    ans := make([][]int,len(queries))\\n    for i,q := range(queries){\\n        a := q[0]\\n        b := q[1]\\n        if value,ok := substring[int64(a^b)]; ok{\\n            ans[i] = value\\n        }else{\\n            ans[i] = []int{-1,-1}\\n        }\\n    }\\n    return ans\\n}\\n```\n```python []\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        substring = defaultdict(lambda: [-1, -1])\\n        for l in range(33, 0, -1):\\n            for i in range(len(s)-l, -1, -1):\\n                substring[int(s[i:i+l], 2)] = [i, i+l-1]\\n        ans = []\\n        for a, b in queries:\\n            ans.append(substring[a^b])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176020,
                "title": "cpp-solution-using-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<string,int>m;\\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\')\\n            {\\n                m[\"0\"]=i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\'){\\n                int n=s.size();\\n                int p=min(i+30,n);\\n                string t=\"\";\\n                for(int j=i;j<p;j++){\\n                    t+=s[j];\\n                    if(m.find(t)==m.end())m[t]=i;\\n                }\\n                \\n            }\\n        }\\n        \\n        for(auto ele:queries){\\n            int x=ele[0]^ele[1];\\n            \\n            string t=\"\";\\n            while(x){\\n                if(x%2!=0)t+=\\'1\\';\\n                else t+=\\'0\\';\\n                x=x>>1;\\n            }\\n            \\n            reverse(t.begin(),t.end());\\n            if(t.size()==0)t=\"0\";\\n            \\n            vector<int>v={-1,-1};\\n            if(m.find(t)!=m.end()){\\n                v[0]=m[t];\\n                v[1]=v[0]+t.size()-1;\\n            }\\n            \\n            ans.push_back(v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<string,int>m;\\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\')\\n            {\\n                m[\"0\"]=i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\'){\\n                int n=s.size();\\n                int p=min(i+30,n);\\n                string t=\"\";\\n                for(int j=i;j<p;j++){\\n                    t+=s[j];\\n                    if(m.find(t)==m.end())m[t]=i;\\n                }\\n                \\n            }\\n        }\\n        \\n        for(auto ele:queries){\\n            int x=ele[0]^ele[1];\\n            \\n            string t=\"\";\\n            while(x){\\n                if(x%2!=0)t+=\\'1\\';\\n                else t+=\\'0\\';\\n                x=x>>1;\\n            }\\n            \\n            reverse(t.begin(),t.end());\\n            if(t.size()==0)t=\"0\";\\n            \\n            vector<int>v={-1,-1};\\n            if(m.find(t)!=m.end()){\\n                v[0]=m[t];\\n                v[1]=v[0]+t.size()-1;\\n            }\\n            \\n            ans.push_back(v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176004,
                "title": "c-trie-solution-o-32-n",
                "content": "```\\nclass trie{\\npublic:\\n    vector<trie*> nums;\\n    pair<int,int> p;\\n    vector<int> mp;\\n    trie(){ nums = {NULL,NULL}; p = {-1,-1}; }\\n    void insert(int n,int i){\\n        trie* root = this;\\n        int l = n?log2(n)+1:1;\\n        for(int i = 0; i<l;++i){\\n            int k = bool(n&(1<<i));\\n            if(root->nums[k]!=NULL) root = root->nums[k];\\n            else root = (root->nums[k] = new trie());\\n        }\\n        root->mp.push_back(i);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void dfs(trie* root,vector<vector<int>>& re){\\n        if(root->mp.size()){\\n            for(int i = 0; i<root->mp.size();++i) re[root->mp[i]] = {root->p.first,root->p.second};\\n        }\\n        if(root->nums[0]) dfs(root->nums[0],re);\\n        if(root->nums[1]) dfs(root->nums[1],re);\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        trie* root = new trie();\\n        vector<vector<int>> re(q.size());\\n        for(int i = 0; i<q.size();++i) root->insert((q[i][0]^q[i][1]),i);\\n        for(int i = s.size()-1; i>=0;--i){\\n            trie* temp = root;\\n            for(int j = i; j>=0 && j>=i-31;--j){\\n                int k = s[j]-\\'0\\';\\n                if(temp->nums[k]==NULL) break;\\n                temp = temp->nums[k];\\n                if(temp->mp.size()){\\n                    if(temp->p.first == -1) temp->p = {j,i};\\n                    else{\\n                        if(temp->p.second - temp->p.first >= i-j) temp->p = {j,i};\\n                    }\\n                }\\n            }\\n        }\\n        dfs(root,re);\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass trie{\\npublic:\\n    vector<trie*> nums;\\n    pair<int,int> p;\\n    vector<int> mp;\\n    trie(){ nums = {NULL,NULL}; p = {-1,-1}; }\\n    void insert(int n,int i){\\n        trie* root = this;\\n        int l = n?log2(n)+1:1;\\n        for(int i = 0; i<l;++i){\\n            int k = bool(n&(1<<i));\\n            if(root->nums[k]!=NULL) root = root->nums[k];\\n            else root = (root->nums[k] = new trie());\\n        }\\n        root->mp.push_back(i);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void dfs(trie* root,vector<vector<int>>& re){\\n        if(root->mp.size()){\\n            for(int i = 0; i<root->mp.size();++i) re[root->mp[i]] = {root->p.first,root->p.second};\\n        }\\n        if(root->nums[0]) dfs(root->nums[0],re);\\n        if(root->nums[1]) dfs(root->nums[1],re);\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        trie* root = new trie();\\n        vector<vector<int>> re(q.size());\\n        for(int i = 0; i<q.size();++i) root->insert((q[i][0]^q[i][1]),i);\\n        for(int i = s.size()-1; i>=0;--i){\\n            trie* temp = root;\\n            for(int j = i; j>=0 && j>=i-31;--j){\\n                int k = s[j]-\\'0\\';\\n                if(temp->nums[k]==NULL) break;\\n                temp = temp->nums[k];\\n                if(temp->mp.size()){\\n                    if(temp->p.first == -1) temp->p = {j,i};\\n                    else{\\n                        if(temp->p.second - temp->p.first >= i-j) temp->p = {j,i};\\n                    }\\n                }\\n            }\\n        }\\n        dfs(root,re);\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175870,
                "title": "intutive-solution-o-32-n-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere we first find all substrings so that we can find if that string is thier or not by map data structure her if u have to notice that only length of 32 substrings are enough to be iterated since 10^9 can have 32 bits max so get all substrings at O(length of string * 32) time now use formula a^b=c as b=a^c\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnow calculate for each queries the a^x=b the x value is x=b^a\\nnow convert x in binary string format ie(0\\'s and 1\\'s)\\nand check if map contains that string if it contains get its first and last indexes that we precomputed in map<string ,pair<int,int>>\\nif it is not their push {-1,-1} to vector\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(string length*32+(q))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<string,pair<int,int>>m1;\\n        unordered_map<string,long long int>m2;\\n        for(int i=0;i<s.length();i++){\\n            string h=\"\";\\n            // h+=s[i];\\n            for(int j=i;j<s.length() && j-i+1<=32;j++){\\n                h+=s[j];\\n                if(h==\"0\" && j==i+1)break;\\n                \\n                if(m2[h]==0){\\n                    m1[h]={i,j};\\n                    m2[h]++;\\n                }\\n            }\\n            \\n        }\\n        vector<vector<int>>ans;\\n        for(auto it:queries){\\n            long long int x=(it[0]^it[1]);\\n            string h1=\"\";\\n            if(x==0)h1+=\\'0\\';\\n            while(x){\\n                if(x&1){\\n                    h1+=\\'1\\';\\n                }\\n                else{\\n                    h1+=\\'0\\';\\n                }\\n                x=(x>>1);\\n            }\\n            reverse(h1.begin(),h1.end());\\n            if(m2[h1]!=0){\\n                vector<int>y;\\n                y.push_back(m1[h1].first);\\n                y.push_back(m1[h1].second);\\n                ans.push_back(y);\\n            }\\n            else{\\n                 ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<string,pair<int,int>>m1;\\n        unordered_map<string,long long int>m2;\\n        for(int i=0;i<s.length();i++){\\n            string h=\"\";\\n            // h+=s[i];\\n            for(int j=i;j<s.length() && j-i+1<=32;j++){\\n                h+=s[j];\\n                if(h==\"0\" && j==i+1)break;\\n                \\n                if(m2[h]==0){\\n                    m1[h]={i,j};\\n                    m2[h]++;\\n                }\\n            }\\n            \\n        }\\n        vector<vector<int>>ans;\\n        for(auto it:queries){\\n            long long int x=(it[0]^it[1]);\\n            string h1=\"\";\\n            if(x==0)h1+=\\'0\\';\\n            while(x){\\n                if(x&1){\\n                    h1+=\\'1\\';\\n                }\\n                else{\\n                    h1+=\\'0\\';\\n                }\\n                x=(x>>1);\\n            }\\n            reverse(h1.begin(),h1.end());\\n            if(m2[h1]!=0){\\n                vector<int>y;\\n                y.push_back(m1[h1].first);\\n                y.push_back(m1[h1].second);\\n                ans.push_back(y);\\n            }\\n            else{\\n                 ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175759,
                "title": "hashmap-bitmanipulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>>ans;\\n        int n=s.length();\\n         \\n        map<int,unordered_set<int>>mp;\\n        \\n        vector<vector<int>>pre(31,vector<int>(n));\\n        // precomputation of decimal values of each length of window\\n        \\n        for(int l=1;l<=30;l++){// length of the sliding window\\n            if(l>n)break;\\n            int init=0,p=0;\\n            for(int i=n-1;i>=(n-l);i--){\\n                if(s[i]==\\'1\\')init+=(1<<p);\\n                p++;\\n            }\\n            pre[l][n-l]=init;\\n            mp[l].insert(init);\\n            for(int i=n-2;i>=(l-1);i--){\\n                if(s[i+1]==\\'1\\')init--;\\n                init/=2;\\n                if(s[i-l+1]==\\'1\\')init+=(1<<(l-1));\\n                pre[l][i-l+1]=init;\\n                mp[l].insert(init);\\n            }\\n        }\\n        \\n  \\n        for(auto &it:queries){\\n            int f=it[0],s=it[1];\\n            bool ok=false;\\n           int x=f^s;\\n            int l=1;\\n            for(l=1;l<=30;l++){\\n                if(mp[l].find(x)!=mp[l].end()){\\n                    break;\\n                }\\n            }\\n            if(l>30){\\n                ans.push_back({-1,-1});\\n            }\\n            else{\\n                for(int i=0;i<=n-l;i++){\\n                    if(pre[l][i]==x){\\n                        ans.push_back({i,i+l-1});\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>>ans;\\n        int n=s.length();\\n         \\n        map<int,unordered_set<int>>mp;\\n        \\n        vector<vector<int>>pre(31,vector<int>(n));\\n        // precomputation of decimal values of each length of window\\n        \\n        for(int l=1;l<=30;l++){// length of the sliding window\\n            if(l>n)break;\\n            int init=0,p=0;\\n            for(int i=n-1;i>=(n-l);i--){\\n                if(s[i]==\\'1\\')init+=(1<<p);\\n                p++;\\n            }\\n            pre[l][n-l]=init;\\n            mp[l].insert(init);\\n            for(int i=n-2;i>=(l-1);i--){\\n                if(s[i+1]==\\'1\\')init--;\\n                init/=2;\\n                if(s[i-l+1]==\\'1\\')init+=(1<<(l-1));\\n                pre[l][i-l+1]=init;\\n                mp[l].insert(init);\\n            }\\n        }\\n        \\n  \\n        for(auto &it:queries){\\n            int f=it[0],s=it[1];\\n            bool ok=false;\\n           int x=f^s;\\n            int l=1;\\n            for(l=1;l<=30;l++){\\n                if(mp[l].find(x)!=mp[l].end()){\\n                    break;\\n                }\\n            }\\n            if(l>30){\\n                ans.push_back({-1,-1});\\n            }\\n            else{\\n                for(int i=0;i<=n-l;i++){\\n                    if(pre[l][i]==x){\\n                        ans.push_back({i,i+l-1});\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175729,
                "title": "easiest-python-solution-using-sliding-window-of-size-1-to-32",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrecomputation of value for every window (substring) of size 1 <= window <= 32.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst store all the values which can exist staring from window of size 1 to 32, because we know that bitwise xor is associative in natue means, first ^ value = second is also same as first ^ second = value is also same as second ^ value = first. Using this approach we will find all values by sliding a window of size 1 to 32 over string and store the values. Later on we can find that whatever the postion of rsb (right most set bit in first or second can be the window size and we can grab value from precomputated array).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*32)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries):\\n        pre = [{} for i in range(32)]\\n        ans = []\\n        for i in range(32):\\n            start = 0\\n            end = i\\n            val = 0\\n            pos = i\\n            if len(s) < i+1:break\\n            for b in range(start, end + 1):\\n                bt = ord(s[b]) - ord(\\'0\\')\\n                val |= (bt << pos)\\n                pos -= 1\\n\\n            while end < len(s):\\n                if val not in pre[i]:\\n                    pre[i][val] = [start, end]\\n                val <<= 1\\n                if s[start] == \\'1\\':\\n                    val ^= (1 << i+1)\\n\\n                start += 1\\n                end += 1\\n                if end == len(s):\\n                    break\\n\\n                val |= ord(s[end]) - ord(\\'0\\')\\n\\n        for q in queries:\\n            first = q[0]\\n            second = q[1]\\n            pos = 1\\n            for i in range(32):\\n                if first & (1 << i) != second & (1 << i):\\n                    pos = i + 1\\n\\n            if len(s) < pos:\\n                ans.append([-1, -1])\\n\\n            else:\\n                val = first ^ second\\n                if val in pre[pos - 1]:\\n                    ans.append(pre[pos - 1][val])\\n                else:\\n                    ans.append([-1, -1])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries):\\n        pre = [{} for i in range(32)]\\n        ans = []\\n        for i in range(32):\\n            start = 0\\n            end = i\\n            val = 0\\n            pos = i\\n            if len(s) < i+1:break\\n            for b in range(start, end + 1):\\n                bt = ord(s[b]) - ord(\\'0\\')\\n                val |= (bt << pos)\\n                pos -= 1\\n\\n            while end < len(s):\\n                if val not in pre[i]:\\n                    pre[i][val] = [start, end]\\n                val <<= 1\\n                if s[start] == \\'1\\':\\n                    val ^= (1 << i+1)\\n\\n                start += 1\\n                end += 1\\n                if end == len(s):\\n                    break\\n\\n                val |= ord(s[end]) - ord(\\'0\\')\\n\\n        for q in queries:\\n            first = q[0]\\n            second = q[1]\\n            pos = 1\\n            for i in range(32):\\n                if first & (1 << i) != second & (1 << i):\\n                    pos = i + 1\\n\\n            if len(s) < pos:\\n                ans.append([-1, -1])\\n\\n            else:\\n                val = first ^ second\\n                if val in pre[pos - 1]:\\n                    ans.append(pre[pos - 1][val])\\n                else:\\n                    ans.append([-1, -1])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175705,
                "title": "unordered-map-bitwise-simple",
                "content": "# Intuition\\n10^9 contraints, so it is nearly 30 bits. Think ok bitwise.\\nif a^b=1, a^1=b. property\\n\\n# Approach\\ngenerate all values for x for all queries and then check if the value is present in the map\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        int mx=INT_MIN;\\n        for(auto q:queries)\\n        {\\n            string s=\"\";\\n            int a=q[0];\\n            int b=q[1];\\n            int ans=a^b;\\n            temp.push_back(ans);\\n        }\\n        int n=s.length();\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<=n;j++)\\n            {\\n                if(j-i>30)break;\\n                int c=stol(s.substr(i,j-i),0,2);\\n                if(mp.find(c)!=mp.end())\\n                {\\n                    if((mp[c][1]-mp[c][0])<=(j-1-i))\\n                    {\\n                      continue;  \\n                    }\\n                }\\n                mp[c]={i,j-1};\\n            }\\n        }\\n        for(auto i:temp)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                ans.push_back(mp[i]);\\n            }else{\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        int mx=INT_MIN;\\n        for(auto q:queries)\\n        {\\n            string s=\"\";\\n            int a=q[0];\\n            int b=q[1];\\n            int ans=a^b;\\n            temp.push_back(ans);\\n        }\\n        int n=s.length();\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<=n;j++)\\n            {\\n                if(j-i>30)break;\\n                int c=stol(s.substr(i,j-i),0,2);\\n                if(mp.find(c)!=mp.end())\\n                {\\n                    if((mp[c][1]-mp[c][0])<=(j-1-i))\\n                    {\\n                      continue;  \\n                    }\\n                }\\n                mp[c]={i,j-1};\\n            }\\n        }\\n        for(auto i:temp)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                ans.push_back(mp[i]);\\n            }else{\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175697,
                "title": "dictionary-intuition",
                "content": "# Intuition\\n\\nTaking into consideration that `a xor b = c` and `c xor b = a` we can rephrase a description: for given pair `[a, b]` find `c` among all substring of `s` that `a xor b = c`.\\n\\n# Approach\\n\\n1. Int consists of 32 bits. So, need to find all possible substrings of `s` with a length equal to or less than 32. I used a dictionary for that and stored substring indexes as a dictionary value.\\n2. Find all possible substring using two loops. There is also can be substrings with leading zeros like `00101`, they should be replaced with shortest values like `101`.\\n3. Now we can go through all `[a, b]` pairs, calculate `c`, and check the dictionary.\\n\\n# Complexity\\n- Time complexity: $$O(32*n + m)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, qs: List[List[int]]) -> List[List[int]]:\\n        d, n = dict(), len(s)\\n        for i in range(n):\\n            for j in range(i, min(i+32, n)):\\n                key = int(s[i:j+1], 2)\\n                if key not in d:\\n                    d[key] = [i, j]\\n                else:\\n                    ex = d[key]\\n                    if ex[0] > i or j-i < ex[1]-ex[0]:\\n                        d[key] = [i, j]\\n        result = []\\n        for i in range(len(qs)):\\n            key = qs[i][0] ^ qs[i][1]\\n            if key in d:\\n                result.append(d[key])\\n            else:\\n                result.append([-1, -1])\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, qs: List[List[int]]) -> List[List[int]]:\\n        d, n = dict(), len(s)\\n        for i in range(n):\\n            for j in range(i, min(i+32, n)):\\n                key = int(s[i:j+1], 2)\\n                if key not in d:\\n                    d[key] = [i, j]\\n                else:\\n                    ex = d[key]\\n                    if ex[0] > i or j-i < ex[1]-ex[0]:\\n                        d[key] = [i, j]\\n        result = []\\n        for i in range(len(qs)):\\n            key = qs[i][0] ^ qs[i][1]\\n            if key in d:\\n                result.append(d[key])\\n            else:\\n                result.append([-1, -1])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175316,
                "title": "can-anyone-help-passing-only-55-test-cases-out-of-59",
                "content": "class Solution {\\npublic:\\n    string func(int n)\\n    {\\n        string s = \"\";\\n        while(n>0){\\n            if(n%2)\\n                s = \\'1\\'+s;\\n            else\\n                s = \\'0\\'+s;\\n            n = n>>1;\\n        }\\n        return s;\\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) \\n    {\\n        vector<vector<int>>arr;\\n        for(int i=0;i<q.size();i++){\\n            int l = q[i][0];\\n            int r = q[i][1];\\n            int t = l ^ r;\\n            string goal = func(t);\\n            int x = goal.size();\\n            if(goal.size() == 0)\\n            {\\n                goal = \"0\";\\n                x += 1;\\n            }\\n            size_t found = s.find(goal);\\n            if (found != string::npos){\\n                int l = found-0;\\n                arr.push_back({l,l+x-1});\\n            }\\n            else{\\n                arr.push_back({-1,-1});\\n            }\\n        }\\n        return arr;\\n    }\\n\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    string func(int n)\\n    {\\n        string s = \"\";\\n        while(n>0){\\n            if(n%2)\\n                s = \\'1\\'+s;\\n            else\\n                s = \\'0\\'+s;\\n            n = n>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3175311,
                "title": "o-32-n-solution",
                "content": "# Intuition\\nYour result for the COR can\\'t be greater than 2e31;\\n\\n# Approach\\nmap[\"0\"] = to the leftmost \"0\" substring you find\\n\\nfor rest indices of our`string s` indices we will go upto 31 characters ahead if possible to look for every possible substring starting from current index.\\nJust for sake of understanding you can try uncommenting line \\n`   // cout<<t<<\\' \\'<<i<<\\' \\'<<i+cnt<<endl;`\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(32*n)\\n\\n- Space complexity:\\nO(32*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string help(int n){\\n        string res = \"\";\\n        if(n == 1)return \"1\";\\n        if(n==0)return \"0\";\\n        while(n>0){\\n            res = (n&1?\"1\":\"0\") + res;\\n            n/=2;\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>>ans;\\n        unordered_map<string,vector<int>>mp;\\n        for(int i = 0;i<s.length();i++){\\n            string t = \"\";\\n            if(s[i] == \\'0\\'){\\n                    if(mp[\"0\"].size()==0){\\n                        mp[\"0\"] = {i,i};\\n                    }\\n                    continue;\\n            }\\n            int cnt = 0;\\n            for(int j=i;cnt<32 && j<s.length();j++,++cnt){\\n                \\n                t += (s[j]);\\n                if(mp[t].size()==0){\\n                    mp[t] = {i,i+cnt};\\n                   // cout<<t<<\\' \\'<<i<<\\' \\'<<i+cnt<<endl;\\n                }\\n\\n                \\n            }\\n        }\\n        for(auto q:queries){\\n            int val = q[0]^q[1];\\n            string p = help(val);\\n            //cout<<p<<endl;\\n            if(mp[p].size()>0)\\n                ans.push_back(mp[p]);\\n            else\\n                ans.push_back({-1,-1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string help(int n){\\n        string res = \"\";\\n        if(n == 1)return \"1\";\\n        if(n==0)return \"0\";\\n        while(n>0){\\n            res = (n&1?\"1\":\"0\") + res;\\n            n/=2;\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>>ans;\\n        unordered_map<string,vector<int>>mp;\\n        for(int i = 0;i<s.length();i++){\\n            string t = \"\";\\n            if(s[i] == \\'0\\'){\\n                    if(mp[\"0\"].size()==0){\\n                        mp[\"0\"] = {i,i};\\n                    }\\n                    continue;\\n            }\\n            int cnt = 0;\\n            for(int j=i;cnt<32 && j<s.length();j++,++cnt){\\n                \\n                t += (s[j]);\\n                if(mp[t].size()==0){\\n                    mp[t] = {i,i+cnt};\\n                   // cout<<t<<\\' \\'<<i<<\\' \\'<<i+cnt<<endl;\\n                }\\n\\n                \\n            }\\n        }\\n        for(auto q:queries){\\n            int val = q[0]^q[1];\\n            string p = help(val);\\n            //cout<<p<<endl;\\n            if(mp[p].size()>0)\\n                ans.push_back(mp[p]);\\n            else\\n                ans.push_back({-1,-1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3175255,
                "title": "beginner-friendly-hashmap-bit-mainpulation",
                "content": "APPROACH: For a certian query(i) we need to find a subarray such that decimal val (VAL) of that subarray xor with first(i) equals to second(i).\\n   We know that VAL^first(i)=second(i) so VAL=first(i)^second(i)  by XOR property.\\n   So , we need to find substring with decimal value VAL.\\n   \\n   We can precompute all substring .It complexity will be n^2 .In addition to that 2^(1e4) will lead to overflow.So this thing will not work .But value of first(i) and second(i) are less than 1e9 and xor value will also be in this range .\\n   So we need to compute subtrings of length less than equals to 30.Its complexity will be O(30*n).\\n   For storing we can use a hash table and for the smallest starting range we can either use a set to store OR we can also compare the last stored result with the current one.\\n   \\n   ```\\n   class Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries)\\n    {\\n        vector<vector<int>>ans;\\n        int n=s.size();\\n        unordered_map<int,set<pair<int,int>>>mp;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int last=-1;\\n            int curr=0;\\n            for(int j=i;j>=0;j--)\\n            {\\n                if(i-j+1>30)           // substring size greater than 30 are not needed break \\n                    break;\\n                \\n               int val=1LL<<(i-j);\\n                curr+=(val*(s[j]-\\'0\\'));\\n                if(curr!=last)\\n                {\\n                    mp[curr].insert({j,i});           // insert the range in the set  of mp[curr]\\n                    last=curr;\\n                }\\n            }\\n        }\\n        \\n        for(auto it:queries)\\n        {\\n            int val=it[0]^it[1];                  // if the value does not exist in the map \\n            if(mp.find(val)==mp.end())\\n            {\\n                ans.push_back({-1,-1});\\n            }\\n            else           // pushback the first element of the set i.e mp[val].begin() => this is a pair\\n            {\\n                ans.push_back({mp[val].begin()->first,mp[val].begin()->second});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n   class Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries)\\n    {\\n        vector<vector<int>>ans;\\n        int n=s.size();\\n        unordered_map<int,set<pair<int,int>>>mp;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int last=-1;\\n            int curr=0;\\n            for(int j=i;j>=0;j--)\\n            {\\n                if(i-j+1>30)           // substring size greater than 30 are not needed break \\n                    break;\\n                \\n               int val=1LL<<(i-j);\\n                curr+=(val*(s[j]-\\'0\\'));\\n                if(curr!=last)\\n                {\\n                    mp[curr].insert({j,i});           // insert the range in the set  of mp[curr]\\n                    last=curr;\\n                }\\n            }\\n        }\\n        \\n        for(auto it:queries)\\n        {\\n            int val=it[0]^it[1];                  // if the value does not exist in the map \\n            if(mp.find(val)==mp.end())\\n            {\\n                ans.push_back({-1,-1});\\n            }\\n            else           // pushback the first element of the set i.e mp[val].begin() => this is a pair\\n            {\\n                ans.push_back({mp[val].begin()->first,mp[val].begin()->second});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175204,
                "title": "easy-code-python-string-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n\\n        # val ^ first = second\\n        # val ^ first ^ first = second ^ first\\n        # val = second ^ first \\n        # So we wl calculate val=second ^ first and then we wl find that substring in the given string using find method in python 3\\n        # find() -> returns -1 if substring is not found ,else return the index\\n\\n        res=[] #To store the answer\\n        for i in queries:\\n            val=bin(i[0]^i[1])[2:] # [2: ] bcz bin() return the binary vallue with 0b____\\n            if val in s:\\n                t=s.find(val)\\n                t1=t+len(val)-1\\n                res.append([t,t1])\\n            else:\\n                res.append([-1,-1])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n\\n        # val ^ first = second\\n        # val ^ first ^ first = second ^ first\\n        # val = second ^ first \\n        # So we wl calculate val=second ^ first and then we wl find that substring in the given string using find method in python 3\\n        # find() -> returns -1 if substring is not found ,else return the index\\n\\n        res=[] #To store the answer\\n        for i in queries:\\n            val=bin(i[0]^i[1])[2:] # [2: ] bcz bin() return the binary vallue with 0b____\\n            if val in s:\\n                t=s.find(val)\\n                t1=t+len(val)-1\\n                res.append([t,t1])\\n            else:\\n                res.append([-1,-1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175142,
                "title": "python-with-intuition-approach",
                "content": "# TLE version: Top-Down \\n\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n\\n        res = []\\n\\n        @lru_cache\\n        def match(s, match_str):\\n            # return idx\\n            ms = len(match_str)\\n\\n            index = s.find(match_str)\\n            if index>=0:\\n                return [index, index+ms-1]\\n            else:\\n                return [-1, -1]\\n\\n        for a, b in queries:\\n            c = a ^ b\\n            match_str = str(bin(c)[2:])\\n            ip = match(s, match_str)\\n            # print(match_str)\\n            res.append(ip)\\n\\n        return res\\n\\n```\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Intuition & Approach\\n\\nbecause the above code TLE\\nit is because we may need to match things larger than 2**32\\nthat is not required \\nfirst we need to look at the input range\\n\\nestimation\\n2^10 ~= 10^3\\n10^9 ~= 2^30\\nso the query number must under 32 bit, we can assume that we don\\'t care for the number larger then 2**32 \\n\\nwe know that \\na^b=c\\na^b^b = c^b\\n=> a = b^c\\nsince 0 <= firsti(a), secondi(b) <= 10**9\\nso c must be less than 2**32\\n\\nsince what we need to found in s is must less than 2**32\\nso rather than we top-down to memorize the input\\nwe can bottom up to consturct a hashmap\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*32)+O(Q)\\nN is the length of string\\n\\n- Space complexity:\\nO(N*32)\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n\\n        INT_MAX = 2**32\\n        dic = dict()\\n\\n        for i in range(len(s)):\\n            cur = 0\\n            for j in range(i+1, len(s)+1):\\n                # deal with leading zero\\n                if s[i] == \"0\":\\n                    if 0 not in dic:\\n                        dic[0] = [i, i]\\n                    break\\n                    # don\\'t need to care about leading zero\\n                val = int(s[i:j], 2)\\n                if val>INT_MAX:\\n                    break\\n                if val not in dic:\\n                    dic[val] = [i, j-1]\\n\\n        res = []\\n        for a, b in queries:\\n            c = a^b\\n            res.append(dic.get(c, [-1,-1]))\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n\\n        res = []\\n\\n        @lru_cache\\n        def match(s, match_str):\\n            # return idx\\n            ms = len(match_str)\\n\\n            index = s.find(match_str)\\n            if index>=0:\\n                return [index, index+ms-1]\\n            else:\\n                return [-1, -1]\\n\\n        for a, b in queries:\\n            c = a ^ b\\n            match_str = str(bin(c)[2:])\\n            ip = match(s, match_str)\\n            # print(match_str)\\n            res.append(ip)\\n\\n        return res\\n\\n```\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n\\n        INT_MAX = 2**32\\n        dic = dict()\\n\\n        for i in range(len(s)):\\n            cur = 0\\n            for j in range(i+1, len(s)+1):\\n                # deal with leading zero\\n                if s[i] == \"0\":\\n                    if 0 not in dic:\\n                        dic[0] = [i, i]\\n                    break\\n                    # don\\'t need to care about leading zero\\n                val = int(s[i:j], 2)\\n                if val>INT_MAX:\\n                    break\\n                if val not in dic:\\n                    dic[val] = [i, j-1]\\n\\n        res = []\\n        for a, b in queries:\\n            c = a^b\\n            res.append(dic.get(c, [-1,-1]))\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175064,
                "title": "java-hashmap-o-32-n-30ms-beats-100",
                "content": "# Approach\\nThe maximum length of the input string sss is 10^4 and we have 30 substrings to consider for every starting position in s. This gives us 3\\u22C510^5 potentially unique values, so we can put everything to a HashMap without causing TLE.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            if (s.charAt(i) == \\'0\\') {\\n                map.put(0, new int[]{i,1});\\n                continue;\\n            }\\n\\n            int limit = Math.min(i+30, s.length());\\n            int c = 0;\\n            \\n            for (int j = i; j < limit; j++) {\\n                c = c << 1;\\n                c = c | (s.charAt(j)-\\'0\\');\\n                map.put(c, new int[]{i, j-i+1});\\n            }\\n        }\\n\\n        int[][] res = new int[queries.length][2];\\n        \\n        for (int[] q : queries) {\\n            int search = q[0]^q[1];\\n            if (map.containsKey(search)) {\\n                q[0] = map.get(search)[0];\\n                q[1] = map.get(search)[0]+map.get(search)[1]-1;\\n            } else {\\n                q[0] = -1;\\n                q[1] = -1;\\n            }\\n        }\\n        \\n        return queries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            if (s.charAt(i) == \\'0\\') {\\n                map.put(0, new int[]{i,1});\\n                continue;\\n            }\\n\\n            int limit = Math.min(i+30, s.length());\\n            int c = 0;\\n            \\n            for (int j = i; j < limit; j++) {\\n                c = c << 1;\\n                c = c | (s.charAt(j)-\\'0\\');\\n                map.put(c, new int[]{i, j-i+1});\\n            }\\n        }\\n\\n        int[][] res = new int[queries.length][2];\\n        \\n        for (int[] q : queries) {\\n            int search = q[0]^q[1];\\n            if (map.containsKey(search)) {\\n                q[0] = map.get(search)[0];\\n                q[1] = map.get(search)[0]+map.get(search)[1]-1;\\n            } else {\\n                q[0] = -1;\\n                q[1] = -1;\\n            }\\n        }\\n        \\n        return queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175058,
                "title": "pre-process-substrings-unordered-map-c",
                "content": "# Intuition\\nLeetCode Hints\\n- You do not need to consider substrings having lengths greater than 30.\\n- Pre-process all substrings with lengths not greater than 30, and add the best endpoints to a dictionary.\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string toBinary(int n)\\n    {\\n        if(n==0) return \"0\";\\n        string ans=\"\";\\n        while(n!=0)\\n        {\\n            int d=n%2;\\n            ans=to_string(d)+ans;\\n            n/=2;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> ans;\\n        int q=queries.size();\\n        int n=s.size();\\n        unordered_map<string,int> m;\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int l=1; l<=30; l++)\\n            {\\n                string t=s.substr(x,l);\\n                if(m.find(t)==m.end()) m[t]=x;\\n            }\\n        }\\n        for(int x=0; x<q; x++)\\n        {\\n            int xo=queries[x][0]^queries[x][1];\\n            string bin=toBinary(xo);\\n            int b=bin.size();\\n            if(m.find(bin)!=m.end())\\n            {\\n                int p=m[bin];\\n                vector<int> v={p,p+b-1};\\n                ans.push_back(v);\\n            }\\n            else\\n            {\\n                vector<int> v={-1,-1};\\n                ans.push_back(v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string toBinary(int n)\\n    {\\n        if(n==0) return \"0\";\\n        string ans=\"\";\\n        while(n!=0)\\n        {\\n            int d=n%2;\\n            ans=to_string(d)+ans;\\n            n/=2;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> ans;\\n        int q=queries.size();\\n        int n=s.size();\\n        unordered_map<string,int> m;\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int l=1; l<=30; l++)\\n            {\\n                string t=s.substr(x,l);\\n                if(m.find(t)==m.end()) m[t]=x;\\n            }\\n        }\\n        for(int x=0; x<q; x++)\\n        {\\n            int xo=queries[x][0]^queries[x][1];\\n            string bin=toBinary(xo);\\n            int b=bin.size();\\n            if(m.find(bin)!=m.end())\\n            {\\n                int p=m[bin];\\n                vector<int> v={p,p+b-1};\\n                ans.push_back(v);\\n            }\\n            else\\n            {\\n                vector<int> v={-1,-1};\\n                ans.push_back(v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174997,
                "title": "c-beginner-friendly-hash-table-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int to_decimal(string s)\\n    {\\n        int ans=0;\\n        reverse(s.begin(),s.end());\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans+=pow(2,i)*(s[i]==\\'0\\'?0:1);\\n        }\\n        return ans;\\n            \\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \\n    {\\n        int k=1,n=s.size();\\n        unordered_map<int,pair<int,int>> mp;\\n        while(k<=30)\\n        {\\n            int i=0,j=k-1;\\n            while(j<n)\\n            {\\n                int x=to_decimal(s.substr(i,k));\\n                if(mp.find(x)==mp.end())\\n                {\\n                    mp[x]={i,j};\\n                }\\n                i++;\\n                j++;\\n            }\\n            k++;\\n            \\n        }\\n        vector<vector<int>> ans;\\n        for(auto &v:queries)\\n        {\\n            int x=v[0]^v[1];\\n            if(mp.find(x)!=mp.end())\\n            {\\n                ans.push_back({mp[x].first,mp[x].second});\\n            }\\n            else\\n            {\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int to_decimal(string s)\\n    {\\n        int ans=0;\\n        reverse(s.begin(),s.end());\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans+=pow(2,i)*(s[i]==\\'0\\'?0:1);\\n        }\\n        return ans;\\n            \\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \\n    {\\n        int k=1,n=s.size();\\n        unordered_map<int,pair<int,int>> mp;\\n        while(k<=30)\\n        {\\n            int i=0,j=k-1;\\n            while(j<n)\\n            {\\n                int x=to_decimal(s.substr(i,k));\\n                if(mp.find(x)==mp.end())\\n                {\\n                    mp[x]={i,j};\\n                }\\n                i++;\\n                j++;\\n            }\\n            k++;\\n            \\n        }\\n        vector<vector<int>> ans;\\n        for(auto &v:queries)\\n        {\\n            int x=v[0]^v[1];\\n            if(mp.find(x)!=mp.end())\\n            {\\n                ans.push_back({mp[x].first,mp[x].second});\\n            }\\n            else\\n            {\\n                ans.push_back({-1,-1});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174961,
                "title": "c-easy-to-understand-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccording to then question val^first=second\\nThis implies val^first^first=second^first\\nWe know x^x=0 and x^0=x (x^x cancels each other out)\\nSo we get val^(0)=second^first\\nval=second^first\\nWe need to find the substring with decimal val which makes second^first\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe store the value of second^first of all queries in a hashmap with their indices.\\nWe calculate the maximum possible length of any binary (ws)\\nwe make two for loops to iterate over all possibilities \\n`i->stating index`\\n`j->ending index`\\nwe skip all itereation where starting is from 0 to avoid the prefixes of 0\\nwe also break the 2nd loop of j when the current window size becomes greater than the maximum possible window size\\nSuppose we get the xor values in map as `2,9,0,4,15`\\nHere the largert number is 15 and its binary form has 4 digits so we need not check any substring with length greater than 4 because it will be greater than 15 and so its not in the map\\nNow we have to check for 0 and we have stored the first index of 0 in the variable `zero`.\\nif map has 0 then we put `ans[index]={zero,zero}`\\n# Complexity\\n- Time complexity:O(n^2+m) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=queries.size();\\n        vector<vector<int>>ans(n);\\n        //keep maxi to store the maximum xor value\\n        int maxi=0;\\n        //maps the xor values to the indices and then with these indices we put the {left,right} in ans[ind]\\n        unordered_map<int,vector<int>>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            int xori=queries[i][1]^queries[i][0];\\n            mp[xori].push_back(i);\\n            maxi=max(maxi,xori);\\n        }\\n\\n        //with the maximum  we calculate what can be the maximum window size for a substring\\n        ll ws=(1LL*log(maxi)/log(2))+1;\\n        //we also store the first zero\\'s index\\n        int zero=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            //we skip all binaries which have \\'0\\' in prefix(we are also skipping the bianry number 0 itself)\\n            if(s[i]==\\'0\\')\\n            {\\n                if(zero==-1)zero=i;\\n                continue;\\n            }\\n            \\n            long long num=0;\\n            for(int j=i;j<s.length();j++)\\n            {\\n                //break if the current window size is greater than the max possible\\n                if(j-i+1>ws)break;\\n                //shifting the number and adding the new s[j] to it\\n                num<<=1;\\n                num|=s[j]-\\'0\\';\\n                if(mp.find(num)!=mp.end())\\n                {\\n                    for(auto it:mp[num])\\n                    {\\n                        if(ans[it].empty())\\n                            ans[it]={i,j};\\n                    }\\n                }\\n                \\n            }\\n        }\\n        //in the case when map has 0 the first index of zero will be taken\\n        if(zero!=-1 and mp.find(0)!=mp.end())\\n        {\\n            for(int i:mp[0])\\n            {\\n                ans[i]={zero,zero};\\n            }\\n        }\\n        //make the rest empty spaces as {-1,-1}\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ans[i].empty())\\n            {\\n                ans[i]={-1,-1};\\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=queries.size();\\n        vector<vector<int>>ans(n);\\n        //keep maxi to store the maximum xor value\\n        int maxi=0;\\n        //maps the xor values to the indices and then with these indices we put the {left,right} in ans[ind]\\n        unordered_map<int,vector<int>>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            int xori=queries[i][1]^queries[i][0];\\n            mp[xori].push_back(i);\\n            maxi=max(maxi,xori);\\n        }\\n\\n        //with the maximum  we calculate what can be the maximum window size for a substring\\n        ll ws=(1LL*log(maxi)/log(2))+1;\\n        //we also store the first zero\\'s index\\n        int zero=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            //we skip all binaries which have \\'0\\' in prefix(we are also skipping the bianry number 0 itself)\\n            if(s[i]==\\'0\\')\\n            {\\n                if(zero==-1)zero=i;\\n                continue;\\n            }\\n            \\n            long long num=0;\\n            for(int j=i;j<s.length();j++)\\n            {\\n                //break if the current window size is greater than the max possible\\n                if(j-i+1>ws)break;\\n                //shifting the number and adding the new s[j] to it\\n                num<<=1;\\n                num|=s[j]-\\'0\\';\\n                if(mp.find(num)!=mp.end())\\n                {\\n                    for(auto it:mp[num])\\n                    {\\n                        if(ans[it].empty())\\n                            ans[it]={i,j};\\n                    }\\n                }\\n                \\n            }\\n        }\\n        //in the case when map has 0 the first index of zero will be taken\\n        if(zero!=-1 and mp.find(0)!=mp.end())\\n        {\\n            for(int i:mp[0])\\n            {\\n                ans[i]={zero,zero};\\n            }\\n        }\\n        //make the rest empty spaces as {-1,-1}\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ans[i].empty())\\n            {\\n                ans[i]={-1,-1};\\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174958,
                "title": "java-cache-query-integers-and-find-in-substring-splits",
                "content": "```\\n/*\\nexplanation: substring xor using string match algorithm! This program exploits the facts that for any three numbers a, b, c.. if a^b = c then a will be equal to b^c! Therefore we xor the first and second of query q to find the decimal number we need to look into string s, then converting this to string and finding index will give our first element!\\n\\ntestcase: \"101101\"\\n[[0,5],[1,2]] -> Works\\n\\nTime & Space Complexity: O(n^2) & O(n): Time and space complexity of this program is quadratic and linear respectivey! Since we iterate and try finding substring in string each time therefore time complexity is quadratic, also space complexity is linear due to storage space required!\\n*/\\nclass Solution {\\n    class E {\\n        int e;\\n        int qdx;\\n        \\n        E(int e, int qdx){\\n            this.e = e;\\n            this.qdx = qdx;\\n        }\\n    }\\n    \\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int[][] ans = new int[queries.length][2];\\n        for(int[] a : ans) Arrays.fill(a, -1);\\n        \\n        HashMap<Integer, List<E>> _contain_cache = new HashMap<>();\\n\\n        int z=0;\\n        int indexOf0 = s.indexOf(\"0\");\\n        for(int[] q:queries){\\n            int st = q[0];\\n            int ed = q[1];\\n            int dcm = st ^ ed;\\n            \\n            if(dcm == 0){\\n                // Special case :)\\n                ans[z++] = new int[]{indexOf0, indexOf0};\\n                continue;\\n            }\\n            \\n            List<E> arr = _contain_cache.getOrDefault(dcm, new ArrayList<E>());\\n            arr.add(new E(dcm, z++));\\n            _contain_cache.put(dcm, arr);\\n        }\\n        \\n        for(int i=0; i<s.length(); i++){\\n            StringBuilder str = new StringBuilder();\\n            if (s.charAt(i) == \\'0\\') continue;\\n            for(int j=i; j<s.length(); j++){\\n                // st += s.charAt(j);\\n                str.append(s.charAt(j));\\n                \\n                if (str.length() > Integer.toBinaryString(Integer.MAX_VALUE).length()) break;\\n\\n                int parse = Integer.parseInt(str.toString(), 2);\\n                List<E> arr = _contain_cache.getOrDefault(parse, new ArrayList<E>());\\n                for(E e : arr){\\n                    ans[e.qdx] = new int[]{i, j};\\n                }\\n                _contain_cache.remove(parse);\\n            }\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nexplanation: substring xor using string match algorithm! This program exploits the facts that for any three numbers a, b, c.. if a^b = c then a will be equal to b^c! Therefore we xor the first and second of query q to find the decimal number we need to look into string s, then converting this to string and finding index will give our first element!\\n\\ntestcase: \"101101\"\\n[[0,5],[1,2]] -> Works\\n\\nTime & Space Complexity: O(n^2) & O(n): Time and space complexity of this program is quadratic and linear respectivey! Since we iterate and try finding substring in string each time therefore time complexity is quadratic, also space complexity is linear due to storage space required!\\n*/\\nclass Solution {\\n    class E {\\n        int e;\\n        int qdx;\\n        \\n        E(int e, int qdx){\\n            this.e = e;\\n            this.qdx = qdx;\\n        }\\n    }\\n    \\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int[][] ans = new int[queries.length][2];\\n        for(int[] a : ans) Arrays.fill(a, -1);\\n        \\n        HashMap<Integer, List<E>> _contain_cache = new HashMap<>();\\n\\n        int z=0;\\n        int indexOf0 = s.indexOf(\"0\");\\n        for(int[] q:queries){\\n            int st = q[0];\\n            int ed = q[1];\\n            int dcm = st ^ ed;\\n            \\n            if(dcm == 0){\\n                // Special case :)\\n                ans[z++] = new int[]{indexOf0, indexOf0};\\n                continue;\\n            }\\n            \\n            List<E> arr = _contain_cache.getOrDefault(dcm, new ArrayList<E>());\\n            arr.add(new E(dcm, z++));\\n            _contain_cache.put(dcm, arr);\\n        }\\n        \\n        for(int i=0; i<s.length(); i++){\\n            StringBuilder str = new StringBuilder();\\n            if (s.charAt(i) == \\'0\\') continue;\\n            for(int j=i; j<s.length(); j++){\\n                // st += s.charAt(j);\\n                str.append(s.charAt(j));\\n                \\n                if (str.length() > Integer.toBinaryString(Integer.MAX_VALUE).length()) break;\\n\\n                int parse = Integer.parseInt(str.toString(), 2);\\n                List<E> arr = _contain_cache.getOrDefault(parse, new ArrayList<E>());\\n                for(E e : arr){\\n                    ans[e.qdx] = new int[]{i, j};\\n                }\\n                _contain_cache.remove(parse);\\n            }\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174943,
                "title": "easy-with-hashmap-o-32-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(32 * n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String str, int[][] queries) {\\n\\n        int [][] ans = new int[queries.length][2];\\n        \\n        int i = 0;\\n        Map<Integer, Integer> nums = new HashMap<>();\\n\\n        int num = 0;\\n\\n        // Generate all possible numbers <= 10^9. Only Store theier first index occurence\\n        //time complexity O(n * 32)\\n        for(i = 0; i < str.length(); i++){\\n\\n            StringBuilder sb = new StringBuilder();\\n            if(str.charAt(i) == \\'0\\'){\\n                if(!nums.containsKey(0))\\n                    nums.put(0, i);\\n                continue;\\n            } \\n            for(int j = i; j <= Math.min(i + 32 ,str.length()-1); j++){\\n                sb.append(str.charAt(j));\\n                int d = Integer.parseInt(sb.toString(), 2);\\n                if(d > 1000000001) break;\\n                if(!nums.containsKey(d))\\n                    nums.put(d, i);\\n            }\\n        }\\n        i = 0;\\n        for(int [] q : queries ){\\n\\n            int v =  q[0]^q[1];\\n            //inverse of XOR is XOR itself.\\n            // for any val^x = y  == val = x^y\\n            String bstr =  Integer.toBinaryString(v);\\n            //check if the given number exist in Map \\n            int c = nums.getOrDefault(v, -1);\\n            if(c == -1){\\n                ans[i] = new int[] {-1,-1};\\n            }else{\\n                ans[i] = new int[] {c,(c +  bstr.length()-1)};\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String str, int[][] queries) {\\n\\n        int [][] ans = new int[queries.length][2];\\n        \\n        int i = 0;\\n        Map<Integer, Integer> nums = new HashMap<>();\\n\\n        int num = 0;\\n\\n        // Generate all possible numbers <= 10^9. Only Store theier first index occurence\\n        //time complexity O(n * 32)\\n        for(i = 0; i < str.length(); i++){\\n\\n            StringBuilder sb = new StringBuilder();\\n            if(str.charAt(i) == \\'0\\'){\\n                if(!nums.containsKey(0))\\n                    nums.put(0, i);\\n                continue;\\n            } \\n            for(int j = i; j <= Math.min(i + 32 ,str.length()-1); j++){\\n                sb.append(str.charAt(j));\\n                int d = Integer.parseInt(sb.toString(), 2);\\n                if(d > 1000000001) break;\\n                if(!nums.containsKey(d))\\n                    nums.put(d, i);\\n            }\\n        }\\n        i = 0;\\n        for(int [] q : queries ){\\n\\n            int v =  q[0]^q[1];\\n            //inverse of XOR is XOR itself.\\n            // for any val^x = y  == val = x^y\\n            String bstr =  Integer.toBinaryString(v);\\n            //check if the given number exist in Map \\n            int c = nums.getOrDefault(v, -1);\\n            if(c == -1){\\n                ans[i] = new int[] {-1,-1};\\n            }else{\\n                ans[i] = new int[] {c,(c +  bstr.length()-1)};\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174897,
                "title": "c-o-32n-q-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each query `[first, second]`, we have to find the first appearance of the bit format of `first ^ second` since if `first ^ s == second`, then `first^first^s = 0^s = s = first^second`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBecause `first` and `second` are all within `10^9`, the maximal possible xor of them can only be as large as a 32-bit unsigned integer. The worst case to list all the possible substring is at most `32n`(when all digits are 1), which is tolerable.\\n\\nWe can memorize all the first appearance of all possible `length<=32` substring of the string `s` in a hash table. Note that we don\\'t have to memorize any substring with `length >= 2` if it starts with a `0`.  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(32n + q)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(32n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        // substring -> [start index, end index]\\n        unordered_map<unsigned, pair<int, int>> mp;\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'0\\') {\\n                if (!mp.count(0)) mp[0] = {i, i}; \\n            } else {\\n                unsigned cur = 0;\\n                for (int j = 0; j < 32 && i + j < n; ++j) {\\n                    cur = (cur << 1) | (s[i+j]-\\'0\\');\\n                    if (!mp.count(cur)) mp[cur] = {i, i+j};\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> res;\\n        for (auto & q: queries) {\\n            unsigned target = (unsigned)q[0]^(unsigned)q[1];\\n            if (!mp.count(target)) res.push_back({-1, -1});\\n            else {\\n                auto [start, end] = mp[target];\\n                res.push_back({start, end});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        // substring -> [start index, end index]\\n        unordered_map<unsigned, pair<int, int>> mp;\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'0\\') {\\n                if (!mp.count(0)) mp[0] = {i, i}; \\n            } else {\\n                unsigned cur = 0;\\n                for (int j = 0; j < 32 && i + j < n; ++j) {\\n                    cur = (cur << 1) | (s[i+j]-\\'0\\');\\n                    if (!mp.count(cur)) mp[cur] = {i, i+j};\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> res;\\n        for (auto & q: queries) {\\n            unsigned target = (unsigned)q[0]^(unsigned)q[1];\\n            if (!mp.count(target)) res.push_back({-1, -1});\\n            else {\\n                auto [start, end] = mp[target];\\n                res.push_back({start, end});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174894,
                "title": "c-unordered-map-and-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> mp;\\n    \\n    int getVal(string &s, int i, int j){\\n        int val = 0;\\n        for(int k=i; k<=j; ++k){\\n            int x = s[k]-\\'0\\';\\n            val = (val<<1);\\n            val = val|x;\\n        }\\n        return val;\\n    }\\n    \\n    void solve(string &s, int k, int n){\\n        for(int i=0; i+k-1<n; ++i){\\n            int val = getVal(s, i, i+k-1);\\n            if(mp.find(val) != mp.end() && mp[val][0] == -1){\\n                mp[val] = {i, i+k-1};\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        vector<vector<int>> res;\\n        vector<int> v;\\n        mp.clear();\\n        \\n        for(auto &e : queries){\\n            int x = e[0]^e[1];\\n            v.push_back(x);\\n            mp[x] = {-1, -1};\\n        }\\n        \\n        \\n        for(int k=1; k<=30; ++k){\\n            solve(s,k,n);\\n        }\\n        \\n        for(auto &q : v){\\n            res.push_back(mp[q]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> mp;\\n    \\n    int getVal(string &s, int i, int j){\\n        int val = 0;\\n        for(int k=i; k<=j; ++k){\\n            int x = s[k]-\\'0\\';\\n            val = (val<<1);\\n            val = val|x;\\n        }\\n        return val;\\n    }\\n    \\n    void solve(string &s, int k, int n){\\n        for(int i=0; i+k-1<n; ++i){\\n            int val = getVal(s, i, i+k-1);\\n            if(mp.find(val) != mp.end() && mp[val][0] == -1){\\n                mp[val] = {i, i+k-1};\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        vector<vector<int>> res;\\n        vector<int> v;\\n        mp.clear();\\n        \\n        for(auto &e : queries){\\n            int x = e[0]^e[1];\\n            v.push_back(x);\\n            mp[x] = {-1, -1};\\n        }\\n        \\n        \\n        for(int k=1; k<=30; ++k){\\n            solve(s,k,n);\\n        }\\n        \\n        for(auto &q : v){\\n            res.push_back(mp[q]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174858,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string binaryString(int val)\\n    {\\n        if (val==0) return \"0\";\\n        string str=\"\";\\n        while(val)\\n        {\\n            if (val&1)\\n            str+=\"1\";\\n            else str+=\"0\";\\n            val/=2;\\n        }\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \\n    {\\n        map<string,pair<int,int>>mp;\\n        int n=s.size();\\n        for (int i=0;i<n;i++)\\n        {\\n            string cur=\"\";\\n            for (int j=i;j<n && j<i+31;j++)\\n            {\\n               cur+=s[j];\\n               if (mp.find(cur)==mp.end())\\n               {\\n                   mp[cur]={i,j};\\n               }\\n               if (s[i]==\\'0\\') break;\\n            }\\n        }\\n        vector<vector<int>>ans(queries.size());\\n        for (int i=0;i<queries.size();i++)\\n        {\\n            int val=queries[i][0]^queries[i][1];\\n            string str=binaryString(val);\\n            if (mp.find(str)!=mp.end())\\n            {\\n              ans[i].push_back(mp[str].first);\\n              ans[i].push_back(mp[str].second);\\n            }\\n            else{\\n                ans[i].push_back(-1);\\n                ans[i].push_back(-1);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string binaryString(int val)\\n    {\\n        if (val==0) return \"0\";\\n        string str=\"\";\\n        while(val)\\n        {\\n            if (val&1)\\n            str+=\"1\";\\n            else str+=\"0\";\\n            val/=2;\\n        }\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \\n    {\\n        map<string,pair<int,int>>mp;\\n        int n=s.size();\\n        for (int i=0;i<n;i++)\\n        {\\n            string cur=\"\";\\n            for (int j=i;j<n && j<i+31;j++)\\n            {\\n               cur+=s[j];\\n               if (mp.find(cur)==mp.end())\\n               {\\n                   mp[cur]={i,j};\\n               }\\n               if (s[i]==\\'0\\') break;\\n            }\\n        }\\n        vector<vector<int>>ans(queries.size());\\n        for (int i=0;i<queries.size();i++)\\n        {\\n            int val=queries[i][0]^queries[i][1];\\n            string str=binaryString(val);\\n            if (mp.find(str)!=mp.end())\\n            {\\n              ans[i].push_back(mp[str].first);\\n              ans[i].push_back(mp[str].second);\\n            }\\n            else{\\n                ans[i].push_back(-1);\\n                ans[i].push_back(-1);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174850,
                "title": "python-optimized-solution-hash-map-pre-processing-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPre-process all the substrings of the string which have length less than 32 and store the results in a hash map. Then, use the said hash map to evaluate queries\\n\\n# Complexity\\n- Time complexity: $$O(32 * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(32 * n)$$ for the hash map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        hashMap, res = defaultdict(tuple), []\\n        hashMap[0] = (s.index(\\'0\\') if \\'0\\' in s else -1, s.index(\\'0\\') if \\'0\\' in s else -1)\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\': continue\\n            for j in range(i + 1, len(s) + 1):\\n                curr = s[i: j]\\n                if len(curr) > 32: break\\n                if int(curr, 2) not in hashMap:\\n                    hashMap[int(curr, 2)] = (i, j - 1)\\n        for idx in range(len(queries)):\\n            xor = queries[idx][0] ^ queries[idx][1]\\n            if xor in hashMap:\\n                res.append(hashMap[xor])\\n            else:\\n                res.append((-1, -1))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```python []\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        hashMap, res = defaultdict(tuple), []\\n        hashMap[0] = (s.index(\\'0\\') if \\'0\\' in s else -1, s.index(\\'0\\') if \\'0\\' in s else -1)\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\': continue\\n            for j in range(i + 1, len(s) + 1):\\n                curr = s[i: j]\\n                if len(curr) > 32: break\\n                if int(curr, 2) not in hashMap:\\n                    hashMap[int(curr, 2)] = (i, j - 1)\\n        for idx in range(len(queries)):\\n            xor = queries[idx][0] ^ queries[idx][1]\\n            if xor in hashMap:\\n                res.append(hashMap[xor])\\n            else:\\n                res.append((-1, -1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174670,
                "title": "easy-explanation-map-c-simple-observation",
                "content": "# Observation\\nLet X be XOR of first_i & second_i given in queries;\\nSince the max number possible is 10^9 in Constraints,which is 2^32.\\nSo we will check all substrings of length 32 & Store (start & end index of the numbers formed by converting binary substring X to decimal) with the X in map. & return answer for each query in O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string str;\\n//FUnction to convert Binary String to Decimal Number\\n    long long btd(int l,int r)\\n    {\\n        long long dec_num = 0ll;\\n        long long power = 0ll ;\\n        long long n = str.length() ;\\n\\n          for(long long i = r ; i>=l ; i--){\\n          if(str[i] == \\'1\\'){\\n            dec_num += (1<<power) ;\\n          }\\n          power++;\\n        }\\n        return dec_num;\\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        int n=s.length();\\n        str=s;\\n        unordered_map<int,pair<int,int>> mp;\\n        for(int i=0;i<n;i++){\\n        //checking all substrings of length 1 to 32;\\n            for(int j=i;j<n && j-i<min(n,32);j++){\\n\\n                long long num=btd(i,j);\\n                auto it=mp.find(num);\\n//if not added into map,add start & end index with the number in decimal\\n                if(it==mp.end())mp[num]={i,j};\\n                else {\\n//if that number is already added to the map,then we store the shortest substring that makes that number.\\n\\n//Example Explanation:\\n//011 //11\\n//Both of these binary substring form 3 in decimal.\\n//But we will choose second one because its shortest.\\n                    if(((it->second.second)-(it->second.first))>j-i){\\n                        mp[num]={i,j};\\n                    }\\n                }\\n            }\\n        }\\n        //ANswering queires in O(1) avg TC.\\n        vector<vector<int>> master;\\n\\n        for(auto i:q){\\n\\n            int f=i[0],s=i[1];\\n            int x=f^s;\\n\\n            auto it=mp.find(x);\\n            \\n            if(it==mp.end())master.push_back({-1,-1});\\n            else master.push_back({it->second.first,it->second.second});\\n        }\\n        return master;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string str;\\n//FUnction to convert Binary String to Decimal Number\\n    long long btd(int l,int r)\\n    {\\n        long long dec_num = 0ll;\\n        long long power = 0ll ;\\n        long long n = str.length() ;\\n\\n          for(long long i = r ; i>=l ; i--){\\n          if(str[i] == \\'1\\'){\\n            dec_num += (1<<power) ;\\n          }\\n          power++;\\n        }\\n        return dec_num;\\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        int n=s.length();\\n        str=s;\\n        unordered_map<int,pair<int,int>> mp;\\n        for(int i=0;i<n;i++){\\n        //checking all substrings of length 1 to 32;\\n            for(int j=i;j<n && j-i<min(n,32);j++){\\n\\n                long long num=btd(i,j);\\n                auto it=mp.find(num);\\n//if not added into map,add start & end index with the number in decimal\\n                if(it==mp.end())mp[num]={i,j};\\n                else {\\n//if that number is already added to the map,then we store the shortest substring that makes that number.\\n\\n//Example Explanation:\\n//011 //11\\n//Both of these binary substring form 3 in decimal.\\n//But we will choose second one because its shortest.\\n                    if(((it->second.second)-(it->second.first))>j-i){\\n                        mp[num]={i,j};\\n                    }\\n                }\\n            }\\n        }\\n        //ANswering queires in O(1) avg TC.\\n        vector<vector<int>> master;\\n\\n        for(auto i:q){\\n\\n            int f=i[0],s=i[1];\\n            int x=f^s;\\n\\n            auto it=mp.find(x);\\n            \\n            if(it==mp.end())master.push_back({-1,-1});\\n            else master.push_back({it->second.first,it->second.second});\\n        }\\n        return master;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174633,
                "title": "java-brute-force-with-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe target was `val == first ^ second`, so we can search the substring from `s`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe `s.indexOf(binary)` will got TLE, so we can collect all number in map with brute force.\\nSince `val < 10 ^ 9 < 2 ^ 31`, we can decrease the time from $$O(N^2)$$ to $$O(31N)$$.\\n\\n# Complexity\\n- Time complexity: $$O(31N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(10^9)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[][] substringXorQueries(String s, int[][] queries) {\\n    final int m = s.length();\\n    final int n = queries.length;\\n    int[][] result = new int[n][2];\\n    Map<Integer, int[]> map = new HashMap<>();\\n    for (int i = 0; i < m; i++) {\\n      int num = 0;\\n      // 10 ** 9 < 2 ** 31\\n      for (int j = 0; j < 31 && i + j < m; j++) {\\n        // collect all number start with one\\n        num = (num << 1) + s.charAt(i + j) - \\'0\\';\\n        // always keep the first number\\n        if (!map.containsKey(num)) {\\n          map.put(num, new int[] {i, i + j});\\n        }\\n\\n        // skip the zero\\n        if (s.charAt(i) == \\'0\\') {\\n          break;\\n        }\\n      }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n      result[i] = map.getOrDefault(queries[i][0] ^ queries[i][1], new int[] {-1, -1});\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int[][] substringXorQueries(String s, int[][] queries) {\\n    final int m = s.length();\\n    final int n = queries.length;\\n    int[][] result = new int[n][2];\\n    Map<Integer, int[]> map = new HashMap<>();\\n    for (int i = 0; i < m; i++) {\\n      int num = 0;\\n      // 10 ** 9 < 2 ** 31\\n      for (int j = 0; j < 31 && i + j < m; j++) {\\n        // collect all number start with one\\n        num = (num << 1) + s.charAt(i + j) - \\'0\\';\\n        // always keep the first number\\n        if (!map.containsKey(num)) {\\n          map.put(num, new int[] {i, i + j});\\n        }\\n\\n        // skip the zero\\n        if (s.charAt(i) == \\'0\\') {\\n          break;\\n        }\\n      }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n      result[i] = map.getOrDefault(queries[i][0] ^ queries[i][1], new int[] {-1, -1});\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174612,
                "title": "java-solution-with-explanation-2-approaches",
                "content": "# Approach\\nThe straight forward meaning of this question is that we have to find-\\n    - XOR of both values of each query \\n    - Convert It into binary string\\n    - Find the index of above string is \\'s\\'\\n\\n# --> Please upvote\\n\\n# Simple Approach\\nIt will give TLE but help to understand concept so MUST DO IT\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int[][] res = new int[queries.length][];\\n        for(int i = 0; i<queries.length; i++){\\n            String xor = Integer.toBinaryString(queries[i][0]^queries[i][1]);\\n            int ind = s.indexOf(xor);\\n            if(ind >= 0){\\n                res[i] = new int[]{ind, ind+xor.length()-1};\\n            } else {\\n                res[i] = new int[]{-1, -1};\\n            }\\n        }\\n        return res;\\n    }\\n}\\n``` \\n\\n# Efficent Code using hash map\\nIn this code we will reduse search time by storing all possible substring in hashmap\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        HashMap<Integer, int[]> hm = new HashMap<>();\\n        hm.put(0, new int[]{s.indexOf(\"0\"), s.indexOf(\"0\")});\\n        int n = s.length();\\n        for(int i = 0; i<n; i++){\\n            if(s.charAt(i) == \\'0\\') continue;\\n            for(int j = i+1; j<=n; j++){\\n                String curr = s.substring(i, j);\\n                if(curr.length() > Integer.toBinaryString(Integer.MAX_VALUE).length()) break;\\n                hm.putIfAbsent(Integer.parseInt(curr, 2), new int[]{i, j-1});\\n            }\\n        }\\n        int[][] res = new int[queries.length][];\\n        for(int i = 0; i<queries.length; i++){\\n            int xor = queries[i][0]^queries[i][1];\\n            if(hm.containsKey(xor)){\\n                res[i] = hm.get(xor);\\n            } else {\\n                res[i] = new int[]{-1, -1};\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int[][] res = new int[queries.length][];\\n        for(int i = 0; i<queries.length; i++){\\n            String xor = Integer.toBinaryString(queries[i][0]^queries[i][1]);\\n            int ind = s.indexOf(xor);\\n            if(ind >= 0){\\n                res[i] = new int[]{ind, ind+xor.length()-1};\\n            } else {\\n                res[i] = new int[]{-1, -1};\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        HashMap<Integer, int[]> hm = new HashMap<>();\\n        hm.put(0, new int[]{s.indexOf(\"0\"), s.indexOf(\"0\")});\\n        int n = s.length();\\n        for(int i = 0; i<n; i++){\\n            if(s.charAt(i) == \\'0\\') continue;\\n            for(int j = i+1; j<=n; j++){\\n                String curr = s.substring(i, j);\\n                if(curr.length() > Integer.toBinaryString(Integer.MAX_VALUE).length()) break;\\n                hm.putIfAbsent(Integer.parseInt(curr, 2), new int[]{i, j-1});\\n            }\\n        }\\n        int[][] res = new int[queries.length][];\\n        for(int i = 0; i<queries.length; i++){\\n            int xor = queries[i][0]^queries[i][1];\\n            if(hm.containsKey(xor)){\\n                res[i] = hm.get(xor);\\n            } else {\\n                res[i] = new int[]{-1, -1};\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174605,
                "title": "substring-xor-queries-beginners-friendly",
                "content": "class Nod{\\n    String str  ; \\n    int x1 ; \\n    int x2 ; \\n    Nod(String str, int x1 , int x2) {\\n        this.str = str ; \\n        this.x1 = x1; \\n        this.x2 = x2 ; \\n    }\\n}\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n\\n        HashMap<String , Nod > map = new HashMap<String,Nod>() ; \\n        \\n        for(int i = 0  ; i < s.length() ; i++) {\\n            \\n            if(s.charAt(i) != \\'0\\') { \\n                \\n                String x = \"\" ; \\n                for(int j = i  ; j < s.length()  && j-i < 32  ; j++) { \\n                    \\n                    \\n                    x += s.charAt(j) ; \\n                    if(!map.containsKey(x)) {\\n                        Nod y = new Nod(x,i,j) ; \\n                        map.put(x, y) ; \\n                    }\\n                    \\n                }\\n            } \\n            \\n            else{\\n                if(!map.containsKey(\\'0\\'+\"\")) {\\n                    String x = \\'0\\'+\"\" ; \\n                        Nod y = new  Nod(x , i , i) ; \\n                        map.put(x, y) ; \\n                    \\n                    \\n                }\\n            }\\n        } \\n       // System.out.println(map) ;\\n        int[][] res=  new int[queries.length][queries[0].length]  ; \\n      \\n        for(int i = 0 ; i<queries.length ; i++){\\n            int req = queries[i][0] ^ queries[i][1] ; \\n            \\n            if(req == 0) {\\n                if(map.containsKey(\\'0\\'+\"\")){\\n                      Nod vv = map.get(\\'0\\'+\"\") ; \\n                res[i][0] = vv.x1; \\n                res[i][1] = vv.x2 ; \\n                    \\n                }\\n            } \\n            else{\\n           // System.out.println(req) ;\\n            String v = \"\" ; \\n            while(req > 0 ) {\\n                if((req & 1) == 1 ) {\\n                    v = \\'1\\' + v ; \\n                }\\n                else{\\n                    v = \\'0\\' + v ; \\n                }\\n                req = req >> 1  ; \\n            }\\n           \\n            \\n            if(map.containsKey(v)) {\\n                Nod vv = map.get(v) ; \\n                res[i][0] = vv.x1 ; \\n                res[i][1] = vv.x2 ; \\n            }\\n            else{\\n                res[i][0] = -1 ; \\n                res[i][1] = -1 ; \\n            }\\n            }\\n            \\n            \\n         \\n        }\\n         \\n            \\n            \\n        return res;\\n        \\n       \\n        \\n            \\n            \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n\\n        HashMap<String , Nod > map = new HashMap<String,Nod>() ; \\n        \\n        for(int i = 0  ; i < s.length() ; i++) {\\n            \\n            if(s.charAt(i) != \\'0\\') { \\n                \\n                String x = \"\" ; \\n                for(int j = i  ; j < s.length()  && j-i < 32  ; j++) { \\n                    \\n                    \\n                    x += s.charAt(j) ; \\n                    if(!map.containsKey(x)) {\\n                        Nod y = new Nod(x,i,j) ; \\n                        map.put(x, y) ; \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3174594,
                "title": "o-32-n-solution-map-string-c",
                "content": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tvector<vector < int>> substringXorQueries(string s, vector<vector < int>> &queries)\\n\\t\\t{\\n\\t\\t\\tmap<string, pair<int, int>> mp;\\n\\t\\t\\tfor (int i = 0; i < s.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring temp = \"\";\\n\\t\\t\\t\\tfor (int j = i; j < i + 32 && j < s.size(); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp += s[j];\\n\\t\\t\\t\\t\\tif (mp.find(temp) == mp.end())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmp[temp] = {i, j};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector < int>> ans;\\n\\t\\t\\tfor (auto it: queries)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint num = it[0] ^ it[1]; //REQUIRED \\n\\t\\t\\t\\tvector<int> tem(2, -1);\\n\\t\\t\\t\\tstring temp = \"\";\\n\\t\\t\\t\\tif (num == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp += \\'0\\';\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\twhile (num > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (num % 2 == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp += \\'0\\';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp += \\'1\\';\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tnum /= 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treverse(temp.begin(), temp.end());\\n\\t\\t\\t\\tif (mp.find(temp) != mp.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttem[0] = mp[temp].first;\\n\\t\\t\\t\\t\\ttem[1] = mp[temp].second;\\n\\t\\t\\t\\t\\tans.push_back(tem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans.push_back(tem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tvector<vector < int>> substringXorQueries(string s, vector<vector < int>> &queries)\\n\\t\\t{\\n\\t\\t\\tmap<string, pair<int, int>> mp;\\n\\t\\t\\tfor (int i = 0; i < s.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring temp = \"\";\\n\\t\\t\\t\\tfor (int j = i; j < i + 32 && j < s.size(); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp += s[j];\\n\\t\\t\\t\\t\\tif (mp.find(temp) == mp.end())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmp[temp] = {i, j};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector < int>> ans;\\n\\t\\t\\tfor (auto it: queries)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint num = it[0] ^ it[1]; //REQUIRED \\n\\t\\t\\t\\tvector<int> tem(2, -1);\\n\\t\\t\\t\\tstring temp = \"\";\\n\\t\\t\\t\\tif (num == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp += \\'0\\';\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\twhile (num > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (num % 2 == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp += \\'0\\';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp += \\'1\\';\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tnum /= 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treverse(temp.begin(), temp.end());\\n\\t\\t\\t\\tif (mp.find(temp) != mp.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttem[0] = mp[temp].first;\\n\\t\\t\\t\\t\\ttem[1] = mp[temp].second;\\n\\t\\t\\t\\t\\tans.push_back(tem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans.push_back(tem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174581,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_s + n_queries)\\n * Space Complexity: O(n_s)\\n * where `n_s` is the length of the string `s`\\n *       `n_queries` is the length of the vector `queries`\\n */\\nclass Solution {\\n public:\\n  vector<vector<int>> substringXorQueries(const string &s, const vector<vector<int>> &queries) {\\n    constexpr char zero = \\'0\\';\\n    constexpr int base = 2;\\n    constexpr int max_length = 30;   // 2 ^ 30 = 1073741824\\n    const int n = static_cast<int>(s.size());\\n    unordered_map<int, vector<int>> num_to_result;\\n    for (int begin = 0; begin < n; ++begin) {\\n      int number = 0;\\n      for (int length = 1; length < max_length + 1 && begin + length - 1 < n; ++length) {\\n        const int end = begin + length - 1;\\n        number = base * number + (s[end] - zero);\\n        auto itr = num_to_result.find(number);\\n        if (itr == num_to_result.end()) {\\n          num_to_result[number] = vector<int>{begin, end};\\n        }\\n        if (length == 1 && number == 0) {\\n          break;\\n        }\\n      }\\n    }\\n    \\n    vector<vector<int>> ret(queries.size());\\n    for (size_t i = 0; i < queries.size(); ++i) {\\n      const int number = queries[i][0] ^ queries[i][1];\\n      auto itr = num_to_result.find(number);\\n      if (itr == num_to_result.end()) {\\n        ret[i] = vector{-1, -1};\\n      } else {\\n        ret[i] = itr->second;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_s + n_queries)\\n * Space Complexity: O(n_s)\\n * where `n_s` is the length of the string `s`\\n *       `n_queries` is the length of the vector `queries`\\n */\\nclass Solution {\\n public:\\n  vector<vector<int>> substringXorQueries(const string &s, const vector<vector<int>> &queries) {\\n    constexpr char zero = \\'0\\';\\n    constexpr int base = 2;\\n    constexpr int max_length = 30;   // 2 ^ 30 = 1073741824\\n    const int n = static_cast<int>(s.size());\\n    unordered_map<int, vector<int>> num_to_result;\\n    for (int begin = 0; begin < n; ++begin) {\\n      int number = 0;\\n      for (int length = 1; length < max_length + 1 && begin + length - 1 < n; ++length) {\\n        const int end = begin + length - 1;\\n        number = base * number + (s[end] - zero);\\n        auto itr = num_to_result.find(number);\\n        if (itr == num_to_result.end()) {\\n          num_to_result[number] = vector<int>{begin, end};\\n        }\\n        if (length == 1 && number == 0) {\\n          break;\\n        }\\n      }\\n    }\\n    \\n    vector<vector<int>> ret(queries.size());\\n    for (size_t i = 0; i < queries.size(); ++i) {\\n      const int number = queries[i][0] ^ queries[i][1];\\n      auto itr = num_to_result.find(number);\\n      if (itr == num_to_result.end()) {\\n        ret[i] = vector{-1, -1};\\n      } else {\\n        ret[i] = itr->second;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174539,
                "title": "python3-using-dictionary",
                "content": "# Intuition\\na xor b = c -> a xor c = b\\nSo, for each query(a,b), we need to search first occurence of a xor b in s.\\n\\nAssume len(s)=n and len(queries)=q,\\n(i) Applying Brute Force will be searching q times in s i.e O(n*q)\\n\\n(ii)Thus we need to precompute what all substrings are possible in s and store them in dictionary.\\nThen we can check if a xor b is in dict or not.\\nCalculating substrings takes O(n^2) + Searching in queries takes O(q) i.e O(n^2+q)=O(n^2) as n=10000 and q=100000\\n\\n(iii) Thus, We need to precompute all substrings in O(n) to make it O(n+q)=O(q). To do this, while checking all substrings, in second loop, we will check at max 32 characters.(Every decimal number can be represented in maximum 32 bits)\\n\\n# Approach\\nStore first occurence of substrings of string s in dictionary s.\\nIn second for loop, check till max 32 next characters.\\nFor each query(a,b), calculate a xor b and check if it is in dictionary.If present, append in ans. If not, append [-1,-1] to ans.\\n\\n# Complexity\\n- Time complexity:\\nO(n+q)=O(q) as q>n\\n\\n- Space complexity:\\nO(n) for dictionary\\nO(q) for ans\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        def fun():\\n            return False\\n        d=defaultdict(fun)\\n        for i in range(len(s)):\\n            for j in range(i,min(len(s),i+32)):\\n                ss=s[i:j+1]\\n                if d[ss]:\\n                    continue               #need to store first occurence, so if already present before, skip\\n                d[ss]=(i,j)\\n                \\n            \\n        ans=[]\\n        for a,b in queries:\\n            xor=a^b\\n            test=str(bin(xor))[2:]\\n            print(test)\\n            if d[test]:\\n                ans.append(d[test])\\n            else:\\n                ans.append((-1,-1))\\n        return ans\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        def fun():\\n            return False\\n        d=defaultdict(fun)\\n        for i in range(len(s)):\\n            for j in range(i,min(len(s),i+32)):\\n                ss=s[i:j+1]\\n                if d[ss]:\\n                    continue               #need to store first occurence, so if already present before, skip\\n                d[ss]=(i,j)\\n                \\n            \\n        ans=[]\\n        for a,b in queries:\\n            xor=a^b\\n            test=str(bin(xor))[2:]\\n            print(test)\\n            if d[test]:\\n                ans.append(d[test])\\n            else:\\n                ans.append((-1,-1))\\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174538,
                "title": "note-no-xor-substr-len-would-be-greater-than-30-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n            vector<vector<int>> res;\\n            unordered_map<int,vector<int>> mp;\\n            int n = s.size();\\n            for(int i = n-1;i >=0  ;i--){\\n                \\n                    long long r = 0;\\n                    for(int j=i;j >= max(0, i-30); j--){\\n                        if (s[j] == \\'1\\'){\\n                            r += pow(2,i-j);\\n                            mp[r] = {j,i};\\n                        }\\n                        else mp[0] = {j,j};\\n                    }\\n                \\n            }\\n            for (auto q : queries){\\n                int val = q[0]^q[1];\\n                if (mp.find(val) != mp.end()){\\n                    res.push_back(mp[val]);\\n                }\\n                else res.push_back({-1,-1});\\n            }\\n            return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n            vector<vector<int>> res;\\n            unordered_map<int,vector<int>> mp;\\n            int n = s.size();\\n            for(int i = n-1;i >=0  ;i--){\\n                \\n                    long long r = 0;\\n                    for(int j=i;j >= max(0, i-30); j--){\\n                        if (s[j] == \\'1\\'){\\n                            r += pow(2,i-j);\\n                            mp[r] = {j,i};\\n                        }\\n                        else mp[0] = {j,j};\\n                    }\\n                \\n            }\\n            for (auto q : queries){\\n                int val = q[0]^q[1];\\n                if (mp.find(val) != mp.end()){\\n                    res.push_back(mp[val]);\\n                }\\n                else res.push_back({-1,-1});\\n            }\\n            return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174501,
                "title": "c-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& Q) {\\n        vector<vector<int>> res;\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'0\\') { if(mp.find(0) == mp.end()) mp[0] = {i, i}; }\\n            else for(long j = i, v = 0; v <= INT_MAX && j < s.size(); j++) {\\n                v = (v << 1) + s[j]-\\'0\\';\\n                if(v <= INT_MAX && mp.find(v) == mp.end()) mp[v] = {(int)i, (int)j};\\n            }\\n        }\\n        for(auto q : Q) res.push_back(mp.find(q[0]^q[1]) != mp.end() ? mp[q[0]^q[1]] : vector<int>{-1, -1});\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& Q) {\\n        vector<vector<int>> res;\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'0\\') { if(mp.find(0) == mp.end()) mp[0] = {i, i}; }\\n            else for(long j = i, v = 0; v <= INT_MAX && j < s.size(); j++) {\\n                v = (v << 1) + s[j]-\\'0\\';\\n                if(v <= INT_MAX && mp.find(v) == mp.end()) mp[v] = {(int)i, (int)j};\\n            }\\n        }\\n        for(auto q : Q) res.push_back(mp.find(q[0]^q[1]) != mp.end() ? mp[q[0]^q[1]] : vector<int>{-1, -1});\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174459,
                "title": "c-o-n-solution-with-great-details",
                "content": "# Intuition\\nThe first thing I thought of was probably hashing all the strings of length 30 or less but as I started implementing I realised I don\\'t need to hash strings since these strings are in Binary(I know it is mentioned in the question but I was half asleep :\\') )\\n\\n# Approach\\nThe only logic needed is that we can hash the strings(without leading zeroes, except the string \"0\") by converting them into their equivalent decimal represntation.\\nAnd since the range of numbers in queries is upto 1e9, we just need to consider at max 30 substrings for any index i.\\nSo in the worst case the number of hashings would be 10000 * 30 (actually less than even this but let\\'s take some extra counts :P)\\n\\nSo, mp[i] has the starting and ending position of the first occurence of the number i in the string s in binary form.\\n\\nNow all that is left is xoring queries[i][0] and queries[i][1] and finding this number\\'s first occurence in the hashmap which is trivial.\\n\\n# Complexity\\n- Time complexity:\\no(30 * s.length()) = O(s.length())\\n\\n- Space complexity:\\nO(30 * s.length()) = O(s.length())\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans;\\n        int n = s.size();\\n        unordered_map<int, pair<int, int>> mp;\\n        \\n        for(int i=0; i<n; i++){\\n            string x = \"\";\\n            if(s[i] == \\'0\\'){\\n                if(mp.find(0) == mp.end()){\\n                    mp[0] = make_pair(i, i);\\n                }\\n                continue;\\n            }\\n            int y = 0;\\n            for(int len=0; len<31 && (i+len)<n; len++){\\n                x += s[i+len];\\n                y <<= 1;\\n                if(x.back() == \\'1\\')   y++;\\n                if(mp.find(y) != mp.end())  continue;\\n                pair<int, int> p = {i, i+len};\\n                mp[y] = p;\\n            }\\n        }\\n        \\n        for(auto v:queries){\\n            vector<int> x = {-1, -1};\\n            int need_num = v[0] ^ v[1];\\n            if(mp.find(need_num) != mp.end())  \\n                x[0] = mp[need_num].first, x[1] = mp[need_num].second;\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> ans;\\n        int n = s.size();\\n        unordered_map<int, pair<int, int>> mp;\\n        \\n        for(int i=0; i<n; i++){\\n            string x = \"\";\\n            if(s[i] == \\'0\\'){\\n                if(mp.find(0) == mp.end()){\\n                    mp[0] = make_pair(i, i);\\n                }\\n                continue;\\n            }\\n            int y = 0;\\n            for(int len=0; len<31 && (i+len)<n; len++){\\n                x += s[i+len];\\n                y <<= 1;\\n                if(x.back() == \\'1\\')   y++;\\n                if(mp.find(y) != mp.end())  continue;\\n                pair<int, int> p = {i, i+len};\\n                mp[y] = p;\\n            }\\n        }\\n        \\n        for(auto v:queries){\\n            vector<int> x = {-1, -1};\\n            int need_num = v[0] ^ v[1];\\n            if(mp.find(need_num) != mp.end())  \\n                x[0] = mp[need_num].first, x[1] = mp[need_num].second;\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174457,
                "title": "python-o-len-s-len-queries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. `a ^ b = c  => a = b ^ c`. Now the problem is to find a target substring has the decimal value `val = first ^ second`in `s`.\\n2. Store all possible value and the corresponding result string(actually only the start and end indexes) in a dict. Use two nest loops to build this dict. This needs `O(M^2)` where `M^2 = len(s) = 10^8`. Probably not acceptable.\\n3. Since `0 <= val <= 10^9`, the number is at most 32 bits, and the target substring can only be at most 32 chars long. Now the inner loop in `#2` runs at most 32 times, and the complexity goes to `O(32M) = O(M)`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Build a dict `table`to store all substrings\\' decimal value in `s`. Each substring is at most 32 chars long.\\n2. Update the value\\'s index when:\\n    - The value is not in the dict.\\n    - The substring\\'s length is longer.\\n    - The substring\\'s length is equal to the current one but the leftmost index is larger than the current one.\\n3. Iterating from the end of the `s` instead of the start. In this way we can avoid the leading zero issue.\\n4. For each query, find `val = first ^ second` and the result for this query is `table[val]` or `[-1, -1]`.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(32M + N) = O(M + N)`, where `M` is the length of `s` and `N` is the length of `queries`.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(32M)` since the two nested loops give at most `32 * M` different values, which is the size of the dict.\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        table = defaultdict(list)\\n        n = len(s)\\n        for i in range(n)[::-1]:\\n            val = 0\\n            digit = 0\\n            for j in range(i + 1)[::-1]:\\n                if i - j + 1 > 32:\\n                    break\\n                val += (1 << digit) * (1 if s[j] == \\'1\\' else 0)\\n                digit += 1\\n                \\n                if not table[val]:\\n                    table[val] = [j, i]\\n                elif table[val][1] - table[val][0] > i - j:\\n                    table[val] = [j, i]\\n                elif table[val][1] - table[val][0] == i - j and table[val][0] > j:\\n                    table[val] = [j, i]\\n        \\n        res = []\\n        for a, b in queries:\\n            target = b ^ a\\n            res.append(table[target] if table[target] else [-1, -1])\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        table = defaultdict(list)\\n        n = len(s)\\n        for i in range(n)[::-1]:\\n            val = 0\\n            digit = 0\\n            for j in range(i + 1)[::-1]:\\n                if i - j + 1 > 32:\\n                    break\\n                val += (1 << digit) * (1 if s[j] == \\'1\\' else 0)\\n                digit += 1\\n                \\n                if not table[val]:\\n                    table[val] = [j, i]\\n                elif table[val][1] - table[val][0] > i - j:\\n                    table[val] = [j, i]\\n                elif table[val][1] - table[val][0] == i - j and table[val][0] > j:\\n                    table[val] = [j, i]\\n        \\n        res = []\\n        for a, b in queries:\\n            target = b ^ a\\n            res.append(table[target] if table[target] else [-1, -1])\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174455,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            String subStr=\"\";\\n            if(s.charAt(i)==\\'1\\'){\\n                for (int j = i; j < s.length() && j<64+i; j++) {\\n                    subStr += s.charAt(j);\\n                    if(!hm.containsKey(subStr))hm.put(subStr,i);\\n                }\\n            }else {\\n                if(!hm.containsKey(\"0\"))hm.put(\"0\",i);\\n            }\\n        }\\n        int ans[][] = new int[queries.length][2];\\n        for(int i=0;i<queries.length;i++){\\n            int a = queries[i][0];\\n            int b = queries[i][1];\\n            int c = a^b;\\n            String str = \"\";\\n            do{\\n                if((c&1)>0)str=\"1\"+str;\\n                else str=\"0\"+str;\\n                c=c/2;\\n            }while(c>0);\\n            \\n            if(str.length()>s.length()){\\n                ans[i][0] = -1;\\n                ans[i][1] = -1;\\n            }\\n            else {\\n                \\n                if(!hm.containsKey(str)){\\n                    ans[i][0] = -1;\\n                    ans[i][1] = -1;\\n                }else{\\n                    ans[i][0] = hm.get(str);\\n                    ans[i][1] = hm.get(str)+str.length()-1;\\n                }\\n           }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            String subStr=\"\";\\n            if(s.charAt(i)==\\'1\\'){\\n                for (int j = i; j < s.length() && j<64+i; j++) {\\n                    subStr += s.charAt(j);\\n                    if(!hm.containsKey(subStr))hm.put(subStr,i);\\n                }\\n            }else {\\n                if(!hm.containsKey(\"0\"))hm.put(\"0\",i);\\n            }\\n        }\\n        int ans[][] = new int[queries.length][2];\\n        for(int i=0;i<queries.length;i++){\\n            int a = queries[i][0];\\n            int b = queries[i][1];\\n            int c = a^b;\\n            String str = \"\";\\n            do{\\n                if((c&1)>0)str=\"1\"+str;\\n                else str=\"0\"+str;\\n                c=c/2;\\n            }while(c>0);\\n            \\n            if(str.length()>s.length()){\\n                ans[i][0] = -1;\\n                ans[i][1] = -1;\\n            }\\n            else {\\n                \\n                if(!hm.containsKey(str)){\\n                    ans[i][0] = -1;\\n                    ans[i][1] = -1;\\n                }else{\\n                    ans[i][0] = hm.get(str);\\n                    ans[i][1] = hm.get(str)+str.length()-1;\\n                }\\n           }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174439,
                "title": "try-32-different-substring-lengths-find-s-i-j-first-second",
                "content": "# Intuition\\ns[i\\\\~j]^first == second \\n=> s[i\\\\~j] == first^second\\nSo for each query[i], we just need to find substring in s that equals first^second. Or the other way, for each substring in s, we try to find out all queries that is looking for this value.\\nWe enumerate all possible lengths of substring, substring cannot be longer than 32, so totally try 32 times.\\nFor each fixed length of substring, we use sliding window to fast calculate the value inside it, and fill the result to all queries whose first^second equals this value.\\n\\n# Time Complexity\\nO(32n)\\n\\n# Code\\n```python\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(list)\\n        for i,(a,b) in enumerate(queries):\\n            d[a^b].append(i)\\n        res =[[-1,-1]]*len(queries)\\n        zero_idx = s.find(\\'0\\')\\n        if zero_idx>=0:\\n            for idx in d[0]:\\n                res[idx]=[zero_idx,zero_idx]\\n        for l in range(1,32):\\n            cur,mask = 0, (1<<l)-1\\n            for i in range(len(s)):\\n                cur = ((cur<<1)+int(s[i])) & mask\\n                if i>=l-1 and s[i-l+1]==\\'1\\':\\n                    for idx in d[cur]:\\n                        if res[idx]==[-1,-1]:\\n                            res[idx] = [i-l+1,i]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(list)\\n        for i,(a,b) in enumerate(queries):\\n            d[a^b].append(i)\\n        res =[[-1,-1]]*len(queries)\\n        zero_idx = s.find(\\'0\\')\\n        if zero_idx>=0:\\n            for idx in d[0]:\\n                res[idx]=[zero_idx,zero_idx]\\n        for l in range(1,32):\\n            cur,mask = 0, (1<<l)-1\\n            for i in range(len(s)):\\n                cur = ((cur<<1)+int(s[i])) & mask\\n                if i>=l-1 and s[i-l+1]==\\'1\\':\\n                    for idx in d[cur]:\\n                        if res[idx]==[-1,-1]:\\n                            res[idx] = [i-l+1,i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174411,
                "title": "why-at-o-n-2-on-the-s-giving-tle-1-s-length-10-4",
                "content": "Why !! This \\nplease explain anyone\\n\\n**(1 <= s.length <= 10^4)**\\n\\n<img src=\"https://assets.leetcode.com/users/images/c3155f44-0201-4c46-9a56-55fa74b1a7fb_1676178308.658944.png\" width=\"35%\">\\n",
                "solutionTags": [],
                "code": "Why !! This \\nplease explain anyone\\n\\n**(1 <= s.length <= 10^4)**\\n\\n<img src=\"https://assets.leetcode.com/users/images/c3155f44-0201-4c46-9a56-55fa74b1a7fb_1676178308.658944.png\" width=\"35%\">\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3174376,
                "title": "js-hash-map-30-bits-substring",
                "content": "### Tip\\n1. store 1st value in the Map\\n2. only start at `1` bit\\n3. the constraint `2^27 > 10^9` of each number, so the value of XOR might increase to `2^30 > 10^10` (I tried a few), so I tried the 30 bits substring\\n4. Since in JavaScript the MAX_SAFE_NUMBER= `2^53 \\u2013 1`, we cannot assume the bit of integer is only 32 bit int in java.\\n\\n```\\nvar substringXorQueries = function(s, queries) {\\n    // 2^30 > 10^10\\n    const map = new Map();\\n    for(let i = 0; i<s.length; i++) {\\n        if(s[i] === \\'1\\') {\\n            for(let j = i; j<i+30; j++) {\\n                const str = s.slice(i, j+1);\\n                const val = parseInt(str, 2);\\n                if(!map.has(val)) {\\n                    map.set(val, [i, j]);\\n                }\\n            }\\n        }\\n        else if(s[i] === \\'0\\') {\\n           if(!map.has(0)) {\\n                map.set(0, [i, i]);\\n           } \\n        }\\n    }\\n    const res = [];\\n    for(const [first, second] of queries) {\\n        const target = first ^ second;\\n        if(map.has(target)) {\\n            res.push([...map.get(target)]);\\n        }\\n        else {\\n            res.push([-1, -1]);\\n        }\\n    }\\n    return res; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar substringXorQueries = function(s, queries) {\\n    // 2^30 > 10^10\\n    const map = new Map();\\n    for(let i = 0; i<s.length; i++) {\\n        if(s[i] === \\'1\\') {\\n            for(let j = i; j<i+30; j++) {\\n                const str = s.slice(i, j+1);\\n                const val = parseInt(str, 2);\\n                if(!map.has(val)) {\\n                    map.set(val, [i, j]);\\n                }\\n            }\\n        }\\n        else if(s[i] === \\'0\\') {\\n           if(!map.has(0)) {\\n                map.set(0, [i, i]);\\n           } \\n        }\\n    }\\n    const res = [];\\n    for(const [first, second] of queries) {\\n        const target = first ^ second;\\n        if(map.has(target)) {\\n            res.push([...map.get(target)]);\\n        }\\n        else {\\n            res.push([-1, -1]);\\n        }\\n    }\\n    return res; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174330,
                "title": "c-map-clean-code-o-n-32",
                "content": "```\\nclass Solution {\\npublic:\\n     string db(int n)\\n    {\\n         if(n==0)\\n         {\\n             return \"0\";\\n         }\\n         string ans = \"\";\\n        while (n > 0) \\n        {\\n            ans += to_string(n%2);\\n            n = n / 2;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \\n    {\\n        map<string,pair<int,int>>mp1;\\n        int len = s.length();\\n      \\n        for(int  i = 0;i<len;i++)\\n        {\\n              string p = \"\";\\n             for(int  j = i;j<len;j++)\\n             {\\n                 p += s[j];\\n                \\n                 if(mp1.count(p)==0)\\n                 {\\n                     mp1[p] = {i,j};\\n                 }\\n                 if(j==i+32)\\n                     break;\\n             }\\n        }\\n       map<int, vector<int>>mpp;\\n        int q  = queries.size();\\n        vector<vector<int>>ans(q,  {-1,-1});\\n        for(int  i= 0;i<q;i++)\\n        {\\n            vector<int>it = queries[i];\\n            int val = (it[0]^it[1]);\\n            mpp[val].push_back(i);\\n        }\\n        for(auto it: mpp)\\n        {\\n            int val = it.first;\\n            string ss = db(val);  \\n            if(mp1.count(ss))\\n            {\\n                int an11 = mp1[ss].first;\\n                int an22 = mp1[ss].second;\\n                for(auto itt: it.second)\\n                {\\n                    ans[itt] = {an11, an22};\\n                }\\n            }\\n        }\\n        return ans;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     string db(int n)\\n    {\\n         if(n==0)\\n         {\\n             return \"0\";\\n         }\\n         string ans = \"\";\\n        while (n > 0) \\n        {\\n            ans += to_string(n%2);\\n            n = n / 2;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \\n    {\\n        map<string,pair<int,int>>mp1;\\n        int len = s.length();\\n      \\n        for(int  i = 0;i<len;i++)\\n        {\\n              string p = \"\";\\n             for(int  j = i;j<len;j++)\\n             {\\n                 p += s[j];\\n                \\n                 if(mp1.count(p)==0)\\n                 {\\n                     mp1[p] = {i,j};\\n                 }\\n                 if(j==i+32)\\n                     break;\\n             }\\n        }\\n       map<int, vector<int>>mpp;\\n        int q  = queries.size();\\n        vector<vector<int>>ans(q,  {-1,-1});\\n        for(int  i= 0;i<q;i++)\\n        {\\n            vector<int>it = queries[i];\\n            int val = (it[0]^it[1]);\\n            mpp[val].push_back(i);\\n        }\\n        for(auto it: mpp)\\n        {\\n            int val = it.first;\\n            string ss = db(val);  \\n            if(mp1.count(ss))\\n            {\\n                int an11 = mp1[ss].first;\\n                int an22 = mp1[ss].second;\\n                for(auto itt: it.second)\\n                {\\n                    ans[itt] = {an11, an22};\\n                }\\n            }\\n        }\\n        return ans;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174327,
                "title": "java-pre-processing-properties-of-xor-explained",
                "content": "# Intuition\\n1. Based on the properties of XOR, `a ^ a = 0`, `a ^ b = b ^ a`, and `a ^ (b ^ c) = (a ^ b) ^ c`. Then, `val ^ first = second` could be transformed into `val ^ first ^ first = second ^ first`, and simplified further to `val = second ^ first`.\\n2. For the query question, pre-processing the given data may be a good option to try.\\n3. Since the range of given data in this problem is around 10 ^ 5, so the solution should be at least O(n*logn) and even linear time complexity. If one want to match substring for each query, then its complexity will be at least O(n ^ 2). That\\'s not acceptable.\\n\\n# Complexity\\n`n` represents the length of the string `s`\\n`m` represents the size of the `queries` array\\n- Time complexity: `O(n + m)`\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        // val = first ^ second\\n        // pre-compute the possible value that the substring can form\\n        Map<Integer, int[]> known = new HashMap<>();\\n        boolean foundZero = false;\\n        for (int i = 0; i < s.length(); ++i) {\\n            // if current char is \\'0\\', then we can skip it\\n            // However, we need to store the first 0, since it represents value 0\\n            if (s.charAt(i) == \\'0\\') {\\n                if (!foundZero) {\\n                    known.put(0, new int[]{i, i});\\n                    foundZero = true;\\n                }\\n                continue;\\n            }\\n\\n            // the length of the substring can\\'t exceed 30 digits\\n            // because the range of the number is in [0, 10 ^ 9]\\n            int val = 0, upperBound = Math.min(s.length(), i + 30);\\n            for (int j = i; j < upperBound; ++j) {\\n                // move the whole string left by 1\\n                val <<= 1;\\n                if (s.charAt(j) == \\'1\\') val += 1;\\n                if (!known.containsKey(val)) {\\n                    known.put(val, new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        int[][] ans = new int[queries.length][2];       \\n        for (int i = 0; i < queries.length; ++i) {\\n            // if value not exist in the known map, then it means non exist, so we use {-1, -1} directly\\n            ans[i] = known.getOrDefault(queries[i][0] ^ queries[i][1], new int[]{-1, -1});   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        // val = first ^ second\\n        // pre-compute the possible value that the substring can form\\n        Map<Integer, int[]> known = new HashMap<>();\\n        boolean foundZero = false;\\n        for (int i = 0; i < s.length(); ++i) {\\n            // if current char is \\'0\\', then we can skip it\\n            // However, we need to store the first 0, since it represents value 0\\n            if (s.charAt(i) == \\'0\\') {\\n                if (!foundZero) {\\n                    known.put(0, new int[]{i, i});\\n                    foundZero = true;\\n                }\\n                continue;\\n            }\\n\\n            // the length of the substring can\\'t exceed 30 digits\\n            // because the range of the number is in [0, 10 ^ 9]\\n            int val = 0, upperBound = Math.min(s.length(), i + 30);\\n            for (int j = i; j < upperBound; ++j) {\\n                // move the whole string left by 1\\n                val <<= 1;\\n                if (s.charAt(j) == \\'1\\') val += 1;\\n                if (!known.containsKey(val)) {\\n                    known.put(val, new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        int[][] ans = new int[queries.length][2];       \\n        for (int i = 0; i < queries.length; ++i) {\\n            // if value not exist in the known map, then it means non exist, so we use {-1, -1} directly\\n            ans[i] = known.getOrDefault(queries[i][0] ^ queries[i][1], new int[]{-1, -1});   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174305,
                "title": "python-memorize-queries-first-and-then-update-answer-by-window-sliding-o-n",
                "content": "\\n# Code\\n```python []\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        ans = defaultdict(list)\\n        for i, q in enumerate(queries):\\n            ans[q[0] ^ q[1]].append(i)\\n        anss = [[-1, -1] for i in range(len(queries))]\\n        d = {}\\n        s = list(map(int, s))\\n        mask = 1\\n        # i is the bit length\\n        # find all possible number can be generated by window sliding `s`\\n        # Time Complexity = O(max(len(s)*32, len(queries))) \\n        for i in range(1, min(32, len(s)+1)):\\n            c = 0\\n            for j in range(i-1):\\n                c <<= 1\\n                c |= s[j]\\n            for j in range(i-1, len(s)):\\n                c <<= 1\\n                c |= s[j]\\n                c &= mask\\n                if c in ans and anss[ans[c][0]] == [-1, -1]:\\n                    for k in ans[c]:\\n                        anss[k] = [j-i+1, j]\\n                    \\n            mask <<= 1 \\n            mask += 1\\n        return anss\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        ans = defaultdict(list)\\n        for i, q in enumerate(queries):\\n            ans[q[0] ^ q[1]].append(i)\\n        anss = [[-1, -1] for i in range(len(queries))]\\n        d = {}\\n        s = list(map(int, s))\\n        mask = 1\\n        # i is the bit length\\n        # find all possible number can be generated by window sliding `s`\\n        # Time Complexity = O(max(len(s)*32, len(queries))) \\n        for i in range(1, min(32, len(s)+1)):\\n            c = 0\\n            for j in range(i-1):\\n                c <<= 1\\n                c |= s[j]\\n            for j in range(i-1, len(s)):\\n                c <<= 1\\n                c |= s[j]\\n                c &= mask\\n                if c in ans and anss[ans[c][0]] == [-1, -1]:\\n                    for k in ans[c]:\\n                        anss[k] = [j-i+1, j]\\n                    \\n            mask <<= 1 \\n            mask += 1\\n        return anss\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174294,
                "title": "js-solution-using-tostring-function-for-base-conversion",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[][]}\\n */\\nvar substringXorQueries = function(s, queries) {\\n    let ans=[];\\n    for(const query of queries) {\\n        let x=query[0]^query[1]; //inverse of XOR is XOR itself\\n        let str = x.toString(2);\\n        let idx=s.indexOf(str);\\n        if(idx!==-1) {\\n            ans.push([idx,str.length+idx-1]);\\n        } else {\\n            ans.push([-1,-1]);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[][]}\\n */\\nvar substringXorQueries = function(s, queries) {\\n    let ans=[];\\n    for(const query of queries) {\\n        let x=query[0]^query[1]; //inverse of XOR is XOR itself\\n        let str = x.toString(2);\\n        let idx=s.indexOf(str);\\n        if(idx!==-1) {\\n            ans.push([idx,str.length+idx-1]);\\n        } else {\\n            ans.push([-1,-1]);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174289,
                "title": "using-map-using-property-of-bitwise-xor",
                "content": "# Intuition\\nif a^b=c then a^c=b and b^c=a\\n\\n# Approach\\nStore the decimal value and endpoints of each substring of string s in map .\\nIf  any substring with decimal value x and if this decimal value is already present in map,then do not update the map\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        map<long long,pair<int,int>>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                if(mp.find(0)==mp.end())\\n                {\\n                    mp[0]={i,i};\\n                }\\n                continue;\\n            }\\n            long long v=0;\\n        \\n            for(int j=i;j<n;j++)\\n            {\\n                if(v>1e9)\\n                {\\n                    break;\\n                }\\n                long long dec_val=2*v+(long long)(s[j]-\\'0\\');\\n                if(mp.find(dec_val)==mp.end())\\n                {\\n                    mp[dec_val]={i,j};\\n                }\\n                v=dec_val;\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        \\n      for(auto it:queries)\\n      {\\n          int a=it[0];\\n          int b=it[1];\\n          int c=a^b;\\n          if(mp.find(c)!=mp.end())\\n          {\\n              auto p=mp[c];\\n              int l=p.first;\\n              int r=p.second;\\n              ans.push_back({l,r});\\n          }\\n          else{\\n                ans.push_back({-1,-1});\\n\\n          }\\n          \\n      }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        map<long long,pair<int,int>>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                if(mp.find(0)==mp.end())\\n                {\\n                    mp[0]={i,i};\\n                }\\n                continue;\\n            }\\n            long long v=0;\\n        \\n            for(int j=i;j<n;j++)\\n            {\\n                if(v>1e9)\\n                {\\n                    break;\\n                }\\n                long long dec_val=2*v+(long long)(s[j]-\\'0\\');\\n                if(mp.find(dec_val)==mp.end())\\n                {\\n                    mp[dec_val]={i,j};\\n                }\\n                v=dec_val;\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        \\n      for(auto it:queries)\\n      {\\n          int a=it[0];\\n          int b=it[1];\\n          int c=a^b;\\n          if(mp.find(c)!=mp.end())\\n          {\\n              auto p=mp[c];\\n              int l=p.first;\\n              int r=p.second;\\n              ans.push_back({l,r});\\n          }\\n          else{\\n                ans.push_back({-1,-1});\\n\\n          }\\n          \\n      }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174250,
                "title": "c-short-and-concise-solution-map",
                "content": "```\\n vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        \\n        vector<vector<int>> ans;\\n        map<long long,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            string k=\"\";\\n            for(int j=i;j<s.size() && j<i+32;j++){\\n                k+= s[j];\\n                long long p= stol(k, 0, 2);\\n                if(mp.find(p)==mp.end()){\\n                    mp[p]= i;\\n                }\\n                if(k[0]==\\'0\\') break;\\n            }\\n        }\\n        \\n        for(int i=0;i<queries.size();i++){\\n            int xr= queries[i][0]^queries[i][1];\\n            \\n            if(mp.find(xr)==mp.end()){\\n                ans.push_back({-1,-1});\\n            }\\n            else{\\n                int r= xr==0?0:log2(xr);\\n                ans.push_back({mp[xr],r+mp[xr]});\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        \\n        vector<vector<int>> ans;\\n        map<long long,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            string k=\"\";\\n            for(int j=i;j<s.size() && j<i+32;j++){\\n                k+= s[j];\\n                long long p= stol(k, 0, 2);\\n                if(mp.find(p)==mp.end()){\\n                    mp[p]= i;\\n                }\\n                if(k[0]==\\'0\\') break;\\n            }\\n        }\\n        \\n        for(int i=0;i<queries.size();i++){\\n            int xr= queries[i][0]^queries[i][1];\\n            \\n            if(mp.find(xr)==mp.end()){\\n                ans.push_back({-1,-1});\\n            }\\n            else{\\n                int r= xr==0?0:log2(xr);\\n                ans.push_back({mp[xr],r+mp[xr]});\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3174235,
                "title": "using-precomputation-and-map-c",
                "content": "# Intuition\\nPrecomputing all the substrings of length less than 32 and storing their position\\'s using a map \\n\\n# Approach\\nWe can use precomputing and then answering queries in constant time to solve this problem.\\nAs the range of firsti and secondi is\\n**0 <= firsti, secondi <= 1e9 **\\nwe can be sure that we don\\'t need more than 32 bits to represent the answer so we will precompute all substring of length < 32\\n\\n# Complexity\\n- Time complexity:\\nn : length of string\\nm : number of queries\\n\\nO(n * 32 + m) = O(n + m)\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\n#define ll int\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& v) {\\n        vector<vector<ll>> res;\\n        map<string,pair<ll,ll>> mp;\\n        for(ll i = 0; i < s.size(); i++){\\n            if(s[i] == \\'0\\') {\\n                if(!mp.count(\"0\")) mp[\"0\"] = {i, i};   \\n                continue;\\n            }\\n            string z =\"\";\\n            ll n = s.length();\\n            for(ll j = i; j < min(n, i + 32); j++){\\n                z += s[j];\\n                if(!mp.count(z)){\\n                    mp[z] = {i, j};\\n                }\\n                else{\\n                    if((j - i) < (mp[z].second - mp[z].first)){\\n                        mp[z] = {i, j};\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(ll i = 0; i < v.size(); i++){\\n            bool flag = true;\\n            ll k = v[i][0] ^ v[i][1];\\n            string fin = \"\";\\n            if(k == 0) fin = \"0\";\\n            for(ll i = 31; i >= 0; i--){\\n                if(k & (1 << i)){\\n                    fin += \"1\";\\n                    flag = false;\\n                }\\n                else{\\n                    if(flag) continue;\\n                    else fin += \\'0\\';\\n                }\\n            }\\n            if(mp.count(fin)){\\n                    vector<ll> a = {mp[fin].first, mp[fin].second};\\n                    res.push_back(a);\\n                }\\n            else{\\n                vector<ll> a = {-1, -1};\\n                res.push_back(a);\\n            }\\n        }\\n            return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\n#define ll int\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& v) {\\n        vector<vector<ll>> res;\\n        map<string,pair<ll,ll>> mp;\\n        for(ll i = 0; i < s.size(); i++){\\n            if(s[i] == \\'0\\') {\\n                if(!mp.count(\"0\")) mp[\"0\"] = {i, i};   \\n                continue;\\n            }\\n            string z =\"\";\\n            ll n = s.length();\\n            for(ll j = i; j < min(n, i + 32); j++){\\n                z += s[j];\\n                if(!mp.count(z)){\\n                    mp[z] = {i, j};\\n                }\\n                else{\\n                    if((j - i) < (mp[z].second - mp[z].first)){\\n                        mp[z] = {i, j};\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(ll i = 0; i < v.size(); i++){\\n            bool flag = true;\\n            ll k = v[i][0] ^ v[i][1];\\n            string fin = \"\";\\n            if(k == 0) fin = \"0\";\\n            for(ll i = 31; i >= 0; i--){\\n                if(k & (1 << i)){\\n                    fin += \"1\";\\n                    flag = false;\\n                }\\n                else{\\n                    if(flag) continue;\\n                    else fin += \\'0\\';\\n                }\\n            }\\n            if(mp.count(fin)){\\n                    vector<ll> a = {mp[fin].first, mp[fin].second};\\n                    res.push_back(a);\\n                }\\n            else{\\n                vector<ll> a = {-1, -1};\\n                res.push_back(a);\\n            }\\n        }\\n            return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3174221,
                "title": "java-solution-hashmap-dfs-with-purge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        // HashMap \\n        Map<Integer, int[]> map = new HashMap<>(); // <val, leftestRange>\\n        int n = s.length();\\n        for (int i=0; i<n; i++) { // get first 0 and 1, the first 1 will be used for next loop purge\\n            if (s.charAt(i) == \\'0\\' && !map.containsKey(0)) map.put(0, new int[]{i, i});\\n            if (s.charAt(i) == \\'1\\' && !map.containsKey(1)) map.put(1, new int[]{i, i});\\n            if (map.containsKey(0) && map.containsKey(1)) break;\\n        }\\n        for (int i=map.getOrDefault(1, new int[]{n, n})[0]; i<n; i++) { // \\u526A\\u679D\\u4F18\\u5316\\n            if (s.charAt(i) == \\'0\\') continue;\\n            int val = 1;\\n            for (int j=i+1; j<Math.min((i+31), n); j++) { // \\u4E0D\\u9700\\u8981\\u904D\\u5386\\u5B8C\\uFF0C\\u56E0\\u4E3A\\u6574\\u6570\\u6700\\u591A 32 \\u4F4D\\u5373\\u53EF\\n                val = (val << 1) | (s.charAt(j) - \\'0\\');\\n                if (!map.containsKey(val)) map.put(val, new int[]{i, j});\\n            }\\n        }\\n        int[][] res = new int[queries.length][2];\\n        for (int i=0; i<queries.length; i++) {\\n            int val = queries[i][0] ^ queries[i][1];\\n            res[i] = map.getOrDefault(val, new int[]{-1, -1});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        // HashMap \\n        Map<Integer, int[]> map = new HashMap<>(); // <val, leftestRange>\\n        int n = s.length();\\n        for (int i=0; i<n; i++) { // get first 0 and 1, the first 1 will be used for next loop purge\\n            if (s.charAt(i) == \\'0\\' && !map.containsKey(0)) map.put(0, new int[]{i, i});\\n            if (s.charAt(i) == \\'1\\' && !map.containsKey(1)) map.put(1, new int[]{i, i});\\n            if (map.containsKey(0) && map.containsKey(1)) break;\\n        }\\n        for (int i=map.getOrDefault(1, new int[]{n, n})[0]; i<n; i++) { // \\u526A\\u679D\\u4F18\\u5316\\n            if (s.charAt(i) == \\'0\\') continue;\\n            int val = 1;\\n            for (int j=i+1; j<Math.min((i+31), n); j++) { // \\u4E0D\\u9700\\u8981\\u904D\\u5386\\u5B8C\\uFF0C\\u56E0\\u4E3A\\u6574\\u6570\\u6700\\u591A 32 \\u4F4D\\u5373\\u53EF\\n                val = (val << 1) | (s.charAt(j) - \\'0\\');\\n                if (!map.containsKey(val)) map.put(val, new int[]{i, j});\\n            }\\n        }\\n        int[][] res = new int[queries.length][2];\\n        for (int i=0; i<queries.length; i++) {\\n            int val = queries[i][0] ^ queries[i][1];\\n            res[i] = map.getOrDefault(val, new int[]{-1, -1});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174214,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        map<int,vector<int>> mp;\\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++){   //store all subarray in map with its index range, except for one which starts with 0.\\n            if(s[i]==\\'0\\'){\\n                if(mp.count(0)==0){\\n                    mp[0]={i,i};\\n                }\\n                continue;\\n            }\\n            int num=0;\\n            for(int j=i;j<n && j-i<31;j++){\\n                num=num*2 + (s[j]-\\'0\\');\\n                if(mp.count(num)==0){\\n                    mp[num]={i,j};\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(auto &vec: queries){\\n            int first=vec[0],second=vec[1];\\n            int curr=first^second;\\n            if(mp.count(curr)){\\n                ans.push_back(mp[curr]);\\n            }\\n            else ans.push_back({-1,-1});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/155de7be-2b79-4562-8e57-495e37fff452_1676176321.5088468.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        map<int,vector<int>> mp;\\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++){   //store all subarray in map with its index range, except for one which starts with 0.\\n            if(s[i]==\\'0\\'){\\n                if(mp.count(0)==0){\\n                    mp[0]={i,i};\\n                }\\n                continue;\\n            }\\n            int num=0;\\n            for(int j=i;j<n && j-i<31;j++){\\n                num=num*2 + (s[j]-\\'0\\');\\n                if(mp.count(num)==0){\\n                    mp[num]={i,j};\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(auto &vec: queries){\\n            int first=vec[0],second=vec[1];\\n            int curr=first^second;\\n            if(mp.count(curr)){\\n                ans.push_back(mp[curr]);\\n            }\\n            else ans.push_back({-1,-1});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174197,
                "title": "java-frequency-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        Map<Integer, int[]> freq = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            int num = 0;\\n            for (int j = i, k = 0; j >= 0 && k <= 31; j--, k++) {\\n                int bit = s.charAt(j) - \\'0\\';\\n                num += (bit << k);\\n                int[] v = {j, i};\\n                if (num < Integer.MAX_VALUE && !freq.containsKey(num)) {\\n                    freq.put(num, v);\\n                }\\n            }\\n        }\\n        int[][] ans = new int[queries.length][2];\\n        for (int i = 0; i < queries.length; i++) {\\n            int target = (queries[i][0] ^ queries[i][1]);\\n            if (freq.containsKey(target)) {\\n                ans[i] = freq.get(target);\\n            } else {\\n                ans[i] = new int[]{-1, -1};\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        Map<Integer, int[]> freq = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            int num = 0;\\n            for (int j = i, k = 0; j >= 0 && k <= 31; j--, k++) {\\n                int bit = s.charAt(j) - \\'0\\';\\n                num += (bit << k);\\n                int[] v = {j, i};\\n                if (num < Integer.MAX_VALUE && !freq.containsKey(num)) {\\n                    freq.put(num, v);\\n                }\\n            }\\n        }\\n        int[][] ans = new int[queries.length][2];\\n        for (int i = 0; i < queries.length; i++) {\\n            int target = (queries[i][0] ^ queries[i][1]);\\n            if (freq.containsKey(target)) {\\n                ans[i] = freq.get(target);\\n            } else {\\n                ans[i] = new int[]{-1, -1};\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174187,
                "title": "hashmap-solution-c",
                "content": "```\\nT.C: O(32*N)\\nS.C: O(32*N)\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        int n=s.length(),m=q.size();\\n        map<ll,vector<int>> mp;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                if(mp.find(0)==mp.end()) mp[0]={i,i};\\n                continue;\\n            }\\n            int sz=min(i+32,n-1);\\n            ll val=0;\\n            for(int j=i;j<=sz;j++){\\n                val=(val<<1) + (s[j]-\\'0\\');\\n                if(mp.find(val)==mp.end()) mp[val]={i,j};\\n            }\\n        }\\n        vector<vector<int>> res;\\n        for(int i=0;i<m;i++){\\n            int val=(q[i][0] ^ q[i][1]);\\n            if(mp.find(val)!=mp.end()){\\n                res.push_back(mp[val]);\\n            }\\n            else{\\n                res.push_back({-1,-1});\\n            }\\n        }\\n        if(res.size()==0) res.push_back({-1,-1});\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nT.C: O(32*N)\\nS.C: O(32*N)\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& q) {\\n        int n=s.length(),m=q.size();\\n        map<ll,vector<int>> mp;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                if(mp.find(0)==mp.end()) mp[0]={i,i};\\n                continue;\\n            }\\n            int sz=min(i+32,n-1);\\n            ll val=0;\\n            for(int j=i;j<=sz;j++){\\n                val=(val<<1) + (s[j]-\\'0\\');\\n                if(mp.find(val)==mp.end()) mp[val]={i,j};\\n            }\\n        }\\n        vector<vector<int>> res;\\n        for(int i=0;i<m;i++){\\n            int val=(q[i][0] ^ q[i][1]);\\n            if(mp.find(val)!=mp.end()){\\n                res.push_back(mp[val]);\\n            }\\n            else{\\n                res.push_back({-1,-1});\\n            }\\n        }\\n        if(res.size()==0) res.push_back({-1,-1});\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174182,
                "title": "c-sliding-window-preprocessing-with-thought-process",
                "content": "We first note that for each query, we\\'re looking for val such that\\n`val ^ first = second`, and XORing by `first` on both sides gives us `val = val ^ first ^ first = second ^ first`.\\nIn this way, we can reduce the problem to looking for occurrences of binary form of `first ^ second` for each query.\\n\\nThe next step is to quickly search for the binary form.\\n\\nMy initial approach was to convert it to a string and do use `stl::find()` but that turns out to be O(n^2), TLE.\\n\\nThe solution is to notice that our possible vals are up to 1e9, which is 2^30. Our target substrings are thus of length up to 30.\\n\\nWe can thus preprocess all possible values (within the bounds of 1e9) in about O(n). I opted for a sliding window, but a naive `30*30*n` approach would probably pass as well.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>> found;\\n    \\n    void preprocess(string&s){        \\n        // We do a check for substrings of length up to 30 since 1e9 <= 2^30\\n        for(int sz=1; sz<=s.size() && sz<31; sz++){\\n            int x = 0;\\n            int mask = (1<<sz)-1;\\n            \\n            // Initialize the sliding window\\n            for(int i=0; i<sz; i++){\\n                x*=2;\\n                x+=(s[i]==\\'1\\');\\n            }\\n            if(found.find(x)==found.end()) found[x] = {0,sz-1};\\n            \\n            // Slide to the end\\n            for(int i=sz; i<s.size(); i++){\\n                x*=2;\\n                x+=(s[i]==\\'1\\');\\n                x &= mask;\\n                if(found.find(x)==found.end()) found[x] = {i-sz+1,i};\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        preprocess(s);\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(auto&q:queries){\\n            int t = q[1] ^ q[0];\\n            auto it = found.find(t);\\n            if(it==found.end()) ans.push_back({-1,-1});\\n            else ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>> found;\\n    \\n    void preprocess(string&s){        \\n        // We do a check for substrings of length up to 30 since 1e9 <= 2^30\\n        for(int sz=1; sz<=s.size() && sz<31; sz++){\\n            int x = 0;\\n            int mask = (1<<sz)-1;\\n            \\n            // Initialize the sliding window\\n            for(int i=0; i<sz; i++){\\n                x*=2;\\n                x+=(s[i]==\\'1\\');\\n            }\\n            if(found.find(x)==found.end()) found[x] = {0,sz-1};\\n            \\n            // Slide to the end\\n            for(int i=sz; i<s.size(); i++){\\n                x*=2;\\n                x+=(s[i]==\\'1\\');\\n                x &= mask;\\n                if(found.find(x)==found.end()) found[x] = {i-sz+1,i};\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        preprocess(s);\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(auto&q:queries){\\n            int t = q[1] ^ q[0];\\n            auto it = found.find(t);\\n            if(it==found.end()) ans.push_back({-1,-1});\\n            else ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174173,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = queries.size() ;\\n        vector<vector<int>>ret(n, vector<int>(2, -1)) ;\\n        unordered_map<int, vector<int>>Map ;\\n        int check = 0;\\n        for(int i = 0; i < n; i++){\\n            int val = queries[i][0] ^ queries[i][1] ;\\n            Map[val].push_back(i) ;\\n        }\\n        unordered_set<int>Set ;\\n        for(int i = 0; i < s.size(); i++){\\n            long long val = 0 ;\\n            if(s[i] == \\'0\\'){\\n                if(Set.count(0) == 0 ){\\n                    if(Map.count(0)){\\n                        for(auto v : Map[0]){\\n                            ret[v][0] = i ;\\n                            ret[v][1] = i ;\\n                            check++;\\n                        }\\n                    }\\n                    Set.insert(0) ;\\n                }\\n                continue ;\\n            }\\n            for(int j = i ; j < fmin(i+31, s.size()); j++){\\n                val = val*2 + s[j] -\\'0\\' ;\\n                if(Set.count(val))\\n                    continue ;\\n                Set.insert(val) ;\\n                if(Map.count(val)){\\n                    for(auto v : Map[val]){\\n                        ret[v][0] = i ;\\n                        ret[v][1] = j ;\\n                        check++;\\n                    }           \\n                }\\n                if(check == n)\\n                    break ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        int n = queries.size() ;\\n        vector<vector<int>>ret(n, vector<int>(2, -1)) ;\\n        unordered_map<int, vector<int>>Map ;\\n        int check = 0;\\n        for(int i = 0; i < n; i++){\\n            int val = queries[i][0] ^ queries[i][1] ;\\n            Map[val].push_back(i) ;\\n        }\\n        unordered_set<int>Set ;\\n        for(int i = 0; i < s.size(); i++){\\n            long long val = 0 ;\\n            if(s[i] == \\'0\\'){\\n                if(Set.count(0) == 0 ){\\n                    if(Map.count(0)){\\n                        for(auto v : Map[0]){\\n                            ret[v][0] = i ;\\n                            ret[v][1] = i ;\\n                            check++;\\n                        }\\n                    }\\n                    Set.insert(0) ;\\n                }\\n                continue ;\\n            }\\n            for(int j = i ; j < fmin(i+31, s.size()); j++){\\n                val = val*2 + s[j] -\\'0\\' ;\\n                if(Set.count(val))\\n                    continue ;\\n                Set.insert(val) ;\\n                if(Map.count(val)){\\n                    for(auto v : Map[val]){\\n                        ret[v][0] = i ;\\n                        ret[v][1] = j ;\\n                        check++;\\n                    }           \\n                }\\n                if(check == n)\\n                    break ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174155,
                "title": "java-using-hashmap-of-substrings",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(32 * n)$$, where n is the length of string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(32 * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int[][] res = new int[queries.length][2];\\n        Map<Integer, Integer> indexMap = new HashMap<>();\\n        int zero = -1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                if (zero == -1) {\\n                    zero = i;\\n                }\\n                continue;\\n            }\\n            for (int j = i + 1; j < i + 32 && j <= s.length(); j++) {\\n                indexMap.putIfAbsent(Integer.parseInt(s.substring(i, j), 2), i);\\n            }\\n        }\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int[] query = queries[i];\\n            Integer index = indexMap.get(query[0] ^ query[1]);\\n            if (query[0] == query[1]) index = zero;\\n            if (index==null) {\\n                res[i][0] = -1;\\n                res[i][1] = -1;\\n            } else {\\n                res[i][0] = index;\\n                res[i][1] = index + Integer.toBinaryString(query[0] ^ query[1]).length() - 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] substringXorQueries(String s, int[][] queries) {\\n        int[][] res = new int[queries.length][2];\\n        Map<Integer, Integer> indexMap = new HashMap<>();\\n        int zero = -1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                if (zero == -1) {\\n                    zero = i;\\n                }\\n                continue;\\n            }\\n            for (int j = i + 1; j < i + 32 && j <= s.length(); j++) {\\n                indexMap.putIfAbsent(Integer.parseInt(s.substring(i, j), 2), i);\\n            }\\n        }\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int[] query = queries[i];\\n            Integer index = indexMap.get(query[0] ^ query[1]);\\n            if (query[0] == query[1]) index = zero;\\n            if (index==null) {\\n                res[i][0] = -1;\\n                res[i][1] = -1;\\n            } else {\\n                res[i][0] = index;\\n                res[i][1] = index + Integer.toBinaryString(query[0] ^ query[1]).length() - 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174145,
                "title": "python-clean-solution",
                "content": "\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        dt, n = {}, len(s)\\n        for i in range(n):\\n            t = 0\\n            for j in range(i, min(i + 30, n)):\\n                t = (t << 1) | int(s[j])\\n                if t not in dt or dt[t][1] - dt[t][0] > j - i:\\n                    dt[t] = [i, j]\\n            \\n        return [dt.get(fir ^ sec, [-1, -1]) for fir, sec in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        dt, n = {}, len(s)\\n        for i in range(n):\\n            t = 0\\n            for j in range(i, min(i + 30, n)):\\n                t = (t << 1) | int(s[j])\\n                if t not in dt or dt[t][1] - dt[t][0] > j - i:\\n                    dt[t] = [i, j]\\n            \\n        return [dt.get(fir ^ sec, [-1, -1]) for fir, sec in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174123,
                "title": "simple-python-approach-with-explanation",
                "content": "# Intuition\\n- intially we need to get the Xor value of the given queries and check whether the converted decimal equivalent is exiting int the given string or not\\n- if exist then get the respective index and add to the result \\n- if not exist then as mentioned above append (-1,-1) and also if there are no such case exist simply return [[-1,-1]]\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n- n is the string length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m) \\n- where m is the number of queries\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        res=[]\\n        for a,b in queries:\\n            xor_value= b^a\\n            binaryValue = bin(xor_value)[2:]\\n            if binaryValue in s:\\n                res.append([s.index(binaryValue),s.index(binaryValue)+len(binaryValue)-1])\\n            else:\\n                res.append([-1,-1])\\n        if res:\\n            return res\\n        else:\\n            return [[-1,-1]]\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        res=[]\\n        for a,b in queries:\\n            xor_value= b^a\\n            binaryValue = bin(xor_value)[2:]\\n            if binaryValue in s:\\n                res.append([s.index(binaryValue),s.index(binaryValue)+len(binaryValue)-1])\\n            else:\\n                res.append([-1,-1])\\n        if res:\\n            return res\\n        else:\\n            return [[-1,-1]]\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174109,
                "title": "hashmap-bit-manipulation-observation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        // there are only 30 bits in total right\\n        // hence find all the values for sliding window sizes of 30\\n        unordered_map<int,int> ind;\\n        \\n        for(int i=1; i<=30; i++) {\\n            // use a sliding window of size i\\n            int val=0;\\n            int mask = ((1<<i)-1);\\n            \\n            for(int j=0; j<s.size(); j++) {\\n                val <<= 1;\\n                val |= (s[j]-\\'0\\');\\n                val = (val & (mask));\\n                \\n                if(j >= i-1) {\\n                    if(not ind.count(val & mask)) {\\n                        ind[val & mask] = j-i+1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> result;\\n        \\n        for(vector<int>& q : queries) {\\n            // val^left == right is the same as\\n            // val == left ^ right\\n            int num = (q[0]^q[1]);\\n            int len;\\n            \\n            if(num != 0) len = 32 - __builtin_clz(num);\\n            else len = 1;\\n            \\n            if(ind.count(num)) {\\n                result.push_back({ind[num],ind[num]+len-1});\\n            }\\n            else {\\n                result.push_back({-1,-1});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        // there are only 30 bits in total right\\n        // hence find all the values for sliding window sizes of 30\\n        unordered_map<int,int> ind;\\n        \\n        for(int i=1; i<=30; i++) {\\n            // use a sliding window of size i\\n            int val=0;\\n            int mask = ((1<<i)-1);\\n            \\n            for(int j=0; j<s.size(); j++) {\\n                val <<= 1;\\n                val |= (s[j]-\\'0\\');\\n                val = (val & (mask));\\n                \\n                if(j >= i-1) {\\n                    if(not ind.count(val & mask)) {\\n                        ind[val & mask] = j-i+1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> result;\\n        \\n        for(vector<int>& q : queries) {\\n            // val^left == right is the same as\\n            // val == left ^ right\\n            int num = (q[0]^q[1]);\\n            int len;\\n            \\n            if(num != 0) len = 32 - __builtin_clz(num);\\n            else len = 1;\\n            \\n            if(ind.count(num)) {\\n                result.push_back({ind[num],ind[num]+len-1});\\n            }\\n            else {\\n                result.push_back({-1,-1});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174106,
                "title": "c-o-nlogn-sliding-window-bit-manipulation-intuition-approach",
                "content": "# Intuition\\n1. We notice that we need to search for binary representation of `first ^ second` for every query.\\n\\nXor with first on both sides of the original equation\\n`val ^ first ^ first = second ^ first`\\n`val = second ^ first`\\n\\n2. We cannot search the string `s` for every query since this will give TLE.\\n3. We need to preprocess it somehow\\n4. Maximum xor can be `1e9` which means maximum 32 concurrent bits from `s` have to be taken. \\n\\n# Approach\\n1. Store every `first ^ second` in an unordered_map.\\n2. Iterate over `s` for all windows of length 1 to length 32.\\n3. Get the dec representation of number in the window.\\n4. If the dec is present in the unordered_map and unassigned, Assign it.\\n\\nNote that this will always yeild correct answer, since if dec is unassigned, it is not possible to get it using a substring of smaller length. We iterate from left to right so the smallest index will be set.\\n\\nTo get dec representation of number in the sliding window, say window length is 3, previous binary number in the window is 101:\\n\\n1. You unset the third bit, using `number &= ~(1<<(3-1))`;\\n2. You left shift the number, `number <<= 1`;\\n3. You add the current bit.\\n\\n# Complexity\\n- Time complexity:\\n`O(max(queries, 32 * length))`\\n\\n- Space complexity:\\n`O(max(queries, length))`\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, pair<int, int>> mp;\\n        //filling the map\\n        for(auto i: queries){\\n            mp[i[0] ^ i[1]] = {INT_MAX, INT_MAX};\\n        }\\n        long curr;\\n        //iterating over length\\n        for(int i = 1;i<=32;i++){\\n            curr = 0;\\n            for(int j = 0;j<min(i, (int)s.size());j++){\\n                curr<<=1;\\n                curr+=(s[j] - \\'0\\');\\n            }\\n            if(mp.count(curr) && mp[curr].first == INT_MAX) mp[curr] = {0, i-1};\\n            //sliding window\\n            for(int j = i;j<s.size();j++){\\n                curr &= ~(1<<(i-1));\\n                curr <<= 1;\\n                curr += (s[j] - \\'0\\');\\n                if(mp.count(curr)){\\n                    if(mp[curr].first == INT_MAX){\\n                        mp[curr] = {j-i + 1, j};\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto i: queries){\\n            if(mp[i[0] ^ i[1]].first == INT_MAX){\\n                ans.push_back({-1, -1});\\n            }else{\\n                ans.push_back({mp[i[0] ^ i[1]].first, mp[i[0] ^ i[1]].second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int, pair<int, int>> mp;\\n        //filling the map\\n        for(auto i: queries){\\n            mp[i[0] ^ i[1]] = {INT_MAX, INT_MAX};\\n        }\\n        long curr;\\n        //iterating over length\\n        for(int i = 1;i<=32;i++){\\n            curr = 0;\\n            for(int j = 0;j<min(i, (int)s.size());j++){\\n                curr<<=1;\\n                curr+=(s[j] - \\'0\\');\\n            }\\n            if(mp.count(curr) && mp[curr].first == INT_MAX) mp[curr] = {0, i-1};\\n            //sliding window\\n            for(int j = i;j<s.size();j++){\\n                curr &= ~(1<<(i-1));\\n                curr <<= 1;\\n                curr += (s[j] - \\'0\\');\\n                if(mp.count(curr)){\\n                    if(mp[curr].first == INT_MAX){\\n                        mp[curr] = {j-i + 1, j};\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto i: queries){\\n            if(mp[i[0] ^ i[1]].first == INT_MAX){\\n                ans.push_back({-1, -1});\\n            }else{\\n                ans.push_back({mp[i[0] ^ i[1]].first, mp[i[0] ^ i[1]].second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1797799,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797584,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797553,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797575,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797546,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797866,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1798670,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 2014937,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1803702,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1798428,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797799,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797584,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797553,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797575,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797546,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1797866,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1798670,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 2014937,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1803702,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            },
            {
                "id": 1798428,
                "content": [
                    {
                        "username": "ustinovas",
                        "content": "The maximum length of the input string $$s$$ is $$10^4$$ and we have 30 substrings to consider for every starting position in $$s$$. This gives us $$3\\\\cdot 10^5$$ potentially unique values, so we CAN put everything to a HashMap without causing MLE. "
                    },
                    {
                        "username": "shubham3786",
                        "content": "HINT:\\nif, a^b = c therefore, a = c^b\\nor, in more sense to question,\\nif val^first = second => `val = first^second`"
                    },
                    {
                        "username": "workcool",
                        "content": "More like a brain teaser question"
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I get Time Limit Exceeded for input of s = nothing and I pass 59/59 test cases. Any way to cope with that?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "what is value for `queries` for this subcase ?"
                    },
                    {
                        "username": "CODEX47",
                        "content": "You have been toyed with brother. Sorry for your loss."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "HINT: This question requires some knowledge of XOR, which is that a XOR b = c, and at the same time a XOR c = b. Hope this helps!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The question is difficult to understand."
                    },
                    {
                        "username": "HarshG",
                        "content": " As per contstraint \"if multiple answers choose the one with minimum left \"\nSo for Input: s = \"101101\", queries = [[0,5],[1,2]]\nI get answer as [[0,2],[1,3]] but expected answer as per testcase is [[0,2],[2,3]].\n\nIn my case [1,3] satisfies the minimum constraint but it failed even though substring \"011\" is as valid as the expected \"11\"  and in fact \"011\" satisfies the minimum constraint between \"011\" and \"11\".\nIs the expected answer incorrect or am i doing something wrong?\n\nBelow is my code\n\n `public int[][] substringXorQueries(String s, int[][] queries) {\n        \n        int[][] ans = new int[queries.length][2];\n        HashMap<Integer,int[]> map = new HashMap<Integer,int[]>();\n\n        for(int i=0;i<s.length();i++) {\n            for(int j=i+1;j<s.length();j++){\n                String sub = s.substring(i,j);\n                int deci = Integer.parseInt(sub,2);\n                if(!map.containsKey(deci)) {\n                    map.put(deci,new int[]{i,j-1});\n                }\n            }\n        }\n\n        int k=0;\n        for(int[] row: queries) {\n            int val = row[0] ^ row[1];\n            if(map.containsKey(val)) {\n                ans[k][0] = map.get(val)[0];\n                ans[k][1] = map.get(val)[1];\n            } else {\n                ans[k][0] = -1;\n                ans[k][1] =-1;\n            }\n            k++;\n        }\n        return ans;\n\n    }`"
                    },
                    {
                        "username": "lostboy",
                        "content": "it should also be the shortest substring, not just the one with the minimum starting position. "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "val ^ first = second\\n(val ^ first) ^ first = second ^ first\\nval ^ (first ^ first) = first ^ second\\nval ^ 0 = first ^ second\\nval = first ^ second\\n\\nHence: `val ^ first = second` -> `val = first ^ second`"
                    },
                    {
                        "username": "yjianghong",
                        "content": "Being a previous interviewer in a big tech I\\'m not even certain how this question is applicable since none of our work requires a day in and day out calculation of xor so I cannot expect candidates to remember xor\\'s reverse is also xor. "
                    },
                    {
                        "username": "stealthyjason",
                        "content": "Does anyone know how you would solve this if the length of substring you needed to find can be equal to the length of s? "
                    }
                ]
            }
        ]
    }
]