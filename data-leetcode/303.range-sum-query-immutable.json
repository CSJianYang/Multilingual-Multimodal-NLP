[
    {
        "title": "Range Sum Query - Immutable",
        "question_content": "Given an integer array nums, handle multiple queries of the following type:\n\n\tCalculate the sum of the elements of nums between indices left and right inclusive where left <= right.\n\nImplement the NumArray class:\n\n\tNumArray(int[] nums) Initializes the object with the integer array nums.\n\tint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\n\n&nbsp;\nExample 1:\n\nInput\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-105 <= nums[i] <= 105\n\t0 <= left <= right < nums.length\n\tAt most 104 calls will be made to sumRange.",
        "solutions": [
            {
                "id": 75192,
                "title": "java-simple-o-n-init-and-o-1-query-solution",
                "content": "public class NumArray {\\n\\n    int[] nums;\\n    \\n    public NumArray(int[] nums) {\\n        for(int i = 1; i < nums.length; i++)\\n            nums[i] += nums[i - 1];\\n        \\n        this.nums = nums;\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        if(i == 0)\\n            return nums[j];\\n        \\n        return nums[j] - nums[i - 1];\\n    }\\n}",
                "solutionTags": [],
                "code": "public class NumArray {\\n\\n    int[] nums;\\n    \\n    public NumArray(int[] nums) {\\n        for(int i = 1; i < nums.length; i++)\\n            nums[i] += nums[i - 1];\\n        \\n        this.nums = nums;\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        if(i == 0)\\n            return nums[j];\\n        \\n        return nums[j] - nums[i - 1];\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1406465,
                "title": "c-java-python-prefix-sum-clean-concise-o-1-space",
                "content": "**Idea**\\n- This problem is quite easy since our operations are just query `sumRange` without update values in `nums` on the way (Immutable).\\n- So we just pre-calculated the prefix sum of `nums` array, where `preSum[i]` is sum of `nums[0..i]`, so the result of `sumRange(left, right)` are:\\n\\t- If `left = 0` then return `preSum[right]`\\n\\t- Else return `preSum[right] - preSum[left-1]`.\\n- The advance version of this problem is [307. Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/) where we can update the values in `nums` dynamically (Mutable).\\n\\n<iframe src=\"https://leetcode.com/playground/hqJuDsAL/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\n**Complexity**\\n- Time: \\n\\t- Constructor: O(N)\\n\\t- sumRange(left, right): `O(1)`\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**Idea**\\n- This problem is quite easy since our operations are just query `sumRange` without update values in `nums` on the way (Immutable).\\n- So we just pre-calculated the prefix sum of `nums` array, where `preSum[i]` is sum of `nums[0..i]`, so the result of `sumRange(left, right)` are:\\n\\t- If `left = 0` then return `preSum[right]`\\n\\t- Else return `preSum[right] - preSum[left-1]`.\\n- The advance version of this problem is [307. Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/) where we can update the values in `nums` dynamically (Mutable).\\n\\n<iframe src=\"https://leetcode.com/playground/hqJuDsAL/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\n**Complexity**\\n- Time: \\n\\t- Constructor: O(N)\\n\\t- sumRange(left, right): `O(1)`\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 75184,
                "title": "5-lines-c-4-lines-python",
                "content": "The idea is fairly straightforward: create an array `accu` that stores the accumulated sum for `nums` such that `accu[i] = nums[0] + ... + nums[i - 1]` in the initializer of `NumArray`. Then just return `accu[j + 1] - accu[i]` in `sumRange`. You may try the example in the problem statement to convince yourself of this idea.\\n\\nThe code is as follows.\\n\\n----------\\n**C++**\\n\\n    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) {\\n            accu.push_back(0);\\n            for (int num : nums)\\n                accu.push_back(accu.back() + num);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return accu[j + 1] - accu[i];\\n        }\\n    private:\\n        vector<int> accu;\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2); \\n\\n----------\\n**Python**\\n\\n    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.accu = [0]\\n            for num in nums: \\n                self.accu += self.accu[-1] + num,\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int \\n            :type j: int\\n            :rtype: int \\n            \"\"\"\\n            return self.accu[j + 1] - self.accu[i]\\n    \\n    \\n    # Your NumArray object will be instantiated and called as such:\\n    # numArray = NumArray(nums)\\n    # numArray.sumRange(0, 1)\\n    # numArray.sumRange(1, 2)",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "The idea is fairly straightforward: create an array `accu` that stores the accumulated sum for `nums` such that `accu[i] = nums[0] + ... + nums[i - 1]` in the initializer of `NumArray`. Then just return `accu[j + 1] - accu[i]` in `sumRange`. You may try the example in the problem statement to convince yourself of this idea.\\n\\nThe code is as follows.\\n\\n----------\\n**C++**\\n\\n    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) {\\n            accu.push_back(0);\\n            for (int num : nums)\\n                accu.push_back(accu.back() + num);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return accu[j + 1] - accu[i];\\n        }\\n    private:\\n        vector<int> accu;\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2); \\n\\n----------\\n**Python**\\n\\n    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.accu = [0]\\n            for num in nums: \\n                self.accu += self.accu[-1] + num,\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int \\n            :type j: int\\n            :rtype: int \\n            \"\"\"\\n            return self.accu[j + 1] - self.accu[i]\\n    \\n    \\n    # Your NumArray object will be instantiated and called as such:\\n    # numArray = NumArray(nums)\\n    # numArray.sumRange(0, 1)\\n    # numArray.sumRange(1, 2)",
                "codeTag": "Java"
            },
            {
                "id": 75194,
                "title": "explanation-with-images",
                "content": "\\n![SumQuery](/assets/uploads/files/1503631407822-sumquery-1-resized.jpg) \\n\\nThe Image above represents the following \\nAll these are for the input array [-2,0,3,-5,2,-1]\\nThe inout array and the 0 based index ( highlighted in yellow ) are shown. \\n\\nIdea is to represent this array in a n*n matrix where n is the size of the initial array.\\n\\nThere are 2 ways of doing this representation. Table 1 show one way\\nIn Table 1 , note the following \\n- Diagonal represents the original array. so arr[i][j] = nuts[i]\\n- The values in the next column come from the previous column \\n   row 0, col 0 = Since there is no column before it, nothing to do\\n   row 1, col 1 = This is a diagonal, so we already know its value \\n   row 0, col 1 = row 0 , col 0 + row 1, col1\\n  \\n  row 2, col 2 = Diagonal value , so its same as nums[2]\\n  row 1, col2 = row1,col1 + row2,col2 \\n  row 0,col 2 = row0, col2 + row2, col2\\n\\nYou get the idea \\n\\nHere is the code. \\n\\n```\\n\\n    private int[][] ints;\\n    public NumArray(int[] nums) {\\n        ints = new int[nums.length][nums.length];\\n        populate(nums);\\n    }\\n\\n    private void populate(int[] nums){\\n        for (int i=0; i < nums.length; i++){\\n            ints[i][i] = nums[i];\\n\\n            for (int j= i-1; j >=0; j--){\\n                ints[j][i] = ints[j][i-1] + ints[i][i];\\n            }\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        \\n        return ints[i][j];\\n    }\\n```\\n\\nThe issue is that this uses n*n matrix space and its still a O(n2) due to initial population of array \\n\\nBut, the idea to expand the problem to get a better understanding. Thats how the mind works, right ;)\\n\\nKey thing to notice above are these things \\n1. The table was build from the fact the diagonal has the same values as the input array.\\n2. The table was build bottom up, as in, from the diagonal value to the rows above it and this was done for each column. \\n3. After the n*n matrix is build, take a look at the first row. It sure looks like a cumulative array. Nice!! Now knowing this , we can start to optimize the solution. \\n\\nNext, lets look at TABLE 2\\nBased on the discoveries of TABLE1 , we use those to build table 2\\n1. We know that if we can get a cumulative array , represented by first row, then the rest of the table can be build. \\n2. To build from row 0 to all the other rows, we would have to go top ( row 0 ) to bottom. Do this for every column, like it was done in TABLE 1\\n\\nThe last column in the table shows the example, which follows the following rule \\n\\nrow0 - represents the cumulative array , lets call it cArr\\n\\nval(i,j) = cArr(j) - cArr(i)\\n\\nThats it, this means, that there is no need to build a n*n array if we know the cumulative Array \\n\\nNow the code is easy \\n\\n```\\npublic class NumArray {\\nint[] nums;\\n\\npublic NumArray(int[] nums) {\\n    for(int i = 1; i < nums.length; i++)\\n        nums[i] += nums[i - 1];\\n    \\n    this.nums = nums;\\n}\\n\\npublic int sumRange(int i, int j) {\\n    if(i == 0)\\n        return nums[j];\\n    \\n    return nums[j] - nums[i - 1];\\n}\\n}\\n```\\n\\nI have seen a lot of people post a similar solution for this problem, and they look like geniuses. I spend about 4 hours on this problem from start to finish. Thats a long time and with this article I want to say that, it does take time, initially. So if you are seeing this problem or similar problems and its taking you time to come up with a solution, its ok. Take you time, because with that time, your wirings in the brain are also changing and that change is slow and long process. \\nSecond point I want to make is that, when solving problems like these, expand the problem, even if expansion of the problem is using extra space along with additional time. So expansion of a problem is causing both Time And Space complexity to increase. ... And thats Ok, because with the expansion of the problem, you will discover new things , and you can build on top of those new things a optimal solution. This type of thinking process goes a long way during interviews. \\nImagine if  you got this problem during Google interview. If you start by expanding the problem ... which atleast solves the problem and then you optimize it. I say, you are hired.",
                "solutionTags": [],
                "code": "```\\n\\n    private int[][] ints;\\n    public NumArray(int[] nums) {\\n        ints = new int[nums.length][nums.length];\\n        populate(nums);\\n    }\\n\\n    private void populate(int[] nums){\\n        for (int i=0; i < nums.length; i++){\\n            ints[i][i] = nums[i];\\n\\n            for (int j= i-1; j >=0; j--){\\n                ints[j][i] = ints[j][i-1] + ints[i][i];\\n            }\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        \\n        return ints[i][j];\\n    }\\n```\n```\\npublic class NumArray {\\nint[] nums;\\n\\npublic NumArray(int[] nums) {\\n    for(int i = 1; i < nums.length; i++)\\n        nums[i] += nums[i - 1];\\n    \\n    this.nums = nums;\\n}\\n\\npublic int sumRange(int i, int j) {\\n    if(i == 0)\\n        return nums[j];\\n    \\n    return nums[j] - nums[i - 1];\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75303,
                "title": "c-o-1-queries-just-2-extra-lines-of-code",
                "content": "    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) : psum(nums.size()+1, 0) {\\n            partial_sum( nums.begin(), nums.end(), psum.begin()+1);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return psum[j+1] - psum[i];\\n        }\\n    private:\\n        vector<int> psum;    \\n    };",
                "solutionTags": [],
                "code": "    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) : psum(nums.size()+1, 0) {\\n            partial_sum( nums.begin(), nums.end(), psum.begin()+1);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return psum[j+1] - psum[i];\\n        }\\n    private:\\n        vector<int> psum;    \\n    };",
                "codeTag": "Java"
            },
            {
                "id": 75200,
                "title": "a-very-short-python-solution",
                "content": "    class NumArray(object):\\n        def __init__(self, nums):\\n            self.dp = nums\\n            for i in xrange(1, len(nums)):\\n                self.dp[i] += self.dp[i-1]\\n    \\n        def sumRange(self, i, j):\\n            return self.dp[j] - (self.dp[i-1] if i > 0 else 0)",
                "solutionTags": [],
                "code": "    class NumArray(object):\\n        def __init__(self, nums):\\n            self.dp = nums\\n            for i in xrange(1, len(nums)):\\n                self.dp[i] += self.dp[i-1]\\n    \\n        def sumRange(self, i, j):\\n            return self.dp[j] - (self.dp[i-1] if i > 0 else 0)",
                "codeTag": "Java"
            },
            {
                "id": 597654,
                "title": "easy-to-understand-faster-simple-python-solution",
                "content": "```\\n    def __init__(self, nums: List[int]):\\n        self.sum = []\\n        sum_till = 0\\n        for i in nums:\\n            sum_till += i\\n            self.sum.append(sum_till)\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        if i > 0 and j > 0:\\n            return self.sum[j] - self.sum[i - 1]\\n        else:\\n            return self.sum[i or j]\\n        \\n\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def __init__(self, nums: List[int]):\\n        self.sum = []\\n        sum_till = 0\\n        for i in nums:\\n            sum_till += i\\n            self.sum.append(sum_till)\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        if i > 0 and j > 0:\\n            return self.sum[j] - self.sum[i - 1]\\n        else:\\n            return self.sum[i or j]\\n        \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1406509,
                "title": "range-sum-query-immutable-prefix-sum-c-python-java",
                "content": "**SOLUTION**\\n`In C++`\\n```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i = 1; i < nums.size(); i++)\\n            vec[i] = nums[i] + vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j] - vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```\\n`In Python3`\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.preSum = nums\\n        for i in range(len(nums)-1):\\n            self.preSum[i+1] += self.preSum[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0: return self.preSum[right]\\n        return self.preSum[right] - self.preSum[left-1]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```\\n`In JAVA`\\n```\\nclass NumArray {\\n    int[] sum ;\\n    public NumArray(int[] nums) {\\n        sum = new int[nums.length];\\n        sum[0]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            sum[i]=sum[i-1]+nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left==0)\\n            return sum[right];\\n        return sum[right]-sum[left-1];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```\\n**Complexity**\\n* Time:\\n\\t* Constructor: O(N) \\n\\t* sumRange(left, right): O(1)\\n* Space: O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i = 1; i < nums.size(); i++)\\n            vec[i] = nums[i] + vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j] - vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.preSum = nums\\n        for i in range(len(nums)-1):\\n            self.preSum[i+1] += self.preSum[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0: return self.preSum[right]\\n        return self.preSum[right] - self.preSum[left-1]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```\n```\\nclass NumArray {\\n    int[] sum ;\\n    public NumArray(int[] nums) {\\n        sum = new int[nums.length];\\n        sum[0]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            sum[i]=sum[i-1]+nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left==0)\\n            return sum[right];\\n        return sum[right]-sum[left-1];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406464,
                "title": "python-accumulate-oneliner-explained",
                "content": "In this problem we are given tha our nums are immutable, that is we do not need to support operation for changing them. So, what we need to do is to precalculate some information, such that we can quickly compute sums in range. This information is cumulative sums: if we calculate all of them we can compute sum in any range as difference of two cumulative sums.\\n\\n#### Complexity\\nIt is just `O(n)` for time and space for initialization and `O(1)` time and space for query.\\n\\n#### Code\\n```python\\nclass NumArray:\\n    def __init__(self, nums):\\n        self.arr = [0] + list(accumulate(nums))\\n        \\n    def sumRange(self, left, right):\\n        return self.arr[right + 1] - self.arr[left]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass NumArray:\\n    def __init__(self, nums):\\n        self.arr = [0] + list(accumulate(nums))\\n        \\n    def sumRange(self, left, right):\\n        return self.arr[right + 1] - self.arr[left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494994,
                "title": "java-tc-init-o-n-sumrange-o-1-using-prefix-sum",
                "content": "```java\\n/**\\n * Using a prefix sum array\\n *\\n * prefixSum[i] = prefixSum[i-1] + nums[i-1]. Length of prefixSum array is 1 +\\n * length of input array.\\n *\\n * sumRange(1,3) = prefixSum[3+1] - prefixSum[1]\\n *\\n * Time Complexity: NumArray() -> O(N). sumRange() -> O(1)\\n *\\n * Space Complexity: O(N) (Can be O(1) if allowed to modify nums array)\\n *\\n * N = Length of input array.\\n */\\nclass NumArray {\\n\\n    int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left < 0 || right >= prefixSum.length - 1) {\\n            throw new IndexOutOfBoundsException(\"Input indices are out of bounds\");\\n        }\\n\\n        // Here both left and right are inclusive.\\n        // right maps to right+1 in prefixSum. left maps to left+1 in prefixSum.\\n        // To get the result subtract the prefixSum before left index from prefixSum at\\n        // right index.\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```java\\n/**\\n * Using a prefix sum array\\n *\\n * prefixSum[i] = prefixSum[i-1] + nums[i-1]. Length of prefixSum array is 1 +\\n * length of input array.\\n *\\n * sumRange(1,3) = prefixSum[3+1] - prefixSum[1]\\n *\\n * Time Complexity: NumArray() -> O(N). sumRange() -> O(1)\\n *\\n * Space Complexity: O(N) (Can be O(1) if allowed to modify nums array)\\n *\\n * N = Length of input array.\\n */\\nclass NumArray {\\n\\n    int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left < 0 || right >= prefixSum.length - 1) {\\n            throw new IndexOutOfBoundsException(\"Input indices are out of bounds\");\\n        }\\n\\n        // Here both left and right are inclusive.\\n        // right maps to right+1 in prefixSum. left maps to left+1 in prefixSum.\\n        // To get the result subtract the prefixSum before left index from prefixSum at\\n        // right index.\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75190,
                "title": "my-java-3ms-solution",
                "content": "    public class NumArray {\\n        private int[] sums;\\n    \\n        public NumArray(int[] nums) {\\n            if(nums.length != 0){\\n                sums = new int[nums.length];\\n            \\n                sums[0] = nums[0];\\n                for(int i=1; i<nums.length; i++){\\n                    sums[i] = nums[i] + sums[i-1];\\n                }\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            return i==0 ? sums[j] : sums[j]-sums[i-1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class NumArray {\\n        private int[] sums;\\n    \\n        public NumArray(int[] nums) {\\n            if(nums.length != 0){\\n                sums = new int[nums.length];\\n            \\n                sums[0] = nums[0];\\n                for(int i=1; i<nums.length; i++){\\n                    sums[i] = nums[i] + sums[i-1];\\n                }\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            return i==0 ? sums[j] : sums[j]-sums[i-1];\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 75308,
                "title": "javascript-solution",
                "content": "    function NumArray(nums) {\\n      this.sums = [];\\n      var sum = 0;\\n      for (var i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        this.sums.push(sum);\\n      }\\n    }\\n    \\n    NumArray.prototype.sumRange = function(i, j) {\\n      return this.sums[j] - (i > 0 ? this.sums[i - 1] : 0);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function NumArray(nums) {\\n      this.sums = [];\\n      var sum = 0;\\n      for (var i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        this.sums.push(sum);\\n      }\\n    }\\n    \\n    NumArray.prototype.sumRange = function(i, j) {\\n      return this.sums[j] - (i > 0 ? this.sums[i - 1] : 0);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 75278,
                "title": "my-3ms-clean-java-dp-solution-may-help-u",
                "content": "    public class NumArray {\\n        \\n        private static int[] sum;\\n    \\n    \\tpublic NumArray(int[] nums) {\\n    \\t\\tfor (int i = 1; i < nums.length; ++i)\\n    \\t\\t\\tnums[i] += nums[i - 1];\\n    \\t\\tthis.sum = nums;\\n    \\t}\\n    \\n    \\tpublic int sumRange(int i, int j) {\\n    \\t\\treturn sum[j] - (i == 0 ? 0 : sum[i - 1]);\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public class NumArray {\\n        \\n        private static int[] sum;\\n    \\n    \\tpublic NumArray(int[] nums) {\\n    \\t\\tfor (int i = 1; i < nums.length; ++i)\\n    \\t\\t\\tnums[i] += nums[i - 1];\\n    \\t\\tthis.sum = nums;\\n    \\t}\\n    \\n    \\tpublic int sumRange(int i, int j) {\\n    \\t\\treturn sum[j] - (i == 0 ? 0 : sum[i - 1]);\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 75314,
                "title": "solutions-using-binary-indexed-tree-and-segment-tree",
                "content": " Binary Indexed Tree, O(lgn) modify, O(lgn) query\\n\\n    public class NumArray {\\n        \\n        int[] tree;\\n        \\n        public NumArray(int[] nums) {\\n            tree = new int[nums.length + 1];\\n            for (int i = 0; i < nums.length; i++) {\\n                int j = i + 1;\\n                while (j < nums.length + 1) {\\n                    tree[j] += nums[i];\\n                    j += lowBit(j);\\n                }\\n            }\\n        }\\n        \\n        public int sumRange(int i, int j) {\\n            return getSum(j + 1) - getSum(i);\\n        }\\n        \\n        private int getSum(int i) {\\n            int sum = 0;\\n            while (i > 0) {\\n                sum += tree[i];\\n                i -= lowBit(i);\\n            }\\n            return sum;\\n        }\\n        \\n        private int lowBit(int x) {\\n            return x&(-x);\\n        }\\n    }\\n\\n\\nSegment Tree, O(n) build, O(lgn) modify, O(lgn) query\\n\\n    public class NumArray {\\n    \\n        SegmentTreeNode root;\\n        public NumArray(int[] nums) {\\n            if (nums.length == 0) return;\\n            root = buildTree(nums, 0, nums.length - 1);\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            return query(root, i, j);\\n        }\\n        \\n        private int query(SegmentTreeNode node, int start, int end) {\\n            int mid = node.start + ((node.end - node.start) >> 1);\\n            if (start <= node.start && end >= node.end) {\\n                return node.sum;\\n            } else if (end <= mid) {\\n                return query(node.left, start, end);\\n            } else if (start > mid) {\\n                return query(node.right, start, end);\\n            } else if (start <= mid && end > mid) {\\n                return query(node.left, start, mid) + query(node.right, mid + 1, end);\\n            }\\n            return 0;\\n        }\\n        \\n        private SegmentTreeNode buildTree(int[] nums, int l, int r) {\\n            if (l == r) {\\n                return new SegmentTreeNode(l, r, nums[l]);\\n            }\\n            int mid = l + ((r - l) >> 1);\\n            SegmentTreeNode leftNode = buildTree(nums, l, mid);\\n            SegmentTreeNode rightNode = buildTree(nums, mid + 1, r);\\n            SegmentTreeNode node = new SegmentTreeNode(l, r, leftNode.sum + rightNode.sum);\\n            node.left = leftNode;\\n            node.right = rightNode;\\n            return node;\\n        }\\n        \\n        class SegmentTreeNode {\\n            int start, end, sum;\\n            SegmentTreeNode left, right;\\n            public SegmentTreeNode(int s, int e, int val) {\\n                start = s;\\n                end = e;\\n                sum = val;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": " Binary Indexed Tree, O(lgn) modify, O(lgn) query\\n\\n    public class NumArray {\\n        \\n        int[] tree;\\n        \\n        public NumArray(int[] nums) {\\n            tree = new int[nums.length + 1];\\n            for (int i = 0; i < nums.length; i++) {\\n                int j = i + 1;\\n                while (j < nums.length + 1) {\\n                    tree[j] += nums[i];\\n                    j += lowBit(j);\\n                }\\n            }\\n        }\\n        \\n        public int sumRange(int i, int j) {\\n            return getSum(j + 1) - getSum(i);\\n        }\\n        \\n        private int getSum(int i) {\\n            int sum = 0;\\n            while (i > 0) {\\n                sum += tree[i];\\n                i -= lowBit(i);\\n            }\\n            return sum;\\n        }\\n        \\n        private int lowBit(int x) {\\n            return x&(-x);\\n        }\\n    }\\n\\n\\nSegment Tree, O(n) build, O(lgn) modify, O(lgn) query\\n\\n    public class NumArray {\\n    \\n        SegmentTreeNode root;\\n        public NumArray(int[] nums) {\\n            if (nums.length == 0) return;\\n            root = buildTree(nums, 0, nums.length - 1);\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            return query(root, i, j);\\n        }\\n        \\n        private int query(SegmentTreeNode node, int start, int end) {\\n            int mid = node.start + ((node.end - node.start) >> 1);\\n            if (start <= node.start && end >= node.end) {\\n                return node.sum;\\n            } else if (end <= mid) {\\n                return query(node.left, start, end);\\n            } else if (start > mid) {\\n                return query(node.right, start, end);\\n            } else if (start <= mid && end > mid) {\\n                return query(node.left, start, mid) + query(node.right, mid + 1, end);\\n            }\\n            return 0;\\n        }\\n        \\n        private SegmentTreeNode buildTree(int[] nums, int l, int r) {\\n            if (l == r) {\\n                return new SegmentTreeNode(l, r, nums[l]);\\n            }\\n            int mid = l + ((r - l) >> 1);\\n            SegmentTreeNode leftNode = buildTree(nums, l, mid);\\n            SegmentTreeNode rightNode = buildTree(nums, mid + 1, r);\\n            SegmentTreeNode node = new SegmentTreeNode(l, r, leftNode.sum + rightNode.sum);\\n            node.left = leftNode;\\n            node.right = rightNode;\\n            return node;\\n        }\\n        \\n        class SegmentTreeNode {\\n            int start, end, sum;\\n            SegmentTreeNode left, right;\\n            public SegmentTreeNode(int s, int e, int val) {\\n                start = s;\\n                end = e;\\n                sum = val;\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1406518,
                "title": "c-easy-clean-solution-using-prefix-sums",
                "content": "**Solution:**\\n\\nApproach\\n1. First calculate prefix sums array for the given array `nums`.\\n2. Now, your task is to find sum of elements from `left to right`.\\n3. If `left == 0`, means we need to directly return sum at the index `pref[right]`.\\n4. Otherwise, just return the difference of sums at `pref[right] - pref[left - 1]`.\\n\\nExample:\\n`ar = [-2, 0, 3, -5, 2, -1]`\\n`range = [0, 2], [2, 5]`\\n\\n`Prefix Sums Array = [-2,-2,1,-4,-2,-3]`\\n\\n`Output:`\\nFor query 1, `left == 0`, return prefix sum at index right. `Print pref[2] = 1`\\nFor query 2, `left != 0`, return pref[right] - pref[left - 1]. `Print pref[5] - pref[1] = -1`\\n\\n```\\nclass NumArray {\\npublic:\\n    vector<int> pref;\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tpref.clear();\\n        for(int i = 0; i < n; i++){\\n            if(i == 0)\\n                pref.push_back(nums[i]);\\n            else\\n                pref.push_back(nums[i] + pref[i - 1]);\\n        }\\n    }  \\n    int sumRange(int left, int right) {\\n        if(left == 0)\\n            return pref[right];\\n        return pref[right] - pref[left - 1]; \\n    }\\n};\\n```\\n\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> pref;\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tpref.clear();\\n        for(int i = 0; i < n; i++){\\n            if(i == 0)\\n                pref.push_back(nums[i]);\\n            else\\n                pref.push_back(nums[i] + pref[i - 1]);\\n        }\\n    }  \\n    int sumRange(int left, int right) {\\n        if(left == 0)\\n            return pref[right];\\n        return pref[right] - pref[left - 1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75315,
                "title": "c-simple-solution-o-n-to-build-o-1-to-query",
                "content": "Use a vector to store the sum from 0 to i.\\n\\n    class NumArray {\\n    public:\\n        vector<int> memo = {0};\\n        NumArray(vector<int> &nums) {\\n            int summ = 0;\\n            for (int n : nums) {\\n                summ += n;\\n                memo.push_back(summ);\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return memo[j+1] - memo[i];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "Use a vector to store the sum from 0 to i.\\n\\n    class NumArray {\\n    public:\\n        vector<int> memo = {0};\\n        NumArray(vector<int> &nums) {\\n            int summ = 0;\\n            for (int n : nums) {\\n                summ += n;\\n                memo.push_back(summ);\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return memo[j+1] - memo[i];\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 75309,
                "title": "java-solution-using-sum-array-built-in-constructor",
                "content": "    public class NumArray {\\n        int[] sum;\\n        public NumArray(int[] nums) {\\n            sum = new int[nums.length];\\n            if(nums.length>0)sum[0]=nums[0];\\n            for(int i=1; i<nums.length; i++){\\n                sum[i]=sum[i-1]+nums[i];\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            if(i==0)return sum[j];\\n            return sum[j]-sum[i-1];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public class NumArray {\\n        int[] sum;\\n        public NumArray(int[] nums) {\\n            sum = new int[nums.length];\\n            if(nums.length>0)sum[0]=nums[0];\\n            for(int i=1; i<nums.length; i++){\\n                sum[i]=sum[i-1]+nums[i];\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            if(i==0)return sum[j];\\n            return sum[j]-sum[i-1];\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2381014,
                "title": "short-and-simple-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar NumArray = function(nums) {\\n    this.nums = nums;\\n};\\n\\nNumArray.prototype.sumRange = function(left, right) {\\n    let sum = 0;\\n    for(let i = left; i <= right; i++) sum += this.nums[i]\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar NumArray = function(nums) {\\n    this.nums = nums;\\n};\\n\\nNumArray.prototype.sumRange = function(left, right) {\\n    let sum = 0;\\n    for(let i = left; i <= right; i++) sum += this.nums[i]\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511735,
                "title": "python-js-go-c-by-prefix-sum-with-explanation",
                "content": "Python sol. with O(n) init, O(1) query by prefix sum. \\n\\n[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/6511745dfd89780001d072c3)\\n\\n[\\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247\\nTutorial video in Chinese](https://youtu.be/HHFnsTqE2sA)\\n\\n---\\n\\nHint:\\n#1.\\nThink of the concept of dynamic programming, and **look-up table**.\\n\\n#2.\\nSince **input array**, *nums*, is **immutable**, we can build a **prefix sum table** to **speed up range sum query** later.\\n\\n---\\n\\nRecurrence relationship:\\nLet *S* denotes the **prefix sum table**\\n*S*[ *0* ] = *nums*[ *0* ]\\n*S*[ *i* ] = *S*[ *i - 1* ] + *nums*[ *i* ] for every *i* = 1, 2, 3, ..., n\\n\\nRange sum Query:\\nQuery( *i*, *j* ) = *S*[ *j* ], if *i* =0\\nQuery( *i*, *j* ) = *S*[ *j* ] - *S*[ *i* -1 ], otherwise.\\n\\n---\\n\\nAlgorithm:\\n\\nStep_#1:\\nBuild the prefix sum table based on recurrence relationship, during initialization in O(n).\\n\\nStep_#2:\\nHandle incoming range sum query by index lookup in prefix sum table, in O(1).\\n\\n---\\n\\n\\n```Python []\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        \\n        self.size = len(nums)\\n        \\n\\n        # build prefix sum table when input nums is valid\\n        self.s = [ 0 for _ in range(self.size) ]\\n\\n        self.s[0] = nums[0]\\n\\n        # s[k] = nums[0] + ... + nums[k]\\n        # s[k] = s[k-1] + nums[k]\\n        for k in range(1,self.size):\\n            self.s[k] = self.s[ k-1 ] + nums[ k ]\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        \\n\\n        # lookup table from prefix sum table, s\\n        if left == 0:\\n            return self.s[ right ]\\n        else:\\n            return self.s[ right ]-self.s[ left-1 ]\\n```\\n```Javascript []\\nvar NumArray = function(nums) {\\n    \\n    this.size = nums.length;\\n    this.prefixSum = Array( nums.legnth ).fill( 0 );\\n    \\n    this.prefixSum[0] = nums[0];\\n    \\n    for( let i = 1; i < this.size ; i++ ){\\n        this.prefixSum[i] = this.prefixSum[i-1] + nums[i];\\n    }\\n    \\n    \\n};\\n\\n/** \\n * @param {number} left \\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(left, right) {\\n    \\n    // lookup table from prefixSum\\n    if( left == 0 ){\\n        return this.prefixSum[right];\\n    }else{\\n        return this.prefixSum[right] - this.prefixSum[left-1];\\n    }\\n    \\n    \\n};\\n```\\n```Go []\\ntype NumArray struct {\\n    size int;\\n    prefixTable []int;\\n}\\n\\n\\nfunc Constructor(nums []int) NumArray {\\n    \\n    numArray := new(NumArray)\\n    \\n    numArray.size = len(nums)\\n    \\n    // build prefix sum table\\n    numArray.prefixTable = make( []int, len(nums) )\\n    \\n    numArray.prefixTable[0] = nums[0]\\n    \\n    for k := 1 ; k < numArray.size ; k++{\\n        numArray.prefixTable[k] = numArray.prefixTable[k-1] + nums[k]\\n    }\\n    \\n    return *numArray\\n}\\n\\n\\nfunc (this *NumArray) SumRange(left int, right int) int {\\n    \\n    if left == 0 {\\n        return this.prefixTable[right]\\n    }else{\\n        return this.prefixTable[right] - this.prefixTable[left-1]\\n    }\\n    \\n}\\n```\\n```C++ []\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        size = nums.size();\\n        \\n        // build prefix sum table \\n        prefixSum = vector<int>(size, 0);\\n\\n        prefixSum[0] = nums[0];\\n\\n        for( int k = 1; k < size ; k++){\\n            prefixSum[k] = prefixSum[k-1] + nums[k];\\n        }\\n\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        \\n        // lookup table from prefixSum\\n        if( left == 0 ){\\n            return prefixSum[right];\\n        \\n        }else{\\n            return prefixSum[right] - prefixSum[left-1];    \\n        }\\n        \\n    }\\nprivate:\\n    int size;\\n    vector<int> prefixSum;\\n};\\n```\\n\\n---\\n\\nComplexity analysis:\\n\\nTime complexity: O(n)\\nO(n) : building of prefix sum table, s.\\n\\nO(1) : each single range sum query.\\n\\n---\\n\\nSpace complexity: O(n)\\n\\nO(n) : size of prefix sum table, s.\\n\\n\\n---\\n\\nReference:\\n\\n[1] [OpenGenius: Prefix sum array](https://iq.opengenus.org/prefix-sum-array/)\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #304 Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/)\\n\\n[Leetcode #1352 Product of the Last K Numbers](https://leetcode.com/problems/product-of-the-last-k-numbers/)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```Python []\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        \\n        self.size = len(nums)\\n        \\n\\n        # build prefix sum table when input nums is valid\\n        self.s = [ 0 for _ in range(self.size) ]\\n\\n        self.s[0] = nums[0]\\n\\n        # s[k] = nums[0] + ... + nums[k]\\n        # s[k] = s[k-1] + nums[k]\\n        for k in range(1,self.size):\\n            self.s[k] = self.s[ k-1 ] + nums[ k ]\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        \\n\\n        # lookup table from prefix sum table, s\\n        if left == 0:\\n            return self.s[ right ]\\n        else:\\n            return self.s[ right ]-self.s[ left-1 ]\\n```\n```Javascript []\\nvar NumArray = function(nums) {\\n    \\n    this.size = nums.length;\\n    this.prefixSum = Array( nums.legnth ).fill( 0 );\\n    \\n    this.prefixSum[0] = nums[0];\\n    \\n    for( let i = 1; i < this.size ; i++ ){\\n        this.prefixSum[i] = this.prefixSum[i-1] + nums[i];\\n    }\\n    \\n    \\n};\\n\\n/** \\n * @param {number} left \\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(left, right) {\\n    \\n    // lookup table from prefixSum\\n    if( left == 0 ){\\n        return this.prefixSum[right];\\n    }else{\\n        return this.prefixSum[right] - this.prefixSum[left-1];\\n    }\\n    \\n    \\n};\\n```\n```Go []\\ntype NumArray struct {\\n    size int;\\n    prefixTable []int;\\n}\\n\\n\\nfunc Constructor(nums []int) NumArray {\\n    \\n    numArray := new(NumArray)\\n    \\n    numArray.size = len(nums)\\n    \\n    // build prefix sum table\\n    numArray.prefixTable = make( []int, len(nums) )\\n    \\n    numArray.prefixTable[0] = nums[0]\\n    \\n    for k := 1 ; k < numArray.size ; k++{\\n        numArray.prefixTable[k] = numArray.prefixTable[k-1] + nums[k]\\n    }\\n    \\n    return *numArray\\n}\\n\\n\\nfunc (this *NumArray) SumRange(left int, right int) int {\\n    \\n    if left == 0 {\\n        return this.prefixTable[right]\\n    }else{\\n        return this.prefixTable[right] - this.prefixTable[left-1]\\n    }\\n    \\n}\\n```\n```C++ []\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        size = nums.size();\\n        \\n        // build prefix sum table \\n        prefixSum = vector<int>(size, 0);\\n\\n        prefixSum[0] = nums[0];\\n\\n        for( int k = 1; k < size ; k++){\\n            prefixSum[k] = prefixSum[k-1] + nums[k];\\n        }\\n\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        \\n        // lookup table from prefixSum\\n        if( left == 0 ){\\n            return prefixSum[right];\\n        \\n        }else{\\n            return prefixSum[right] - prefixSum[left-1];    \\n        }\\n        \\n    }\\nprivate:\\n    int size;\\n    vector<int> prefixSum;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75265,
                "title": "java-concise-solution-without-if",
                "content": "    public class NumArray {\\n\\t\\n\\tint[] table;\\n\\n    public NumArray(int[] nums) {\\n        int sum = 0;\\n        table = new int[nums.length + 1];\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n        \\tsum = sum + nums[i];\\n        \\ttable[i + 1] = sum;\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return table[j + 1] - table[i];\\n    }\\n    }",
                "solutionTags": [],
                "code": "    public class NumArray {\\n\\t\\n\\tint[] table;\\n\\n    public NumArray(int[] nums) {\\n        int sum = 0;\\n        table = new int[nums.length + 1];\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n        \\tsum = sum + nums[i];\\n        \\ttable[i + 1] = sum;\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return table[j + 1] - table[i];\\n    }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3398350,
                "title": "range-sum-query-immutable-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass NumArray {\\npublic:\\n    vector<int> arr;\\n    NumArray(vector<int>& nums) {\\n        arr.push_back(nums[0]);\\n        for(int i=1 ; i<nums.size() ; i++)\\n        {\\n            arr.push_back(nums[i]+arr[i-1]);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n            return arr[right];\\n        else\\n            return arr[right]-arr[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> arr;\\n    NumArray(vector<int>& nums) {\\n        arr.push_back(nums[0]);\\n        for(int i=1 ; i<nums.size() ; i++)\\n        {\\n            arr.push_back(nums[i]+arr[i-1]);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n            return arr[right];\\n        else\\n            return arr[right]-arr[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406906,
                "title": "easy-c-solution-prefix-sum",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int> a;\\n    NumArray(vector<int>& nums) {\\n        for(int i = 0;i < (int)nums.size(); i++){\\n            if(i==0)a.push_back(nums[i]);\\n            else a.push_back(nums[i]+a.back());\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int v = a[right];\\n        if(left == 0)return v;\\n        return v-a[left-1];\\n        \\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```\\n**Questions/ Discussions are welcome.**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> a;\\n    NumArray(vector<int>& nums) {\\n        for(int i = 0;i < (int)nums.size(); i++){\\n            if(i==0)a.push_back(nums[i]);\\n            else a.push_back(nums[i]+a.back());\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int v = a[right];\\n        if(left == 0)return v;\\n        return v-a[left-1];\\n        \\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187825,
                "title": "python-4-liner",
                "content": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n        for i in range(1, len(nums)):\\n            self.nums[i] += self.nums[i - 1]\\n        \\n\\n    def sumRange(self, i, j):\\n        return self.nums[j] - self.nums[i - 1] if i else self.nums[j]\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n        for i in range(1, len(nums)):\\n            self.nums[i] += self.nums[i - 1]\\n        \\n\\n    def sumRange(self, i, j):\\n        return self.nums[j] - self.nums[i - 1] if i else self.nums[j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75258,
                "title": "beat-100-c-solution",
                "content": "\\n\\nclass NumArray {\\n\\n    private:\\n    vector<int> data;\\npublic:\\n    \\n    NumArray(vector<int> &nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            data.push_back(sum);\\n        }\\n    }\\n\\n    int sumRange(int i, int j) {\\n        if(i==0)\\n            return data[j];\\n        else\\n            return data[j]-data[i-1];\\n    }\\n};\\n\\n\\n// Your NumArray object will be instantiated and called as such:\\n// NumArray numArray(nums);\\n// numArray.sumRange(0, 1);\\n// numArray.sumRange(1, 2);",
                "solutionTags": [],
                "code": "\\n\\nclass NumArray {\\n\\n    private:\\n    vector<int> data;\\npublic:\\n    \\n    NumArray(vector<int> &nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            data.push_back(sum);\\n        }\\n    }\\n\\n    int sumRange(int i, int j) {\\n        if(i==0)\\n            return data[j];\\n        else\\n            return data[j]-data[i-1];\\n    }\\n};\\n\\n\\n// Your NumArray object will be instantiated and called as such:\\n// NumArray numArray(nums);\\n// numArray.sumRange(0, 1);\\n// numArray.sumRange(1, 2);",
                "codeTag": "Java"
            },
            {
                "id": 75266,
                "title": "simple-python-solution-use-dict",
                "content": "    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.dc = {-1:0}\\n            for i,v in enumerate(nums):\\n                self.dc[i] = self.dc[i-1] + v\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int\\n            :type j: int\\n            :rtype: int\\n            \"\"\"\\n            return self.dc[j]-self.dc[i-1]",
                "solutionTags": [],
                "code": "    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.dc = {-1:0}\\n            for i,v in enumerate(nums):\\n                self.dc[i] = self.dc[i-1] + v\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int\\n            :type j: int\\n            :rtype: int\\n            \"\"\"\\n            return self.dc[j]-self.dc[i-1]",
                "codeTag": "Java"
            },
            {
                "id": 2129952,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Java ***\\n\\n```\\n\\n/**\\n * Using a prefix sum array\\n *\\n * prefixSum[i] = prefixSum[i-1] + nums[i-1]. Length of prefixSum array is 1 +\\n * length of input array.\\n *\\n * sumRange(1,3) = prefixSum[3+1] - prefixSum[1]\\n *\\n * Time Complexity: NumArray() -> O(N). sumRange() -> O(1)\\n *\\n * Space Complexity: O(N) (Can be O(1) if allowed to modify nums array)\\n *\\n * N = Length of input array.\\n */\\nclass NumArray {\\n\\n    int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left < 0 || right >= prefixSum.length - 1) {\\n            throw new IndexOutOfBoundsException(\"Input indices are out of bounds\");\\n        }\\n\\n        // Here both left and right are inclusive.\\n        // right maps to right+1 in prefixSum. left maps to left+1 in prefixSum.\\n        // To get the result subtract the prefixSum before left index from prefixSum at\\n        // right index.\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\n/**\\n * Using a prefix sum array\\n *\\n * prefixSum[i] = prefixSum[i-1] + nums[i-1]. Length of prefixSum array is 1 +\\n * length of input array.\\n *\\n * sumRange(1,3) = prefixSum[3+1] - prefixSum[1]\\n *\\n * Time Complexity: NumArray() -> O(N). sumRange() -> O(1)\\n *\\n * Space Complexity: O(N) (Can be O(1) if allowed to modify nums array)\\n *\\n * N = Length of input array.\\n */\\nclass NumArray {\\n\\n    int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left < 0 || right >= prefixSum.length - 1) {\\n            throw new IndexOutOfBoundsException(\"Input indices are out of bounds\");\\n        }\\n\\n        // Here both left and right are inclusive.\\n        // right maps to right+1 in prefixSum. left maps to left+1 in prefixSum.\\n        // To get the result subtract the prefixSum before left index from prefixSum at\\n        // right index.\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75286,
                "title": "java-easy-version-to-understand",
                "content": "        int[] nums;\\n\\tint[] sum;\\n\\n\\tpublic NumArray(int[] nums) {\\n\\t    if(nums==null||nums.length==0)\\n\\t    return;\\n\\t\\tthis.nums = nums;\\n\\t\\tint len = nums.length;\\n\\t\\tsum = new int[len];\\n\\t\\tsum[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tsum[i] = sum[i - 1] + nums[i];\\n\\t}\\n\\n\\tpublic int sumRange(int i, int j) {\\n\\n\\t\\treturn sum[j] - sum[i] + nums[i];\\n\\t}",
                "solutionTags": [],
                "code": "        int[] nums;\\n\\tint[] sum;\\n\\n\\tpublic NumArray(int[] nums) {\\n\\t    if(nums==null||nums.length==0)\\n\\t    return;\\n\\t\\tthis.nums = nums;\\n\\t\\tint len = nums.length;\\n\\t\\tsum = new int[len];\\n\\t\\tsum[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tsum[i] = sum[i - 1] + nums[i];\\n\\t}\\n\\n\\tpublic int sumRange(int i, int j) {\\n\\n\\t\\treturn sum[j] - sum[i] + nums[i];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3585378,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray {\\npublic:\\nvector<int>a;\\n    NumArray(vector<int>& nums) {\\n        a.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        a.push_back(nums[i]+a[i-1]);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0 )\\n        return a[right];\\n        \\n        return a[right]-a[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\nvector<int>a;\\n    NumArray(vector<int>& nums) {\\n        a.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        a.push_back(nums[i]+a[i-1]);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0 )\\n        return a[right];\\n        \\n        return a[right]-a[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406467,
                "title": "c-simple-and-clean-explained-solution-o-1-query",
                "content": "**Idea:**\\nWe create an array to keep the accumulated sum for nums.\\nThe array looks like this: vec[i] = nums[0] + nums[1] + ... + nums[i].\\nThen, for the query [i, j], we just return vec[j] - vec[i-1].\\n**Example:**\\nnums = [-2, 0, 3, -5, 2, -1]\\nvec = [-2, -2, 1, -4, -2, -3]\\nquery = [2, 5]: (-3) - (-2) = -1\\n```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i = 1; i < nums.size(); i++)\\n            vec[i] = nums[i] + vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j] - vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i = 1; i < nums.size(); i++)\\n            vec[i] = nums[i] + vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j] - vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223399,
                "title": "easiest-python-solution",
                "content": "\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)",
                "codeTag": "Java"
            },
            {
                "id": 3439382,
                "title": "java",
                "content": "# Code\\n```\\nclass NumArray {\\n    private int[] sumArray;\\n    public NumArray(int[] nums) {\\n        sumArray = new int[nums.length + 1];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            sumArray[i + 1] = sumArray[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return sumArray[right + 1] - sumArray[left];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    private int[] sumArray;\\n    public NumArray(int[] nums) {\\n        sumArray = new int[nums.length + 1];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            sumArray[i + 1] = sumArray[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return sumArray[right + 1] - sumArray[left];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238729,
                "title": "303-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We define a NumArray class with two methods: __init__ and sumRange.\\n- In __init__, we compute the prefix sums of the input nums array and store them in a prefix_sum list. We initialize the prefix_sum list with 0\\'s and then loop through nums, adding each element to the corresponding index in prefix_sum. This gives us the cumulative sum up to each index in nums. Note that we add an extra 0 to the beginning of prefix_sum to simplify the code for sumRange.\\n- In sumRange, we return the sum of the elements between left and right by subtracting the prefix sums at left and right+1. This is because prefix_sum[right+1] gives us the sum of the elements up to index right, while prefix_sum[left] gives us the sum of the elements up to index left-1. By subtracting these two values, we get the sum of the elements between left and right.\\n\\nThis solution has a time complexity of O(1) for each call to sumRange, since we only need to perform two constant-time operations: two lookups in the prefix_sum list and a subtraction. The space complexity is O(n), where n is the length of the input array, since we need to store the prefix_sum list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] * (len(nums) + 1)\\n        for i in range(len(nums)):\\n            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Design",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] * (len(nums) + 1)\\n        for i in range(len(nums)):\\n            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407777,
                "title": "simple-python-approach-brute-force-prefix-sum",
                "content": "The initial idea I got after understanding the way was to brute force my way through it. This included using the array provided and returning the sum of the elements.\\n```\\nclass NumArray(object):\\n    def __init__(self, nums):\\n        self.arr=nums\\n\\n    def sumRange(self, left, right):\\n        return(sum(self.arr[left:right+1]))\\n```\\nAfter the solution passed I noticed that the execution time was really high and there must be a way to solve this question in O(1) time. A concept synonymous with addition in an array is \\' prefix sum\\' . \\n\\n The overall time complexity will be greatly reduced as only the \\'__init__\\' function will need a O(N) time complexity for creation , while the \\'sumRange\\' function being called multiple times will have O(1) time.\\n \\n Here is the implementation with comments:\\n```\\nclass NumArray(object):\\n    def __init__(self, nums):\\n        l=[nums[0]] #store first element of the array to start prefix sum\\n        for i in range(1,len(nums)):\\n            l.append(l[i-1]+nums[i]) #implement prefix sum for each element\\n        self.arr=l       \\n\\n    def sumRange(self, left, right):\\n        if(left!=0): #Apply the logic of prefix sum to get the sum of elements between and including left and right.\\n            return(self.arr[right]-self.arr[left-1]) \\n        else: #in case left is 0,the sum in the \\'right\\' position will give the total sum required\\n            return(self.arr[right])\\n```\\nDo leave an **upvote** if you found my way of thinking useful! Thank you for the reading my first post on leetcode.",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray(object):\\n    def __init__(self, nums):\\n        self.arr=nums\\n\\n    def sumRange(self, left, right):\\n        return(sum(self.arr[left:right+1]))\\n```\n```\\nclass NumArray(object):\\n    def __init__(self, nums):\\n        l=[nums[0]] #store first element of the array to start prefix sum\\n        for i in range(1,len(nums)):\\n            l.append(l[i-1]+nums[i]) #implement prefix sum for each element\\n        self.arr=l       \\n\\n    def sumRange(self, left, right):\\n        if(left!=0): #Apply the logic of prefix sum to get the sum of elements between and including left and right.\\n            return(self.arr[right]-self.arr[left-1]) \\n        else: #in case left is 0,the sum in the \\'right\\' position will give the total sum required\\n            return(self.arr[right])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309366,
                "title": "simple-and-concise-c-solution",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        int n=nums.size();\\n        v.resize(n);\\n        v[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n           v[i]=v[i-1]+nums[i]; \\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n            return v[right];\\n       \\n        else\\n             return v[right]-v[left-1];\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        int n=nums.size();\\n        v.resize(n);\\n        v[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n           v[i]=v[i-1]+nums[i]; \\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n            return v[right];\\n       \\n        else\\n             return v[right]-v[left-1];\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989549,
                "title": "python-solution-using-prefix-sum",
                "content": "Hello guys. Hope you all are safe\\uD83D\\uDE0A\\uD83D\\uDE0A\\nRuntime: 80 ms, faster than 61.24% of Python3 online submissions for Range Sum Query - Immutable.\\nMemory Usage: 17.9 MB, less than 16.27% of Python3 online submissions for Range Sum Query - Immutable.\\n\\nSuggestions are most welcome.\\n```\\n    def __init__(self, array: List[int]):\\n        # prefix sum\\n        self.nums = array[:]  \\n        for i in range(1,len(self.nums)):\\n            self.nums[i] = self.nums[i]+self.nums[i-1]\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        if i == 0:\\n            return self.nums[j]        \\n        return(self.nums[j] - self.nums[i-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\n    def __init__(self, array: List[int]):\\n        # prefix sum\\n        self.nums = array[:]  \\n        for i in range(1,len(self.nums)):\\n            self.nums[i] = self.nums[i]+self.nums[i-1]\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        if i == 0:\\n            return self.nums[j]        \\n        return(self.nums[j] - self.nums[i-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 75284,
                "title": "my-clear-cpp-code",
                "content": "    class NumArray {\\n    public:\\n    \\n        vector<int> sums;\\n        \\n        NumArray(vector<int> &nums) \\n        {\\n            sums = vector<int>(nums.size()+1, 0);\\n            \\n            for(int i=0; i < nums.size(); i++)\\n                sums[i+1] = nums[i] + sums[i];\\n        }\\n    \\n        int sumRange(int i, int j) \\n        {\\n            if(sums.size() == 1) return sums[0];\\n            return sums[j+1] - sums[i];\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "solutionTags": [],
                "code": "    class NumArray {\\n    public:\\n    \\n        vector<int> sums;\\n        \\n        NumArray(vector<int> &nums) \\n        {\\n            sums = vector<int>(nums.size()+1, 0);\\n            \\n            for(int i=0; i < nums.size(); i++)\\n                sums[i+1] = nums[i] + sums[i];\\n        }\\n    \\n        int sumRange(int i, int j) \\n        {\\n            if(sums.size() == 1) return sums[0];\\n            return sums[j+1] - sums[i];\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "codeTag": "Java"
            },
            {
                "id": 75319,
                "title": "share-my-python-solution-o-n-for-init-and-o-1-for-query",
                "content": "Use an extra element for summation so we don't need to check boundary condition in the query.\\n\\n    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.sums = [0] * (len(nums) + 1)\\n            for i in xrange(len(nums)):\\n                self.sums[i+1] = self.sums[i] + nums[i]\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int\\n            :type j: int\\n            :rtype: int\\n            \"\"\"\\n            return self.sums[j+1] - self.sums[i]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "Use an extra element for summation so we don't need to check boundary condition in the query.\\n\\n    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.sums = [0] * (len(nums) + 1)\\n            for i in xrange(len(nums)):\\n                self.sums[i+1] = self.sums[i] + nums[i]\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int\\n            :type j: int\\n            :rtype: int\\n            \"\"\"\\n            return self.sums[j+1] - self.sums[i]",
                "codeTag": "Java"
            },
            {
                "id": 75324,
                "title": "accepted-c-solution",
                "content": "    struct NumArray {\\n        int size;\\n        int *sum;\\n};\\n\\n    \\n/** Initialize your data structure here. */\\n\\n    struct NumArray* NumArrayCreate(int* nums, int numsSize) {\\n        struct NumArray *array;\\n        int i;\\n\\n        array = (struct NumArray*)calloc(1, sizeof(struct NumArray));\\n        array->sum = (int *) calloc(numsSize+1, sizeof(int));\\n        array->size = numsSize;\\n        array->sum[0] = 0;\\n        for(i = 0; i < numsSize; i++){\\n                array->sum[i+1] = nums[i] + array->sum[i];\\n        }\\n        return array;\\n}\\n\\n     int sumRange(struct NumArray* numArray, int i, int j)\\n    {\\n        int sum = 0;\\n        if(!numArray)\\n                return 0;\\n        sum = numArray->sum[j+1] - numArray->sum[i];\\n        return sum;\\n}\\n\\n\\n    /** Deallocates memory previously allocated for the data structure. */\\n    void NumArrayFree(struct NumArray* numArray) {\\n        free(numArray->sum);\\n        free(numArray);\\n}",
                "solutionTags": [],
                "code": "    struct NumArray {\\n        int size;\\n        int *sum;\\n};\\n\\n    \\n/** Initialize your data structure here. */\\n\\n    struct NumArray* NumArrayCreate(int* nums, int numsSize) {\\n        struct NumArray *array;\\n        int i;\\n\\n        array = (struct NumArray*)calloc(1, sizeof(struct NumArray));\\n        array->sum = (int *) calloc(numsSize+1, sizeof(int));\\n        array->size = numsSize;\\n        array->sum[0] = 0;\\n        for(i = 0; i < numsSize; i++){\\n                array->sum[i+1] = nums[i] + array->sum[i];\\n        }\\n        return array;\\n}\\n\\n     int sumRange(struct NumArray* numArray, int i, int j)\\n    {\\n        int sum = 0;\\n        if(!numArray)\\n                return 0;\\n        sum = numArray->sum[j+1] - numArray->sum[i];\\n        return sum;\\n}\\n\\n\\n    /** Deallocates memory previously allocated for the data structure. */\\n    void NumArrayFree(struct NumArray* numArray) {\\n        free(numArray->sum);\\n        free(numArray);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 75342,
                "title": "my-simple-short-python-solution",
                "content": "    class NumArray(object):\\n        def __init__(self, nums):\\n            self.dp = [0]+nums[:]\\n            for i in xrange(1, len(nums)+1):\\n                self.dp[i] += self.dp[i-1]\\n\\n        def sumRange(self, i, j):\\n            return self.dp[j+1]-self.dp[i]",
                "solutionTags": [],
                "code": "    class NumArray(object):\\n        def __init__(self, nums):\\n            self.dp = [0]+nums[:]\\n            for i in xrange(1, len(nums)+1):\\n                self.dp[i] += self.dp[i-1]\\n\\n        def sumRange(self, i, j):\\n            return self.dp[j+1]-self.dp[i]",
                "codeTag": "Java"
            },
            {
                "id": 2640650,
                "title": "java-easiest-solution",
                "content": "```\\nclass NumArray {\\n    private int arr[];\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for(int i = left;i<=right;i++)\\n            sum += this.arr[i];\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    private int arr[];\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for(int i = left;i<=right;i++)\\n            sum += this.arr[i];\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141522,
                "title": "java-javascript-python-beginner-friendly-solutions",
                "content": "**Java**\\n```\\nclass NumArray {\\n\\n    int[] arr;\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        while(left<=right){\\n            sum += this.arr[left++];\\n        }\\n        return sum;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar NumArray = function(nums) {\\n    this.arr = nums\\n};\\n\\nNumArray.prototype.sumRange = function(left, right) {\\n    let sum = 0\\n    while( left <= right){\\n        sum += this.arr[left++]\\n    }\\n    return sum\\n};\\n```\\n**Python**\\n```\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.arr = nums\\n        \\n    def sumRange(self, left, right):\\n        return sum(self.arr[left : right+1])\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass NumArray {\\n\\n    int[] arr;\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        while(left<=right){\\n            sum += this.arr[left++];\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nvar NumArray = function(nums) {\\n    this.arr = nums\\n};\\n\\nNumArray.prototype.sumRange = function(left, right) {\\n    let sum = 0\\n    while( left <= right){\\n        sum += this.arr[left++]\\n    }\\n    return sum\\n};\\n```\n```\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.arr = nums\\n        \\n    def sumRange(self, left, right):\\n        return sum(self.arr[left : right+1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114601,
                "title": "c-easy-to-understand",
                "content": "```\\nclass NumArray {\\n    private:\\n    vector<int>v;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        \\n        for(int i=1;i<nums.size();i++){\\n            nums[i]=nums[i]+nums[i-1];\\n        }\\n        v = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n       \\n        return v[right]-((left!=0)?v[left-1]:0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    private:\\n    vector<int>v;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        \\n        for(int i=1;i<nums.size();i++){\\n            nums[i]=nums[i]+nums[i-1];\\n        }\\n        v = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n       \\n        return v[right]-((left!=0)?v[left-1]:0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797665,
                "title": "c-simple-and-clean-solution-using-prefix-sum",
                "content": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i=1; i<nums.size(); i++)\\n            vec[i] = nums[i]+vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j]-vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i=1; i<nums.size(); i++)\\n            vec[i] = nums[i]+vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j]-vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265043,
                "title": "c-template-remove-reference-on-vector",
                "content": "It may seem obvious to many, as of March 30 the given c++ temlpate will fail at compile time, unless `vector<int>&` is changed to `vector<int>`.",
                "solutionTags": [],
                "code": "It may seem obvious to many, as of March 30 the given c++ temlpate will fail at compile time, unless `vector<int>&` is changed to `vector<int>`.",
                "codeTag": "Unknown"
            },
            {
                "id": 75305,
                "title": "accepted-java-range-sum-query-solution",
                "content": "\\npublic class NumArray {\\n\\n    int[] nums;\\n    int[] numSum;\\n\\n    public NumArray(int[] nums) {\\n        this.nums = nums;\\n        numSum = new int[nums.length + 1];\\n        numSum[0] = 0;\\n        for(int i = 1; i < numSum.length; i++){\\n            numSum[i] = numSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        if(i < 0 || j >= nums.length){\\n            return 0;\\n        }\\n        \\n        return numSum[j + 1] - numSum[i];\\n    }\\n}",
                "solutionTags": [],
                "code": "\\npublic class NumArray {\\n\\n    int[] nums;\\n    int[] numSum;\\n\\n    public NumArray(int[] nums) {\\n        this.nums = nums;\\n        numSum = new int[nums.length + 1];\\n        numSum[0] = 0;\\n        for(int i = 1; i < numSum.length; i++){\\n            numSum[i] = numSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        if(i < 0 || j >= nums.length){\\n            return 0;\\n        }\\n        \\n        return numSum[j + 1] - numSum[i];\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3593362,
                "title": "beats-93-in-runtime-entire-problem-explained-in-detail-commented-code",
                "content": "# Explanation of the problem:\\nNums array given:\\n![nums arr.png](https://assets.leetcode.com/users/images/02f65ba1-7592-46bb-baa5-26a1a197da30_1685803697.891482.png)\\n\\n\\nPrefix sum array:\\n![prefix sum arr.png](https://assets.leetcode.com/users/images/4005752d-3699-4663-912d-89ab289bd7fc_1685803707.6904702.png)\\n\\n\\nHere we can see that the prefix array contains the sum up till every index given(right index)\\n\\nfor ex: right index given = 5 left index = 0\\nNow at the 5th index of prefix sum we have 4\\nHence the sum will be 4.\\n\\nfor ex: right index = 5 left index = 3\\nsum = 4-(0)=4\\nhere we subtracted the value at the 5th index that is 4 and the sum value of every element till the 3rd index excluding the sum at the 3rd index. (that is left index \\u2013 1) \\n\\n\\n# Code\\n```\\nvar NumArray = function(nums) {\\n    \\n    this.size = nums.length; //stores length of array\\n    this.prefixSum = Array( nums.length ).fill( 0 );//empty array\\n    this.prefixSum[0] = nums[0];//first value of prefix sum is the same as that of the first element of nums\\n    \\n    for( let i = 1; i < this.size ; i++ ){//traverse from left to right of array nums\\n        this.prefixSum[i] = this.prefixSum[i-1] + nums[i];\\n        /*stores sum of current value(nums) + previous sum value \\n        at the index before it(prefixsum)*/\\n    }\\n    \\n    \\n};\\n\\n/** \\n * @param {number} left \\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(left, right) {\\n    \\n    if( left == 0 ){\\n        /* if left index isnt mentioned then we return the \\n        sum up till the right index from the prefix sum array */\\n        return this.prefixSum[right];\\n    }else{\\n        //if the left index is given, then return the sum up \\n        //till the right index minus the value of prefix sum at \\n        //the index before the given left index i.e. value \\n        //at the (left - 1) index\\n        return this.prefixSum[right] - this.prefixSum[left-1];\\n    }\\n    \\n    \\n};\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Segment Tree",
                    "Prefix Sum"
                ],
                "code": "# Explanation of the problem:\\nNums array given:\\n![nums arr.png](https://assets.leetcode.com/users/images/02f65ba1-7592-46bb-baa5-26a1a197da30_1685803697.891482.png)\\n\\n\\nPrefix sum array:\\n![prefix sum arr.png](https://assets.leetcode.com/users/images/4005752d-3699-4663-912d-89ab289bd7fc_1685803707.6904702.png)\\n\\n\\nHere we can see that the prefix array contains the sum up till every index given(right index)\\n\\nfor ex: right index given = 5 left index = 0\\nNow at the 5th index of prefix sum we have 4\\nHence the sum will be 4.\\n\\nfor ex: right index = 5 left index = 3\\nsum = 4-(0)=4\\nhere we subtracted the value at the 5th index that is 4 and the sum value of every element till the 3rd index excluding the sum at the 3rd index. (that is left index \\u2013 1) \\n\\n\\n# Code\\n```\\nvar NumArray = function(nums) {\\n    \\n    this.size = nums.length; //stores length of array\\n    this.prefixSum = Array( nums.length ).fill( 0 );//empty array\\n    this.prefixSum[0] = nums[0];//first value of prefix sum is the same as that of the first element of nums\\n    \\n    for( let i = 1; i < this.size ; i++ ){//traverse from left to right of array nums\\n        this.prefixSum[i] = this.prefixSum[i-1] + nums[i];\\n        /*stores sum of current value(nums) + previous sum value \\n        at the index before it(prefixsum)*/\\n    }\\n    \\n    \\n};\\n\\n/** \\n * @param {number} left \\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(left, right) {\\n    \\n    if( left == 0 ){\\n        /* if left index isnt mentioned then we return the \\n        sum up till the right index from the prefix sum array */\\n        return this.prefixSum[right];\\n    }else{\\n        //if the left index is given, then return the sum up \\n        //till the right index minus the value of prefix sum at \\n        //the index before the given left index i.e. value \\n        //at the (left - 1) index\\n        return this.prefixSum[right] - this.prefixSum[left-1];\\n    }\\n    \\n    \\n};\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3478350,
                "title": "java-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray {\\n    int num[];\\n    public NumArray(int[] nums) {\\n        num=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            num[i]=nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum=0;\\n        for(int i=left;i<=right;i++)\\n        sum+=num[i];\\n        return sum;\\n    }\\n\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    int num[];\\n    public NumArray(int[] nums) {\\n        num=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            num[i]=nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum=0;\\n        for(int i=left;i<=right;i++)\\n        sum+=num[i];\\n        return sum;\\n    }\\n\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206578,
                "title": "efficient-range-sum-query-using-prefix-sum-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find the sum of the elements of nums between indices left and right inclusive. This can be achieved by creating a prefix sum array, which stores the sum of the elements up to that index. By subtracting the prefix sum of the left index - 1 from the prefix sum of the right index, we can obtain the sum of the elements between the two indices.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can initialize the prefix sum array with 0\\'s, with a length of 1 greater than the length of the input array. We then iterate through the input array and store the cumulative sum up to that index in the prefix sum array.\\n\\nTo find the sum between the left and right indices, we return the difference between the prefix sum of the right index + 1 and the prefix sum of the left index.\\n# Complexity\\n- Time complexity:  $$O(n)$$ for initializing the prefix sum array, where $$n$$ is the length of the input array. Each sumRange query can be answered in $$O(1)$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$ O(n)$$ for storing the prefix sum array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] * (len(nums) + 1)\\n        for i in range(1, len(nums) + 1):\\n            self.prefix_sum[i] = self.prefix_sum[i-1] + nums[i-1]\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right+1] - self.prefix_sum[left]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Design",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] * (len(nums) + 1)\\n        for i in range(1, len(nums) + 1):\\n            self.prefix_sum[i] = self.prefix_sum[i-1] + nums[i-1]\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right+1] - self.prefix_sum[left]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147205,
                "title": "beats-85-tc-o-n-sc-o-n-prefix-sum-4-lines-code-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Traversing same arrey each time ,so use Prefix sum,to minimise TC.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Prefix Sum\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass NumArray {\\npublic:\\nvector<int> v;\\n    NumArray(vector<int>& nums) {\\n       v.push_back(nums[0]);\\n       for(int i=1;i<nums.size();i++)\\n            v.push_back(nums[i]+v[i-1]);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0) return v[right];\\n        return v[right]-v[left-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Traversing same arrey each time ,so use Prefix sum,to minimise TC.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Prefix Sum\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass NumArray {\\npublic:\\nvector<int> v;\\n    NumArray(vector<int>& nums) {\\n       v.push_back(nums[0]);\\n       for(int i=1;i<nums.size();i++)\\n            v.push_back(nums[i]+v[i-1]);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0) return v[right];\\n        return v[right]-v[left-1];\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2921730,
                "title": "beats-99-93-of-the-python-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use a prefix sum array for this problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity of building the prefix_array is $$O(n)$$ but you\\'ll get your answer for sumRange() function within $$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is $$O(n)$$ as we have used extra space for building the prefix array.\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_array = [nums[0]]\\n        for i in range(1,len(nums)):\\n            self.prefix_array.append(nums[i]+self.prefix_array[-1])\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0:\\n            return self.prefix_array[right]\\n        return self.prefix_array[right]-self.prefix_array[left-1]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_array = [nums[0]]\\n        for i in range(1,len(nums)):\\n            self.prefix_array.append(nums[i]+self.prefix_array[-1])\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0:\\n            return self.prefix_array[right]\\n        return self.prefix_array[right]-self.prefix_array[left-1]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843255,
                "title": "java-2-solutions-naive-prefix-sum-easy",
                "content": "### **Please Upvote** :D\\n##### 1. Naive solution:\\n```\\nclass NumArray {\\n    private int[] arr;\\n\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for (int i = left; i <= right; i++) {\\n            sum += arr[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(k * n), SC: O(n)\\n// let k be the number of calls made to sumRange()\\n```\\n##### 2. Using prefix-sum:\\n```\\nclass NumArray {\\n    private int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n// sumRange() runs on O(1) time complexity\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    private int[] arr;\\n\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for (int i = left; i <= right; i++) {\\n            sum += arr[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(k * n), SC: O(n)\\n// let k be the number of calls made to sumRange()\\n```\n```\\nclass NumArray {\\n    private int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n// sumRange() runs on O(1) time complexity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376804,
                "title": "c-easy-to-understand-self-explaintory",
                "content": "![image](https://assets.leetcode.com/users/images/de134498-9b51-42d3-8c94-db11083a8696_1659589326.830725.png)\\n\\n\\tclass NumArray {\\n\\tpublic:\\n\\t\\tvector<int>arr;\\n\\t\\tNumArray(vector<int>& nums) {\\n\\t\\t\\tarr=nums;\\n\\t\\t}\\n\\n\\t\\tint sumRange(int left, int right) {\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=left;i<=right;i++) sum+=arr[i];\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/de134498-9b51-42d3-8c94-db11083a8696_1659589326.830725.png)\\n\\n\\tclass NumArray {\\n\\tpublic:\\n\\t\\tvector<int>arr;\\n\\t\\tNumArray(vector<int>& nums) {\\n\\t\\t\\tarr=nums;\\n\\t\\t}\\n\\n\\t\\tint sumRange(int left, int right) {\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=left;i<=right;i++) sum+=arr[i];\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2204819,
                "title": "segment-tree-implementation",
                "content": "```\\nclass NumArray {\\npublic:\\n    int n;\\n    vector<int> seg;\\n    \\n    int getSum(int index, int segStart, int segEnd, int queryStart, int queryEnd){ //index - index of current segement, \\n        //segStart and segEnd - range of values this segment has summed up\\n        //queryStart queryEnd - query left and right indexs\\n        \\n        if(queryStart<=segStart && queryEnd>=segEnd){//if our seg completely overlaps with the query range\\n            return seg[index];\\n        }\\n        \\n        if(segStart>queryEnd || segEnd<queryStart){// our segment does not overlap with the queryrange\\n            return 0;\\n        }\\n        \\n        //if it overlaps partially we will break down the segment down again\\n        int mid = segStart + (segEnd-segStart)/2;\\n        int ans = getSum(index*2+1, segStart, mid, queryStart, queryEnd) + \\n            getSum(index*2+2, mid+1, segEnd, queryStart, queryEnd); //searching in left and right\\n        return ans;\\n        // return 0;\\n        \\n    }\\n    \\n    int constructSegementTree(vector<int>&nums, int index, int start, int end){\\n        if(start == end){ // leaf node\\n            seg[index] = nums[start];\\n            // cout<<seg[index]<<endl;\\n            return seg[index];\\n        }\\n        \\n        //we will divide the array into two parts and recursively store the total sum in our node\\n        \\n        int mid = start+(end-start)/2;\\n        seg[index] = constructSegementTree(nums, 2*index+1, start, mid); //left sise\\n        seg[index] += constructSegementTree(nums, 2*index+2, mid+1, end); //right sise\\n        // cout<<seg[index]<<endl;\\n        return seg[index]; //return the sum store in this node as this is the sum of the subpart of its parent node.\\n    }\\n    \\n    NumArray(vector<int>& nums) {\\n        n = nums.size();\\n        \\n        int x = ceil(log2(n));//height of the segment tree\\n        int size = 2 * (int)(pow(2, x)) - 1; //size of segment tree\\n        \\n        seg.resize(size, 0);\\n        \\n        constructSegementTree(nums, 0, 0, n-1);\\n        // for(auto i: seg){\\n        //     cout<<i<<\" \";\\n        // }cout<<endl;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return getSum(0, 0, n-1, left, right);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    int n;\\n    vector<int> seg;\\n    \\n    int getSum(int index, int segStart, int segEnd, int queryStart, int queryEnd){ //index - index of current segement, \\n        //segStart and segEnd - range of values this segment has summed up\\n        //queryStart queryEnd - query left and right indexs\\n        \\n        if(queryStart<=segStart && queryEnd>=segEnd){//if our seg completely overlaps with the query range\\n            return seg[index];\\n        }\\n        \\n        if(segStart>queryEnd || segEnd<queryStart){// our segment does not overlap with the queryrange\\n            return 0;\\n        }\\n        \\n        //if it overlaps partially we will break down the segment down again\\n        int mid = segStart + (segEnd-segStart)/2;\\n        int ans = getSum(index*2+1, segStart, mid, queryStart, queryEnd) + \\n            getSum(index*2+2, mid+1, segEnd, queryStart, queryEnd); //searching in left and right\\n        return ans;\\n        // return 0;\\n        \\n    }\\n    \\n    int constructSegementTree(vector<int>&nums, int index, int start, int end){\\n        if(start == end){ // leaf node\\n            seg[index] = nums[start];\\n            // cout<<seg[index]<<endl;\\n            return seg[index];\\n        }\\n        \\n        //we will divide the array into two parts and recursively store the total sum in our node\\n        \\n        int mid = start+(end-start)/2;\\n        seg[index] = constructSegementTree(nums, 2*index+1, start, mid); //left sise\\n        seg[index] += constructSegementTree(nums, 2*index+2, mid+1, end); //right sise\\n        // cout<<seg[index]<<endl;\\n        return seg[index]; //return the sum store in this node as this is the sum of the subpart of its parent node.\\n    }\\n    \\n    NumArray(vector<int>& nums) {\\n        n = nums.size();\\n        \\n        int x = ceil(log2(n));//height of the segment tree\\n        int size = 2 * (int)(pow(2, x)) - 1; //size of segment tree\\n        \\n        seg.resize(size, 0);\\n        \\n        constructSegementTree(nums, 0, 0, n-1);\\n        // for(auto i: seg){\\n        //     cout<<i<<\" \";\\n        // }cout<<endl;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return getSum(0, 0, n-1, left, right);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2105767,
                "title": "java-easy-solution-o-1-query",
                "content": "```\\nclass NumArray {\\n    int ar[];\\n\\n    public NumArray(int[] nums) {\\n        int len = nums.length;\\n        ar = new int[len];\\n        ar[0] = nums[0];\\n        for (int i = 1; i < len; i++) {\\n            ar[i] = ar[i - 1] + nums[i];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left == 0)\\n            return ar[right];\\n        else\\n            return (ar[right] - ar[left - 1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    int ar[];\\n\\n    public NumArray(int[] nums) {\\n        int len = nums.length;\\n        ar = new int[len];\\n        ar[0] = nums[0];\\n        for (int i = 1; i < len; i++) {\\n            ar[i] = ar[i - 1] + nums[i];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left == 0)\\n            return ar[right];\\n        else\\n            return (ar[right] - ar[left - 1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028445,
                "title": "simple-and-straightforward-c-solution-with-algorithm-o-n",
                "content": "**Algorithm**\\n\\n* Create a struct with array pointer.\\n* Copy all the elements of nums to NumArray arr.\\n* Sum the elements from left to right(inclusive).\\n* Free NumArray arr and NumArray.\\n\\nTime Complexity: O(n) | Space Complexity: O(n)\\n\\n**Code**\\n\\n```\\ntypedef struct {\\n    int *arr;\\n} NumArray;\\n\\n\\nNumArray* numArrayCreate(int* nums, int numsSize) {\\n    NumArray* ptr = (NumArray*)malloc(sizeof(NumArray));\\n    ptr->arr = (int*)malloc(sizeof(int)*numsSize);\\n    for(int i=0; i<numsSize; i++){\\n        ptr->arr[i] = nums[i];\\n    }\\n    return ptr;\\n}\\n\\nint numArraySumRange(NumArray* obj, int left, int right) {\\n  int sum = 0;\\n    for(int i=left; i<=right; i++){\\n        sum+= obj->arr[i];\\n    }\\n    return sum;\\n}\\n\\nvoid numArrayFree(NumArray* obj) {\\n    free(obj->arr);\\n    free(obj);\\n}\\n```\\n**Please upvote if it helped you.**\\n*Feel free to ask any questions/query if any.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    int *arr;\\n} NumArray;\\n\\n\\nNumArray* numArrayCreate(int* nums, int numsSize) {\\n    NumArray* ptr = (NumArray*)malloc(sizeof(NumArray));\\n    ptr->arr = (int*)malloc(sizeof(int)*numsSize);\\n    for(int i=0; i<numsSize; i++){\\n        ptr->arr[i] = nums[i];\\n    }\\n    return ptr;\\n}\\n\\nint numArraySumRange(NumArray* obj, int left, int right) {\\n  int sum = 0;\\n    for(int i=left; i<=right; i++){\\n        sum+= obj->arr[i];\\n    }\\n    return sum;\\n}\\n\\nvoid numArrayFree(NumArray* obj) {\\n    free(obj->arr);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1852571,
                "title": "find-prefix-sum-and-answer-the-query-c",
                "content": "```\\nclass NumArray {\\nprivate:    \\n    vector<int> arr;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        int sum = 0;\\n        for(auto &it : nums){\\n            sum += it;\\n            arr.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int r = arr[right];\\n        int l = 0;\\n        if(left != 0) l = arr[left-1];\\n        int ans = r - l;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\nprivate:    \\n    vector<int> arr;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        int sum = 0;\\n        for(auto &it : nums){\\n            sum += it;\\n            arr.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int r = arr[right];\\n        int l = 0;\\n        if(left != 0) l = arr[left-1];\\n        int ans = r - l;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778944,
                "title": "java-simple-solution-with-explanation",
                "content": "### Please upvote if you like the solution\\n\\n```\\nclass NumArray {\\n\\n\\n    /****\\n     *                *****  Approach - 1   ******\\n     *\\n     * By keeping the sum value till that position\\n     *\\n     *             Input : [-2,  0,  3, -5,  2, -1]\\n     * sumTillPosition  : [-2, -2,  1, -4, -2, -3]\\n     *\\n     * Now there are two cases\\n     * case-1 :  if (left == 0) in that case  return sumTillPosition of the right side\\n     *           sumTillPosition[right];\\n     *\\n     * Case-2 : For other cases\\n     *          subtract sumTillPosition of the (left - 1) side   from  sumTillPosition of the right side\\n     *          return sumTillPosition[right] - sumTillPosition[left - 1];\\n     */\\n    int[] sumTillPosition;\\n\\n    public NumArray(int[] nums) {\\n        sumTillPosition = new int[nums.length];\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            sumTillPosition[i] = sum;\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left == 0) {\\n            return sumTillPosition[right];\\n        }\\n        return sumTillPosition[right] - sumTillPosition[left - 1];\\n    }\\n\\n\\n    /**\\n     *                 *****  Approach - 2   ******\\n     *\\n     * By keeping two array\\n     * 1. Sum value of its left\\n     * 2. Sum value of its right\\n     *\\n     * For an example\\n     * Input : [-2, 0, 3, -5, 2, -1]\\n     * Left  : [0, -2, -2, 1, -4, -2]\\n     * Right : [-1, -1, -4, 1, -1, 0]\\n     *\\n     * Now if we have this precomputed arrays we can get the range sum by subtracting the leftSideSum & rightSideSum\\n     * resultedSum = totalSum - (leftSideSum[left] + rightSideSum[right]);\\n     */\\n\\n    /*\\n\\n    int[] leftSideSum;\\n    int[] rightSideSum;\\n    int totalSum = 0;\\n    public NumArray(int[] nums) {\\n\\n        leftSideSum = new int[nums.length];\\n        rightSideSum = new int[nums.length];\\n\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            leftSideSum[i] = sum;\\n            sum += nums[i];\\n        }\\n        totalSum = sum;\\n\\n        sum = 0;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            rightSideSum[i] = sum;\\n            sum += nums[i];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return totalSum - (leftSideSum[left] + rightSideSum[right]);\\n    }\\n    */\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n\\n\\n    /****\\n     *                *****  Approach - 1   ******\\n     *\\n     * By keeping the sum value till that position\\n     *\\n     *             Input : [-2,  0,  3, -5,  2, -1]\\n     * sumTillPosition  : [-2, -2,  1, -4, -2, -3]\\n     *\\n     * Now there are two cases\\n     * case-1 :  if (left == 0) in that case  return sumTillPosition of the right side\\n     *           sumTillPosition[right];\\n     *\\n     * Case-2 : For other cases\\n     *          subtract sumTillPosition of the (left - 1) side   from  sumTillPosition of the right side\\n     *          return sumTillPosition[right] - sumTillPosition[left - 1];\\n     */\\n    int[] sumTillPosition;\\n\\n    public NumArray(int[] nums) {\\n        sumTillPosition = new int[nums.length];\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            sumTillPosition[i] = sum;\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left == 0) {\\n            return sumTillPosition[right];\\n        }\\n        return sumTillPosition[right] - sumTillPosition[left - 1];\\n    }\\n\\n\\n    /**\\n     *                 *****  Approach - 2   ******\\n     *\\n     * By keeping two array\\n     * 1. Sum value of its left\\n     * 2. Sum value of its right\\n     *\\n     * For an example\\n     * Input : [-2, 0, 3, -5, 2, -1]\\n     * Left  : [0, -2, -2, 1, -4, -2]\\n     * Right : [-1, -1, -4, 1, -1, 0]\\n     *\\n     * Now if we have this precomputed arrays we can get the range sum by subtracting the leftSideSum & rightSideSum\\n     * resultedSum = totalSum - (leftSideSum[left] + rightSideSum[right]);\\n     */\\n\\n    /*\\n\\n    int[] leftSideSum;\\n    int[] rightSideSum;\\n    int totalSum = 0;\\n    public NumArray(int[] nums) {\\n\\n        leftSideSum = new int[nums.length];\\n        rightSideSum = new int[nums.length];\\n\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            leftSideSum[i] = sum;\\n            sum += nums[i];\\n        }\\n        totalSum = sum;\\n\\n        sum = 0;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            rightSideSum[i] = sum;\\n            sum += nums[i];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return totalSum - (leftSideSum[left] + rightSideSum[right]);\\n    }\\n    */\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655756,
                "title": "c-easy-to-understand-2-approaches",
                "content": "**Naive approach**\\n```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        v=nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n      int sum=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            sum+=v[i];\\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Prefix sum approach**\\n```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            v.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left-1>=0)\\n        return v[right]-v[left-1];\\n        else\\n        return v[right];\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        v=nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n      int sum=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            sum+=v[i];\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            v.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left-1>=0)\\n        return v[right]-v[left-1];\\n        else\\n        return v[right];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493472,
                "title": "python-prefix-sum-with-explanation",
                "content": "#### Think it this way:\\n#### prefix[i] = num[0] +...+ num[i]\\n#### sumRange(left, right) = num[left] +...+ num[right] = prefix[right] - prefix[left-1]\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        \\n        self.prefix = {-1:0}\\n        for i,num in enumerate(nums):\\n            self.prefix[i] = self.prefix[i-1]+num\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix[right] - self.prefix[left-1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        \\n        self.prefix = {-1:0}\\n        for i,num in enumerate(nums):\\n            self.prefix[i] = self.prefix[i-1]+num\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix[right] - self.prefix[left-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370375,
                "title": "java-prefix-sum-technique-full-explanation-100-faster",
                "content": "Prefix sum is a very vital tool  to minimize the repeated calculation done in an array and thus reduces the time complexity of your program.\\n\\n**What is prefix sum ?**\\nSuppose you are given an array, A = { 2 , 6 , 5 , 8 , 7 , 1 }. Let us define a new array PA[ ], size of which is same as the size of array A. The element at the ith index of the array PA will contain the sum of all the elements from A[0] to A[i], i.e :\\n```\\n\\nPA[0] = A[0]\\n PA[1] = A[0] + A[1]\\n PA[2] = A[0] + A[1] + A[2]\\n\\t .\\n\\t .\\n\\t .\\n PA[i] = A[0] + A[1] + A[2] + ........ + A[i]\\n\\t .\\n\\t .\\n\\t .\\n PA[N-1] = A[0] + A[1] + A[2] + ......... + A[N-1]\\n```\\n\\nSo, the prefix array of the given array A will be , PA [ ] = { 2 , 8 , 13 , 21 , 28 , 29 }\\n\\n**Creating Prefix array**\\nPrefix array can easily be constructed by travelling the array A once. This can be done by using the formula :\\nPA[ i ] = PA [ i \\u2212 1 ] + A[i]\\nHere i varies from 1 to N \\u2212 1. PA[ 0 ] is initialize to A[ 0 ] before the loop starts.\\n\\n**Advantage**\\nSuppose you are said to calculate the sum of first K elements of the array A. It is fine if you have to do the given task once, but if you are asked repeatedly to find the sum of first K elements of the array A (note : K may vary from 0 to N-1 ) then it may take lot of time. But if we construct prefix array of the given array then we can answer the query in O( 1 ) time by just printing PA[ K \\u2212 1 ].\\n\\nNow suppose you are asked to calculate the sum of elements of array A from index L to index R ( L \\u2264 R) i.e, you have to calculate the summation of the series A[ L ] + A[ L + 1 ] + ........ + A [ R ], if you are asked to calculate once then it is fine but if you have to repeatedly calculate then prefix array would be a better option. We can answer the query in O( 1 ) time by just printing, PA[ R ] \\u2212 PA[ L \\u2212 1 ].\\nExplanation\\n\\u2003\\u2003\\u2003\\u2003 PA[ R ] = A[ 0 ] + A [ 1 ] + A[ 2 ] + ....... + A[ L-1 ] + A[ L ] + ........ + A[ R ] (note L \\u2264 R)\\n\\u2003\\u2003\\u2003\\u2003 PA[ L-1 ] = A[ 0 ] + A [ 1 ] + A[ 2 ] + ....... + A[ L \\u2212 1 ]\\n\\nsubstracting PA[ R ] by PA[ L \\u2212 1 ] we get:\\n\\n\\u2003\\u2003\\u2003\\u2003 PA[ R ] \\u2212 PA[ L \\u2212 1] = A[ L ] + ........ + A[ R ]\\n\\n**Properties**\\nIf the given array A has all non-negative numbers the the prefix array constructed will be sorted in non-descending order.\\n\\n**Solution**\\n\\n```\\nclass NumArray {\\n    \\n    int[] num;\\n    public NumArray(int[] nums) {\\n        num = nums;\\n        for (int i = 1; i < nums.length; i++) {\\n            num[i] += num[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return left == 0 ? num[right] : num[right] - num[left - 1];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nPA[0] = A[0]\\n PA[1] = A[0] + A[1]\\n PA[2] = A[0] + A[1] + A[2]\\n\\t .\\n\\t .\\n\\t .\\n PA[i] = A[0] + A[1] + A[2] + ........ + A[i]\\n\\t .\\n\\t .\\n\\t .\\n PA[N-1] = A[0] + A[1] + A[2] + ......... + A[N-1]\\n```\n```\\nclass NumArray {\\n    \\n    int[] num;\\n    public NumArray(int[] nums) {\\n        num = nums;\\n        for (int i = 1; i < nums.length; i++) {\\n            num[i] += num[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return left == 0 ? num[right] : num[right] - num[left - 1];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702265,
                "title": "go",
                "content": "```\\ntype NumArray struct {\\n    sum []int\\n}\\n\\n\\nfunc Constructor(nums []int) NumArray {\\n    if len(nums) == 0 {\\n        return NumArray{}\\n    }\\n    \\n    sum := make([]int, len(nums) + 1)\\n    sum[0], sum[1] = 0, nums[0]\\n    for i := 2; i < len(sum); i++ {\\n        sum[i] = sum[i - 1] + nums[i - 1]\\n    }\\n    return NumArray{sum: sum}\\n}\\n\\n\\nfunc (this *NumArray) SumRange(i int, j int) int {\\n    \\n    return this.sum[j + 1] - this.sum[i]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype NumArray struct {\\n    sum []int\\n}\\n\\n\\nfunc Constructor(nums []int) NumArray {\\n    if len(nums) == 0 {\\n        return NumArray{}\\n    }\\n    \\n    sum := make([]int, len(nums) + 1)\\n    sum[0], sum[1] = 0, nums[0]\\n    for i := 2; i < len(sum); i++ {\\n        sum[i] = sum[i - 1] + nums[i - 1]\\n    }\\n    return NumArray{sum: sum}\\n}\\n\\n\\nfunc (this *NumArray) SumRange(i int, j int) int {\\n    \\n    return this.sum[j + 1] - this.sum[i]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696259,
                "title": "c-segment-tree-solution",
                "content": "```\\nclass NumArray {\\npublic:\\n    int n;\\n    vector<int>seg;\\n    \\n    int query(int index,int low,int high,int l,int r)\\n    {\\n        if(low>=l && high<=r)\\n        {\\n            return seg[index];\\n        }\\n        if(high<l || low>r)\\n            return 0;\\n        int mid=(low+high)/2;\\n        int left=query(2*index+1,low,mid,l,r);\\n        int right=query(2*index+2,mid+1,high,l,r);\\n        return left+right;\\n    }\\n    \\n    void build(int index,int low,int high,vector<int>&nums)\\n    {\\n        if(low==high)\\n        {\\n            seg[index]=nums[low];\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        build(2*index+1,low,mid,nums);\\n        build(2*index+2,mid+1,high,nums);\\n        seg[index]=seg[2*index+1]+seg[2*index+2];\\n    }\\n    \\n    \\n    NumArray(vector<int>& nums) {\\n        n=nums.size();\\n        if(n==0)\\n            return ;\\n        seg.resize(4*n);\\n        build(0,0,n-1,nums);\\n        \\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return query(0,0,n-1,i,j);\\n        \\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(i,j);\\n */",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    int n;\\n    vector<int>seg;\\n    \\n    int query(int index,int low,int high,int l,int r)\\n    {\\n        if(low>=l && high<=r)\\n        {\\n            return seg[index];\\n        }\\n        if(high<l || low>r)\\n            return 0;\\n        int mid=(low+high)/2;\\n        int left=query(2*index+1,low,mid,l,r);\\n        int right=query(2*index+2,mid+1,high,l,r);\\n        return left+right;\\n    }\\n    \\n    void build(int index,int low,int high,vector<int>&nums)\\n    {\\n        if(low==high)\\n        {\\n            seg[index]=nums[low];\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        build(2*index+1,low,mid,nums);\\n        build(2*index+2,mid+1,high,nums);\\n        seg[index]=seg[2*index+1]+seg[2*index+2];\\n    }\\n    \\n    \\n    NumArray(vector<int>& nums) {\\n        n=nums.size();\\n        if(n==0)\\n            return ;\\n        seg.resize(4*n);\\n        build(0,0,n-1,nums);\\n        \\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return query(0,0,n-1,i,j);\\n        \\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(i,j);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 75188,
                "title": "7-lines-c-dp",
                "content": "And my [7 lines DP solution](https://discuss.leetcode.com/topic/104453/7-lines-c-dp) for the [304. Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/description/).\\n```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int> nums) {\\n        int sum = 0;\\n        for(auto x: nums){\\n            sum += x;\\n            dp.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return i == 0 ? dp[j] : dp[j] - dp[i - 1];\\n    }\\n    \\nprivate:\\n    vector<int>dp;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int> nums) {\\n        int sum = 0;\\n        for(auto x: nums){\\n            sum += x;\\n            dp.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return i == 0 ? dp[j] : dp[j] - dp[i - 1];\\n    }\\n    \\nprivate:\\n    vector<int>dp;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75244,
                "title": "c-beats-100-solutions",
                "content": "    class NumArray {\\n    public:\\n        map<int,int> mp;\\n        NumArray(vector<int> &nums) {\\n            mp[-1] = 0;\\n            int sum = 0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                sum += nums[i];\\n                mp[i] = sum;\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return (mp[j]-mp[i-1]);\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class NumArray {\\n    public:\\n        map<int,int> mp;\\n        NumArray(vector<int> &nums) {\\n            mp[-1] = 0;\\n            int sum = 0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                sum += nums[i];\\n                mp[i] = sum;\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return (mp[j]-mp[i-1]);\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 75271,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class NumArray {\\n        vector<int> sums;\\n    public:\\n        NumArray(vector<int> &nums) {\\n            sums.resize(nums.size()+1, 0);\\n            for(int i=1; i<=nums.size(); i++){\\n                sums[i]=sums[i-1]+nums[i-1];\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return sums[j+1]-sums[i];\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "solutionTags": [],
                "code": "    class NumArray {\\n        vector<int> sums;\\n    public:\\n        NumArray(vector<int> &nums) {\\n            sums.resize(nums.size()+1, 0);\\n            for(int i=1; i<=nums.size(); i++){\\n                sums[i]=sums[i-1]+nums[i-1];\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return sums[j+1]-sums[i];\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "codeTag": "Java"
            },
            {
                "id": 75317,
                "title": "c-solution-with-accumulated-sum-array",
                "content": "    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) {\\n        int accum=0;\\n        for(int i=0;i<nums.size();i++)\\n            {\\n            accum+=nums[i];\\n            _acarray.push_back(accum);\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            if(i==0)\\n                return (_acarray[j]);\\n            else \\n                return (_acarray[j]-_acarray[i-1]);\\n        }\\n        \\n    private:\\n        vector<int> _acarray;\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "solutionTags": [],
                "code": "    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) {\\n        int accum=0;\\n        for(int i=0;i<nums.size();i++)\\n            {\\n            accum+=nums[i];\\n            _acarray.push_back(accum);\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            if(i==0)\\n                return (_acarray[j]);\\n            else \\n                return (_acarray[j]-_acarray[i-1]);\\n        }\\n        \\n    private:\\n        vector<int> _acarray;\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "codeTag": "Java"
            },
            {
                "id": 75326,
                "title": "a-ruby-solution",
                "content": "    class NumArray\\n    \\n      def initialize(nums)\\n        @sum = [s = 0] + nums.map { |n| s += n }\\n      end\\n    \\n      def sum_range(i, j)\\n        @sum[j + 1] - @sum[i]\\n      end\\n    \\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    class NumArray\\n    \\n      def initialize(nums)\\n        @sum = [s = 0] + nums.map { |n| s += n }\\n      end\\n    \\n      def sum_range(i, j)\\n        @sum[j + 1] - @sum[i]\\n      end\\n    \\n    end",
                "codeTag": "Java"
            },
            {
                "id": 3371852,
                "title": "python-o-1-solution-beats-97-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        arr = [nums[0]]\\n        for i in range(1,len(nums)):\\n            arr.append(arr[-1]+nums[i])\\n        self.arr = arr\\n\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0:\\n            return self.arr[right]\\n        return self.arr[right] - self.arr[left - 1]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n\\n\\n\\n\"\"\"\\ngiven n>= j > i >0\\nprefix_sum(i,j) = prefix_sum(0,j) - prefix_sum(0,i)\\nwe need to itilaze a prefix_sum\\n\\n\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        arr = [nums[0]]\\n        for i in range(1,len(nums)):\\n            arr.append(arr[-1]+nums[i])\\n        self.arr = arr\\n\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0:\\n            return self.arr[right]\\n        return self.arr[right] - self.arr[left - 1]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n\\n\\n\\n\"\"\"\\ngiven n>= j > i >0\\nprefix_sum(i,j) = prefix_sum(0,j) - prefix_sum(0,i)\\nwe need to itilaze a prefix_sum\\n\\n\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061568,
                "title": "java-prefix-sum-solution",
                "content": "# Intuition\\nUse prefix sum to precalculate range sum.\\n\\n# Approach\\nUse prefix sum to precalculate range sum.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass NumArray {\\n\\n    private int[] prefixSum;\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length];\\n\\n        for(int i=0; i < nums.length ; i++) {\\n            prefixSum[i] = nums[i];\\n            if(i > 0) prefixSum[i] += prefixSum[i-1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return prefixSum[right] - (left > 0 ? prefixSum[left-1] : 0);\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n\\n    private int[] prefixSum;\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length];\\n\\n        for(int i=0; i < nums.length ; i++) {\\n            prefixSum[i] = nums[i];\\n            if(i > 0) prefixSum[i] += prefixSum[i-1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return prefixSum[right] - (left > 0 ? prefixSum[left-1] : 0);\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059374,
                "title": "prefixsum-approach",
                "content": "# Complexity\\n- Time complexity: O(1) - to process each query\\n\\n- Space complexity: O(n) - to store prefix sum\\n\\n# Code\\n```\\nclass NumArray {\\n    int[] n;\\n    public NumArray(int[] nums) {\\n        n=new int[nums.length];\\n        n[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            n[i]=nums[i]+n[i-1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left==0){\\n            return n[right];\\n        }\\n        else{\\n            return n[right]-n[left-1];\\n        }\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    int[] n;\\n    public NumArray(int[] nums) {\\n        n=new int[nums.length];\\n        n[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            n[i]=nums[i]+n[i-1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left==0){\\n            return n[right];\\n        }\\n        else{\\n            return n[right]-n[left-1];\\n        }\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054764,
                "title": "in-o-1-find-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray {\\n    int prefixArray[] = null;\\n    public NumArray(int[] nums) {\\n        int sum = 0; int n = nums.length;\\n        prefixArray = new int[n];\\n        for(int i = 0;i<n;i++){\\n            sum+=nums[i];\\n            prefixArray[i] = sum;\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left>0) return (prefixArray[right]-prefixArray[left-1]);\\n         return prefixArray[right];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    int prefixArray[] = null;\\n    public NumArray(int[] nums) {\\n        int sum = 0; int n = nums.length;\\n        prefixArray = new int[n];\\n        for(int i = 0;i<n;i++){\\n            sum+=nums[i];\\n            prefixArray[i] = sum;\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left>0) return (prefixArray[right]-prefixArray[left-1]);\\n         return prefixArray[right];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932581,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass NumArray {\\npublic:\\n    int pref[10005];\\n    NumArray(vector<int>& nums) {\\n        for(int i=0; i<nums.size(); i++) pref[i+1] = pref[i] + nums[i];\\n    }  \\n    int sumRange(int left, int right) {\\n        return pref[right + 1] - pref[left];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    int pref[10005];\\n    NumArray(vector<int>& nums) {\\n        for(int i=0; i<nums.size(); i++) pref[i+1] = pref[i] + nums[i];\\n    }  \\n    int sumRange(int left, int right) {\\n        return pref[right + 1] - pref[left];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844575,
                "title": "c-using-prefix-sum",
                "content": "# Please Upvote if Usefull , means lot.\\n**Intutuion** \\n* Just Use Prefix Sum .\\n```\\nclass NumArray {\\npublic:\\n    vector< int>  sum;\\n    NumArray(vector<int>& a) {\\n        sum.resize(a.size()+1,0);\\n        for( int i=1;i<=a.size();i++){\\n            sum[i]+=sum[i-1]+a[i-1];\\n        }\\n    }\\n    \\n    int sumRange(int l, int r) {\\n        return sum[r+1]-sum[l];\\n    }\\n        \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector< int>  sum;\\n    NumArray(vector<int>& a) {\\n        sum.resize(a.size()+1,0);\\n        for( int i=1;i<=a.size();i++){\\n            sum[i]+=sum[i-1]+a[i-1];\\n        }\\n    }\\n    \\n    int sumRange(int l, int r) {\\n        return sum[r+1]-sum[l];\\n    }\\n        \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360797,
                "title": "c-easy-solution",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int> ans;\\n    int sum=0;\\n    NumArray(vector<int>& nums) \\n    {\\n        ans=nums;\\n        sum=accumulate(ans.begin(),ans.end(),0);\\n    }\\n    \\n    int sumRange(int left, int right) \\n    {\\n        int res=sum;\\n        for(int i=0;i<left;i++)\\n            res-=ans[i];\\n        \\n        for(int i=right+1;i<ans.size();i++)\\n            res-=ans[i];\\n        \\n        return res;\\n    }\\n};\\n```\\nPlease upvote if you like the solution :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> ans;\\n    int sum=0;\\n    NumArray(vector<int>& nums) \\n    {\\n        ans=nums;\\n        sum=accumulate(ans.begin(),ans.end(),0);\\n    }\\n    \\n    int sumRange(int left, int right) \\n    {\\n        int res=sum;\\n        for(int i=0;i<left;i++)\\n            res-=ans[i];\\n        \\n        for(int i=right+1;i<ans.size();i++)\\n            res-=ans[i];\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105239,
                "title": "easy-c-dp-method-beginner-friendly",
                "content": "**Code:**\\n\\n```\\nclass NumArray {\\npublic:\\n    vector<int> sumMat; // DP array\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size(), prefix=nums[0];\\n        sumMat = vector<int>(n+1);\\n        sumMat[0]=0; sumMat[1]=nums[0];\\n        \\n        for (int i=1; i<n; i++){\\n            prefix+=nums[i];\\n            sumMat[i+1]=prefix;\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return (sumMat[right+1]-sumMat[left]);\\n    }\\n};\\n```\\n\\n**Hit Upvote, if my solution helped you!**\\n*Feel Free to reach me out for any help!*\\n \\n**Happy Learning!** \\uD83D\\uDD25\\uD83C\\uDFAF",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> sumMat; // DP array\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size(), prefix=nums[0];\\n        sumMat = vector<int>(n+1);\\n        sumMat[0]=0; sumMat[1]=nums[0];\\n        \\n        for (int i=1; i<n; i++){\\n            prefix+=nums[i];\\n            sumMat[i+1]=prefix;\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return (sumMat[right+1]-sumMat[left]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830909,
                "title": "easy-c-solution-prefix-sum",
                "content": "**Try this one**\\nany suggession for imrpovments in it??\\n```\\nclass NumArray {\\npublic:\\n    vector<int>vec;\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int sum=0;\\n        for(int i=left;i<=right;i++){\\n            sum+=vec[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int>vec;\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int sum=0;\\n        for(int i=left;i<=right;i++){\\n            sum+=vec[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237877,
                "title": "c-solution",
                "content": "```\\npublic class NumArray {\\n    \\n    // runningSum[i]: sum of nums[0,i]\\n    private int[] runningSum;\\n\\n\\t// O(N)\\n    public NumArray(int[] nums) {\\n        \\n        runningSum = new int[nums.Length];\\n        runningSum[0] = nums[0];\\n        for(int i = 1; i < nums.Length; i++)\\n            runningSum[i] = runningSum[i - 1] + nums[i];\\n    }\\n    \\n\\t// O(1)\\n    public int SumRange(int left, int right) {\\n       \\n        // sum[i,j] = runningSum[0,j] - runningSum[0,i-1]       \\n        return left == 0? runningSum[right] : runningSum[right] - runningSum[left - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class NumArray {\\n    \\n    // runningSum[i]: sum of nums[0,i]\\n    private int[] runningSum;\\n\\n\\t// O(N)\\n    public NumArray(int[] nums) {\\n        \\n        runningSum = new int[nums.Length];\\n        runningSum[0] = nums[0];\\n        for(int i = 1; i < nums.Length; i++)\\n            runningSum[i] = runningSum[i - 1] + nums[i];\\n    }\\n    \\n\\t// O(1)\\n    public int SumRange(int left, int right) {\\n       \\n        // sum[i,j] = runningSum[0,j] - runningSum[0,i-1]       \\n        return left == 0? runningSum[right] : runningSum[right] - runningSum[left - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141638,
                "title": "java-dynamic-programming-prefix-sum-array-beats-100-init-o-n-sumrange-o-1",
                "content": "\\n\\tint[] prefixSum;\\n\\t\\n\\t// O(nums.length)\\n\\tpublic NumArray(int[] nums) {\\n\\t\\tint len = nums.length;\\n\\t\\tprefixSum = new int[len];\\n\\t\\tprefixSum[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tprefixSum[i] = prefixSum[i - 1] + nums[i];\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic int sumRange(int left, int right) {\\n\\t\\treturn (left == 0) ? prefixSum[right] : prefixSum[right] - prefixSum[left - 1];\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\tint[] prefixSum;\\n\\t\\n\\t// O(nums.length)\\n\\tpublic NumArray(int[] nums) {\\n\\t\\tint len = nums.length;\\n\\t\\tprefixSum = new int[len];\\n\\t\\tprefixSum[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tprefixSum[i] = prefixSum[i - 1] + nums[i];\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic int sumRange(int left, int right) {\\n\\t\\treturn (left == 0) ? prefixSum[right] : prefixSum[right] - prefixSum[left - 1];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 846086,
                "title": "java-clean-code-dynamic-programming-technique-o-1-time-complexity",
                "content": "```\\nclass NumArray {\\n    \\n    int[] dp;\\n\\n    public NumArray(int[] nums) {\\n        \\n        if (nums.length == 0) {\\n            return;\\n        }\\n        \\n        dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            dp[i] = dp[i - 1] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        \\n        int beforeSum = i == 0 ? 0 : dp[i - 1];\\n        return dp[j] - beforeSum;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    \\n    int[] dp;\\n\\n    public NumArray(int[] nums) {\\n        \\n        if (nums.length == 0) {\\n            return;\\n        }\\n        \\n        dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            dp[i] = dp[i - 1] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        \\n        int beforeSum = i == 0 ? 0 : dp[i - 1];\\n        return dp[j] - beforeSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655347,
                "title": "java-segment-tree",
                "content": "**DP solution o(1) time per query**\\n**Space = O(n)**\\n```\\nclass NumArray {\\n    int dp[] ;\\n    public NumArray(int[] nums) {\\n        if( nums.length == 0)   return;\\n        dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        for(int i = 1 ;i < nums.length; i++){\\n            dp[i] = dp[i-1] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        if( i == 0)\\n            return dp[j];\\n        return dp[j] - dp[i-1];\\n    }\\n}\\n\\n\\n\\n```\\n\\n**Segment Tree solution O(logN) time per query**\\n**Space = O(n)**\\n```\\nclass NumArray {\\n    int tree[];\\n    int n;\\n    int build(int L, int R, int pos, int [] nums){\\n        if (L == R){\\n            tree[pos] = nums[L];\\n            return tree[pos];\\n        }\\n        int mid = (L + R )/2;\\n        tree[pos] = build(L, mid, pos*2, nums) + build(mid+1, R, pos*2+1, nums);\\n        return tree[pos];\\n        \\n    }\\n    public NumArray(int[] nums) {\\n        \\n        n = nums.length;\\n        if( n == 0) return;\\n        if( (n &(n-1)) == 0){\\n            tree = new int[2 * n];\\n        }\\n        else{\\n            int count = 0;\\n            int n1 = n;\\n            while( n1 > 0){\\n                count++;\\n                n1 >>= 1;\\n            }\\n            tree = new int[ 2 *( 1 <<count)];\\n            \\n        }\\n        build(0, n-1, 1, nums);\\n    }\\n    \\n    int find(int st, int end, int L, int R, int pos){\\n        if( end < L || R < st)\\n            return 0;\\n        if( st <= L && R <= end )\\n            return tree[pos];\\n        int mid = (L + R) /2;\\n        return find(st, end, L, mid, pos*2) + find(st, end, mid+1, R, pos*2+1);\\n    }\\n    public int sumRange(int i, int j) {\\n        \\n        return find(i, j , 0 , n-1,1);\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass NumArray {\\n    int dp[] ;\\n    public NumArray(int[] nums) {\\n        if( nums.length == 0)   return;\\n        dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        for(int i = 1 ;i < nums.length; i++){\\n            dp[i] = dp[i-1] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        if( i == 0)\\n            return dp[j];\\n        return dp[j] - dp[i-1];\\n    }\\n}\\n\\n\\n\\n```\n```\\nclass NumArray {\\n    int tree[];\\n    int n;\\n    int build(int L, int R, int pos, int [] nums){\\n        if (L == R){\\n            tree[pos] = nums[L];\\n            return tree[pos];\\n        }\\n        int mid = (L + R )/2;\\n        tree[pos] = build(L, mid, pos*2, nums) + build(mid+1, R, pos*2+1, nums);\\n        return tree[pos];\\n        \\n    }\\n    public NumArray(int[] nums) {\\n        \\n        n = nums.length;\\n        if( n == 0) return;\\n        if( (n &(n-1)) == 0){\\n            tree = new int[2 * n];\\n        }\\n        else{\\n            int count = 0;\\n            int n1 = n;\\n            while( n1 > 0){\\n                count++;\\n                n1 >>= 1;\\n            }\\n            tree = new int[ 2 *( 1 <<count)];\\n            \\n        }\\n        build(0, n-1, 1, nums);\\n    }\\n    \\n    int find(int st, int end, int L, int R, int pos){\\n        if( end < L || R < st)\\n            return 0;\\n        if( st <= L && R <= end )\\n            return tree[pos];\\n        int mid = (L + R) /2;\\n        return find(st, end, L, mid, pos*2) + find(st, end, mid+1, R, pos*2+1);\\n    }\\n    public int sumRange(int i, int j) {\\n        \\n        return find(i, j , 0 , n-1,1);\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638181,
                "title": "java-sparse-tabla",
                "content": "```\\nclass NumArray {\\n    int sparse[][];\\n    int A[];\\n    public NumArray(int[] A) {\\n        this.A=A;\\n        sparse=new int[A.length][31];\\n        for(int i=0;i<A.length;i++){\\n            sparse[i][0]=A[i];\\n        }\\n        for(int j=1;j<=30;j++){\\n            for(int i=0;i+(1<<j)<=A.length;i++){\\n                sparse[i][j]=sparse[i][j-1]+sparse[i+(1<<(j-1))][j-1];\\n            }\\n        }\\n    }\\n    public int sumRange(int L, int R) {\\n        int sum = 0;\\n        for (int j = 30; j >= 0; j--) {\\n            if (L+(1 << j) <= R+1) {// check if in range\\n                sum += sparse[L][j];\\n                L+=1<< j;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(i,j);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    int sparse[][];\\n    int A[];\\n    public NumArray(int[] A) {\\n        this.A=A;\\n        sparse=new int[A.length][31];\\n        for(int i=0;i<A.length;i++){\\n            sparse[i][0]=A[i];\\n        }\\n        for(int j=1;j<=30;j++){\\n            for(int i=0;i+(1<<j)<=A.length;i++){\\n                sparse[i][j]=sparse[i][j-1]+sparse[i+(1<<(j-1))][j-1];\\n            }\\n        }\\n    }\\n    public int sumRange(int L, int R) {\\n        int sum = 0;\\n        for (int j = 30; j >= 0; j--) {\\n            if (L+(1 << j) <= R+1) {// check if in range\\n                sum += sparse[L][j];\\n                L+=1<< j;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(i,j);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438454,
                "title": "very-simple-and-straight-forward-ruby-dp-solution",
                "content": "```\\ndef initialize(nums)\\n  @sum_cache = []\\n  sum = 0\\n  nums.each_with_index { |num, i|\\n\\tsum += num\\n\\t@sum_cache[i] = sum\\n  }\\nend\\n\\ndef sum_range(i, j)\\n  i == 0 ? @sum_cache[j] : @sum_cache[j] - @sum_cache[i-1]\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef initialize(nums)\\n  @sum_cache = []\\n  sum = 0\\n  nums.each_with_index { |num, i|\\n\\tsum += num\\n\\t@sum_cache[i] = sum\\n  }\\nend\\n\\ndef sum_range(i, j)\\n  i == 0 ? @sum_cache[j] : @sum_cache[j] - @sum_cache[i-1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 417809,
                "title": "simple-dp-based-solution-easy-to-understand",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar NumArray = function(nums) {\\n    this.nums = []\\n    let sum = 0;\\n    nums.forEach((val, i) => {\\n        sum+=val\\n        this.nums.push(sum)\\n    \\n    });\\n};\\n\\n/** \\n * @param {number} i \\n * @param {number} j\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(i, j) {\\n    let nums = this.nums;\\n    return nums[j] - (nums[i-1] || 0);\\n};\\n\\n/** \\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(i,j)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar NumArray = function(nums) {\\n    this.nums = []\\n    let sum = 0;\\n    nums.forEach((val, i) => {\\n        sum+=val\\n        this.nums.push(sum)\\n    \\n    });\\n};\\n\\n/** \\n * @param {number} i \\n * @param {number} j\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(i, j) {\\n    let nums = this.nums;\\n    return nums[j] - (nums[i-1] || 0);\\n};\\n\\n/** \\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(i,j)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 75253,
                "title": "java-accepted-solution",
                "content": "\\npublic class NumArray {\\n    List list = new ArrayList<Integer>();\\n    \\n    public NumArray(int[] nums) {\\n       //int[] num = new int[nums.length];\\n       if(nums.length == 0)\\n        return;\\n       list.add(0, nums[0]);\\n       for (int i=1; i<nums.length; i++){\\n           list.add(i, ((int)list.get(i-1) + nums[i]));\\n       }\\n    }\\n\\n\\n    public int sumRange(int i, int j) {\\n        if(i==0)\\n            return ((int)list.get(j));\\n        return ((int)list.get(j) - (int)list.get(i-1));\\n    }\\n}",
                "solutionTags": [],
                "code": "\\npublic class NumArray {\\n    List list = new ArrayList<Integer>();\\n    \\n    public NumArray(int[] nums) {\\n       //int[] num = new int[nums.length];\\n       if(nums.length == 0)\\n        return;\\n       list.add(0, nums[0]);\\n       for (int i=1; i<nums.length; i++){\\n           list.add(i, ((int)list.get(i-1) + nums[i]));\\n       }\\n    }\\n\\n\\n    public int sumRange(int i, int j) {\\n        if(i==0)\\n            return ((int)list.get(j));\\n        return ((int)list.get(j) - (int)list.get(i-1));\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 75280,
                "title": "java-accepted-solution",
                "content": "    public class NumArray {\\n    \\n        public NumArray(int[] nums) {\\n            int n = nums.length;\\n            if (n == 0) return;\\n            sum = new int[n];\\n            sum[0] = nums[0];\\n            for (int i = 1; i < n; i++) {\\n                sum[i] += sum[i-1] + nums[i];\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            if (sum == null) return 0;\\n            if (i == 0) \\n                return sum[j];\\n            else \\n                return sum[j] - sum[i-1];\\n        }\\n        int[] sum;\\n    }",
                "solutionTags": [
                    "Array"
                ],
                "code": "    public class NumArray {\\n    \\n        public NumArray(int[] nums) {\\n            int n = nums.length;\\n            if (n == 0) return;\\n            sum = new int[n];\\n            sum[0] = nums[0];\\n            for (int i = 1; i < n; i++) {\\n                sum[i] += sum[i-1] + nums[i];\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            if (sum == null) return 0;\\n            if (i == 0) \\n                return sum[j];\\n            else \\n                return sum[j] - sum[i-1];\\n        }\\n        int[] sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 75227,
                "title": "dynamic-programming-bottom-up-approach-java-with-explanation",
                "content": "public class NumArray {\\n\\n    private int sum[][];\\n    \\n    public NumArray(int[] nums) {\\n        int n = nums.length;\\n        sum = new int[n][n];\\n\\n        //init the base case\\n        for (int i = 0; i < n; i++) {\\n            sum[i][i] = nums[i];\\n        }\\n\\n        // using dp, go diagonally and process all sums, O(n^2) time with O(n^2) space.\\n        for (int i = 0, d = 0; i < n; i++, d = 0) {\\n            for (int j = i + 1; j < n; j++, d++) {\\n                // current location equals the previous sum on the top left plus the nums[d].\\n                sum[d][j] = sum[d + 1][j] + sum[d][d];\\n            }\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        return sum[i][j]; //O(1)\\n    }\\n\\n}\\n\\nI'm just posting this here in case anyone wanted to see a bottom up dynamic programming approach.\\n\\nI initially thought about this because I related it to subset-sum which is an NP-Complete problem.\\n\\nSince the problem mentioned dynamic programming, I started off with a bottom up approach instead of using memoization. \\n\\nIt has a O(n^2) init runtime/space. O(1) query.\\n\\nI saw other better solutions with O(n) init runtime/space and O(1) query.\\n\\nThis solution generates this 2d array:\\n\\n    -2 -2  1 -4 -2 -3\\n     0  0  3 -2  0 -1 \\n     0  0  3 -2  0 -1 \\n     0  0  0 -5 -3 -4 \\n     0  0  0  0  2  1 \\n     0  0  0  0  0 -1 \\n\\n    -2,  0,  3, -5,  2, -1\\n       -2,  3, -2, -3, 1\\n          1,  1,  0, -4 \\n            -4,  0, -1\\n              -2, -1\\n                -3",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "public class NumArray {\\n\\n    private int sum[][];\\n    \\n    public NumArray(int[] nums) {\\n        int n = nums.length;\\n        sum = new int[n][n];\\n\\n        //init the base case\\n        for (int i = 0; i < n; i++) {\\n            sum[i][i] = nums[i];\\n        }\\n\\n        // using dp, go diagonally and process all sums, O(n^2) time with O(n^2) space.\\n        for (int i = 0, d = 0; i < n; i++, d = 0) {\\n            for (int j = i + 1; j < n; j++, d++) {\\n                // current location equals the previous sum on the top left plus the nums[d].\\n                sum[d][j] = sum[d + 1][j] + sum[d][d];\\n            }\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        return sum[i][j]; //O(1)\\n    }\\n\\n}\\n\\nI'm just posting this here in case anyone wanted to see a bottom up dynamic programming approach.\\n\\nI initially thought about this because I related it to subset-sum which is an NP-Complete problem.\\n\\nSince the problem mentioned dynamic programming, I started off with a bottom up approach instead of using memoization. \\n\\nIt has a O(n^2) init runtime/space. O(1) query.\\n\\nI saw other better solutions with O(n) init runtime/space and O(1) query.\\n\\nThis solution generates this 2d array:\\n\\n    -2 -2  1 -4 -2 -3\\n     0  0  3 -2  0 -1 \\n     0  0  3 -2  0 -1 \\n     0  0  0 -5 -3 -4 \\n     0  0  0  0  2  1 \\n     0  0  0  0  0 -1 \\n\\n    -2,  0,  3, -5,  2, -1\\n       -2,  3, -2, -3, 1\\n          1,  1,  0, -4 \\n            -4,  0, -1\\n              -2, -1\\n                -3",
                "codeTag": "Java"
            },
            {
                "id": 75292,
                "title": "accepted-python-solution",
                "content": "This solution is not a O(N) look at the comment \"# No O(N) cause\", i don't know why, can't use \"nums[0]\" before loop, i got error out of range, so stranger!\\n    \\n    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.lists = [0]\\n        # error out of range when use nums[0] here\\n        # nums[0]\\n        for i, n in enumerate(nums):\\n            # No O(N) cause\\n            if i == 0:\\n                self.lists.append(nums[i])\\n            else:\\n                self.lists.append(self.lists[i] + n)\\n            \\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.lists[j+1] - self.lists[i]",
                "solutionTags": [
                    "Python"
                ],
                "code": "This solution is not a O(N) look at the comment \"# No O(N) cause\", i don't know why, can't use \"nums[0]\" before loop, i got error out of range, so stranger!\\n    \\n    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.lists = [0]\\n        # error out of range when use nums[0] here\\n        # nums[0]\\n        for i, n in enumerate(nums):\\n            # No O(N) cause\\n            if i == 0:\\n                self.lists.append(nums[i])\\n            else:\\n                self.lists.append(self.lists[i] + n)\\n            \\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.lists[j+1] - self.lists[i]",
                "codeTag": "Python3"
            },
            {
                "id": 75327,
                "title": "c-java-python-o-n-build-o-1-query",
                "content": "The problem is easy. The array is not changing therefore we don't need a Binary Indexed Tree or Segment Tree. Prefix sums can do the trick perfectly.\\n\\nOne argument is that reusing the nums array for underlying data structure is not a good idea. We should allocate new memory to store the sums in the constructor.\\n\\n**Java**\\n\\n    private int[] sums;\\n\\n    public NumArray(int[] nums) {\\n        sums = new int[nums.length + 1];\\n        for (int i = 0; i < nums.length; ++i)\\n            sums[i + 1] = sums[i] + nums[i];\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return sums[j + 1] - sums[i];\\n    }\\n\\n**Java with ArrayList**\\n\\n    private List<Integer> sums = new ArrayList<>(Collections.singletonList(0));\\n\\n    public NumArray(int[] nums) {\\n        for (int x : nums)\\n            sums.add(sums.get(sums.size() - 1) + x);\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return sums.get(j + 1) - sums.get(i);\\n    }\\n\\n\\n**C++**\\n\\n    vector<int> sums = {0};\\n    NumArray(vector<int> &nums) {\\n        for (auto x: nums)\\n            sums.push_back(sums.back() + x);\\n    }\\n    int sumRange(int i, int j) {\\n        return sums[j + 1] - sums[i];\\n    }\\n\\n**Python**\\n\\n    def __init__(self, nums):\\n        self.sums = [0]\\n        for x in nums:\\n            self.sums.append(self.sums[-1] + x)\\n\\n    def sumRange(self, i, j):\\n        return self.sums[j + 1] - self.sums[i]",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "The problem is easy. The array is not changing therefore we don't need a Binary Indexed Tree or Segment Tree. Prefix sums can do the trick perfectly.\\n\\nOne argument is that reusing the nums array for underlying data structure is not a good idea. We should allocate new memory to store the sums in the constructor.\\n\\n**Java**\\n\\n    private int[] sums;\\n\\n    public NumArray(int[] nums) {\\n        sums = new int[nums.length + 1];\\n        for (int i = 0; i < nums.length; ++i)\\n            sums[i + 1] = sums[i] + nums[i];\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return sums[j + 1] - sums[i];\\n    }\\n\\n**Java with ArrayList**\\n\\n    private List<Integer> sums = new ArrayList<>(Collections.singletonList(0));\\n\\n    public NumArray(int[] nums) {\\n        for (int x : nums)\\n            sums.add(sums.get(sums.size() - 1) + x);\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return sums.get(j + 1) - sums.get(i);\\n    }\\n\\n\\n**C++**\\n\\n    vector<int> sums = {0};\\n    NumArray(vector<int> &nums) {\\n        for (auto x: nums)\\n            sums.push_back(sums.back() + x);\\n    }\\n    int sumRange(int i, int j) {\\n        return sums[j + 1] - sums[i];\\n    }\\n\\n**Python**\\n\\n    def __init__(self, nums):\\n        self.sums = [0]\\n        for x in nums:\\n            self.sums.append(self.sums[-1] + x)\\n\\n    def sumRange(self, i, j):\\n        return self.sums[j + 1] - self.sums[i]",
                "codeTag": "Python3"
            },
            {
                "id": 4015571,
                "title": "prefix-sum-solution-with-step-by-step-explanation",
                "content": "# Intuition\\nFor this problem we would use prefix sum.\\n\\n# Approach\\nIn class NumArray we declare prefix array field, and in constructor we initiate it and calculaye prefix sum for nums array. In sumRange method we just return difference between right prfix sum and left.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> we iterate once for nums array\\n\\n- Space complexity:\\nO(n) -> we create prefix sum array of nums length + 1\\n# Code\\n```\\nclass NumArray {\\n    // declare prefix array field\\n    int[] prefix;\\n    public NumArray(int[] nums) {\\n        // initialize prefix sum array with nums length + 1\\n        prefix = new int[nums.length + 1];\\n        // iterate over nums array\\n        for(int i = 0; i < nums.length; i++) {\\n            // calculate prefix sum on each iteration\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        // return difference between right and left prefix sum\\n        return prefix[right + 1] - prefix[left];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    // declare prefix array field\\n    int[] prefix;\\n    public NumArray(int[] nums) {\\n        // initialize prefix sum array with nums length + 1\\n        prefix = new int[nums.length + 1];\\n        // iterate over nums array\\n        for(int i = 0; i < nums.length; i++) {\\n            // calculate prefix sum on each iteration\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        // return difference between right and left prefix sum\\n        return prefix[right + 1] - prefix[left];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684449,
                "title": "c-using-prefix-sum-t-c-o-n-o-1-s-c-o-n",
                "content": "```\\nclass NumArray {\\n    \\n    /*\\n        Time Complexity : O(N) + O(1)\\n        Space Complexity : O(N)\\n    */\\n    \\nprivate:\\n    vector<int> prefixSum;\\n    \\npublic:\\n    NumArray(vector<int>& nums) {\\n        prefixSum.resize(nums.size());\\n        \\n        prefixSum[0] = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left == 0){\\n            return prefixSum[right];\\n        }\\n        \\n        return prefixSum[right] - prefixSum[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    \\n    /*\\n        Time Complexity : O(N) + O(1)\\n        Space Complexity : O(N)\\n    */\\n    \\nprivate:\\n    vector<int> prefixSum;\\n    \\npublic:\\n    NumArray(vector<int>& nums) {\\n        prefixSum.resize(nums.size());\\n        \\n        prefixSum[0] = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left == 0){\\n            return prefixSum[right];\\n        }\\n        \\n        return prefixSum[right] - prefixSum[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605565,
                "title": "clean-code-using-prefix-sum-beats-97-13",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe problem requires calculating the sum of elements within a given range repeatedly. To optimize the time complexity, we can precompute the prefix sum array. This array will store the cumulative sum of elements up to each index. Then, to calculate the sum within a range, we can subtract the prefix sum at the starting index from the prefix sum at the ending index.\\n\\n# Approach\\n1. In the constructor, we initialize an array called answer to store the prefix sums of the input array.\\n1. We iterate over the input array and calculate the prefix sum at each index by adding the current element to the prefix sum of the previous index.\\n1. To calculate the range sum between left and right, we subtract the prefix sum at index left-1 from the prefix sum at index right.\\n1. If left is 0, we return the prefix sum at index right directly since there is no prefix sum before index 0.\\n1. Finally, we return the calculated range sum.\\n\\n# Complexity\\n- Time complexity:\\nThe initialization step in the constructor takes $$O(n)$$ time, where n is the length of the input array. Each range sum query in the sumRange method takes $$O(1)$$ time since it involves only constant-time subtractions.\\n- Space complexity:\\nThe space complexity is $$O(n)$$ since we use an additional array answer to store the prefix sums, where n is the length of the input array.\\n# Code\\n```\\nclass NumArray {\\n    int[] answer;\\n    \\n    public NumArray(int[] nums) {\\n        answer = new int[nums.length];\\n        int n = nums.length;\\n        answer[0] = nums[0];\\n        \\n        // Calculate prefix sums for the input array\\n        for (int i = 1; i < n; i++) {\\n            answer[i] = nums[i] + answer[i - 1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        // Calculate the range sum using prefix sums\\n        \\n        if (left == 0) {\\n            return answer[right];\\n        }\\n        return answer[right] - answer[left - 1];\\n    }\\n}\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/8d695c6c-86d8-4a70-8d9e-19496759655d_1686068201.7162793.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    int[] answer;\\n    \\n    public NumArray(int[] nums) {\\n        answer = new int[nums.length];\\n        int n = nums.length;\\n        answer[0] = nums[0];\\n        \\n        // Calculate prefix sums for the input array\\n        for (int i = 1; i < n; i++) {\\n            answer[i] = nums[i] + answer[i - 1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        // Calculate the range sum using prefix sums\\n        \\n        if (left == 0) {\\n            return answer[right];\\n        }\\n        return answer[right] - answer[left - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057568,
                "title": "dart-solution",
                "content": "# Code\\n```\\nclass NumArray {\\n  List<int> arr = [];\\n\\n  NumArray(List<int> nums) {\\n    List<int> sums = [];\\n    var currentSum = 0;\\n    for (var num in nums) {\\n      currentSum += num;\\n      sums.add(currentSum);\\n    }\\n    arr = sums;\\n  }\\n\\n  int sumRange(int left, int right) {\\n    if (left == 0) {\\n      return arr[right];\\n    }\\n    return arr[right] - arr[left - 1];\\n  }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = NumArray(nums);\\n * int param1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass NumArray {\\n  List<int> arr = [];\\n\\n  NumArray(List<int> nums) {\\n    List<int> sums = [];\\n    var currentSum = 0;\\n    for (var num in nums) {\\n      currentSum += num;\\n      sums.add(currentSum);\\n    }\\n    arr = sums;\\n  }\\n\\n  int sumRange(int left, int right) {\\n    if (left == 0) {\\n      return arr[right];\\n    }\\n    return arr[right] - arr[left - 1];\\n  }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = NumArray(nums);\\n * int param1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019454,
                "title": "accepted-swift",
                "content": "```\\nclass NumArray {\\n    \\n    private let nums: [Int]\\n\\n    init(_ nums: [Int]) {\\n        self.nums = nums\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        nums[left...right].reduce(0, +)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass NumArray {\\n    \\n    private let nums: [Int]\\n\\n    init(_ nums: [Int]) {\\n        self.nums = nums\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        nums[left...right].reduce(0, +)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916819,
                "title": "easy-to-understand-c-solution-prefix-sum-na-ve-approach",
                "content": "## Code: Na\\xEFve Approach\\n```\\nclass NumArray {\\npublic:\\n    vector<int> nums;\\n    NumArray(vector<int>& nums) {\\n        for (auto val: nums){\\n            (this->nums).push_back(val);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int sum=0;\\n        for (int i= left; i<=right; i++)sum+= nums[i];\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```\\n### Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n---\\n\\n\\n## Code: Prefix Sum\\n```\\nclass NumArray {\\nprivate:\\n    vector<int> pref;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        pref.push_back(nums[0]);\\n        for (int i=1; i<nums.size(); i++){\\n            pref.push_back(pref[i-1]+nums[i]);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left==0){\\n            return pref[right];\\n        }\\n        return pref[right]-pref[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```\\n\\n### Complexity\\n- Time complexity: O(1) for call, O(N) on initialisation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> nums;\\n    NumArray(vector<int>& nums) {\\n        for (auto val: nums){\\n            (this->nums).push_back(val);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int sum=0;\\n        for (int i= left; i<=right; i++)sum+= nums[i];\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```\n```\\nclass NumArray {\\nprivate:\\n    vector<int> pref;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        pref.push_back(nums[0]);\\n        for (int i=1; i<nums.size(); i++){\\n            pref.push_back(pref[i-1]+nums[i]);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left==0){\\n            return pref[right];\\n        }\\n        return pref[right]-pref[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826445,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass NumArray {\\n    int[] arr;\\n    public NumArray(int[] nums) {\\n        arr = nums;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for (int i = left; i <= right; i++) sum += arr[i];\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    int[] arr;\\n    public NumArray(int[] nums) {\\n        arr = nums;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for (int i = left; i <= right; i++) sum += arr[i];\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812741,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n\\n   class NumArray { \\npublic:\\n    vector<int>& preSum; \\n    \\n    NumArray(vector<int>& nums) : preSum(nums) {\\n        for (int i = 1; i < preSum.size(); ++i)\\n            preSum[i] += preSum[i-1]; \\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left == 0) return preSum[right];\\n        return preSum[right] - preSum[left-1];\\n    }\\n};\\n\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   class NumArray { \\npublic:\\n    vector<int>& preSum; \\n    \\n    NumArray(vector<int>& nums) : preSum(nums) {\\n        for (int i = 1; i < preSum.size(); ++i)\\n            preSum[i] += preSum[i-1]; \\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left == 0) return preSum[right];\\n        return preSum[right] - preSum[left-1];\\n    }\\n};\\n\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698174,
                "title": "typescript-prefix-sum",
                "content": "# Intuition\\nhave a way to cache query, since the question says the query function would have a lot of hits\\n\\n\\n# Approach\\nCreate pre-calculated sums (prefix-sum) and use that to derive sums for each query\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ for creation \\n$$O(1)$$ for query \\n \\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass NumArray {\\n    private nums : number[];\\n    private prefixSum: number[];\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n        this.prefixSum = [0]\\n        // num --> [-2,0,3,-5,2,-1]\\n        // prefixSum --> [0,-2,-2,1,-4,-2,-3]\\n        for(let i = 0; i < nums.length;i++){\\n            this.prefixSum[i+1] = this.prefixSum[i] + this.nums[i]\\n        }\\n    }\\n\\n    sumRange(left: number, right: number): number {\\n        return  this.prefixSum[right+1] -  this.prefixSum[left]\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(left,right)\\n */\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    private nums : number[];\\n    private prefixSum: number[];\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n        this.prefixSum = [0]\\n        // num --> [-2,0,3,-5,2,-1]\\n        // prefixSum --> [0,-2,-2,1,-4,-2,-3]\\n        for(let i = 0; i < nums.length;i++){\\n            this.prefixSum[i+1] = this.prefixSum[i] + this.nums[i]\\n        }\\n    }\\n\\n    sumRange(left: number, right: number): number {\\n        return  this.prefixSum[right+1] -  this.prefixSum[left]\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(left,right)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576594,
                "title": "c-solution",
                "content": "class NumArray {\\npublic: vector<int>nums;\\n    NumArray(vector<int>& nums) {\\n        this->nums = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return accumulate(this->nums.begin()+left, this->nums.begin()+right+1, 0);\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class NumArray {\\npublic: vector<int>nums;\\n    NumArray(vector<int>& nums) {\\n        this->nums = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return accumulate(this->nums.begin()+left, this->nums.begin()+right+1, 0);\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2474605,
                "title": "javascript-straightforward-class-solution",
                "content": "```\\nclass NumArray {\\n    data = [];\\n\\n    constructor(numbers) {\\n        this.data = numbers;\\n    }\\n\\n    sumRange(left, right) {\\n        let sum = 0;\\n\\n        for (let i = left; i <= right; i++) {\\n            sum += this.data[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass NumArray {\\n    data = [];\\n\\n    constructor(numbers) {\\n        this.data = numbers;\\n    }\\n\\n    sumRange(left, right) {\\n        let sum = 0;\\n\\n        for (let i = left; i <= right; i++) {\\n            sum += this.data[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401393,
                "title": "python-easy-one-liner-solution-beats-90",
                "content": "**Python Easy One liner Solution**\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326150,
                "title": "range-sum-query-using-segment-tree-cpp-solution",
                "content": "![image](https://assets.leetcode.com/users/images/a566658d-e90f-4ad7-8547-a1c7cc153b78_1658650817.0123808.jpeg)\\n![image](https://assets.leetcode.com/users/images/ca86eb8e-29d7-4cdb-b2c8-dd0cbb7bf95b_1658650780.442661.jpeg)\\n```\\nclass NumArray {\\npublic:\\n    vector<int> seg;\\n    int n;\\n    void build(int index,vector<int>& nums,int l,int r){\\n        if(l==r){\\n            seg[index] = nums[l];\\n            return;\\n        }\\n        int mid = (l+r)/2;\\n        build(2*index+1,nums,l,mid);\\n        build(2*index+2,nums,mid+1,r);\\n        seg[index] = seg[2*index+1]+seg[2*index+2];\\n    }\\n    int getSum(int index,int sl,int sr,int l,int r){\\n        if(sr<l or sl>r) return 0;//no over-lap\\n        if(sl>=l and sr<=r) return seg[index];//completly overlap\\n        //partial overlap\\n        int mid = (sl+sr)/2;\\n        int left = getSum(2*index+1,sl,mid,l,r);\\n        int right = getSum(2*index+2,mid+1,sr,l,r);\\n        return left+right;\\n    }\\n    NumArray(vector<int>& nums) {\\n        n = nums.size();\\n        seg.resize(n*4);\\n        build(0,nums,0,n-1);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return getSum(0,0,n-1,left,right);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> seg;\\n    int n;\\n    void build(int index,vector<int>& nums,int l,int r){\\n        if(l==r){\\n            seg[index] = nums[l];\\n            return;\\n        }\\n        int mid = (l+r)/2;\\n        build(2*index+1,nums,l,mid);\\n        build(2*index+2,nums,mid+1,r);\\n        seg[index] = seg[2*index+1]+seg[2*index+2];\\n    }\\n    int getSum(int index,int sl,int sr,int l,int r){\\n        if(sr<l or sl>r) return 0;//no over-lap\\n        if(sl>=l and sr<=r) return seg[index];//completly overlap\\n        //partial overlap\\n        int mid = (sl+sr)/2;\\n        int left = getSum(2*index+1,sl,mid,l,r);\\n        int right = getSum(2*index+2,mid+1,sr,l,r);\\n        return left+right;\\n    }\\n    NumArray(vector<int>& nums) {\\n        n = nums.size();\\n        seg.resize(n*4);\\n        build(0,nums,0,n-1);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return getSum(0,0,n-1,left,right);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212693,
                "title": "python-simple-python-solution-using-two-approach",
                "content": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# First Solution Using Prefix Sum -\\n\\tclass NumArray:\\n\\n\\t\\tdef __init__(self, nums: List[int]):\\n\\t\\t\\tself.nums = nums\\n\\t\\t\\tif len(self.nums) == 0:\\n\\t\\t\\t\\treturn None\\n\\n\\t\\t\\tself.dp = [0]*(len(self.nums))\\n\\t\\t\\ts = 0\\n\\t\\t\\tj = 0\\n\\t\\t\\tfor i in self.nums:\\n\\t\\t\\t\\ts = s + i\\n\\t\\t\\t\\tself.dp[j] = s\\n\\t\\t\\t\\tj = j + 1\\n\\n\\t\\tdef sumRange(self, i: int, j: int) -> int:\\n\\t\\t\\tif i == 0:\\n\\t\\t\\t\\treturn self.dp[j]\\n\\t\\t\\treturn self.dp[j] - self.dp[i-1]\\n\\n# Second Solution -\\n\\n\\tclass NumArray:\\n\\n\\t\\tdef __init__(self, nums: List[int]):\\n\\n\\t\\t\\tself.array = nums\\n\\n\\t\\tdef sumRange(self, left: int, right: int) -> int:\\n\\n\\t\\t\\tresult = sum(self.array[left:right+1])\\n\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# First Solution Using Prefix Sum -\\n\\tclass NumArray:\\n\\n\\t\\tdef __init__(self, nums: List[int]):\\n\\t\\t\\tself.nums = nums\\n\\t\\t\\tif len(self.nums) == 0:\\n\\t\\t\\t\\treturn None\\n\\n\\t\\t\\tself.dp = [0]*(len(self.nums))\\n\\t\\t\\ts = 0\\n\\t\\t\\tj = 0\\n\\t\\t\\tfor i in self.nums:\\n\\t\\t\\t\\ts = s + i\\n\\t\\t\\t\\tself.dp[j] = s\\n\\t\\t\\t\\tj = j + 1\\n\\n\\t\\tdef sumRange(self, i: int, j: int) -> int:\\n\\t\\t\\tif i == 0:\\n\\t\\t\\t\\treturn self.dp[j]\\n\\t\\t\\treturn self.dp[j] - self.dp[i-1]\\n\\n# Second Solution -\\n\\n\\tclass NumArray:\\n\\n\\t\\tdef __init__(self, nums: List[int]):\\n\\n\\t\\t\\tself.array = nums\\n\\n\\t\\tdef sumRange(self, left: int, right: int) -> int:\\n\\n\\t\\t\\tresult = sum(self.array[left:right+1])\\n\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 2105333,
                "title": "c-prefix-sum",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int> sum;\\n    NumArray(vector<int>& nums) {\\n        int total=0;\\n        sum.emplace_back(0);\\n        for(auto i: nums){\\n            total += i;\\n            sum.emplace_back(total);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return sum[right+1] - sum[left];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> sum;\\n    NumArray(vector<int>& nums) {\\n        int total=0;\\n        sum.emplace_back(0);\\n        for(auto i: nums){\\n            total += i;\\n            sum.emplace_back(total);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return sum[right+1] - sum[left];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986451,
                "title": "java-optimized-solution-using-prefix-sum-approach",
                "content": "\\nclass NumArray {\\n\\n    private int[] nums;\\n    private int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        this.nums=nums;\\n        this.prefixSum= calculatePrefixSum();\\n    }\\n\\n    private int[] calculatePrefixSum(){\\n        int[] arr = new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+= nums[i];\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if(left>0){\\n            return prefixSum[right]-prefixSum[left-1];\\n        } else{\\n            return prefixSum[right];\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "\\nclass NumArray {\\n\\n    private int[] nums;\\n    private int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        this.nums=nums;\\n        this.prefixSum= calculatePrefixSum();\\n    }\\n\\n    private int[] calculatePrefixSum(){\\n        int[] arr = new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+= nums[i];\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if(left>0){\\n            return prefixSum[right]-prefixSum[left-1];\\n        } else{\\n            return prefixSum[right];\\n        }\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1924208,
                "title": "c-segment-tree",
                "content": "Did this in segment tree just for practicing. Prefix sum would be faster.\\n```\\nclass NumArray {\\npublic:\\n    vector<int> seg;\\n    int size;\\n    NumArray(vector<int>& nums) {\\n        size = nums.size();\\n        seg.resize(size*4, 0);\\n        \\n        build(nums, 0, 0, size-1);\\n    }\\n    \\n    void build(vector<int>& nums, int v, int left, int right){\\n        if(left==right){\\n            seg[v]=nums[left];\\n        }else{\\n            int mid = left+(right-left)/2;\\n            build(nums, 2*v+1, left, mid);\\n            build(nums, 2*v+2, mid+1, right);\\n            seg[v]=seg[v*2+1]+seg[v*2+2];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return sum(left, right, 0, 0, size-1);\\n    }\\n    \\n    int sum(int left, int right, int v, int l, int r){\\n        if(left>right){\\n            return 0;\\n        }\\n        if(l==left && r==right){\\n            return seg[v];\\n        }\\n        \\n        int mid=l+(r-l)/2;\\n        \\n        return sum(left, min(right, mid), v*2+1, l, mid)+sum(max(mid+1, left), right, v*2+2, mid+1, r);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> seg;\\n    int size;\\n    NumArray(vector<int>& nums) {\\n        size = nums.size();\\n        seg.resize(size*4, 0);\\n        \\n        build(nums, 0, 0, size-1);\\n    }\\n    \\n    void build(vector<int>& nums, int v, int left, int right){\\n        if(left==right){\\n            seg[v]=nums[left];\\n        }else{\\n            int mid = left+(right-left)/2;\\n            build(nums, 2*v+1, left, mid);\\n            build(nums, 2*v+2, mid+1, right);\\n            seg[v]=seg[v*2+1]+seg[v*2+2];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return sum(left, right, 0, 0, size-1);\\n    }\\n    \\n    int sum(int left, int right, int v, int l, int r){\\n        if(left>right){\\n            return 0;\\n        }\\n        if(l==left && r==right){\\n            return seg[v];\\n        }\\n        \\n        int mid=l+(r-l)/2;\\n        \\n        return sum(left, min(right, mid), v*2+1, l, mid)+sum(max(mid+1, left), right, v*2+2, mid+1, r);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831760,
                "title": "rust",
                "content": "```rust\\nstruct NumArray {\\n    prev_sum: Vec<i32>,\\n}\\n\\n/**\\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl NumArray {\\n    fn new(nums: Vec<i32>) -> Self {\\n        let mut prev_sum = vec![0; nums.len() + 1];\\n        for i in 0..nums.len() {\\n            prev_sum[i + 1] = prev_sum[i] + nums[i];\\n        }\\n        Self { prev_sum }\\n    }\\n\\n    fn sum_range(&self, left: i32, right: i32) -> i32 {\\n        self.prev_sum[right as usize + 1] - self.prev_sum[left as usize]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nstruct NumArray {\\n    prev_sum: Vec<i32>,\\n}\\n\\n/**\\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl NumArray {\\n    fn new(nums: Vec<i32>) -> Self {\\n        let mut prev_sum = vec![0; nums.len() + 1];\\n        for i in 0..nums.len() {\\n            prev_sum[i + 1] = prev_sum[i] + nums[i];\\n        }\\n        Self { prev_sum }\\n    }\\n\\n    fn sum_range(&self, left: i32, right: i32) -> i32 {\\n        self.prev_sum[right as usize + 1] - self.prev_sum[left as usize]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786869,
                "title": "prefix-sum-python",
                "content": "```\\ndef __init__(self, nums: List[int]):\\n        self.prefixSum = [nums[0]]  \\n        #Creating Prefix Sum array \\n        # To avoid traversing array for each query \\n        for i in range(1,len(nums)):\\n            self.prefixSum.append(self.prefixSum[i-1] + nums[i])\\n            \\n    def sumRange(self, L: int, R: int) -> int:\\n        # if L==0 return prefixSum[right]\\n        # else prefixSum[right]- prefixSum[left-1] beacuse to avoid prefix sum of element from the starting of the array\\n        return self.prefixSum[R] - self.prefixSum[L-1] if L>0 else self.prefixSum[R] \\n",
                "solutionTags": [],
                "code": "```\\ndef __init__(self, nums: List[int]):\\n        self.prefixSum = [nums[0]]  \\n        #Creating Prefix Sum array \\n        # To avoid traversing array for each query \\n        for i in range(1,len(nums)):\\n            self.prefixSum.append(self.prefixSum[i-1] + nums[i])\\n            \\n    def sumRange(self, L: int, R: int) -> int:\\n        # if L==0 return prefixSum[right]\\n        # else prefixSum[right]- prefixSum[left-1] beacuse to avoid prefix sum of element from the starting of the array\\n        return self.prefixSum[R] - self.prefixSum[L-1] if L>0 else self.prefixSum[R] \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1767181,
                "title": "c-prefix-sum-method-with-detailed-explanation",
                "content": "The idea of the Prefix Sum array can be applied here. We accumulate the values of nums[i] into a new vector arr such that arr[i] carries the sum of values in the range[0,i] (i.e. inclusively).\\n\\nHence, given a range [left, right] whose sum we want, we can use this property of the prefix sum. The sum of values from nums[left] to nums[right] (inclusive) can be computed by the difference `arr[right] - arr[left-1]`.\\n\\n**Why arr[left-1], and not just arr[left]?**\\n`arr[right]` will be storing the sum of values from [0,right]. `arr[left]` will be storing the sum of values from [0,left]. Now, we just want to remove the accumulated sum from elements before left (which will render us the sum of elements in range [left,right]).\\n\\nIf we subtract `arr[left]`, then we will also be removing the value `nums[left]` from the total sum because `arr[left] = nums[0] + nums[1] + .... + nums[left]`. Hence, we rather subtract `arr[left-1]`, meaning we remove only values uptil `nums[left-1]`, and not `nums[left]` as well.\\n\\nHence, `arr[right] - arr[left] = nums[left] + nums[left+1] + .... + nums[right]`.\\n```\\nclass NumArray {\\npublic:\\n\\tvector<int>& arr; // by reference rather than by copy (hence memory is now O(1))\\n    \\n    NumArray(vector<int>& nums) : arr(nums) {\\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            arr[i] = arr[i-1] + nums[i];\\n        }\\n    }\\n\\t\\n    int sumRange(int left, int right) {\\n        if(left == 0) return arr[right];\\n        \\n        return arr[right] - arr[left-1];\\n        // we do \\'left-1\\' because arr[left] will also include the val of nums[left]\\n        // and hence we will end up subtracting that value as well, whereas we just\\n        // wanted to remove values uptil nums[left-1].\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n\\tvector<int>& arr; // by reference rather than by copy (hence memory is now O(1))\\n    \\n    NumArray(vector<int>& nums) : arr(nums) {\\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            arr[i] = arr[i-1] + nums[i];\\n        }\\n    }\\n\\t\\n    int sumRange(int left, int right) {\\n        if(left == 0) return arr[right];\\n        \\n        return arr[right] - arr[left-1];\\n        // we do \\'left-1\\' because arr[left] will also include the val of nums[left]\\n        // and hence we will end up subtracting that value as well, whereas we just\\n        // wanted to remove values uptil nums[left-1].\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765551,
                "title": "presum-list-python3",
                "content": "Construct the instance takes O(N), but the sumRange is O(1), given that sumRange would be called multiple times, it is worth it to pre-calculated the presum list. The first element is zero becuase the sum before the 0 index num is zero,\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        accu_sum = 0\\n        self._pre_sum = [0,]\\n        for num in nums:\\n            accu_sum += num\\n            self._pre_sum.append(accu_sum)\\n            \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self._pre_sum[right+1] - self._pre_sum[left]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        accu_sum = 0\\n        self._pre_sum = [0,]\\n        for num in nums:\\n            accu_sum += num\\n            self._pre_sum.append(accu_sum)\\n            \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self._pre_sum[right+1] - self._pre_sum[left]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540785,
                "title": "c-easy",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int>s;\\n    NumArray(vector<int>& nums) {\\n        s=nums;\\n        for(int i=1;i<nums.size();i++)s[i]=s[i-1]+nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(!left) return s[right];\\n        return s[right]-s[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int>s;\\n    NumArray(vector<int>& nums) {\\n        s=nums;\\n        for(int i=1;i<nums.size();i++)s[i]=s[i-1]+nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(!left) return s[right];\\n        return s[right]-s[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489427,
                "title": "java-fastest-easiest",
                "content": "```\\nclass NumArray {\\n    int sums[];\\n    public NumArray(int[] nums) {\\n      this.prefix=new int[nums.length];\\n      fillPrefixArr(nums);  \\n    }\\n    public void fillPrefixArr(int []nums){\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            this.sums[i]=sum;\\n        }\\n    }\\n    public int sumRange(int left, int right) {\\n                      //this will give the sum of range\\n    //sum of higher range - sum of (lower range-1)(bcoz we also need lower range\\'s element)\\n        return left> 0 ?sums[right]-sums[left-1]:sums[right];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    int sums[];\\n    public NumArray(int[] nums) {\\n      this.prefix=new int[nums.length];\\n      fillPrefixArr(nums);  \\n    }\\n    public void fillPrefixArr(int []nums){\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            this.sums[i]=sum;\\n        }\\n    }\\n    public int sumRange(int left, int right) {\\n                      //this will give the sum of range\\n    //sum of higher range - sum of (lower range-1)(bcoz we also need lower range\\'s element)\\n        return left> 0 ?sums[right]-sums[left-1]:sums[right];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426429,
                "title": "faster-than-100-java-solutions-prefix-sum",
                "content": "\\n```\\nclass NumArray {\\n    \\n    int[] arr;\\n    \\n    public NumArray(int[] nums) {\\n        arr= new int[nums.length+1];\\n        int j=1;\\n        for(int i: nums){\\n            arr[j]=arr[j-1]+i;\\n            j++;\\n        }    \\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return arr[right+1]-arr[left];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    \\n    int[] arr;\\n    \\n    public NumArray(int[] nums) {\\n        arr= new int[nums.length+1];\\n        int j=1;\\n        for(int i: nums){\\n            arr[j]=arr[j-1]+i;\\n            j++;\\n        }    \\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return arr[right+1]-arr[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417475,
                "title": "python-o-n-space-o-1-tc-using-prefix-sums",
                "content": "*idea*:\\nCalculating the sum from i to j, is the same as calculating the difference between sum[0:j] - sum[0:i], where the elements of i and j are inclusive\\n\\nWith that idea, we can implement it by pre calculating an array, the holds the SumSoFar from 0 up to the current index.\\ne.g\\nnums = [1,2,3,4]\\npreFixSum = [0,1,3,6,10] \\n\\nwhen i = 1, and j =2\\nsumrange of nums[1]+nums[2] = prefixSum[2+1]-prefixsum[1] = 6-1 = 5\\n\\n\\n```python\\nclass NumArray:\\n    \\n    nums = None\\n    prefixSum = None\\n    \\n    def __init__(self, nums: List[int]):\\n        self.nums = nums.copy()\\n        self.prefixSum = [0] * (len(nums)+1)\\n        currentsum=0\\n        for i in range(0,len(nums)):\\n            currentsum+=nums[i]\\n            self.prefixSum[i+1] = currentsum\\n            \\n            \\'\\'\\'\\n            [1,2,3,4]\\n            [0,1,3,6,10] prefix\\n            [1,3] = prefix[right+1] - prefix[1] = 10-1 = 5\\n            \\'\\'\\'\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefixSum[right+1] - self.prefixSum[left]\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass NumArray:\\n    \\n    nums = None\\n    prefixSum = None\\n    \\n    def __init__(self, nums: List[int]):\\n        self.nums = nums.copy()\\n        self.prefixSum = [0] * (len(nums)+1)\\n        currentsum=0\\n        for i in range(0,len(nums)):\\n            currentsum+=nums[i]\\n            self.prefixSum[i+1] = currentsum\\n            \\n            \\'\\'\\'\\n            [1,2,3,4]\\n            [0,1,3,6,10] prefix\\n            [1,3] = prefix[right+1] - prefix[1] = 10-1 = 5\\n            \\'\\'\\'\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefixSum[right+1] - self.prefixSum[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407479,
                "title": "segment-tree-solution-20-ms-17-2mb",
                "content": "```\\nclass NumArray {\\npublic:\\n    int* tree;\\n    int size;\\n\\n    NumArray(vector<int>& nums) {\\n        // build\\n        size = nums.size();\\n        init_tree(size);\\n\\n        build_tree(nums, 1, 0, nums.size()-1);\\n    }\\n\\n    void init_tree(int size) {\\n        tree = new int[4*size];\\n    }\\n\\n    void build_tree(vector<int>& nums, int node, int b, int e) {\\n        // sum from b till e will be in tree[node]\\n\\n        if (b == e) {\\n            tree[node] = nums[b];\\n            return;\\n        }\\n\\n        int mid = (b+e)/2;\\n        int left = 2*node;\\n        int right = 2*node+1;\\n\\n        build_tree(nums, left, b, mid);\\n        build_tree(nums, right, mid+1, e);\\n\\n        // fetch sum from subordinate nodes\\n        tree[node] = tree[left]+tree[right];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        // query\\n        int ans = query(1, 0, size-1, left, right);\\n\\n        return ans;\\n    }\\n\\n    int query(int node, int b, int e, int i, int j) {\\n        // current node contains sum from index b to index e\\n        // looking for the sum from index i to index j\\n\\n        // this node contains the range sum that is not included in desired range\\n        if (i > e or j < b) return 0;\\n\\n        // this node contains the range sum that is a subrange of the desired range\\n        if (i <= b and e <= j) return tree[node];\\n\\n        // oterwise go to the subordinate nodes\\n        int mid = (b+e)/2;\\n        int left = 2*node;\\n        int right = 2*node+1;\\n\\n        int ret1 = query(left, b, mid, i, j);\\n        int ret2 = query(right, mid+1, e, i, j);\\n\\n        // return the sum got from the subordinate nodes\\n        return ret1+ret2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    int* tree;\\n    int size;\\n\\n    NumArray(vector<int>& nums) {\\n        // build\\n        size = nums.size();\\n        init_tree(size);\\n\\n        build_tree(nums, 1, 0, nums.size()-1);\\n    }\\n\\n    void init_tree(int size) {\\n        tree = new int[4*size];\\n    }\\n\\n    void build_tree(vector<int>& nums, int node, int b, int e) {\\n        // sum from b till e will be in tree[node]\\n\\n        if (b == e) {\\n            tree[node] = nums[b];\\n            return;\\n        }\\n\\n        int mid = (b+e)/2;\\n        int left = 2*node;\\n        int right = 2*node+1;\\n\\n        build_tree(nums, left, b, mid);\\n        build_tree(nums, right, mid+1, e);\\n\\n        // fetch sum from subordinate nodes\\n        tree[node] = tree[left]+tree[right];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        // query\\n        int ans = query(1, 0, size-1, left, right);\\n\\n        return ans;\\n    }\\n\\n    int query(int node, int b, int e, int i, int j) {\\n        // current node contains sum from index b to index e\\n        // looking for the sum from index i to index j\\n\\n        // this node contains the range sum that is not included in desired range\\n        if (i > e or j < b) return 0;\\n\\n        // this node contains the range sum that is a subrange of the desired range\\n        if (i <= b and e <= j) return tree[node];\\n\\n        // oterwise go to the subordinate nodes\\n        int mid = (b+e)/2;\\n        int left = 2*node;\\n        int right = 2*node+1;\\n\\n        int ret1 = query(left, b, mid, i, j);\\n        int ret2 = query(right, mid+1, e, i, j);\\n\\n        // return the sum got from the subordinate nodes\\n        return ret1+ret2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407220,
                "title": "java-solution",
                "content": "```\\nclass NumArray {\\n    // solution 1 naive approach\\n//     List<Integer> list = new ArrayList<>();\\n//     public NumArray(int[] nums) {\\n//         for(int i=0;i<nums.length;i++)\\n//             list.add(nums[i]);\\n//     }\\n    \\n//     public int sumRange(int left, int right) {\\n//         int sum=0;\\n//         for(int i=left;i<=right;i++){\\n//             sum = sum + list.get(i);\\n//         }\\n//         return sum;\\n//     }\\n    \\n    // solution 2 using prefix sum\\n    int[] prefixSum = null;\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length + 1];\\n        for(int i=0;i<nums.length;i++){\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n    \\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    // solution 1 naive approach\\n//     List<Integer> list = new ArrayList<>();\\n//     public NumArray(int[] nums) {\\n//         for(int i=0;i<nums.length;i++)\\n//             list.add(nums[i]);\\n//     }\\n    \\n//     public int sumRange(int left, int right) {\\n//         int sum=0;\\n//         for(int i=left;i<=right;i++){\\n//             sum = sum + list.get(i);\\n//         }\\n//         return sum;\\n//     }\\n    \\n    // solution 2 using prefix sum\\n    int[] prefixSum = null;\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length + 1];\\n        for(int i=0;i<nums.length;i++){\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n    \\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407112,
                "title": "kotlin-o-1-query-o-n-space-solution",
                "content": "```\\nclass NumArray(nums: IntArray) {\\n\\n    val accSum = IntArray(nums.size + 1).also {\\n        for (i in 1..it.lastIndex) {\\n            it[i] = it[i - 1] + nums[i - 1]\\n        }\\n    }\\n\\n    fun sumRange(left: Int, right: Int): Int {\\n        return accSum[right + 1] - accSum[left]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass NumArray(nums: IntArray) {\\n\\n    val accSum = IntArray(nums.size + 1).also {\\n        for (i in 1..it.lastIndex) {\\n            it[i] = it[i - 1] + nums[i - 1]\\n        }\\n    }\\n\\n    fun sumRange(left: Int, right: Int): Int {\\n        return accSum[right + 1] - accSum[left]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406810,
                "title": "simple-o-n-and-o-1-query",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int> pref;\\n    NumArray(vector<int>& nums) {\\n        pref.resize(nums.size() + 1);\\n        pref[0] = nums[0];\\n        \\n        for(int i = 1; i <nums.size(); i++)\\n            pref[i] = pref[i-1] + nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left == 0)\\n        return pref[right];\\n        else\\n        return pref[right] - pref[left - 1];\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> pref;\\n    NumArray(vector<int>& nums) {\\n        pref.resize(nums.size() + 1);\\n        pref[0] = nums[0];\\n        \\n        for(int i = 1; i <nums.size(); i++)\\n            pref[i] = pref[i-1] + nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left == 0)\\n        return pref[right];\\n        else\\n        return pref[right] - pref[left - 1];\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1406806,
                "title": "python3-a-neat-clean-segment-tree-solution",
                "content": "***CODE***\\n```\\nclass NumArray:\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.n = len(self.nums)\\n        self.tree = [0]*4*self.n  # why 4? check the reference!\\n        self.build(1, 0, self.n-1)\\n\\t\\n    # builds the segment tree, x is curr index, l is left and r is right\\n    def build(self, x, l, r):\\n        if l == r: \\n            self.tree[x] = self.nums[l]\\n        else:\\n            m = (l+r)//2\\n            self.build(2*x, l, m)\\n            self.build(2*x+1, m+1, r)\\n            self.tree[x] = self.tree[x*2]+self.tree[x*2+1]\\n\\n    # tl and tr are target left and target right\\n\\tdef _sum(self, x, l, r, tl, tr):\\n        if tl > tr:\\n            return 0\\n        if l == tl and r == tr:\\n            return self.tree[x]\\n        m = (l+r)//2\\n        return self._sum(x*2, l, m, tl, min(m, tr)) + self._sum(x*2+1, m+1, r, max(m+1, tl), tr)\\n\\n        \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self._sum(1, 0, self.n-1, left, right)\\n```\\n***COMPLEXITY ANALYSIS***\\n- Time to build segment tree: `O(N)` for `4*N` nodes.\\n- Time to query segment tree: `O(logN)`, since that gives the height.\\n- Space to build the segment tree: `O(N)` for `4*N` nodes.\\n- Space to query segment tree: `O(1)`. No additional space required.\\n\\nReference: https://cp-algorithms.com/data_structures/segment_tree.html\\n\\n**Upvote if you find this helpful!**",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass NumArray:\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.n = len(self.nums)\\n        self.tree = [0]*4*self.n  # why 4? check the reference!\\n        self.build(1, 0, self.n-1)\\n\\t\\n    # builds the segment tree, x is curr index, l is left and r is right\\n    def build(self, x, l, r):\\n        if l == r: \\n            self.tree[x] = self.nums[l]\\n        else:\\n            m = (l+r)//2\\n            self.build(2*x, l, m)\\n            self.build(2*x+1, m+1, r)\\n            self.tree[x] = self.tree[x*2]+self.tree[x*2+1]\\n\\n    # tl and tr are target left and target right\\n\\tdef _sum(self, x, l, r, tl, tr):\\n        if tl > tr:\\n            return 0\\n        if l == tl and r == tr:\\n            return self.tree[x]\\n        m = (l+r)//2\\n        return self._sum(x*2, l, m, tl, min(m, tr)) + self._sum(x*2+1, m+1, r, max(m+1, tl), tr)\\n\\n        \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self._sum(1, 0, self.n-1, left, right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406673,
                "title": "python3",
                "content": "```\\ndef __init__(self, nums: List[int]):\\n        self.nums=nums\\n        self.pre=list(accumulate(nums))  #creates prefix array\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left ==0:\\n            return self.pre[right]\\n        return self.pre[right] - self.pre[left-1]",
                "solutionTags": [],
                "code": "```\\ndef __init__(self, nums: List[int]):\\n        self.nums=nums\\n        self.pre=list(accumulate(nums))  #creates prefix array\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left ==0:\\n            return self.pre[right]\\n        return self.pre[right] - self.pre[left-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1406493,
                "title": "easy-prefix-sum-ac-solution",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int>v;\\n    NumArray(vector<int>& nums) {\\n     int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            v.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return v[j]-(i==0? 0 : v[i-1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int>v;\\n    NumArray(vector<int>& nums) {\\n     int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            v.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return v[j]-(i==0? 0 : v[i-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362066,
                "title": "python-prefix-sum-solution",
                "content": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] + list(accumulate(nums))\\n        \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] + list(accumulate(nums))\\n        \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281986,
                "title": "java-running-sum-solution-beats-100-in-time",
                "content": "```\\nclass NumArray {\\n\\n    int[] sum;\\n    public NumArray(int[] nums) {\\n        this.sum = new int[nums.length];\\n        sum[0] = nums[0];\\n        for(int i = 1;i<nums.length;i++)\\n            sum[i] = sum[i-1] + nums[i];\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        \\n        int leftVal = 0;\\n        if(left - 1 >=0 )\\n            leftVal = sum[left - 1];\\n        return sum[right] - leftVal;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n\\n    int[] sum;\\n    public NumArray(int[] nums) {\\n        this.sum = new int[nums.length];\\n        sum[0] = nums[0];\\n        for(int i = 1;i<nums.length;i++)\\n            sum[i] = sum[i-1] + nums[i];\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        \\n        int leftVal = 0;\\n        if(left - 1 >=0 )\\n            leftVal = sum[left - 1];\\n        return sum[right] - leftVal;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245308,
                "title": "prefix-sum-js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar NumArray = function (nums) {\\n  this.prefixSumArr = new Array(nums.length);\\n  let prefixSum = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    prefixSum += nums[i];\\n    this.prefixSumArr[i] = prefixSum;\\n  }\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function (left, right) {\\n  if (left < 0 || right > this.prefixSumArr.length - 1) {\\n    return null;\\n  }\\n  return left > 0\\n    ? this.prefixSumArr[right] - this.prefixSumArr[left - 1]\\n    : this.prefixSumArr[right];\\n    // T.C: O(1)\\n    // S.C: O(1)\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(left,right)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar NumArray = function (nums) {\\n  this.prefixSumArr = new Array(nums.length);\\n  let prefixSum = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    prefixSum += nums[i];\\n    this.prefixSumArr[i] = prefixSum;\\n  }\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function (left, right) {\\n  if (left < 0 || right > this.prefixSumArr.length - 1) {\\n    return null;\\n  }\\n  return left > 0\\n    ? this.prefixSumArr[right] - this.prefixSumArr[left - 1]\\n    : this.prefixSumArr[right];\\n    // T.C: O(1)\\n    // S.C: O(1)\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(left,right)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1204526,
                "title": "c-constant-time-result-solution-explained-100-time-80-space",
                "content": "This problem, similarly to its [older brother](https://leetcode.com/problems/range-sum-query-2d-immutable/) (solution [here](https://leetcode.com/problems/range-sum-query-2d-immutable/discuss/1204583/)), can be tempting for a brute force approach, but if we know how many queries we are going to get, we might realise it is not the best approach.\\n\\nWe could instead store in memory when we initialise not a trivial copy of the input vector/array, as naively thought before, but one with already partially made work: each cell would be equal to the sum of all the elements up to there (current one included) from the original vector/array.\\n\\nTo do so, we will declare just one class variable, `store`, as a reference to our new array that we will create in the constructor and populate as mentioned above.\\n\\nNow, given for example an initial input of `{3,4,0,1,2}`, `store` will contain `{3,7,7,8,10}`.\\n\\nWhy do we want to do this?\\n\\nBecause summing all the numbers in a range is relative expensive (linear time) and want to do it as little as possible.\\n\\nTo obtain sums from `left` to `right` (included), we might then just retrieve the sum of all the elements up to `right` and then remove the sum  of all the elements up to `left` (excluded), provided `left` is not `0`.\\n\\nIn our example before, given `left == 2` and. `right == 4`, we will just have to return `10` (sum of all the elements up to index `4`, included) minus `7` (sum of all the elements up to index. `2`, excluded).\\n\\nAnd that is precisely what we do in our `sumRange` method, with surprisingly good performance :)\\n\\nThe code:\\n\\n```cpp\\nclass NumArray {\\n    int *store;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        store = new int[nums.size()];\\n        for (int i = 0, lmt = nums.size(), tmp = 0; i < lmt; i++) store[i] = tmp += nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return store[right] - (left ? store[left - 1] : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```cpp\\nclass NumArray {\\n    int *store;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        store = new int[nums.size()];\\n        for (int i = 0, lmt = nums.size(), tmp = 0; i < lmt; i++) store[i] = tmp += nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return store[right] - (left ? store[left - 1] : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135014,
                "title": "c",
                "content": "```\\npublic class NumArray {\\n\\n    private int[] Numbers {get; set;}\\n    \\n    public NumArray(int[] nums) {\\n        Numbers = nums;\\n    }\\n    \\n    public int SumRange(int left, int right) {\\n        \\n        if (left < 0)\\n        {\\n            return 0;\\n        }\\n        \\n        if (right > Numbers.Length)\\n        {\\n            return 0;\\n        }\\n        \\n        int result = 0;\\n        for(int i = left; i <= right ; i++)\\n        {\\n            result += Numbers[i];\\n        }\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.SumRange(left,right);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\npublic class NumArray {\\n\\n    private int[] Numbers {get; set;}\\n    \\n    public NumArray(int[] nums) {\\n        Numbers = nums;\\n    }\\n    \\n    public int SumRange(int left, int right) {\\n        \\n        if (left < 0)\\n        {\\n            return 0;\\n        }\\n        \\n        if (right > Numbers.Length)\\n        {\\n            return 0;\\n        }\\n        \\n        int result = 0;\\n        for(int i = left; i <= right ; i++)\\n        {\\n            result += Numbers[i];\\n        }\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.SumRange(left,right);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1107723,
                "title": "c-explained-prefix-sum-approach",
                "content": "Code has been commented below:\\n```\\nclass NumArray {\\n    vector<int> sum; // vector to store the sum of elements upto particular index\\npublic:\\n    NumArray(vector<int>& nums) {\\n// we loop the nums vector store the sum of elements upto that particular index\\n    for(int i=0;i<nums.size();i++){\\n        if(i==0)sum.push_back(nums[0]); // if first element jsut store the element\\n        else \\n            sum.push_back(nums[i]+sum[i-1]);// else we store the sum upto current index starting drom index 0\\n    }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if(i==0)return sum[j];//if i==0 then we return the sum of elements upto index j\\n        else   //else to get the sum in b/w index i & j we subtract the sum upto index i-1 from sum upto index j\\n            return sum[j]-sum[i-1];\\n    }\\n};\\n ```\\n Do upvote if explanaton was useful :)",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    vector<int> sum; // vector to store the sum of elements upto particular index\\npublic:\\n    NumArray(vector<int>& nums) {\\n// we loop the nums vector store the sum of elements upto that particular index\\n    for(int i=0;i<nums.size();i++){\\n        if(i==0)sum.push_back(nums[0]); // if first element jsut store the element\\n        else \\n            sum.push_back(nums[i]+sum[i-1]);// else we store the sum upto current index starting drom index 0\\n    }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if(i==0)return sum[j];//if i==0 then we return the sum of elements upto index j\\n        else   //else to get the sum in b/w index i & j we subtract the sum upto index i-1 from sum upto index j\\n            return sum[j]-sum[i-1];\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1090411,
                "title": "c-16ms-99-timeo1-spaceo1-in-place",
                "content": "Runtime: 16 ms, faster than 97.54% of C++ online submissions for Range Sum Query - Immutable.\\nMemory Usage: 16.9 MB, less than 94.51% of C++ online submissions for Range Sum Query - Immutable.\\n```\\nclass NumArray {\\npublic:\\n  vector<int> *p;                                 //pointer to vector <int>\\n  NumArray(vector<int> &nums) {\\n    for(int i = 1; i < nums.size(); i++) nums[i] += nums[i-1];      //transform vector as vector of previous sum\\n    p = &nums;                                    //retain pointer to vector nums\\n  }\\n    \\n  int sumRange(int i, int j) {                    //fetch sum in range\\n    return (*p)[j] - (i ? (*p)[i-1] : 0);\\n  }\\n};\\n```\\n\\n**more readable code**\\nRuntime: 16 ms, faster than 98.68% of C++ online submissions for Range Sum Query - Immutable.\\nMemory Usage: 17 MB, less than 85.00% of C++ online submissions for Range Sum Query - Immutable.\\n```\\nclass NumArray {\\npublic:\\n  vector<int> *p;                                 //pointer to vector <int>\\n  NumArray(vector<int>& nums) {\\n    for(int i = 1; i < nums.size(); i++) nums[i] += nums[i-1];      //transform vector as vector of previous sum\\n    p = &nums;                                    //retain pointer to vector nums\\n  }\\n    \\n  int sumRange(int i, int j) {                    //fetch sum in range\\n    if(i == 0) return p->operator[](j);\\n    else return p->operator[](j) - p->operator[](i-1);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n  vector<int> *p;                                 //pointer to vector <int>\\n  NumArray(vector<int> &nums) {\\n    for(int i = 1; i < nums.size(); i++) nums[i] += nums[i-1];      //transform vector as vector of previous sum\\n    p = &nums;                                    //retain pointer to vector nums\\n  }\\n    \\n  int sumRange(int i, int j) {                    //fetch sum in range\\n    return (*p)[j] - (i ? (*p)[i-1] : 0);\\n  }\\n};\\n```\n```\\nclass NumArray {\\npublic:\\n  vector<int> *p;                                 //pointer to vector <int>\\n  NumArray(vector<int>& nums) {\\n    for(int i = 1; i < nums.size(); i++) nums[i] += nums[i-1];      //transform vector as vector of previous sum\\n    p = &nums;                                    //retain pointer to vector nums\\n  }\\n    \\n  int sumRange(int i, int j) {                    //fetch sum in range\\n    if(i == 0) return p->operator[](j);\\n    else return p->operator[](j) - p->operator[](i-1);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086197,
                "title": "python",
                "content": "```\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n        self.prefix = [0]\\n        for i in self.nums:\\n            self.prefix.append(self.prefix[-1] + i)\\n            \\n        \\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.prefix[j+1] - self.prefix[i]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(i,j)",
                "solutionTags": [],
                "code": "```\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n        self.prefix = [0]\\n        for i in self.nums:\\n            self.prefix.append(self.prefix[-1] + i)\\n            \\n        \\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.prefix[j+1] - self.prefix[i]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(i,j)",
                "codeTag": "Java"
            },
            {
                "id": 837788,
                "title": "very-simple-c-solution",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int> sum;\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sum.resize(n);\\n        sum = nums;\\n        for(int i = 1; i<n; i++)\\n            sum[i] += sum[i-1];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return left == 0 ? sum[right] : sum[right]-sum[left-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> sum;\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sum.resize(n);\\n        sum = nums;\\n        for(int i = 1; i<n; i++)\\n            sum[i] += sum[i-1];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return left == 0 ? sum[right] : sum[right]-sum[left-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776556,
                "title": "python3-prefix-sum",
                "content": "without leading 0 \\n\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i-1]\\n        self.prefix = nums\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        ans = self.prefix[j]\\n        if i: ans -= self.prefix[i-1]\\n        return ans \\n```\\n\\nwith leading 0 which indeed simplifies the query. \\n\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix = [0]\\n        for x in nums: self.prefix.append(self.prefix[-1] + x)\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        return self.prefix[j+1] - self.prefix[i]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i-1]\\n        self.prefix = nums\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        ans = self.prefix[j]\\n        if i: ans -= self.prefix[i-1]\\n        return ans \\n```\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix = [0]\\n        for x in nums: self.prefix.append(self.prefix[-1] + x)\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        return self.prefix[j+1] - self.prefix[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696140,
                "title": "100-faster-in-java",
                "content": "```\\nclass NumArray {\\n  \\n    public int[] numss;\\n    public NumArray(int[] nums) {\\n      numss = new int[nums.length];\\n      int sum = 0; int i = 0;\\n      for (int n: nums) {\\n        sum += nums[i]; numss[i] = sum;\\n        i++;\\n      }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        if (i == 0) { return numss[j]; } else { return numss[j]-numss[i-1]; }\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n  \\n    public int[] numss;\\n    public NumArray(int[] nums) {\\n      numss = new int[nums.length];\\n      int sum = 0; int i = 0;\\n      for (int n: nums) {\\n        sum += nums[i]; numss[i] = sum;\\n        i++;\\n      }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        if (i == 0) { return numss[j]; } else { return numss[j]-numss[i-1]; }\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 662198,
                "title": "small-python3-solution-o-n-time-for-init-o-1-for-query",
                "content": "Also, since I don\\'t want to modify the original array, the space complexity for `__init__` is also O(n).\\n\\n```\\nclass NumArray:\\n    def __init__(self, nums: List[int]):\\n        self.cumulative = [0]\\n        for num in nums:\\n            self.cumulative.append(\\n                self.cumulative[-1]+num)\\n\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        return self.cumulative[j+1] - self.cumulative[i]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass NumArray:\\n    def __init__(self, nums: List[int]):\\n        self.cumulative = [0]\\n        for num in nums:\\n            self.cumulative.append(\\n                self.cumulative[-1]+num)\\n\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        return self.cumulative[j+1] - self.cumulative[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396097,
                "title": "easy-c-solution-20ms-beats-99",
                "content": "Runtime: 20 ms, faster than 99.94% of C++ online submissions for Range Sum Query - Immutable.\\nMemory Usage: 17.1 MB, less than 100.00% of C++ online submissions for Range Sum Query - Immutable.\\n\\n```\\nclass NumArray {\\n    vector<int> sum;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        sum.resize(nums.size()+1);\\n        for(int i=1; i<=nums.size(); i++)\\n            sum[i] = sum[i-1] + nums[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        \\n        return (sum[j+1] - sum[i]);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(i,j);\\n */",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Runtime: 20 ms, faster than 99.94% of C++ online submissions for Range Sum Query - Immutable.\\nMemory Usage: 17.1 MB, less than 100.00% of C++ online submissions for Range Sum Query - Immutable.\\n\\n```\\nclass NumArray {\\n    vector<int> sum;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        sum.resize(nums.size()+1);\\n        for(int i=1; i<=nums.size(); i++)\\n            sum[i] = sum[i-1] + nums[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        \\n        return (sum[j+1] - sum[i]);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(i,j);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 211387,
                "title": "python-3-60-ms",
                "content": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums=nums;\\n        for i in range(1,len(nums)):\\n            nums[i]=nums[i]+nums[i-1];\\n        \\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        num=self.nums;\\n        if(i==0):\\n            return num[j];\\n        return num[j]-num[i-1]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(i,j)\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums=nums;\\n        for i in range(1,len(nums)):\\n            nums[i]=nums[i]+nums[i-1];\\n        \\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        num=self.nums;\\n        if(i==0):\\n            return num[j];\\n        return num[j]-num[i-1]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(i,j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136385,
                "title": "python-o-n-time-o-n-space-solution-beats-97",
                "content": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.val = {-1:0}\\n        for i in range(len(nums)):\\n            self.val[i] = self.val[i-1] + nums[i]\\n        \\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.val[j] - self.val[i-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.val = {-1:0}\\n        for i in range(len(nums)):\\n            self.val[i] = self.val[i-1] + nums[i]\\n        \\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.val[j] - self.val[i-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75186,
                "title": "easy-to-understand-java-solution-o-n-process-time-o-1-query-time",
                "content": "```\\nclass NumArray {\\n    \\n    int[] arr;\\n    \\n    public NumArray(int[] nums) {\\n        arr = new int[nums.length];\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            arr[i]= sum;    \\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        \\n        if(i==0)\\n            return arr[j];\\n        \\n        return arr[j]-arr[i-1];\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    \\n    int[] arr;\\n    \\n    public NumArray(int[] nums) {\\n        arr = new int[nums.length];\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            arr[i]= sum;    \\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        \\n        if(i==0)\\n            return arr[j];\\n        \\n        return arr[j]-arr[i-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75259,
                "title": "cpp-solution-which-beats-100-submissions-easy-to-understand",
                "content": "    class NumArray {\\n    public:\\n        vector<int> nums_;\\n        NumArray(vector<int> &nums) {\\n            nums_.push_back(0);\\n            for (int i = 0; i < nums.size(); i++)\\n                nums_.push_back(nums_.back() + nums[i]);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return nums_[j + 1] - nums_[i];\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class NumArray {\\n    public:\\n        vector<int> nums_;\\n        NumArray(vector<int> &nums) {\\n            nums_.push_back(0);\\n            for (int i = 0; i < nums.size(); i++)\\n                nums_.push_back(nums_.back() + nums[i]);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return nums_[j + 1] - nums_[i];\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 75269,
                "title": "simple-and-easy-solution",
                "content": "class NumArray {\\n\\n    vector<int> mat;\\npublic:\\n\\n    NumArray(vector<int> &nums) {\\n        int size=nums.size(),i;\\n        mat.resize(size+1);\\n        mat[0]=0;\\n        for(i=1;i<=size;i++){\\n            mat[i]=mat[i-1]+nums[i-1];\\n        }\\n    }\\n\\n    int sumRange(int i, int j) {\\n        return mat[j+1] - mat[i];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class NumArray {\\n\\n    vector<int> mat;\\npublic:\\n\\n    NumArray(vector<int> &nums) {\\n        int size=nums.size(),i;\\n        mat.resize(size+1);\\n        mat[0]=0;\\n        for(i=1;i<=size;i++){\\n            mat[i]=mat[i-1]+nums[i-1];\\n        }\\n    }\\n\\n    int sumRange(int i, int j) {\\n        return mat[j+1] - mat[i];\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 75282,
                "title": "easy-to-understand-python-solution-o-n-runtime-o-n-space",
                "content": "    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n        self.sumList = []\\n        sum = 0\\n        for index in range(len(nums)):\\n            sum += nums[index]\\n            (self.sumList).append(sum)\\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.sumList[j] - self.sumList[i] + self.nums[i]",
                "solutionTags": [],
                "code": "    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n        self.sumList = []\\n        sum = 0\\n        for index in range(len(nums)):\\n            sum += nums[index]\\n            (self.sumList).append(sum)\\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.sumList[j] - self.sumList[i] + self.nums[i]",
                "codeTag": "Python3"
            },
            {
                "id": 75283,
                "title": "why-is-this-solution-exceeding-the-time-limit",
                "content": "\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums=nums\\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return sum(self.nums[i:j+1])",
                "solutionTags": [],
                "code": "\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums=nums\\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return sum(self.nums[i:j+1])",
                "codeTag": "Java"
            },
            {
                "id": 75290,
                "title": "sharing-my-585ms-c-solution",
                "content": "    class NumArray {\\n    private:\\n        vector<int> sums;\\n    public:\\n        NumArray(vector<int> &nums) {\\n            int n = nums.size();\\n            sums.resize(n, 0);\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                sums[i] = sum + nums[i];\\n                sum = sums[i];\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            if(i==0)\\n                return sums[j];\\n            else\\n                return (sums[j] - sums[i-1]);\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class NumArray {\\n    private:\\n        vector<int> sums;\\n    public:\\n        NumArray(vector<int> &nums) {\\n            int n = nums.size();\\n            sums.resize(n, 0);\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                sums[i] = sum + nums[i];\\n                sum = sums[i];\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            if(i==0)\\n                return sums[j];\\n            else\\n                return (sums[j] - sums[i-1]);\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "codeTag": "Java"
            },
            {
                "id": 4063582,
                "title": "python3-single-line-code",
                "content": "\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837269,
                "title": "o-1-space-complexity-answer-using-initializer-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the numbers of queries are large. It will be very inefficient to iterate over the array and calculate the sum for each query separately. We have to devise the solution so that we can get the answer of the query in constant time. We will be storing the sum upto a particular index in prefix sum Array. We will be using the prefix sum array to calculate the sum for the given range.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the reference of the vector is already given in the NumaArray constructor so we will take advantage of it, we will not create a copy instead we will create a vector<int> reference and we will initialize that reference with the argument reference of Numarray so it will be O(1) space complexity and we can initialize the vector<int> reference in initializer list which I have done like this in my code \" NumArray(vector<int>& nums) : prefixSum(nums) \" you can learn more about initializer list if you are getting confused just go and learn about it for once from GFG article it will help you alot in future\\n\\n\\nprefixSum[] = Array stores the sum (A[0]+A[1]+....A[i]) at index i.\\n example prefixSum[i]=prefixSum[i-1]+prefixSum[i-2]+.......prefixSum[0];\\n    or\\n prefixSum[0]=prefixSum[0];\\n prefixSum[1]=prefixSum[1]+prefixSum[0];\\n prefixSum[2]=prefixSum[2]+prefixSum[1];\\n\\n\\n \\n if l == 0 :\\n    sum(l,r) = prefixSum[r]\\n else :\\n    sum(l,r) = prefixSum[r] - prefixSum[l-1]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass NumArray {\\npublic:\\n    vector<int>&prefixSum;\\n    NumArray(vector<int>& nums) : prefixSum(nums){\\n        for(int i=1;i<prefixSum.size();i++)\\n        {\\n          prefixSum[i]+=prefixSum[i-1];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n        {\\n          return prefixSum[right];\\n        }\\n        return prefixSum[right]-prefixSum[left-1];\\n    }\\n};\\n<!-- kindly upvote if you liked my solution -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the numbers of queries are large. It will be very inefficient to iterate over the array and calculate the sum for each query separately. We have to devise the solution so that we can get the answer of the query in constant time. We will be storing the sum upto a particular index in prefix sum Array. We will be using the prefix sum array to calculate the sum for the given range.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the reference of the vector is already given in the NumaArray constructor so we will take advantage of it, we will not create a copy instead we will create a vector<int> reference and we will initialize that reference with the argument reference of Numarray so it will be O(1) space complexity and we can initialize the vector<int> reference in initializer list which I have done like this in my code \" NumArray(vector<int>& nums) : prefixSum(nums) \" you can learn more about initializer list if you are getting confused just go and learn about it for once from GFG article it will help you alot in future\\n\\n\\nprefixSum[] = Array stores the sum (A[0]+A[1]+....A[i]) at index i.\\n example prefixSum[i]=prefixSum[i-1]+prefixSum[i-2]+.......prefixSum[0];\\n    or\\n prefixSum[0]=prefixSum[0];\\n prefixSum[1]=prefixSum[1]+prefixSum[0];\\n prefixSum[2]=prefixSum[2]+prefixSum[1];\\n\\n\\n \\n if l == 0 :\\n    sum(l,r) = prefixSum[r]\\n else :\\n    sum(l,r) = prefixSum[r] - prefixSum[l-1]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass NumArray {\\npublic:\\n    vector<int>&prefixSum;\\n    NumArray(vector<int>& nums) : prefixSum(nums){\\n        for(int i=1;i<prefixSum.size();i++)\\n        {\\n          prefixSum[i]+=prefixSum[i-1];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n        {\\n          return prefixSum[right];\\n        }\\n        return prefixSum[right]-prefixSum[left-1];\\n    }\\n};\\n<!-- kindly upvote if you liked my solution -->",
                "codeTag": "Java"
            },
            {
                "id": 3363767,
                "title": "c-prefix-sum-solution",
                "content": "# Intuition\\nTo avoid iterate the array every time that the SumRange() method is called we can have the running totals, take the total of the right index and substact the total of the left index\\n\\n# Approach\\nPrefix sum, with an additional index at the left side to have a value of zero and avoid checking for index 0.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ constructor, and $$O(1)$$ the SumRange() method\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class NumArray {\\n\\n    private int[] _nums;\\n\\n    public NumArray(int[] nums) {\\n        var n = nums.Length;\\n        _nums = new int[n+1];\\n        for (int i = 0; i < n; i++) _nums[i+1] = _nums[i] + nums[i];\\n    }\\n    \\n    public int SumRange(int left, int right) {\\n        return _nums[right+1] - _nums[left];\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/0d0898ec-1f4b-4f4d-8e7c-d74de6d20dfd_1680305281.5864549.png)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class NumArray {\\n\\n    private int[] _nums;\\n\\n    public NumArray(int[] nums) {\\n        var n = nums.Length;\\n        _nums = new int[n+1];\\n        for (int i = 0; i < n; i++) _nums[i+1] = _nums[i] + nums[i];\\n    }\\n    \\n    public int SumRange(int left, int right) {\\n        return _nums[right+1] - _nums[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233210,
                "title": "rust-0ms-o-1-query-o-n-space",
                "content": "I chain a 1 size array with 0 to the nums iter to create the monotonic array.\\nI use scan to sum it up. This avoids checking if left is OOB when calculating sum.\\n\\n# Code\\n```\\nstruct NumArray {\\n    monotonic_stack: Vec<i32>,\\n}\\n\\nimpl NumArray {\\n\\n    fn new(nums: Vec<i32>) -> Self {\\n        Self {\\n            monotonic_stack: [0].iter().chain(nums.iter())\\n                .scan(0,|state,val|{\\n                    *state += val;\\n                    Some(*state)\\n                }).collect::<Vec<i32>>(),\\n        }\\n    }\\n    \\n    fn sum_range(&self, left: i32, right: i32) -> i32 {\\n        self.monotonic_stack[(right+1) as usize] - self.monotonic_stack[left as usize]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct NumArray {\\n    monotonic_stack: Vec<i32>,\\n}\\n\\nimpl NumArray {\\n\\n    fn new(nums: Vec<i32>) -> Self {\\n        Self {\\n            monotonic_stack: [0].iter().chain(nums.iter())\\n                .scan(0,|state,val|{\\n                    *state += val;\\n                    Some(*state)\\n                }).collect::<Vec<i32>>(),\\n        }\\n    }\\n    \\n    fn sum_range(&self, left: i32, right: i32) -> i32 {\\n        self.monotonic_stack[(right+1) as usize] - self.monotonic_stack[left as usize]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3102283,
                "title": "using-accumulate-range-sum-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=[0]+list(accumulate(nums))\\n        print(self.nums)\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.nums[right+1]-self.nums[left]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=[0]+list(accumulate(nums))\\n        print(self.nums)\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.nums[right+1]-self.nums[left]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022478,
                "title": "simple-clear-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray {\\n  List<int> arr = [];\\n\\n  NumArray(List<int> nums) {\\n    arr = nums;\\n  }\\n\\n  int sumRange(int left, int right) {\\n    int sum = 0;\\n    for (int i = left; i <= right; i++) sum += arr[i];\\n    return sum;\\n  }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = NumArray(nums);\\n * int param1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass NumArray {\\n  List<int> arr = [];\\n\\n  NumArray(List<int> nums) {\\n    arr = nums;\\n  }\\n\\n  int sumRange(int left, int right) {\\n    int sum = 0;\\n    for (int i = left; i <= right; i++) sum += arr[i];\\n    return sum;\\n  }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = NumArray(nums);\\n * int param1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014293,
                "title": "swift-solution-beats-99",
                "content": "# Dummy solution\\n```\\nclass NumArray {\\n    private let nums: [Int]\\n\\n    init(_ nums: [Int]) {\\n        self.nums = nums\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        return nums[left...right].reduce(0, +)\\n    }\\n}\\n```\\n## Complexity\\n- Time complexity: $$O(n)$$ - each run we need to count sum for given range without any caching\\n\\n- Space complexity: $$O(1)$$ - because Swift stores a reference to given array instead of its copy.\\n\\n\\n# Optimized solution\\n```\\nclass NumArray {\\n    private let sumArray: [Int]\\n\\n    init(_ nums: [Int]) {\\n        var sum: Int = 0\\n        self.sumArray = nums.map { num in\\n            sum += num;\\n            return sum\\n        }\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        if left == 0 { \\n            return sumArray[right] \\n        } else {\\n            return sumArray[right] - sumArray[left - 1]\\n        }\\n    }\\n}\\n```\\n## Complexity\\n- Time complexity: $$O(1)$$ - need to access dictionary\\'s value.\\n\\n- Space complexity: $$O(n)$$ - creating new array of the same size as the given one.\\n### Please upwote if you like the solution)",
                "solutionTags": [
                    "Swift",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    private let nums: [Int]\\n\\n    init(_ nums: [Int]) {\\n        self.nums = nums\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        return nums[left...right].reduce(0, +)\\n    }\\n}\\n```\n```\\nclass NumArray {\\n    private let sumArray: [Int]\\n\\n    init(_ nums: [Int]) {\\n        var sum: Int = 0\\n        self.sumArray = nums.map { num in\\n            sum += num;\\n            return sum\\n        }\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        if left == 0 { \\n            return sumArray[right] \\n        } else {\\n            return sumArray[right] - sumArray[left - 1]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634640,
                "title": "easy-understanding-python-solution",
                "content": "class NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=nums\\n        self.pre=nums\\n        for i in range(len(self.pre)-1):\\n            self.pre[i+1]+=self.pre[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        self.left=left\\n        self.right=right\\n        if self.left:\\n            return self.pre[right]-self.pre[left-1]\\n        else:\\n            return self.pre[right]",
                "solutionTags": [],
                "code": "class NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=nums\\n        self.pre=nums\\n        for i in range(len(self.pre)-1):\\n            self.pre[i+1]+=self.pre[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        self.left=left\\n        self.right=right\\n        if self.left:\\n            return self.pre[right]-self.pre[left-1]\\n        else:\\n            return self.pre[right]",
                "codeTag": "Java"
            },
            {
                "id": 2585302,
                "title": "c-solution-98-83-time-72-52-space-o-n-time-space",
                "content": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        int i, sum{}, size = nums.size();\\n        for (i = 0; i < size; ++i) {\\n            sum+=nums[i];\\n            _acum.emplace_back(sum);\\n        }\\n        return;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left > 0) {\\n            return _acum[right]-_acum[left-1];\\n        } else {\\n            return _acum[right];\\n        }\\n    }\\nprivate:\\n    vector<int> _acum;\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        int i, sum{}, size = nums.size();\\n        for (i = 0; i < size; ++i) {\\n            sum+=nums[i];\\n            _acum.emplace_back(sum);\\n        }\\n        return;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left > 0) {\\n            return _acum[right]-_acum[left-1];\\n        } else {\\n            return _acum[right];\\n        }\\n    }\\nprivate:\\n    vector<int> _acum;\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567951,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569065,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572637,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569188,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2009514,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572524,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571554,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2061827,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1776188,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759585,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1567951,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569065,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572637,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569188,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2009514,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572524,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571554,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2061827,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1776188,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759585,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    }
]