[
    {
        "title": "Same Tree",
        "question_content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n&nbsp;\nExample 1:\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\nExample 2:\nInput: p = [1,2], q = [1,null,2]\nOutput: false\nExample 3:\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n&nbsp;\nConstraints:\n\tThe number of nodes in both trees is in the range [0, 100].\n\t-104 <= Node.val <= 104",
        "solutions": [
            {
                "id": 32729,
                "title": "shortest-simplest-python",
                "content": "The \"proper\" way:\\n\\n    def isSameTree(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n\\nThe \"tupleify\" way:\\n\\n    def isSameTree(self, p, q):\\n        def t(n):\\n            return n and (n.val, t(n.left), t(n.right))\\n        return t(p) == t(q)\\n\\nThe first way as one-liner:\\n\\n    def isSameTree(self, p, q):\\n        return p and q and p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) or p is q",
                "solutionTags": [
                    "Python"
                ],
                "code": "The \"proper\" way:\\n\\n    def isSameTree(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n\\nThe \"tupleify\" way:\\n\\n    def isSameTree(self, p, q):\\n        def t(n):\\n            return n and (n.val, t(n.left), t(n.right))\\n        return t(p) == t(q)\\n\\nThe first way as one-liner:\\n\\n    def isSameTree(self, p, q):\\n        return p and q and p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) or p is q",
                "codeTag": "Python3"
            },
            {
                "id": 32687,
                "title": "five-line-java-solution-with-recursion",
                "content": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 32685,
                "title": "here-s-a-c-recursion-solution-in-minimal-lines-of-code",
                "content": "    //\\n    // Algorithm for the recursion:\\n    // 1)\\n    // If one of the node is NULL then return the equality result of p an q.\\n    // This boils down to if both are NULL then return true, \\n    // but if one of them is NULL but not the other one then return false\\n    // 2)\\n    // At this point both root nodes represent valid pointers.\\n    // Return true if the root nodes have same value and \\n    // the left tree of the roots are same (recursion)\\n    // and the right tree of the roots are same (recursion). \\n    // Otherwise return false. \\n    //\\n    \\n    bool isSameTree(TreeNode *p, TreeNode *q) {\\n        if (p == NULL || q == NULL) return (p == q);\\n        return (p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\\n    }",
                "solutionTags": [],
                "code": "    //\\n    // Algorithm for the recursion:\\n    // 1)\\n    // If one of the node is NULL then return the equality result of p an q.\\n    // This boils down to if both are NULL then return true, \\n    // but if one of them is NULL but not the other one then return false\\n    // 2)\\n    // At this point both root nodes represent valid pointers.\\n    // Return true if the root nodes have same value and \\n    // the left tree of the roots are same (recursion)\\n    // and the right tree of the roots are same (recursion). \\n    // Otherwise return false. \\n    //\\n    \\n    bool isSameTree(TreeNode *p, TreeNode *q) {\\n        if (p == NULL || q == NULL) return (p == q);\\n        return (p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3746149,
                "title": "recursive-approach-with-easy-steps",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe intuition behind the solution is to recursively check if two binary trees are identical. If both trees are empty (null), they are considered identical. If only one tree is empty or the values of the current nodes are different, the trees are not identical. Otherwise, we recursively check if the left and right subtrees of both trees are identical.\\n\\n# Approach\\n1. Check the base case: if both trees are null, return true.\\n1. Check if only one tree is null or the values of the current nodes are different, return false.\\n1. Recursively check if the left subtrees of both trees are identical.\\n1. Recursively check if the right subtrees of both trees are identical.\\n1. Return the logical AND of the results from steps 3 and 4.\\n\\n Complexity\\n- Time complexity:\\nThe time complexity of the solution is $$O(min(N, M))$$, where N and M are the number of nodes in the two trees, respectively. This is because we need to visit each node once in order to compare their values. In the worst case, where both trees have the same number of nodes, the time complexity would be O(N).\\n\\n- Space complexity:\\nThe space complexity of the solution is$$O(min(H1, H2))$$, where H1 and H2 are the heights of the two trees, respectively. This is because the space used by the recursive stack is determined by the height of the smaller tree. In the worst case, where one tree is significantly larger than the other, the space complexity would be closer to O(N) or O(M), depending on which tree is larger.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // Base case: if both trees are null, they are identical\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If only one tree is null or the values are different, they are not identical\\n        if (p == null || q == null || p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check if the left and right subtrees are identical\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        # If both nodes are None, they are identical\\n        if p is None and q is None:\\n            return True\\n        # If only one of the nodes is None, they are not identical\\n        if p is None or q is None:\\n            return False\\n        # Check if values are equal and recursively check left and right subtrees\\n        if p.val == q.val:\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # Values are not equal, they are not identical\\n        return False\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both nodes are NULL, they are identical\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        // If only one of the nodes is NULL, they are not identical\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        // Check if values are equal and recursively check left and right subtrees\\n        if (p->val == q->val) {\\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        }\\n        // Values are not equal, they are not identical\\n        return false;\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/779ca60d-af64-404b-8240-038c7cee76af_1689003011.760921.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // Base case: if both trees are null, they are identical\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If only one tree is null or the values are different, they are not identical\\n        if (p == null || q == null || p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check if the left and right subtrees are identical\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        # If both nodes are None, they are identical\\n        if p is None and q is None:\\n            return True\\n        # If only one of the nodes is None, they are not identical\\n        if p is None or q is None:\\n            return False\\n        # Check if values are equal and recursively check left and right subtrees\\n        if p.val == q.val:\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # Values are not equal, they are not identical\\n        return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both nodes are NULL, they are identical\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        // If only one of the nodes is NULL, they are not identical\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        // Check if values are equal and recursively check left and right subtrees\\n        if (p->val == q->val) {\\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        }\\n        // Values are not equal, they are not identical\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32894,
                "title": "python-recursive-solution-and-dfs-iterative-solution-with-stack-and-bfs-iterative-solution-with-queue",
                "content": "    def isSameTree1(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return p == q\\n    \\n    # DFS with stack        \\n    def isSameTree2(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            node1, node2 = stack.pop()\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                stack.append((node1.right, node2.right))\\n                stack.append((node1.left, node2.left))\\n        return True\\n     \\n    # BFS with queue    \\n    def isSameTree3(self, p, q):\\n        queue = [(p, q)]\\n        while queue:\\n            node1, node2 = queue.pop(0)\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                queue.append((node1.left, node2.left))\\n                queue.append((node1.right, node2.right))\\n        return True",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    def isSameTree1(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return p == q\\n    \\n    # DFS with stack        \\n    def isSameTree2(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            node1, node2 = stack.pop()\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                stack.append((node1.right, node2.right))\\n                stack.append((node1.left, node2.left))\\n        return True\\n     \\n    # BFS with queue    \\n    def isSameTree3(self, p, q):\\n        queue = [(p, q)]\\n        while queue:\\n            node1, node2 = queue.pop(0)\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                queue.append((node1.left, node2.left))\\n                queue.append((node1.right, node2.right))\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 32684,
                "title": "my-non-recursive-method",
                "content": "the idea is to use stack for preorder traverse \\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n    \\t     Stack<TreeNode> stack_q = new Stack <> ();\\n    \\t     if (p != null) stack_p.push( p ) ;\\n    \\t     if (q != null) stack_q.push( q ) ;\\n    \\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n    \\t    \\t TreeNode pn = stack_p.pop() ;\\n    \\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n    \\t    \\t if (pn.val != qn.val) return false ;\\n    \\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n    \\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n    \\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t     }\\t\\t     \\n    \\t     return stack_p.size() == stack_q.size() ;\\t \\n    \\t }",
                "solutionTags": [],
                "code": "the idea is to use stack for preorder traverse \\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n    \\t     Stack<TreeNode> stack_q = new Stack <> ();\\n    \\t     if (p != null) stack_p.push( p ) ;\\n    \\t     if (q != null) stack_q.push( q ) ;\\n    \\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n    \\t    \\t TreeNode pn = stack_p.pop() ;\\n    \\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n    \\t    \\t if (pn.val != qn.val) return false ;\\n    \\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n    \\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n    \\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t     }\\t\\t     \\n    \\t     return stack_p.size() == stack_q.size() ;\\t \\n    \\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 826280,
                "title": "recursive-and-iterative-easy-understanding",
                "content": "\\n\\t //iterative\\n\\n      class Solution {\\n      public:\\n          bool isSameTree(TreeNode* p, TreeNode* q) {\\n              queue<TreeNode *> queue;\\n              queue.push(p);\\n              queue.push(q);\\n              while (queue.size()!=0){\\n                  TreeNode * q2=queue.front();\\n                  queue.pop();\\n                  TreeNode * q1=queue.front();\\n                  queue.pop();\\n                  if (q1==nullptr && q2==nullptr) continue;\\n                  if (q1==nullptr || q2==nullptr) return false;\\n                  if (q1->val!=q2->val) return false;\\n                  queue.push(q1->left);\\n                  queue.push(q2->left);\\n                  queue.push(q1->right);\\n                  queue.push(q2->right);\\n              }\\n              return true;\\n          }\\n      };\\n\\t  \\n    //recursive\\n\\n      class Solution {\\n      public:\\n          bool isSameTree(TreeNode* p, TreeNode* q) {\\n              if(p==nullptr && q==nullptr) return true;\\n              if(p==nullptr || q==nullptr) return false;\\n              if(q->val!=p->val) return false;\\n              return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n          }\\n      };\\n\\t  \\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n      public:\\n          bool isSameTree(TreeNode* p, TreeNode* q) {\\n              queue<TreeNode *> queue;\\n              queue.push(p);\\n              queue.push(q);\\n              while (queue.size()!=0){\\n                  TreeNode * q2=queue.front();\\n                  queue.pop();\\n                  TreeNode * q1=queue.front();\\n                  queue.pop();\\n                  if (q1==nullptr && q2==nullptr) continue;\\n                  if (q1==nullptr || q2==nullptr) return false;\\n                  if (q1->val!=q2->val) return false;\\n                  queue.push(q1->left);\\n                  queue.push(q2->left);\\n                  queue.push(q1->right);\\n                  queue.push(q2->right);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3027456,
                "title": "c-recursion-one-line-and-iterative-solution-with-explaination",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n# Intuition\\nWe well use 2 method to solve this problem\\n1. Recursive method\\n2. Iterative method\\n\\n# Approach\\n# method 1. Recursion\\n1. If one of the node is NULL then return the equality result of p an q.\\n     a. This boils down to if both are NULL then return true, \\n     b. if one of them is NULL but not the other one then return false\\n  \\n2.  At this point both root nodes represent valid pointers(after checking the if condition).\\n    - Return true if the root nodes have same value  (p->val==q->val)\\n    - Recursively check right subtrees of both trees p and q\\n    - Recursively check left subtrees of both trees p and q\\n3. If the left or right subtrees are different, return false \\n\\nHere is image for more clearity\\n![leetcode.png](https://assets.leetcode.com/users/images/09b47818-50d3-40e3-8c4b-05ea129abf09_1673315076.6926653.png)\\n\\n\\n# Complexity\\n- Time complexity -->O(N)\\n\\n- Space complexity -->O(H)H=height of binary tree\\n\\n# Method 2. Iterative solution\\n1. Create a stack and push the roots of both trees onto the stack as pairs.\\n2. While the stack is not empty\\n    - Pop a pair of nodes from the stack.\\n    -  If both nodes are null, continue.\\n    -  If one node is null or the values at the nodes are different, return false.\\n    -  Push the left and right children of both nodes onto the stack as pairs.\\n3. If the loop completes, return true.\\n\\n# Complexity\\n- Time complexity -->O(N)\\n\\n- Space complexity -->O(N)\\n\\n\\n# Code(Recursion)\\n```\\n\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p && !q)    return true;\\n        if(!p || !q)    return false;\\n            return (p->val == q->val && isSameTree(p->right, q->right) && isSameTree(p->left, q->left));\\n    }\\n};\\n```\\n# Code(Iterative)\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```\\n# [MY LINKDIN](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)\\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\\n*Let me know in comment if i can do better*.\\nLets connect on # [Linkdin](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p && !q)    return true;\\n        if(!p || !q)    return false;\\n            return (p->val == q->val && isSameTree(p->right, q->right) && isSameTree(p->left, q->left));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32935,
                "title": "javascript-solution",
                "content": "```js\\nfunction isSameTree(p, q) {\\n  if (!p && !q) return true;\\n  if (!p || !q || p.val !== q.val) return false;\\n  \\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction isSameTree(p, q) {\\n  if (!p && !q) return true;\\n  if (!p || !q || p.val !== q.val) return false;\\n  \\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607631,
                "title": "javascript-too-easy",
                "content": "````\\nvar isSameTree = function(p, q) {\\n     return JSON.stringify(p)===JSON.stringify(q)\\n};\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\nvar isSameTree = function(p, q) {\\n     return JSON.stringify(p)===JSON.stringify(q)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027900,
                "title": "java-solution-with-explanation",
                "content": "\\n# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n1. This code is checking if two trees are the same by comparing their structure and node values. The function takes in the root nodes of the two trees, p and q, as arguments.\\n\\n2. The function first checks if both trees are null - if they are, then the function returns true, because two null trees are considered to be the same. If only one of the trees is null (and the other isn\\'t), the function returns false, because a tree with nodes is not the same as a null tree.\\n\\n3. If both trees are non-null, the function compares the values of their root nodes. If the values are not the same, the function returns false, because the trees are not the same. If the values are the same, the function recursively calls itself on the left and right children of the two root nodes. The function returns true if the left and right subtrees of both trees are the same, and false otherwise.\\n\\n4. Overall, the function checks the structure and node values of the two trees in a recursive manner, starting from the root nodes and moving down to the leaf nodes. If the structure and values of both trees are the same at every level, the function returns true, indicating that the trees are the same. If any differences are found, the function returns false, indicating that the trees are not the same.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\n    // If both p and q are null, then they are the same tree\\n    if (p == null && q == null) return true;\\n    \\n    // If only one of p and q is null, then they are not the same tree\\n    if (p == null || q == null) return false;\\n    \\n    // If the values of p and q are different, then they are not the same tree\\n    if (p.val != q.val) return false;\\n    \\n    // Recursively check the left and right subtrees of p and q\\n    // If both the left and right subtrees are the same, then p and q are the same tree\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\n    // If both p and q are null, then they are the same tree\\n    if (p == null && q == null) return true;\\n    \\n    // If only one of p and q is null, then they are not the same tree\\n    if (p == null || q == null) return false;\\n    \\n    // If the values of p and q are different, then they are not the same tree\\n    if (p.val != q.val) return false;\\n    \\n    // Recursively check the left and right subtrees of p and q\\n    // If both the left and right subtrees are the same, then p and q are the same tree\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376495,
                "title": "c-solution-recursive-approach",
                "content": "Time complexity - O(N)\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```\\nPlease Upvote if you like the solution and comment if have doubts",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32733,
                "title": "simple-java-solution-both-recurison-and-iteration",
                "content": "\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // recurision method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        if (p.val != q.val) return false;\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n\\n\\n----------\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // iteration method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        Stack<TreeNode> stackP = new Stack<>();\\n        Stack<TreeNode> stackQ = new Stack<>();\\n        stackP.add(p);\\n        stackQ.add(q);\\n        while (!stackP.isEmpty() && !stackQ.isEmpty()) {\\n            TreeNode tmpP = stackP.pop();\\n            TreeNode tmpQ = stackQ.pop();\\n            if (tmpP.val != tmpQ.val) return false;\\n            if (tmpP.left != null && tmpQ.left != null) {\\n                stackP.push(tmpP.left);\\n                stackQ.push(tmpQ.left);\\n            } else if (tmpP.left == null && tmpQ.left == null) {\\n            } else {\\n                return false;\\n            }\\n            if (tmpP.right != null && tmpQ.right != null) {\\n                stackP.push(tmpP.right);\\n                stackQ.push(tmpQ.right);\\n            } else if (tmpP.right == null && tmpQ.right == null) {\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (!stackP.isEmpty() || !stackQ.isEmpty()) return false;\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // recurision method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        if (p.val != q.val) return false;\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n\\n\\n----------\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // iteration method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        Stack<TreeNode> stackP = new Stack<>();\\n        Stack<TreeNode> stackQ = new Stack<>();\\n        stackP.add(p);\\n        stackQ.add(q);\\n        while (!stackP.isEmpty() && !stackQ.isEmpty()) {\\n            TreeNode tmpP = stackP.pop();\\n            TreeNode tmpQ = stackQ.pop();\\n            if (tmpP.val != tmpQ.val) return false;\\n            if (tmpP.left != null && tmpQ.left != null) {\\n                stackP.push(tmpP.left);\\n                stackQ.push(tmpQ.left);\\n            } else if (tmpP.left == null && tmpQ.left == null) {\\n            } else {\\n                return false;\\n            }\\n            if (tmpP.right != null && tmpQ.right != null) {\\n                stackP.push(tmpP.right);\\n                stackQ.push(tmpQ.right);\\n            } else if (tmpP.right == null && tmpQ.right == null) {\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (!stackP.isEmpty() || !stackQ.isEmpty()) return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3027608,
                "title": "python3-dfs-explained-chatgpt-solutions",
                "content": "\\n**Logic:**\\n(1) If both ```p``` and ```q``` are None, we have reched the end on the branches from both trees, so return True.\\n(2) If both nodes are not None, then their values has to be the same, and if so we keep check their left and right nodes.\\n(3) If both nodes are not None, but their values are different, retun False.\\n(4) If one of the node is None and the other one is not, we return False.\\n\\nAs you can see (3) and (4) are just in the else condition from (2). \\n\\n**DFS (Recursive)**\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\t\\t\\t\\t\\t#(1)\\n            return True\\n        if p and q and p.val == q.val:\\t\\t#(2)\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n        else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n            return False\\n```\\n\\n**DFS (Iterative)** Applying the same logic but using stack.\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [[p,q]]\\n        while stack:\\n            p,q = stack.pop()\\n            if not p and not q:\\t\\t\\t\\t\\t#(1)\\n                continue\\n            elif p and q and p.val == q.val:\\t#(2)\\n                stack.append([p.left, q.left])\\n                stack.append([p.right, q.right])\\n            else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n                return False\\n        return True\\n```\\n\\n**Solution and explination from ChatGPT** (I\\'m sure ChatGPT has seen this question before, and the answer it gives is the same as the offical one)\\n\\nTo check if two binary trees are the same, we can do a pre-order traversal of both trees and compare the nodes at each level. If at any point the nodes are different or one of the trees has no more nodes, we can return false. Otherwise, we can return true.\\n\\nThis function will have a time complexity of O(n) where n is the number of nodes in the tree, since it needs to visit each node exactly once. The space complexity is also O(n) since at worst case the recursive call stack could contain all the nodes in one of the trees.\\n\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: both nodes are null\\n        if not p and not q:\\n            return True\\n        # base case: one node is null\\n        if not p or not q:\\n            return False\\n        # check if the values of the nodes are the same\\n        if p.val != q.val:\\n            return False\\n        # check if the left and right subtrees are the same\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\n\\n**Me: can you do it without recursion?**\\n\\n**ChatGPT:** Yes, it is also possible to implement this function without recursion using an iterative approach. One way to do this is to use a breadth-first search (BFS) to traverse the trees level by level, and compare the nodes at each level.\\n\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: if both trees are None, they are the same\\n        if not p and not q:\\n            return True\\n        # base case: if only one tree is None, they are not the same\\n        if not p or not q:\\n            return False\\n\\n        # create a queue to hold the nodes at each level\\n        queue = [(p, q)]\\n\\n        # do a BFS of the trees\\n        while queue:\\n            # get the next nodes to compare\\n            node1, node2 = queue.pop(0)\\n            # check if the nodes are the same\\n            if node1.val != node2.val:\\n                return False\\n            # add the left and right children of the nodes to the queue if they exist\\n            if node1.left and node2.left:\\n                queue.append((node1.left, node2.left))\\n            elif node1.left or node2.left:\\n                # if only one of the nodes has a left child, the trees are not the same\\n                return False\\n            if node1.right and node2.right:\\n                queue.append((node1.right, node2.right))\\n            elif node1.right or node2.right:\\n                # if only one of the nodes has a right child, the trees are not the same\\n                return False\\n        # if we made it through the loop, the trees are the same\\n        return True\\n```\\n\\nFrom what I tested, ChatGPT can only do easy problem if it has never seen it before, and will fail on the medium ones. Note that since the training data for ChatGPT is the data before 2021, so for these harder questions on LeetCode before 2021, ChatGPT can also do it.\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n\\n",
                "solutionTags": [],
                "code": "```p```\n```q```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\t\\t\\t\\t\\t#(1)\\n            return True\\n        if p and q and p.val == q.val:\\t\\t#(2)\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n        else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n            return False\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [[p,q]]\\n        while stack:\\n            p,q = stack.pop()\\n            if not p and not q:\\t\\t\\t\\t\\t#(1)\\n                continue\\n            elif p and q and p.val == q.val:\\t#(2)\\n                stack.append([p.left, q.left])\\n                stack.append([p.right, q.right])\\n            else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n                return False\\n        return True\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: both nodes are null\\n        if not p and not q:\\n            return True\\n        # base case: one node is null\\n        if not p or not q:\\n            return False\\n        # check if the values of the nodes are the same\\n        if p.val != q.val:\\n            return False\\n        # check if the left and right subtrees are the same\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: if both trees are None, they are the same\\n        if not p and not q:\\n            return True\\n        # base case: if only one tree is None, they are not the same\\n        if not p or not q:\\n            return False\\n\\n        # create a queue to hold the nodes at each level\\n        queue = [(p, q)]\\n\\n        # do a BFS of the trees\\n        while queue:\\n            # get the next nodes to compare\\n            node1, node2 = queue.pop(0)\\n            # check if the nodes are the same\\n            if node1.val != node2.val:\\n                return False\\n            # add the left and right children of the nodes to the queue if they exist\\n            if node1.left and node2.left:\\n                queue.append((node1.left, node2.left))\\n            elif node1.left or node2.left:\\n                # if only one of the nodes has a left child, the trees are not the same\\n                return False\\n            if node1.right and node2.right:\\n                queue.append((node1.right, node2.right))\\n            elif node1.right or node2.right:\\n                # if only one of the nodes has a right child, the trees are not the same\\n                return False\\n        # if we made it through the loop, the trees are the same\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642761,
                "title": "easy-to-understand-faster-simple-recursive-iterative-dfs-python-solution",
                "content": "```\\n    def recursive(self, p, q):\\n        if not p and not q:\\n            return True\\n        elif not p or not q:\\n            return False\\n        else:\\n            return p.val == q.val and self.recursive(p.left, q.left) and self.recursive(p.right, q.right)\\n        \\n    def iterative(self, p, q):\\n        stack = [(p, q)]\\n        while len(stack):\\n            first, second = stack.pop()\\n            if not first and not second: pass\\n            elif not first or not second: return False\\n            else:\\n                if first.val != second.val: return False\\n                stack.append((first.left, second.left))\\n                stack.append((first.right, second.right))\\n        return True\\n        \\n    \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def recursive(self, p, q):\\n        if not p and not q:\\n            return True\\n        elif not p or not q:\\n            return False\\n        else:\\n            return p.val == q.val and self.recursive(p.left, q.left) and self.recursive(p.right, q.right)\\n        \\n    def iterative(self, p, q):\\n        stack = [(p, q)]\\n        while len(stack):\\n            first, second = stack.pop()\\n            if not first and not second: pass\\n            elif not first or not second: return False\\n            else:\\n                if first.val != second.val: return False\\n                stack.append((first.left, second.left))\\n                stack.append((first.right, second.right))\\n        return True\\n        \\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3028777,
                "title": "java-without-recursion-100-faster",
                "content": "Upvote if it helps \\u270C\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n\\t     Stack<TreeNode> stack_q = new Stack <> ();\\n\\t     if (p != null) stack_p.push( p ) ;\\n\\t     if (q != null) stack_q.push( q ) ;\\n\\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n\\t    \\t TreeNode pn = stack_p.pop() ;\\n\\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n\\t    \\t if (pn.val != qn.val) return false ;\\n\\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n\\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n\\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t     }\\t\\t     \\n\\t     return stack_p.size() == stack_q.size() ;\\t \\n\\t }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n\\t     Stack<TreeNode> stack_q = new Stack <> ();\\n\\t     if (p != null) stack_p.push( p ) ;\\n\\t     if (q != null) stack_q.push( q ) ;\\n\\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n\\t    \\t TreeNode pn = stack_p.pop() ;\\n\\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n\\t    \\t if (pn.val != qn.val) return false ;\\n\\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n\\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n\\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t     }\\t\\t     \\n\\t     return stack_p.size() == stack_q.size() ;\\t \\n\\t }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158580,
                "title": "python-dfs-stack-queue",
                "content": "### 100. Same Tree\\n```\\n> \\u7C7B\\u578B\\uFF1ADFSF\\u5206\\u5236\\n> Time Complexity O(N)\\n> Space Complexity O(h)\\n```\\n\\n\\u5728\\u6BCF\\u4E00\\u5C42\\u5148\\u68C0\\u67E5\\u518D\\u9012\\u5F52\\uFF0C\\u6240\\u4EE5\\u8FD9\\u662Fpre-order\\u7684\\u601D\\u8DEF\\u3002\\n\\u6BD4\\u5BF9\\u76F8\\u7B49\\u7684\\u6761\\u4EF6\\uFF1A\\n1. `p.val == q.val`\\n2. `if not p or not q: return p == q`\\n\\u5982\\u6709\\u4E0D\\u7B49\\uFF0C\\u76F4\\u63A5\\u8FD4\\u56DEFalse\\uFF0C\\u5C31\\u4E0D\\u7528\\u7EE7\\u7EED\\u9012\\u5F52\\u4E86\\u3002\\u6700\\u540E\\u5DE6\\u53F3\\u5B69\\u5B50\\u8FD4\\u56DE\\u7ED9Root\\uFF1A`return left and right`\\n\\n\\np.s. \\u4E0A\\u9762\\u7684\\u7B2C\\u4E8C\\u4E2A\\u76F8\\u7B49\\u6761\\u4EF6\\uFF0C\\u68C0\\u67E5\\u4E862\\u79CD\\u60C5\\u51B5\\uFF1A\\n1.`if not p and not q: return True`\\n2.`if not p or not q: return False`\\n\\n#### DFS\\n```python     \\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        return left and right\\n```\\n\\n#### Stack\\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\\n\\n#### Queue\\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFSF\\u5206\\u5236\\n> Time Complexity O(N)\\n> Space Complexity O(h)\\n```\n```python     \\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        return left and right\\n```\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32926,
                "title": "2-lines-c-simple-solution-easy-understanding",
                "content": "    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p || !q) return q == p;\\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p || !q) return q == p;\\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 733783,
                "title": "python-3-lines-recursion-explained",
                "content": "As it given in problem statement: two binary trees are considered the same if they are structurally identical and the nodes have the same value. So all we need to do is to check this condition recursively:\\n\\nIf we reached node `p` in one tree and `q` in another tree (we allow to reach `None` nodes), we need to consider 3 cases:\\n\\n1. If one of them do not exist and another exist, we return `False`.\\n2. If two of them are equal to `None`, we return `True`.\\n3. If none of two above condition holds, we look at children and return `True` only if values of nodes are equal and if `True` holds for left and right subtrees.\\n\\n**Complexity**: time complexity is `O(n)`, because we traverse all tree. Space complexity is `O(h)` to keep recursion stack. Time complexity can be imporved a bit, if we use helper function and directly return `False` if we found difference between trees. \\n\\n```\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        if p and not q or q and not p: return False\\n        if not p and not q: return True\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        if p and not q or q and not p: return False\\n        if not p and not q: return True\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32910,
                "title": "python-recursive-solution-within-36ms",
                "content": "    class Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not q and not p:\\n            return True\\n        elif not p or not q:\\n            return False\\n        elif p.val!=q.val:\\n            return False\\n        else:\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not q and not p:\\n            return True\\n        elif not p or not q:\\n            return False\\n        elif p.val!=q.val:\\n            return False\\n        else:\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)",
                "codeTag": "Java"
            },
            {
                "id": 3029585,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        if (p->val != q->val) {\\n            return false;\\n        }\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n```\\n\\n```Java []\\nclass Solution {\\n  public boolean isSameTree(TreeNode p, TreeNode q) {\\n    if (p == null || q == null)\\n      return p == q;\\n    return p.val == q.val &&\\n           isSameTree(p.left, q.left) &&\\n           isSameTree(p.right, q.right);\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        if (p->val != q->val) {\\n            return false;\\n        }\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n```\n```Java []\\nclass Solution {\\n  public boolean isSameTree(TreeNode p, TreeNode q) {\\n    if (p == null || q == null)\\n      return p == q;\\n    return p.val == q.val &&\\n           isSameTree(p.left, q.left) &&\\n           isSameTree(p.right, q.right);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32721,
                "title": "2-lines-java-code",
                "content": "    public class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == null && q == null) return true;\\n            return p != null && q != null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        } }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == null && q == null) return true;\\n            return p != null && q != null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32703,
                "title": "javascript-solution",
                "content": "Nothing fancy, just perform a preorder traversal for both trees at the same pace, simply return `false` whenever we found a mismatch, otherwise continue the traversal on both left and right subtrees.\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)` (ignore recursion stack, otherwise the height of the tree)\\n```\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) {\\n        return true;\\n    }\\n    if (!p || !q || p.val !== q.val) {\\n        return false;\\n    }\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) {\\n        return true;\\n    }\\n    if (!p || !q || p.val !== q.val) {\\n        return false;\\n    }\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1724190,
                "title": "python-3-30ms-recursive-dfs-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None and q is None:\\n            return True\\n        if p is None or q is None:\\n            return False\\n        if p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right):\\n            return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None and q is None:\\n            return True\\n        if p is None or q is None:\\n            return False\\n        if p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right):\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32936,
                "title": "c-solutions-recursively-bfs-queue-dfs-stack",
                "content": "     \\n    // Recursively\\n    bool isSameTree1(TreeNode* p, TreeNode* q) {\\n        if (p && q)\\n            return p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        return p == q;\\n    }\\n    \\n    // BFS + queue\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        queue<pair<TreeNode*, TreeNode*>> myQueue;\\n        myQueue.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myQueue.empty()) {\\n            p = myQueue.front().first;\\n            q = myQueue.front().second;\\n            if(!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myQueue.pop();\\n            if(p && q) {\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->left, q->left));\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->right, q->right));\\n            }\\n        }\\n        return myQueue.empty();\\n    }\\n    \\n    // DFS + stack\\n    bool isSameTree3(TreeNode* p, TreeNode* q) {\\n        stack<pair<TreeNode*, TreeNode* >> myStack;\\n        myStack.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myStack.empty()) {\\n            p = myStack.top().first;\\n            q = myStack.top().second;\\n            if (!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myStack.pop();\\n            if (p && q) {\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->right, q->right));\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->left, q->left));\\n            }\\n        }\\n        return myStack.empty();\\n    }",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "     \\n    // Recursively\\n    bool isSameTree1(TreeNode* p, TreeNode* q) {\\n        if (p && q)\\n            return p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        return p == q;\\n    }\\n    \\n    // BFS + queue\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        queue<pair<TreeNode*, TreeNode*>> myQueue;\\n        myQueue.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myQueue.empty()) {\\n            p = myQueue.front().first;\\n            q = myQueue.front().second;\\n            if(!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myQueue.pop();\\n            if(p && q) {\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->left, q->left));\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->right, q->right));\\n            }\\n        }\\n        return myQueue.empty();\\n    }\\n    \\n    // DFS + stack\\n    bool isSameTree3(TreeNode* p, TreeNode* q) {\\n        stack<pair<TreeNode*, TreeNode* >> myStack;\\n        myStack.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myStack.empty()) {\\n            p = myStack.top().first;\\n            q = myStack.top().second;\\n            if (!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myStack.pop();\\n            if (p && q) {\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->right, q->right));\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->left, q->left));\\n            }\\n        }\\n        return myStack.empty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 32749,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar isSameTree = function(p, q) {\\n    // the same if both nodes are null\\n    if (!p && !q) return true;\\n    // not the same if either of the nodes is null or the values are different\\n    if ((!p && q) || (p && !q) || p.val !== q.val) return false;\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar isSameTree = function(p, q) {\\n    // the same if both nodes are null\\n    if (!p && !q) return true;\\n    // not the same if either of the nodes is null or the values are different\\n    if ((!p && q) || (p && !q) || p.val !== q.val) return false;\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32916,
                "title": "recursive-non-recursive-recommend-for-beginners-clean-c-implementation",
                "content": "> Non-recursive solution\\n\\n    class Solution {\\n    public:\\n        bool isSameTree(TreeNode* p, TreeNode* q) {\\n            stack<TreeNode*> stack_p;\\n            stack<TreeNode*> stack_q;\\n            if(p)   stack_p.push(p);\\n            if(q)   stack_q.push(q);\\n            while(!stack_p.empty() && !stack_q.empty()){\\n                TreeNode* cur_p=stack_p.top();\\n                TreeNode* cur_q=stack_q.top();\\n                stack_p.pop();\\n                stack_q.pop();\\n                if(cur_p->val!=cur_q->val) return false;\\n                if(cur_p->left) stack_p.push(cur_p->left);\\n                if(cur_q->left) stack_q.push(cur_q->left);\\n                if(stack_p.size() != stack_q.size())    return false;\\n                if(cur_p->right) stack_p.push(cur_p->right);\\n                if(cur_q->right) stack_q.push(cur_q->right);\\n                if(stack_p.size() != stack_q.size())    return false;\\n            }\\n            return stack_p.size() == stack_q.size();\\n        }\\n    };\\n\\n\\n> Recursive Solution\\n\\n    class Solution {\\n    public:\\n        bool isSameTree(TreeNode* p, TreeNode* q) {\\n            if(!p && !q)    return true;\\n            if(!p || !q)    return false;\\n            return p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSameTree(TreeNode* p, TreeNode* q) {\\n            stack<TreeNode*> stack_p;\\n            stack<TreeNode*> stack_q;\\n            if(p)   stack_p.push(p);\\n            if(q)   stack_q.push(q);\\n            while(!stack_p.empty() && !stack_q.empty()){\\n                TreeNode* cur_p=stack_p.top();\\n                TreeNode* cur_q=stack_q.top();\\n                stack_p.pop();\\n                stack_q.pop();\\n                if(cur_p->val!=cur_q->val) return false;\\n                if(cur_p->left) stack_p.push(cur_p->left);\\n                if(cur_q->left) stack_q.push(cur_q->left);\\n                if(stack_p.size() != stack_q.size())    return false;\\n                if(cur_p->right) stack_p.push(cur_p->right);\\n                if(cur_q->right) stack_q.push(cur_q->right);\\n                if(stack_p.size() != stack_q.size())    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 463101,
                "title": "c-short-and-easy-o-n-iterative-solution",
                "content": "```\\n bool isSameTree(TreeNode* p, TreeNode* q) {\\n    queue<TreeNode*> queue;\\n    if(p==NULL || q==NULL) return p==q;\\n    queue.push(p); queue.push(q);\\n    while(!queue.empty())  {\\n        TreeNode* left = queue.front(); queue.pop();\\n        TreeNode *right = queue.front(); queue.pop();\\n        if(left==NULL && right==NULL) continue;\\n        if(left==NULL || right==NULL) return false;\\n        if(left->val != right->val) return false;\\n        queue.push(left->left);\\n        queue.push(right->left);\\n        queue.push(left->right);\\n        queue.push(right->right);\\n    }\\n    return true;  \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\n bool isSameTree(TreeNode* p, TreeNode* q) {\\n    queue<TreeNode*> queue;\\n    if(p==NULL || q==NULL) return p==q;\\n    queue.push(p); queue.push(q);\\n    while(!queue.empty())  {\\n        TreeNode* left = queue.front(); queue.pop();\\n        TreeNode *right = queue.front(); queue.pop();\\n        if(left==NULL && right==NULL) continue;\\n        if(left==NULL || right==NULL) return false;\\n        if(left->val != right->val) return false;\\n        queue.push(left->left);\\n        queue.push(right->left);\\n        queue.push(left->right);\\n        queue.push(right->right);\\n    }\\n    return true;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361737,
                "title": "python3-recursively-and-bfs-and-dfs-iteratively",
                "content": "* recursively\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"    \\n        # p and q are both None\\n        if not p and not q:\\n            return True\\n        # one of p and q is None\\n        if (not q or not p) or (p.val != q.val):\\n            return False\\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\\n```\\n* DFS iteratively\\n```\\n# iterative DFS\\ndef isSameTree(p,q):\\n    stack =[(p,q)]\\n    while stack:\\n        p,q = stack.pop()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val !=q.val):\\n            return False\\n        stack.extend([(q.right,p.right),(q.left,p.left)])\\n    return True\\n```\\n\\n* BFS iteratively\\n```\\n# iterative BFS\\ndef isSameTreeBFS(p,q):\\n    queue = collections.deque([p,q])\\n    while queue:\\n        p,q = queue.popleft()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val != q.val):\\n            return False\\n        queue.extend([(p.left,q.left),(p.right,q.right)])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"    \\n        # p and q are both None\\n        if not p and not q:\\n            return True\\n        # one of p and q is None\\n        if (not q or not p) or (p.val != q.val):\\n            return False\\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\\n```\n```\\n# iterative DFS\\ndef isSameTree(p,q):\\n    stack =[(p,q)]\\n    while stack:\\n        p,q = stack.pop()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val !=q.val):\\n            return False\\n        stack.extend([(q.right,p.right),(q.left,p.left)])\\n    return True\\n```\n```\\n# iterative BFS\\ndef isSameTreeBFS(p,q):\\n    queue = collections.deque([p,q])\\n    while queue:\\n        p,q = queue.popleft()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val != q.val):\\n            return False\\n        queue.extend([(p.left,q.left),(p.right,q.right)])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028413,
                "title": "funny-one-liner-py",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301998,
                "title": "rust-one-line-solution",
                "content": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32969,
                "title": "three-lines-java-solution",
                "content": "public class Same_Tree {\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == q; // if they are null at the same time\\n\\n        if (p.val != q.val) return false;\\n\\n        return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);\\n    }\\n}",
                "solutionTags": [],
                "code": "public class Same_Tree {\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == q; // if they are null at the same time\\n\\n        if (p.val != q.val) return false;\\n\\n        return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3028332,
                "title": "python-simple-python-solution-using-dfs-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 35 ms, faster than 73.56% of Python3 online submissions for Same Tree.\\n# Memory Usage: 13.8 MB, less than 72.95% of Python3 online submissions for Same Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef DFS(node1 , node2):\\n\\n\\t\\t\\t\\tif node1 == None and node2 == None:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\telif node1 == None or node2 == None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\telif node1.val != node2.val:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn DFS(node1.left , node2.left) and DFS(node1.right , node2.right)\\n\\n\\t\\t\\treturn DFS(p , q)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 35 ms, faster than 73.56% of Python3 online submissions for Same Tree.\\n# Memory Usage: 13.8 MB, less than 72.95% of Python3 online submissions for Same Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef DFS(node1 , node2):\\n\\n\\t\\t\\t\\tif node1 == None and node2 == None:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\telif node1 == None or node2 == None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\telif node1.val != node2.val:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn DFS(node1.left , node2.left) and DFS(node1.right , node2.right)\\n\\n\\t\\t\\treturn DFS(p , q)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3027467,
                "title": "c-java-c-python-explained-beats-100-0ms",
                "content": "\\n# Appraoch (Recursive)\\n1. If both trees reach their end, then every node in them was checked (return True)\\n1. If one tree ends before the other (return False)\\n2. If a node is different than another (return False)\\n3. Call the function to check the left & right subtrees\\n4. return their conjunction (AND)\\n\\n![image.png](https://assets.leetcode.com/users/images/0c52c091-11e8-46d5-9868-93da969328cf_1673313225.8125043.png)\\n\\n# Explained Code\\n```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) // Same tree\\n            return true; \\n        if(p == nullptr || q == nullptr) // Different size\\n            return false; \\n        if(p->val != q->val) // Different Nodes\\n            return false; \\n        return isSameTree(p->left,q->left) && // check left subtree\\n               isSameTree(p->right,q->right); // check right subtree\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) // Same Tree\\n            return true;\\n        if(p == null || q == null) // Different Size\\n            return false;\\n        if(p.val != q.val) // Different Nodes\\n            return false;\\n        return  isSameTree(p.left,q.left) && // check left subtree\\n                isSameTree(p.right,q.right); // check right subtree\\n    }\\n}\\n```\\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) // Same Tree\\n            return true;\\n        if(p == NULL || q == NULL) // Different Size\\n            return false;\\n        if(p->val != q->val) // Different Nodes\\n            return false;\\n        return isSameTree(p->left,q->left) &&// check left subtree\\n               isSameTree(p->right,q->right);// check right subtree\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : # Same Tree\\n            return True\\n        if p == None or q == None : # Different Size\\n            return False\\n        if p.val != q.val : # Different Nodes \\n            return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```\\n# Raw Code\\n```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) return true; \\n        if(p == nullptr || q == nullptr) return false; \\n        if(p->val != q->val) return false; \\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val != q.val) return false;\\n        return  isSameTree(p.left,q.left) &&\\n                isSameTree(p.right,q.right);\\n    }\\n}\\n```\\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) return true;\\n        if(p == NULL || q == NULL) return false;\\n        if(p->val != q->val) return false;\\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : return True\\n        if p == None or q == None : return False\\n        if p.val != q.val : return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```\\nTime Complexity : $$O(n)$$\\nSpace Complexity : $$O(n)$$\\n![image.png](https://assets.leetcode.com/users/images/5e74b192-b0fc-4ce2-a284-6be226aec420_1673312476.8145483.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) // Same tree\\n            return true; \\n        if(p == nullptr || q == nullptr) // Different size\\n            return false; \\n        if(p->val != q->val) // Different Nodes\\n            return false; \\n        return isSameTree(p->left,q->left) && // check left subtree\\n               isSameTree(p->right,q->right); // check right subtree\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) // Same Tree\\n            return true;\\n        if(p == null || q == null) // Different Size\\n            return false;\\n        if(p.val != q.val) // Different Nodes\\n            return false;\\n        return  isSameTree(p.left,q.left) && // check left subtree\\n                isSameTree(p.right,q.right); // check right subtree\\n    }\\n}\\n```\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) // Same Tree\\n            return true;\\n        if(p == NULL || q == NULL) // Different Size\\n            return false;\\n        if(p->val != q->val) // Different Nodes\\n            return false;\\n        return isSameTree(p->left,q->left) &&// check left subtree\\n               isSameTree(p->right,q->right);// check right subtree\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : # Same Tree\\n            return True\\n        if p == None or q == None : # Different Size\\n            return False\\n        if p.val != q.val : # Different Nodes \\n            return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) return true; \\n        if(p == nullptr || q == nullptr) return false; \\n        if(p->val != q->val) return false; \\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val != q.val) return false;\\n        return  isSameTree(p.left,q.left) &&\\n                isSameTree(p.right,q.right);\\n    }\\n}\\n```\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) return true;\\n        if(p == NULL || q == NULL) return false;\\n        if(p->val != q->val) return false;\\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : return True\\n        if p == None or q == None : return False\\n        if p.val != q.val : return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508218,
                "title": "c-python-simple-solution",
                "content": "**C++ :**\\n\\n```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\tif(!p || !q)\\n\\t\\treturn (p == q);\\n\\n\\treturn (p -> val == q -> val) && isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\tif not p or not q:\\n\\t\\treturn p == q\\n\\n\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q. right)\\n```\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\tif(!p || !q)\\n\\t\\treturn (p == q);\\n\\n\\treturn (p -> val == q -> val) && isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);\\n}\\n```\n```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\tif not p or not q:\\n\\t\\treturn p == q\\n\\n\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q. right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 32856,
                "title": "3-lines-java-solution",
                "content": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if(p==null || q==null) return false;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n\\nrecursion",
                "solutionTags": [],
                "code": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if(p==null || q==null) return false;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n\\nrecursion",
                "codeTag": "Unknown"
            },
            {
                "id": 33026,
                "title": "java-one-liner-and-the-more-readable-solution-it-was-derived-from",
                "content": "Just for fun;\\n\\n    return p == null || q == null ? p == null && q == null : p.val != q.val ? false : \\n         isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n\\nThis is a ternary-if abusing version of the following (much more sensible) solution.\\n\\n    if (p == null || q == null) {\\n        return p == null && q == null;\\n    } else if (p.val == q.val) {\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    return false;\\n\\nThere's not a whole lot of magic here. We know that if either p or q is null, then if they're not both null, the trees do not share the same shape. \\n\\nOtherwise we go on to recursively check the node's children iff the values of p and q are equal, returning false otherwise.",
                "solutionTags": [
                    "Java"
                ],
                "code": "Just for fun;\\n\\n    return p == null || q == null ? p == null && q == null : p.val != q.val ? false : \\n         isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n\\nThis is a ternary-if abusing version of the following (much more sensible) solution.\\n\\n    if (p == null || q == null) {\\n        return p == null && q == null;\\n    } else if (p.val == q.val) {\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    return false;\\n\\nThere's not a whole lot of magic here. We know that if either p or q is null, then if they're not both null, the trees do not share the same shape. \\n\\nOtherwise we go on to recursively check the node's children iff the values of p and q are equal, returning false otherwise.",
                "codeTag": "Unknown"
            },
            {
                "id": 2778173,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919297,
                "title": "c-100-faster-100-memory-efficient-easy-code",
                "content": "If one of the tree is NULL, then ans is \\'false\\'\\nIf both the trees are NULL, then ans is \\'true\\'\\n\\n**1. Recursive approach :**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\t\\n\\t\\t\\tif(p==NULL && q!=NULL)return false;\\n\\t\\t\\tif(q==NULL && p!=NULL)return false;\\n\\n\\t\\t\\tif(p==NULL && q==NULL)return true;\\n\\n\\t\\t\\tbool l=false;\\n\\t\\t\\tbool r = false;\\n\\n\\t\\t\\tif(p->val == q->val){\\n\\t\\t\\t\\tl = isSameTree(p->left,q->left);\\n\\t\\t\\t\\tr = isSameTree(p->right,q->right);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn l&r;        \\n\\t\\t}\\n\\t};\\n\\t\\n**2. Iterative approach:**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\n\\t\\t\\t//for iterative approach, we generally follow the 4 major steps:\\n\\t\\t\\t//1. Make a queue \\n\\t\\t\\t//2. Push the current Node in the queue (starting from the root node)\\n\\t\\t\\t//3. Process the queue, while its not empty (by adding its left & right child)\\n\\t\\t\\t//4. Once the queue is empty, then alorithm has finished\\n\\n\\t\\t\\t//Step 1\\n\\t\\t\\tqueue<TreeNode*> qu;  \\n\\n\\t\\t\\t//Step 2\\n\\t\\t\\tqu.push(p);\\n\\t\\t\\tqu.push(q);\\n\\n\\t\\t\\t//step 3\\n\\t\\t\\twhile(qu.size() != 0){\\n\\t\\t\\t\\tTreeNode* n1 = qu.front();\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tTreeNode* n2 = qu.front();\\n\\t\\t\\t\\tqu.pop();\\n\\n\\t\\t\\t\\t//meet the question conditions\\n\\t\\t\\t\\tif(n1 == NULL && n2 == NULL) continue;\\n\\t\\t\\t\\tif(n1 == NULL || n2 == NULL) return false;\\n\\t\\t\\t\\tif(n1->val != n2->val) return false;\\n\\n\\t\\t\\t\\tqu.push(n1->left);\\n\\t\\t\\t\\tqu.push(n2->left);\\n\\t\\t\\t\\tqu.push(n1->right);\\n\\t\\t\\t\\tqu.push(n2->right);\\n\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t//Step 4\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\t\\n\\t\\t\\tif(p==NULL && q!=NULL)return false;\\n\\t\\t\\tif(q==NULL && p!=NULL)return false;\\n\\n\\t\\t\\tif(p==NULL && q==NULL)return true;\\n\\n\\t\\t\\tbool l=false;\\n\\t\\t\\tbool r = false;\\n\\n\\t\\t\\tif(p->val == q->val){\\n\\t\\t\\t\\tl = isSameTree(p->left,q->left);\\n\\t\\t\\t\\tr = isSameTree(p->right,q->right);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3027471,
                "title": "javascript-simple-video-explanation-dfs",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://youtu.be/37Q-F5qqsXw\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true\\n    if (!p || !q || p.val !== q.val) return false\\n    return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right))\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true\\n    if (!p || !q || p.val !== q.val) return false\\n    return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1926231,
                "title": "100-fastest-swift-solution-time-o-min-n-m-space-o-min-n-m",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    //   - space: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    \\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\\n        guard p != nil || q != nil else { return true }\\n        \\n        guard let p = p, let q = q else { return false }\\n        \\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    //   - space: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    \\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\\n        guard p != nil || q != nil else { return true }\\n        \\n        guard let p = p, let q = q else { return false }\\n        \\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028320,
                "title": "explanation-with-images-clean-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, think from the smallest part. The smallest part or the base case of a tree to consider is when it is null.\\n\\n- If both trees are null, they are the same. So, we will return true.\\n- If one of them is null, then they cannot be equal. So, we will return false.\\n\\n![image.png](https://assets.leetcode.com/users/images/a0233f35-a325-4a35-84d2-6ce2767a81dc_1673326587.6208208.png)\\n\\n- When both nodes are not null, we first need to check if the values are equal. Then we will traverse the left subtree and the right subtree of the both tree sequentially.\\n\\n- Check if `p.val == q.val`:\\n\\n![image.png](https://assets.leetcode.com/users/images/7c934401-4552-40ff-8b3c-d1ad64758202_1673326852.0365388.png)\\n\\n- Recursively call the left and right subtree:\\n\\n- Left Subtree `isSameTree(p.left, q.left)` :\\n\\n![image.png](https://assets.leetcode.com/users/images/a359591a-bcf4-4b46-8e47-3ee1d7c598cc_1673326981.6579647.png)\\n\\n- Right Subtree `isSameTree(p.right, q.right)` :\\n\\n![image.png](https://assets.leetcode.com/users/images/5e6e7bfb-a2e2-4114-8085-9175430c08de_1673327073.0911453.png)\\n\\n\\n- Now, all of these must return true. So, the recursive call should return:\\n\\n`p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)`\\n\\nIf one of them is not true, it will be false. That\\'s why we need the && operation.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we visit every node of the tree.\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe recursion stack is called n times in worst case. So, it will need $$O(n)$$ memory.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        if(p == null || q == null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        if(p == null || q == null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028316,
                "title": "rust-derive-eq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe defination of TreeNode derived the Eq trait so the answer is just use it.\\n\\n# Code\\n```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn is_same_tree(\\n        p: Option<Rc<RefCell<TreeNode>>>,\\n        q: Option<Rc<RefCell<TreeNode>>>,\\n    ) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn is_same_tree(\\n        p: Option<Rc<RefCell<TreeNode>>>,\\n        q: Option<Rc<RefCell<TreeNode>>>,\\n    ) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 766257,
                "title": "rust-recursive-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Same Tree.\\nMemory Usage: 2 MB, less than 100.00% of Rust online submissions for Same Tree.\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (None, None) => true,\\n            (Some(p), Some(q)) => {\\n                let p = p.borrow();\\n                let q = q.borrow();\\n                p.val == q.val\\n                    && Self::is_same_tree(p.left.clone(), q.left.clone())\\n                    && Self::is_same_tree(p.right.clone(), q.right.clone())\\n            }\\n            _ => false,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (None, None) => true,\\n            (Some(p), Some(q)) => {\\n                let p = p.borrow();\\n                let q = q.borrow();\\n                p.val == q.val\\n                    && Self::is_same_tree(p.left.clone(), q.left.clone())\\n                    && Self::is_same_tree(p.right.clone(), q.right.clone())\\n            }\\n            _ => false,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560321,
                "title": "python-js-go-c-o-n-sol-by-dfs-w-visualization",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/6506b5dbfd89780001901407)\\n\\nO(n) sol by DFS\\n\\n---\\n\\n**Diagram** and **Abstract Model**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585824141.png)\\n\\n\\n---\\n\\n\\n**Implementation** by DFS:\\n\\nPython:\\n\\n```\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \\n        if p and q:\\n            \\n            # Both p and q are non-empty\\n            # Check equality on both subtree\\n            return (p.val == q.val) and self.isSameTree( p.left, q.left) and self.isSameTree( p.right, q.right )\\n        \\n        else:\\n            \\n            # At least one of them is empty\\n            # Check whether both p and q are empty or not\\n            return p == q\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar isSameTree = function(p, q) {\\n\\n    if( p && q ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q;    \\n    }\\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    \\n    if( (p!=nil) && (q!=nil) ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return (p.Val == q.Val) && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q\\n    }\\n    \\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n     \\n        if( p && q){\\n            \\n            // Both p and q are non-empty\\n            // Check equality on both subtree\\n            return p->val == q->val && isSameTree( p->left, q->left) && isSameTree( p->right, q->right);\\n            \\n        }else{\\n            \\n            // At least one of them is empty\\n            // Check whether both p and q are empty or not\\n            return p == q;\\n        }\\n    }\\n};\\n```\\n\\n\\n---\\n\\nAnother **Implementation** by BFS :\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n\\n        def bfs( node: TreeNode ):\\n            \\n            cur_queue = [ node ] if node else [ None ]\\n\\n            while cur_queue:\\n                \\n                next_queue = []\\n                \\n                for cur_node in cur_queue:\\n                    \\n                    if cur_node:\\n                        \\n                        yield cur_node.val\\n                        \\n                        next_queue.append( cur_node.left )\\n                        next_queue.append( cur_node.right )\\n                        \\n                    else:\\n                        yield None\\n            \\n                cur_queue = next_queue\\n            \\n        # -----------------------------------------------------\\n        \\n        iterator_p =  bfs( p ) \\n        iterator_q =  bfs( q ) \\n        \\n        while True:\\n            try:\\n                if next(iterator_p) != next(iterator_q):\\n                    return False\\n            except StopIteration:\\n                break\\n        \\n        return True\\n```\\n\\n---\\n\\n\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #101 Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)\\n\\n[Leetcode #144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal)\\n\\n---\\n\\nReference:\\n\\n[Wiki: Pre-order traversal of binary tree](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \\n        if p and q:\\n            \\n            # Both p and q are non-empty\\n            # Check equality on both subtree\\n            return (p.val == q.val) and self.isSameTree( p.left, q.left) and self.isSameTree( p.right, q.right )\\n        \\n        else:\\n            \\n            # At least one of them is empty\\n            # Check whether both p and q are empty or not\\n            return p == q\\n```\n```\\nvar isSameTree = function(p, q) {\\n\\n    if( p && q ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q;    \\n    }\\n    \\n};\\n```\n```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    \\n    if( (p!=nil) && (q!=nil) ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return (p.Val == q.Val) && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n     \\n        if( p && q){\\n            \\n            // Both p and q are non-empty\\n            // Check equality on both subtree\\n            return p->val == q->val && isSameTree( p->left, q->left) && isSameTree( p->right, q->right);\\n            \\n        }else{\\n            \\n            // At least one of them is empty\\n            // Check whether both p and q are empty or not\\n            return p == q;\\n        }\\n    }\\n};\\n```\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n\\n        def bfs( node: TreeNode ):\\n            \\n            cur_queue = [ node ] if node else [ None ]\\n\\n            while cur_queue:\\n                \\n                next_queue = []\\n                \\n                for cur_node in cur_queue:\\n                    \\n                    if cur_node:\\n                        \\n                        yield cur_node.val\\n                        \\n                        next_queue.append( cur_node.left )\\n                        next_queue.append( cur_node.right )\\n                        \\n                    else:\\n                        yield None\\n            \\n                cur_queue = next_queue\\n            \\n        # -----------------------------------------------------\\n        \\n        iterator_p =  bfs( p ) \\n        iterator_q =  bfs( q ) \\n        \\n        while True:\\n            try:\\n                if next(iterator_p) != next(iterator_q):\\n                    return False\\n            except StopIteration:\\n                break\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543621,
                "title": "javascript-recursion-iterative",
                "content": "- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true;\\n    if (!p || !q) return false;\\n    return p.val === q.val\\n        && isSameTree(p.left, q.left)\\n        && isSameTree(p.right, q.right);\\n};\\n```\\n```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    const stack1 = [], stack2 = [];\\n    while (p || q || stack1.length || stack2.length) {\\n        while (p) {\\n            stack1.push(p);\\n            p = p.left\\n        }\\n        while (q) {\\n            stack2.push(q);\\n            q = q.left;\\n        }\\n        p = stack1.pop();\\n        q = stack2.pop();\\n        if (!p && !q) {\\n            continue;\\n        }\\n        if (!p || !q || p.val !== q.val) {\\n            return false;\\n        }\\n        stack1.push(null);\\n        stack2.push(null);\\n        p = p.right;\\n        q = q.right;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true;\\n    if (!p || !q) return false;\\n    return p.val === q.val\\n        && isSameTree(p.left, q.left)\\n        && isSameTree(p.right, q.right);\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    const stack1 = [], stack2 = [];\\n    while (p || q || stack1.length || stack2.length) {\\n        while (p) {\\n            stack1.push(p);\\n            p = p.left\\n        }\\n        while (q) {\\n            stack2.push(q);\\n            q = q.left;\\n        }\\n        p = stack1.pop();\\n        q = stack2.pop();\\n        if (!p && !q) {\\n            continue;\\n        }\\n        if (!p || !q || p.val !== q.val) {\\n            return false;\\n        }\\n        stack1.push(null);\\n        stack2.push(null);\\n        p = p.right;\\n        q = q.right;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456229,
                "title": "python-recursion-iteration",
                "content": "# Recursion:\\n```python\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\nRuntime: 24 ms, faster than 95.22% of Python3 online submissions for Same Tree.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Same Tree.\\n\\n\\n# Iteration:\\none function\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        def check(p,q):\\n            if not p and not q:  return True\\n            if not p or not q:  return False\\n            if p.val != q.val: return False\\n            return True\\n        deq = deque([(p , q),])\\n        while deq:\\n            p , q = deq.popleft()\\n            if not check(p , q): return False\\n            if p:\\n                deq.append((p.left , q.left))\\n                deq.append((p.right , q.right))\\n        return True\\n```\\nRuntime: 28 ms, faster than 85.04% of Python3 online submissions for Same Tree.\\nMemory Usage: 12.7 MB, less than 100.00% of Python3 online submissions for Same Tree.\\n\\ntwo function , which is more easy to understand\\n```python\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\\nRuntime: 28 ms, faster than 85.04% of Python3 online submissions for Same Tree.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Same Tree.\\n\\nRecursion is faster a little \\n\\n**If it helps you , \\nPlease give me a vote star\\nThanls**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\n```python\\nfrom collections import deque\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        def check(p,q):\\n            if not p and not q:  return True\\n            if not p or not q:  return False\\n            if p.val != q.val: return False\\n            return True\\n        deq = deque([(p , q),])\\n        while deq:\\n            p , q = deq.popleft()\\n            if not check(p , q): return False\\n            if p:\\n                deq.append((p.left , q.left))\\n                deq.append((p.right , q.right))\\n        return True\\n```\n```python\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432219,
                "title": "python-20ms-beats-99-64",
                "content": "```\\n\\nclass Solution:\\n    def preOrder(self,a,l):\\n        if not a:\\n            l.append(None)\\n        else:\\n            l.append(a.val)\\n            self.preOrder(a.left,l)\\n            self.preOrder(a.right,l)\\n        return l\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        pl=self.preOrder(p,[])\\n        ql=self.preOrder(q,[])\\n        return(pl==ql)\\n\\t\\t\\n```\\n   \\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def preOrder(self,a,l):\\n        if not a:\\n            l.append(None)\\n        else:\\n            l.append(a.val)\\n            self.preOrder(a.left,l)\\n            self.preOrder(a.right,l)\\n        return l\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        pl=self.preOrder(p,[])\\n        ql=self.preOrder(q,[])\\n        return(pl==ql)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293440,
                "title": "just-3-lines-of-code-superb-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:----->90%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:---->99%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        def iss(p,q):\\n            if p==None and q==None: return True\\n            if p==None or q==None: return False\\n            return p.val==q.val and iss(p.left,q.left) and iss(p.right,q.right)\\n        return iss(p,q)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        def iss(p,q):\\n            if p==None and q==None: return True\\n            if p==None or q==None: return False\\n            return p.val==q.val and iss(p.left,q.left) and iss(p.right,q.right)\\n        return iss(p,q)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027571,
                "title": "c-easy-solution",
                "content": "```re\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p and !q)\\n        return true;\\n        if(!p || !q)\\n        return false;\\n        if(p->val!=q->val)\\n        return false;\\n        return isSameTree(p->left,q->left) and isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```re\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p and !q)\\n        return true;\\n        if(!p || !q)\\n        return false;\\n        if(p->val!=q->val)\\n        return false;\\n        return isSameTree(p->left,q->left) and isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733818,
                "title": "c-simple-one-line-performing-100-time-90-space-recursive-solution-explained",
                "content": "First of all I check if both nodes are `NULL`, in which case I return `true`; if it is `false`, then I move to the right term of my `||` statement as follows.\\n\\nIf at least one of them is not `NULL`, then I make sure that they both are valid (ie: non terminal, non `NULL`) nodes (`p && q`,  I can stop there if see that one is `NULL` and other is not). If that is `true` (both are valid nodes), then I can access their properties without fearing errors and first of all I compare their `val`s; if they match, I progress onwars, calling the function recursively on their `left` and then `right` branches.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return !p && !q || p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\nThe kind of sweet problem that you solve in one line, first attempt and that sets your mood for the day (and hopefully the week as well!) - thanks LC :)\\n\\nEdit: now that I posted, I see that actually this solution is giving me consistenly 100% time - title updated!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return !p && !q || p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33022,
                "title": "simple-iterative-solution",
                "content": "    public class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if(p == null && q == null){\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\t//structure\\n    \\t\\tif(p == null || q == null){\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t//val\\n    \\t\\tif(p.val != q.val){\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tStack<TreeNode> stk1 = new Stack<TreeNode>();\\n    \\t\\tStack<TreeNode> stk2 = new Stack<TreeNode>();\\n    \\t\\tstk1.push(p);\\n    \\t\\tstk2.push(q);\\n    \\t\\t\\n    \\t\\twhile( !stk1.isEmpty() && !stk2.isEmpty() ){\\n    \\t\\t\\tTreeNode tn1 = stk1.pop();\\n    \\t\\t\\tTreeNode tn2 = stk2.pop();\\n    \\t\\t\\t\\n    \\t\\t\\tif(tn1.val != tn2.val){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\t//structure different\\n    \\t\\t\\tif(tn1.left == null && tn2.left != null){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}else if (tn1.left != null && tn2.left == null){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}else if (tn1.right == null && tn2.right != null){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}else if (tn1.right != null && tn2.right == null) {\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t\\tif(tn1.left != null && tn2.left != null){\\n    \\t\\t\\t\\tstk1.push(tn1.left);\\n    \\t\\t\\t\\tstk2.push(tn2.left);\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t\\tif(tn1.right != null && tn2.right != null){\\n    \\t\\t\\t\\tstk1.push(tn1.right);\\n    \\t\\t\\t\\tstk2.push(tn2.right);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn true;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if(p == null && q == null){\\n    \\t\\t\\treturn true;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1300535,
                "title": "c-3-statements-only-easily-understand-recursion",
                "content": "Here we simply trasverse each node of both the given trees and compare if each of their child is similar with current root. If all of them returns `true` then keep on checking and at any time if we get `false` we return the answer.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p == NULL && q == NULL)\\n            return true;\\n        \\n        if(p == NULL || q == NULL)\\n            return false;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\t\\t//If value at root and both childs are same\\n    }\\n};\\n```\\n\\u2728 PS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments :slight_smile:. Thanks for reading.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p == NULL && q == NULL)\\n            return true;\\n        \\n        if(p == NULL || q == NULL)\\n            return false;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\t\\t//If value at root and both childs are same\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083292,
                "title": "non-recursive-javscript",
                "content": "```\\nvar isSameTree = function(p, q) {\\n    let stack = [[p,q]];\\n    \\n    while (stack.length){\\n        let [x,y] = stack.shift();\\n\\t\\t\\n        // if both leaves\\n        if (x==null && y==null) continue; \\n        if(!x || !y) return false;\\n        if(x.val == y.val){\\n            stack.push([x.left, y.left]);\\n            stack.push([x.right, y.right]);\\n        }\\n        else return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSameTree = function(p, q) {\\n    let stack = [[p,q]];\\n    \\n    while (stack.length){\\n        let [x,y] = stack.shift();\\n\\t\\t\\n        // if both leaves\\n        if (x==null && y==null) continue; \\n        if(!x || !y) return false;\\n        if(x.val == y.val){\\n            stack.push([x.left, y.left]);\\n            stack.push([x.right, y.right]);\\n        }\\n        else return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557390,
                "title": "c-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Same Tree.\\nMemory Usage: 5.3 MB, less than 100.00% of C online submissions for Same Tree.\\n\\n```c\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    if (p == NULL && q == NULL) {\\n        return true;\\n    } else if (p == NULL || q == NULL) {\\n        return false;\\n    }\\n    \\n    if (p->val == q->val) {\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    } else {\\n        return false;\\n    }\\n} \\n```",
                "solutionTags": [],
                "code": "```c\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    if (p == NULL && q == NULL) {\\n        return true;\\n    } else if (p == NULL || q == NULL) {\\n        return false;\\n    }\\n    \\n    if (p->val == q->val) {\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    } else {\\n        return false;\\n    }\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32884,
                "title": "oh-java-thou-beauty",
                "content": "    public class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if((q==null || p==null)) return false\\n        return (p.val == q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if((q==null || p==null)) return false\\n        return (p.val == q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3187804,
                "title": "100-same-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved recursively. We first check if the roots of the two trees are equal. Then we check recursively if the left and right subtrees of the two trees are equal.\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is the number of nodes in the larger tree.\\n\\n- Space complexity:\\nO(H) where H is the height of the larger tree. In the worst case, the space complexity can be O(N) when the tree is completely unbalanced.\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        # if both nodes are None, return True\\n        if not p and not q:\\n            return True\\n        # if one of the nodes is None, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the nodes are not equal, return False\\n        if p.val != q.val:\\n            return False\\n        # check recursively if the left and right subtrees are equal\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        # if both nodes are None, return True\\n        if not p and not q:\\n            return True\\n        # if one of the nodes is None, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the nodes are not equal, return False\\n        if p.val != q.val:\\n            return False\\n        # check recursively if the left and right subtrees are equal\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036465,
                "title": "c-solution-with-video",
                "content": "# Video\\nhttps://youtu.be/m_oZLz8tk8g\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        \\n        return (\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right)\\n        );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        \\n        return (\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right)\\n        );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028181,
                "title": "simple-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL&&q==NULL)\\n        return true;\\n        if((p==NULL&&q!=NULL)||(p!=NULL&&q==NULL)||(p->val!=q->val))\\n        return false;\\n        if(isSameTree(p->left, q->left)==false||isSameTree(p->right, q->right)==false)\\n        return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL&&q==NULL)\\n        return true;\\n        if((p==NULL&&q!=NULL)||(p!=NULL&&q==NULL)||(p->val!=q->val))\\n        return false;\\n        if(isSameTree(p->left, q->left)==false||isSameTree(p->right, q->right)==false)\\n        return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419286,
                "title": "very-easy-0-ms-100-fully-explained-c-java-python-js-c-python3",
                "content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\\n# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Same Tree.\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are empty then return true...\\n        if(p == null && q == null) {\\n            return true;\\n        }\\n        // If one of the tree is empty and the other is not then return false...\\n        else if(p == null || q == null) {\\n            return false;\\n        }\\n        // If the value of p tree is equal to the value of q tree...\\n        if(p.val == q.val){\\n            // Check left subtrees and right subtrees recursively...\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }\\n        // If the value is different, false is returned\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 2 ms, faster than 89.56% of C++ online submissions for Same Tree.\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both trees are empty then return true...\\n        if(p == NULL && q == NULL)\\n            return true;\\n        // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n        if(p == NULL || q == NULL || p->val != q->val)\\n            return false;\\n        // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```\\n        \\n# **JavaSript Solution:**\\n```\\nvar isSameTree = function(p, q) {\\n    // If both trees are empty then return true...\\n    if(p == null && q == null) {\\n        return true;\\n    }\\n    // If one of the tree is empty and the other is not then return false...\\n    else if(p == null || q == null) {\\n        return false;\\n    }\\n    // If the value of p tree is equal to the value of q tree...\\n    if(p.val == q.val){\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    // If the value is different, false is returned\\n    else{\\n        return false;\\n    }\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    // If both trees are empty then return true...\\n    if(p == NULL && q == NULL)\\n        return true;\\n    // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n    if(p == NULL || q == NULL || p->val != q->val)\\n        return false;\\n    // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n    // Check left subtrees and right subtrees recursively...\\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are empty then return true...\\n        if(p == null && q == null) {\\n            return true;\\n        }\\n        // If one of the tree is empty and the other is not then return false...\\n        else if(p == null || q == null) {\\n            return false;\\n        }\\n        // If the value of p tree is equal to the value of q tree...\\n        if(p.val == q.val){\\n            // Check left subtrees and right subtrees recursively...\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }\\n        // If the value is different, false is returned\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both trees are empty then return true...\\n        if(p == NULL && q == NULL)\\n            return true;\\n        // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n        if(p == NULL || q == NULL || p->val != q->val)\\n            return false;\\n        // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```\n```\\nvar isSameTree = function(p, q) {\\n    // If both trees are empty then return true...\\n    if(p == null && q == null) {\\n        return true;\\n    }\\n    // If one of the tree is empty and the other is not then return false...\\n    else if(p == null || q == null) {\\n        return false;\\n    }\\n    // If the value of p tree is equal to the value of q tree...\\n    if(p.val == q.val){\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    // If the value is different, false is returned\\n    else{\\n        return false;\\n    }\\n};\\n```\n```\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    // If both trees are empty then return true...\\n    if(p == NULL && q == NULL)\\n        return true;\\n    // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n    if(p == NULL || q == NULL || p->val != q->val)\\n        return false;\\n    // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n    // Check left subtrees and right subtrees recursively...\\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n}\\n```\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726340,
                "title": "100-faster-and-elegant-c-solution",
                "content": "Dear All,\\n\\nPlease find below 100% faster and elegant C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if( p == nullptr && q == nullptr ) return true;\\n        if( p == nullptr || q == nullptr ) return false;\\n        if( p->val != q->val ) return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\nHope you found this solution useful.\\n\\nThank you and have a good day.\\n\\nBest regards, Yevhen.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if( p == nullptr && q == nullptr ) return true;\\n        if( p == nullptr || q == nullptr ) return false;\\n        if( p->val != q->val ) return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471532,
                "title": "2-liner-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        return (p!=NULL && q!=NULL) ? (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        return (p!=NULL && q!=NULL) ? (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872029,
                "title": "python3-dfs-easy-solution",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is None:\\n            return True\\n        elif p is None or q is None:\\n            return False\\n\\n        if p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is None:\\n            return True\\n        elif p is None or q is None:\\n            return False\\n\\n        if p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "codeTag": "Java"
            },
            {
                "id": 428859,
                "title": "rust-0-ms-iterative-recursive-and-native-solutions",
                "content": "Nobody posted yet an iterative solution for Rust, so here\\'s mine.\\n\\n**Iteration**\\n\\nQuite complex but still 0 ms runtime.\\n\\nBecause of the borrow checker I couldn\\'t push to the queue references to the left and right nodes Options from inside the while loop, so I had to clone the Rcs and wrap them in new Options.\\n\\nDoes anyone have a better solution?\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::Ref;\\nuse std::cell::RefCell;\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut deque: VecDeque<(Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>)> =\\n            VecDeque::new();\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                deque.push_back((Some(Rc::clone(&p)), Some(Rc::clone(&q))));\\n            }\\n            (None, None) => return true,\\n            _ => return false,\\n        }\\n        while !deque.is_empty() {\\n            let (p, q) = deque.pop_front().unwrap();\\n            if !match (&p, &q) {\\n                (Some(p), Some(q)) => p.borrow().val == q.borrow().val,\\n                (None, None) => true,\\n                _ => false,\\n            } {\\n                return false;\\n            }\\n            if let (Some(p), Some(q)) = (p, q) {\\n                let (p, q) = (\\n                    Solution::clone_nodes(p.borrow()),\\n                    Solution::clone_nodes(q.borrow()),\\n                );\\n                deque.push_back((p.0, q.0));\\n                deque.push_back((p.1, q.1));\\n            }\\n        }\\n        true\\n    }\\n    \\n    fn clone_nodes(\\n        tree: Ref<TreeNode>,\\n    ) -> (Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>) {\\n        (\\n            if tree.left.is_some() {\\n                Some(Rc::clone(tree.left.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n            if tree.right.is_some() {\\n                Some(Rc::clone(tree.right.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n        )\\n    }\\n}\\n```\\n\\nAnd for reference, much simplifier solutions.\\n\\n**Recursion**\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        Solution::compare(&p, &q)\\n    }\\n    \\n    fn compare(p: &Option<Rc<RefCell<TreeNode>>>, q: &Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                let (p, q) = (p.borrow(), q.borrow());\\n                p.val == q.val\\n                    && Solution::compare(&p.left, &q.left)\\n                    && Solution::compare(&p.right, &q.right)\\n            }\\n            (None, None) => true,\\n            _ => false,\\n        }\\n    }\\n}\\n```\\n\\n**Native**\\n\\nRust can compare by itself the structs because of `derive(PartialEq)`. Not very interesting for learning purpose but quite handy in real life situations. :)\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::Ref;\\nuse std::cell::RefCell;\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut deque: VecDeque<(Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>)> =\\n            VecDeque::new();\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                deque.push_back((Some(Rc::clone(&p)), Some(Rc::clone(&q))));\\n            }\\n            (None, None) => return true,\\n            _ => return false,\\n        }\\n        while !deque.is_empty() {\\n            let (p, q) = deque.pop_front().unwrap();\\n            if !match (&p, &q) {\\n                (Some(p), Some(q)) => p.borrow().val == q.borrow().val,\\n                (None, None) => true,\\n                _ => false,\\n            } {\\n                return false;\\n            }\\n            if let (Some(p), Some(q)) = (p, q) {\\n                let (p, q) = (\\n                    Solution::clone_nodes(p.borrow()),\\n                    Solution::clone_nodes(q.borrow()),\\n                );\\n                deque.push_back((p.0, q.0));\\n                deque.push_back((p.1, q.1));\\n            }\\n        }\\n        true\\n    }\\n    \\n    fn clone_nodes(\\n        tree: Ref<TreeNode>,\\n    ) -> (Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>) {\\n        (\\n            if tree.left.is_some() {\\n                Some(Rc::clone(tree.left.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n            if tree.right.is_some() {\\n                Some(Rc::clone(tree.right.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n        )\\n    }\\n}\\n```\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        Solution::compare(&p, &q)\\n    }\\n    \\n    fn compare(p: &Option<Rc<RefCell<TreeNode>>>, q: &Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                let (p, q) = (p.borrow(), q.borrow());\\n                p.val == q.val\\n                    && Solution::compare(&p.left, &q.left)\\n                    && Solution::compare(&p.right, &q.right)\\n            }\\n            (None, None) => true,\\n            _ => false,\\n        }\\n    }\\n}\\n```\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32915,
                "title": "0ms-simple-java-solution",
                "content": "public class Solution {\\n    \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) {\\n            return true;\\n        }\\n        \\n        if(p==null || q==null) {\\n            return false;\\n        }\\n        \\n        if(p.val == q.val) {\\n            boolean left = isSameTree(p.left, q.left);\\n            boolean right = isSameTree(p.right, q.right);\\n            return (left & right);\\n        }\\n\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 33034,
                "title": "my-one-line-recursive-solutions-in-3-languages",
                "content": "I use syntactic sugar to combine stop condition and recursive call together.\\n\\nJava:\\n\\n    return (p == null || q == null) ? p == q : p.val == q.val && this.isSameTree(p.left, q.left) && this.isSameTree(p.right, q.right);\\n\\nC++:\\n\\n    return (p == NULL || q == NULL) ? p == q : p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\nPython:\\n\\n    return p == q if p is None or q is None else p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "I use syntactic sugar to combine stop condition and recursive call together.\\n\\nJava:\\n\\n    return (p == null || q == null) ? p == q : p.val == q.val && this.isSameTree(p.left, q.left) && this.isSameTree(p.right, q.right);\\n\\nC++:\\n\\n    return (p == NULL || q == NULL) ? p == q : p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\nPython:\\n\\n    return p == q if p is None or q is None else p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "codeTag": "Unknown"
            },
            {
                "id": 3483205,
                "title": "easy-bfs",
                "content": "1. The algorithm will look as follows:\\n\\n1. We create a queue, in which we add the root nodes of both trees.\\n\\n1. As long as the queue is not empty, retrieve an element from the beginning of the queue:\\n\\n1. If the elements are null, then move on to the next element in the queue.\\n\\n1. If the node values are not equal, the trees are not identical.\\n\\n1. If the node values are equal, then add the left and right children for both nodes to the queue.\\n\\n1. If all nodes pass the check, then the trees are identical.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(p);\\n        queue.offer(q);\\n\\n        while(!queue.isEmpty()) {\\n            TreeNode node1 = queue.poll();\\n            TreeNode node2 = queue.poll();\\n\\n            if (node1 == null && node2 == null) {\\n                continue;\\n            }\\n\\n            if (node1 == null || node2 == null) {\\n                return false;\\n            }\\n\\n            if (node1.val != node2.val) {\\n                return false;\\n            }\\n\\n            queue.offer(node1.left);\\n            queue.offer(node2.left);\\n            queue.offer(node1.right);\\n            queue.offer(node2.right);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(p);\\n        queue.offer(q);\\n\\n        while(!queue.isEmpty()) {\\n            TreeNode node1 = queue.poll();\\n            TreeNode node2 = queue.poll();\\n\\n            if (node1 == null && node2 == null) {\\n                continue;\\n            }\\n\\n            if (node1 == null || node2 == null) {\\n                return false;\\n            }\\n\\n            if (node1.val != node2.val) {\\n                return false;\\n            }\\n\\n            queue.offer(node1.left);\\n            queue.offer(node2.left);\\n            queue.offer(node1.right);\\n            queue.offer(node2.right);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030595,
                "title": "python-iterative-solution-visual-explanation",
                "content": "Here is the visual explanation for the iterative version.\\nI\\'m waiting for your comments\\uD83D\\uDCA1\\nThanks for your Upvote\\uD83D\\uDE4F\\n\\nSample 1:\\n![leet code (2).png](https://assets.leetcode.com/users/images/026ba740-aa53-469a-ae64-0b4afd374a30_1673365031.5457146.png)\\n\\n___\\nSample 2:\\n![leet code (1).png](https://assets.leetcode.com/users/images/604e96a3-5e42-455c-8793-dc5ee57da7fc_1673358122.7690244.png)\\n\\n\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [(p, q)]\\n\\n        while stack:\\n            u, v = stack.pop()\\n            if not u and not v:\\n                continue\\n            if not u or not v:\\n                return False\\n            if u.val != v.val:\\n                return False\\n            \\n            stack.append((u.right, v.right))\\n            stack.append((u.left, v.left))\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [(p, q)]\\n\\n        while stack:\\n            u, v = stack.pop()\\n            if not u and not v:\\n                continue\\n            if not u or not v:\\n                return False\\n            if u.val != v.val:\\n                return False\\n            \\n            stack.append((u.right, v.right))\\n            stack.append((u.left, v.left))\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028026,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        bool left = isSameTree(p->left,q->left);//check for left\\n        bool right = isSameTree(p->right,q->right);//check for right\\n        bool value = p->val == q->val;//check the value\\n        if(left && right && value)//if all are true\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        bool left = isSameTree(p->left,q->left);//check for left\\n        bool right = isSameTree(p->right,q->right);//check for right\\n        bool value = p->val == q->val;//check the value\\n        if(left && right && value)//if all are true\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249745,
                "title": "python-dfs-recursion-time-o-n-space-o-n",
                "content": "# Explaination:\\nWe are given two trees and we need to find out if they are the same tree. Meaning they have the same height, same node values in the same places, and same structure.\\n\\nWe will be traversing through both trees at the same exact time and in the same way. Meaning we will check the left side of both trees first to see if they match and then the right side. As we go down the tree we will compare the current node we are at for both trees and see if they have matching values, if at any point they do not match, we return `False`. \\nIf everything matches and we reach `None` when checking the leaf nodes children, if both trees match and they both reach the leaf node and reach the `None` at the same time, we return `True`\\n\\n**Solution Breakdown:**\\n1. We check if either trees `p` or `q` are `None`, if either of them or both of them are, then we return `p == q` to check if they are both `None`, if they are it will return `True` meaning they match, if only one is `None`, we return `False` and say the trees don\\'t match.\\n2. Each time we visit a node we compare the node we are currently visiting on both trees and return `False` if they don\\'t match.\\n3. If they match we check the left and then the right of both trees.\\n4. Then we return `left == right` which means, if all the nodes on the left side for both trees match and all the nodes on the right side for both trees match, we return `True`, if we got `False` on either side of the traversals, we return `False`.\\n\\n**Time O(N) | Space O(N):**\\nTime is O(N) since we need to traverse through all the nodes of both trees, since we are doing it at the same time for both its O(N), since in the worst case both trees match and we visited all nodes to confirm they matched.\\nSpace is O(N) due to the recursive stack and in the worst case we can have an unbalanced tree which will look like a linked list.\\n\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p or not q:\\n            return p == q\\n        if p.val != q.val:\\n            return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        \\n        return left and right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p or not q:\\n            return p == q\\n        if p.val != q.val:\\n            return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        \\n        return left and right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536269,
                "title": "c-0ms-faster-than-100-1-line-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n    \\n        return (!p || !q) ? p==q : (p->val != q->val) ? false : isSameTree(p->left,q->left) && isSameTree(p->right , q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n    \\n        return (!p || !q) ? p==q : (p->val != q->val) ? false : isSameTree(p->left,q->left) && isSameTree(p->right , q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733770,
                "title": "c-easy-to-understand-with-explanation",
                "content": "### Approach 1 - DFS\\nWe have to perform DFS on both the trees simultaneously and at any point if the value is not same we can return false\\n1. If p or q is null - IF both are null return true otherwise return false\\n2. Both are non-null so if p->val != q->val, return false\\n3. perform DFS on left and right children and return true only if both are true otherwise return false (left && right);\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q; \\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```\\n\\n### Approach 2 - BFS (level order traversal)\\nWe will use a queue for this purpose\\n1. Check if the initial p and q are valid. If not return false.\\n2. insert them in the queue - qu (pair - {p,q})\\n3. while qu is not empty (qu is empty - last level)\\n4. store the current size of q in sz - the elements we have to check in current level\\n5. Perform the checks if both are valid. If not return false.\\n6. If both are valid insert their left and right children as pair in the queue\\n7. Perform the same operation using loop for the level then we go to next level and so on\\n8. If the entire tree is valid the loop ends and return true;\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q;\\n        if(p->val != q->val) return false;\\n        queue<pair<TreeNode*,TreeNode*>> qu;\\n        qu.push({p,q});\\n        while(!qu.empty()){\\n            int sz = qu.size();\\n            while(sz--){\\n                auto pu = qu.front();qu.pop();           \\n                if((!pu.first || !pu.second) && (pu.first != pu.second))  return false;\\n                if(!pu.first && !pu.second) continue;\\n                if(pu.first->val != pu.second->val) return false;\\n                qu.push({pu.first->left,pu.second->left});\\n                qu.push({pu.first->right,pu.second->right});\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q; \\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q;\\n        if(p->val != q->val) return false;\\n        queue<pair<TreeNode*,TreeNode*>> qu;\\n        qu.push({p,q});\\n        while(!qu.empty()){\\n            int sz = qu.size();\\n            while(sz--){\\n                auto pu = qu.front();qu.pop();           \\n                if((!pu.first || !pu.second) && (pu.first != pu.second))  return false;\\n                if(!pu.first && !pu.second) continue;\\n                if(pu.first->val != pu.second->val) return false;\\n                qu.push({pu.first->left,pu.second->left});\\n                qu.push({pu.first->right,pu.second->right});\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32784,
                "title": "c-non-recursive-o-1-space-based-on-morris-traversal",
                "content": "Not a fan of recursive. Stack space is also space, otherwise we wouldn't have the \"STACKOVERFLOW\".\\n```\\nclass Solution {\\npublic:\\n    int m(TreeNode *&h) {\\n        int v = 0;\\n        if (h) {\\n            v = h->val;\\n            if (TreeNode *p = h->left) {\\n                while (p->right && p->right != h) p = p->right;\\n                if (p->right) {\\n                    h = h->right;\\n                    p->right = NULL;\\n                } else {\\n                    p->right = h;\\n                    h = h->left;\\n                }\\n            } else {\\n                h = h->right;\\n            }\\n        }\\n        return v;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        bool o = true;\\n        while (p || q) {\\n            if (!(p&&q)) o = false;\\n            if (m(p) != m(q)) o = false;\\n        }\\n        return o;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m(TreeNode *&h) {\\n        int v = 0;\\n        if (h) {\\n            v = h->val;\\n            if (TreeNode *p = h->left) {\\n                while (p->right && p->right != h) p = p->right;\\n                if (p->right) {\\n                    h = h->right;\\n                    p->right = NULL;\\n                } else {\\n                    p->right = h;\\n                    h = h->left;\\n                }\\n            } else {\\n                h = h->right;\\n            }\\n        }\\n        return v;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        bool o = true;\\n        while (p || q) {\\n            if (!(p&&q)) o = false;\\n            if (m(p) != m(q)) o = false;\\n        }\\n        return o;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32947,
                "title": "two-line-java-code",
                "content": "    public class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; \\n        return p!=null && q!= null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; \\n        return p!=null && q!= null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3672457,
                "title": "easy-approach-2-lines-inorder-traversal-beats-100",
                "content": "# Intuition \\uD83D\\uDCA1\\nTo determine if two binary trees are the same, we can compare their nodes recursively. If the current nodes have the same value and the left and right subtrees are also the same, then the trees are considered the same.\\n\\n# Approach \\uD83D\\uDD0D\\nHere is the step-by-step approach to solve the problem:\\n\\n1. Write a recursive function `isSameTree` that takes two parameters, `p` and `q`, representing the root nodes of the two binary trees.\\n2. Check if either `p` or `q` is null. If one is null and the other is not, return false since they cannot be the same.\\n3. Check if the values of the current nodes, `p.val` and `q.val`, are equal.\\n4. Recursively call the `isSameTree` function on the left subtrees, `p.left` and `q.left`.\\n5. Recursively call the `isSameTree` function on the right subtrees, `p.right` and `q.right`.\\n6. Return the logical AND of all the conditions checked above.\\n\\n> Feel free to post your doubts in the commen section :) \\n# Code \\nThe Java code implementing the above approach is as follows:\\n\\n```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        if (p == null || q == null) { return p == q;}\\n        \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); \\n    }\\n}```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        if (p == null || q == null) { return p == q;}\\n        \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3532284,
                "title": "c-dfs-beats-92-100",
                "content": "# Intuition\\nTraversing branches by recursion\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == nullptr && q == nullptr) return true;\\n        else if (p == nullptr || q == nullptr) return false;\\n        else if (p -> val != q -> val) return false;\\n        else {\\n            bool res_right = isSameTree(p -> right, q -> right);\\n            bool res_left = isSameTree(p -> left, q -> left);\\n            return (res_right && res_left);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == nullptr && q == nullptr) return true;\\n        else if (p == nullptr || q == nullptr) return false;\\n        else if (p -> val != q -> val) return false;\\n        else {\\n            bool res_right = isSameTree(p -> right, q -> right);\\n            bool res_left = isSameTree(p -> left, q -> left);\\n            return (res_right && res_left);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029302,
                "title": "clear-and-concise-recursive-solution",
                "content": "Sorry for the lambda syntax, but I could not resist using it:\\n```csharp\\npublic class Solution\\n{\\n    public bool IsSameTree(TreeNode p, TreeNode q) =>\\n        p is null || q is null\\n        ? p is null && q is null\\n        : p.val == q.val && IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public bool IsSameTree(TreeNode p, TreeNode q) =>\\n        p is null || q is null\\n        ? p is null && q is null\\n        : p.val == q.val && IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028873,
                "title": "simple-recursive-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nto check if the two trees are same we need to make sure that value at each node is same.That is we can check each node at a time via recursion\\n\\n# Approach\\n   passing each node recursively and if their value are not same i return false, i fthey are same we pass one call to check the left subtree and then another call to check the same for right subtree and return true if both left and right are true.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nlet the height of the tree be h=log(n) (approximately)\\nso the time copmplexity of the above code is O(2^h) since at each level we have two options put h=log(n) we get the time complexity to be O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nhere the space complexity is O(h) that is O(log(n)) and this space is due to the recursive stack space in the compiler if we do not consider the recurasive stack space then space complexity is O(1).\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* t1, TreeNode* t2) {\\n         if(t1==NULL){\\n            if(t2!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t2==NULL){\\n            if(t1!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t1->val!=t2->val){\\n            return false;\\n        }\\n        bool left=isSameTree(t1->left,t2->left);\\n        bool right=isSameTree(t1->right,t2->right);\\n        return left && right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* t1, TreeNode* t2) {\\n         if(t1==NULL){\\n            if(t2!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t2==NULL){\\n            if(t1!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t1->val!=t2->val){\\n            return false;\\n        }\\n        bool left=isSameTree(t1->left,t2->left);\\n        bool right=isSameTree(t1->right,t2->right);\\n        return left && right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028868,
                "title": "c-solution-100-faster-simple-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n__The Idea is to match all the nodes of one tree with the other one, and whenever there is no match possible, return false__\\n\\n# Approach\\n__The idea her is to recursive map nodes of one tree with the nodes of the other tree__\\n\\n>__Check if the nodes reach null together (base case),__ \\n  If yes, return true\\n  Else, execute other statements \\n\\n>__Check if only either of the nodes reach an end point__\\n If yes, Return false\\n Else, execute other statements\\n\\n>__If the nodes are not the end points, check if the values they are storing are same or not?__\\nIf different, return false\\nElse, continue with the code\\n\\n>Recursive structure: \\n__[match the left subtree of the current node with the left subtree of the other current node]__\\n__&&  (logical operator)__\\n__[match the right subtree of the current node with the right subtree of the other current node]__\\n\\n# Complexity\\n- Time complexity:\\nO(N) :- N => Number of nodes in the tree\\n\\n- Space complexity:\\nO(1), ignoring the recursive stack, otherwise the space = O(N)\\n\\n# Code\\n```\\nclass Solution //100% faster, 95.24% better space\\n{\\npublic:\\n    bool chc(TreeNode *p, TreeNode *q)\\n    {\\n        if (p == NULL && q == NULL) // If the node reach an endpoint together, say true\\n            return true;\\n        if (p == NULL && q != NULL || q == NULL && p != NULL) // If only either of the nodes reach an end point, say false\\n            return false;\\n        if (p->val != q->val) // If none of the nodes are at the end points but there values differ, say false\\n            return false;\\n        return (chc(p->left, q->left) && chc(p->right, q->right));   \\n        // && is used instead of & as it short circuits the condition\\n        // i.e. it stops checking the conditions when a false is received (in the case of &&)\\n        // and in the case of ||, it stops checking when a true value is received\\n    }\\n    bool isSameTree(TreeNode *p, TreeNode *q)\\n    {\\n        return chc(p, q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution //100% faster, 95.24% better space\\n{\\npublic:\\n    bool chc(TreeNode *p, TreeNode *q)\\n    {\\n        if (p == NULL && q == NULL) // If the node reach an endpoint together, say true\\n            return true;\\n        if (p == NULL && q != NULL || q == NULL && p != NULL) // If only either of the nodes reach an end point, say false\\n            return false;\\n        if (p->val != q->val) // If none of the nodes are at the end points but there values differ, say false\\n            return false;\\n        return (chc(p->left, q->left) && chc(p->right, q->right));   \\n        // && is used instead of & as it short circuits the condition\\n        // i.e. it stops checking the conditions when a false is received (in the case of &&)\\n        // and in the case of ||, it stops checking when a true value is received\\n    }\\n    bool isSameTree(TreeNode *p, TreeNode *q)\\n    {\\n        return chc(p, q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027524,
                "title": "java-solution-with-explanation-beat-100",
                "content": "# Intuition\\nIf tree is same it must have nodes with same value at same place\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are using recursion to solve this problem \\n1)if p is null and q is null then it\\'s same we will return true\\n2)if any of p or q is null then we will return false\\n3) if value of p and q is not same then it\\'s not same tree so we will return false\\nNow check for above cases for left subtree and right subtree and if we get false we will return false otherwise the trees are same\\n\\n# Complexity\\n- Time complexity:\\nO(min(N, M)), Where N and M are the sizes of the trees\\n\\n- Space complexity:\\n O(log min(N, M)), due to auxiliary stack space used by recursion calls\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null){\\n            return true;\\n        }\\n        if(p==null || q==null || p.val!=q.val){\\n            return false;\\n        }\\n\\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n\\n    }\\n}\\n```\\n\\nI hope you guys understand the solution,Keep coding.\\n\\nJai Shree Krishna\\u2764\\uFE0F\\uD83D\\uDE4F....",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null){\\n            return true;\\n        }\\n        if(p==null || q==null || p.val!=q.val){\\n            return false;\\n        }\\n\\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027419,
                "title": "c-2-different-approaches-recursive-one-liner-iterative",
                "content": "# Approach 1: recursive\\n\\nIt\\'s a long one-liner though:\\n\\n```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        return p && q ? p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : p == q;\\n    }\\n```\\n\\nclang-formatted and with comments:\\n\\n```cpp\\n  return\\n      // If both pointers are valid ...\\n      p && q ?\\n             // ... then the values need to be the same, and ...\\n             p->val == q->val &&\\n             // ... both subtrees need to be the same.\\n             isSameTree(p->left, q->left) && isSameTree(p->right, q->right)\\n             // If at least one of the pointers was a nullptr, both need to be\\n             // nullptr, i.e. equal.\\n             : p == q;\\n```\\n\\nSimilar idea, slightly different implementation:\\n\\n```cpp\\n    return p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) || !p && !q;\\n```\\n\\nA slightly more readable version could look like this:\\n\\n```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        // If one of the pointers is a nullptr, then both need to be a nullptr.\\n        if (!p || !q) return !p && !q;\\n        \\n        return\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right);\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the number of nodes in the tree and $$h$$ the height, which can vary from $$\\\\log n$$ to $$n$$ then the\\n  * Time complexity is $$O(n)$$ we need to visit all the nodes and the\\n  * Space complexity is $$O(h)$$\\n\\n# Approach 2: iterative\\nThe benefit of the iterative approach could be that we have better control and catch situtations if the input isn\\'t a actually a tree and contains a loop.\\n\\n```cpp\\npublic:\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) {\\n        stack<pair<const TreeNode*, const TreeNode*>> st;\\n        st.push({p, q});\\n        while (!empty(st)) {\\n            auto [r, s] = st.top(); st.pop();\\n            if (r && s) {\\n                if (r->val != s->val) return false;\\n                st.push({r->left, s->left});\\n                st.push({r->right, s->right});\\n            } else if (!r != !s) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\n**Complexity Analysis**\\nIs the same as for the recursive version.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        return p && q ? p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : p == q;\\n    }\\n```\n```cpp\\n  return\\n      // If both pointers are valid ...\\n      p && q ?\\n             // ... then the values need to be the same, and ...\\n             p->val == q->val &&\\n             // ... both subtrees need to be the same.\\n             isSameTree(p->left, q->left) && isSameTree(p->right, q->right)\\n             // If at least one of the pointers was a nullptr, both need to be\\n             // nullptr, i.e. equal.\\n             : p == q;\\n```\n```cpp\\n    return p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) || !p && !q;\\n```\n```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        // If one of the pointers is a nullptr, then both need to be a nullptr.\\n        if (!p || !q) return !p && !q;\\n        \\n        return\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right);\\n    }\\n```\n```cpp\\npublic:\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) {\\n        stack<pair<const TreeNode*, const TreeNode*>> st;\\n        st.push({p, q});\\n        while (!empty(st)) {\\n            auto [r, s] = st.top(); st.pop();\\n            if (r && s) {\\n                if (r->val != s->val) return false;\\n                st.push({r->left, s->left});\\n                st.push({r->right, s->right});\\n            } else if (!r != !s) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027357,
                "title": "explained-recursive-solution-o-n",
                "content": "#### Approach\\n\\nThe simplest strategy here is to use recursion. Check if p and q nodes are not None, and their values are equal. If all checks are OK, do the same for the child nodes recursively.\\n\\n#### Complexity Analysis\\n\\n**Time complexity** : O(n), where n is a number of nodes in the tree, since one visits each node exactly once.\\n\\n**Space complexity** : O(n) in the worst case of completely unbalanced tree, to keep a recursion stack.\\n\\n```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857536,
                "title": "0ms-solution-recursion-java",
                "content": "```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p==null && q==null)\\n         return true;\\n        if(p==null || q==null)\\n          return false;\\n        if(p.val==q.val)\\n        {\\n            return isSameTree(p.left,q.left) &&isSameTree(p.right,q.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\n```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p==null && q==null)\\n         return true;\\n        if(p==null || q==null)\\n          return false;\\n        if(p.val==q.val)\\n        {\\n            return isSameTree(p.left,q.left) &&isSameTree(p.right,q.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780859,
                "title": "c-0-ms-faster-than-100-recursive-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf root of p and q is same, then check again for the root of left subtree of p and q. Again repeat the same process until you reach NULL.\\nRepeat this process for the right subtrees also.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We are following a bottom to top approach where we go to the bottom of the tree and then come to top and keep checking whether p and q are same or not. If at any point, they are not same, return false, otherwise keep returning true.\\n- Also if p and q both are NULL at the same time, then it will return true because it implies that both are equal.\\nBut if either p is null or q is null (but not both at the same time), then it implies that they are not equal and we return false.\\n- Also note that at any point of time, if the actual value of p and q are not equal, then also we have to return false. Here, we cannot write `p!=q`. Instead, we have to write `p->val != q->val` because we have to compare the values of p and q, but `p!=q` will compare the pointers, which can obviously never be equal because both p and q are present at different memory locations, although the value present inside both of them maybe same.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nBecause we traverse each node only once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Auxiliary $$O(n)$$\\nBecause in the worst case i.e. for a skew tree, the maximum stack space required will be equal to total number of nodes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL){\\n            return true;\\n        }\\n        if(p == NULL || q == NULL){\\n            return false;\\n        }\\n        if(p->val!=q->val){\\n            return false;\\n        }\\n        bool l = isSameTree(p->left,q->left);    //left subtrees\\n        bool r = isSameTree(p->right,q->right);  //right subtrees\\n        return l&&r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL){\\n            return true;\\n        }\\n        if(p == NULL || q == NULL){\\n            return false;\\n        }\\n        if(p->val!=q->val){\\n            return false;\\n        }\\n        bool l = isSameTree(p->left,q->left);    //left subtrees\\n        bool r = isSameTree(p->right,q->right);  //right subtrees\\n        return l&&r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365177,
                "title": "c-solution-using-recursion-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        else if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        else if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        else if(p->val != q->val)\\n        {\\n            return false;\\n        }\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        else if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        else if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        else if(p->val != q->val)\\n        {\\n            return false;\\n        }\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936835,
                "title": "js-simple-explained-recursive-pre-order",
                "content": "# 100. Same Tree \\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n<!-- ### Index:\\n1. [Explaining the Question](#explaining-the-question)\\n2. [Recommended Knowledge](#what-do-we-know)\\n3. [What do we know](#recommended-knowledge)\\n4. [Solution Explanation](#how-were-going-to-do-it)\\n5. [Big *O* Notation](#big-o-notation)\\n6. [Leetcode Results](#leetcode-results)\\n7. [Solution](#the-solution) -->\\n\\n## Explaining The Question\\nThe question explains itself pretty well here. All we need to do is to go to each node in both trees at the same time and ensure they\\'re the same exact node as each other. \\n\\n##  Recommended Knowledge\\n1. Binary Trees\\n2. Depth First Search (Recursive)\\n3. Javascript Stack (Bubbles up in DFS)\\n4. Recursion\\n\\n## What do we know?\\n1. That we have 2 trees and we need to check that they\\'re the same\\n2. The max number of nodes a tree can have is 100.\\n\\n## How we\\'re going to do it:\\n1. We\\'re going to do this recursively. Meaning, that at each node in the both trees, we\\'re going to be visiting at one point. We do this by recalling the ***isSameTree*** function with the left or right pointers\\n2.  We\\'re going to go to each node in both trees at the same time. That is to say, in tree 1, when we go left, we also go left in tree 2. Until we reach the very end of that right tree. We will also do this with the right tree too.\\n3.  Each time we visit a new node, we will make a check, are both nodes empty? In this case, both trees are empty and are at the end and thus correct.\\n4. Are any of the pointers null that aren\\'t supposed to be? Meaning the mirror node isn\\'t null? In this case, it\\'s a invalid tree.\\n5. We then check the values. Are they not the same? Then it\\'s a invalid tree\\n6. Repeat this until all nodes are exhausted, comparing that both the left and right trees are valid.\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is equal to the number of nodes in both trees. | We visit every node in worst case\\n* Space Complexity: *O(**h**)* | Where ***h*** is the height of the tallest tree. This is within the Call Stack | In the worst case, a tree\\'s number of nodes is it\\'s height. \\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 64 ms, faster than ***84.15%*** of JavaScript online submissions for Same Tree.\\n* Memory Usage: 42.3 MB, less than ***58.35%*** of JavaScript online submissions for Same Tree.\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/678388505/)\\n\\n\\n***\\n\\n# The Solution\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n * this.val   = (val===undefined ? 0 : val)\\n * this.left  = (left===undefined ? null : left)\\n * this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function (p, q) {\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               100. Same Tree                               */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/**\\n\\t * @author  Samuel Hinchliffe\\n\\t * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n\\t * @see    {@link github.com/Samuel-Hinchliffe}\\n\\t */\\n\\n\\t// What do we know:\\n\\t// 1 - That we have 2 trees and we need to check that they\\'re the same\\n\\t// 2 - The max number of nodes a tree can have is 100.\\n\\n\\t// What do you need to know to understand?\\n\\t// 1 - Binary Trees\\n\\t// 2 - Depth First Search (Recursive)\\n\\t// 3 - Javascript Stack (Bubbles up in DFS)\\n\\t// 4 - Recursion\\n\\n\\t// How we\\'re going to do it:\\n\\t// 1 - We\\'re going to do this recursively. Meaning, that at each node\\n\\t//   - in the both trees, we\\'re going to be visiting at one point.\\n\\t//   - we do this by recalling the isSameTree function with the left or right pointers\\n\\t// 2 - We\\'re going to go to each node in both trees at the same time.\\n\\t//   - That is to say, in tree 1, when we go left, we also go left in tree 2.\\n\\t//   - Until we reach the very end of that right tree.\\n\\t//   - We will also do this with the right tree too.\\n\\t// 3 - Each time we visit a new node, we will make a check, are both nodes empty?\\n\\t//   - in this case, both trees are empty and are at the end and thus correct.\\n\\t// 4 - Are any of the pointers null that aren\\'t supposed to be?\\n\\t//   -  meaning the mirror node isn\\'t null? In this case, it\\'s a invalid tree.\\n\\t// 5 - We then check the values. Are they not the same? Then it\\'s a invalid tree\\n\\t// 6 - Repeat this until all nodes are exhausted, comparing that both the left and right\\n\\t//   - trees are valid.\\n\\n\\t// Big O Notation:\\n\\t// Time Complexity:  O(n) | Where n is equal to the number of nodes in both trees.\\n\\t// Space Complexity: O(h) | Where h is the height of the tallest tree. This is within the Call Stack\\n\\n\\t// Leetcode Results:\\n\\t// Runtime: 64 ms, faster than 84.15% of JavaScript online submissions for Same Tree.\\n\\t// Memory Usage: 42.3 MB, less than 58.35% of JavaScript online submissions for Same Tree.\\n\\t// https://leetcode.com/submissions/detail/678388505/\\n\\n\\t/* ----------------------------- Solution Below ----------------------------- */\\n\\n\\t// So both our trees current node is null\\n\\t// This mean\\'s they both reached the end of the tree\\n\\t// at the same time without error\\n\\tif (p == null && q == null) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// One of the pointers are null when another is not\\n\\t// This mean\\'s one of our pointers has traversed to a correct node\\n\\t// but another has reached the end of the list too early and thus\\n\\t// cannot be a valid mirror tree\\n\\tif ((p == null && q != null) || (q == null && p != null)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// As we have moved nodes\\n\\t// Are they the same value?\\n\\tif (p.val != q.val) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// Get both left nodes\\n\\t// We will traverse the left nodes in a DFS fashion\\n\\t// to be able to compare both left nodes at the same time\\n\\t// So we move left at the same time on both trees.\\n\\tlet good_lefts = isSameTree(p.left, q.left);\\n\\n\\t// Get both right nodes\\n\\t// We will traverse the right nodes in a DFS fashion\\n\\t// to be able to compare both right nodes at the same time\\n\\t// So we move right at the same time on both trees.\\n\\tlet good_rights = isSameTree(p.right, q.right);\\n\\n\\t// So are both sides good?\\n\\treturn good_lefts && good_rights;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n * this.val   = (val===undefined ? 0 : val)\\n * this.left  = (left===undefined ? null : left)\\n * this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function (p, q) {\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               100. Same Tree                               */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/**\\n\\t * @author  Samuel Hinchliffe\\n\\t * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n\\t * @see    {@link github.com/Samuel-Hinchliffe}\\n\\t */\\n\\n\\t// What do we know:\\n\\t// 1 - That we have 2 trees and we need to check that they\\'re the same\\n\\t// 2 - The max number of nodes a tree can have is 100.\\n\\n\\t// What do you need to know to understand?\\n\\t// 1 - Binary Trees\\n\\t// 2 - Depth First Search (Recursive)\\n\\t// 3 - Javascript Stack (Bubbles up in DFS)\\n\\t// 4 - Recursion\\n\\n\\t// How we\\'re going to do it:\\n\\t// 1 - We\\'re going to do this recursively. Meaning, that at each node\\n\\t//   - in the both trees, we\\'re going to be visiting at one point.\\n\\t//   - we do this by recalling the isSameTree function with the left or right pointers\\n\\t// 2 - We\\'re going to go to each node in both trees at the same time.\\n\\t//   - That is to say, in tree 1, when we go left, we also go left in tree 2.\\n\\t//   - Until we reach the very end of that right tree.\\n\\t//   - We will also do this with the right tree too.\\n\\t// 3 - Each time we visit a new node, we will make a check, are both nodes empty?\\n\\t//   - in this case, both trees are empty and are at the end and thus correct.\\n\\t// 4 - Are any of the pointers null that aren\\'t supposed to be?\\n\\t//   -  meaning the mirror node isn\\'t null? In this case, it\\'s a invalid tree.\\n\\t// 5 - We then check the values. Are they not the same? Then it\\'s a invalid tree\\n\\t// 6 - Repeat this until all nodes are exhausted, comparing that both the left and right\\n\\t//   - trees are valid.\\n\\n\\t// Big O Notation:\\n\\t// Time Complexity:  O(n) | Where n is equal to the number of nodes in both trees.\\n\\t// Space Complexity: O(h) | Where h is the height of the tallest tree. This is within the Call Stack\\n\\n\\t// Leetcode Results:\\n\\t// Runtime: 64 ms, faster than 84.15% of JavaScript online submissions for Same Tree.\\n\\t// Memory Usage: 42.3 MB, less than 58.35% of JavaScript online submissions for Same Tree.\\n\\t// https://leetcode.com/submissions/detail/678388505/\\n\\n\\t/* ----------------------------- Solution Below ----------------------------- */\\n\\n\\t// So both our trees current node is null\\n\\t// This mean\\'s they both reached the end of the tree\\n\\t// at the same time without error\\n\\tif (p == null && q == null) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// One of the pointers are null when another is not\\n\\t// This mean\\'s one of our pointers has traversed to a correct node\\n\\t// but another has reached the end of the list too early and thus\\n\\t// cannot be a valid mirror tree\\n\\tif ((p == null && q != null) || (q == null && p != null)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// As we have moved nodes\\n\\t// Are they the same value?\\n\\tif (p.val != q.val) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// Get both left nodes\\n\\t// We will traverse the left nodes in a DFS fashion\\n\\t// to be able to compare both left nodes at the same time\\n\\t// So we move left at the same time on both trees.\\n\\tlet good_lefts = isSameTree(p.left, q.left);\\n\\n\\t// Get both right nodes\\n\\t// We will traverse the right nodes in a DFS fashion\\n\\t// to be able to compare both right nodes at the same time\\n\\t// So we move right at the same time on both trees.\\n\\tlet good_rights = isSameTree(p.right, q.right);\\n\\n\\t// So are both sides good?\\n\\treturn good_lefts && good_rights;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338775,
                "title": "faster-than-100-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL){\\n            return true;\\n        }\\n        else if(p==NULL || q==NULL){\\n            return false;\\n        }\\n        else{\\n            bool c1= p->val == q->val;\\n            bool c2=isSameTree(p->left,q->left);\\n            bool c3=isSameTree(p->right,q->right);\\n            \\n            if(c1 && c2 && c3){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL){\\n            return true;\\n        }\\n        else if(p==NULL || q==NULL){\\n            return false;\\n        }\\n        else{\\n            bool c1= p->val == q->val;\\n            bool c2=isSameTree(p->left,q->left);\\n            bool c3=isSameTree(p->right,q->right);\\n            \\n            if(c1 && c2 && c3){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734211,
                "title": "python-3-5-lines-recursive-solution",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is not None: return False\\n        if q is None and p is not None: return False\\n        if p is None and q is None: return True\\n        if p.val != q.val: return False\\n        \\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```\\n\\nUPD: In 4 lines\\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p and not q: return True\\n        if not p or not q: return False\\n        if p.val != q.val: return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is not None: return False\\n        if q is None and p is not None: return False\\n        if p is None and q is None: return True\\n        if p.val != q.val: return False\\n        \\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p and not q: return True\\n        if not p or not q: return False\\n        if p.val != q.val: return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327852,
                "title": "golang-recursive-and-bfs-solutions",
                "content": "```\\n// t: O(n)\\n// s: O(height)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p == nil && q == nil {\\n        return true\\n    } else if p == nil || q == nil {\\n        return false\\n    }\\n    \\n    if p.Val != q.Val {\\n        return false\\n    } \\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```\\n\\n```\\n// t: O(n)\\n// s: O(n)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    qP := []*TreeNode{p}\\n    qQ := []*TreeNode{q}\\n    \\n    for len(qP) !=  0 && len(qQ) != 0 {\\n        pNode := qP[0]\\n        qP = qP[1:]\\n        \\n        qNode := qQ[0]\\n        qQ = qQ[1:]\\n        \\n        if pNode == nil && qNode == nil {\\n            continue\\n        }\\n        if pNode == nil && qNode != nil || pNode != nil && qNode == nil {\\n            return false\\n        }\\n        if pNode.Val != qNode.Val {\\n            return false\\n        }\\n        \\n        qP = append(qP, pNode.Left, pNode.Right)\\n        qQ = append(qQ, qNode.Left, qNode.Right)\\n    }\\n    \\n    if len(qP) == 0 && len(qQ) == 0 {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// t: O(n)\\n// s: O(height)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p == nil && q == nil {\\n        return true\\n    } else if p == nil || q == nil {\\n        return false\\n    }\\n    \\n    if p.Val != q.Val {\\n        return false\\n    } \\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```\n```\\n// t: O(n)\\n// s: O(n)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    qP := []*TreeNode{p}\\n    qQ := []*TreeNode{q}\\n    \\n    for len(qP) !=  0 && len(qQ) != 0 {\\n        pNode := qP[0]\\n        qP = qP[1:]\\n        \\n        qNode := qQ[0]\\n        qQ = qQ[1:]\\n        \\n        if pNode == nil && qNode == nil {\\n            continue\\n        }\\n        if pNode == nil && qNode != nil || pNode != nil && qNode == nil {\\n            return false\\n        }\\n        if pNode.Val != qNode.Val {\\n            return false\\n        }\\n        \\n        qP = append(qP, pNode.Left, pNode.Right)\\n        qQ = append(qQ, qNode.Left, qNode.Right)\\n    }\\n    \\n    if len(qP) == 0 && len(qQ) == 0 {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32683,
                "title": "java-intuitive-and-easy-to-understand-non-recursive-solutions-both-bfs-and-dfs-no-size-checking",
                "content": "Hi here are my non-recursive solutions. I think it is more intuitive as I only deal with properties of nodes pushed/polled and don't check queue/stack's status in the while loop.\\n\\nIn this question the iterative DFS and  iterative BFS are exactly the same thing. I think it is because we're doing the graph search, so it doesn't matter which sequence we are following to check nodes, as long as the checking for two trees are synchronized. \\n\\nIterative DFS:\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Stack<TreeNode> pstack = new Stack<>();\\n        Stack<TreeNode> qstack = new Stack<>();\\n        pstack.push(p);\\n        qstack.push(q);\\n        while(!pstack.isEmpty() && !qstack.isEmpty()){\\n            TreeNode t1 = pstack.pop();\\n            TreeNode t2 = qstack.pop();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            pstack.push(t1.left);\\n            pstack.push(t1.right);\\n            qstack.push(t2.left);\\n            qstack.push(t2.right);\\n        }\\n        if(pstack.isEmpty() && qstack.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```\\n\\n\\nIterative BFS:\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> q1 = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q1.offer(p);\\n        q2.offer(q);\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            TreeNode t1 = q1.poll();\\n            TreeNode t2 = q2.poll();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            q1.offer(t1.left);\\n            q1.offer(t1.right);\\n            q2.offer(t2.left);\\n            q2.offer(t2.right);\\n        }\\n        if(q1.isEmpty() && q2.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```\\n\\nThough I have to say that the time performance of these two iterative solutions are pretty bad... below 5%. \\n\\nidk if it is because how I wrote my for loop.. anyway this format seems to be more intuitive to me!\\n\\nHope it helps!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Stack<TreeNode> pstack = new Stack<>();\\n        Stack<TreeNode> qstack = new Stack<>();\\n        pstack.push(p);\\n        qstack.push(q);\\n        while(!pstack.isEmpty() && !qstack.isEmpty()){\\n            TreeNode t1 = pstack.pop();\\n            TreeNode t2 = qstack.pop();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            pstack.push(t1.left);\\n            pstack.push(t1.right);\\n            qstack.push(t2.left);\\n            qstack.push(t2.right);\\n        }\\n        if(pstack.isEmpty() && qstack.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> q1 = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q1.offer(p);\\n        q2.offer(q);\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            TreeNode t1 = q1.poll();\\n            TreeNode t2 = q2.poll();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            q1.offer(t1.left);\\n            q1.offer(t1.right);\\n            q2.offer(t2.left);\\n            q2.offer(t2.right);\\n        }\\n        if(q1.isEmpty() && q2.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32908,
                "title": "one-line-java-with-recursive",
                "content": "        return((p==null||q==null)?(p==q):(p.val==q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)));\\n\\nNot the fastest though...",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        return((p==null||q==null)?(p==q):(p.val==q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)));\\n\\nNot the fastest though...",
                "codeTag": "Unknown"
            },
            {
                "id": 4047543,
                "title": "python-3line-code-simple-approach",
                "content": "**Plz Upvote ..if you got help from this.**\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None or q is None:\\n            return p == q\\n        return (p.val== q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None or q is None:\\n            return p == q\\n        return (p.val== q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513811,
                "title": "python-easy-3-line-code",
                "content": "```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p==None or q==None:\\n            return p==q\\n        return (p.val==q.val) and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p==None or q==None:\\n            return p==q\\n        return (p.val==q.val) and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3484336,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        if (p->val != q->val) return false;\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right); \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        if (p->val != q->val) return false;\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right); \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430835,
                "title": "4-lines-of-code-100-faster-optimal",
                "content": "# Explantion\\n1. if both the nodes are null return *true*\\n2. one of the nodes are null return *false*\\n3. if values of both nodes are not same return *false*\\n4. call left and right child for both the nodes.\\n# Complexity\\n- Time complexity: O(n), where, n is the number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        if(p==NULL || q==NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        if(p==NULL || q==NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030035,
                "title": "beats-100-simple-c-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust check if current nodes data of both trees is same and check for left subtree and rightsubtree respectively by simply doing  recusrive calls for both\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL and q==NULL)return true;\\n        if(p==NULL or q==NULL)return false;\\n        return (p->val==q->val and isSameTree(p->left,q->left) and isSameTree(p->right,q->right) );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL and q==NULL)return true;\\n        if(p==NULL or q==NULL)return false;\\n        return (p->val==q->val and isSameTree(p->left,q->left) and isSameTree(p->right,q->right) );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029914,
                "title": "java-3-solutions-commented",
                "content": "# Please Upvote :D\\n---\\n##### 1. Preorder traversal + extra space:\\n\\n``` java []\\n// do any type of traversal on both the trees and store it in lists\\n// check if the lists are equal\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        List<Integer> pList = new ArrayList<>();\\n        List<Integer> qList = new ArrayList<>();\\n        dfs(p, pList); dfs(q, qList);\\n        return pList.equals(qList);\\n    }\\n\\n    void dfs(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            list.add(null);\\n            return;\\n        }\\n        list.add(root.val);\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n + h)\\n```\\n##### 2. Recursive approach (No extra space):\\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // either one of them is null or both of them is\\n        if (p == null || q == null) {\\n            return p == q;\\n        }\\n        // check if values are equal\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // call the functions for left and right subtrees\\n        boolean left = isSameTree(p.left, q.left);\\n        boolean right = isSameTree(p.right, q.right);\\n        return left && right;   // return what the subtrees return\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```\\n---\\n##### 3. Iterative approach:\\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // condition checking for root nodes\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        if ((p == null && q != null) || (p != null && q == null)) {\\n            return false;\\n        }\\n\\n        Stack<TreeNode> st1 = new Stack<>();\\n        Stack<TreeNode> st2 = new Stack<>();\\n        st1.push(p);\\n        st2.push(q);\\n\\n        while (!st1.empty() && !st2.empty()) {\\n            TreeNode n1 = st1.pop();\\n            TreeNode n2 = st2.pop();\\n\\n            // check if values are equal\\n            if (n1.val != n2.val) {\\n                return false;\\n            }\\n            // condition checking for children nodes\\n            if ((n1.left != null && n2.left == null) || (n1.left == null && n2.left != null)) {\\n                return false;\\n            }\\n            if ((n1.right != null && n2.right == null) || (n1.right == null && n2.right != null)) {\\n                return false;\\n            }\\n\\n            // add the children to the stacks\\n            if (n1.left != null && n2.left != null) {\\n                st1.push(n1.left);\\n                st2.push(n2.left);\\n            }\\n            if (n1.right != null && n2.right != null) {\\n                st1.push(n1.right);\\n                st2.push(n2.right);\\n            }\\n        }\\n\\n        // any dissimilarity if encountered above, would\\'ve returned false already\\n        // no dissimilarity encountered means trees are same, so return true\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "``` java []\\n// do any type of traversal on both the trees and store it in lists\\n// check if the lists are equal\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        List<Integer> pList = new ArrayList<>();\\n        List<Integer> qList = new ArrayList<>();\\n        dfs(p, pList); dfs(q, qList);\\n        return pList.equals(qList);\\n    }\\n\\n    void dfs(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            list.add(null);\\n            return;\\n        }\\n        list.add(root.val);\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n + h)\\n```\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // either one of them is null or both of them is\\n        if (p == null || q == null) {\\n            return p == q;\\n        }\\n        // check if values are equal\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // call the functions for left and right subtrees\\n        boolean left = isSameTree(p.left, q.left);\\n        boolean right = isSameTree(p.right, q.right);\\n        return left && right;   // return what the subtrees return\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // condition checking for root nodes\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        if ((p == null && q != null) || (p != null && q == null)) {\\n            return false;\\n        }\\n\\n        Stack<TreeNode> st1 = new Stack<>();\\n        Stack<TreeNode> st2 = new Stack<>();\\n        st1.push(p);\\n        st2.push(q);\\n\\n        while (!st1.empty() && !st2.empty()) {\\n            TreeNode n1 = st1.pop();\\n            TreeNode n2 = st2.pop();\\n\\n            // check if values are equal\\n            if (n1.val != n2.val) {\\n                return false;\\n            }\\n            // condition checking for children nodes\\n            if ((n1.left != null && n2.left == null) || (n1.left == null && n2.left != null)) {\\n                return false;\\n            }\\n            if ((n1.right != null && n2.right == null) || (n1.right == null && n2.right != null)) {\\n                return false;\\n            }\\n\\n            // add the children to the stacks\\n            if (n1.left != null && n2.left != null) {\\n                st1.push(n1.left);\\n                st2.push(n2.left);\\n            }\\n            if (n1.right != null && n2.right != null) {\\n                st1.push(n1.right);\\n                st2.push(n2.right);\\n            }\\n        }\\n\\n        // any dissimilarity if encountered above, would\\'ve returned false already\\n        // no dissimilarity encountered means trees are same, so return true\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029147,
                "title": "java-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/11922000-a384-41a2-85fb-a6bfedcea97f_1673336288.9135783.png)\\n\\n\\n# Intuition\\nThe problem is straightforward. First, compare both trees\\' root node values with each other, and continue this procedure going right and left.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; // both empty\\n        if(p == null || q == null) return false; // of the the trees empty\\n        if(p.val != q.val) return false; // value equality\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; // both empty\\n        if(p == null || q == null) return false; // of the the trees empty\\n        if(p.val != q.val) return false; // value equality\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027740,
                "title": "c-100-faster-1-liner-solution-must-watch",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return (p==NULL || q==NULL) ? (p==q) : (p->val == q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return (p==NULL || q==NULL) ? (p==q) : (p->val == q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027461,
                "title": "c-solution-in-recursive-and-iterative-approach",
                "content": "## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursive solution.***\\n- If both trees are null, return true\\n- If one tree is null and the other is not, return false\\n- If the values at the roots of the trees are different, return false\\n- Recursively check the left and right subtrees of both trees\\n    - If the left or right subtrees are different, return false\\n- If the function has not yet returned false, return true\\n- **Time complexity:** O(n).\\n- **Space complexity:** O(n).\\n\\n### Solution 02\\n\\n- Using ***Iterative solution.***\\n- Create a stack and push the roots of both trees onto the stack as pairs.\\n- While the stack is not empty:\\n    - Pop a pair of nodes from the stack.\\n    - If both nodes are null, continue.\\n    - If one node is null or the values at the nodes are different, return false.\\n    - Push the left and right children of both nodes onto the stack as pairs.\\n- If the loop completes, return true.\\n- **Time complexity:** O(n).\\n- **Space complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL || q == NULL) return p==q;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL || q == NULL) return p==q;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027352,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* p,TreeNode* q)\\n    {\\n        if(p==NULL||q==NULL)\\n        {\\n            return (p==NULL&&q==NULL);\\n        }\\n        if(p->val==q->val)\\n        {\\n            bool left=isSymmetric(p->left,q->left);\\n            bool right=isSymmetric(p->right,q->right);\\n            return left&&right;\\n        }\\n            return false;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return isSymmetric(p,q);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* p,TreeNode* q)\\n    {\\n        if(p==NULL||q==NULL)\\n        {\\n            return (p==NULL&&q==NULL);\\n        }\\n        if(p->val==q->val)\\n        {\\n            bool left=isSymmetric(p->left,q->left);\\n            bool right=isSymmetric(p->right,q->right);\\n            return left&&right;\\n        }\\n            return false;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return isSymmetric(p,q);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830951,
                "title": "shortest-simplest-c-2-lines",
                "content": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL || q==NULL) return p==q;\\n        return p->val==q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL || q==NULL) return p==q;\\n        return p->val==q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2765177,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726706,
                "title": "python-bt-beginners-solution-easy",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714988,
                "title": "0ms-runtime-easy-3-lines-c-solution",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        // if both nodes are null,then both are technically equal\\n\\n        if ((!p || !q) || p->val != q->val) return false;\\n        // if either of them is null then they aren\\'t equal, or if their values are not equal, we return false\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        // we break the tree into smaller parts ie, trees from the left and right nodes and if either of them returns false, then we know there is a difference in the trees somewhere down there]\\n    }\\n};\\n```\\n*If this code helps please upvote, it motivates to write more solutions to help the community*\\n\\n## My GitHub: https://github.com/crimsonKn1ght",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        // if both nodes are null,then both are technically equal\\n\\n        if ((!p || !q) || p->val != q->val) return false;\\n        // if either of them is null then they aren\\'t equal, or if their values are not equal, we return false\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        // we break the tree into smaller parts ie, trees from the left and right nodes and if either of them returns false, then we know there is a difference in the trees somewhere down there]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690285,
                "title": "stack-queue-approach",
                "content": "**Stack**\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\\n\\n\\n**Queue**\\n\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "solutionTags": [
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656522,
                "title": "o-n-time-and-o-n-space-recursion",
                "content": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p==nil || q==nil{\\n        return p==q\\n    }\\n    \\n    return p.Val==q.Val && isSameTree(p.Left,q.Left) && isSameTree(p.Right,q.Right)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p==nil || q==nil{\\n        return p==q\\n    }\\n    \\n    return p.Val==q.Val && isSameTree(p.Left,q.Left) && isSameTree(p.Right,q.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640564,
                "title": "c-solution-same-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q == NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n        \\n        bool left = isSameTree(p->left , q->left);\\n        bool right = isSameTree(p->right , q->right);\\n        \\n        bool curr = p->val == q->val;\\n        \\n        if(left && right && curr)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q == NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n        \\n        bool left = isSameTree(p->left , q->left);\\n        bool right = isSameTree(p->right , q->right);\\n        \\n        bool curr = p->val == q->val;\\n        \\n        if(left && right && curr)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197519,
                "title": "elixir-a-solution-that-cannot-be-simpler",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec is_same_tree(p :: TreeNode.t | nil, q :: TreeNode.t | nil) :: boolean\\n  def is_same_tree(p, q) do\\n    p == q\\n  end\\nend\\n```\\n\\nWe can do so because in Elixir, everything is immutable, so if two things initially look the same, they\\'ll never become different; if they are initially different, they\\'ll never become the same either. Thus, comparing references is meaningless. So, in Elixir, `==` compares whole data structures.",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec is_same_tree(p :: TreeNode.t | nil, q :: TreeNode.t | nil) :: boolean\\n  def is_same_tree(p, q) do\\n    p == q\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1769465,
                "title": "3-lines-clean-easy-c-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\tif(p==NULL || q==NULL)\\n\\t\\t\\t\\treturn (p==q);\\n\\n\\t\\t\\treturn (p->val == q->val) && isSameTree(p->left ,q->left) && isSameTree(p->right ,q->right);\\n\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\tif(p==NULL || q==NULL)\\n\\t\\t\\t\\treturn (p==q);\\n\\n\\t\\t\\treturn (p->val == q->val) && isSameTree(p->left ,q->left) && isSameTree(p->right ,q->right);\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1393461,
                "title": "bfs-c",
                "content": "\\n**Implementation**\\n\\nTime Complexity = O(N), Space Complexity = O(W) where W is the width of the Binary Tree\\n\\n```\\nbool isSameTree(TreeNode* p, TreeNode* q) {        \\n    \\n    if(p != NULL && q != NULL){\\n        queue<TreeNode*> pq;\\n        queue<TreeNode*> qq;\\n        \\n        pq.push(p);\\n        qq.push(q);\\n        \\n        while(pq.empty() == false && qq.empty() == false){\\n            TreeNode* cur1 = pq.front(); pq.pop();\\n            TreeNode* cur2 = qq.front(); qq.pop();\\n            \\n            if(cur1->val != cur2->val) return false;\\n                                            \\n            if(cur1->left != NULL && cur2->left != NULL) {\\n                pq.push(cur1->left);\\n                qq.push(cur2->left);\\n            }\\n            else if(cur1->left != cur2->left) return false;\\n            \\n            if(cur1->right != NULL && cur2->right != NULL){\\n                pq.push(cur1->right);\\n                qq.push(cur2->right);\\n            }\\n            else if(cur1->right != cur2->right) return false;\\n        }            \\n        if(pq.empty() != qq.empty()) return false;\\n        else return true;\\n    }\\n    else if(q != p) return false; \\n    else return true;\\n}\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {        \\n    \\n    if(p != NULL && q != NULL){\\n        queue<TreeNode*> pq;\\n        queue<TreeNode*> qq;\\n        \\n        pq.push(p);\\n        qq.push(q);\\n        \\n        while(pq.empty() == false && qq.empty() == false){\\n            TreeNode* cur1 = pq.front(); pq.pop();\\n            TreeNode* cur2 = qq.front(); qq.pop();\\n            \\n            if(cur1->val != cur2->val) return false;\\n                                            \\n            if(cur1->left != NULL && cur2->left != NULL) {\\n                pq.push(cur1->left);\\n                qq.push(cur2->left);\\n            }\\n            else if(cur1->left != cur2->left) return false;\\n            \\n            if(cur1->right != NULL && cur2->right != NULL){\\n                pq.push(cur1->right);\\n                qq.push(cur2->right);\\n            }\\n            else if(cur1->right != cur2->right) return false;\\n        }            \\n        if(pq.empty() != qq.empty()) return false;\\n        else return true;\\n    }\\n    else if(q != p) return false; \\n    else return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038971,
                "title": "95-faster-python-3-code-recursive",
                "content": "```\\nif (p==None and q==None):\\n\\treturn True\\n\\nif p and q:\\n\\tif p.val==q.val:\\n\\t\\treturn self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\nelse:\\n\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\nif (p==None and q==None):\\n\\treturn True\\n\\nif p and q:\\n\\tif p.val==q.val:\\n\\t\\treturn self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\nelse:\\n\\treturn False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 956314,
                "title": "java-0-ms-100-faster-queues-iterative-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList();\\n        queue.add(p);\\n        queue.add(q);\\n        while(!queue.isEmpty()){\\n            TreeNode root1 = queue.poll();\\n            TreeNode root2 = queue.poll();\\n            if(root1==null && root2==null) continue;\\n            if(root1==null || root2==null || root1.val!=root2.val) return false;\\n            queue.add(root1.left);\\n            queue.add(root2.left);\\n            queue.add(root1.right);\\n            queue.add(root2.right);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList();\\n        queue.add(p);\\n        queue.add(q);\\n        while(!queue.isEmpty()){\\n            TreeNode root1 = queue.poll();\\n            TreeNode root2 = queue.poll();\\n            if(root1==null && root2==null) continue;\\n            if(root1==null || root2==null || root1.val!=root2.val) return false;\\n            queue.add(root1.left);\\n            queue.add(root2.left);\\n            queue.add(root1.right);\\n            queue.add(root2.right);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796604,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool isSameTree(TreeNode* r1, TreeNode* r2) \\n\\t{\\n        if (r1 == nullptr && r2 == nullptr)\\n            return true;\\n\\t\\t\\t\\n        if ((r1 != nullptr && r2 == nullptr)\\n          || (r1 == nullptr && r2 != nullptr))\\n            return false;\\n\\t\\t\\t\\n        if (r1->val != r2->val)\\n            return false;\\n\\t\\t\\t\\n        return isSameTree(r1->left, r2->left) && isSameTree(r1->right, r2->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isSameTree(TreeNode* r1, TreeNode* r2) \\n\\t{\\n        if (r1 == nullptr && r2 == nullptr)\\n            return true;\\n\\t\\t\\t\\n        if ((r1 != nullptr && r2 == nullptr)\\n          || (r1 == nullptr && r2 != nullptr))\\n            return false;\\n\\t\\t\\t\\n        if (r1->val != r2->val)\\n            return false;\\n\\t\\t\\t\\n        return isSameTree(r1->left, r2->left) && isSameTree(r1->right, r2->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794503,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if ((!p) || (!q))\\n        {\\n            if ((!p) && (!q))\\n                return true;\\n            else return false;\\n        }\\n        if (p->val != q->val)\\n            return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if ((!p) || (!q))\\n        {\\n            if ((!p) && (!q))\\n                return true;\\n            else return false;\\n        }\\n        if (p->val != q->val)\\n            return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765093,
                "title": "esay-understand-of-interative",
                "content": "It is dfs with stack,i think it is very easy to understand,use only one stack can success it ,better than the offical answer\\n```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        LinkedList<TreeNode> queue=new LinkedList<>();\\n        queue.addLast(p);\\n        queue.addLast(q);\\n        while (queue.size()!=0){\\n            TreeNode q2=queue.removeLast();\\n            TreeNode q1=queue.removeLast();\\n            if (q1==null && q2==null) continue;\\n            if (q1==null || q2==null) return false;\\n            if (q1.val!=q2.val) return false;\\n            queue.addLast(q1.left);\\n            queue.addLast(q2.left);\\n            queue.addLast(q1.right);\\n            queue.addLast(q2.right);\\n        }\\n        return true;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        LinkedList<TreeNode> queue=new LinkedList<>();\\n        queue.addLast(p);\\n        queue.addLast(q);\\n        while (queue.size()!=0){\\n            TreeNode q2=queue.removeLast();\\n            TreeNode q1=queue.removeLast();\\n            if (q1==null && q2==null) continue;\\n            if (q1==null || q2==null) return false;\\n            if (q1.val!=q2.val) return false;\\n            queue.addLast(q1.left);\\n            queue.addLast(q2.left);\\n            queue.addLast(q1.right);\\n            queue.addLast(q2.right);\\n        }\\n        return true;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 735223,
                "title": "java-2-lines",
                "content": "```\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == null && q == null;\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == null && q == null;\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345623,
                "title": "go-recursive-solution",
                "content": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t} else if p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t} else {\\n\\t\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t} else if p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t} else {\\n\\t\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234255,
                "title": "go-100-0ms",
                "content": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t}\\n\\tif p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t}\\n\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t}\\n\\tif p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t}\\n\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222099,
                "title": "python-fast-and-simple-solution-both-recursion-and-iterative",
                "content": "### Recursion\\n```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\n\\n### Iterative\\n```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        stack = [(p, q)]\\n        \\n        while stack:\\n            p, q = stack.pop()\\n            \\n            if not p and not q:\\n                continue\\n            if not p or not q or p.val != q.val:\\n                return False\\n            stack.append((p.right, q.right))\\n            stack.append((p.left, q.left))\\n            \\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        stack = [(p, q)]\\n        \\n        while stack:\\n            p, q = stack.pop()\\n            \\n            if not p and not q:\\n                continue\\n            if not p or not q or p.val != q.val:\\n                return False\\n            stack.append((p.right, q.right))\\n            stack.append((p.left, q.left))\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189672,
                "title": "python-clean-iterative-solution",
                "content": "```python\\nclass Solution(object):\\n    def isSameTree(self, head1, head2):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        stack = [(head1, head2)]\\n\\n        while stack:\\n            root1, root2 = stack.pop()\\n            if (root1 and not root2) or (not root1 and root2) or (root1 and root2 and root1.val != root2.val):\\n                return False\\n\\n            if root1 and root2:\\n                stack.append((root1.left, root2.left))\\n                stack.append((root1.right, root2.right))\\n\\n        return True\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isSameTree(self, head1, head2):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        stack = [(head1, head2)]\\n\\n        while stack:\\n            root1, root2 = stack.pop()\\n            if (root1 and not root2) or (not root1 and root2) or (root1 and root2 and root1.val != root2.val):\\n                return False\\n\\n            if root1 and root2:\\n                stack.append((root1.left, root2.left))\\n                stack.append((root1.right, root2.right))\\n\\n        return True\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 181179,
                "title": "simple-python-solution-beats-99-95",
                "content": "```\\ndef isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if p and q:\\n            if p.val != q.val:\\n                return False\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if p and q:\\n            if p.val != q.val:\\n                return False\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161608,
                "title": "python-solution",
                "content": "Iterative:\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        queue = collections.deque([p,q])\\n        while queue:\\n            u1 = queue.popleft()\\n            u2 = queue.popleft()\\n            if u1 == None and u2 != None:\\n                return False\\n            if u1 != None and u2 == None:\\n                return False\\n            if u1 != None and u2 != None:\\n                if u1.val != u2.val:\\n                    return False\\n                else:\\n                    queue.append(u1.left)\\n                    queue.append(u2.left)\\n                    queue.append(u1.right)\\n                    queue.append(u2.right)\\n        return True\\n```\\nRecursive:\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if p == None and q == None:\\n            return True\\n        elif p == None and q != None:\\n            return False\\n        elif p != None and q == None:\\n            return False\\n        else:\\n            if p.val != q.val:\\n                return False\\n            else:\\n                return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        queue = collections.deque([p,q])\\n        while queue:\\n            u1 = queue.popleft()\\n            u2 = queue.popleft()\\n            if u1 == None and u2 != None:\\n                return False\\n            if u1 != None and u2 == None:\\n                return False\\n            if u1 != None and u2 != None:\\n                if u1.val != u2.val:\\n                    return False\\n                else:\\n                    queue.append(u1.left)\\n                    queue.append(u2.left)\\n                    queue.append(u1.right)\\n                    queue.append(u2.right)\\n        return True\\n```\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if p == None and q == None:\\n            return True\\n        elif p == None and q != None:\\n            return False\\n        elif p != None and q == None:\\n            return False\\n        else:\\n            if p.val != q.val:\\n                return False\\n            else:\\n                return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32862,
                "title": "java-0ms-3-line-recursive-solution",
                "content": "    public class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == q) return true;\\n            if ((p == null && q != null) || (p != null && q == null) || (p.val != q.val)) return false;\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == q) return true;\\n            if ((p == null && q != null) || (p != null && q == null) || (p.val != q.val)) return false;\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32940,
                "title": "easy-java-solution",
                "content": "    public class Solution {\\n    \\n    boolean isSame = true;\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        //two nodes are null , return true\\n        if(p==null && q==null)\\n            return true;\\n            \\n            \\n        //one node is null, and the other node is not null, return false    \\n        if(p==null || q==null)\\n            return false;\\n        \\n    \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right) ;\\n        \\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    boolean isSame = true;\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        //two nodes are null , return true\\n        if(p==null && q==null)\\n            return true;\\n            \\n            \\n        //one node is null, and the other node is not null, return false    \\n        if(p==null || q==null)\\n            return false;\\n        \\n    \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right) ;\\n        \\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32867,
                "title": "0-ms-c-solution",
                "content": "    bool isSameTree(struct TreeNode* p, struct TreeNode* q) {\\n    if(p == NULL && q == NULL) \\n        return true;\\n    if(p != NULL && q == NULL) \\n        return false;\\n    if(p == NULL && q != NULL) \\n        return false;\\n    if(p->val != q->val)\\n        return false;\\n    return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }",
                "solutionTags": [],
                "code": "    bool isSameTree(struct TreeNode* p, struct TreeNode* q) {\\n    if(p == NULL && q == NULL) \\n        return true;\\n    if(p != NULL && q == NULL) \\n        return false;\\n    if(p == NULL && q != NULL) \\n        return false;\\n    if(p->val != q->val)\\n        return false;\\n    return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 32972,
                "title": "my-44ms-python-solution",
                "content": "\\n    class Solution:\\n        # @param {TreeNode} p\\n        # @param {TreeNode} q\\n        # @return {boolean}\\n        def isSameTree(self, p, q):\\n            if p==q==None:\\n                return True\\n            if None in [p,q]:\\n                return False\\n            if p.val!=q.val:\\n                return False\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 3885554,
                "title": "simple-optimised-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null)\\n        return true;\\n        if(p!=null&&q!=null)\\n        {\\n            return ( (p.val==q.val)&&(isSameTree(p.left,q.left))&& (isSameTree(p.right,q.right)));\\n        }\\n        return false;\\n      }\\n      \\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null)\\n        return true;\\n        if(p!=null&&q!=null)\\n        {\\n            return ( (p.val==q.val)&&(isSameTree(p.left,q.left))&& (isSameTree(p.right,q.right)));\\n        }\\n        return false;\\n      }\\n      \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808320,
                "title": "simplest-python-recursive-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q:\\n            return False\\n        if p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q:\\n            return False\\n        if p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483195,
                "title": "java-solution",
                "content": "Follow the given steps to solve the problem:\\n\\n    - If both trees are empty then return 1(Base case)\\n    - Else If both trees are non-empty\\n    - Check data of the root nodes (tree1->data ==  tree2->data)\\n    - Check left subtrees recursively\\n    - Check right subtrees recursively\\n    - If the above three statements are true then return 1\\n    - Else return 0 (one is empty and the other is not)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391761,
                "title": "pyhton3-dfs-recursion",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363285,
                "title": "this-java-solution-beats-everyone",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H) where h is height of the tree\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/1b42ccef-6f00-4aa8-9c48-986edd079a88_1680286752.4062045.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       \\n       // If both trees are empty, return true\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        // If one of the trees is empty and the other is not, return false\\n        if(p == null || q == null){\\n            return false;\\n        }\\n\\n        // If the values at the current nodes of the two trees are different, return false\\n        if(p.val != q.val){\\n            return false;\\n        }\\n\\n        // Recursively compare the left and right subtrees of the two trees\\n        // If both subtrees are the same, the two trees are the same\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       \\n       // If both trees are empty, return true\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        // If one of the trees is empty and the other is not, return false\\n        if(p == null || q == null){\\n            return false;\\n        }\\n\\n        // If the values at the current nodes of the two trees are different, return false\\n        if(p.val != q.val){\\n            return false;\\n        }\\n\\n        // Recursively compare the left and right subtrees of the two trees\\n        // If both subtrees are the same, the two trees are the same\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217719,
                "title": "best-o-n-solution",
                "content": "# Approach\\nWe can use any traversal.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL)\\n            return true;\\n        if (p == NULL || q == NULL)\\n            return false;\\n        if (p->val != q->val)\\n            return false;\\n        bool l = isSameTree(p->left, q->left); \\n        bool r = isSameTree(p->right, q->right);\\n        if (l != true || r != true)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL)\\n            return true;\\n        if (p == NULL || q == NULL)\\n            return false;\\n        if (p->val != q->val)\\n            return false;\\n        bool l = isSameTree(p->left, q->left); \\n        bool r = isSameTree(p->right, q->right);\\n        if (l != true || r != true)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030043,
                "title": "python-easy-to-unserstand-well-explained",
                "content": "# Intuition\\nTo recursively check for the structural and value similarity between each node of both trees\\n\\n# Approach\\nDepth-first search (DFS) traversal\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(n)        \\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # if both trees are None, return True\\n        if not p and not q:\\n            return True\\n        # if one tree is None and the other is not, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the current nodes are not the same, return False\\n        if p.val != q.val:\\n            return False\\n        # recursively check the left and right subtrees\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # if both trees are None, return True\\n        if not p and not q:\\n            return True\\n        # if one tree is None and the other is not, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the current nodes are not the same, return False\\n        if p.val != q.val:\\n            return False\\n        # recursively check the left and right subtrees\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028642,
                "title": "c-easy-solution-with-two-easy-approch",
                "content": "# Intuition\\nSo Main Intution of this Question is just we have to check for each node in both the tree if node has same value then check for left subtree and right subtree and all nodes have same value with other tree so return 1 else return 0.\\n\\n# Approach\\nFor this Question we have a two approch.\\n1) First just check a node for both tree and compare its value if the value is same so go for left and right subtree for that purpose we can use any traversal method.\\n2) and in second approch just do any one traversal in both tree and store in a vector and at the end just compare two vector if that vector is same so bothe the tree is same otherwise not.\\n\\n# Complexity\\n- Time complexity:\\n\\n1) O(N) where N is number of node.\\n2) 2O(N) N is number of node.\\n\\n- Space complexity:\\n1) only auxilary stack space\\n2) O(N)+ auxilary stack space\\n\\n# Code\\n```\\nThis is first approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nbool checkforsame(TreeNode *p,TreeNode *q)\\n{\\n    int checkl=0,checkr=0;\\n    if(p==NULL&&q==NULL)\\n    {\\n        return 1;\\n    }\\n    if(p==NULL&&q!=NULL)return 0;\\n    if(p!=NULL&&q==NULL)return 0;\\n    if(p->val==q->val)\\n    {\\n        checkl=checkforsame(p->left,q->left);\\n        checkr=checkforsame(p->right,q->right);\\n\\n    }\\n    else return 0;\\n    return checkl&&checkr;\\n\\n\\n}\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return checkforsame(p,q);\\n        \\n    }\\n};\\n```\\n\\n# code\\n```\\nsecond Approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(vector<int> &res,TreeNode *root)\\n    {\\n       if(root==NULL){\\n           res.push_back(-1);\\n           return;\\n       }\\n        res.push_back(root->val);\\n        solve(res,root->left);\\n        solve(res,root->right);\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int> res1;\\n        vector<int> res2;\\n        solve(res1,p);\\n        solve(res2,q);\\n        if(res1.size()!=res2.size())return false;\\n        for(int i=0;i<res1.size();i++)\\n        {\\n            if(res1[i]!=res2[i])\\n            {\\n                return false;\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nThis is first approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nbool checkforsame(TreeNode *p,TreeNode *q)\\n{\\n    int checkl=0,checkr=0;\\n    if(p==NULL&&q==NULL)\\n    {\\n        return 1;\\n    }\\n    if(p==NULL&&q!=NULL)return 0;\\n    if(p!=NULL&&q==NULL)return 0;\\n    if(p->val==q->val)\\n    {\\n        checkl=checkforsame(p->left,q->left);\\n        checkr=checkforsame(p->right,q->right);\\n\\n    }\\n    else return 0;\\n    return checkl&&checkr;\\n\\n\\n}\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return checkforsame(p,q);\\n        \\n    }\\n};\\n```\n```\\nsecond Approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(vector<int> &res,TreeNode *root)\\n    {\\n       if(root==NULL){\\n           res.push_back(-1);\\n           return;\\n       }\\n        res.push_back(root->val);\\n        solve(res,root->left);\\n        solve(res,root->right);\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int> res1;\\n        vector<int> res2;\\n        solve(res1,p);\\n        solve(res2,q);\\n        if(res1.size()!=res2.size())return false;\\n        for(int i=0;i<res1.size();i++)\\n        {\\n            if(res1[i]!=res2[i])\\n            {\\n                return false;\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028358,
                "title": "3-js-solutions",
                "content": "\\n# Code BFS\\n```\\nvar isSameTree = function (p, q) {\\n  const stk = [p, q];\\n  while (stk.length) {\\n    const n1 = stk.pop(), n2 = stk.pop();\\n    if (!n1 && !n2) continue;\\n    if (!n1 || !n2 || n1.val !== n2.val) return false;\\n    stk.push(n1.left, n2.left, n1.right, n2.right);\\n  }\\n  return true;\\n};\\n\\n```\\n\\n# Code DFS\\n```\\nvar isSameTree = function (p, q) {\\n  if (!p && !q) return true;\\n  if ((p && !q) || (q && !p) || p.val !== q.val) return false;\\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n\\n```\\n\\n# Code JSON\\n```\\nvar isSameTree = function (p, q) {\\n  return JSON.stringify(p) === JSON.stringify(q)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSameTree = function (p, q) {\\n  const stk = [p, q];\\n  while (stk.length) {\\n    const n1 = stk.pop(), n2 = stk.pop();\\n    if (!n1 && !n2) continue;\\n    if (!n1 || !n2 || n1.val !== n2.val) return false;\\n    stk.push(n1.left, n2.left, n1.right, n2.right);\\n  }\\n  return true;\\n};\\n\\n```\n```\\nvar isSameTree = function (p, q) {\\n  if (!p && !q) return true;\\n  if ((p && !q) || (q && !p) || p.val !== q.val) return false;\\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n\\n```\n```\\nvar isSameTree = function (p, q) {\\n  return JSON.stringify(p) === JSON.stringify(q)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3028273,
                "title": "efficiently-comparing-structurally-identical-binary-trees-o-n-time",
                "content": "The function takes two TreeNode objects as input, p and q. It first checks if p and q are the same object (i.e., if they are both null or if they are the same instance). If they are, it returns true. If either p or q is null, it returns false. If the values of p and q are different, it also returns false. If none of these conditions are true, it recursively checks if the left and right subtrees of p and q are the same.\\n\\n# Approach\\nRecursion\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsSameTree(TreeNode p, TreeNode q) {\\n        if (p == q) return true;\\n        if (p == null || q == null) return false;\\n        if (p.val != q.val) return false;\\n        return IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsSameTree(TreeNode p, TreeNode q) {\\n        if (p == q) return true;\\n        if (p == null || q == null) return false;\\n        if (p.val != q.val) return false;\\n        return IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028256,
                "title": "simple-approach-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat should be true for them to be same???\\n(1) Value of root should be same \\n(2) Left subtree should also be same \\n(3) Same for the right subtree\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None or q == None:\\n            return p == q\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None or q == None:\\n            return p == q\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028165,
                "title": "solved-using-pre-order-traversal-python3-solutiont",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf I Traverse through both trees and develop a list of their values, Then if the list of both the trees is same, then  those two trees will be Same\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe apply inorder Traversal through the tree, and store the values in the seperate lists for both the trees, Note, when an intermediate tree node has Null value we store `-` in the list to differentiate between the empty node. At the end we compare two list so obtained and return True if the lists are same or else False..\\nHope it helps!!\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef preorder_list(root):\\n    global ans\\n    ans =[]\\n    def preorder(root):\\n        if root:    \\n            ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        else:\\n            ans.append(\\'-\\')\\n    preorder(root)\\n    return ans\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n        x = preorder_list(p)\\n        y = preorder_list(q)      \\n        return x == y\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef preorder_list(root):\\n    global ans\\n    ans =[]\\n    def preorder(root):\\n        if root:    \\n            ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        else:\\n            ans.append(\\'-\\')\\n    preorder(root)\\n    return ans\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n        x = preorder_list(p)\\n        y = preorder_list(q)      \\n        return x == y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028020,
                "title": "c-short-code",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL||q==NULL)\\n        {\\n            return p==q;\\n        }\\n        return (p->val==q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL||q==NULL)\\n        {\\n            return p==q;\\n        }\\n        return (p->val==q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027663,
                "title": "c-recursion-approach-with-explanation",
                "content": "# Intuition\\n- Recursion\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- The idea is to traverse both trees and compare values at their root node. If the value matches, recursively check if the first tree\\u2019s left subtree is identical to the left subtree of the second tree and the right subtree of the first tree is identical to the right subtree of the second tree. If the value at their root node differs, the trees violate data property. If at any point in the recursion, the first tree is empty and the second tree is non-empty, or the second tree is empty and the first tree is non-empty, the trees violate structural property, and they cannot be identical.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(min(n,m))$$\\n   - Where n & m are the size of tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(log (min(n, m)))$$\\n   - Due to auxiliary stack space used by recursion calls\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n\\n        // Base cases:\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n\\n        // recursion to check left & right subtrees\\n        bool Left=isSameTree(p->left,q->left);\\n        bool Right=isSameTree(p->right,q->right);\\n\\n        bool ans=p->val==q->val;\\n\\n        if(Left && Right && ans)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n\\n        // Base cases:\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n\\n        // recursion to check left & right subtrees\\n        bool Left=isSameTree(p->left,q->left);\\n        bool Right=isSameTree(p->right,q->right);\\n\\n        bool ans=p->val==q->val;\\n\\n        if(Left && Right && ans)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027484,
                "title": "java-iterative-recursive-0-ms-beats-100-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We just have to traverse through the trees and just check whether at every instance \\n    1. If the current node of `p` is null then so must be the current node of `q`\\n    2. If any one of them is null and not both then we return false\\n    3. If the values of current nodes don\\'t match we return false\\n    4. If we successfully traversed both the tree without hitting any roadblocks mentioned above we return true.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- One possible approach is recursion, by traversing through the depth of the tree. Use the points mentioned in the intuition section to build the base case.\\n- For Iterative appraoch, we can use Breadth-First-Search. Even for BFS we keep in mind the 4 steps mentioned above.\\n\\n\\n# Code\\n\\n### Recursive\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null || (p.val != q.val)) return false;\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```\\n\\n### Iterative\\n\\n``` \\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if((p == null && q != null) || (p != null && q == null)) return false;\\n\\n        Queue<TreeNode> tq1 = new LinkedList<>();\\n        Queue<TreeNode> tq2 = new LinkedList<>();\\n\\n        if(p!= null) tq1.offer(p);\\n        if(q!= null) tq2.offer(q);\\n\\n        while(!tq1.isEmpty() && !tq2.isEmpty()){\\n             TreeNode temp1 = tq1.poll();\\n             TreeNode temp2 = tq2.poll();\\n\\n             if(temp1.val != temp2.val) return false;\\n\\n             if(temp1.left != null && temp2.left != null){\\n                 tq1.offer(temp1.left);\\n                 tq2.offer(temp2.left);\\n             }\\n             else if((temp1.left == null && temp2.left != null) || (temp1.left != null && temp2.left == null)) return false;\\n\\n             if(temp1.right != null && temp2.right != null){\\n                 tq1.offer(temp1.right);\\n                 tq2.offer(temp2.right);\\n             }\\n             else if((temp1.right == null && temp2.right != null) || (temp1.right != null && temp2.right == null)) return false;\\n\\n         }\\n         return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null || (p.val != q.val)) return false;\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```\n``` \\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if((p == null && q != null) || (p != null && q == null)) return false;\\n\\n        Queue<TreeNode> tq1 = new LinkedList<>();\\n        Queue<TreeNode> tq2 = new LinkedList<>();\\n\\n        if(p!= null) tq1.offer(p);\\n        if(q!= null) tq2.offer(q);\\n\\n        while(!tq1.isEmpty() && !tq2.isEmpty()){\\n             TreeNode temp1 = tq1.poll();\\n             TreeNode temp2 = tq2.poll();\\n\\n             if(temp1.val != temp2.val) return false;\\n\\n             if(temp1.left != null && temp2.left != null){\\n                 tq1.offer(temp1.left);\\n                 tq2.offer(temp2.left);\\n             }\\n             else if((temp1.left == null && temp2.left != null) || (temp1.left != null && temp2.left == null)) return false;\\n\\n             if(temp1.right != null && temp2.right != null){\\n                 tq1.offer(temp1.right);\\n                 tq2.offer(temp2.right);\\n             }\\n             else if((temp1.right == null && temp2.right != null) || (temp1.right != null && temp2.right == null)) return false;\\n\\n         }\\n         return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027375,
                "title": "c-easy-to-understand-best-and-easiest-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;     // case 1\\n        }\\n        else if(p && q== NULL || q && p== NULL)\\n        {\\n            return false;   //case2\\n        }\\n        \\n        else{\\n            if(p->val == q->val)  //when both value is equal\\n            {\\n                if(isSameTree(p->left,q->left) && isSameTree(p->right, q->right))    //recursively call for left and right for both tree\\n                {\\n                    return true;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;     // case 1\\n        }\\n        else if(p && q== NULL || q && p== NULL)\\n        {\\n            return false;   //case2\\n        }\\n        \\n        else{\\n            if(p->val == q->val)  //when both value is equal\\n            {\\n                if(isSameTree(p->left,q->left) && isSameTree(p->right, q->right))    //recursively call for left and right for both tree\\n                {\\n                    return true;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027351,
                "title": "daily-leetcoding-challenge-january-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/same-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/same-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2812678,
                "title": "the-same-tree",
                "content": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n\\n        def is_same(p,q):\\n            if not p and not q:\\n                return True\\n            if not p or not q:\\n                return False\\n            return is_same(p.left,q.left) and p.val == q.val and is_same(p.right, q.right)\\n        return is_same(p,q)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n\\n        def is_same(p,q):\\n            if not p and not q:\\n                return True\\n            if not p or not q:\\n                return False\\n            return is_same(p.left,q.left) and p.val == q.val and is_same(p.right, q.right)\\n        return is_same(p,q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754146,
                "title": "very-easy-java-solution-0ms-100-faster-5lines-of-code",
                "content": "**very simplified solution for same tree**\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\t\\t   public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\t\\t\\t\\tif(p==null && q==null) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(p==null||q==null || p.val!=q.val) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t\\t   public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\t\\t\\t\\tif(p==null && q==null) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2747446,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\n\\n``` \\nvar isSameTree = function(p, q) {\\n\\t// A FLAG VARIABLE TO KEEP TRACK OF IF THE TREES ARE SAME OR NOT\\n    let isSame = true;\\n    \\n\\t// IF THE ROOT NODES ARE BOTH NULL THEN THEY\\'RE THE SAME TREE\\n    if (!p && !q) {\\n        return true;\\n    }\\n    \\n\\t// IF EITHER OF THE ROOT NODES ARE NULL AND THE OTHER ISNT, THEN THEY\\'RE NOT THE SAME TREE\\n    if ((p && !q) || (!p && q)) {\\n        return false;\\n    }\\n    \\n\\t// HELPER TRAVERSAL FUNCTION FOR DEPTH FIRST SEARCH\\n\\t// TAKES IN THE NODES FROM BOTH TREES AS PARAMETERS\\n    let traverse = (a, b) => {\\n\\t\\n\\t\\t// IF THE TWO NODES VALUES ARE NOT THE SAME, THEN THEY\\'RE NOT THE SAME TREE\\n        if (a.val !== b.val) {\\n            isSame = false;\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE LEFT NODES, RUN HELPER FUNCTION\\n        if (a.left && b.left) {\\n            traverse(a.left, b.left)\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE RIGHT NODES, RUN HELPER FUNCTION\\n        if (a.right && b.right) {\\n            traverse(a.right, b.right)\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A LEFT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.left && !b.left) || (!a.left && b.left)) {\\n            isSame = false\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A RIGHT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.right && !b.right) || (!a.right && b.right)) {\\n            isSame = false;\\n        }\\n    }\\n    \\n\\t// INVOKE THE HELPER FUNCTION WITH THE ROOT NODES\\n    traverse(p, q)\\n    \\n    return isSame;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "``` \\nvar isSameTree = function(p, q) {\\n\\t// A FLAG VARIABLE TO KEEP TRACK OF IF THE TREES ARE SAME OR NOT\\n    let isSame = true;\\n    \\n\\t// IF THE ROOT NODES ARE BOTH NULL THEN THEY\\'RE THE SAME TREE\\n    if (!p && !q) {\\n        return true;\\n    }\\n    \\n\\t// IF EITHER OF THE ROOT NODES ARE NULL AND THE OTHER ISNT, THEN THEY\\'RE NOT THE SAME TREE\\n    if ((p && !q) || (!p && q)) {\\n        return false;\\n    }\\n    \\n\\t// HELPER TRAVERSAL FUNCTION FOR DEPTH FIRST SEARCH\\n\\t// TAKES IN THE NODES FROM BOTH TREES AS PARAMETERS\\n    let traverse = (a, b) => {\\n\\t\\n\\t\\t// IF THE TWO NODES VALUES ARE NOT THE SAME, THEN THEY\\'RE NOT THE SAME TREE\\n        if (a.val !== b.val) {\\n            isSame = false;\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE LEFT NODES, RUN HELPER FUNCTION\\n        if (a.left && b.left) {\\n            traverse(a.left, b.left)\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE RIGHT NODES, RUN HELPER FUNCTION\\n        if (a.right && b.right) {\\n            traverse(a.right, b.right)\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A LEFT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.left && !b.left) || (!a.left && b.left)) {\\n            isSame = false\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A RIGHT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.right && !b.right) || (!a.right && b.right)) {\\n            isSame = false;\\n        }\\n    }\\n    \\n\\t// INVOKE THE HELPER FUNCTION WITH THE ROOT NODES\\n    traverse(p, q)\\n    \\n    return isSame;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2698286,
                "title": "java-single-line-code-runtime-0-ms",
                "content": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q==null){\\n            return true;\\n        }   \\n        if(p==null || q==null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q==null){\\n            return true;\\n        }   \\n        if(p==null || q==null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377267,
                "title": "c-bfs-esay-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n\\n    \\n    bool isSameTree(TreeNode* root1, TreeNode* root2) {\\n        \\n        queue<TreeNode*> q1;\\n        queue<TreeNode*> q2;\\n        \\n        q1.push(root1);\\n        q2.push(root2);\\n        \\n        while(!q1.empty() and !q2.empty()){\\n            \\n            auto node1 = q1.front();\\n            auto node2 = q2.front();\\n            q1.pop();\\n            q2.pop();\\n            \\n            if(node1 == NULL or node2 == NULL){\\n                if(node1 != node2) return false;\\n                continue;\\n            }\\n            \\n            if(node1->val != node2->val) return false;\\n            \\n            q1.push(node1->left);\\n            q1.push(node1->right);\\n            \\n            q2.push(node2->left);\\n            q2.push(node2->right);\\n            \\n        }\\n        \\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    \\n    bool isSameTree(TreeNode* root1, TreeNode* root2) {\\n        \\n        queue<TreeNode*> q1;\\n        queue<TreeNode*> q2;\\n        \\n        q1.push(root1);\\n        q2.push(root2);\\n        \\n        while(!q1.empty() and !q2.empty()){\\n            \\n            auto node1 = q1.front();\\n            auto node2 = q2.front();\\n            q1.pop();\\n            q2.pop();\\n            \\n            if(node1 == NULL or node2 == NULL){\\n                if(node1 != node2) return false;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2250107,
                "title": "c-simple-and-clean-solution",
                "content": "**Please Upvote if it helped you \\nHappy Coding :)**\\n```\\n bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL || q==NULL)\\n            return false;\\n        if(p->val != q->val)\\n            return false;\\n        return isSameTree(p->left,q->left) && isSameTree( p->right, q->right);\\n    }\\n```\\t",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL || q==NULL)\\n            return false;\\n        if(p->val != q->val)\\n            return false;\\n        return isSameTree(p->left,q->left) && isSameTree( p->right, q->right);\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1750693,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574703,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722899,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568922,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1575136,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568923,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849628,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574744,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576370,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1751506,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1750693,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574703,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722899,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568922,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1575136,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568923,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849628,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574744,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576370,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1751506,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1751251,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1750475,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1574051,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1575533,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1571213,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2056465,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2035545,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2034620,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2032553,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2017649,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1950698,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1920118,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1914194,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1911901,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1888531,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1873892,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1833960,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1801300,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1793045,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1783411,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1778166,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1768687,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1753213,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752974,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752507,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752124,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751778,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751329,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751191,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751137,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751123,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751121,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751090,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751067,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751003,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750994,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750940,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750912,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750873,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750872,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750863,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750853,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750781,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750710,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750704,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750662,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750655,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750631,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750572,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750559,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750533,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750512,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750508,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750501,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750489,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750472,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750432,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750386,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750384,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750380,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1742029,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1734679,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1732046,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1728203,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1714471,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1713647,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1710568,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1697147,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1676250,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1675088,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            }
        ]
    }
]